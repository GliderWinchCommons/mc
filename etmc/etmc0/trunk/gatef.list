
gatef.elf:     file format elf32-littlearm


Disassembly of section .text:

08000188 <incIdx>:
#define CANBUSBUFSIZE	64	// Number of incoming CAN msgs to buffer
static struct CANRCVBUF canbuf[CANBUSBUFSIZE];
static u32 canmsgct[CANBUSBUFSIZE]; // Msg seq number for CAN-to-PC.
static int canbufidxi = 0;	// Incoming index into canbuf
static int canbufidxm = 0;	// Outgoing index into canbuf
static int incIdx(int x){x += 1; if (x >= CANBUSBUFSIZE) x = 0; return x;} 
 8000188:	3001      	adds	r0, #1
 800018a:	283f      	cmp	r0, #63	; 0x3f
 800018c:	bfc8      	it	gt
 800018e:	2000      	movgt	r0, #0
 8000190:	4770      	bx	lr

08000192 <canbuf_add>:
 * static void canbuf_add(struct CANRCVBUF* p);
 * @brief	: Add msg to buffer
 * @param	: p = Pointer to CAN msg
 * ************************************************************************************** */
static void canbuf_add(struct CANRCVBUF* p)
{
 8000192:	b570      	push	{r4, r5, r6, lr}
	int temp;
	canbuf[canbufidxi] = *p;		// Copy struct
 8000194:	4c0f      	ldr	r4, [pc, #60]	; (80001d4 <canbuf_add+0x42>)
 8000196:	c80f      	ldmia	r0, {r0, r1, r2, r3}
 8000198:	6826      	ldr	r6, [r4, #0]
 800019a:	eb04 1506 	add.w	r5, r4, r6, lsl #4
 800019e:	3508      	adds	r5, #8
 80001a0:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
	canmsgct[canbufidxi] = canmsgctr;	// Save sequence count that goes with this msg
 80001a4:	f894 3408 	ldrb.w	r3, [r4, #1032]	; 0x408
 80001a8:	eb04 0286 	add.w	r2, r4, r6, lsl #2
	canmsgctr += 1;				// Count incoming CAN msgs
	temp = incIdx(canbufidxi);		// Increment the index for incoming msgs.
 80001ac:	4630      	mov	r0, r6
 * ************************************************************************************** */
static void canbuf_add(struct CANRCVBUF* p)
{
	int temp;
	canbuf[canbufidxi] = *p;		// Copy struct
	canmsgct[canbufidxi] = canmsgctr;	// Save sequence count that goes with this msg
 80001ae:	f8c2 340c 	str.w	r3, [r2, #1036]	; 0x40c
	canmsgctr += 1;				// Count incoming CAN msgs
 80001b2:	3301      	adds	r3, #1
 80001b4:	f884 3408 	strb.w	r3, [r4, #1032]	; 0x408
	temp = incIdx(canbufidxi);		// Increment the index for incoming msgs.
 80001b8:	f7ff ffe6 	bl	8000188 <incIdx>
	if (canbufidxm == temp)  		// Did this last fill the last one?
 80001bc:	f8d4 350c 	ldr.w	r3, [r4, #1292]	; 0x50c
 80001c0:	4283      	cmp	r3, r0
 80001c2:	d105      	bne.n	80001d0 <canbuf_add+0x3e>
	{ // Yes, we have filled the buffer.  This CAN msg might be dropped (by not advancing the index)
		Errors_misc(-1);		// Add to buffer overrun counter
 80001c4:	f04f 30ff 	mov.w	r0, #4294967295
	else
	{ // Here, there is room in the buffer and we are good to go.
		canbufidxi = temp;		// Update the index to next buffer position.
	}	
	return;
}
 80001c8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	canmsgct[canbufidxi] = canmsgctr;	// Save sequence count that goes with this msg
	canmsgctr += 1;				// Count incoming CAN msgs
	temp = incIdx(canbufidxi);		// Increment the index for incoming msgs.
	if (canbufidxm == temp)  		// Did this last fill the last one?
	{ // Yes, we have filled the buffer.  This CAN msg might be dropped (by not advancing the index)
		Errors_misc(-1);		// Add to buffer overrun counter
 80001cc:	f000 bdc8 	b.w	8000d60 <Errors_misc>
	}
	else
	{ // Here, there is room in the buffer and we are good to go.
		canbufidxi = temp;		// Update the index to next buffer position.
 80001d0:	6020      	str	r0, [r4, #0]
	}	
	return;
}
 80001d2:	bd70      	pop	{r4, r5, r6, pc}
 80001d4:	200007f8 	.word	0x200007f8

080001d8 <Default_Handler08>:
float outputTorque = 0.0;

/* --------------- For debugging...(usb) ------------------------------ */
int Default_HandlerCode = 999;
u32 DH08;
void Default_Handler08(void) {DH08 += 1; return;}
 80001d8:	4b02      	ldr	r3, [pc, #8]	; (80001e4 <Default_Handler08+0xc>)
 80001da:	681a      	ldr	r2, [r3, #0]
 80001dc:	3201      	adds	r2, #1
 80001de:	601a      	str	r2, [r3, #0]
 80001e0:	4770      	bx	lr
 80001e2:	bf00      	nop
 80001e4:	200019e0 	.word	0x200019e0

080001e8 <Default_Handler76>:

void OTG_FS_IRQHandler(void);
void Default_Handler76(void) {	OTG_FS_IRQHandler(); return; }
 80001e8:	f000 bdf0 	b.w	8000dcc <OTG_FS_IRQHandler>

080001ec <Default_Handler00>:

void Default_Handler00(void) { Default_HandlerCode =  0; panic_leds(5); }
 80001ec:	4b02      	ldr	r3, [pc, #8]	; (80001f8 <Default_Handler00+0xc>)
 80001ee:	2200      	movs	r2, #0
 80001f0:	2005      	movs	r0, #5
 80001f2:	601a      	str	r2, [r3, #0]
 80001f4:	f004 bdbf 	b.w	8004d76 <panic_leds>
 80001f8:	20000000 	.word	0x20000000

080001fc <Default_Handler01>:
void Default_Handler01(void) { Default_HandlerCode =  1; panic_leds(5); }
 80001fc:	4b02      	ldr	r3, [pc, #8]	; (8000208 <Default_Handler01+0xc>)
 80001fe:	2201      	movs	r2, #1
 8000200:	2005      	movs	r0, #5
 8000202:	601a      	str	r2, [r3, #0]
 8000204:	f004 bdb7 	b.w	8004d76 <panic_leds>
 8000208:	20000000 	.word	0x20000000

0800020c <Default_Handler02>:
void Default_Handler02(void) { Default_HandlerCode =  2; panic_leds(5); }
 800020c:	4b02      	ldr	r3, [pc, #8]	; (8000218 <Default_Handler02+0xc>)
 800020e:	2202      	movs	r2, #2
 8000210:	2005      	movs	r0, #5
 8000212:	601a      	str	r2, [r3, #0]
 8000214:	f004 bdaf 	b.w	8004d76 <panic_leds>
 8000218:	20000000 	.word	0x20000000

0800021c <Default_Handler03>:
void Default_Handler03(void) { Default_HandlerCode =  3; panic_leds(5); }
 800021c:	4b02      	ldr	r3, [pc, #8]	; (8000228 <Default_Handler03+0xc>)
 800021e:	2203      	movs	r2, #3
 8000220:	2005      	movs	r0, #5
 8000222:	601a      	str	r2, [r3, #0]
 8000224:	f004 bda7 	b.w	8004d76 <panic_leds>
 8000228:	20000000 	.word	0x20000000

0800022c <Default_Handler04>:
void Default_Handler04(void) { Default_HandlerCode =  4; panic_leds(5); }
 800022c:	4b02      	ldr	r3, [pc, #8]	; (8000238 <Default_Handler04+0xc>)
 800022e:	2204      	movs	r2, #4
 8000230:	2005      	movs	r0, #5
 8000232:	601a      	str	r2, [r3, #0]
 8000234:	f004 bd9f 	b.w	8004d76 <panic_leds>
 8000238:	20000000 	.word	0x20000000

0800023c <Default_Handler05>:
void Default_Handler05(void) { Default_HandlerCode =  5; panic_leds(5); }
 800023c:	4b02      	ldr	r3, [pc, #8]	; (8000248 <Default_Handler05+0xc>)
 800023e:	2005      	movs	r0, #5
 8000240:	6018      	str	r0, [r3, #0]
 8000242:	f004 bd98 	b.w	8004d76 <panic_leds>
 8000246:	bf00      	nop
 8000248:	20000000 	.word	0x20000000

0800024c <Default_Handler06>:
void Default_Handler06(void) { Default_HandlerCode =  6; panic_leds(5); }
 800024c:	4b02      	ldr	r3, [pc, #8]	; (8000258 <Default_Handler06+0xc>)
 800024e:	2206      	movs	r2, #6
 8000250:	2005      	movs	r0, #5
 8000252:	601a      	str	r2, [r3, #0]
 8000254:	f004 bd8f 	b.w	8004d76 <panic_leds>
 8000258:	20000000 	.word	0x20000000

0800025c <Default_Handler07>:
void Default_Handler07(void) { Default_HandlerCode =  7; panic_leds(5); }
 800025c:	4b02      	ldr	r3, [pc, #8]	; (8000268 <Default_Handler07+0xc>)
 800025e:	2207      	movs	r2, #7
 8000260:	2005      	movs	r0, #5
 8000262:	601a      	str	r2, [r3, #0]
 8000264:	f004 bd87 	b.w	8004d76 <panic_leds>
 8000268:	20000000 	.word	0x20000000

0800026c <Default_Handler09>:
//void Default_Handler08(void) { Default_HandlerCode =  8; panic_leds(5); }
void Default_Handler09(void) { Default_HandlerCode =  9; panic_leds(5); }
 800026c:	4b02      	ldr	r3, [pc, #8]	; (8000278 <Default_Handler09+0xc>)
 800026e:	2209      	movs	r2, #9
 8000270:	2005      	movs	r0, #5
 8000272:	601a      	str	r2, [r3, #0]
 8000274:	f004 bd7f 	b.w	8004d76 <panic_leds>
 8000278:	20000000 	.word	0x20000000

0800027c <Default_Handler10>:
void Default_Handler10(void) { Default_HandlerCode = 10; panic_leds(5); }
 800027c:	4b02      	ldr	r3, [pc, #8]	; (8000288 <Default_Handler10+0xc>)
 800027e:	220a      	movs	r2, #10
 8000280:	2005      	movs	r0, #5
 8000282:	601a      	str	r2, [r3, #0]
 8000284:	f004 bd77 	b.w	8004d76 <panic_leds>
 8000288:	20000000 	.word	0x20000000

0800028c <Default_Handler11>:
void Default_Handler11(void) { Default_HandlerCode = 11; panic_leds(5); }
 800028c:	4b02      	ldr	r3, [pc, #8]	; (8000298 <Default_Handler11+0xc>)
 800028e:	220b      	movs	r2, #11
 8000290:	2005      	movs	r0, #5
 8000292:	601a      	str	r2, [r3, #0]
 8000294:	f004 bd6f 	b.w	8004d76 <panic_leds>
 8000298:	20000000 	.word	0x20000000

0800029c <Default_Handler12>:
void Default_Handler12(void) { Default_HandlerCode = 12; panic_leds(5); }
 800029c:	4b02      	ldr	r3, [pc, #8]	; (80002a8 <Default_Handler12+0xc>)
 800029e:	220c      	movs	r2, #12
 80002a0:	2005      	movs	r0, #5
 80002a2:	601a      	str	r2, [r3, #0]
 80002a4:	f004 bd67 	b.w	8004d76 <panic_leds>
 80002a8:	20000000 	.word	0x20000000

080002ac <Default_Handler13>:
void Default_Handler13(void) { Default_HandlerCode = 13; panic_leds(5); }
 80002ac:	4b02      	ldr	r3, [pc, #8]	; (80002b8 <Default_Handler13+0xc>)
 80002ae:	220d      	movs	r2, #13
 80002b0:	2005      	movs	r0, #5
 80002b2:	601a      	str	r2, [r3, #0]
 80002b4:	f004 bd5f 	b.w	8004d76 <panic_leds>
 80002b8:	20000000 	.word	0x20000000

080002bc <Default_Handler14>:
void Default_Handler14(void) { Default_HandlerCode = 14; panic_leds(5); }
 80002bc:	4b02      	ldr	r3, [pc, #8]	; (80002c8 <Default_Handler14+0xc>)
 80002be:	220e      	movs	r2, #14
 80002c0:	2005      	movs	r0, #5
 80002c2:	601a      	str	r2, [r3, #0]
 80002c4:	f004 bd57 	b.w	8004d76 <panic_leds>
 80002c8:	20000000 	.word	0x20000000

080002cc <Default_Handler15>:
void Default_Handler15(void) { Default_HandlerCode = 15; panic_leds(5); }
 80002cc:	4b02      	ldr	r3, [pc, #8]	; (80002d8 <Default_Handler15+0xc>)
 80002ce:	220f      	movs	r2, #15
 80002d0:	2005      	movs	r0, #5
 80002d2:	601a      	str	r2, [r3, #0]
 80002d4:	f004 bd4f 	b.w	8004d76 <panic_leds>
 80002d8:	20000000 	.word	0x20000000

080002dc <Default_Handler16>:
void Default_Handler16(void) { Default_HandlerCode = 16; panic_leds(5); }
 80002dc:	4b02      	ldr	r3, [pc, #8]	; (80002e8 <Default_Handler16+0xc>)
 80002de:	2210      	movs	r2, #16
 80002e0:	2005      	movs	r0, #5
 80002e2:	601a      	str	r2, [r3, #0]
 80002e4:	f004 bd47 	b.w	8004d76 <panic_leds>
 80002e8:	20000000 	.word	0x20000000

080002ec <Default_Handler17>:
void Default_Handler17(void) { Default_HandlerCode = 17; panic_leds(5); }
 80002ec:	4b02      	ldr	r3, [pc, #8]	; (80002f8 <Default_Handler17+0xc>)
 80002ee:	2211      	movs	r2, #17
 80002f0:	2005      	movs	r0, #5
 80002f2:	601a      	str	r2, [r3, #0]
 80002f4:	f004 bd3f 	b.w	8004d76 <panic_leds>
 80002f8:	20000000 	.word	0x20000000

080002fc <Default_Handler18>:
void Default_Handler18(void) { Default_HandlerCode = 18; panic_leds(5); }
 80002fc:	4b02      	ldr	r3, [pc, #8]	; (8000308 <Default_Handler18+0xc>)
 80002fe:	2212      	movs	r2, #18
 8000300:	2005      	movs	r0, #5
 8000302:	601a      	str	r2, [r3, #0]
 8000304:	f004 bd37 	b.w	8004d76 <panic_leds>
 8000308:	20000000 	.word	0x20000000

0800030c <Default_Handler19>:
void Default_Handler19(void) { Default_HandlerCode = 19; panic_leds(5); }
 800030c:	4b02      	ldr	r3, [pc, #8]	; (8000318 <Default_Handler19+0xc>)
 800030e:	2213      	movs	r2, #19
 8000310:	2005      	movs	r0, #5
 8000312:	601a      	str	r2, [r3, #0]
 8000314:	f004 bd2f 	b.w	8004d76 <panic_leds>
 8000318:	20000000 	.word	0x20000000

0800031c <Default_Handler20>:
void Default_Handler20(void) { Default_HandlerCode = 20; panic_leds(5); }
 800031c:	4b02      	ldr	r3, [pc, #8]	; (8000328 <Default_Handler20+0xc>)
 800031e:	2214      	movs	r2, #20
 8000320:	2005      	movs	r0, #5
 8000322:	601a      	str	r2, [r3, #0]
 8000324:	f004 bd27 	b.w	8004d76 <panic_leds>
 8000328:	20000000 	.word	0x20000000

0800032c <Default_Handler21>:
void Default_Handler21(void) { Default_HandlerCode = 21; panic_leds(5); }
 800032c:	4b02      	ldr	r3, [pc, #8]	; (8000338 <Default_Handler21+0xc>)
 800032e:	2215      	movs	r2, #21
 8000330:	2005      	movs	r0, #5
 8000332:	601a      	str	r2, [r3, #0]
 8000334:	f004 bd1f 	b.w	8004d76 <panic_leds>
 8000338:	20000000 	.word	0x20000000

0800033c <Default_Handler22>:
void Default_Handler22(void) { Default_HandlerCode = 22; panic_leds(5); }
 800033c:	4b02      	ldr	r3, [pc, #8]	; (8000348 <Default_Handler22+0xc>)
 800033e:	2216      	movs	r2, #22
 8000340:	2005      	movs	r0, #5
 8000342:	601a      	str	r2, [r3, #0]
 8000344:	f004 bd17 	b.w	8004d76 <panic_leds>
 8000348:	20000000 	.word	0x20000000

0800034c <Default_Handler23>:
void Default_Handler23(void) { Default_HandlerCode = 23; panic_leds(5); }
 800034c:	4b02      	ldr	r3, [pc, #8]	; (8000358 <Default_Handler23+0xc>)
 800034e:	2217      	movs	r2, #23
 8000350:	2005      	movs	r0, #5
 8000352:	601a      	str	r2, [r3, #0]
 8000354:	f004 bd0f 	b.w	8004d76 <panic_leds>
 8000358:	20000000 	.word	0x20000000

0800035c <Default_Handler24>:
void Default_Handler24(void) { Default_HandlerCode = 24; panic_leds(5); }
 800035c:	4b02      	ldr	r3, [pc, #8]	; (8000368 <Default_Handler24+0xc>)
 800035e:	2218      	movs	r2, #24
 8000360:	2005      	movs	r0, #5
 8000362:	601a      	str	r2, [r3, #0]
 8000364:	f004 bd07 	b.w	8004d76 <panic_leds>
 8000368:	20000000 	.word	0x20000000

0800036c <Default_Handler25>:
void Default_Handler25(void) { Default_HandlerCode = 25; panic_leds(5); }
 800036c:	4b02      	ldr	r3, [pc, #8]	; (8000378 <Default_Handler25+0xc>)
 800036e:	2219      	movs	r2, #25
 8000370:	2005      	movs	r0, #5
 8000372:	601a      	str	r2, [r3, #0]
 8000374:	f004 bcff 	b.w	8004d76 <panic_leds>
 8000378:	20000000 	.word	0x20000000

0800037c <Default_Handler26>:
void Default_Handler26(void) { Default_HandlerCode = 26; panic_leds(5); }
 800037c:	4b02      	ldr	r3, [pc, #8]	; (8000388 <Default_Handler26+0xc>)
 800037e:	221a      	movs	r2, #26
 8000380:	2005      	movs	r0, #5
 8000382:	601a      	str	r2, [r3, #0]
 8000384:	f004 bcf7 	b.w	8004d76 <panic_leds>
 8000388:	20000000 	.word	0x20000000

0800038c <Default_Handler27>:
void Default_Handler27(void) { Default_HandlerCode = 27; panic_leds(5); }
 800038c:	4b02      	ldr	r3, [pc, #8]	; (8000398 <Default_Handler27+0xc>)
 800038e:	221b      	movs	r2, #27
 8000390:	2005      	movs	r0, #5
 8000392:	601a      	str	r2, [r3, #0]
 8000394:	f004 bcef 	b.w	8004d76 <panic_leds>
 8000398:	20000000 	.word	0x20000000

0800039c <Default_Handler28>:
void Default_Handler28(void) { Default_HandlerCode = 28; panic_leds(5); }
 800039c:	4b02      	ldr	r3, [pc, #8]	; (80003a8 <Default_Handler28+0xc>)
 800039e:	221c      	movs	r2, #28
 80003a0:	2005      	movs	r0, #5
 80003a2:	601a      	str	r2, [r3, #0]
 80003a4:	f004 bce7 	b.w	8004d76 <panic_leds>
 80003a8:	20000000 	.word	0x20000000

080003ac <Default_Handler29>:
void Default_Handler29(void) { Default_HandlerCode = 29; panic_leds(5); }
 80003ac:	4b02      	ldr	r3, [pc, #8]	; (80003b8 <Default_Handler29+0xc>)
 80003ae:	221d      	movs	r2, #29
 80003b0:	2005      	movs	r0, #5
 80003b2:	601a      	str	r2, [r3, #0]
 80003b4:	f004 bcdf 	b.w	8004d76 <panic_leds>
 80003b8:	20000000 	.word	0x20000000

080003bc <Default_Handler30>:
void Default_Handler30(void) { Default_HandlerCode = 30; panic_leds(5); }
 80003bc:	4b02      	ldr	r3, [pc, #8]	; (80003c8 <Default_Handler30+0xc>)
 80003be:	221e      	movs	r2, #30
 80003c0:	2005      	movs	r0, #5
 80003c2:	601a      	str	r2, [r3, #0]
 80003c4:	f004 bcd7 	b.w	8004d76 <panic_leds>
 80003c8:	20000000 	.word	0x20000000

080003cc <Default_Handler31>:
void Default_Handler31(void) { Default_HandlerCode = 31; panic_leds(5); }
 80003cc:	4b02      	ldr	r3, [pc, #8]	; (80003d8 <Default_Handler31+0xc>)
 80003ce:	221f      	movs	r2, #31
 80003d0:	2005      	movs	r0, #5
 80003d2:	601a      	str	r2, [r3, #0]
 80003d4:	f004 bccf 	b.w	8004d76 <panic_leds>
 80003d8:	20000000 	.word	0x20000000

080003dc <Default_Handler32>:
void Default_Handler32(void) { Default_HandlerCode = 32; panic_leds(5); }
 80003dc:	4b02      	ldr	r3, [pc, #8]	; (80003e8 <Default_Handler32+0xc>)
 80003de:	2220      	movs	r2, #32
 80003e0:	2005      	movs	r0, #5
 80003e2:	601a      	str	r2, [r3, #0]
 80003e4:	f004 bcc7 	b.w	8004d76 <panic_leds>
 80003e8:	20000000 	.word	0x20000000

080003ec <Default_Handler33>:
void Default_Handler33(void) { Default_HandlerCode = 33; panic_leds(5); }
 80003ec:	4b02      	ldr	r3, [pc, #8]	; (80003f8 <Default_Handler33+0xc>)
 80003ee:	2221      	movs	r2, #33	; 0x21
 80003f0:	2005      	movs	r0, #5
 80003f2:	601a      	str	r2, [r3, #0]
 80003f4:	f004 bcbf 	b.w	8004d76 <panic_leds>
 80003f8:	20000000 	.word	0x20000000

080003fc <Default_Handler34>:
void Default_Handler34(void) { Default_HandlerCode = 34; panic_leds(5); }
 80003fc:	4b02      	ldr	r3, [pc, #8]	; (8000408 <Default_Handler34+0xc>)
 80003fe:	2222      	movs	r2, #34	; 0x22
 8000400:	2005      	movs	r0, #5
 8000402:	601a      	str	r2, [r3, #0]
 8000404:	f004 bcb7 	b.w	8004d76 <panic_leds>
 8000408:	20000000 	.word	0x20000000

0800040c <Default_Handler35>:
void Default_Handler35(void) { Default_HandlerCode = 35; panic_leds(5); }
 800040c:	4b02      	ldr	r3, [pc, #8]	; (8000418 <Default_Handler35+0xc>)
 800040e:	2223      	movs	r2, #35	; 0x23
 8000410:	2005      	movs	r0, #5
 8000412:	601a      	str	r2, [r3, #0]
 8000414:	f004 bcaf 	b.w	8004d76 <panic_leds>
 8000418:	20000000 	.word	0x20000000

0800041c <Default_Handler36>:
void Default_Handler36(void) { Default_HandlerCode = 36; panic_leds(5); }
 800041c:	4b02      	ldr	r3, [pc, #8]	; (8000428 <Default_Handler36+0xc>)
 800041e:	2224      	movs	r2, #36	; 0x24
 8000420:	2005      	movs	r0, #5
 8000422:	601a      	str	r2, [r3, #0]
 8000424:	f004 bca7 	b.w	8004d76 <panic_leds>
 8000428:	20000000 	.word	0x20000000

0800042c <Default_Handler37>:
void Default_Handler37(void) { Default_HandlerCode = 37; panic_leds(5); }
 800042c:	4b02      	ldr	r3, [pc, #8]	; (8000438 <Default_Handler37+0xc>)
 800042e:	2225      	movs	r2, #37	; 0x25
 8000430:	2005      	movs	r0, #5
 8000432:	601a      	str	r2, [r3, #0]
 8000434:	f004 bc9f 	b.w	8004d76 <panic_leds>
 8000438:	20000000 	.word	0x20000000

0800043c <Default_Handler38>:
void Default_Handler38(void) { Default_HandlerCode = 38; panic_leds(5); }
 800043c:	4b02      	ldr	r3, [pc, #8]	; (8000448 <Default_Handler38+0xc>)
 800043e:	2226      	movs	r2, #38	; 0x26
 8000440:	2005      	movs	r0, #5
 8000442:	601a      	str	r2, [r3, #0]
 8000444:	f004 bc97 	b.w	8004d76 <panic_leds>
 8000448:	20000000 	.word	0x20000000

0800044c <Default_Handler39>:
void Default_Handler39(void) { Default_HandlerCode = 39; panic_leds(5); }
 800044c:	4b02      	ldr	r3, [pc, #8]	; (8000458 <Default_Handler39+0xc>)
 800044e:	2227      	movs	r2, #39	; 0x27
 8000450:	2005      	movs	r0, #5
 8000452:	601a      	str	r2, [r3, #0]
 8000454:	f004 bc8f 	b.w	8004d76 <panic_leds>
 8000458:	20000000 	.word	0x20000000

0800045c <Default_Handler40>:
void Default_Handler40(void) { Default_HandlerCode = 40; panic_leds(5); }
 800045c:	4b02      	ldr	r3, [pc, #8]	; (8000468 <Default_Handler40+0xc>)
 800045e:	2228      	movs	r2, #40	; 0x28
 8000460:	2005      	movs	r0, #5
 8000462:	601a      	str	r2, [r3, #0]
 8000464:	f004 bc87 	b.w	8004d76 <panic_leds>
 8000468:	20000000 	.word	0x20000000

0800046c <Default_Handler41>:
void Default_Handler41(void) { Default_HandlerCode = 41; panic_leds(5); }
 800046c:	4b02      	ldr	r3, [pc, #8]	; (8000478 <Default_Handler41+0xc>)
 800046e:	2229      	movs	r2, #41	; 0x29
 8000470:	2005      	movs	r0, #5
 8000472:	601a      	str	r2, [r3, #0]
 8000474:	f004 bc7f 	b.w	8004d76 <panic_leds>
 8000478:	20000000 	.word	0x20000000

0800047c <Default_Handler42>:
void Default_Handler42(void) { Default_HandlerCode = 42; panic_leds(5); }
 800047c:	4b02      	ldr	r3, [pc, #8]	; (8000488 <Default_Handler42+0xc>)
 800047e:	222a      	movs	r2, #42	; 0x2a
 8000480:	2005      	movs	r0, #5
 8000482:	601a      	str	r2, [r3, #0]
 8000484:	f004 bc77 	b.w	8004d76 <panic_leds>
 8000488:	20000000 	.word	0x20000000

0800048c <Default_Handler43>:
void Default_Handler43(void) { Default_HandlerCode = 43; panic_leds(5); }
 800048c:	4b02      	ldr	r3, [pc, #8]	; (8000498 <Default_Handler43+0xc>)
 800048e:	222b      	movs	r2, #43	; 0x2b
 8000490:	2005      	movs	r0, #5
 8000492:	601a      	str	r2, [r3, #0]
 8000494:	f004 bc6f 	b.w	8004d76 <panic_leds>
 8000498:	20000000 	.word	0x20000000

0800049c <Default_Handler44>:
void Default_Handler44(void) { Default_HandlerCode = 44; panic_leds(5); }
 800049c:	4b02      	ldr	r3, [pc, #8]	; (80004a8 <Default_Handler44+0xc>)
 800049e:	222c      	movs	r2, #44	; 0x2c
 80004a0:	2005      	movs	r0, #5
 80004a2:	601a      	str	r2, [r3, #0]
 80004a4:	f004 bc67 	b.w	8004d76 <panic_leds>
 80004a8:	20000000 	.word	0x20000000

080004ac <Default_Handler45>:
void Default_Handler45(void) { Default_HandlerCode = 45; panic_leds(5); }
 80004ac:	4b02      	ldr	r3, [pc, #8]	; (80004b8 <Default_Handler45+0xc>)
 80004ae:	222d      	movs	r2, #45	; 0x2d
 80004b0:	2005      	movs	r0, #5
 80004b2:	601a      	str	r2, [r3, #0]
 80004b4:	f004 bc5f 	b.w	8004d76 <panic_leds>
 80004b8:	20000000 	.word	0x20000000

080004bc <Default_Handler46>:
void Default_Handler46(void) { Default_HandlerCode = 46; panic_leds(5); }
 80004bc:	4b02      	ldr	r3, [pc, #8]	; (80004c8 <Default_Handler46+0xc>)
 80004be:	222e      	movs	r2, #46	; 0x2e
 80004c0:	2005      	movs	r0, #5
 80004c2:	601a      	str	r2, [r3, #0]
 80004c4:	f004 bc57 	b.w	8004d76 <panic_leds>
 80004c8:	20000000 	.word	0x20000000

080004cc <Default_Handler47>:
void Default_Handler47(void) { Default_HandlerCode = 47; panic_leds(5); }
 80004cc:	4b02      	ldr	r3, [pc, #8]	; (80004d8 <Default_Handler47+0xc>)
 80004ce:	222f      	movs	r2, #47	; 0x2f
 80004d0:	2005      	movs	r0, #5
 80004d2:	601a      	str	r2, [r3, #0]
 80004d4:	f004 bc4f 	b.w	8004d76 <panic_leds>
 80004d8:	20000000 	.word	0x20000000

080004dc <Default_Handler48>:
void Default_Handler48(void) { Default_HandlerCode = 48; panic_leds(5); }
 80004dc:	4b02      	ldr	r3, [pc, #8]	; (80004e8 <Default_Handler48+0xc>)
 80004de:	2230      	movs	r2, #48	; 0x30
 80004e0:	2005      	movs	r0, #5
 80004e2:	601a      	str	r2, [r3, #0]
 80004e4:	f004 bc47 	b.w	8004d76 <panic_leds>
 80004e8:	20000000 	.word	0x20000000

080004ec <Default_Handler49>:
void Default_Handler49(void) { Default_HandlerCode = 49; panic_leds(5); }
 80004ec:	4b02      	ldr	r3, [pc, #8]	; (80004f8 <Default_Handler49+0xc>)
 80004ee:	2231      	movs	r2, #49	; 0x31
 80004f0:	2005      	movs	r0, #5
 80004f2:	601a      	str	r2, [r3, #0]
 80004f4:	f004 bc3f 	b.w	8004d76 <panic_leds>
 80004f8:	20000000 	.word	0x20000000

080004fc <Default_Handler50>:
void Default_Handler50(void) { Default_HandlerCode = 50; panic_leds(5); }
 80004fc:	4b02      	ldr	r3, [pc, #8]	; (8000508 <Default_Handler50+0xc>)
 80004fe:	2232      	movs	r2, #50	; 0x32
 8000500:	2005      	movs	r0, #5
 8000502:	601a      	str	r2, [r3, #0]
 8000504:	f004 bc37 	b.w	8004d76 <panic_leds>
 8000508:	20000000 	.word	0x20000000

0800050c <Default_Handler51>:
void Default_Handler51(void) { Default_HandlerCode = 51; panic_leds(5); }
 800050c:	4b02      	ldr	r3, [pc, #8]	; (8000518 <Default_Handler51+0xc>)
 800050e:	2233      	movs	r2, #51	; 0x33
 8000510:	2005      	movs	r0, #5
 8000512:	601a      	str	r2, [r3, #0]
 8000514:	f004 bc2f 	b.w	8004d76 <panic_leds>
 8000518:	20000000 	.word	0x20000000

0800051c <Default_Handler52>:
void Default_Handler52(void) { Default_HandlerCode = 52; panic_leds(5); }
 800051c:	4b02      	ldr	r3, [pc, #8]	; (8000528 <Default_Handler52+0xc>)
 800051e:	2234      	movs	r2, #52	; 0x34
 8000520:	2005      	movs	r0, #5
 8000522:	601a      	str	r2, [r3, #0]
 8000524:	f004 bc27 	b.w	8004d76 <panic_leds>
 8000528:	20000000 	.word	0x20000000

0800052c <Default_Handler53>:
void Default_Handler53(void) { Default_HandlerCode = 53; panic_leds(5); }
 800052c:	4b02      	ldr	r3, [pc, #8]	; (8000538 <Default_Handler53+0xc>)
 800052e:	2235      	movs	r2, #53	; 0x35
 8000530:	2005      	movs	r0, #5
 8000532:	601a      	str	r2, [r3, #0]
 8000534:	f004 bc1f 	b.w	8004d76 <panic_leds>
 8000538:	20000000 	.word	0x20000000

0800053c <Default_Handler54>:
void Default_Handler54(void) { Default_HandlerCode = 54; panic_leds(5); }
 800053c:	4b02      	ldr	r3, [pc, #8]	; (8000548 <Default_Handler54+0xc>)
 800053e:	2236      	movs	r2, #54	; 0x36
 8000540:	2005      	movs	r0, #5
 8000542:	601a      	str	r2, [r3, #0]
 8000544:	f004 bc17 	b.w	8004d76 <panic_leds>
 8000548:	20000000 	.word	0x20000000

0800054c <Default_Handler55>:
void Default_Handler55(void) { Default_HandlerCode = 55; panic_leds(5); }
 800054c:	4b02      	ldr	r3, [pc, #8]	; (8000558 <Default_Handler55+0xc>)
 800054e:	2237      	movs	r2, #55	; 0x37
 8000550:	2005      	movs	r0, #5
 8000552:	601a      	str	r2, [r3, #0]
 8000554:	f004 bc0f 	b.w	8004d76 <panic_leds>
 8000558:	20000000 	.word	0x20000000

0800055c <Default_Handler56>:
void Default_Handler56(void) { Default_HandlerCode = 56; panic_leds(5); }
 800055c:	4b02      	ldr	r3, [pc, #8]	; (8000568 <Default_Handler56+0xc>)
 800055e:	2238      	movs	r2, #56	; 0x38
 8000560:	2005      	movs	r0, #5
 8000562:	601a      	str	r2, [r3, #0]
 8000564:	f004 bc07 	b.w	8004d76 <panic_leds>
 8000568:	20000000 	.word	0x20000000

0800056c <Default_Handler57>:
void Default_Handler57(void) { Default_HandlerCode = 57; panic_leds(5); }
 800056c:	4b02      	ldr	r3, [pc, #8]	; (8000578 <Default_Handler57+0xc>)
 800056e:	2239      	movs	r2, #57	; 0x39
 8000570:	2005      	movs	r0, #5
 8000572:	601a      	str	r2, [r3, #0]
 8000574:	f004 bbff 	b.w	8004d76 <panic_leds>
 8000578:	20000000 	.word	0x20000000

0800057c <Default_Handler58>:
void Default_Handler58(void) { Default_HandlerCode = 58; panic_leds(5); }
 800057c:	4b02      	ldr	r3, [pc, #8]	; (8000588 <Default_Handler58+0xc>)
 800057e:	223a      	movs	r2, #58	; 0x3a
 8000580:	2005      	movs	r0, #5
 8000582:	601a      	str	r2, [r3, #0]
 8000584:	f004 bbf7 	b.w	8004d76 <panic_leds>
 8000588:	20000000 	.word	0x20000000

0800058c <Default_Handler59>:
void Default_Handler59(void) { Default_HandlerCode = 59; panic_leds(5); }
 800058c:	4b02      	ldr	r3, [pc, #8]	; (8000598 <Default_Handler59+0xc>)
 800058e:	223b      	movs	r2, #59	; 0x3b
 8000590:	2005      	movs	r0, #5
 8000592:	601a      	str	r2, [r3, #0]
 8000594:	f004 bbef 	b.w	8004d76 <panic_leds>
 8000598:	20000000 	.word	0x20000000

0800059c <Default_Handler60>:
void Default_Handler60(void) { Default_HandlerCode = 60; panic_leds(5); }
 800059c:	4b02      	ldr	r3, [pc, #8]	; (80005a8 <Default_Handler60+0xc>)
 800059e:	223c      	movs	r2, #60	; 0x3c
 80005a0:	2005      	movs	r0, #5
 80005a2:	601a      	str	r2, [r3, #0]
 80005a4:	f004 bbe7 	b.w	8004d76 <panic_leds>
 80005a8:	20000000 	.word	0x20000000

080005ac <Default_Handler61>:
void Default_Handler61(void) { Default_HandlerCode = 61; panic_leds(5); }
 80005ac:	4b02      	ldr	r3, [pc, #8]	; (80005b8 <Default_Handler61+0xc>)
 80005ae:	223d      	movs	r2, #61	; 0x3d
 80005b0:	2005      	movs	r0, #5
 80005b2:	601a      	str	r2, [r3, #0]
 80005b4:	f004 bbdf 	b.w	8004d76 <panic_leds>
 80005b8:	20000000 	.word	0x20000000

080005bc <Default_Handler62>:
void Default_Handler62(void) { Default_HandlerCode = 62; panic_leds(5); }
 80005bc:	4b02      	ldr	r3, [pc, #8]	; (80005c8 <Default_Handler62+0xc>)
 80005be:	223e      	movs	r2, #62	; 0x3e
 80005c0:	2005      	movs	r0, #5
 80005c2:	601a      	str	r2, [r3, #0]
 80005c4:	f004 bbd7 	b.w	8004d76 <panic_leds>
 80005c8:	20000000 	.word	0x20000000

080005cc <Default_Handler63>:
void Default_Handler63(void) { Default_HandlerCode = 63; panic_leds(5); }
 80005cc:	4b02      	ldr	r3, [pc, #8]	; (80005d8 <Default_Handler63+0xc>)
 80005ce:	223f      	movs	r2, #63	; 0x3f
 80005d0:	2005      	movs	r0, #5
 80005d2:	601a      	str	r2, [r3, #0]
 80005d4:	f004 bbcf 	b.w	8004d76 <panic_leds>
 80005d8:	20000000 	.word	0x20000000

080005dc <Default_Handler64>:
void Default_Handler64(void) { Default_HandlerCode = 64; panic_leds(5); }
 80005dc:	4b02      	ldr	r3, [pc, #8]	; (80005e8 <Default_Handler64+0xc>)
 80005de:	2240      	movs	r2, #64	; 0x40
 80005e0:	2005      	movs	r0, #5
 80005e2:	601a      	str	r2, [r3, #0]
 80005e4:	f004 bbc7 	b.w	8004d76 <panic_leds>
 80005e8:	20000000 	.word	0x20000000

080005ec <Default_Handler65>:
void Default_Handler65(void) { Default_HandlerCode = 65; panic_leds(5); }
 80005ec:	4b02      	ldr	r3, [pc, #8]	; (80005f8 <Default_Handler65+0xc>)
 80005ee:	2241      	movs	r2, #65	; 0x41
 80005f0:	2005      	movs	r0, #5
 80005f2:	601a      	str	r2, [r3, #0]
 80005f4:	f004 bbbf 	b.w	8004d76 <panic_leds>
 80005f8:	20000000 	.word	0x20000000

080005fc <Default_Handler66>:
void Default_Handler66(void) { Default_HandlerCode = 66; panic_leds(5); }
 80005fc:	4b02      	ldr	r3, [pc, #8]	; (8000608 <Default_Handler66+0xc>)
 80005fe:	2242      	movs	r2, #66	; 0x42
 8000600:	2005      	movs	r0, #5
 8000602:	601a      	str	r2, [r3, #0]
 8000604:	f004 bbb7 	b.w	8004d76 <panic_leds>
 8000608:	20000000 	.word	0x20000000

0800060c <Default_Handler67>:
void Default_Handler67(void) { Default_HandlerCode = 67; panic_leds(5); }
 800060c:	4b02      	ldr	r3, [pc, #8]	; (8000618 <Default_Handler67+0xc>)
 800060e:	2243      	movs	r2, #67	; 0x43
 8000610:	2005      	movs	r0, #5
 8000612:	601a      	str	r2, [r3, #0]
 8000614:	f004 bbaf 	b.w	8004d76 <panic_leds>
 8000618:	20000000 	.word	0x20000000

0800061c <Default_Handler68>:
void Default_Handler68(void) { Default_HandlerCode = 68; panic_leds(5); }
 800061c:	4b02      	ldr	r3, [pc, #8]	; (8000628 <Default_Handler68+0xc>)
 800061e:	2244      	movs	r2, #68	; 0x44
 8000620:	2005      	movs	r0, #5
 8000622:	601a      	str	r2, [r3, #0]
 8000624:	f004 bba7 	b.w	8004d76 <panic_leds>
 8000628:	20000000 	.word	0x20000000

0800062c <Default_Handler69>:
void Default_Handler69(void) { Default_HandlerCode = 69; panic_leds(5); }
 800062c:	4b02      	ldr	r3, [pc, #8]	; (8000638 <Default_Handler69+0xc>)
 800062e:	2245      	movs	r2, #69	; 0x45
 8000630:	2005      	movs	r0, #5
 8000632:	601a      	str	r2, [r3, #0]
 8000634:	f004 bb9f 	b.w	8004d76 <panic_leds>
 8000638:	20000000 	.word	0x20000000

0800063c <Default_Handler70>:
void Default_Handler70(void) { Default_HandlerCode = 70; panic_leds(5); }
 800063c:	4b02      	ldr	r3, [pc, #8]	; (8000648 <Default_Handler70+0xc>)
 800063e:	2246      	movs	r2, #70	; 0x46
 8000640:	2005      	movs	r0, #5
 8000642:	601a      	str	r2, [r3, #0]
 8000644:	f004 bb97 	b.w	8004d76 <panic_leds>
 8000648:	20000000 	.word	0x20000000

0800064c <Default_Handler71>:
void Default_Handler71(void) { Default_HandlerCode = 71; panic_leds(5); }
 800064c:	4b02      	ldr	r3, [pc, #8]	; (8000658 <Default_Handler71+0xc>)
 800064e:	2247      	movs	r2, #71	; 0x47
 8000650:	2005      	movs	r0, #5
 8000652:	601a      	str	r2, [r3, #0]
 8000654:	f004 bb8f 	b.w	8004d76 <panic_leds>
 8000658:	20000000 	.word	0x20000000

0800065c <Default_Handler72>:
void Default_Handler72(void) { Default_HandlerCode = 72; panic_leds(5); }
 800065c:	4b02      	ldr	r3, [pc, #8]	; (8000668 <Default_Handler72+0xc>)
 800065e:	2248      	movs	r2, #72	; 0x48
 8000660:	2005      	movs	r0, #5
 8000662:	601a      	str	r2, [r3, #0]
 8000664:	f004 bb87 	b.w	8004d76 <panic_leds>
 8000668:	20000000 	.word	0x20000000

0800066c <Default_Handler73>:
void Default_Handler73(void) { Default_HandlerCode = 73; panic_leds(5); }
 800066c:	4b02      	ldr	r3, [pc, #8]	; (8000678 <Default_Handler73+0xc>)
 800066e:	2249      	movs	r2, #73	; 0x49
 8000670:	2005      	movs	r0, #5
 8000672:	601a      	str	r2, [r3, #0]
 8000674:	f004 bb7f 	b.w	8004d76 <panic_leds>
 8000678:	20000000 	.word	0x20000000

0800067c <Default_Handler74>:
void Default_Handler74(void) { Default_HandlerCode = 74; panic_leds(5); }
 800067c:	4b02      	ldr	r3, [pc, #8]	; (8000688 <Default_Handler74+0xc>)
 800067e:	224a      	movs	r2, #74	; 0x4a
 8000680:	2005      	movs	r0, #5
 8000682:	601a      	str	r2, [r3, #0]
 8000684:	f004 bb77 	b.w	8004d76 <panic_leds>
 8000688:	20000000 	.word	0x20000000

0800068c <Default_Handler75>:
void Default_Handler75(void) { Default_HandlerCode = 75; panic_leds(5); }
 800068c:	4b02      	ldr	r3, [pc, #8]	; (8000698 <Default_Handler75+0xc>)
 800068e:	224b      	movs	r2, #75	; 0x4b
 8000690:	2005      	movs	r0, #5
 8000692:	601a      	str	r2, [r3, #0]
 8000694:	f004 bb6f 	b.w	8004d76 <panic_leds>
 8000698:	20000000 	.word	0x20000000

0800069c <Default_Handler77>:
//void Default_Handler76(void) { Default_HandlerCode = 76; panic_leds(5); }
void Default_Handler77(void) { Default_HandlerCode = 77; panic_leds(5); }
 800069c:	4b02      	ldr	r3, [pc, #8]	; (80006a8 <Default_Handler77+0xc>)
 800069e:	224d      	movs	r2, #77	; 0x4d
 80006a0:	2005      	movs	r0, #5
 80006a2:	601a      	str	r2, [r3, #0]
 80006a4:	f004 bb67 	b.w	8004d76 <panic_leds>
 80006a8:	20000000 	.word	0x20000000

080006ac <Default_Handler78>:
void Default_Handler78(void) { Default_HandlerCode = 78; panic_leds(5); }
 80006ac:	4b02      	ldr	r3, [pc, #8]	; (80006b8 <Default_Handler78+0xc>)
 80006ae:	224e      	movs	r2, #78	; 0x4e
 80006b0:	2005      	movs	r0, #5
 80006b2:	601a      	str	r2, [r3, #0]
 80006b4:	f004 bb5f 	b.w	8004d76 <panic_leds>
 80006b8:	20000000 	.word	0x20000000

080006bc <Default_Handler79>:
void Default_Handler79(void) { Default_HandlerCode = 79; panic_leds(5); }
 80006bc:	4b02      	ldr	r3, [pc, #8]	; (80006c8 <Default_Handler79+0xc>)
 80006be:	224f      	movs	r2, #79	; 0x4f
 80006c0:	2005      	movs	r0, #5
 80006c2:	601a      	str	r2, [r3, #0]
 80006c4:	f004 bb57 	b.w	8004d76 <panic_leds>
 80006c8:	20000000 	.word	0x20000000

080006cc <Default_Handler80>:
void Default_Handler80(void) { Default_HandlerCode = 80; panic_leds(5); }
 80006cc:	4b02      	ldr	r3, [pc, #8]	; (80006d8 <Default_Handler80+0xc>)
 80006ce:	2250      	movs	r2, #80	; 0x50
 80006d0:	2005      	movs	r0, #5
 80006d2:	601a      	str	r2, [r3, #0]
 80006d4:	f004 bb4f 	b.w	8004d76 <panic_leds>
 80006d8:	20000000 	.word	0x20000000

080006dc <Default_Handler81>:
void Default_Handler81(void) { Default_HandlerCode = 81; panic_leds(5); }
 80006dc:	4b02      	ldr	r3, [pc, #8]	; (80006e8 <Default_Handler81+0xc>)
 80006de:	2251      	movs	r2, #81	; 0x51
 80006e0:	2005      	movs	r0, #5
 80006e2:	601a      	str	r2, [r3, #0]
 80006e4:	f004 bb47 	b.w	8004d76 <panic_leds>
 80006e8:	20000000 	.word	0x20000000

080006ec <Default_Handler82>:
void Default_Handler82(void) { Default_HandlerCode = 82; panic_leds(5); }
 80006ec:	4b02      	ldr	r3, [pc, #8]	; (80006f8 <Default_Handler82+0xc>)
 80006ee:	2252      	movs	r2, #82	; 0x52
 80006f0:	2005      	movs	r0, #5
 80006f2:	601a      	str	r2, [r3, #0]
 80006f4:	f004 bb3f 	b.w	8004d76 <panic_leds>
 80006f8:	20000000 	.word	0x20000000

080006fc <Default_Handler83>:
void Default_Handler83(void) { Default_HandlerCode = 83; panic_leds(5); }
 80006fc:	4b02      	ldr	r3, [pc, #8]	; (8000708 <Default_Handler83+0xc>)
 80006fe:	2253      	movs	r2, #83	; 0x53
 8000700:	2005      	movs	r0, #5
 8000702:	601a      	str	r2, [r3, #0]
 8000704:	f004 bb37 	b.w	8004d76 <panic_leds>
 8000708:	20000000 	.word	0x20000000

0800070c <Default_Handler84>:
void Default_Handler84(void) { Default_HandlerCode = 84; panic_leds(5); }
 800070c:	4b02      	ldr	r3, [pc, #8]	; (8000718 <Default_Handler84+0xc>)
 800070e:	2254      	movs	r2, #84	; 0x54
 8000710:	2005      	movs	r0, #5
 8000712:	601a      	str	r2, [r3, #0]
 8000714:	f004 bb2f 	b.w	8004d76 <panic_leds>
 8000718:	20000000 	.word	0x20000000

0800071c <Default_Handler85>:
void Default_Handler85(void) { Default_HandlerCode = 85; panic_leds(5); }
 800071c:	4b02      	ldr	r3, [pc, #8]	; (8000728 <Default_Handler85+0xc>)
 800071e:	2255      	movs	r2, #85	; 0x55
 8000720:	2005      	movs	r0, #5
 8000722:	601a      	str	r2, [r3, #0]
 8000724:	f004 bb27 	b.w	8004d76 <panic_leds>
 8000728:	20000000 	.word	0x20000000

0800072c <Default_Handler86>:
void Default_Handler86(void) { Default_HandlerCode = 86; panic_leds(5); }
 800072c:	4b02      	ldr	r3, [pc, #8]	; (8000738 <Default_Handler86+0xc>)
 800072e:	2256      	movs	r2, #86	; 0x56
 8000730:	2005      	movs	r0, #5
 8000732:	601a      	str	r2, [r3, #0]
 8000734:	f004 bb1f 	b.w	8004d76 <panic_leds>
 8000738:	20000000 	.word	0x20000000

0800073c <Default_Handler87>:
void Default_Handler87(void) { Default_HandlerCode = 87; panic_leds(5); }
 800073c:	4b02      	ldr	r3, [pc, #8]	; (8000748 <Default_Handler87+0xc>)
 800073e:	2257      	movs	r2, #87	; 0x57
 8000740:	2005      	movs	r0, #5
 8000742:	601a      	str	r2, [r3, #0]
 8000744:	f004 bb17 	b.w	8004d76 <panic_leds>
 8000748:	20000000 	.word	0x20000000

0800074c <Default_Handler88>:
void Default_Handler88(void) { Default_HandlerCode = 88; panic_leds(5); }
 800074c:	4b02      	ldr	r3, [pc, #8]	; (8000758 <Default_Handler88+0xc>)
 800074e:	2258      	movs	r2, #88	; 0x58
 8000750:	2005      	movs	r0, #5
 8000752:	601a      	str	r2, [r3, #0]
 8000754:	f004 bb0f 	b.w	8004d76 <panic_leds>
 8000758:	20000000 	.word	0x20000000

0800075c <Default_Handler89>:
void Default_Handler89(void) { Default_HandlerCode = 89; panic_leds(5); }
 800075c:	4b02      	ldr	r3, [pc, #8]	; (8000768 <Default_Handler89+0xc>)
 800075e:	2259      	movs	r2, #89	; 0x59
 8000760:	2005      	movs	r0, #5
 8000762:	601a      	str	r2, [r3, #0]
 8000764:	f004 bb07 	b.w	8004d76 <panic_leds>
 8000768:	20000000 	.word	0x20000000

0800076c <Default_Handler90>:
void Default_Handler90(void) { Default_HandlerCode = 90; panic_leds(5); }
 800076c:	4b02      	ldr	r3, [pc, #8]	; (8000778 <Default_Handler90+0xc>)
 800076e:	225a      	movs	r2, #90	; 0x5a
 8000770:	2005      	movs	r0, #5
 8000772:	601a      	str	r2, [r3, #0]
 8000774:	f004 baff 	b.w	8004d76 <panic_leds>
 8000778:	20000000 	.word	0x20000000

0800077c <toggle_led>:
/* ************************************************************
Turn the LEDs on in sequence, then turn them back off 
***************************************************************/
void toggle_led (int lednum)
{
	if ((GPIO_ODR(GPIOD) & (1<<lednum)) == 0)
 800077c:	4b06      	ldr	r3, [pc, #24]	; (8000798 <toggle_led+0x1c>)
 800077e:	2201      	movs	r2, #1
 8000780:	681b      	ldr	r3, [r3, #0]
 8000782:	fa12 f100 	lsls.w	r1, r2, r0
 8000786:	4219      	tst	r1, r3
 8000788:	4b04      	ldr	r3, [pc, #16]	; (800079c <toggle_led+0x20>)
 800078a:	d101      	bne.n	8000790 <toggle_led+0x14>
	{ // Here, LED bit was off
		GPIO_BSRR(GPIOD) = (1<<lednum);	// Set bit
 800078c:	6019      	str	r1, [r3, #0]
 800078e:	4770      	bx	lr
	}
	else
	{ // HEre, LED bit was on
		GPIO_BSRR(GPIOD) = (1<<(lednum+16));	// Reset bit
 8000790:	3010      	adds	r0, #16
 8000792:	4082      	lsls	r2, r0
 8000794:	601a      	str	r2, [r3, #0]
 8000796:	4770      	bx	lr
 8000798:	40020c14 	.word	0x40020c14
 800079c:	40020c18 	.word	0x40020c18

080007a0 <initMasterController>:
// 		// str[strlen(str)] = padChar;
// 	}
// }

/* Setup & initialization functions */ 
void initMasterController () {
 80007a0:	b537      	push	{r0, r1, r2, r4, r5, lr}
	int init_ret = -4;
	/* --------------------- Begin setting things up -------------------------------------------------- */ 
		clockspecifysetup((struct CLOCKS*)&clocks);		// Get the system clock and bus clocks running
 80007a2:	4831      	ldr	r0, [pc, #196]	; (8000868 <initMasterController+0xc8>)
 80007a4:	f004 fbf0 	bl	8004f88 <clockspecifysetup>
	/* ---------------------- Set up pins ------------------------------------------------------------- */
		/* Configure pins */
		DISCgpiopins_Config();	// Configure pins
 80007a8:	f003 fec6 	bl	8004538 <DISCgpiopins_Config>
	/* ---------------------- Set usb ----------------------------------------------------------------- */
		// usb1_init();	// Initialization for USB (STM32F4_USB_CDC demo package)
		setbuf(stdout, NULL);
 80007ac:	4b2f      	ldr	r3, [pc, #188]	; (800086c <initMasterController+0xcc>)
 80007ae:	681b      	ldr	r3, [r3, #0]
 80007b0:	2100      	movs	r1, #0
 80007b2:	6898      	ldr	r0, [r3, #8]
 80007b4:	f006 f95e 	bl	8006a74 <setbuf>
	/* --------------------- Initialize USART/UARTs ---------------------------------------------------- */
		bsp_uart_int_init_number(USTDO, 230400, 256, 256, 0x40);
 80007b8:	f44f 7280 	mov.w	r2, #256	; 0x100
 80007bc:	2340      	movs	r3, #64	; 0x40
 80007be:	f44f 3161 	mov.w	r1, #230400	; 0x38400
 80007c2:	9300      	str	r3, [sp, #0]
 80007c4:	2002      	movs	r0, #2
 80007c6:	4613      	mov	r3, r2
 80007c8:	f005 fa16 	bl	8005bf8 <bsp_uart_int_init_number>
		// This sets up the UART used for the LCD screen
		lcd_init(UXPRT);
 80007cc:	2006      	movs	r0, #6
 80007ce:	f003 fe8e 	bl	80044ee <lcd_init>
	/* Setup STDOUT, STDIN (a shameful sequence until we sort out 'newlib' and 'fopen'.)  The following 'open' sets up 
	   the USART/UART that will be used as STDOUT_FILENO, and STDIN_FILENO.  Don't call 'open' again!  */
		fd = open("tty2", 0,0); // This sets up the uart control block pointer versus file descriptor ('fd')
 80007d2:	2100      	movs	r1, #0
 80007d4:	460a      	mov	r2, r1
 80007d6:	4826      	ldr	r0, [pc, #152]	; (8000870 <initMasterController+0xd0>)
 80007d8:	f007 fe74 	bl	80084c4 <open>
 80007dc:	4b25      	ldr	r3, [pc, #148]	; (8000874 <initMasterController+0xd4>)
		PD00 CAN1  Rx LQFP 81 Header P2|36 BLU
		PD01 CAN1  Tx LQFP 82 Header P2|33 WHT
		PC04 GPIIO RS LQFP 33 Header P1|20 GRN
		*/
		/* Configure CAN driver RS pin: PC4 LQFP 33, Header P1|20, fo hi speed. */
		can_nxp_setRS_ldr(0,(volatile u32 *)GPIOC, 4); // (1st arg) 0 = high speed mode; not-zero = standby mode
 80007de:	4926      	ldr	r1, [pc, #152]	; (8000878 <initMasterController+0xd8>)
		bsp_uart_int_init_number(USTDO, 230400, 256, 256, 0x40);
		// This sets up the UART used for the LCD screen
		lcd_init(UXPRT);
	/* Setup STDOUT, STDIN (a shameful sequence until we sort out 'newlib' and 'fopen'.)  The following 'open' sets up 
	   the USART/UART that will be used as STDOUT_FILENO, and STDIN_FILENO.  Don't call 'open' again!  */
		fd = open("tty2", 0,0); // This sets up the uart control block pointer versus file descriptor ('fd')
 80007e0:	6018      	str	r0, [r3, #0]
	/* ---------------------- DTW sys counter -------------------------------------------------------- */
		// Use DTW_CYCCNT counter (driven by sysclk) for polling type timing 
		// CYCCNT counter is in the Cortex-M-series core.  See the following for details 
		// http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html 
		*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
 80007e2:	4b26      	ldr	r3, [pc, #152]	; (800087c <initMasterController+0xdc>)
 80007e4:	681a      	ldr	r2, [r3, #0]
 80007e6:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80007ea:	601a      	str	r2, [r3, #0]
		*(volatile unsigned int*)0xE0001000 |= 0x1;	// Enable DTW_CYCCNT (Data Watch cycle counter)
 80007ec:	4b24      	ldr	r3, [pc, #144]	; (8000880 <initMasterController+0xe0>)
 80007ee:	681a      	ldr	r2, [r3, #0]
 80007f0:	f042 0201 	orr.w	r2, r2, #1
 80007f4:	601a      	str	r2, [r3, #0]
		PD00 CAN1  Rx LQFP 81 Header P2|36 BLU
		PD01 CAN1  Tx LQFP 82 Header P2|33 WHT
		PC04 GPIIO RS LQFP 33 Header P1|20 GRN
		*/
		/* Configure CAN driver RS pin: PC4 LQFP 33, Header P1|20, fo hi speed. */
		can_nxp_setRS_ldr(0,(volatile u32 *)GPIOC, 4); // (1st arg) 0 = high speed mode; not-zero = standby mode
 80007f6:	2000      	movs	r0, #0
 80007f8:	2204      	movs	r2, #4
 80007fa:	f004 f873 	bl	80048e4 <can_nxp_setRS_ldr>

		/* Setup CAN registers and initialize routine */
		init_ret = can_init_pod_ldr((struct CAN_PARAMS*)&can_params); // 'struct' that holds all the parameters
 80007fe:	4821      	ldr	r0, [pc, #132]	; (8000884 <initMasterController+0xe4>)
 8000800:	f003 ff2e 	bl	8004660 <can_init_pod_ldr>

		/* Check if initialization was successful, or timed out. */
		if (init_ret <= 0)
 8000804:	2800      	cmp	r0, #0
 8000806:	dc03      	bgt.n	8000810 <initMasterController+0x70>
		{ // Here the init returned an error code
			// xprintf(UXPRT, "###### can init failed: code = %d\n\r",init_ret); 
			panic_leds(6);	while (1==1);	// Flash panic display with code 6
 8000808:	2006      	movs	r0, #6
 800080a:	f004 fab4 	bl	8004d76 <panic_leds>
 800080e:	e7fe      	b.n	800080e <initMasterController+0x6e>
		{
			// xprintf(UXPRT, "###### can_filtermask16_add failed: code = %d\n\r",can_ret);
			panic_leds(7);	while (1==1);	// Flash panic display with code 7
		}
	/* --------------------- Hardware is ready, so do program-specific startup ---------------------------- */
		t_led = *(volatile unsigned int *)0xE0001004 + FLASHCOUNT; // Set initial time
 8000810:	4d1d      	ldr	r5, [pc, #116]	; (8000888 <initMasterController+0xe8>)

		PC_msg_initg(&pctogateway);	// Initialize struct for CAN message from PC
 8000812:	4c1e      	ldr	r4, [pc, #120]	; (800088c <initMasterController+0xec>)
			panic_leds(6);	while (1==1);	// Flash panic display with code 6
		}
		// xprintf (UXPRT, "\n\rcan ret ct: %d..............................................\n\r",init_ret); // Just a check for how long "exit initialization" took

		/* Set filters to respond "this" unit number and time sync broadcasts */
		can_filter_unitid_ldr(can_params.iamunitnumber);	// Setup msg filter banks
 8000814:	f04f 7068 	mov.w	r0, #60817408	; 0x3a00000
 8000818:	f004 f87a 	bl	8004910 <can_filter_unitid_ldr>

		// xprintf (UXPRT, " IAMUNITNUMBER %0x %0x.....................................\n\r",(unsigned int)IAMUNITNUMBER,(unsigned int)CAN_UNITID_SE1 >> CAN_UNITID_SHIFT); 

		/* Since this is a gateway set the filter for the hardware to accept all msgs. */
		int can_ret = can_filtermask16_add_ldr( 0 );	// Allow all msgs
 800081c:	2000      	movs	r0, #0
 800081e:	f004 f8a9 	bl	8004974 <can_filtermask16_add_ldr>
		{
			// xprintf(UXPRT, "###### can_filtermask16_add failed: code = %d\n\r",can_ret);
			panic_leds(7);	while (1==1);	// Flash panic display with code 7
		}
	/* --------------------- Hardware is ready, so do program-specific startup ---------------------------- */
		t_led = *(volatile unsigned int *)0xE0001004 + FLASHCOUNT; // Set initial time
 8000822:	682a      	ldr	r2, [r5, #0]
 8000824:	4b1a      	ldr	r3, [pc, #104]	; (8000890 <initMasterController+0xf0>)
 8000826:	18d3      	adds	r3, r2, r3
 8000828:	4a1a      	ldr	r2, [pc, #104]	; (8000894 <initMasterController+0xf4>)

		PC_msg_initg(&pctogateway);	// Initialize struct for CAN message from PC
 800082a:	f504 60a2 	add.w	r0, r4, #1296	; 0x510
		{
			// xprintf(UXPRT, "###### can_filtermask16_add failed: code = %d\n\r",can_ret);
			panic_leds(7);	while (1==1);	// Flash panic display with code 7
		}
	/* --------------------- Hardware is ready, so do program-specific startup ---------------------------- */
		t_led = *(volatile unsigned int *)0xE0001004 + FLASHCOUNT; // Set initial time
 800082e:	6013      	str	r3, [r2, #0]

		PC_msg_initg(&pctogateway);	// Initialize struct for CAN message from PC
 8000830:	f003 facf 	bl	8003dd2 <PC_msg_initg>
		PC_msg_initg(&gatewayToPC);	// Initialize struct for CAN message from PC
 8000834:	f504 60ae 	add.w	r0, r4, #1392	; 0x570
 8000838:	f003 facb 	bl	8003dd2 <PC_msg_initg>

		/* Set modes for routines that receive and send CAN msgs */
		pctogateway.mode_link = MODE_LINK;
 800083c:	2302      	movs	r3, #2
 800083e:	f884 354e 	strb.w	r3, [r4, #1358]	; 0x54e
		gatewayToPC.mode_link = MODE_LINK;
 8000842:	f884 35ae 	strb.w	r3, [r4, #1454]	; 0x5ae
	/* --------------------- Initialize SPI2 ------------------------------------------------------------------------------- */
		spi2rw_init();
 8000846:	f004 faf9 	bl	8004e3c <spi2rw_init>
		t_spi = *(volatile unsigned int *)0xE0001004 + SPIPACE;
 800084a:	682b      	ldr	r3, [r5, #0]
 800084c:	4a12      	ldr	r2, [pc, #72]	; (8000898 <initMasterController+0xf8>)
 800084e:	f503 234c 	add.w	r3, r3, #835584	; 0xcc000
 8000852:	f503 538a 	add.w	r3, r3, #4416	; 0x1140
 8000856:	6013      	str	r3, [r2, #0]
	/* --------------------- LCD ---------------------------------------------------------------------------- */
		t_lcd = *(volatile unsigned int *)0xE0001004 + LCDPACE;
 8000858:	682b      	ldr	r3, [r5, #0]
 800085a:	4a10      	ldr	r2, [pc, #64]	; (800089c <initMasterController+0xfc>)
 800085c:	f103 7380 	add.w	r3, r3, #16777216	; 0x1000000
 8000860:	f503 43b2 	add.w	r3, r3, #22784	; 0x5900
 8000864:	6013      	str	r3, [r2, #0]
}
 8000866:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8000868:	0800cce8 	.word	0x0800cce8
 800086c:	20000278 	.word	0x20000278
 8000870:	0800d110 	.word	0x0800d110
 8000874:	200019f8 	.word	0x200019f8
 8000878:	40020800 	.word	0x40020800
 800087c:	e000edfc 	.word	0xe000edfc
 8000880:	e0001000 	.word	0xe0001000
 8000884:	0800ccfc 	.word	0x0800ccfc
 8000888:	e0001004 	.word	0xe0001004
 800088c:	200007f8 	.word	0x200007f8
 8000890:	0501bd00 	.word	0x0501bd00
 8000894:	200019dc 	.word	0x200019dc
 8000898:	200019c0 	.word	0x200019c0
 800089c:	20001a7c 	.word	0x20001a7c

080008a0 <ledHeartbeat>:

// main loop functions
	/* Flash the red LED to amuse the hapless Op or signal the wizard programmer that the loop is running. */
	void ledHeartbeat () {
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_led)) > 0) // Has the time expired?
 80008a0:	4b06      	ldr	r3, [pc, #24]	; (80008bc <ledHeartbeat+0x1c>)
 80008a2:	4a07      	ldr	r2, [pc, #28]	; (80008c0 <ledHeartbeat+0x20>)
 80008a4:	681b      	ldr	r3, [r3, #0]
 80008a6:	6811      	ldr	r1, [r2, #0]
 80008a8:	1a5b      	subs	r3, r3, r1
 80008aa:	2b00      	cmp	r3, #0
 80008ac:	dd04      	ble.n	80008b8 <ledHeartbeat+0x18>
		{ // Here, yes.
			t_led += FLASHCOUNT; 	// Set next toggle time
 80008ae:	4b05      	ldr	r3, [pc, #20]	; (80008c4 <ledHeartbeat+0x24>)

			toggle_led(14); 	// Advance some LED pattern
 80008b0:	200e      	movs	r0, #14
// main loop functions
	/* Flash the red LED to amuse the hapless Op or signal the wizard programmer that the loop is running. */
	void ledHeartbeat () {
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_led)) > 0) // Has the time expired?
		{ // Here, yes.
			t_led += FLASHCOUNT; 	// Set next toggle time
 80008b2:	18cb      	adds	r3, r1, r3
 80008b4:	6013      	str	r3, [r2, #0]

			toggle_led(14); 	// Advance some LED pattern
 80008b6:	e761      	b.n	800077c <toggle_led>
 80008b8:	4770      	bx	lr
 80008ba:	bf00      	nop
 80008bc:	e0001004 	.word	0xe0001004
 80008c0:	200019dc 	.word	0x200019dc
 80008c4:	0501bd00 	.word	0x0501bd00

080008c8 <timeKeeper>:
		}
	}

	/* function to find the 64th second beats */
	void timeKeeper () {
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_timeKeeper)) > 0) // Has the time expired?
 80008c8:	4b11      	ldr	r3, [pc, #68]	; (8000910 <timeKeeper+0x48>)
 80008ca:	4a12      	ldr	r2, [pc, #72]	; (8000914 <timeKeeper+0x4c>)
 80008cc:	681b      	ldr	r3, [r3, #0]
 80008ce:	6811      	ldr	r1, [r2, #0]
 80008d0:	1a5b      	subs	r3, r3, r1
 80008d2:	2b00      	cmp	r3, #0
 80008d4:	dd1a      	ble.n	800090c <timeKeeper+0x44>
		{ // Here, yes.
			t_timeKeeper += SIXTYFOURTH; 	// Set next toggle time
 80008d6:	4b10      	ldr	r3, [pc, #64]	; (8000918 <timeKeeper+0x50>)
 80008d8:	18cb      	adds	r3, r1, r3
 80008da:	6013      	str	r3, [r2, #0]

			count64++;
 80008dc:	4b0f      	ldr	r3, [pc, #60]	; (800091c <timeKeeper+0x54>)
 80008de:	f893 25d0 	ldrb.w	r2, [r3, #1488]	; 0x5d0
 80008e2:	3201      	adds	r2, #1
 80008e4:	b2d2      	uxtb	r2, r2

			if(count64 == 64) {
 80008e6:	2a40      	cmp	r2, #64	; 0x40
	void timeKeeper () {
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_timeKeeper)) > 0) // Has the time expired?
		{ // Here, yes.
			t_timeKeeper += SIXTYFOURTH; 	// Set next toggle time

			count64++;
 80008e8:	f883 25d0 	strb.w	r2, [r3, #1488]	; 0x5d0

			if(count64 == 64) {
 80008ec:	d10b      	bne.n	8000906 <timeKeeper+0x3e>
				currentTime++;
 80008ee:	f8d3 25d4 	ldr.w	r2, [r3, #1492]	; 0x5d4
 80008f2:	3201      	adds	r2, #1
 80008f4:	f8c3 25d4 	str.w	r2, [r3, #1492]	; 0x5d4
				count64 = 0;
 80008f8:	2200      	movs	r2, #0
 80008fa:	f883 25d0 	strb.w	r2, [r3, #1488]	; 0x5d0
				timerMsgFlag = 2; // send 1 sec message
 80008fe:	3202      	adds	r2, #2
 8000900:	f883 25d8 	strb.w	r2, [r3, #1496]	; 0x5d8
 8000904:	4770      	bx	lr
			} else {
				timerMsgFlag = 1; // send 1/64th sec message
 8000906:	2201      	movs	r2, #1
 8000908:	f883 25d8 	strb.w	r2, [r3, #1496]	; 0x5d8
 800090c:	4770      	bx	lr
 800090e:	bf00      	nop
 8000910:	e0001004 	.word	0xe0001004
 8000914:	20001a80 	.word	0x20001a80
 8000918:	00280de8 	.word	0x00280de8
 800091c:	200007f8 	.word	0x200007f8

08000920 <spiInOut>:
		}
	}

	/* spi i/o */
	void spiInOut () {
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_spi)) > 0) {
 8000920:	4b0b      	ldr	r3, [pc, #44]	; (8000950 <spiInOut+0x30>)
 8000922:	6819      	ldr	r1, [r3, #0]
 8000924:	4b0b      	ldr	r3, [pc, #44]	; (8000954 <spiInOut+0x34>)
 8000926:	681a      	ldr	r2, [r3, #0]
 8000928:	1a89      	subs	r1, r1, r2
 800092a:	2900      	cmp	r1, #0
			}
		}
	}

	/* spi i/o */
	void spiInOut () {
 800092c:	b510      	push	{r4, lr}
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_spi)) > 0) {
 800092e:	dd0e      	ble.n	800094e <spiInOut+0x2e>
			t_spi += SPIPACE;
 8000930:	f502 224c 	add.w	r2, r2, #835584	; 0xcc000
 8000934:	f502 528a 	add.w	r2, r2, #4416	; 0x1140
 8000938:	601a      	str	r2, [r3, #0]

			if (spi2_busy() != 0) // Is SPI2 busy?
 800093a:	f004 fabd 	bl	8004eb8 <spi2_busy>
 800093e:	b130      	cbz	r0, 800094e <spiInOut+0x2e>
			{ // Here, no.
				spi2_rw(spi_ledout, spi_swin, SPI2SIZE); // Send/rcv three bytes
 8000940:	4805      	ldr	r0, [pc, #20]	; (8000958 <spiInOut+0x38>)
 8000942:	4906      	ldr	r1, [pc, #24]	; (800095c <spiInOut+0x3c>)
 8000944:	2203      	movs	r2, #3
			}
		}
	}
 8000946:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_spi)) > 0) {
			t_spi += SPIPACE;

			if (spi2_busy() != 0) // Is SPI2 busy?
			{ // Here, no.
				spi2_rw(spi_ledout, spi_swin, SPI2SIZE); // Send/rcv three bytes
 800094a:	f004 babd 	b.w	8004ec8 <spi2_rw>
 800094e:	bd10      	pop	{r4, pc}
 8000950:	e0001004 	.word	0xe0001004
 8000954:	200019c0 	.word	0x200019c0
 8000958:	20000004 	.word	0x20000004
 800095c:	200019c4 	.word	0x200019c4

08000960 <lcdOut>:
		}
	}

	/* LCD output routine */
	void lcdOut () {
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_lcd)) > 0) {
 8000960:	4b1b      	ldr	r3, [pc, #108]	; (80009d0 <lcdOut+0x70>)
			}
		}
	}

	/* LCD output routine */
	void lcdOut () {
 8000962:	b513      	push	{r0, r1, r4, lr}
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_lcd)) > 0) {
 8000964:	6819      	ldr	r1, [r3, #0]
 8000966:	4b1b      	ldr	r3, [pc, #108]	; (80009d4 <lcdOut+0x74>)
 8000968:	681a      	ldr	r2, [r3, #0]
 800096a:	1a89      	subs	r1, r1, r2
 800096c:	2900      	cmp	r1, #0
 800096e:	dd2d      	ble.n	80009cc <lcdOut+0x6c>
			t_lcd += LCDPACE;

			snprintf(lcdLine0, 20, "%16s%4d", "Current State:", currentState);
 8000970:	4c19      	ldr	r4, [pc, #100]	; (80009d8 <lcdOut+0x78>)
 8000972:	481a      	ldr	r0, [pc, #104]	; (80009dc <lcdOut+0x7c>)
	}

	/* LCD output routine */
	void lcdOut () {
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_lcd)) > 0) {
			t_lcd += LCDPACE;
 8000974:	f102 7280 	add.w	r2, r2, #16777216	; 0x1000000
 8000978:	f502 42b2 	add.w	r2, r2, #22784	; 0x5900
 800097c:	601a      	str	r2, [r3, #0]

			snprintf(lcdLine0, 20, "%16s%4d", "Current State:", currentState);
 800097e:	f8d4 35dc 	ldr.w	r3, [r4, #1500]	; 0x5dc
 8000982:	4a17      	ldr	r2, [pc, #92]	; (80009e0 <lcdOut+0x80>)
 8000984:	9300      	str	r3, [sp, #0]
 8000986:	2114      	movs	r1, #20
 8000988:	4b16      	ldr	r3, [pc, #88]	; (80009e4 <lcdOut+0x84>)
 800098a:	f006 f957 	bl	8006c3c <snprintf>
			snprintf(lcdLine1, 20, "outputTorque: %20f\0", outputTorque);
 800098e:	f8d4 05e0 	ldr.w	r0, [r4, #1504]	; 0x5e0
 8000992:	f005 fbd1 	bl	8006138 <__aeabi_f2d>
 8000996:	4a14      	ldr	r2, [pc, #80]	; (80009e8 <lcdOut+0x88>)
 8000998:	e9cd 0100 	strd	r0, r1, [sp]
 800099c:	2114      	movs	r1, #20
 800099e:	4813      	ldr	r0, [pc, #76]	; (80009ec <lcdOut+0x8c>)
 80009a0:	f006 f94c 	bl	8006c3c <snprintf>
			snprintf(lcdLine2, 20, "Time: %20d\0", currentTime);
 80009a4:	2114      	movs	r1, #20
 80009a6:	f8d4 35d4 	ldr.w	r3, [r4, #1492]	; 0x5d4
 80009aa:	4a11      	ldr	r2, [pc, #68]	; (80009f0 <lcdOut+0x90>)
 80009ac:	4811      	ldr	r0, [pc, #68]	; (80009f4 <lcdOut+0x94>)
 80009ae:	f006 f945 	bl	8006c3c <snprintf>
			// padString(' ', lcdLine1, 20);
			// padString(' ', lcdLine2, 20);
			// padString(' ', lcdLine3, 20);

			// display a char on the lcd
			lcd_printToLine(UXPRT, 0, lcdLine0);
 80009b2:	2006      	movs	r0, #6
 80009b4:	2100      	movs	r1, #0
 80009b6:	4a09      	ldr	r2, [pc, #36]	; (80009dc <lcdOut+0x7c>)
 80009b8:	f003 fdb3 	bl	8004522 <lcd_printToLine>
			// lcd_printToLine(UXPRT, 1, lcdLine1);
			lcd_printToLine(UXPRT, 2, lcdLine2);
 80009bc:	4a0d      	ldr	r2, [pc, #52]	; (80009f4 <lcdOut+0x94>)
 80009be:	2006      	movs	r0, #6
 80009c0:	2102      	movs	r1, #2
			// lcd_printToLine(UXPRT, 3, lcdLine3);
		}
	}
 80009c2:	b002      	add	sp, #8
 80009c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			// padString(' ', lcdLine3, 20);

			// display a char on the lcd
			lcd_printToLine(UXPRT, 0, lcdLine0);
			// lcd_printToLine(UXPRT, 1, lcdLine1);
			lcd_printToLine(UXPRT, 2, lcdLine2);
 80009c8:	f003 bdab 	b.w	8004522 <lcd_printToLine>
			// lcd_printToLine(UXPRT, 3, lcdLine3);
		}
	}
 80009cc:	b002      	add	sp, #8
 80009ce:	bd10      	pop	{r4, pc}
 80009d0:	e0001004 	.word	0xe0001004
 80009d4:	20001a7c 	.word	0x20001a7c
 80009d8:	200007f8 	.word	0x200007f8
 80009dc:	200019e4 	.word	0x200019e4
 80009e0:	0800d115 	.word	0x0800d115
 80009e4:	0800d11d 	.word	0x0800d11d
 80009e8:	0800cd10 	.word	0x0800cd10
 80009ec:	20001a84 	.word	0x20001a84
 80009f0:	0800cd24 	.word	0x0800cd24
 80009f4:	200019c7 	.word	0x200019c7

080009f8 <stateZero>:

	void stateZero () {
		// TODO: check for conditions that progress the state
		if (currentTime > 60) {
 80009f8:	4b04      	ldr	r3, [pc, #16]	; (8000a0c <stateZero+0x14>)
 80009fa:	f8d3 25d4 	ldr.w	r2, [r3, #1492]	; 0x5d4
 80009fe:	2a3c      	cmp	r2, #60	; 0x3c
 8000a00:	d902      	bls.n	8000a08 <stateZero+0x10>
			nextState = 1;
 8000a02:	2201      	movs	r2, #1
 8000a04:	f8c3 25e4 	str.w	r2, [r3, #1508]	; 0x5e4
 8000a08:	4770      	bx	lr
 8000a0a:	bf00      	nop
 8000a0c:	200007f8 	.word	0x200007f8

08000a10 <stateOne>:
		}
	}

	void stateOne () {

	}
 8000a10:	4770      	bx	lr

08000a12 <stateMachine>:

	/* State Machine */
	void stateMachine () {
		currentState = nextState;
 8000a12:	4a04      	ldr	r2, [pc, #16]	; (8000a24 <stateMachine+0x12>)
 8000a14:	f8d2 35e4 	ldr.w	r3, [r2, #1508]	; 0x5e4
 8000a18:	f8c2 35dc 	str.w	r3, [r2, #1500]	; 0x5dc

		switch(currentState) {
 8000a1c:	b903      	cbnz	r3, 8000a20 <stateMachine+0xe>
			case 0:
				stateZero();
 8000a1e:	e7eb      	b.n	80009f8 <stateZero>
 8000a20:	4770      	bx	lr
 8000a22:	bf00      	nop
 8000a24:	200007f8 	.word	0x200007f8

08000a28 <desiredTensionSpeed>:
				break;
		}
	}

	void desiredTensionSpeed () {
		desiredSpeed = 1;
 8000a28:	4b04      	ldr	r3, [pc, #16]	; (8000a3c <desiredTensionSpeed+0x14>)
 8000a2a:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8000a2e:	f8c3 25e8 	str.w	r2, [r3, #1512]	; 0x5e8
		desiredTension = 2;
 8000a32:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8000a36:	f8c3 25ec 	str.w	r2, [r3, #1516]	; 0x5ec
	}
 8000a3a:	4770      	bx	lr
 8000a3c:	200007f8 	.word	0x200007f8

08000a40 <controlLaw>:

	void controlLaw () {
 8000a40:	b510      	push	{r4, lr}
		if (currentState == 0) {
 8000a42:	4c08      	ldr	r4, [pc, #32]	; (8000a64 <controlLaw+0x24>)
 8000a44:	f8d4 35dc 	ldr.w	r3, [r4, #1500]	; 0x5dc
 8000a48:	b913      	cbnz	r3, 8000a50 <controlLaw+0x10>
			outputTorque = 0.5 * desiredSpeed;
 8000a4a:	f8d4 05e8 	ldr.w	r0, [r4, #1512]	; 0x5e8
 8000a4e:	e001      	b.n	8000a54 <controlLaw+0x14>
		} else {
			outputTorque = 0.5 * desiredTension;
 8000a50:	f8d4 05ec 	ldr.w	r0, [r4, #1516]	; 0x5ec
 8000a54:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8000a58:	f005 fbc2 	bl	80061e0 <__aeabi_fmul>
 8000a5c:	f8c4 05e0 	str.w	r0, [r4, #1504]	; 0x5e0
 8000a60:	bd10      	pop	{r4, pc}
 8000a62:	bf00      	nop
 8000a64:	200007f8 	.word	0x200007f8

08000a68 <usbInput>:
	// messages here are from the pc. We need to parse and forward to the CANbus
	void usbInput () {
		int tmp;
		int temp;

		temp=USB_PC_get_msg_mode(STDIN_FILENO, &gatewayToPC, &canrcvbuf);	// Check if msg is ready
 8000a68:	490c      	ldr	r1, [pc, #48]	; (8000a9c <usbInput+0x34>)
		}
	}

	/* ================ PC --> CAN ================================================================= */
	// messages here are from the pc. We need to parse and forward to the CANbus
	void usbInput () {
 8000a6a:	b510      	push	{r4, lr}
		int tmp;
		int temp;

		temp=USB_PC_get_msg_mode(STDIN_FILENO, &gatewayToPC, &canrcvbuf);	// Check if msg is ready
 8000a6c:	2000      	movs	r0, #0
 8000a6e:	f101 0280 	add.w	r2, r1, #128	; 0x80
 8000a72:	f003 fc27 	bl	80042c4 <USB_PC_get_msg_mode>
		if (temp != 0)	// Do we have completion of a msg?
 8000a76:	b178      	cbz	r0, 8000a98 <usbInput+0x30>
		{ // Here, yes.  We have a msg, but it might not be valid.
			if ( temp == 1 ) // Was valid?
 8000a78:	2801      	cmp	r0, #1
 8000a7a:	d109      	bne.n	8000a90 <usbInput+0x28>
				{ // Here, msg is OK msg from the PC

					// TODO: filter message id's that require the MC to do something

					// Take the message and send it over CAN
					tmp = CAN_gateway_send(&canrcvbuf);	// Add to xmit buffer (if OK)
 8000a7c:	4808      	ldr	r0, [pc, #32]	; (8000aa0 <usbInput+0x38>)
 8000a7e:	f004 f9c3 	bl	8004e08 <CAN_gateway_send>
					Errors_CAN_gateway_send(tmp);		// Count any error returns					
 8000a82:	f000 f963 	bl	8000d4c <Errors_CAN_gateway_send>
					PC_msg_initg(&gatewayToPC);	// Initialize struct for next msg from PC to gateway
 8000a86:	4805      	ldr	r0, [pc, #20]	; (8000a9c <usbInput+0x34>)
			else
			{ // Something wrong with the msg.  Count the various types of error returns from 'USB_PC_msg_getASCII'
				Errors_USB_PC_get_msg_mode(temp);
			} // Note: 'pctogateway' gets re-intialized in 'PC_msg_initg' when there are errors.
		}
	}
 8000a88:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
					// TODO: filter message id's that require the MC to do something

					// Take the message and send it over CAN
					tmp = CAN_gateway_send(&canrcvbuf);	// Add to xmit buffer (if OK)
					Errors_CAN_gateway_send(tmp);		// Count any error returns					
					PC_msg_initg(&gatewayToPC);	// Initialize struct for next msg from PC to gateway
 8000a8c:	f003 b9a1 	b.w	8003dd2 <PC_msg_initg>
			else
			{ // Something wrong with the msg.  Count the various types of error returns from 'USB_PC_msg_getASCII'
				Errors_USB_PC_get_msg_mode(temp);
			} // Note: 'pctogateway' gets re-intialized in 'PC_msg_initg' when there are errors.
		}
	}
 8000a90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
					PC_msg_initg(&gatewayToPC);	// Initialize struct for next msg from PC to gateway
				}
			}
			else
			{ // Something wrong with the msg.  Count the various types of error returns from 'USB_PC_msg_getASCII'
				Errors_USB_PC_get_msg_mode(temp);
 8000a94:	f000 b94a 	b.w	8000d2c <Errors_USB_PC_get_msg_mode>
 8000a98:	bd10      	pop	{r4, pc}
 8000a9a:	bf00      	nop
 8000a9c:	20000d68 	.word	0x20000d68
 8000aa0:	20000de8 	.word	0x20000de8

08000aa4 <canInput>:
		}
	}

	/* ================= CAN --> PC ================================================================= */
	// messages here are from the CANbus. We need to parse and forward to the PC
	void canInput () {
 8000aa4:	b510      	push	{r4, lr}
		while ( (pfifo1 = canrcvtim_get_ldr()) != 0)	// Did we receive a HIGH PRIORITY CAN BUS msg?
 8000aa6:	e002      	b.n	8000aae <canInput+0xa>
		{ // Here yes.  Retrieve it from the CAN buffer and save it in our vast mainline storage buffer ;)
			canbuf_add(&pfifo1->R);	// Add msg to buffer
 8000aa8:	3008      	adds	r0, #8
 8000aaa:	f7ff fb72 	bl	8000192 <canbuf_add>
	}

	/* ================= CAN --> PC ================================================================= */
	// messages here are from the CANbus. We need to parse and forward to the PC
	void canInput () {
		while ( (pfifo1 = canrcvtim_get_ldr()) != 0)	// Did we receive a HIGH PRIORITY CAN BUS msg?
 8000aae:	f003 ffaf 	bl	8004a10 <canrcvtim_get_ldr>
 8000ab2:	4c07      	ldr	r4, [pc, #28]	; (8000ad0 <canInput+0x2c>)
 8000ab4:	f8c4 0600 	str.w	r0, [r4, #1536]	; 0x600
 8000ab8:	2800      	cmp	r0, #0
 8000aba:	d1f5      	bne.n	8000aa8 <canInput+0x4>
 8000abc:	e001      	b.n	8000ac2 <canInput+0x1e>
			// TODO: filter message id's that require the MC to do something
		}

		while ( (pfifo0 = canrcv_get_ldr()) != 0)		// Did we receive a LESS-THAN-HIGH-PRIORITY CAN BUS msg?
		{ // Here yes.  Retrieve it from the CAN buffer and save it in our vast mainline storage buffer.
			canbuf_add(pfifo0);	// Add msg to buffer
 8000abe:	f7ff fb68 	bl	8000192 <canbuf_add>
			canbuf_add(&pfifo1->R);	// Add msg to buffer

			// TODO: filter message id's that require the MC to do something
		}

		while ( (pfifo0 = canrcv_get_ldr()) != 0)		// Did we receive a LESS-THAN-HIGH-PRIORITY CAN BUS msg?
 8000ac2:	f003 ff8f 	bl	80049e4 <canrcv_get_ldr>
 8000ac6:	f8c4 0604 	str.w	r0, [r4, #1540]	; 0x604
 8000aca:	2800      	cmp	r0, #0
 8000acc:	d1f7      	bne.n	8000abe <canInput+0x1a>
		{ // Here yes.  Retrieve it from the CAN buffer and save it in our vast mainline storage buffer.
			canbuf_add(pfifo0);	// Add msg to buffer

			// TODO: filter message id's that require the MC to do something
		}
	}
 8000ace:	bd10      	pop	{r4, pc}
 8000ad0:	200007f8 	.word	0x200007f8

08000ad4 <usbOutput>:

	void usbOutput () {
 8000ad4:	b510      	push	{r4, lr}
		/* Send buffered msgs to PC */
		while (canbufidxi != canbufidxm)	// Set up all the buffered msgs until we are caught up.				
 8000ad6:	e014      	b.n	8000b02 <usbOutput+0x2e>
		{ // Here, yes.  Set up a buffered msg from the CAN bus to go to the PC.
			pctogateway.cmprs.seq = canmsgct[canbufidxm];		// Add sequence number (for PC checking for missing msgs)
 8000ad8:	eb04 0283 	add.w	r2, r4, r3, lsl #2
			USB_toPC_msg_mode(STDOUT_FILENO, &pctogateway, &canbuf[canbufidxm]); 	// Send to PC via STDOUT
 8000adc:	f504 61a2 	add.w	r1, r4, #1296	; 0x510

	void usbOutput () {
		/* Send buffered msgs to PC */
		while (canbufidxi != canbufidxm)	// Set up all the buffered msgs until we are caught up.				
		{ // Here, yes.  Set up a buffered msg from the CAN bus to go to the PC.
			pctogateway.cmprs.seq = canmsgct[canbufidxm];		// Add sequence number (for PC checking for missing msgs)
 8000ae0:	f8d2 240c 	ldr.w	r2, [r2, #1036]	; 0x40c
 8000ae4:	f884 256e 	strb.w	r2, [r4, #1390]	; 0x56e
			USB_toPC_msg_mode(STDOUT_FILENO, &pctogateway, &canbuf[canbufidxm]); 	// Send to PC via STDOUT
 8000ae8:	f104 0208 	add.w	r2, r4, #8
 8000aec:	eb02 1203 	add.w	r2, r2, r3, lsl #4
 8000af0:	2001      	movs	r0, #1
 8000af2:	f003 fc81 	bl	80043f8 <USB_toPC_msg_mode>
			canbufidxm = incIdx(canbufidxm);			// Advance outgoing buffer index.
 8000af6:	f8d4 050c 	ldr.w	r0, [r4, #1292]	; 0x50c
 8000afa:	f7ff fb45 	bl	8000188 <incIdx>
 8000afe:	f8c4 050c 	str.w	r0, [r4, #1292]	; 0x50c
		}
	}

	void usbOutput () {
		/* Send buffered msgs to PC */
		while (canbufidxi != canbufidxm)	// Set up all the buffered msgs until we are caught up.				
 8000b02:	4c03      	ldr	r4, [pc, #12]	; (8000b10 <usbOutput+0x3c>)
 8000b04:	f8d4 350c 	ldr.w	r3, [r4, #1292]	; 0x50c
 8000b08:	6822      	ldr	r2, [r4, #0]
 8000b0a:	429a      	cmp	r2, r3
 8000b0c:	d1e4      	bne.n	8000ad8 <usbOutput+0x4>
		{ // Here, yes.  Set up a buffered msg from the CAN bus to go to the PC.
			pctogateway.cmprs.seq = canmsgct[canbufidxm];		// Add sequence number (for PC checking for missing msgs)
			USB_toPC_msg_mode(STDOUT_FILENO, &pctogateway, &canbuf[canbufidxm]); 	// Send to PC via STDOUT
			canbufidxm = incIdx(canbufidxm);			// Advance outgoing buffer index.
		}
	}
 8000b0e:	bd10      	pop	{r4, pc}
 8000b10:	200007f8 	.word	0x200007f8

08000b14 <canOutput>:

	// check flags and send out appropriate messages
	void canOutput () {
 8000b14:	b530      	push	{r4, r5, lr}
		struct CANRCVBUF can;
		int tmp;

		if (timerMsgFlag == 1) { // every 1/64 second
 8000b16:	4c19      	ldr	r4, [pc, #100]	; (8000b7c <canOutput+0x68>)
 8000b18:	f894 55d8 	ldrb.w	r5, [r4, #1496]	; 0x5d8
 8000b1c:	2d01      	cmp	r5, #1
			canbufidxm = incIdx(canbufidxm);			// Advance outgoing buffer index.
		}
	}

	// check flags and send out appropriate messages
	void canOutput () {
 8000b1e:	b085      	sub	sp, #20
		struct CANRCVBUF can;
		int tmp;

		if (timerMsgFlag == 1) { // every 1/64 second
 8000b20:	d115      	bne.n	8000b4e <canOutput+0x3a>
			can.id       = 0x20000000; // time id
 8000b22:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 8000b26:	9300      	str	r3, [sp, #0]
			can.dlc      = 0x00000001;
			can.cd.us[0] = count64;
 8000b28:	f894 35d0 	ldrb.w	r3, [r4, #1488]	; 0x5d0
		struct CANRCVBUF can;
		int tmp;

		if (timerMsgFlag == 1) { // every 1/64 second
			can.id       = 0x20000000; // time id
			can.dlc      = 0x00000001;
 8000b2c:	9501      	str	r5, [sp, #4]
			can.cd.us[0] = count64;

			tmp = CAN_gateway_send(&can);
 8000b2e:	4668      	mov	r0, sp
		int tmp;

		if (timerMsgFlag == 1) { // every 1/64 second
			can.id       = 0x20000000; // time id
			can.dlc      = 0x00000001;
			can.cd.us[0] = count64;
 8000b30:	f8ad 3008 	strh.w	r3, [sp, #8]

			tmp = CAN_gateway_send(&can);
 8000b34:	f004 f968 	bl	8004e08 <CAN_gateway_send>
			canbuf_add(&can);
 8000b38:	4668      	mov	r0, sp
 8000b3a:	f7ff fb2a 	bl	8000192 <canbuf_add>

			can.id       = 0x21400000; // torque
 8000b3e:	f04f 5305 	mov.w	r3, #557842432	; 0x21400000
 8000b42:	9300      	str	r3, [sp, #0]
			can.dlc      = 0x00000002;
 8000b44:	2302      	movs	r3, #2
 8000b46:	9301      	str	r3, [sp, #4]
			can.cd.us[0] = 0x0001;
 8000b48:	f8ad 5008 	strh.w	r5, [sp, #8]
 8000b4c:	e00a      	b.n	8000b64 <canOutput+0x50>

			tmp = CAN_gateway_send(&can);
			canbuf_add(&can);

			timerMsgFlag = 0;
		} else if (timerMsgFlag == 2) { // every second
 8000b4e:	2d02      	cmp	r5, #2
 8000b50:	d111      	bne.n	8000b76 <canOutput+0x62>
			can.id       = 0x20000000;
 8000b52:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 8000b56:	9300      	str	r3, [sp, #0]
			can.dlc      = 0x00000004;
 8000b58:	2304      	movs	r3, #4
 8000b5a:	9301      	str	r3, [sp, #4]
			can.cd.us[0] = currentTime;
 8000b5c:	f8b4 35d4 	ldrh.w	r3, [r4, #1492]	; 0x5d4
 8000b60:	f8ad 3008 	strh.w	r3, [sp, #8]

			tmp = CAN_gateway_send(&can);
 8000b64:	4668      	mov	r0, sp
 8000b66:	f004 f94f 	bl	8004e08 <CAN_gateway_send>
			canbuf_add(&can);
 8000b6a:	4668      	mov	r0, sp
 8000b6c:	f7ff fb11 	bl	8000192 <canbuf_add>

			timerMsgFlag = 0;
 8000b70:	2300      	movs	r3, #0
 8000b72:	f884 35d8 	strb.w	r3, [r4, #1496]	; 0x5d8
		}
	}
 8000b76:	b005      	add	sp, #20
 8000b78:	bd30      	pop	{r4, r5, pc}
 8000b7a:	bf00      	nop
 8000b7c:	200007f8 	.word	0x200007f8

08000b80 <main>:

/*#################################################################################################
And now for the main routine 
  #################################################################################################*/
int main(void)
{
 8000b80:	b508      	push	{r3, lr}
	// initialize
	initMasterController();
 8000b82:	f7ff fe0d 	bl	80007a0 <initMasterController>

/* --------------------- Endless Polling Loop ----------------------------------------------- */
	while (1==1)
	{
		ledHeartbeat();
 8000b86:	f7ff fe8b 	bl	80008a0 <ledHeartbeat>
		timeKeeper();
 8000b8a:	f7ff fe9d 	bl	80008c8 <timeKeeper>
		
		// Gateway functionality (also catches messages for the MC)
		usbInput();
 8000b8e:	f7ff ff6b 	bl	8000a68 <usbInput>
		canInput();
 8000b92:	f7ff ff87 	bl	8000aa4 <canInput>

		stateMachine();
 8000b96:	f7ff ff3c 	bl	8000a12 <stateMachine>
		desiredTensionSpeed();
 8000b9a:	f7ff ff45 	bl	8000a28 <desiredTensionSpeed>
		controlLaw();
 8000b9e:	f7ff ff4f 	bl	8000a40 <controlLaw>

		// Send any messages the MC needs over CAN
		canOutput();
 8000ba2:	f7ff ffb7 	bl	8000b14 <canOutput>
		usbOutput();
 8000ba6:	f7ff ff95 	bl	8000ad4 <usbOutput>

		// SPI - led output & switch input
		spiInOut();
 8000baa:	f7ff feb9 	bl	8000920 <spiInOut>
		lcdOut();
 8000bae:	f7ff fed7 	bl	8000960 <lcdOut>
 8000bb2:	e7e8      	b.n	8000b86 <main+0x6>
 8000bb4:	0800d244 	.word	0x0800d244
 8000bb8:	20000000 	.word	0x20000000
 8000bbc:	200007f8 	.word	0x200007f8
 8000bc0:	200007f8 	.word	0x200007f8
 8000bc4:	20002a90 	.word	0x20002a90

08000bc8 <_close>:

int __errno;

int _close(int file) {
	return 0;
}
 8000bc8:	2000      	movs	r0, #0
 8000bca:	4770      	bx	lr

08000bcc <_fstat>:

int _fstat(int file, struct stat *st) {
	return 0;
}
 8000bcc:	2000      	movs	r0, #0
 8000bce:	4770      	bx	lr

08000bd0 <_isatty>:

int _isatty(int file) {
	return 1;
}
 8000bd0:	2001      	movs	r0, #1
 8000bd2:	4770      	bx	lr

08000bd4 <_lseek>:

int _lseek(int file, int ptr, int dir) {
	return 0;
}
 8000bd4:	2000      	movs	r0, #0
 8000bd6:	4770      	bx	lr

08000bd8 <_open>:



int _open(const char *name, int flags, int mode) {
 8000bd8:	b538      	push	{r3, r4, r5, lr}
	void* pret;
	int i;

	if (i_cur >= FD_OPNMAX) return -1;// No free slots check
 8000bda:	4d0b      	ldr	r5, [pc, #44]	; (8000c08 <_open+0x30>)
 8000bdc:	682c      	ldr	r4, [r5, #0]
 8000bde:	2c0b      	cmp	r4, #11
 8000be0:	dc0d      	bgt.n	8000bfe <_open+0x26>

	i = i_cur;

	/* Check if there is someone out there with this name */
	pret = (struct CB_UART*)bsp_uart_open(name); // Check USART/UARTs
 8000be2:	f004 fd2b 	bl	800563c <bsp_uart_open>
	if (pret != 0) 
 8000be6:	b150      	cbz	r0, 8000bfe <_open+0x26>
	{ // Here, bsp_uart found the name and returned a control blk ptr
		fd_opn[i].pv = pret;
 8000be8:	4b08      	ldr	r3, [pc, #32]	; (8000c0c <_open+0x34>)
 8000bea:	f843 0034 	str.w	r0, [r3, r4, lsl #3]
		fd_opn[i].dev = 0;	// USART/UART group
 8000bee:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 8000bf2:	2200      	movs	r2, #0
 8000bf4:	605a      	str	r2, [r3, #4]
		i_cur += 1;
 8000bf6:	682b      	ldr	r3, [r5, #0]
 8000bf8:	3301      	adds	r3, #1
 8000bfa:	602b      	str	r3, [r5, #0]
		return (i);
 8000bfc:	e001      	b.n	8000c02 <_open+0x2a>
	}
	// Place calls for others here, e.g. usb (device code 0)
	return -1;		// Nobody recognizes this name
 8000bfe:	f04f 34ff 	mov.w	r4, #4294967295
}
 8000c02:	4620      	mov	r0, r4
 8000c04:	bd38      	pop	{r3, r4, r5, pc}
 8000c06:	bf00      	nop
 8000c08:	20000e00 	.word	0x20000e00
 8000c0c:	20001aac 	.word	0x20001aac

08000c10 <_read>:

int _read(int fd, char *ptr, int len) {
 8000c10:	b510      	push	{r4, lr}
	char* p = ptr;
//	if (fd > FD_OPNMAX) return -1;
	if (fd != 0) return -1;
 8000c12:	b938      	cbnz	r0, 8000c24 <_read+0x14>

	if (fd_opn[fd].dev == 0) // Is it a USART/UART?
 8000c14:	4b05      	ldr	r3, [pc, #20]	; (8000c2c <_read+0x1c>)
 8000c16:	685c      	ldr	r4, [r3, #4]
 8000c18:	b934      	cbnz	r4, 8000c28 <_read+0x18>
		return bsp_uart_getn_ptr((struct CB_UART*)fd_opn[fd].pv, ptr, len);
 8000c1a:	6818      	ldr	r0, [r3, #0]
//		while(VCP_get_char_test()  &&  len > 0) 
//		{VCP_get_char((u8*)p++); len -= 1;}
//	}
	
	return p - ptr;
}
 8000c1c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	char* p = ptr;
//	if (fd > FD_OPNMAX) return -1;
	if (fd != 0) return -1;

	if (fd_opn[fd].dev == 0) // Is it a USART/UART?
		return bsp_uart_getn_ptr((struct CB_UART*)fd_opn[fd].pv, ptr, len);
 8000c20:	f004 bedc 	b.w	80059dc <bsp_uart_getn_ptr>
}

int _read(int fd, char *ptr, int len) {
	char* p = ptr;
//	if (fd > FD_OPNMAX) return -1;
	if (fd != 0) return -1;
 8000c24:	f04f 30ff 	mov.w	r0, #4294967295
//		while(VCP_get_char_test()  &&  len > 0) 
//		{VCP_get_char((u8*)p++); len -= 1;}
//	}
	
	return p - ptr;
}
 8000c28:	bd10      	pop	{r4, pc}
 8000c2a:	bf00      	nop
 8000c2c:	20001aac 	.word	0x20001aac

08000c30 <_sbrk_r>:
caddr_t _sbrk_r (struct _reent *r, int incr) {
	extern char   end asm ("end"); /* Defined by the linker.  */
	static char * heap_end;
	char *        prev_heap_end;

	if (heap_end == NULL)
 8000c30:	4b07      	ldr	r3, [pc, #28]	; (8000c50 <_sbrk_r+0x20>)
 8000c32:	685a      	ldr	r2, [r3, #4]
 8000c34:	b90a      	cbnz	r2, 8000c3a <_sbrk_r+0xa>
		heap_end = & end;
 8000c36:	4a07      	ldr	r2, [pc, #28]	; (8000c54 <_sbrk_r+0x24>)
 8000c38:	605a      	str	r2, [r3, #4]

	prev_heap_end = heap_end;
 8000c3a:	6858      	ldr	r0, [r3, #4]

	if (heap_end + incr > stack_ptr) {
 8000c3c:	466b      	mov	r3, sp
 8000c3e:	1841      	adds	r1, r0, r1
 8000c40:	4299      	cmp	r1, r3
		//errno = ENOMEM;
		return (caddr_t) -1;
	}

	heap_end += incr;
 8000c42:	bf96      	itet	ls
 8000c44:	4b02      	ldrls	r3, [pc, #8]	; (8000c50 <_sbrk_r+0x20>)

	prev_heap_end = heap_end;

	if (heap_end + incr > stack_ptr) {
		//errno = ENOMEM;
		return (caddr_t) -1;
 8000c46:	f04f 30ff 	movhi.w	r0, #4294967295
	}

	heap_end += incr;
 8000c4a:	6059      	strls	r1, [r3, #4]

	return (caddr_t) prev_heap_end;
}
 8000c4c:	4770      	bx	lr
 8000c4e:	bf00      	nop
 8000c50:	20000e00 	.word	0x20000e00
 8000c54:	20002a90 	.word	0x20002a90

08000c58 <_write>:

int _write(int fd, char *ptr, int len) 
{
	if ((fd == 1) || (fd == 2))
 8000c58:	3801      	subs	r0, #1
 8000c5a:	2801      	cmp	r0, #1

	return (caddr_t) prev_heap_end;
}

int _write(int fd, char *ptr, int len) 
{
 8000c5c:	b510      	push	{r4, lr}
 8000c5e:	4613      	mov	r3, r2
	if ((fd == 1) || (fd == 2))
 8000c60:	d807      	bhi.n	8000c72 <_write+0x1a>
	{
/* Map either 1 or 2 into 0, since that holds the control block pointer. */
		if (fd_opn[0].dev == 0) // Is it a USART/UART?
 8000c62:	4805      	ldr	r0, [pc, #20]	; (8000c78 <_write+0x20>)
 8000c64:	6844      	ldr	r4, [r0, #4]
 8000c66:	b924      	cbnz	r4, 8000c72 <_write+0x1a>
		{return bsp_uart_putn_ptr((struct CB_UART*)fd_opn[0].pv, ptr, len);}
 8000c68:	6800      	ldr	r0, [r0, #0]
	}	
//		// USB equivalent goes here-----
//	VCP_send_buffer((u8*)ptr, len); 
	return len;
}
 8000c6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
	if ((fd == 1) || (fd == 2))
	{
/* Map either 1 or 2 into 0, since that holds the control block pointer. */
		if (fd_opn[0].dev == 0) // Is it a USART/UART?
		{return bsp_uart_putn_ptr((struct CB_UART*)fd_opn[0].pv, ptr, len);}
 8000c6e:	f004 bf43 	b.w	8005af8 <bsp_uart_putn_ptr>
	}	
//		// USB equivalent goes here-----
//	VCP_send_buffer((u8*)ptr, len); 
	return len;
}
 8000c72:	4618      	mov	r0, r3
 8000c74:	bd10      	pop	{r4, pc}
 8000c76:	bf00      	nop
 8000c78:	20001aac 	.word	0x20001aac

08000c7c <CAN_test_msg_init>:
 * void CAN_test_msg_init(void);
 * @brief	: Initialize time for generating time msgs
 * ************************************************************************************** */
void CAN_test_msg_init(void)
{
	t_dly_pc  = *(volatile unsigned int *)0xE0001004 + CANTESTINC_PC;
 8000c7c:	4904      	ldr	r1, [pc, #16]	; (8000c90 <CAN_test_msg_init+0x14>)
 8000c7e:	4a05      	ldr	r2, [pc, #20]	; (8000c94 <CAN_test_msg_init+0x18>)
 8000c80:	6808      	ldr	r0, [r1, #0]
 8000c82:	4b05      	ldr	r3, [pc, #20]	; (8000c98 <CAN_test_msg_init+0x1c>)
 8000c84:	1880      	adds	r0, r0, r2
 8000c86:	6018      	str	r0, [r3, #0]
	t_dly_can = *(volatile unsigned int *)0xE0001004 + CANTESTINC_CAN;
 8000c88:	6809      	ldr	r1, [r1, #0]
 8000c8a:	188a      	adds	r2, r1, r2
 8000c8c:	605a      	str	r2, [r3, #4]
	return;
}
 8000c8e:	4770      	bx	lr
 8000c90:	e0001004 	.word	0xe0001004
 8000c94:	058b1140 	.word	0x058b1140
 8000c98:	20000e08 	.word	0x20000e08

08000c9c <CAN_test_msg_PC>:

struct CANRCVBUF* CAN_test_msg_PC(void)
{
//return 0; // NO MSGS
	/* Is it time to send a new round of msgs? */
	if (((int)(*(volatile unsigned int *)0xE0001004 - t_dly_pc)) > 0)
 8000c9c:	4b0c      	ldr	r3, [pc, #48]	; (8000cd0 <CAN_test_msg_PC+0x34>)
 8000c9e:	490d      	ldr	r1, [pc, #52]	; (8000cd4 <CAN_test_msg_PC+0x38>)
 8000ca0:	681b      	ldr	r3, [r3, #0]
 8000ca2:	6808      	ldr	r0, [r1, #0]
 8000ca4:	4a0c      	ldr	r2, [pc, #48]	; (8000cd8 <CAN_test_msg_PC+0x3c>)
 8000ca6:	1a1b      	subs	r3, r3, r0
 8000ca8:	2b00      	cmp	r3, #0
 8000caa:	dd04      	ble.n	8000cb6 <CAN_test_msg_PC+0x1a>
	{ // Here, yes.
		t_dly_pc += CANTESTINC_PC;	// Compute next time
 8000cac:	4b0b      	ldr	r3, [pc, #44]	; (8000cdc <CAN_test_msg_PC+0x40>)
 8000cae:	18c3      	adds	r3, r0, r3
 8000cb0:	600b      	str	r3, [r1, #0]
		idx = 0;
 8000cb2:	2300      	movs	r3, #0
 8000cb4:	6013      	str	r3, [r2, #0]
	}
	if (idx >= CANTESTNUMBER_PC) return 0;
 8000cb6:	6813      	ldr	r3, [r2, #0]
 8000cb8:	2b04      	cmp	r3, #4
 8000cba:	dc06      	bgt.n	8000cca <CAN_test_msg_PC+0x2e>
	return (struct CANRCVBUF*)&canPC[idx++];	
 8000cbc:	4808      	ldr	r0, [pc, #32]	; (8000ce0 <CAN_test_msg_PC+0x44>)
 8000cbe:	4a06      	ldr	r2, [pc, #24]	; (8000cd8 <CAN_test_msg_PC+0x3c>)
 8000cc0:	eb00 1003 	add.w	r0, r0, r3, lsl #4
 8000cc4:	3301      	adds	r3, #1
 8000cc6:	6013      	str	r3, [r2, #0]
 8000cc8:	4770      	bx	lr
	if (((int)(*(volatile unsigned int *)0xE0001004 - t_dly_pc)) > 0)
	{ // Here, yes.
		t_dly_pc += CANTESTINC_PC;	// Compute next time
		idx = 0;
	}
	if (idx >= CANTESTNUMBER_PC) return 0;
 8000cca:	2000      	movs	r0, #0
	return (struct CANRCVBUF*)&canPC[idx++];	
}
 8000ccc:	4770      	bx	lr
 8000cce:	bf00      	nop
 8000cd0:	e0001004 	.word	0xe0001004
 8000cd4:	20000e08 	.word	0x20000e08
 8000cd8:	20000008 	.word	0x20000008
 8000cdc:	058b1140 	.word	0x058b1140
 8000ce0:	0800cd30 	.word	0x0800cd30

08000ce4 <CAN_test_msg_CAN>:
struct CANRCVBUF* CAN_test_msg_CAN(void)
{
//return 0; // NO MSGS

	/* Is it time to send a msg? */
	if (((int)(*(volatile unsigned int *)0xE0001004 - t_dly_can)) > 0)
 8000ce4:	4b0c      	ldr	r3, [pc, #48]	; (8000d18 <CAN_test_msg_CAN+0x34>)
 8000ce6:	4a0d      	ldr	r2, [pc, #52]	; (8000d1c <CAN_test_msg_CAN+0x38>)
 8000ce8:	681b      	ldr	r3, [r3, #0]
 8000cea:	6851      	ldr	r1, [r2, #4]
 8000cec:	1a5b      	subs	r3, r3, r1
 8000cee:	2b00      	cmp	r3, #0
 8000cf0:	dd0f      	ble.n	8000d12 <CAN_test_msg_CAN+0x2e>
	{ // Here, yes.
		t_dly_can += CANTESTINC_CAN;	// Compute next time
 8000cf2:	4b0b      	ldr	r3, [pc, #44]	; (8000d20 <CAN_test_msg_CAN+0x3c>)
 8000cf4:	18cb      	adds	r3, r1, r3
 8000cf6:	6053      	str	r3, [r2, #4]
		idx1 += 1; if (idx1 >= CANTESTNUMBER_CAN) idx1 = 0;
 8000cf8:	4b0a      	ldr	r3, [pc, #40]	; (8000d24 <CAN_test_msg_CAN+0x40>)
 8000cfa:	685a      	ldr	r2, [r3, #4]
 8000cfc:	3201      	adds	r2, #1
 8000cfe:	2a03      	cmp	r2, #3
 8000d00:	605a      	str	r2, [r3, #4]
 8000d02:	dd01      	ble.n	8000d08 <CAN_test_msg_CAN+0x24>
 8000d04:	2200      	movs	r2, #0
 8000d06:	605a      	str	r2, [r3, #4]
		return (struct CANRCVBUF*)&canCAN[idx1];
 8000d08:	6858      	ldr	r0, [r3, #4]
 8000d0a:	4b07      	ldr	r3, [pc, #28]	; (8000d28 <CAN_test_msg_CAN+0x44>)
 8000d0c:	eb03 1000 	add.w	r0, r3, r0, lsl #4
 8000d10:	4770      	bx	lr
	}
	return 0;	
 8000d12:	2000      	movs	r0, #0
}
 8000d14:	4770      	bx	lr
 8000d16:	bf00      	nop
 8000d18:	e0001004 	.word	0xe0001004
 8000d1c:	20000e08 	.word	0x20000e08
 8000d20:	058b1140 	.word	0x058b1140
 8000d24:	20000008 	.word	0x20000008
 8000d28:	0800cd80 	.word	0x0800cd80

08000d2c <Errors_USB_PC_get_msg_mode>:
 * @brief	: Count errors
 * @param	: Subroutine return from: USB_PC_get_msg_mode
 * ************************************************************************************** */
void Errors_USB_PC_get_msg_mode(int x)
{
	if ( x > 0 ) return; // Expect negative numbers
 8000d2c:	2800      	cmp	r0, #0
 8000d2e:	dc09      	bgt.n	8000d44 <Errors_USB_PC_get_msg_mode+0x18>
	x = 1 - x; // Make -1 to -n run 0 to + (n-1), i.e an index
 8000d30:	f1c0 0001 	rsb	r0, r0, #1
	if (x >= FIRSTGROUPSIZE) return; // Assure it is in range.
 8000d34:	2809      	cmp	r0, #9
 8000d36:	dc05      	bgt.n	8000d44 <Errors_USB_PC_get_msg_mode+0x18>
	err_ctrs[x] += 1;	// Add to error count
 8000d38:	4b03      	ldr	r3, [pc, #12]	; (8000d48 <Errors_USB_PC_get_msg_mode+0x1c>)
 8000d3a:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 8000d3e:	3201      	adds	r2, #1
 8000d40:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
 8000d44:	4770      	bx	lr
 8000d46:	bf00      	nop
 8000d48:	20001b10 	.word	0x20001b10

08000d4c <Errors_CAN_gateway_send>:
 * @brief	: Count errors
 * @param	: Subroutine return from: USB_PC_get_msg_mode
 * ************************************************************************************** */
void Errors_CAN_gateway_send(int x)
{
	if ( x > 0 ) return; // Expect negative numbers
 8000d4c:	2800      	cmp	r0, #0
 8000d4e:	dc04      	bgt.n	8000d5a <Errors_CAN_gateway_send+0xe>
	x = 1 - x;
	if ( x >= SECONDGROUPSIZE)  return;
 8000d50:	d103      	bne.n	8000d5a <Errors_CAN_gateway_send+0xe>
	err_ctrs[x + FIRSTGROUPSIZE] += 1;
 8000d52:	4b02      	ldr	r3, [pc, #8]	; (8000d5c <Errors_CAN_gateway_send+0x10>)
 8000d54:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000d56:	3201      	adds	r2, #1
 8000d58:	62da      	str	r2, [r3, #44]	; 0x2c
 8000d5a:	4770      	bx	lr
 8000d5c:	20001b10 	.word	0x20001b10

08000d60 <Errors_misc>:
	if ( x > 0 ) return; // Expect negative numbers
	x = 1 - x;
	if ( x >= THIRDGROUPSIZE)  return;
	err_ctrs[x + (FIRSTGROUPSIZE + SECONDGROUPSIZE) ] += 1;
	return;
}
 8000d60:	4770      	bx	lr

08000d62 <Errors_get_count>:
static int CAN_error_idx = 0;	// Index for 'get' of counters

struct CANERR2 Errors_get_count(void)
{
	struct CANERR2 err;
	err.idx = CAN_error_idx;
 8000d62:	4a07      	ldr	r2, [pc, #28]	; (8000d80 <Errors_get_count+0x1e>)
	err.ct  = err_ctrs[CAN_error_idx];
 8000d64:	4907      	ldr	r1, [pc, #28]	; (8000d84 <Errors_get_count+0x22>)
static int CAN_error_idx = 0;	// Index for 'get' of counters

struct CANERR2 Errors_get_count(void)
{
	struct CANERR2 err;
	err.idx = CAN_error_idx;
 8000d66:	6813      	ldr	r3, [r2, #0]
 * @return	: array index; error count
 * ************************************************************************************** */
static int CAN_error_idx = 0;	// Index for 'get' of counters

struct CANERR2 Errors_get_count(void)
{
 8000d68:	b510      	push	{r4, lr}
	struct CANERR2 err;
	err.idx = CAN_error_idx;
	err.ct  = err_ctrs[CAN_error_idx];
 8000d6a:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
	CAN_error_idx += 1; if (CAN_error_idx >= TOTALERRCTSIZE) CAN_error_idx = 0;
 8000d6e:	1c59      	adds	r1, r3, #1
 8000d70:	290c      	cmp	r1, #12
 8000d72:	6011      	str	r1, [r2, #0]
 8000d74:	dd01      	ble.n	8000d7a <Errors_get_count+0x18>
 8000d76:	2100      	movs	r1, #0
 8000d78:	6011      	str	r1, [r2, #0]
 8000d7a:	6003      	str	r3, [r0, #0]
 8000d7c:	6044      	str	r4, [r0, #4]
	return err; // Return count, and step 
}
 8000d7e:	bd10      	pop	{r4, pc}
 8000d80:	20000e10 	.word	0x20000e10
 8000d84:	20001b10 	.word	0x20001b10

08000d88 <NMI_Handler>:
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}
 8000d88:	4770      	bx	lr

08000d8a <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8000d8a:	e7fe      	b.n	8000d8a <HardFault_Handler>

08000d8c <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8000d8c:	e7fe      	b.n	8000d8c <MemManage_Handler>

08000d8e <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 8000d8e:	e7fe      	b.n	8000d8e <BusFault_Handler>

08000d90 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8000d90:	e7fe      	b.n	8000d90 <UsageFault_Handler>

08000d92 <SVC_Handler>:
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
}
 8000d92:	4770      	bx	lr

08000d94 <DebugMon_Handler>:
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
}
 8000d94:	4770      	bx	lr

08000d96 <PendSV_Handler>:
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
}
 8000d96:	4770      	bx	lr

08000d98 <SysTick_Handler>:
  * @retval None
  */
void SysTick_Handler(void)
{

	timing_handler();
 8000d98:	f000 b91e 	b.w	8000fd8 <timing_handler>

08000d9c <OTG_FS_WKUP_IRQHandler>:
/*  file (startup_stm32f4xx.s).                                               */
/******************************************************************************/

#ifdef USE_USB_OTG_FS
void OTG_FS_WKUP_IRQHandler(void)
{
 8000d9c:	b510      	push	{r4, lr}
  if(USB_OTG_dev.cfg.low_power)
 8000d9e:	4c09      	ldr	r4, [pc, #36]	; (8000dc4 <OTG_FS_WKUP_IRQHandler+0x28>)
 8000da0:	7aa3      	ldrb	r3, [r4, #10]
 8000da2:	b14b      	cbz	r3, 8000db8 <OTG_FS_WKUP_IRQHandler+0x1c>
  {
    *(uint32_t *)(0xE000ED10) &= 0xFFFFFFF9 ;
 8000da4:	4b08      	ldr	r3, [pc, #32]	; (8000dc8 <OTG_FS_WKUP_IRQHandler+0x2c>)
 8000da6:	681a      	ldr	r2, [r3, #0]
 8000da8:	f022 0206 	bic.w	r2, r2, #6
 8000dac:	601a      	str	r2, [r3, #0]
    SystemInit();
 8000dae:	f000 f813 	bl	8000dd8 <SystemInit>
    USB_OTG_UngateClock(&USB_OTG_dev);
 8000db2:	4620      	mov	r0, r4
 8000db4:	f001 fcee 	bl	8002794 <USB_OTG_UngateClock>
  }
  EXTI_ClearITPendingBit(EXTI_Line18);
 8000db8:	f44f 2080 	mov.w	r0, #262144	; 0x40000
}
 8000dbc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  {
    *(uint32_t *)(0xE000ED10) &= 0xFFFFFFF9 ;
    SystemInit();
    USB_OTG_UngateClock(&USB_OTG_dev);
  }
  EXTI_ClearITPendingBit(EXTI_Line18);
 8000dc0:	f000 bc48 	b.w	8001654 <EXTI_ClearITPendingBit>
 8000dc4:	20001b44 	.word	0x20001b44
 8000dc8:	e000ed10 	.word	0xe000ed10

08000dcc <OTG_FS_IRQHandler>:
void OTG_HS_IRQHandler(void)
#else
void OTG_FS_IRQHandler(void)
#endif
{
  USBD_OTG_ISR_Handler (&USB_OTG_dev);
 8000dcc:	4801      	ldr	r0, [pc, #4]	; (8000dd4 <OTG_FS_IRQHandler+0x8>)
 8000dce:	f001 bf55 	b.w	8002c7c <USBD_OTG_ISR_Handler>
 8000dd2:	bf00      	nop
 8000dd4:	20001b44 	.word	0x20001b44

08000dd8 <SystemInit>:
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
	SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
#endif
	/* Reset the RCC clock configuration to the default reset state ------------*/
	/* Set HSION bit */
	RCC->CR |= (uint32_t)0x00000001;
 8000dd8:	4b34      	ldr	r3, [pc, #208]	; (8000eac <SystemInit+0xd4>)
 8000dda:	681a      	ldr	r2, [r3, #0]
 8000ddc:	f042 0201 	orr.w	r2, r2, #1
 8000de0:	601a      	str	r2, [r3, #0]

	/* Reset CFGR register */
	RCC->CFGR = 0x00000000;
 8000de2:	2200      	movs	r2, #0
 8000de4:	609a      	str	r2, [r3, #8]

	/* Reset HSEON, CSSON and PLLON bits */
	RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000de6:	6819      	ldr	r1, [r3, #0]
 8000de8:	f021 7184 	bic.w	r1, r1, #17301504	; 0x1080000
 8000dec:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 8000df0:	6019      	str	r1, [r3, #0]

	/* Reset PLLCFGR register */
	RCC->PLLCFGR = 0x24003010;
 8000df2:	492f      	ldr	r1, [pc, #188]	; (8000eb0 <SystemInit+0xd8>)
 8000df4:	6059      	str	r1, [r3, #4]

	/* Reset HSEBYP bit */
	RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000df6:	6819      	ldr	r1, [r3, #0]
 *         SystemFrequency variable.
 * @param  None
 * @retval None
 */
void SystemInit(void)
{
 8000df8:	b082      	sub	sp, #8

	/* Reset PLLCFGR register */
	RCC->PLLCFGR = 0x24003010;

	/* Reset HSEBYP bit */
	RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000dfa:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 8000dfe:	6019      	str	r1, [r3, #0]

	/* Disable all interrupts */
	RCC->CIR = 0x00000000;
 8000e00:	60da      	str	r2, [r3, #12]
static void SetSysClock(void)
{
	/******************************************************************************/
	/*            PLL (clocked by HSE) used as System clock source                */
	/******************************************************************************/
	__IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 8000e02:	9201      	str	r2, [sp, #4]
 8000e04:	9200      	str	r2, [sp, #0]

	/* Enable HSE */
	RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8000e06:	681a      	ldr	r2, [r3, #0]
 8000e08:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8000e0c:	601a      	str	r2, [r3, #0]

	/* Wait till HSE is ready and if Time out is reached exit */
	do
	{
		HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8000e0e:	4b27      	ldr	r3, [pc, #156]	; (8000eac <SystemInit+0xd4>)
 8000e10:	681a      	ldr	r2, [r3, #0]
 8000e12:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 8000e16:	9200      	str	r2, [sp, #0]
		StartUpCounter++;
 8000e18:	9a01      	ldr	r2, [sp, #4]
 8000e1a:	3201      	adds	r2, #1
 8000e1c:	9201      	str	r2, [sp, #4]
	} while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8000e1e:	9a00      	ldr	r2, [sp, #0]
 8000e20:	b91a      	cbnz	r2, 8000e2a <SystemInit+0x52>
 8000e22:	9a01      	ldr	r2, [sp, #4]
 8000e24:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 8000e28:	d1f1      	bne.n	8000e0e <SystemInit+0x36>

	if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8000e2a:	681b      	ldr	r3, [r3, #0]
 8000e2c:	f413 3300 	ands.w	r3, r3, #131072	; 0x20000
	{
		HSEStatus = (uint32_t)0x01;
 8000e30:	bf18      	it	ne
 8000e32:	2301      	movne	r3, #1
	}
	else
	{
		HSEStatus = (uint32_t)0x00;
 8000e34:	9300      	str	r3, [sp, #0]
	}

	if (HSEStatus == (uint32_t)0x01)
 8000e36:	9b00      	ldr	r3, [sp, #0]
 8000e38:	2b01      	cmp	r3, #1
 8000e3a:	d130      	bne.n	8000e9e <SystemInit+0xc6>
	{
		/* Select regulator voltage output Scale 1 mode, System frequency up to 168 MHz */
		RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 8000e3c:	4b1b      	ldr	r3, [pc, #108]	; (8000eac <SystemInit+0xd4>)
 8000e3e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000e40:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000e44:	641a      	str	r2, [r3, #64]	; 0x40
		PWR->CR |= PWR_CR_VOS;
 8000e46:	4a1b      	ldr	r2, [pc, #108]	; (8000eb4 <SystemInit+0xdc>)
 8000e48:	6811      	ldr	r1, [r2, #0]
 8000e4a:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 8000e4e:	6011      	str	r1, [r2, #0]

		/* HCLK = SYSCLK / 1*/
		RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 8000e50:	689a      	ldr	r2, [r3, #8]
 8000e52:	609a      	str	r2, [r3, #8]

		/* PCLK2 = HCLK / 2*/
		RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 8000e54:	689a      	ldr	r2, [r3, #8]
 8000e56:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8000e5a:	609a      	str	r2, [r3, #8]

		/* PCLK1 = HCLK / 4*/
		RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 8000e5c:	689a      	ldr	r2, [r3, #8]
 8000e5e:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 8000e62:	609a      	str	r2, [r3, #8]

		/* Configure the main PLL */
		RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8000e64:	4a14      	ldr	r2, [pc, #80]	; (8000eb8 <SystemInit+0xe0>)
 8000e66:	605a      	str	r2, [r3, #4]
				(RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

		/* Enable the main PLL */
		RCC->CR |= RCC_CR_PLLON;
 8000e68:	681a      	ldr	r2, [r3, #0]
 8000e6a:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000e6e:	601a      	str	r2, [r3, #0]

		/* Wait till the main PLL is ready */
		while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8000e70:	4b0e      	ldr	r3, [pc, #56]	; (8000eac <SystemInit+0xd4>)
 8000e72:	681a      	ldr	r2, [r3, #0]
 8000e74:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8000e78:	d0fa      	beq.n	8000e70 <SystemInit+0x98>
		{
		}

		/* Configure Flash prefetch, Instruction cache, Data cache and wait state */
		FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 8000e7a:	4a10      	ldr	r2, [pc, #64]	; (8000ebc <SystemInit+0xe4>)
 8000e7c:	f240 6105 	movw	r1, #1541	; 0x605
 8000e80:	6011      	str	r1, [r2, #0]

		/* Select the main PLL as system clock source */
		RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8000e82:	689a      	ldr	r2, [r3, #8]
 8000e84:	f022 0203 	bic.w	r2, r2, #3
 8000e88:	609a      	str	r2, [r3, #8]
		RCC->CFGR |= RCC_CFGR_SW_PLL;
 8000e8a:	689a      	ldr	r2, [r3, #8]
 8000e8c:	f042 0202 	orr.w	r2, r2, #2
 8000e90:	609a      	str	r2, [r3, #8]

		/* Wait till the main PLL is used as system clock source */
		while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 8000e92:	4b06      	ldr	r3, [pc, #24]	; (8000eac <SystemInit+0xd4>)
 8000e94:	689b      	ldr	r3, [r3, #8]
 8000e96:	f003 030c 	and.w	r3, r3, #12
 8000e9a:	2b08      	cmp	r3, #8
 8000e9c:	d1f9      	bne.n	8000e92 <SystemInit+0xba>

	/* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
	SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
	SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8000e9e:	4b08      	ldr	r3, [pc, #32]	; (8000ec0 <SystemInit+0xe8>)
 8000ea0:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8000ea4:	609a      	str	r2, [r3, #8]
#endif
}
 8000ea6:	b002      	add	sp, #8
 8000ea8:	4770      	bx	lr
 8000eaa:	bf00      	nop
 8000eac:	40023800 	.word	0x40023800
 8000eb0:	24003010 	.word	0x24003010
 8000eb4:	40007000 	.word	0x40007000
 8000eb8:	07405408 	.word	0x07405408
 8000ebc:	40023c00 	.word	0x40023c00
 8000ec0:	e000ed00 	.word	0xe000ed00

08000ec4 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate(void)
{
	uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

	/* Get SYSCLK source -------------------------------------------------------*/
	tmp = RCC->CFGR & RCC_CFGR_SWS;
 8000ec4:	4a1e      	ldr	r2, [pc, #120]	; (8000f40 <SystemCoreClockUpdate+0x7c>)
 8000ec6:	4b1f      	ldr	r3, [pc, #124]	; (8000f44 <SystemCoreClockUpdate+0x80>)
 8000ec8:	6891      	ldr	r1, [r2, #8]
 8000eca:	f001 010c 	and.w	r1, r1, #12

	switch (tmp)
 8000ece:	2904      	cmp	r1, #4
 8000ed0:	d003      	beq.n	8000eda <SystemCoreClockUpdate+0x16>
 8000ed2:	2908      	cmp	r1, #8
 8000ed4:	d003      	beq.n	8000ede <SystemCoreClockUpdate+0x1a>
 8000ed6:	4a1c      	ldr	r2, [pc, #112]	; (8000f48 <SystemCoreClockUpdate+0x84>)
 8000ed8:	e025      	b.n	8000f26 <SystemCoreClockUpdate+0x62>
	{
	case 0x00:  /* HSI used as system clock source */
		SystemCoreClock = HSI_VALUE;
		break;
	case 0x04:  /* HSE used as system clock source */
		SystemCoreClock = HSE_VALUE;
 8000eda:	4a1c      	ldr	r2, [pc, #112]	; (8000f4c <SystemCoreClockUpdate+0x88>)
 8000edc:	e023      	b.n	8000f26 <SystemCoreClockUpdate+0x62>
	case 0x08:  /* PLL used as system clock source */

		/* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
		 */
		pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8000ede:	6851      	ldr	r1, [r2, #4]
		pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8000ee0:	6850      	ldr	r0, [r2, #4]

		if (pllsource != 0)
 8000ee2:	f411 0f80 	tst.w	r1, #4194304	; 0x400000

		/* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
		 */
		pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
		pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8000ee6:	f000 003f 	and.w	r0, r0, #63	; 0x3f

		if (pllsource != 0)
 8000eea:	d00a      	beq.n	8000f02 <SystemCoreClockUpdate+0x3e>
		{
			/* HSE used as PLL clock source */
			pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8000eec:	6852      	ldr	r2, [r2, #4]
 8000eee:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 8000ef2:	ea02 0101 	and.w	r1, r2, r1
 8000ef6:	4a15      	ldr	r2, [pc, #84]	; (8000f4c <SystemCoreClockUpdate+0x88>)
 8000ef8:	0989      	lsrs	r1, r1, #6
 8000efa:	fbb2 f2f0 	udiv	r2, r2, r0
 8000efe:	434a      	muls	r2, r1
 8000f00:	e009      	b.n	8000f16 <SystemCoreClockUpdate+0x52>
		}
		else
		{
			/* HSI used as PLL clock source */
			pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8000f02:	6851      	ldr	r1, [r2, #4]
 8000f04:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 8000f08:	ea01 0202 	and.w	r2, r1, r2
 8000f0c:	490e      	ldr	r1, [pc, #56]	; (8000f48 <SystemCoreClockUpdate+0x84>)
 8000f0e:	0992      	lsrs	r2, r2, #6
 8000f10:	fbb1 f0f0 	udiv	r0, r1, r0
 8000f14:	4342      	muls	r2, r0
		}

		pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8000f16:	490a      	ldr	r1, [pc, #40]	; (8000f40 <SystemCoreClockUpdate+0x7c>)
 8000f18:	6849      	ldr	r1, [r1, #4]
 8000f1a:	f401 3140 	and.w	r1, r1, #196608	; 0x30000
 8000f1e:	0bc9      	lsrs	r1, r1, #15
 8000f20:	3102      	adds	r1, #2
		SystemCoreClock = pllvco/pllp;
 8000f22:	fbb2 f2f1 	udiv	r2, r2, r1
 8000f26:	601a      	str	r2, [r3, #0]
		SystemCoreClock = HSI_VALUE;
		break;
	}
	/* Compute HCLK frequency --------------------------------------------------*/
	/* Get HCLK prescaler */
	tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8000f28:	4a05      	ldr	r2, [pc, #20]	; (8000f40 <SystemCoreClockUpdate+0x7c>)
	/* HCLK frequency */
	SystemCoreClock >>= tmp;
 8000f2a:	6819      	ldr	r1, [r3, #0]
		SystemCoreClock = HSI_VALUE;
		break;
	}
	/* Compute HCLK frequency --------------------------------------------------*/
	/* Get HCLK prescaler */
	tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8000f2c:	6892      	ldr	r2, [r2, #8]
 8000f2e:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8000f32:	eb03 1212 	add.w	r2, r3, r2, lsr #4
 8000f36:	7912      	ldrb	r2, [r2, #4]
	/* HCLK frequency */
	SystemCoreClock >>= tmp;
 8000f38:	fa31 f202 	lsrs.w	r2, r1, r2
 8000f3c:	601a      	str	r2, [r3, #0]
}
 8000f3e:	4770      	bx	lr
 8000f40:	40023800 	.word	0x40023800
 8000f44:	20000010 	.word	0x20000010
 8000f48:	00f42400 	.word	0x00f42400
 8000f4c:	017d7840 	.word	0x017d7840

08000f50 <usb1_init>:
void usb1_init(void)
{
	GPIO_InitTypeDef  GPIO_InitStructure;

	// ---------- SysTick timer -------- //
	if (SysTick_Config(SystemCoreClock / 1000)) {
 8000f50:	4b19      	ldr	r3, [pc, #100]	; (8000fb8 <usb1_init+0x68>)
 8000f52:	681a      	ldr	r2, [r3, #0]
 8000f54:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000f58:	fbb2 f2f3 	udiv	r2, r2, r3
__ALIGN_BEGIN USB_OTG_CORE_HANDLE  USB_OTG_dev __ALIGN_END;

// Private function prototypes

void usb1_init(void)
{
 8000f5c:	b530      	push	{r4, r5, lr}
 */
static __INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
 8000f5e:	4b17      	ldr	r3, [pc, #92]	; (8000fbc <usb1_init+0x6c>)
 8000f60:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8000f64:	3a01      	subs	r2, #1
 8000f66:	605a      	str	r2, [r3, #4]
    \param [in]  priority  Priority to set
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8000f68:	4a15      	ldr	r2, [pc, #84]	; (8000fc0 <usb1_init+0x70>)
 8000f6a:	21f0      	movs	r1, #240	; 0xf0
 8000f6c:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 8000f70:	2400      	movs	r4, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000f72:	2207      	movs	r2, #7
 8000f74:	b085      	sub	sp, #20
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 8000f76:	609c      	str	r4, [r3, #8]
		while (1){};
	}

	// ---------- GPIO -------- //
	// GPIOD Periph clock enable
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 8000f78:	2008      	movs	r0, #8
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000f7a:	601a      	str	r2, [r3, #0]
 8000f7c:	39ef      	subs	r1, #239	; 0xef
 8000f7e:	f000 f9bb 	bl	80012f8 <RCC_AHB1PeriphClockCmd>

	// Configure PD12, PD13, PD14 and PD15 in output pushpull mode
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15;
 8000f82:	f44f 4370 	mov.w	r3, #61440	; 0xf000
 8000f86:	9302      	str	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8000f88:	2501      	movs	r5, #1
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8000f8a:	2303      	movs	r3, #3
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 8000f8c:	a902      	add	r1, sp, #8
 8000f8e:	480d      	ldr	r0, [pc, #52]	; (8000fc4 <usb1_init+0x74>)

	// Configure PD12, PD13, PD14 and PD15 in output pushpull mode
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8000f90:	f88d 300d 	strb.w	r3, [sp, #13]
	// GPIOD Periph clock enable
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);

	// Configure PD12, PD13, PD14 and PD15 in output pushpull mode
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8000f94:	f88d 500c 	strb.w	r5, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000f98:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8000f9c:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 8000fa0:	f000 fbea 	bl	8001778 <GPIO_Init>

	// ------------- USB -------------- //
	USBD_Init(&USB_OTG_dev,
 8000fa4:	4b08      	ldr	r3, [pc, #32]	; (8000fc8 <usb1_init+0x78>)
 8000fa6:	4809      	ldr	r0, [pc, #36]	; (8000fcc <usb1_init+0x7c>)
 8000fa8:	9300      	str	r3, [sp, #0]
 8000faa:	4629      	mov	r1, r5
 8000fac:	4a08      	ldr	r2, [pc, #32]	; (8000fd0 <usb1_init+0x80>)
 8000fae:	4b09      	ldr	r3, [pc, #36]	; (8000fd4 <usb1_init+0x84>)
 8000fb0:	f002 fa06 	bl	80033c0 <USBD_Init>
	            &USR_desc,
	            &USBD_CDC_cb,
	            &USR_cb);

	return;
}
 8000fb4:	b005      	add	sp, #20
 8000fb6:	bd30      	pop	{r4, r5, pc}
 8000fb8:	20000010 	.word	0x20000010
 8000fbc:	e000e010 	.word	0xe000e010
 8000fc0:	e000ed00 	.word	0xe000ed00
 8000fc4:	40020c00 	.word	0x40020c00
 8000fc8:	20000024 	.word	0x20000024
 8000fcc:	20001b44 	.word	0x20001b44
 8000fd0:	20000058 	.word	0x20000058
 8000fd4:	200000d8 	.word	0x200000d8

08000fd8 <timing_handler>:
/*
 * Called from systick handler.  Call his ticker.
 */
void timing_handler()
{
}
 8000fd8:	4770      	bx	lr

08000fda <_init>:

/*
 * Dummy function to avoid compiler error
 */
void _init() {}
 8000fda:	4770      	bx	lr

08000fdc <USBD_USR_Init>:
* @retval None
*/
void USBD_USR_Init(void)
{   

}
 8000fdc:	4770      	bx	lr

08000fde <USBD_USR_DeviceReset>:
     break;
 default:
     break;
     
 }
}
 8000fde:	4770      	bx	lr

08000fe0 <USBD_USR_DeviceConfigured>:
* @param  None
* @retval Staus
*/
void USBD_USR_DeviceConfigured (void)
{
}
 8000fe0:	4770      	bx	lr

08000fe2 <USBD_USR_DeviceConnected>:
* @param  None
* @retval Staus
*/
void USBD_USR_DeviceConnected (void)
{
}
 8000fe2:	4770      	bx	lr

08000fe4 <USBD_USR_DeviceDisconnected>:
* @param  None
* @retval Staus
*/
void USBD_USR_DeviceDisconnected (void)
{
}
 8000fe4:	4770      	bx	lr

08000fe6 <USBD_USR_DeviceSuspended>:
* @retval None
*/
void USBD_USR_DeviceSuspended(void)
{
  /* Users can do their application actions here for the USB-Reset */
}
 8000fe6:	4770      	bx	lr

08000fe8 <USBD_USR_DeviceResumed>:
* @retval None
*/
void USBD_USR_DeviceResumed(void)
{
  /* Users can do their application actions here for the USB-Reset */
}
 8000fe8:	4770      	bx	lr
	...

08000fec <USBD_USR_DeviceDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_DeviceDescriptor( uint8_t speed , uint16_t *length)
{
  *length = sizeof(USBD_DeviceDesc);
 8000fec:	2312      	movs	r3, #18
 8000fee:	800b      	strh	r3, [r1, #0]
  return USBD_DeviceDesc;
}
 8000ff0:	4800      	ldr	r0, [pc, #0]	; (8000ff4 <USBD_USR_DeviceDescriptor+0x8>)
 8000ff2:	4770      	bx	lr
 8000ff4:	20000040 	.word	0x20000040

08000ff8 <USBD_USR_LangIDStrDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_LangIDStrDescriptor( uint8_t speed , uint16_t *length)
{
  *length =  sizeof(USBD_LangIDDesc);  
 8000ff8:	2304      	movs	r3, #4
 8000ffa:	800b      	strh	r3, [r1, #0]
  return USBD_LangIDDesc;
}
 8000ffc:	4800      	ldr	r0, [pc, #0]	; (8001000 <USBD_USR_LangIDStrDescriptor+0x8>)
 8000ffe:	4770      	bx	lr
 8001000:	20000052 	.word	0x20000052

08001004 <USBD_USR_InterfaceStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_InterfaceStrDescriptor( uint8_t speed , uint16_t *length)
{
 8001004:	460a      	mov	r2, r1
 8001006:	b508      	push	{r3, lr}
  {
    USBD_GetString ((uint8_t*)USBD_INTERFACE_HS_STRING, USBD_StrDesc, length);
  }
  else
  {
    USBD_GetString ((uint8_t*)USBD_INTERFACE_FS_STRING, USBD_StrDesc, length);
 8001008:	4802      	ldr	r0, [pc, #8]	; (8001014 <USBD_USR_InterfaceStrDescriptor+0x10>)
 800100a:	4903      	ldr	r1, [pc, #12]	; (8001018 <USBD_USR_InterfaceStrDescriptor+0x14>)
 800100c:	f002 fcb2 	bl	8003974 <USBD_GetString>
  }
  return USBD_StrDesc;  
}
 8001010:	4801      	ldr	r0, [pc, #4]	; (8001018 <USBD_USR_InterfaceStrDescriptor+0x14>)
 8001012:	bd08      	pop	{r3, pc}
 8001014:	0800d12c 	.word	0x0800d12c
 8001018:	200029c0 	.word	0x200029c0

0800101c <USBD_USR_ConfigStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_ConfigStrDescriptor( uint8_t speed , uint16_t *length)
{
 800101c:	460a      	mov	r2, r1
 800101e:	b508      	push	{r3, lr}
  {  
    USBD_GetString ((uint8_t*)USBD_CONFIGURATION_HS_STRING, USBD_StrDesc, length);
  }
  else
  {
    USBD_GetString ((uint8_t*)USBD_CONFIGURATION_FS_STRING, USBD_StrDesc, length);
 8001020:	4802      	ldr	r0, [pc, #8]	; (800102c <USBD_USR_ConfigStrDescriptor+0x10>)
 8001022:	4903      	ldr	r1, [pc, #12]	; (8001030 <USBD_USR_ConfigStrDescriptor+0x14>)
 8001024:	f002 fca6 	bl	8003974 <USBD_GetString>
  }
  return USBD_StrDesc;  
}
 8001028:	4801      	ldr	r0, [pc, #4]	; (8001030 <USBD_USR_ConfigStrDescriptor+0x14>)
 800102a:	bd08      	pop	{r3, pc}
 800102c:	0800d13a 	.word	0x0800d13a
 8001030:	200029c0 	.word	0x200029c0

08001034 <USBD_USR_SerialStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_SerialStrDescriptor( uint8_t speed , uint16_t *length)
{
 8001034:	b508      	push	{r3, lr}
 8001036:	460a      	mov	r2, r1
  if(speed  == USB_OTG_SPEED_HIGH)
 8001038:	b908      	cbnz	r0, 800103e <USBD_USR_SerialStrDescriptor+0xa>
  {    
    USBD_GetString ((uint8_t*)USBD_SERIALNUMBER_HS_STRING, USBD_StrDesc, length);
 800103a:	4804      	ldr	r0, [pc, #16]	; (800104c <USBD_USR_SerialStrDescriptor+0x18>)
 800103c:	e000      	b.n	8001040 <USBD_USR_SerialStrDescriptor+0xc>
  }
  else
  {
    USBD_GetString ((uint8_t*)USBD_SERIALNUMBER_FS_STRING, USBD_StrDesc, length);
 800103e:	4804      	ldr	r0, [pc, #16]	; (8001050 <USBD_USR_SerialStrDescriptor+0x1c>)
 8001040:	4904      	ldr	r1, [pc, #16]	; (8001054 <USBD_USR_SerialStrDescriptor+0x20>)
 8001042:	f002 fc97 	bl	8003974 <USBD_GetString>
  }
  return USBD_StrDesc;
}
 8001046:	4803      	ldr	r0, [pc, #12]	; (8001054 <USBD_USR_SerialStrDescriptor+0x20>)
 8001048:	bd08      	pop	{r3, pc}
 800104a:	bf00      	nop
 800104c:	0800d145 	.word	0x0800d145
 8001050:	0800d152 	.word	0x0800d152
 8001054:	200029c0 	.word	0x200029c0

08001058 <USBD_USR_ManufacturerStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_ManufacturerStrDescriptor( uint8_t speed , uint16_t *length)
{
 8001058:	460a      	mov	r2, r1
 800105a:	b508      	push	{r3, lr}
  USBD_GetString ((uint8_t*)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 800105c:	4802      	ldr	r0, [pc, #8]	; (8001068 <USBD_USR_ManufacturerStrDescriptor+0x10>)
 800105e:	4903      	ldr	r1, [pc, #12]	; (800106c <USBD_USR_ManufacturerStrDescriptor+0x14>)
 8001060:	f002 fc88 	bl	8003974 <USBD_GetString>
  return USBD_StrDesc;
}
 8001064:	4801      	ldr	r0, [pc, #4]	; (800106c <USBD_USR_ManufacturerStrDescriptor+0x14>)
 8001066:	bd08      	pop	{r3, pc}
 8001068:	0800d15f 	.word	0x0800d15f
 800106c:	200029c0 	.word	0x200029c0

08001070 <USBD_USR_ProductStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_ProductStrDescriptor( uint8_t speed , uint16_t *length)
{
 8001070:	b508      	push	{r3, lr}
 8001072:	460a      	mov	r2, r1
 
  
  if(speed == 0)
 8001074:	b908      	cbnz	r0, 800107a <USBD_USR_ProductStrDescriptor+0xa>
  {   
    USBD_GetString ((uint8_t*)USBD_PRODUCT_HS_STRING, USBD_StrDesc, length);
 8001076:	4804      	ldr	r0, [pc, #16]	; (8001088 <USBD_USR_ProductStrDescriptor+0x18>)
 8001078:	e000      	b.n	800107c <USBD_USR_ProductStrDescriptor+0xc>
  }
  else
  {
    USBD_GetString ((uint8_t*)USBD_PRODUCT_FS_STRING, USBD_StrDesc, length);
 800107a:	4804      	ldr	r0, [pc, #16]	; (800108c <USBD_USR_ProductStrDescriptor+0x1c>)
 800107c:	4904      	ldr	r1, [pc, #16]	; (8001090 <USBD_USR_ProductStrDescriptor+0x20>)
 800107e:	f002 fc79 	bl	8003974 <USBD_GetString>
  }
  return USBD_StrDesc;
}
 8001082:	4803      	ldr	r0, [pc, #12]	; (8001090 <USBD_USR_ProductStrDescriptor+0x20>)
 8001084:	bd08      	pop	{r3, pc}
 8001086:	bf00      	nop
 8001088:	0800d172 	.word	0x0800d172
 800108c:	0800d193 	.word	0x0800d193
 8001090:	200029c0 	.word	0x200029c0

08001094 <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8001094:	4b0a      	ldr	r3, [pc, #40]	; (80010c0 <RCC_DeInit+0x2c>)
 8001096:	6819      	ldr	r1, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8001098:	2200      	movs	r2, #0
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800109a:	f041 0001 	orr.w	r0, r1, #1
 800109e:	6018      	str	r0, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80010a0:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80010a2:	6819      	ldr	r1, [r3, #0]
 80010a4:	f021 7c84 	bic.w	ip, r1, #17301504	; 0x1080000

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80010a8:	4906      	ldr	r1, [pc, #24]	; (80010c4 <RCC_DeInit+0x30>)

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80010aa:	f42c 3080 	bic.w	r0, ip, #65536	; 0x10000
 80010ae:	6018      	str	r0, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80010b0:	6059      	str	r1, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80010b2:	6818      	ldr	r0, [r3, #0]
 80010b4:	f420 2180 	bic.w	r1, r0, #262144	; 0x40000
 80010b8:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80010ba:	60da      	str	r2, [r3, #12]
}
 80010bc:	4770      	bx	lr
 80010be:	bf00      	nop
 80010c0:	40023800 	.word	0x40023800
 80010c4:	24003010 	.word	0x24003010

080010c8 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
 80010c8:	4b02      	ldr	r3, [pc, #8]	; (80010d4 <RCC_HSEConfig+0xc>)
 80010ca:	2200      	movs	r2, #0
 80010cc:	701a      	strb	r2, [r3, #0]

  /* Set the new HSE configuration -------------------------------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
 80010ce:	7018      	strb	r0, [r3, #0]
}
 80010d0:	4770      	bx	lr
 80010d2:	bf00      	nop
 80010d4:	40023802 	.word	0x40023802

080010d8 <RCC_AdjustHSICalibrationValue>:
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));

  tmpreg = RCC->CR;
 80010d8:	4b03      	ldr	r3, [pc, #12]	; (80010e8 <RCC_AdjustHSICalibrationValue+0x10>)
 80010da:	681a      	ldr	r2, [r3, #0]

  /* Clear HSITRIM[4:0] bits */
  tmpreg &= ~RCC_CR_HSITRIM;
 80010dc:	f022 01f8 	bic.w	r1, r2, #248	; 0xf8

  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 80010e0:	ea41 02c0 	orr.w	r2, r1, r0, lsl #3

  /* Store the new value */
  RCC->CR = tmpreg;
 80010e4:	601a      	str	r2, [r3, #0]
}
 80010e6:	4770      	bx	lr
 80010e8:	40023800 	.word	0x40023800

080010ec <RCC_HSICmd>:
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 80010ec:	4b01      	ldr	r3, [pc, #4]	; (80010f4 <RCC_HSICmd+0x8>)
 80010ee:	6018      	str	r0, [r3, #0]
}
 80010f0:	4770      	bx	lr
 80010f2:	bf00      	nop
 80010f4:	42470000 	.word	0x42470000

080010f8 <RCC_LSEConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 80010f8:	4b06      	ldr	r3, [pc, #24]	; (8001114 <RCC_LSEConfig+0x1c>)
 80010fa:	2200      	movs	r2, #0

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
 80010fc:	2801      	cmp	r0, #1
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 80010fe:	701a      	strb	r2, [r3, #0]

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8001100:	701a      	strb	r2, [r3, #0]

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
 8001102:	d004      	beq.n	800110e <RCC_LSEConfig+0x16>
 8001104:	2804      	cmp	r0, #4
 8001106:	d101      	bne.n	800110c <RCC_LSEConfig+0x14>
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
      break;
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 8001108:	2005      	movs	r0, #5
 800110a:	7018      	strb	r0, [r3, #0]
 800110c:	4770      	bx	lr
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 800110e:	7018      	strb	r0, [r3, #0]
      break;
 8001110:	4770      	bx	lr
 8001112:	bf00      	nop
 8001114:	40023870 	.word	0x40023870

08001118 <RCC_LSICmd>:
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 8001118:	4b01      	ldr	r3, [pc, #4]	; (8001120 <RCC_LSICmd+0x8>)
 800111a:	6018      	str	r0, [r3, #0]
}
 800111c:	4770      	bx	lr
 800111e:	bf00      	nop
 8001120:	42470e80 	.word	0x42470e80

08001124 <RCC_PLLConfig>:
  assert_param(IS_RCC_PLLM_VALUE(PLLM));
  assert_param(IS_RCC_PLLN_VALUE(PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLP));
  assert_param(IS_RCC_PLLQ_VALUE(PLLQ));

  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
 8001124:	ea41 0000 	orr.w	r0, r1, r0
 8001128:	ea40 1c82 	orr.w	ip, r0, r2, lsl #6
 800112c:	9a00      	ldr	r2, [sp, #0]
 800112e:	085b      	lsrs	r3, r3, #1
 8001130:	1e59      	subs	r1, r3, #1
 8001132:	ea4c 6002 	orr.w	r0, ip, r2, lsl #24
 8001136:	4b02      	ldr	r3, [pc, #8]	; (8001140 <RCC_PLLConfig+0x1c>)
 8001138:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
 800113c:	605a      	str	r2, [r3, #4]
                 (PLLQ << 24);
}
 800113e:	4770      	bx	lr
 8001140:	40023800 	.word	0x40023800

08001144 <RCC_PLLCmd>:
  */
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8001144:	4b01      	ldr	r3, [pc, #4]	; (800114c <RCC_PLLCmd+0x8>)
 8001146:	6018      	str	r0, [r3, #0]
}
 8001148:	4770      	bx	lr
 800114a:	bf00      	nop
 800114c:	42470060 	.word	0x42470060

08001150 <RCC_PLLI2SConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
  assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));

  RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
 8001150:	0180      	lsls	r0, r0, #6
 8001152:	4b03      	ldr	r3, [pc, #12]	; (8001160 <RCC_PLLI2SConfig+0x10>)
 8001154:	ea40 7101 	orr.w	r1, r0, r1, lsl #28
 8001158:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
}
 800115c:	4770      	bx	lr
 800115e:	bf00      	nop
 8001160:	40023800 	.word	0x40023800

08001164 <RCC_PLLI2SCmd>:
  */
void RCC_PLLI2SCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
 8001164:	4b01      	ldr	r3, [pc, #4]	; (800116c <RCC_PLLI2SCmd+0x8>)
 8001166:	6018      	str	r0, [r3, #0]
}
 8001168:	4770      	bx	lr
 800116a:	bf00      	nop
 800116c:	42470068 	.word	0x42470068

08001170 <RCC_ClockSecuritySystemCmd>:
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 8001170:	4b01      	ldr	r3, [pc, #4]	; (8001178 <RCC_ClockSecuritySystemCmd+0x8>)
 8001172:	6018      	str	r0, [r3, #0]
}
 8001174:	4770      	bx	lr
 8001176:	bf00      	nop
 8001178:	4247004c 	.word	0x4247004c

0800117c <RCC_MCO1Config>:
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
  assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  

  tmpreg = RCC->CFGR;
 800117c:	4b04      	ldr	r3, [pc, #16]	; (8001190 <RCC_MCO1Config+0x14>)
 800117e:	689a      	ldr	r2, [r3, #8]

  /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
  tmpreg &= CFGR_MCO1_RESET_MASK;
 8001180:	f022 6cec 	bic.w	ip, r2, #123731968	; 0x7600000

  /* Select MCO1 clock source and prescaler */
  tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
 8001184:	ea40 000c 	orr.w	r0, r0, ip
 8001188:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 800118c:	609a      	str	r2, [r3, #8]
}
 800118e:	4770      	bx	lr
 8001190:	40023800 	.word	0x40023800

08001194 <RCC_MCO2Config>:
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
  assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
  
  tmpreg = RCC->CFGR;
 8001194:	4b04      	ldr	r3, [pc, #16]	; (80011a8 <RCC_MCO2Config+0x14>)
 8001196:	689a      	ldr	r2, [r3, #8]
  
  /* Clear MCO2 and MCO2PRE[2:0] bits */
  tmpreg &= CFGR_MCO2_RESET_MASK;
 8001198:	f022 4c78 	bic.w	ip, r2, #4160749568	; 0xf8000000

  /* Select MCO2 clock source and prescaler */
  tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
 800119c:	ea40 000c 	orr.w	r0, r0, ip
 80011a0:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 80011a4:	609a      	str	r2, [r3, #8]
}
 80011a6:	4770      	bx	lr
 80011a8:	40023800 	.word	0x40023800

080011ac <RCC_SYSCLKConfig>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));

  tmpreg = RCC->CFGR;
 80011ac:	4b03      	ldr	r3, [pc, #12]	; (80011bc <RCC_SYSCLKConfig+0x10>)
 80011ae:	689a      	ldr	r2, [r3, #8]

  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
 80011b0:	f022 0103 	bic.w	r1, r2, #3

  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 80011b4:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80011b8:	609a      	str	r2, [r3, #8]
}
 80011ba:	4770      	bx	lr
 80011bc:	40023800 	.word	0x40023800

080011c0 <RCC_GetSYSCLKSource>:
  *              - 0x04: HSE used as system clock
  *              - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 80011c0:	4b02      	ldr	r3, [pc, #8]	; (80011cc <RCC_GetSYSCLKSource+0xc>)
 80011c2:	6898      	ldr	r0, [r3, #8]
}
 80011c4:	f000 000c 	and.w	r0, r0, #12
 80011c8:	4770      	bx	lr
 80011ca:	bf00      	nop
 80011cc:	40023800 	.word	0x40023800

080011d0 <RCC_HCLKConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));

  tmpreg = RCC->CFGR;
 80011d0:	4b03      	ldr	r3, [pc, #12]	; (80011e0 <RCC_HCLKConfig+0x10>)
 80011d2:	689a      	ldr	r2, [r3, #8]

  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 80011d4:	f022 01f0 	bic.w	r1, r2, #240	; 0xf0

  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 80011d8:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80011dc:	609a      	str	r2, [r3, #8]
}
 80011de:	4770      	bx	lr
 80011e0:	40023800 	.word	0x40023800

080011e4 <RCC_PCLK1Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 80011e4:	4b03      	ldr	r3, [pc, #12]	; (80011f4 <RCC_PCLK1Config+0x10>)
 80011e6:	689a      	ldr	r2, [r3, #8]

  /* Clear PPRE1[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE1;
 80011e8:	f422 51e0 	bic.w	r1, r2, #7168	; 0x1c00

  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 80011ec:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80011f0:	609a      	str	r2, [r3, #8]
}
 80011f2:	4770      	bx	lr
 80011f4:	40023800 	.word	0x40023800

080011f8 <RCC_PCLK2Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 80011f8:	4b03      	ldr	r3, [pc, #12]	; (8001208 <RCC_PCLK2Config+0x10>)
 80011fa:	689a      	ldr	r2, [r3, #8]

  /* Clear PPRE2[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE2;
 80011fc:	f422 4160 	bic.w	r1, r2, #57344	; 0xe000

  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 8001200:	ea41 02c0 	orr.w	r2, r1, r0, lsl #3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8001204:	609a      	str	r2, [r3, #8]
}
 8001206:	4770      	bx	lr
 8001208:	40023800 	.word	0x40023800

0800120c <RCC_GetClocksFreq>:
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 800120c:	4a20      	ldr	r2, [pc, #128]	; (8001290 <RCC_GetClocksFreq+0x84>)
 800120e:	6893      	ldr	r3, [r2, #8]
 8001210:	f003 030c 	and.w	r3, r3, #12

  switch (tmp)
 8001214:	2b04      	cmp	r3, #4
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8001216:	b410      	push	{r4}
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;

  switch (tmp)
 8001218:	d01d      	beq.n	8001256 <RCC_GetClocksFreq+0x4a>
 800121a:	2b08      	cmp	r3, #8
 800121c:	d01e      	beq.n	800125c <RCC_GetClocksFreq+0x50>

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
      break;
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 800121e:	4b1d      	ldr	r3, [pc, #116]	; (8001294 <RCC_GetClocksFreq+0x88>)
 8001220:	6003      	str	r3, [r0, #0]
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8001222:	491b      	ldr	r1, [pc, #108]	; (8001290 <RCC_GetClocksFreq+0x84>)
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 8001224:	4a1c      	ldr	r2, [pc, #112]	; (8001298 <RCC_GetClocksFreq+0x8c>)
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8001226:	688c      	ldr	r4, [r1, #8]
  tmp = tmp >> 4;
 8001228:	f3c4 1c03 	ubfx	ip, r4, #4, #4
  presc = APBAHBPrescTable[tmp];
 800122c:	f812 400c 	ldrb.w	r4, [r2, ip]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8001230:	40e3      	lsrs	r3, r4
 8001232:	6043      	str	r3, [r0, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 8001234:	688c      	ldr	r4, [r1, #8]
  tmp = tmp >> 10;
 8001236:	f3c4 2c82 	ubfx	ip, r4, #10, #3
  presc = APBAHBPrescTable[tmp];
 800123a:	f812 400c 	ldrb.w	r4, [r2, ip]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800123e:	fa33 f404 	lsrs.w	r4, r3, r4
 8001242:	6084      	str	r4, [r0, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 8001244:	6889      	ldr	r1, [r1, #8]
  tmp = tmp >> 13;
 8001246:	f3c1 3c42 	ubfx	ip, r1, #13, #3
  presc = APBAHBPrescTable[tmp];
 800124a:	f812 200c 	ldrb.w	r2, [r2, ip]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800124e:	40d3      	lsrs	r3, r2
 8001250:	60c3      	str	r3, [r0, #12]
}
 8001252:	bc10      	pop	{r4}
 8001254:	4770      	bx	lr
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8001256:	4b11      	ldr	r3, [pc, #68]	; (800129c <RCC_GetClocksFreq+0x90>)
 8001258:	6003      	str	r3, [r0, #0]
      break;
 800125a:	e7e2      	b.n	8001222 <RCC_GetClocksFreq+0x16>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 800125c:	6854      	ldr	r4, [r2, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800125e:	6851      	ldr	r1, [r2, #4]
      
      if (pllsource != 0)
 8001260:	f414 0f80 	tst.w	r4, #4194304	; 0x400000
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8001264:	6854      	ldr	r4, [r2, #4]
 8001266:	bf14      	ite	ne
 8001268:	4b0c      	ldrne	r3, [pc, #48]	; (800129c <RCC_GetClocksFreq+0x90>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 800126a:	4b0a      	ldreq	r3, [pc, #40]	; (8001294 <RCC_GetClocksFreq+0x88>)
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
      
      if (pllsource != 0)
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 800126c:	f3c4 1288 	ubfx	r2, r4, #6, #9

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001270:	f001 013f 	and.w	r1, r1, #63	; 0x3f
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8001274:	4c06      	ldr	r4, [pc, #24]	; (8001290 <RCC_GetClocksFreq+0x84>)
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8001276:	fbb3 fcf1 	udiv	ip, r3, r1
 800127a:	fb0c f102 	mul.w	r1, ip, r2
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 800127e:	6862      	ldr	r2, [r4, #4]
 8001280:	f3c2 4301 	ubfx	r3, r2, #16, #2
 8001284:	1c5c      	adds	r4, r3, #1
 8001286:	0062      	lsls	r2, r4, #1
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 8001288:	fbb1 f3f2 	udiv	r3, r1, r2
 800128c:	6003      	str	r3, [r0, #0]
      break;
 800128e:	e7c8      	b.n	8001222 <RCC_GetClocksFreq+0x16>
 8001290:	40023800 	.word	0x40023800
 8001294:	00f42400 	.word	0x00f42400
 8001298:	20000080 	.word	0x20000080
 800129c:	017d7840 	.word	0x017d7840

080012a0 <RCC_RTCCLKConfig>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
 80012a0:	f400 7340 	and.w	r3, r0, #768	; 0x300
 80012a4:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80012a8:	d10a      	bne.n	80012c0 <RCC_RTCCLKConfig+0x20>
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;
 80012aa:	4b09      	ldr	r3, [pc, #36]	; (80012d0 <RCC_RTCCLKConfig+0x30>)
 80012ac:	6899      	ldr	r1, [r3, #8]

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 80012ae:	f020 4270 	bic.w	r2, r0, #4026531840	; 0xf0000000
  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;
 80012b2:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 80012b6:	f422 7c40 	bic.w	ip, r2, #768	; 0x300
 80012ba:	ea4c 0201 	orr.w	r2, ip, r1

    /* Store the new value */
    RCC->CFGR = tmpreg;
 80012be:	609a      	str	r2, [r3, #8]
  }
    
  /* Select the RTC clock source */
  RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
 80012c0:	4b03      	ldr	r3, [pc, #12]	; (80012d0 <RCC_RTCCLKConfig+0x30>)
 80012c2:	0500      	lsls	r0, r0, #20
 80012c4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80012c6:	0d01      	lsrs	r1, r0, #20
 80012c8:	ea41 0002 	orr.w	r0, r1, r2
 80012cc:	6718      	str	r0, [r3, #112]	; 0x70
}
 80012ce:	4770      	bx	lr
 80012d0:	40023800 	.word	0x40023800

080012d4 <RCC_RTCCLKCmd>:
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 80012d4:	4b01      	ldr	r3, [pc, #4]	; (80012dc <RCC_RTCCLKCmd+0x8>)
 80012d6:	6018      	str	r0, [r3, #0]
}
 80012d8:	4770      	bx	lr
 80012da:	bf00      	nop
 80012dc:	42470e3c 	.word	0x42470e3c

080012e0 <RCC_BackupResetCmd>:
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 80012e0:	4b01      	ldr	r3, [pc, #4]	; (80012e8 <RCC_BackupResetCmd+0x8>)
 80012e2:	6018      	str	r0, [r3, #0]
}
 80012e4:	4770      	bx	lr
 80012e6:	bf00      	nop
 80012e8:	42470e40 	.word	0x42470e40

080012ec <RCC_I2SCLKConfig>:
void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));

  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
 80012ec:	4b01      	ldr	r3, [pc, #4]	; (80012f4 <RCC_I2SCLKConfig+0x8>)
 80012ee:	6018      	str	r0, [r3, #0]
}
 80012f0:	4770      	bx	lr
 80012f2:	bf00      	nop
 80012f4:	4247015c 	.word	0x4247015c

080012f8 <RCC_AHB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80012f8:	b929      	cbnz	r1, 8001306 <RCC_AHB1PeriphClockCmd+0xe>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 80012fa:	4b05      	ldr	r3, [pc, #20]	; (8001310 <RCC_AHB1PeriphClockCmd+0x18>)
 80012fc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80012fe:	ea22 0100 	bic.w	r1, r2, r0
 8001302:	6319      	str	r1, [r3, #48]	; 0x30
 8001304:	4770      	bx	lr
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 8001306:	4b02      	ldr	r3, [pc, #8]	; (8001310 <RCC_AHB1PeriphClockCmd+0x18>)
 8001308:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800130a:	4310      	orrs	r0, r2
 800130c:	6318      	str	r0, [r3, #48]	; 0x30
 800130e:	4770      	bx	lr
 8001310:	40023800 	.word	0x40023800

08001314 <RCC_AHB2PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001314:	b929      	cbnz	r1, 8001322 <RCC_AHB2PeriphClockCmd+0xe>
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2ENR &= ~RCC_AHB2Periph;
 8001316:	4b05      	ldr	r3, [pc, #20]	; (800132c <RCC_AHB2PeriphClockCmd+0x18>)
 8001318:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800131a:	ea22 0100 	bic.w	r1, r2, r0
 800131e:	6359      	str	r1, [r3, #52]	; 0x34
 8001320:	4770      	bx	lr
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
 8001322:	4b02      	ldr	r3, [pc, #8]	; (800132c <RCC_AHB2PeriphClockCmd+0x18>)
 8001324:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001326:	4310      	orrs	r0, r2
 8001328:	6358      	str	r0, [r3, #52]	; 0x34
 800132a:	4770      	bx	lr
 800132c:	40023800 	.word	0x40023800

08001330 <RCC_AHB3PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001330:	b929      	cbnz	r1, 800133e <RCC_AHB3PeriphClockCmd+0xe>
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3ENR &= ~RCC_AHB3Periph;
 8001332:	4b05      	ldr	r3, [pc, #20]	; (8001348 <RCC_AHB3PeriphClockCmd+0x18>)
 8001334:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001336:	ea22 0100 	bic.w	r1, r2, r0
 800133a:	6399      	str	r1, [r3, #56]	; 0x38
 800133c:	4770      	bx	lr
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
 800133e:	4b02      	ldr	r3, [pc, #8]	; (8001348 <RCC_AHB3PeriphClockCmd+0x18>)
 8001340:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001342:	4310      	orrs	r0, r2
 8001344:	6398      	str	r0, [r3, #56]	; 0x38
 8001346:	4770      	bx	lr
 8001348:	40023800 	.word	0x40023800

0800134c <RCC_APB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800134c:	b929      	cbnz	r1, 800135a <RCC_APB1PeriphClockCmd+0xe>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 800134e:	4b05      	ldr	r3, [pc, #20]	; (8001364 <RCC_APB1PeriphClockCmd+0x18>)
 8001350:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001352:	ea22 0100 	bic.w	r1, r2, r0
 8001356:	6419      	str	r1, [r3, #64]	; 0x40
 8001358:	4770      	bx	lr
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 800135a:	4b02      	ldr	r3, [pc, #8]	; (8001364 <RCC_APB1PeriphClockCmd+0x18>)
 800135c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800135e:	4310      	orrs	r0, r2
 8001360:	6418      	str	r0, [r3, #64]	; 0x40
 8001362:	4770      	bx	lr
 8001364:	40023800 	.word	0x40023800

08001368 <RCC_APB2PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001368:	b929      	cbnz	r1, 8001376 <RCC_APB2PeriphClockCmd+0xe>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 800136a:	4b05      	ldr	r3, [pc, #20]	; (8001380 <RCC_APB2PeriphClockCmd+0x18>)
 800136c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800136e:	ea22 0100 	bic.w	r1, r2, r0
 8001372:	6459      	str	r1, [r3, #68]	; 0x44
 8001374:	4770      	bx	lr
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8001376:	4b02      	ldr	r3, [pc, #8]	; (8001380 <RCC_APB2PeriphClockCmd+0x18>)
 8001378:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800137a:	4310      	orrs	r0, r2
 800137c:	6458      	str	r0, [r3, #68]	; 0x44
 800137e:	4770      	bx	lr
 8001380:	40023800 	.word	0x40023800

08001384 <RCC_AHB1PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001384:	b929      	cbnz	r1, 8001392 <RCC_AHB1PeriphResetCmd+0xe>
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
 8001386:	4b05      	ldr	r3, [pc, #20]	; (800139c <RCC_AHB1PeriphResetCmd+0x18>)
 8001388:	691a      	ldr	r2, [r3, #16]
 800138a:	ea22 0100 	bic.w	r1, r2, r0
 800138e:	6119      	str	r1, [r3, #16]
 8001390:	4770      	bx	lr
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 8001392:	4b02      	ldr	r3, [pc, #8]	; (800139c <RCC_AHB1PeriphResetCmd+0x18>)
 8001394:	691a      	ldr	r2, [r3, #16]
 8001396:	4310      	orrs	r0, r2
 8001398:	6118      	str	r0, [r3, #16]
 800139a:	4770      	bx	lr
 800139c:	40023800 	.word	0x40023800

080013a0 <RCC_AHB2PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80013a0:	b929      	cbnz	r1, 80013ae <RCC_AHB2PeriphResetCmd+0xe>
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2RSTR &= ~RCC_AHB2Periph;
 80013a2:	4b05      	ldr	r3, [pc, #20]	; (80013b8 <RCC_AHB2PeriphResetCmd+0x18>)
 80013a4:	695a      	ldr	r2, [r3, #20]
 80013a6:	ea22 0100 	bic.w	r1, r2, r0
 80013aa:	6159      	str	r1, [r3, #20]
 80013ac:	4770      	bx	lr
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
 80013ae:	4b02      	ldr	r3, [pc, #8]	; (80013b8 <RCC_AHB2PeriphResetCmd+0x18>)
 80013b0:	695a      	ldr	r2, [r3, #20]
 80013b2:	4310      	orrs	r0, r2
 80013b4:	6158      	str	r0, [r3, #20]
 80013b6:	4770      	bx	lr
 80013b8:	40023800 	.word	0x40023800

080013bc <RCC_AHB3PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80013bc:	b929      	cbnz	r1, 80013ca <RCC_AHB3PeriphResetCmd+0xe>
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3RSTR &= ~RCC_AHB3Periph;
 80013be:	4b05      	ldr	r3, [pc, #20]	; (80013d4 <RCC_AHB3PeriphResetCmd+0x18>)
 80013c0:	699a      	ldr	r2, [r3, #24]
 80013c2:	ea22 0100 	bic.w	r1, r2, r0
 80013c6:	6199      	str	r1, [r3, #24]
 80013c8:	4770      	bx	lr
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
 80013ca:	4b02      	ldr	r3, [pc, #8]	; (80013d4 <RCC_AHB3PeriphResetCmd+0x18>)
 80013cc:	699a      	ldr	r2, [r3, #24]
 80013ce:	4310      	orrs	r0, r2
 80013d0:	6198      	str	r0, [r3, #24]
 80013d2:	4770      	bx	lr
 80013d4:	40023800 	.word	0x40023800

080013d8 <RCC_APB1PeriphResetCmd>:
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80013d8:	b929      	cbnz	r1, 80013e6 <RCC_APB1PeriphResetCmd+0xe>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 80013da:	4b05      	ldr	r3, [pc, #20]	; (80013f0 <RCC_APB1PeriphResetCmd+0x18>)
 80013dc:	6a1a      	ldr	r2, [r3, #32]
 80013de:	ea22 0100 	bic.w	r1, r2, r0
 80013e2:	6219      	str	r1, [r3, #32]
 80013e4:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 80013e6:	4b02      	ldr	r3, [pc, #8]	; (80013f0 <RCC_APB1PeriphResetCmd+0x18>)
 80013e8:	6a1a      	ldr	r2, [r3, #32]
 80013ea:	4310      	orrs	r0, r2
 80013ec:	6218      	str	r0, [r3, #32]
 80013ee:	4770      	bx	lr
 80013f0:	40023800 	.word	0x40023800

080013f4 <RCC_APB2PeriphResetCmd>:
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80013f4:	b929      	cbnz	r1, 8001402 <RCC_APB2PeriphResetCmd+0xe>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 80013f6:	4b05      	ldr	r3, [pc, #20]	; (800140c <RCC_APB2PeriphResetCmd+0x18>)
 80013f8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80013fa:	ea22 0100 	bic.w	r1, r2, r0
 80013fe:	6259      	str	r1, [r3, #36]	; 0x24
 8001400:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 8001402:	4b02      	ldr	r3, [pc, #8]	; (800140c <RCC_APB2PeriphResetCmd+0x18>)
 8001404:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001406:	4310      	orrs	r0, r2
 8001408:	6258      	str	r0, [r3, #36]	; 0x24
 800140a:	4770      	bx	lr
 800140c:	40023800 	.word	0x40023800

08001410 <RCC_AHB1PeriphClockLPModeCmd>:
void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001410:	b929      	cbnz	r1, 800141e <RCC_AHB1PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1LPENR &= ~RCC_AHB1Periph;
 8001412:	4b05      	ldr	r3, [pc, #20]	; (8001428 <RCC_AHB1PeriphClockLPModeCmd+0x18>)
 8001414:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8001416:	ea22 0100 	bic.w	r1, r2, r0
 800141a:	6519      	str	r1, [r3, #80]	; 0x50
 800141c:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
 800141e:	4b02      	ldr	r3, [pc, #8]	; (8001428 <RCC_AHB1PeriphClockLPModeCmd+0x18>)
 8001420:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8001422:	4310      	orrs	r0, r2
 8001424:	6518      	str	r0, [r3, #80]	; 0x50
 8001426:	4770      	bx	lr
 8001428:	40023800 	.word	0x40023800

0800142c <RCC_AHB2PeriphClockLPModeCmd>:
void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800142c:	b929      	cbnz	r1, 800143a <RCC_AHB2PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2LPENR &= ~RCC_AHB2Periph;
 800142e:	4b05      	ldr	r3, [pc, #20]	; (8001444 <RCC_AHB2PeriphClockLPModeCmd+0x18>)
 8001430:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8001432:	ea22 0100 	bic.w	r1, r2, r0
 8001436:	6559      	str	r1, [r3, #84]	; 0x54
 8001438:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
 800143a:	4b02      	ldr	r3, [pc, #8]	; (8001444 <RCC_AHB2PeriphClockLPModeCmd+0x18>)
 800143c:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800143e:	4310      	orrs	r0, r2
 8001440:	6558      	str	r0, [r3, #84]	; 0x54
 8001442:	4770      	bx	lr
 8001444:	40023800 	.word	0x40023800

08001448 <RCC_AHB3PeriphClockLPModeCmd>:
void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001448:	b929      	cbnz	r1, 8001456 <RCC_AHB3PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3LPENR &= ~RCC_AHB3Periph;
 800144a:	4b05      	ldr	r3, [pc, #20]	; (8001460 <RCC_AHB3PeriphClockLPModeCmd+0x18>)
 800144c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800144e:	ea22 0100 	bic.w	r1, r2, r0
 8001452:	6599      	str	r1, [r3, #88]	; 0x58
 8001454:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
 8001456:	4b02      	ldr	r3, [pc, #8]	; (8001460 <RCC_AHB3PeriphClockLPModeCmd+0x18>)
 8001458:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800145a:	4310      	orrs	r0, r2
 800145c:	6598      	str	r0, [r3, #88]	; 0x58
 800145e:	4770      	bx	lr
 8001460:	40023800 	.word	0x40023800

08001464 <RCC_APB1PeriphClockLPModeCmd>:
void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001464:	b929      	cbnz	r1, 8001472 <RCC_APB1PeriphClockLPModeCmd+0xe>
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1LPENR &= ~RCC_APB1Periph;
 8001466:	4b05      	ldr	r3, [pc, #20]	; (800147c <RCC_APB1PeriphClockLPModeCmd+0x18>)
 8001468:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800146a:	ea22 0100 	bic.w	r1, r2, r0
 800146e:	6619      	str	r1, [r3, #96]	; 0x60
 8001470:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
 8001472:	4b02      	ldr	r3, [pc, #8]	; (800147c <RCC_APB1PeriphClockLPModeCmd+0x18>)
 8001474:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001476:	4310      	orrs	r0, r2
 8001478:	6618      	str	r0, [r3, #96]	; 0x60
 800147a:	4770      	bx	lr
 800147c:	40023800 	.word	0x40023800

08001480 <RCC_APB2PeriphClockLPModeCmd>:
void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001480:	b929      	cbnz	r1, 800148e <RCC_APB2PeriphClockLPModeCmd+0xe>
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2LPENR &= ~RCC_APB2Periph;
 8001482:	4b05      	ldr	r3, [pc, #20]	; (8001498 <RCC_APB2PeriphClockLPModeCmd+0x18>)
 8001484:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8001486:	ea22 0100 	bic.w	r1, r2, r0
 800148a:	6659      	str	r1, [r3, #100]	; 0x64
 800148c:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
 800148e:	4b02      	ldr	r3, [pc, #8]	; (8001498 <RCC_APB2PeriphClockLPModeCmd+0x18>)
 8001490:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8001492:	4310      	orrs	r0, r2
 8001494:	6658      	str	r0, [r3, #100]	; 0x64
 8001496:	4770      	bx	lr
 8001498:	40023800 	.word	0x40023800

0800149c <RCC_ITConfig>:
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800149c:	b931      	cbnz	r1, 80014ac <RCC_ITConfig+0x10>
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
  }
  else
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 800149e:	4b06      	ldr	r3, [pc, #24]	; (80014b8 <RCC_ITConfig+0x1c>)
 80014a0:	f893 c000 	ldrb.w	ip, [r3]
 80014a4:	ea2c 0100 	bic.w	r1, ip, r0
 80014a8:	7019      	strb	r1, [r3, #0]
 80014aa:	4770      	bx	lr
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 80014ac:	4b02      	ldr	r3, [pc, #8]	; (80014b8 <RCC_ITConfig+0x1c>)
 80014ae:	781a      	ldrb	r2, [r3, #0]
 80014b0:	4310      	orrs	r0, r2
 80014b2:	7018      	strb	r0, [r3, #0]
 80014b4:	4770      	bx	lr
 80014b6:	bf00      	nop
 80014b8:	4002380d 	.word	0x4002380d

080014bc <RCC_GetFlagStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 80014bc:	0943      	lsrs	r3, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 80014be:	2b01      	cmp	r3, #1
 80014c0:	d00b      	beq.n	80014da <RCC_GetFlagStatus+0x1e>
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 80014c2:	2b02      	cmp	r3, #2
  {
    statusreg = RCC->BDCR;
 80014c4:	4b09      	ldr	r3, [pc, #36]	; (80014ec <RCC_GetFlagStatus+0x30>)
 80014c6:	bf0c      	ite	eq
 80014c8:	6f1b      	ldreq	r3, [r3, #112]	; 0x70
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 80014ca:	6f5b      	ldrne	r3, [r3, #116]	; 0x74
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
 80014cc:	f000 011f 	and.w	r1, r0, #31
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 80014d0:	fa33 f001 	lsrs.w	r0, r3, r1
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 80014d4:	f000 0001 	and.w	r0, r0, #1
 80014d8:	4770      	bx	lr

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 80014da:	4b04      	ldr	r3, [pc, #16]	; (80014ec <RCC_GetFlagStatus+0x30>)
 80014dc:	681b      	ldr	r3, [r3, #0]
  {
    statusreg = RCC->CSR;
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
 80014de:	f000 011f 	and.w	r1, r0, #31
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 80014e2:	fa33 f001 	lsrs.w	r0, r3, r1
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 80014e6:	f000 0001 	and.w	r0, r0, #1
 80014ea:	4770      	bx	lr
 80014ec:	40023800 	.word	0x40023800

080014f0 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 80014f0:	b500      	push	{lr}
 80014f2:	b083      	sub	sp, #12
  __IO uint32_t startupcounter = 0;
 80014f4:	2300      	movs	r3, #0
 80014f6:	9301      	str	r3, [sp, #4]
 80014f8:	e000      	b.n	80014fc <RCC_WaitForHSEStartUp+0xc>
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    startupcounter++;
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 80014fa:	b948      	cbnz	r0, 8001510 <RCC_WaitForHSEStartUp+0x20>
  ErrorStatus status = ERROR;
  FlagStatus hsestatus = RESET;
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 80014fc:	2031      	movs	r0, #49	; 0x31
 80014fe:	f7ff ffdd 	bl	80014bc <RCC_GetFlagStatus>
    startupcounter++;
 8001502:	9b01      	ldr	r3, [sp, #4]
 8001504:	1c5a      	adds	r2, r3, #1
 8001506:	9201      	str	r2, [sp, #4]
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 8001508:	9901      	ldr	r1, [sp, #4]
 800150a:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
 800150e:	d1f4      	bne.n	80014fa <RCC_WaitForHSEStartUp+0xa>

  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 8001510:	2031      	movs	r0, #49	; 0x31
 8001512:	f7ff ffd3 	bl	80014bc <RCC_GetFlagStatus>
  else
  {
    status = ERROR;
  }
  return (status);
}
 8001516:	3800      	subs	r0, #0
 8001518:	bf18      	it	ne
 800151a:	2001      	movne	r0, #1
 800151c:	b003      	add	sp, #12
 800151e:	bd00      	pop	{pc}

08001520 <RCC_ClearFlag>:
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= RCC_CSR_RMVF;
 8001520:	4b02      	ldr	r3, [pc, #8]	; (800152c <RCC_ClearFlag+0xc>)
 8001522:	6f58      	ldr	r0, [r3, #116]	; 0x74
 8001524:	f040 7280 	orr.w	r2, r0, #16777216	; 0x1000000
 8001528:	675a      	str	r2, [r3, #116]	; 0x74
}
 800152a:	4770      	bx	lr
 800152c:	40023800 	.word	0x40023800

08001530 <RCC_GetITStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 8001530:	4903      	ldr	r1, [pc, #12]	; (8001540 <RCC_GetITStatus+0x10>)
 8001532:	68cb      	ldr	r3, [r1, #12]
  {
    bitstatus = SET;
 8001534:	4218      	tst	r0, r3
  {
    bitstatus = RESET;
  }
  /* Return the RCC_IT status */
  return  bitstatus;
}
 8001536:	bf0c      	ite	eq
 8001538:	2000      	moveq	r0, #0
 800153a:	2001      	movne	r0, #1
 800153c:	4770      	bx	lr
 800153e:	bf00      	nop
 8001540:	40023800 	.word	0x40023800

08001544 <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 8001544:	4b01      	ldr	r3, [pc, #4]	; (800154c <RCC_ClearITPendingBit+0x8>)
 8001546:	7018      	strb	r0, [r3, #0]
}
 8001548:	4770      	bx	lr
 800154a:	bf00      	nop
 800154c:	4002380e 	.word	0x4002380e

08001550 <EXTI_DeInit>:
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR = 0x00000000;
 8001550:	4b04      	ldr	r3, [pc, #16]	; (8001564 <EXTI_DeInit+0x14>)
  EXTI->EMR = 0x00000000;
  EXTI->RTSR = 0x00000000;
  EXTI->FTSR = 0x00000000;
  EXTI->PR = 0x007FFFFF;
 8001552:	4a05      	ldr	r2, [pc, #20]	; (8001568 <EXTI_DeInit+0x18>)
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR = 0x00000000;
 8001554:	2000      	movs	r0, #0
 8001556:	6018      	str	r0, [r3, #0]
  EXTI->EMR = 0x00000000;
 8001558:	6058      	str	r0, [r3, #4]
  EXTI->RTSR = 0x00000000;
 800155a:	6098      	str	r0, [r3, #8]
  EXTI->FTSR = 0x00000000;
 800155c:	60d8      	str	r0, [r3, #12]
  EXTI->PR = 0x007FFFFF;
 800155e:	615a      	str	r2, [r3, #20]
}
 8001560:	4770      	bx	lr
 8001562:	bf00      	nop
 8001564:	40013c00 	.word	0x40013c00
 8001568:	007fffff 	.word	0x007fffff

0800156c <EXTI_Init>:
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 800156c:	7983      	ldrb	r3, [r0, #6]
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
  *         that contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 800156e:	b470      	push	{r4, r5, r6}
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8001570:	b343      	cbz	r3, 80015c4 <EXTI_Init+0x58>
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 8001572:	4b20      	ldr	r3, [pc, #128]	; (80015f4 <EXTI_Init+0x88>)
 8001574:	6801      	ldr	r1, [r0, #0]
 8001576:	681e      	ldr	r6, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 8001578:	7902      	ldrb	r2, [r0, #4]
    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 800157a:	7945      	ldrb	r5, [r0, #5]
  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 800157c:	43cc      	mvns	r4, r1
 800157e:	ea04 0606 	and.w	r6, r4, r6
 8001582:	601e      	str	r6, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 8001584:	685e      	ldr	r6, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 8001586:	f102 4c80 	add.w	ip, r2, #1073741824	; 0x40000000
 800158a:	f50c 329e 	add.w	r2, ip, #80896	; 0x13c00
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 800158e:	4034      	ands	r4, r6
 8001590:	605c      	str	r4, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8001592:	6814      	ldr	r4, [r2, #0]
 8001594:	ea44 0101 	orr.w	r1, r4, r1
 8001598:	6011      	str	r1, [r2, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 800159a:	6802      	ldr	r2, [r0, #0]
 800159c:	6898      	ldr	r0, [r3, #8]
 800159e:	43d1      	mvns	r1, r2
 80015a0:	ea01 0000 	and.w	r0, r1, r0
 80015a4:	6098      	str	r0, [r3, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 80015a6:	68d8      	ldr	r0, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 80015a8:	2d10      	cmp	r5, #16

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 80015aa:	ea01 0100 	and.w	r1, r1, r0
 80015ae:	60d9      	str	r1, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 80015b0:	d016      	beq.n	80015e0 <EXTI_Init+0x74>
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
    }
    else
    {
      tmp = (uint32_t)EXTI_BASE;
      tmp += EXTI_InitStruct->EXTI_Trigger;
 80015b2:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 80015b6:	f505 359e 	add.w	r5, r5, #80896	; 0x13c00

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80015ba:	6828      	ldr	r0, [r5, #0]
 80015bc:	ea40 0302 	orr.w	r3, r0, r2
 80015c0:	602b      	str	r3, [r5, #0]
 80015c2:	e00b      	b.n	80015dc <EXTI_Init+0x70>
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 80015c4:	7902      	ldrb	r2, [r0, #4]

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 80015c6:	6801      	ldr	r1, [r0, #0]
      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 80015c8:	f102 4080 	add.w	r0, r2, #1073741824	; 0x40000000
 80015cc:	f500 3c9e 	add.w	ip, r0, #80896	; 0x13c00

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 80015d0:	f8dc 3000 	ldr.w	r3, [ip]
 80015d4:	ea23 0201 	bic.w	r2, r3, r1
 80015d8:	f8cc 2000 	str.w	r2, [ip]
  }
}
 80015dc:	bc70      	pop	{r4, r5, r6}
 80015de:	4770      	bx	lr
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 80015e0:	6899      	ldr	r1, [r3, #8]
 80015e2:	ea41 0002 	orr.w	r0, r1, r2
 80015e6:	6098      	str	r0, [r3, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 80015e8:	68d9      	ldr	r1, [r3, #12]
 80015ea:	ea41 0002 	orr.w	r0, r1, r2
 80015ee:	60d8      	str	r0, [r3, #12]
 80015f0:	e7f4      	b.n	80015dc <EXTI_Init+0x70>
 80015f2:	bf00      	nop
 80015f4:	40013c00 	.word	0x40013c00

080015f8 <EXTI_StructInit>:
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 80015f8:	2300      	movs	r3, #0
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 80015fa:	220c      	movs	r2, #12
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 80015fc:	6003      	str	r3, [r0, #0]
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
 80015fe:	7103      	strb	r3, [r0, #4]
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 8001600:	7142      	strb	r2, [r0, #5]
  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
 8001602:	7183      	strb	r3, [r0, #6]
}
 8001604:	4770      	bx	lr
 8001606:	bf00      	nop

08001608 <EXTI_GenerateSWInterrupt>:
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->SWIER |= EXTI_Line;
 8001608:	4b02      	ldr	r3, [pc, #8]	; (8001614 <EXTI_GenerateSWInterrupt+0xc>)
 800160a:	6919      	ldr	r1, [r3, #16]
 800160c:	ea40 0201 	orr.w	r2, r0, r1
 8001610:	611a      	str	r2, [r3, #16]
}
 8001612:	4770      	bx	lr
 8001614:	40013c00 	.word	0x40013c00

08001618 <EXTI_GetFlagStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
 8001618:	4903      	ldr	r1, [pc, #12]	; (8001628 <EXTI_GetFlagStatus+0x10>)
 800161a:	694b      	ldr	r3, [r1, #20]
  {
    bitstatus = SET;
 800161c:	4218      	tst	r0, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 800161e:	bf0c      	ite	eq
 8001620:	2000      	moveq	r0, #0
 8001622:	2001      	movne	r0, #1
 8001624:	4770      	bx	lr
 8001626:	bf00      	nop
 8001628:	40013c00 	.word	0x40013c00

0800162c <EXTI_ClearFlag>:
void EXTI_ClearFlag(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 800162c:	4b01      	ldr	r3, [pc, #4]	; (8001634 <EXTI_ClearFlag+0x8>)
 800162e:	6158      	str	r0, [r3, #20]
}
 8001630:	4770      	bx	lr
 8001632:	bf00      	nop
 8001634:	40013c00 	.word	0x40013c00

08001638 <EXTI_GetITStatus>:
  ITStatus bitstatus = RESET;
  uint32_t enablestatus = 0;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  EXTI->IMR & EXTI_Line;
 8001638:	4905      	ldr	r1, [pc, #20]	; (8001650 <EXTI_GetITStatus+0x18>)
 800163a:	680a      	ldr	r2, [r1, #0]
  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 800163c:	694b      	ldr	r3, [r1, #20]
 800163e:	4003      	ands	r3, r0
 8001640:	d004      	beq.n	800164c <EXTI_GetITStatus+0x14>
  {
    bitstatus = SET;
 8001642:	4210      	tst	r0, r2
 8001644:	bf0c      	ite	eq
 8001646:	2000      	moveq	r0, #0
 8001648:	2001      	movne	r0, #1
 800164a:	4770      	bx	lr
  }
  else
  {
    bitstatus = RESET;
 800164c:	4618      	mov	r0, r3
  }
  return bitstatus;
}
 800164e:	4770      	bx	lr
 8001650:	40013c00 	.word	0x40013c00

08001654 <EXTI_ClearITPendingBit>:
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 8001654:	4b01      	ldr	r3, [pc, #4]	; (800165c <EXTI_ClearITPendingBit+0x8>)
 8001656:	6158      	str	r0, [r3, #20]
}
 8001658:	4770      	bx	lr
 800165a:	bf00      	nop
 800165c:	40013c00 	.word	0x40013c00

08001660 <GPIO_DeInit>:
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
 8001660:	4b3c      	ldr	r3, [pc, #240]	; (8001754 <GPIO_DeInit+0xf4>)
 8001662:	4298      	cmp	r0, r3
  * @note   By default, The GPIO pins are configured in input floating mode (except JTAG pins).
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 8001664:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
 8001666:	d024      	beq.n	80016b2 <GPIO_DeInit+0x52>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
 8001668:	493b      	ldr	r1, [pc, #236]	; (8001758 <GPIO_DeInit+0xf8>)
 800166a:	4288      	cmp	r0, r1
 800166c:	d02b      	beq.n	80016c6 <GPIO_DeInit+0x66>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
 800166e:	4a3b      	ldr	r2, [pc, #236]	; (800175c <GPIO_DeInit+0xfc>)
 8001670:	4290      	cmp	r0, r2
 8001672:	d032      	beq.n	80016da <GPIO_DeInit+0x7a>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
 8001674:	4b3a      	ldr	r3, [pc, #232]	; (8001760 <GPIO_DeInit+0x100>)
 8001676:	4298      	cmp	r0, r3
 8001678:	d039      	beq.n	80016ee <GPIO_DeInit+0x8e>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
  }
  else if (GPIOx == GPIOE)
 800167a:	493a      	ldr	r1, [pc, #232]	; (8001764 <GPIO_DeInit+0x104>)
 800167c:	4288      	cmp	r0, r1
 800167e:	d040      	beq.n	8001702 <GPIO_DeInit+0xa2>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
  }
  else if (GPIOx == GPIOF)
 8001680:	4a39      	ldr	r2, [pc, #228]	; (8001768 <GPIO_DeInit+0x108>)
 8001682:	4290      	cmp	r0, r2
 8001684:	d047      	beq.n	8001716 <GPIO_DeInit+0xb6>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
  }
  else if (GPIOx == GPIOG)
 8001686:	4b39      	ldr	r3, [pc, #228]	; (800176c <GPIO_DeInit+0x10c>)
 8001688:	4298      	cmp	r0, r3
 800168a:	d04e      	beq.n	800172a <GPIO_DeInit+0xca>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
  }
  else if (GPIOx == GPIOH)
 800168c:	4938      	ldr	r1, [pc, #224]	; (8001770 <GPIO_DeInit+0x110>)
 800168e:	4288      	cmp	r0, r1
 8001690:	d055      	beq.n	800173e <GPIO_DeInit+0xde>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
  }
  else
  {
    if (GPIOx == GPIOI)
 8001692:	4a38      	ldr	r2, [pc, #224]	; (8001774 <GPIO_DeInit+0x114>)
 8001694:	4290      	cmp	r0, r2
 8001696:	d000      	beq.n	800169a <GPIO_DeInit+0x3a>
 8001698:	bd10      	pop	{r4, pc}
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
 800169a:	2101      	movs	r1, #1
 800169c:	f44f 7080 	mov.w	r0, #256	; 0x100
 80016a0:	f7ff fe70 	bl	8001384 <RCC_AHB1PeriphResetCmd>
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 80016a4:	f44f 7080 	mov.w	r0, #256	; 0x100
 80016a8:	2100      	movs	r1, #0
    }
  }
}
 80016aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  else
  {
    if (GPIOx == GPIOI)
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 80016ae:	f7ff be69 	b.w	8001384 <RCC_AHB1PeriphResetCmd>
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 80016b2:	2001      	movs	r0, #1
 80016b4:	4601      	mov	r1, r0
 80016b6:	f7ff fe65 	bl	8001384 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
 80016ba:	2001      	movs	r0, #1
 80016bc:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80016be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
 80016c2:	f7ff be5f 	b.w	8001384 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOB)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 80016c6:	2002      	movs	r0, #2
 80016c8:	2101      	movs	r1, #1
 80016ca:	f7ff fe5b 	bl	8001384 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
 80016ce:	2002      	movs	r0, #2
 80016d0:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80016d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
 80016d6:	f7ff be55 	b.w	8001384 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOC)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 80016da:	2004      	movs	r0, #4
 80016dc:	2101      	movs	r1, #1
 80016de:	f7ff fe51 	bl	8001384 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
 80016e2:	2004      	movs	r0, #4
 80016e4:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80016e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
 80016ea:	f7ff be4b 	b.w	8001384 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOD)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 80016ee:	2008      	movs	r0, #8
 80016f0:	2101      	movs	r1, #1
 80016f2:	f7ff fe47 	bl	8001384 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
 80016f6:	2008      	movs	r0, #8
 80016f8:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80016fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
 80016fe:	f7ff be41 	b.w	8001384 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOE)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
 8001702:	2010      	movs	r0, #16
 8001704:	2101      	movs	r1, #1
 8001706:	f7ff fe3d 	bl	8001384 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
 800170a:	2010      	movs	r0, #16
 800170c:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 800170e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
  }
  else if (GPIOx == GPIOE)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
 8001712:	f7ff be37 	b.w	8001384 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOF)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
 8001716:	2020      	movs	r0, #32
 8001718:	2101      	movs	r1, #1
 800171a:	f7ff fe33 	bl	8001384 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
 800171e:	2020      	movs	r0, #32
 8001720:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 8001722:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
  }
  else if (GPIOx == GPIOF)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
 8001726:	f7ff be2d 	b.w	8001384 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOG)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
 800172a:	2040      	movs	r0, #64	; 0x40
 800172c:	2101      	movs	r1, #1
 800172e:	f7ff fe29 	bl	8001384 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
 8001732:	2040      	movs	r0, #64	; 0x40
 8001734:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 8001736:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
  }
  else if (GPIOx == GPIOG)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
 800173a:	f7ff be23 	b.w	8001384 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOH)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
 800173e:	2080      	movs	r0, #128	; 0x80
 8001740:	2101      	movs	r1, #1
 8001742:	f7ff fe1f 	bl	8001384 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
 8001746:	2080      	movs	r0, #128	; 0x80
 8001748:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 800174a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
  }
  else if (GPIOx == GPIOH)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
 800174e:	f7ff be19 	b.w	8001384 <RCC_AHB1PeriphResetCmd>
 8001752:	bf00      	nop
 8001754:	40020000 	.word	0x40020000
 8001758:	40020400 	.word	0x40020400
 800175c:	40020800 	.word	0x40020800
 8001760:	40020c00 	.word	0x40020c00
 8001764:	40021000 	.word	0x40021000
 8001768:	40021400 	.word	0x40021400
 800176c:	40021800 	.word	0x40021800
 8001770:	40021c00 	.word	0x40021c00
 8001774:	40022000 	.word	0x40022000

08001778 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8001778:	2300      	movs	r3, #0
 800177a:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800177e:	680a      	ldr	r2, [r1, #0]
 8001780:	461c      	mov	r4, r3
  {
    pos = ((uint32_t)0x01) << pinpos;
 8001782:	2601      	movs	r6, #1
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8001784:	f04f 0c03 	mov.w	ip, #3
 8001788:	e00b      	b.n	80017a2 <GPIO_Init+0x2a>
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800178a:	3401      	adds	r4, #1
  {
    pos = ((uint32_t)0x01) << pinpos;
 800178c:	fa16 f504 	lsls.w	r5, r6, r4
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8001790:	ea05 0702 	and.w	r7, r5, r2
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8001794:	3302      	adds	r3, #2
  {
    pos = ((uint32_t)0x01) << pinpos;
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
 8001796:	42af      	cmp	r7, r5
 8001798:	d035      	beq.n	8001806 <GPIO_Init+0x8e>
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800179a:	3401      	adds	r4, #1
 800179c:	3302      	adds	r3, #2
 800179e:	2c10      	cmp	r4, #16
 80017a0:	d05a      	beq.n	8001858 <GPIO_Init+0xe0>
  {
    pos = ((uint32_t)0x01) << pinpos;
 80017a2:	fa16 f504 	lsls.w	r5, r6, r4
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80017a6:	ea05 0702 	and.w	r7, r5, r2

    if (currentpin == pos)
 80017aa:	42af      	cmp	r7, r5
 80017ac:	d1ed      	bne.n	800178a <GPIO_Init+0x12>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80017ae:	f8d0 9000 	ldr.w	r9, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80017b2:	f891 8004 	ldrb.w	r8, [r1, #4]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80017b6:	fa0c f503 	lsl.w	r5, ip, r3
 80017ba:	43ed      	mvns	r5, r5
 80017bc:	ea05 0a09 	and.w	sl, r5, r9
 80017c0:	f8c0 a000 	str.w	sl, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80017c4:	f8d0 9000 	ldr.w	r9, [r0]
 80017c8:	fa08 fa03 	lsl.w	sl, r8, r3

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80017cc:	f108 38ff 	add.w	r8, r8, #4294967295
 80017d0:	fa5f f888 	uxtb.w	r8, r8
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80017d4:	ea4a 0909 	orr.w	r9, sl, r9

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80017d8:	f1b8 0f01 	cmp.w	r8, #1
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80017dc:	f8c0 9000 	str.w	r9, [r0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80017e0:	d93d      	bls.n	800185e <GPIO_Init+0xe6>
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 80017e2:	68c7      	ldr	r7, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80017e4:	f891 8007 	ldrb.w	r8, [r1, #7]
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 80017e8:	403d      	ands	r5, r7
 80017ea:	60c5      	str	r5, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80017ec:	68c7      	ldr	r7, [r0, #12]
 80017ee:	fa08 f503 	lsl.w	r5, r8, r3
 80017f2:	433d      	orrs	r5, r7
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80017f4:	3401      	adds	r4, #1
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80017f6:	60c5      	str	r5, [r0, #12]

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
  {
    pos = ((uint32_t)0x01) << pinpos;
 80017f8:	fa16 f504 	lsls.w	r5, r6, r4
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80017fc:	ea05 0702 	and.w	r7, r5, r2
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8001800:	3302      	adds	r3, #2
  {
    pos = ((uint32_t)0x01) << pinpos;
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
 8001802:	42af      	cmp	r7, r5
 8001804:	d1c9      	bne.n	800179a <GPIO_Init+0x22>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8001806:	f8d0 9000 	ldr.w	r9, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 800180a:	f891 8004 	ldrb.w	r8, [r1, #4]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 800180e:	fa0c f503 	lsl.w	r5, ip, r3
 8001812:	43ed      	mvns	r5, r5
 8001814:	ea05 0a09 	and.w	sl, r5, r9
 8001818:	f8c0 a000 	str.w	sl, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 800181c:	f8d0 9000 	ldr.w	r9, [r0]
 8001820:	fa08 fa03 	lsl.w	sl, r8, r3

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8001824:	f108 38ff 	add.w	r8, r8, #4294967295
 8001828:	fa5f f888 	uxtb.w	r8, r8
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 800182c:	ea4a 0909 	orr.w	r9, sl, r9

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8001830:	f1b8 0f01 	cmp.w	r8, #1
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8001834:	f8c0 9000 	str.w	r9, [r0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8001838:	d931      	bls.n	800189e <GPIO_Init+0x126>
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 800183a:	68c7      	ldr	r7, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 800183c:	f891 8007 	ldrb.w	r8, [r1, #7]
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8001840:	ea05 0707 	and.w	r7, r5, r7
 8001844:	60c7      	str	r7, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8001846:	68c7      	ldr	r7, [r0, #12]
 8001848:	fa08 f503 	lsl.w	r5, r8, r3
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800184c:	3401      	adds	r4, #1
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 800184e:	433d      	orrs	r5, r7
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8001850:	3302      	adds	r3, #2
 8001852:	2c10      	cmp	r4, #16
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8001854:	60c5      	str	r5, [r0, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8001856:	d1a4      	bne.n	80017a2 <GPIO_Init+0x2a>
      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 8001858:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 800185c:	4770      	bx	lr
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 800185e:	f8d0 a008 	ldr.w	sl, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8001862:	f891 9005 	ldrb.w	r9, [r1, #5]
        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8001866:	f891 8006 	ldrb.w	r8, [r1, #6]
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 800186a:	ea05 0a0a 	and.w	sl, r5, sl
 800186e:	f8c0 a008 	str.w	sl, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8001872:	f8d0 a008 	ldr.w	sl, [r0, #8]
 8001876:	fa09 f903 	lsl.w	r9, r9, r3
 800187a:	ea49 090a 	orr.w	r9, r9, sl
 800187e:	f8c0 9008 	str.w	r9, [r0, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 8001882:	f8d0 9004 	ldr.w	r9, [r0, #4]
 8001886:	ea29 0707 	bic.w	r7, r9, r7
 800188a:	6047      	str	r7, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 800188c:	6847      	ldr	r7, [r0, #4]
 800188e:	fa08 f804 	lsl.w	r8, r8, r4
 8001892:	fa1f f888 	uxth.w	r8, r8
 8001896:	ea48 0707 	orr.w	r7, r8, r7
 800189a:	6047      	str	r7, [r0, #4]
 800189c:	e7a1      	b.n	80017e2 <GPIO_Init+0x6a>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 800189e:	f8d0 a008 	ldr.w	sl, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 80018a2:	f891 9005 	ldrb.w	r9, [r1, #5]
        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 80018a6:	f891 8006 	ldrb.w	r8, [r1, #6]
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 80018aa:	ea05 0a0a 	and.w	sl, r5, sl
 80018ae:	f8c0 a008 	str.w	sl, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 80018b2:	f8d0 a008 	ldr.w	sl, [r0, #8]
 80018b6:	fa09 f903 	lsl.w	r9, r9, r3
 80018ba:	ea49 090a 	orr.w	r9, r9, sl
 80018be:	f8c0 9008 	str.w	r9, [r0, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 80018c2:	f8d0 9004 	ldr.w	r9, [r0, #4]
 80018c6:	ea29 0707 	bic.w	r7, r9, r7
 80018ca:	6047      	str	r7, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 80018cc:	6847      	ldr	r7, [r0, #4]
 80018ce:	fa08 f804 	lsl.w	r8, r8, r4
 80018d2:	fa1f f888 	uxth.w	r8, r8
 80018d6:	ea48 0707 	orr.w	r7, r8, r7
 80018da:	6047      	str	r7, [r0, #4]
 80018dc:	e7ad      	b.n	800183a <GPIO_Init+0xc2>
 80018de:	bf00      	nop

080018e0 <GPIO_StructInit>:
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 80018e0:	2300      	movs	r3, #0
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 80018e2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80018e6:	6002      	str	r2, [r0, #0]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 80018e8:	7103      	strb	r3, [r0, #4]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 80018ea:	7143      	strb	r3, [r0, #5]
  GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
 80018ec:	7183      	strb	r3, [r0, #6]
  GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
 80018ee:	71c3      	strb	r3, [r0, #7]
}
 80018f0:	4770      	bx	lr
 80018f2:	bf00      	nop

080018f4 <GPIO_PinLockConfig>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80018f4:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0x00010000;
 80018f6:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80018fa:	9201      	str	r2, [sp, #4]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  tmp |= GPIO_Pin;
 80018fc:	9b01      	ldr	r3, [sp, #4]
 80018fe:	ea41 0203 	orr.w	r2, r1, r3
 8001902:	9201      	str	r2, [sp, #4]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8001904:	9b01      	ldr	r3, [sp, #4]
 8001906:	61c3      	str	r3, [r0, #28]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 8001908:	61c1      	str	r1, [r0, #28]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 800190a:	9a01      	ldr	r2, [sp, #4]
 800190c:	61c2      	str	r2, [r0, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 800190e:	69c1      	ldr	r1, [r0, #28]
 8001910:	9101      	str	r1, [sp, #4]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8001912:	69c3      	ldr	r3, [r0, #28]
 8001914:	9301      	str	r3, [sp, #4]
}
 8001916:	b002      	add	sp, #8
 8001918:	4770      	bx	lr
 800191a:	bf00      	nop

0800191c <GPIO_ReadInputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 800191c:	6903      	ldr	r3, [r0, #16]
  {
    bitstatus = (uint8_t)Bit_SET;
 800191e:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 8001920:	bf0c      	ite	eq
 8001922:	2000      	moveq	r0, #0
 8001924:	2001      	movne	r0, #1
 8001926:	4770      	bx	lr

08001928 <GPIO_ReadInputData>:
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->IDR);
 8001928:	6900      	ldr	r0, [r0, #16]
}
 800192a:	b280      	uxth	r0, r0
 800192c:	4770      	bx	lr
 800192e:	bf00      	nop

08001930 <GPIO_ReadOutputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8001930:	6943      	ldr	r3, [r0, #20]
  {
    bitstatus = (uint8_t)Bit_SET;
 8001932:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 8001934:	bf0c      	ite	eq
 8001936:	2000      	moveq	r0, #0
 8001938:	2001      	movne	r0, #1
 800193a:	4770      	bx	lr

0800193c <GPIO_ReadOutputData>:
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->ODR);
 800193c:	6940      	ldr	r0, [r0, #20]
}
 800193e:	b280      	uxth	r0, r0
 8001940:	4770      	bx	lr
 8001942:	bf00      	nop

08001944 <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRL = GPIO_Pin;
 8001944:	8301      	strh	r1, [r0, #24]
}
 8001946:	4770      	bx	lr

08001948 <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRH = GPIO_Pin;
 8001948:	8341      	strh	r1, [r0, #26]
}
 800194a:	4770      	bx	lr

0800194c <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
 800194c:	b90a      	cbnz	r2, 8001952 <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRRL = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRRH = GPIO_Pin ;
 800194e:	8341      	strh	r1, [r0, #26]
 8001950:	4770      	bx	lr
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
  {
    GPIOx->BSRRL = GPIO_Pin;
 8001952:	8301      	strh	r1, [r0, #24]
 8001954:	4770      	bx	lr
 8001956:	bf00      	nop

08001958 <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR = PortVal;
 8001958:	6141      	str	r1, [r0, #20]
}
 800195a:	4770      	bx	lr

0800195c <GPIO_ToggleBits>:
void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR ^= GPIO_Pin;
 800195c:	6942      	ldr	r2, [r0, #20]
 800195e:	ea81 0302 	eor.w	r3, r1, r2
 8001962:	6143      	str	r3, [r0, #20]
}
 8001964:	4770      	bx	lr
 8001966:	bf00      	nop

08001968 <GPIO_PinAFConfig>:
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8001968:	08cb      	lsrs	r3, r1, #3
 800196a:	3308      	adds	r3, #8
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 800196c:	f001 0107 	and.w	r1, r1, #7
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8001970:	b430      	push	{r4, r5}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8001972:	0089      	lsls	r1, r1, #2
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8001974:	f850 5023 	ldr.w	r5, [r0, r3, lsl #2]
 8001978:	240f      	movs	r4, #15
 800197a:	408c      	lsls	r4, r1
 800197c:	ea25 0404 	bic.w	r4, r5, r4
 8001980:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8001984:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8001988:	fa12 f101 	lsls.w	r1, r2, r1
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 800198c:	ea41 0404 	orr.w	r4, r1, r4
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 8001990:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
}
 8001994:	bc30      	pop	{r4, r5}
 8001996:	4770      	bx	lr

08001998 <usbd_cdc_EP0_RxReady>:
  *         Data received on control endpoint
  * @param  pdev: device device instance
  * @retval status
  */
static uint8_t  usbd_cdc_EP0_RxReady (void  *pdev)
{ 
 8001998:	b510      	push	{r4, lr}
  if (cdcCmd != NO_CMD)
 800199a:	4c07      	ldr	r4, [pc, #28]	; (80019b8 <usbd_cdc_EP0_RxReady+0x20>)
 800199c:	6820      	ldr	r0, [r4, #0]
 800199e:	28ff      	cmp	r0, #255	; 0xff
 80019a0:	d007      	beq.n	80019b2 <usbd_cdc_EP0_RxReady+0x1a>
  {
    /* Process the data */
    APP_FOPS.pIf_Ctrl(cdcCmd, CmdBuff, cdcLen);
 80019a2:	4906      	ldr	r1, [pc, #24]	; (80019bc <usbd_cdc_EP0_RxReady+0x24>)
 80019a4:	4a06      	ldr	r2, [pc, #24]	; (80019c0 <usbd_cdc_EP0_RxReady+0x28>)
 80019a6:	688b      	ldr	r3, [r1, #8]
 80019a8:	6812      	ldr	r2, [r2, #0]
 80019aa:	4906      	ldr	r1, [pc, #24]	; (80019c4 <usbd_cdc_EP0_RxReady+0x2c>)
 80019ac:	4798      	blx	r3
    
    /* Reset the command variable to default value */
    cdcCmd = NO_CMD;
 80019ae:	23ff      	movs	r3, #255	; 0xff
 80019b0:	6023      	str	r3, [r4, #0]
  }
  
  return USBD_OK;
}
 80019b2:	2000      	movs	r0, #0
 80019b4:	bd10      	pop	{r4, pc}
 80019b6:	bf00      	nop
 80019b8:	20000090 	.word	0x20000090
 80019bc:	2000013c 	.word	0x2000013c
 80019c0:	20000e14 	.word	0x20000e14
 80019c4:	200021b8 	.word	0x200021b8

080019c8 <USBD_cdc_GetCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_cdc_GetCfgDesc (uint8_t speed, uint16_t *length)
{
  *length = sizeof (usbd_cdc_CfgDesc);
 80019c8:	2343      	movs	r3, #67	; 0x43
 80019ca:	800b      	strh	r3, [r1, #0]
  return usbd_cdc_CfgDesc;
}
 80019cc:	4800      	ldr	r0, [pc, #0]	; (80019d0 <USBD_cdc_GetCfgDesc+0x8>)
 80019ce:	4770      	bx	lr
 80019d0:	20000094 	.word	0x20000094

080019d4 <usbd_cdc_SOF>:
  * @param  pdev: instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  usbd_cdc_SOF (void *pdev)
{      
 80019d4:	b538      	push	{r3, r4, r5, lr}
  static uint32_t FrameCount = 0;
  
  if (FrameCount++ == CDC_IN_FRAME_INTERVAL)
 80019d6:	4c1f      	ldr	r4, [pc, #124]	; (8001a54 <usbd_cdc_SOF+0x80>)
 80019d8:	6863      	ldr	r3, [r4, #4]
 80019da:	1c5a      	adds	r2, r3, #1
 80019dc:	2b05      	cmp	r3, #5
 80019de:	6062      	str	r2, [r4, #4]
 80019e0:	d001      	beq.n	80019e6 <usbd_cdc_SOF+0x12>
    /* Check the data to be sent through IN pipe */
    Handle_USBAsynchXfer(pdev);
  }
  
  return USBD_OK;
}
 80019e2:	2000      	movs	r0, #0
 80019e4:	bd38      	pop	{r3, r4, r5, pc}
static void Handle_USBAsynchXfer (void *pdev)
{
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;
  
  if(USB_Tx_State != 1)
 80019e6:	f894 c008 	ldrb.w	ip, [r4, #8]
  static uint32_t FrameCount = 0;
  
  if (FrameCount++ == CDC_IN_FRAME_INTERVAL)
  {
    /* Reset the frame counter */
    FrameCount = 0;
 80019ea:	2300      	movs	r3, #0
static void Handle_USBAsynchXfer (void *pdev)
{
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;
  
  if(USB_Tx_State != 1)
 80019ec:	f1bc 0f01 	cmp.w	ip, #1
  static uint32_t FrameCount = 0;
  
  if (FrameCount++ == CDC_IN_FRAME_INTERVAL)
  {
    /* Reset the frame counter */
    FrameCount = 0;
 80019f0:	6063      	str	r3, [r4, #4]
static void Handle_USBAsynchXfer (void *pdev)
{
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;
  
  if(USB_Tx_State != 1)
 80019f2:	d0f6      	beq.n	80019e2 <usbd_cdc_SOF+0xe>
  {
    if (APP_Rx_ptr_out == APP_RX_DATA_SIZE)
 80019f4:	68e5      	ldr	r5, [r4, #12]
    {
      APP_Rx_ptr_out = 0;
    }
    
    if(APP_Rx_ptr_out == APP_Rx_ptr_in) 
 80019f6:	4a17      	ldr	r2, [pc, #92]	; (8001a54 <usbd_cdc_SOF+0x80>)
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;
  
  if(USB_Tx_State != 1)
  {
    if (APP_Rx_ptr_out == APP_RX_DATA_SIZE)
 80019f8:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
    {
      APP_Rx_ptr_out = 0;
 80019fc:	bf04      	itt	eq
 80019fe:	60e3      	streq	r3, [r4, #12]
 8001a00:	461d      	moveq	r5, r3
    }
    
    if(APP_Rx_ptr_out == APP_Rx_ptr_in) 
 8001a02:	6923      	ldr	r3, [r4, #16]
 8001a04:	42ab      	cmp	r3, r5
 8001a06:	d021      	beq.n	8001a4c <usbd_cdc_SOF+0x78>
      APP_Rx_length = APP_RX_DATA_SIZE - APP_Rx_ptr_out;
    
    }
    else 
    {
      APP_Rx_length = APP_Rx_ptr_in - APP_Rx_ptr_out;
 8001a08:	bf28      	it	cs
 8001a0a:	ebc5 0103 	rsbcs	r1, r5, r3
    }
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     APP_Rx_length &= ~0x03;
#endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    
    if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE)
 8001a0e:	f8d0 35ec 	ldr.w	r3, [r0, #1516]	; 0x5ec
 8001a12:	f8b3 3039 	ldrh.w	r3, [r3, #57]	; 0x39
      return;
    }
    
    if(APP_Rx_ptr_out > APP_Rx_ptr_in) /* rollback */
    { 
      APP_Rx_length = APP_RX_DATA_SIZE - APP_Rx_ptr_out;
 8001a16:	bf38      	it	cc
 8001a18:	f5c5 6100 	rsbcc	r1, r5, #2048	; 0x800
    }
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     APP_Rx_length &= ~0x03;
#endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    
    if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE)
 8001a1c:	428b      	cmp	r3, r1
      APP_Rx_length = APP_RX_DATA_SIZE - APP_Rx_ptr_out;
    
    }
    else 
    {
      APP_Rx_length = APP_Rx_ptr_in - APP_Rx_ptr_out;
 8001a1e:	6151      	str	r1, [r2, #20]
    }
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     APP_Rx_length &= ~0x03;
#endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    
    if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE)
 8001a20:	d20d      	bcs.n	8001a3e <usbd_cdc_SOF+0x6a>
    {
      USB_Tx_ptr = APP_Rx_ptr_out;
      USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
      
      APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;	
 8001a22:	18ea      	adds	r2, r5, r3
      APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;
 8001a24:	1ac9      	subs	r1, r1, r3
     APP_Rx_length &= ~0x03;
#endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    
    if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE)
    {
      USB_Tx_ptr = APP_Rx_ptr_out;
 8001a26:	b2ad      	uxth	r5, r5
      USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
      
      APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;	
 8001a28:	60e2      	str	r2, [r4, #12]
      APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;
 8001a2a:	6161      	str	r1, [r4, #20]
      APP_Rx_ptr_out += APP_Rx_length;
      APP_Rx_length = 0;
    }
    USB_Tx_State = 1; 

    DCD_EP_Tx (pdev,
 8001a2c:	4a0a      	ldr	r2, [pc, #40]	; (8001a58 <usbd_cdc_SOF+0x84>)
 8001a2e:	2181      	movs	r1, #129	; 0x81
 8001a30:	1952      	adds	r2, r2, r5
      USB_Tx_length = APP_Rx_length;
      
      APP_Rx_ptr_out += APP_Rx_length;
      APP_Rx_length = 0;
    }
    USB_Tx_State = 1; 
 8001a32:	2501      	movs	r5, #1
 8001a34:	7225      	strb	r5, [r4, #8]

    DCD_EP_Tx (pdev,
 8001a36:	f001 f871 	bl	8002b1c <DCD_EP_Tx>
    /* Check the data to be sent through IN pipe */
    Handle_USBAsynchXfer(pdev);
  }
  
  return USBD_OK;
}
 8001a3a:	2000      	movs	r0, #0
 8001a3c:	bd38      	pop	{r3, r4, r5, pc}
    else
    {
      USB_Tx_ptr = APP_Rx_ptr_out;
      USB_Tx_length = APP_Rx_length;
      
      APP_Rx_ptr_out += APP_Rx_length;
 8001a3e:	194a      	adds	r2, r1, r5
      APP_Rx_length = 0;
 8001a40:	2300      	movs	r3, #0
 8001a42:	6163      	str	r3, [r4, #20]
      APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;	
      APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;
    }
    else
    {
      USB_Tx_ptr = APP_Rx_ptr_out;
 8001a44:	b2ad      	uxth	r5, r5
      USB_Tx_length = APP_Rx_length;
      
      APP_Rx_ptr_out += APP_Rx_length;
 8001a46:	60e2      	str	r2, [r4, #12]
      APP_Rx_length = 0;
 8001a48:	b28b      	uxth	r3, r1
 8001a4a:	e7ef      	b.n	8001a2c <usbd_cdc_SOF+0x58>
      APP_Rx_ptr_out = 0;
    }
    
    if(APP_Rx_ptr_out == APP_Rx_ptr_in) 
    {
      USB_Tx_State = 0; 
 8001a4c:	2000      	movs	r0, #0
 8001a4e:	7210      	strb	r0, [r2, #8]
 8001a50:	e7c7      	b.n	80019e2 <usbd_cdc_SOF+0xe>
 8001a52:	bf00      	nop
 8001a54:	20000e14 	.word	0x20000e14
 8001a58:	200021c0 	.word	0x200021c0

08001a5c <usbd_cdc_DataIn>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  usbd_cdc_DataIn (void *pdev, uint8_t epnum)
{
 8001a5c:	b538      	push	{r3, r4, r5, lr}
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;

  if (USB_Tx_State == 1)
 8001a5e:	4913      	ldr	r1, [pc, #76]	; (8001aac <usbd_cdc_DataIn+0x50>)
 8001a60:	7a0b      	ldrb	r3, [r1, #8]
 8001a62:	2b01      	cmp	r3, #1
 8001a64:	d001      	beq.n	8001a6a <usbd_cdc_DataIn+0xe>
                 USB_Tx_length);
    }
  }  
  
  return USBD_OK;
}
 8001a66:	2000      	movs	r0, #0
 8001a68:	bd38      	pop	{r3, r4, r5, pc}
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;

  if (USB_Tx_State == 1)
  {
    if (APP_Rx_length == 0) 
 8001a6a:	694c      	ldr	r4, [r1, #20]
 8001a6c:	b1d4      	cbz	r4, 8001aa4 <usbd_cdc_DataIn+0x48>
    {
      USB_Tx_State = 0;
    }
    else 
    {
      if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE){
 8001a6e:	f8d0 25ec 	ldr.w	r2, [r0, #1516]	; 0x5ec
 8001a72:	f8b2 3039 	ldrh.w	r3, [r2, #57]	; 0x39
 8001a76:	429c      	cmp	r4, r3
 8001a78:	d80d      	bhi.n	8001a96 <usbd_cdc_DataIn+0x3a>
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
        APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;    
      }
      else 
      {
        USB_Tx_ptr = APP_Rx_ptr_out;
 8001a7a:	68ca      	ldr	r2, [r1, #12]
        USB_Tx_length = APP_Rx_length;
        
        APP_Rx_ptr_out += APP_Rx_length;
 8001a7c:	1913      	adds	r3, r2, r4
 8001a7e:	60cb      	str	r3, [r1, #12]
        APP_Rx_length = 0;
 8001a80:	2300      	movs	r3, #0
 8001a82:	614b      	str	r3, [r1, #20]
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
        APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;    
      }
      else 
      {
        USB_Tx_ptr = APP_Rx_ptr_out;
 8001a84:	b292      	uxth	r2, r2
        USB_Tx_length = APP_Rx_length;
        
        APP_Rx_ptr_out += APP_Rx_length;
        APP_Rx_length = 0;
 8001a86:	b2a3      	uxth	r3, r4
      }
      
      /* Prepare the available data buffer to be sent on IN endpoint */
      DCD_EP_Tx (pdev,
 8001a88:	4c09      	ldr	r4, [pc, #36]	; (8001ab0 <usbd_cdc_DataIn+0x54>)
 8001a8a:	2181      	movs	r1, #129	; 0x81
 8001a8c:	18a2      	adds	r2, r4, r2
 8001a8e:	f001 f845 	bl	8002b1c <DCD_EP_Tx>
                 USB_Tx_length);
    }
  }  
  
  return USBD_OK;
}
 8001a92:	2000      	movs	r0, #0
 8001a94:	bd38      	pop	{r3, r4, r5, pc}
      USB_Tx_State = 0;
    }
    else 
    {
      if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE){
        USB_Tx_ptr = APP_Rx_ptr_out;
 8001a96:	68ca      	ldr	r2, [r1, #12]
        USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
        
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
        APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;    
 8001a98:	1ae4      	subs	r4, r4, r3
    {
      if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE){
        USB_Tx_ptr = APP_Rx_ptr_out;
        USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
        
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
 8001a9a:	189d      	adds	r5, r3, r2
 8001a9c:	60cd      	str	r5, [r1, #12]
      USB_Tx_State = 0;
    }
    else 
    {
      if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE){
        USB_Tx_ptr = APP_Rx_ptr_out;
 8001a9e:	b292      	uxth	r2, r2
        USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
        
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
        APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;    
 8001aa0:	614c      	str	r4, [r1, #20]
 8001aa2:	e7f1      	b.n	8001a88 <usbd_cdc_DataIn+0x2c>

  if (USB_Tx_State == 1)
  {
    if (APP_Rx_length == 0) 
    {
      USB_Tx_State = 0;
 8001aa4:	720c      	strb	r4, [r1, #8]
                 USB_Tx_length);
    }
  }  
  
  return USBD_OK;
}
 8001aa6:	2000      	movs	r0, #0
 8001aa8:	bd38      	pop	{r3, r4, r5, pc}
 8001aaa:	bf00      	nop
 8001aac:	20000e14 	.word	0x20000e14
 8001ab0:	200021c0 	.word	0x200021c0

08001ab4 <usbd_cdc_DataOut>:
static uint8_t  usbd_cdc_DataOut (void *pdev, uint8_t epnum)
{      
  uint16_t USB_Rx_Cnt;
  
  /* Get the received data buffer and update the counter */
  USB_Rx_Cnt = ((USB_OTG_CORE_HANDLE*)pdev)->dev.out_ep[epnum].xfer_count;
 8001ab4:	eb01 0c81 	add.w	ip, r1, r1, lsl #2
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  usbd_cdc_DataOut (void *pdev, uint8_t epnum)
{      
 8001ab8:	b538      	push	{r3, r4, r5, lr}
  uint16_t USB_Rx_Cnt;
  
  /* Get the received data buffer and update the counter */
  USB_Rx_Cnt = ((USB_OTG_CORE_HANDLE*)pdev)->dev.out_ep[epnum].xfer_count;
 8001aba:	eb00 01cc 	add.w	r1, r0, ip, lsl #3
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  usbd_cdc_DataOut (void *pdev, uint8_t epnum)
{      
 8001abe:	4604      	mov	r4, r0
  /* Get the received data buffer and update the counter */
  USB_Rx_Cnt = ((USB_OTG_CORE_HANDLE*)pdev)->dev.out_ep[epnum].xfer_count;
  
  /* USB data will be immediately processed, this allow next USB traffic being 
     NAKed till the end of the application Xfer */
  APP_FOPS.pIf_DataRx(USB_Rx_Buffer, USB_Rx_Cnt);
 8001ac0:	4d08      	ldr	r5, [pc, #32]	; (8001ae4 <usbd_cdc_DataOut+0x30>)
 8001ac2:	4809      	ldr	r0, [pc, #36]	; (8001ae8 <usbd_cdc_DataOut+0x34>)
 8001ac4:	f8b1 1388 	ldrh.w	r1, [r1, #904]	; 0x388
 8001ac8:	6902      	ldr	r2, [r0, #16]
 8001aca:	4628      	mov	r0, r5
 8001acc:	4790      	blx	r2
  
  /* Prepare Out endpoint to receive next packet */
  DCD_EP_PrepareRx(pdev,
 8001ace:	f8d4 35ec 	ldr.w	r3, [r4, #1516]	; 0x5ec
 8001ad2:	4620      	mov	r0, r4
 8001ad4:	2101      	movs	r1, #1
 8001ad6:	462a      	mov	r2, r5
 8001ad8:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8001adc:	f000 fff4 	bl	8002ac8 <DCD_EP_PrepareRx>
                   CDC_OUT_EP,
                   (uint8_t*)(USB_Rx_Buffer),
                   CDC_DATA_OUT_PACKET_SIZE);

  return USBD_OK;
}
 8001ae0:	2000      	movs	r0, #0
 8001ae2:	bd38      	pop	{r3, r4, r5, pc}
 8001ae4:	20002178 	.word	0x20002178
 8001ae8:	2000013c 	.word	0x2000013c

08001aec <usbd_cdc_Setup>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t  usbd_cdc_Setup (void  *pdev, 
                                USB_SETUP_REQ *req)
{
 8001aec:	b570      	push	{r4, r5, r6, lr}
  uint16_t len;
  uint8_t  *pbuf;
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8001aee:	780b      	ldrb	r3, [r1, #0]
 8001af0:	f013 0560 	ands.w	r5, r3, #96	; 0x60
  * @param  req: usb requests
  * @retval status
  */
static uint8_t  usbd_cdc_Setup (void  *pdev, 
                                USB_SETUP_REQ *req)
{
 8001af4:	460c      	mov	r4, r1
 8001af6:	4606      	mov	r6, r0
  uint16_t len;
  uint8_t  *pbuf;
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8001af8:	d108      	bne.n	8001b0c <usbd_cdc_Setup+0x20>
    
      
      
    /* Standard Requests -------------------------------*/
  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
 8001afa:	784b      	ldrb	r3, [r1, #1]
 8001afc:	2b0a      	cmp	r3, #10
 8001afe:	d01c      	beq.n	8001b3a <usbd_cdc_Setup+0x4e>
 8001b00:	2b0b      	cmp	r3, #11
 8001b02:	d02d      	beq.n	8001b60 <usbd_cdc_Setup+0x74>
 8001b04:	2b06      	cmp	r3, #6
 8001b06:	d031      	beq.n	8001b6c <usbd_cdc_Setup+0x80>
        USBD_CtlError (pdev, req);
      }
      break;
    }
  }
  return USBD_OK;
 8001b08:	4628      	mov	r0, r5
}
 8001b0a:	bd70      	pop	{r4, r5, r6, pc}
                                USB_SETUP_REQ *req)
{
  uint16_t len;
  uint8_t  *pbuf;
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8001b0c:	2d20      	cmp	r5, #32
 8001b0e:	d003      	beq.n	8001b18 <usbd_cdc_Setup+0x2c>
      }
      
      return USBD_OK;
      
    default:
      USBD_CtlError (pdev, req);
 8001b10:	f001 fd0e 	bl	8003530 <USBD_CtlError>
      return USBD_FAIL;
 8001b14:	2002      	movs	r0, #2
 8001b16:	bd70      	pop	{r4, r5, r6, pc}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
  {
    /* CDC Class Requests -------------------------------*/
  case USB_REQ_TYPE_CLASS :
      /* Check if the request is a data setup packet */
      if (req->wLength)
 8001b18:	88cd      	ldrh	r5, [r1, #6]
 8001b1a:	2d00      	cmp	r5, #0
 8001b1c:	d034      	beq.n	8001b88 <usbd_cdc_Setup+0x9c>
      {
        /* Check if the request is Device-to-Host */
        if (req->bmRequest & 0x80)
 8001b1e:	f013 0f80 	tst.w	r3, #128	; 0x80
 8001b22:	d110      	bne.n	8001b46 <usbd_cdc_Setup+0x5a>
                            req->wLength);          
        }
        else /* Host-to-Device requeset */
        {
          /* Set the value of the current command to be processed */
          cdcCmd = req->bRequest;
 8001b24:	784a      	ldrb	r2, [r1, #1]
 8001b26:	4b1e      	ldr	r3, [pc, #120]	; (8001ba0 <usbd_cdc_Setup+0xb4>)
          cdcLen = req->wLength;
          
          /* Prepare the reception of the buffer over EP0
          Next step: the received data will be managed in usbd_cdc_EP0_TxSent() 
          function. */
          USBD_CtlPrepareRx (pdev,
 8001b28:	491e      	ldr	r1, [pc, #120]	; (8001ba4 <usbd_cdc_Setup+0xb8>)
                            req->wLength);          
        }
        else /* Host-to-Device requeset */
        {
          /* Set the value of the current command to be processed */
          cdcCmd = req->bRequest;
 8001b2a:	601a      	str	r2, [r3, #0]
          cdcLen = req->wLength;
 8001b2c:	4b1e      	ldr	r3, [pc, #120]	; (8001ba8 <usbd_cdc_Setup+0xbc>)
          
          /* Prepare the reception of the buffer over EP0
          Next step: the received data will be managed in usbd_cdc_EP0_TxSent() 
          function. */
          USBD_CtlPrepareRx (pdev,
 8001b2e:	462a      	mov	r2, r5
        }
        else /* Host-to-Device requeset */
        {
          /* Set the value of the current command to be processed */
          cdcCmd = req->bRequest;
          cdcLen = req->wLength;
 8001b30:	601d      	str	r5, [r3, #0]
          
          /* Prepare the reception of the buffer over EP0
          Next step: the received data will be managed in usbd_cdc_EP0_TxSent() 
          function. */
          USBD_CtlPrepareRx (pdev,
 8001b32:	f001 fc91 	bl	8003458 <USBD_CtlPrepareRx>
      {
        /* Transfer the command to the interface layer */
        APP_FOPS.pIf_Ctrl(req->bRequest, NULL, 0);
      }
      
      return USBD_OK;
 8001b36:	2000      	movs	r0, #0
 8001b38:	bd70      	pop	{r4, r5, r6, pc}
                        pbuf,
                        len);
      break;
      
    case USB_REQ_GET_INTERFACE :
      USBD_CtlSendData (pdev,
 8001b3a:	491c      	ldr	r1, [pc, #112]	; (8001bac <usbd_cdc_Setup+0xc0>)
 8001b3c:	2201      	movs	r2, #1
 8001b3e:	f001 fc71 	bl	8003424 <USBD_CtlSendData>
        USBD_CtlError (pdev, req);
      }
      break;
    }
  }
  return USBD_OK;
 8001b42:	4628      	mov	r0, r5
      
    case USB_REQ_GET_INTERFACE :
      USBD_CtlSendData (pdev,
                        (uint8_t *)&usbd_cdc_AltSet,
                        1);
      break;
 8001b44:	bd70      	pop	{r4, r5, r6, pc}
      {
        /* Check if the request is Device-to-Host */
        if (req->bmRequest & 0x80)
        {
          /* Get the data to be sent to Host from interface layer */
          APP_FOPS.pIf_Ctrl(req->bRequest, CmdBuff, req->wLength);
 8001b46:	481a      	ldr	r0, [pc, #104]	; (8001bb0 <usbd_cdc_Setup+0xc4>)
 8001b48:	4916      	ldr	r1, [pc, #88]	; (8001ba4 <usbd_cdc_Setup+0xb8>)
 8001b4a:	6883      	ldr	r3, [r0, #8]
 8001b4c:	7860      	ldrb	r0, [r4, #1]
 8001b4e:	462a      	mov	r2, r5
 8001b50:	4798      	blx	r3
          
          /* Send the data to the host */
          USBD_CtlSendData (pdev, 
 8001b52:	4630      	mov	r0, r6
 8001b54:	4913      	ldr	r1, [pc, #76]	; (8001ba4 <usbd_cdc_Setup+0xb8>)
 8001b56:	88e2      	ldrh	r2, [r4, #6]
 8001b58:	f001 fc64 	bl	8003424 <USBD_CtlSendData>
      {
        /* Transfer the command to the interface layer */
        APP_FOPS.pIf_Ctrl(req->bRequest, NULL, 0);
      }
      
      return USBD_OK;
 8001b5c:	2000      	movs	r0, #0
 8001b5e:	bd70      	pop	{r4, r5, r6, pc}
                        (uint8_t *)&usbd_cdc_AltSet,
                        1);
      break;
      
    case USB_REQ_SET_INTERFACE :
      if ((uint8_t)(req->wValue) < USBD_ITF_MAX_NUM)
 8001b60:	788b      	ldrb	r3, [r1, #2]
 8001b62:	b9cb      	cbnz	r3, 8001b98 <usbd_cdc_Setup+0xac>
      {
        usbd_cdc_AltSet = (uint8_t)(req->wValue);
 8001b64:	4a10      	ldr	r2, [pc, #64]	; (8001ba8 <usbd_cdc_Setup+0xbc>)
        USBD_CtlError (pdev, req);
      }
      break;
    }
  }
  return USBD_OK;
 8001b66:	4618      	mov	r0, r3
      break;
      
    case USB_REQ_SET_INTERFACE :
      if ((uint8_t)(req->wValue) < USBD_ITF_MAX_NUM)
      {
        usbd_cdc_AltSet = (uint8_t)(req->wValue);
 8001b68:	6193      	str	r3, [r2, #24]
 8001b6a:	bd70      	pop	{r4, r5, r6, pc}
    /* Standard Requests -------------------------------*/
  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
    {
    case USB_REQ_GET_DESCRIPTOR: 
      if( (req->wValue >> 8) == CDC_DESCRIPTOR_TYPE)
 8001b6c:	884b      	ldrh	r3, [r1, #2]
 8001b6e:	0a18      	lsrs	r0, r3, #8
 8001b70:	2821      	cmp	r0, #33	; 0x21
 8001b72:	d103      	bne.n	8001b7c <usbd_cdc_Setup+0x90>
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
        pbuf = usbd_cdc_Desc;   
#else
        pbuf = usbd_cdc_CfgDesc + 9 + (9 * USBD_ITF_MAX_NUM);
#endif 
        len = MIN(USB_CDC_DESC_SIZ , req->wLength);
 8001b74:	88ca      	ldrh	r2, [r1, #6]
 8001b76:	2a3a      	cmp	r2, #58	; 0x3a
 8001b78:	bf28      	it	cs
 8001b7a:	223a      	movcs	r2, #58	; 0x3a
      }
      
      USBD_CtlSendData (pdev, 
 8001b7c:	4630      	mov	r0, r6
 8001b7e:	490d      	ldr	r1, [pc, #52]	; (8001bb4 <usbd_cdc_Setup+0xc8>)
 8001b80:	f001 fc50 	bl	8003424 <USBD_CtlSendData>
        USBD_CtlError (pdev, req);
      }
      break;
    }
  }
  return USBD_OK;
 8001b84:	2000      	movs	r0, #0
      }
      
      USBD_CtlSendData (pdev, 
                        pbuf,
                        len);
      break;
 8001b86:	bd70      	pop	{r4, r5, r6, pc}
        }
      }
      else /* No Data request */
      {
        /* Transfer the command to the interface layer */
        APP_FOPS.pIf_Ctrl(req->bRequest, NULL, 0);
 8001b88:	7848      	ldrb	r0, [r1, #1]
 8001b8a:	4909      	ldr	r1, [pc, #36]	; (8001bb0 <usbd_cdc_Setup+0xc4>)
 8001b8c:	462a      	mov	r2, r5
 8001b8e:	688b      	ldr	r3, [r1, #8]
 8001b90:	4629      	mov	r1, r5
 8001b92:	4798      	blx	r3
      }
      
      return USBD_OK;
 8001b94:	4628      	mov	r0, r5
 8001b96:	bd70      	pop	{r4, r5, r6, pc}
        usbd_cdc_AltSet = (uint8_t)(req->wValue);
      }
      else
      {
        /* Call the error management function (command will be nacked */
        USBD_CtlError (pdev, req);
 8001b98:	f001 fcca 	bl	8003530 <USBD_CtlError>
      }
      break;
    }
  }
  return USBD_OK;
 8001b9c:	4628      	mov	r0, r5
 8001b9e:	bd70      	pop	{r4, r5, r6, pc}
 8001ba0:	20000090 	.word	0x20000090
 8001ba4:	200021b8 	.word	0x200021b8
 8001ba8:	20000e14 	.word	0x20000e14
 8001bac:	20000e2c 	.word	0x20000e2c
 8001bb0:	2000013c 	.word	0x2000013c
 8001bb4:	200000a6 	.word	0x200000a6

08001bb8 <usbd_cdc_DeInit>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  usbd_cdc_DeInit (void  *pdev, 
                                 uint8_t cfgidx)
{
 8001bb8:	b510      	push	{r4, lr}
  /* Open EP IN */
  DCD_EP_Close(pdev,
 8001bba:	2181      	movs	r1, #129	; 0x81
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  usbd_cdc_DeInit (void  *pdev, 
                                 uint8_t cfgidx)
{
 8001bbc:	4604      	mov	r4, r0
  /* Open EP IN */
  DCD_EP_Close(pdev,
 8001bbe:	f000 ff6d 	bl	8002a9c <DCD_EP_Close>
              CDC_IN_EP);
  
  /* Open EP OUT */
  DCD_EP_Close(pdev,
 8001bc2:	2101      	movs	r1, #1
 8001bc4:	4620      	mov	r0, r4
 8001bc6:	f000 ff69 	bl	8002a9c <DCD_EP_Close>
              CDC_OUT_EP);
  
  /* Open Command IN EP */
  DCD_EP_Close(pdev,
 8001bca:	2182      	movs	r1, #130	; 0x82
 8001bcc:	4620      	mov	r0, r4
 8001bce:	f000 ff65 	bl	8002a9c <DCD_EP_Close>
              CDC_CMD_EP);

  /* Restore default state of the Interface physical components */
  APP_FOPS.pIf_DeInit();
 8001bd2:	4802      	ldr	r0, [pc, #8]	; (8001bdc <usbd_cdc_DeInit+0x24>)
 8001bd4:	6843      	ldr	r3, [r0, #4]
 8001bd6:	4798      	blx	r3
  
  return USBD_OK;
}
 8001bd8:	2000      	movs	r0, #0
 8001bda:	bd10      	pop	{r4, pc}
 8001bdc:	2000013c 	.word	0x2000013c

08001be0 <usbd_cdc_Init>:
                               uint8_t cfgidx)
{
  uint8_t *pbuf;

  /* Open EP IN */
  DCD_EP_Open(pdev,
 8001be0:	f8d0 25ec 	ldr.w	r2, [r0, #1516]	; 0x5ec
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  usbd_cdc_Init (void  *pdev, 
                               uint8_t cfgidx)
{
 8001be4:	b538      	push	{r3, r4, r5, lr}
 8001be6:	4604      	mov	r4, r0
  uint8_t *pbuf;

  /* Open EP IN */
  DCD_EP_Open(pdev,
 8001be8:	2181      	movs	r1, #129	; 0x81
 8001bea:	2302      	movs	r3, #2
 8001bec:	f8b2 2039 	ldrh.w	r2, [r2, #57]	; 0x39
 8001bf0:	f000 ff34 	bl	8002a5c <DCD_EP_Open>
              CDC_IN_EP,
              CDC_DATA_IN_PACKET_SIZE,
              USB_OTG_EP_BULK);
  
  /* Open EP OUT */
  DCD_EP_Open(pdev,
 8001bf4:	f8d4 55ec 	ldr.w	r5, [r4, #1516]	; 0x5ec
 8001bf8:	2101      	movs	r1, #1
 8001bfa:	f8b5 2040 	ldrh.w	r2, [r5, #64]	; 0x40
 8001bfe:	2302      	movs	r3, #2
 8001c00:	4620      	mov	r0, r4
 8001c02:	f000 ff2b 	bl	8002a5c <DCD_EP_Open>
              CDC_OUT_EP,
              CDC_DATA_OUT_PACKET_SIZE,
              USB_OTG_EP_BULK);
  
  /* Open Command IN EP */
  DCD_EP_Open(pdev,
 8001c06:	2182      	movs	r1, #130	; 0x82
 8001c08:	2208      	movs	r2, #8
 8001c0a:	2303      	movs	r3, #3
 8001c0c:	4620      	mov	r0, r4
 8001c0e:	f000 ff25 	bl	8002a5c <DCD_EP_Open>
              CDC_CMD_EP,
              CDC_CMD_PACKET_SZE,
              USB_OTG_EP_INT);
  
  pbuf = (uint8_t *)USBD_DeviceDesc;
  pbuf[4] = DEVICE_CLASS_CDC;
 8001c12:	4b09      	ldr	r3, [pc, #36]	; (8001c38 <usbd_cdc_Init+0x58>)
  pbuf[5] = DEVICE_SUBCLASS_CDC;
  
  /* Initialize the Interface physical components */
  APP_FOPS.pIf_Init();
 8001c14:	4909      	ldr	r1, [pc, #36]	; (8001c3c <usbd_cdc_Init+0x5c>)
              CDC_CMD_EP,
              CDC_CMD_PACKET_SZE,
              USB_OTG_EP_INT);
  
  pbuf = (uint8_t *)USBD_DeviceDesc;
  pbuf[4] = DEVICE_CLASS_CDC;
 8001c16:	2202      	movs	r2, #2
  pbuf[5] = DEVICE_SUBCLASS_CDC;
 8001c18:	2500      	movs	r5, #0
              CDC_CMD_EP,
              CDC_CMD_PACKET_SZE,
              USB_OTG_EP_INT);
  
  pbuf = (uint8_t *)USBD_DeviceDesc;
  pbuf[4] = DEVICE_CLASS_CDC;
 8001c1a:	711a      	strb	r2, [r3, #4]
  pbuf[5] = DEVICE_SUBCLASS_CDC;
 8001c1c:	715d      	strb	r5, [r3, #5]
  
  /* Initialize the Interface physical components */
  APP_FOPS.pIf_Init();
 8001c1e:	6808      	ldr	r0, [r1, #0]
 8001c20:	4780      	blx	r0

  /* Prepare Out endpoint to receive next packet */
  DCD_EP_PrepareRx(pdev,
 8001c22:	f8d4 35ec 	ldr.w	r3, [r4, #1516]	; 0x5ec
 8001c26:	4a06      	ldr	r2, [pc, #24]	; (8001c40 <usbd_cdc_Init+0x60>)
 8001c28:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8001c2c:	4620      	mov	r0, r4
 8001c2e:	2101      	movs	r1, #1
 8001c30:	f000 ff4a 	bl	8002ac8 <DCD_EP_PrepareRx>
                   CDC_OUT_EP,
                   (uint8_t*)(USB_Rx_Buffer),
                   CDC_DATA_OUT_PACKET_SIZE);
  
  return USBD_OK;
}
 8001c34:	4628      	mov	r0, r5
 8001c36:	bd38      	pop	{r3, r4, r5, pc}
 8001c38:	20000040 	.word	0x20000040
 8001c3c:	2000013c 	.word	0x2000013c
 8001c40:	20002178 	.word	0x20002178

08001c44 <USB_OTG_CoreReset.clone.1>:
/**
* @brief  USB_OTG_CoreReset : Soft reset of the core
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
 8001c44:	b530      	push	{r4, r5, lr}
 8001c46:	4605      	mov	r5, r0
 8001c48:	b083      	sub	sp, #12
{
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 8001c4a:	2300      	movs	r3, #0
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 8001c4c:	2003      	movs	r0, #3
{
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 8001c4e:	9301      	str	r3, [sp, #4]
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 8001c50:	f001 ff21 	bl	8003a96 <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001c54:	682b      	ldr	r3, [r5, #0]
 8001c56:	4c1b      	ldr	r4, [pc, #108]	; (8001cc4 <USB_OTG_CoreReset.clone.1+0x80>)
 8001c58:	691a      	ldr	r2, [r3, #16]
 8001c5a:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
    {
      return USB_OTG_OK;
    }
  }
  while (greset.b.ahbidle == 0);
 8001c5c:	9a01      	ldr	r2, [sp, #4]
 8001c5e:	2a00      	cmp	r2, #0
 8001c60:	db14      	blt.n	8001c8c <USB_OTG_CoreReset.clone.1+0x48>
  
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 8001c62:	2003      	movs	r0, #3
 8001c64:	f001 ff17 	bl	8003a96 <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001c68:	682b      	ldr	r3, [r5, #0]
 8001c6a:	6919      	ldr	r1, [r3, #16]
 8001c6c:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
    {
      return USB_OTG_OK;
    }
  }
  while (greset.b.ahbidle == 0);
 8001c6e:	9801      	ldr	r0, [sp, #4]
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001c70:	3c01      	subs	r4, #1
    if (++count > 200000)
    {
      return USB_OTG_OK;
    }
  }
  while (greset.b.ahbidle == 0);
 8001c72:	2800      	cmp	r0, #0
 8001c74:	db0a      	blt.n	8001c8c <USB_OTG_CoreReset.clone.1+0x48>
  
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 8001c76:	2003      	movs	r0, #3
 8001c78:	f001 ff0d 	bl	8003a96 <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001c7c:	682b      	ldr	r3, [r5, #0]
 8001c7e:	691a      	ldr	r2, [r3, #16]
    if (++count > 200000)
 8001c80:	3c01      	subs	r4, #1
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001c82:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 8001c84:	d1ea      	bne.n	8001c5c <USB_OTG_CoreReset.clone.1+0x18>
  }
  while (greset.b.csftrst == 1);
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
  return status;
}
 8001c86:	2000      	movs	r0, #0
 8001c88:	b003      	add	sp, #12
 8001c8a:	bd30      	pop	{r4, r5, pc}
    }
  }
  while (greset.b.ahbidle == 0);
  /* Core Soft Reset */
  count = 0;
  greset.b.csftrst = 1;
 8001c8c:	9901      	ldr	r1, [sp, #4]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001c8e:	4a0d      	ldr	r2, [pc, #52]	; (8001cc4 <USB_OTG_CoreReset.clone.1+0x80>)
    }
  }
  while (greset.b.ahbidle == 0);
  /* Core Soft Reset */
  count = 0;
  greset.b.csftrst = 1;
 8001c90:	f041 0001 	orr.w	r0, r1, #1
 8001c94:	9001      	str	r0, [sp, #4]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8001c96:	9901      	ldr	r1, [sp, #4]
 8001c98:	6119      	str	r1, [r3, #16]
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001c9a:	6918      	ldr	r0, [r3, #16]
 8001c9c:	9001      	str	r0, [sp, #4]
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.csftrst == 1);
 8001c9e:	9801      	ldr	r0, [sp, #4]
 8001ca0:	f010 0f01 	tst.w	r0, #1
 8001ca4:	d00a      	beq.n	8001cbc <USB_OTG_CoreReset.clone.1+0x78>
  count = 0;
  greset.b.csftrst = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001ca6:	6919      	ldr	r1, [r3, #16]
 8001ca8:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.csftrst == 1);
 8001caa:	9801      	ldr	r0, [sp, #4]
  count = 0;
  greset.b.csftrst = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001cac:	3a01      	subs	r2, #1
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.csftrst == 1);
 8001cae:	f010 0f01 	tst.w	r0, #1
 8001cb2:	d003      	beq.n	8001cbc <USB_OTG_CoreReset.clone.1+0x78>
  count = 0;
  greset.b.csftrst = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001cb4:	6919      	ldr	r1, [r3, #16]
    if (++count > 200000)
 8001cb6:	3a01      	subs	r2, #1
  count = 0;
  greset.b.csftrst = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001cb8:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
 8001cba:	d1f0      	bne.n	8001c9e <USB_OTG_CoreReset.clone.1+0x5a>
      break;
    }
  }
  while (greset.b.csftrst == 1);
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 8001cbc:	2003      	movs	r0, #3
 8001cbe:	f001 feea 	bl	8003a96 <USB_OTG_BSP_uDelay>
 8001cc2:	e7e0      	b.n	8001c86 <USB_OTG_CoreReset.clone.1+0x42>
 8001cc4:	00030d40 	.word	0x00030d40

08001cc8 <USB_OTG_WritePacket>:
*/
USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t             *src, 
                                uint8_t             ch_ep_num, 
                                uint16_t            len)
{
 8001cc8:	b430      	push	{r4, r5}
  USB_OTG_STS status = USB_OTG_OK;
  if (pdev->cfg.dma_enable == 0)
 8001cca:	78c4      	ldrb	r4, [r0, #3]
 8001ccc:	bb04      	cbnz	r4, 8001d10 <USB_OTG_WritePacket+0x48>
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
 8001cce:	eb00 0082 	add.w	r0, r0, r2, lsl #2
  if (pdev->cfg.dma_enable == 0)
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
 8001cd2:	3303      	adds	r3, #3
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001cd4:	109b      	asrs	r3, r3, #2
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
 8001cd6:	f8d0 40d0 	ldr.w	r4, [r0, #208]	; 0xd0
    for (i = 0; i < count32b; i++, src+=4)
 8001cda:	d019      	beq.n	8001d10 <USB_OTG_WritePacket+0x48>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001cdc:	f851 2b04 	ldr.w	r2, [r1], #4
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001ce0:	2001      	movs	r0, #1
 8001ce2:	1e5d      	subs	r5, r3, #1
 8001ce4:	4283      	cmp	r3, r0
 8001ce6:	f005 0501 	and.w	r5, r5, #1
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001cea:	6022      	str	r2, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001cec:	d010      	beq.n	8001d10 <USB_OTG_WritePacket+0x48>
 8001cee:	b12d      	cbz	r5, 8001cfc <USB_OTG_WritePacket+0x34>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001cf0:	f851 2b04 	ldr.w	r2, [r1], #4
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001cf4:	2002      	movs	r0, #2
 8001cf6:	4283      	cmp	r3, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001cf8:	6022      	str	r2, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001cfa:	d009      	beq.n	8001d10 <USB_OTG_WritePacket+0x48>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001cfc:	460a      	mov	r2, r1
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001cfe:	3002      	adds	r0, #2
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001d00:	f852 5b04 	ldr.w	r5, [r2], #4
 8001d04:	6025      	str	r5, [r4, #0]
 8001d06:	684d      	ldr	r5, [r1, #4]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001d08:	1d11      	adds	r1, r2, #4
 8001d0a:	4283      	cmp	r3, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001d0c:	6025      	str	r5, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001d0e:	d1f5      	bne.n	8001cfc <USB_OTG_WritePacket+0x34>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
    }
  }
  return status;
}
 8001d10:	2000      	movs	r0, #0
 8001d12:	bc30      	pop	{r4, r5}
 8001d14:	4770      	bx	lr
 8001d16:	bf00      	nop

08001d18 <USB_OTG_ReadPacket>:
void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
                         uint8_t *dest, 
                         uint16_t len)
{
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
 8001d18:	3203      	adds	r2, #3
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001d1a:	1092      	asrs	r2, r2, #2
* @retval None
*/
void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
                         uint8_t *dest, 
                         uint16_t len)
{
 8001d1c:	b470      	push	{r4, r5, r6}
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
 8001d1e:	f8d0 50d0 	ldr.w	r5, [r0, #208]	; 0xd0
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001d22:	d01c      	beq.n	8001d5e <USB_OTG_ReadPacket+0x46>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001d24:	682c      	ldr	r4, [r5, #0]
 8001d26:	460b      	mov	r3, r1
 8001d28:	1e50      	subs	r0, r2, #1
 8001d2a:	f843 4b04 	str.w	r4, [r3], #4
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001d2e:	2401      	movs	r4, #1
 8001d30:	42a2      	cmp	r2, r4
 8001d32:	f000 0001 	and.w	r0, r0, #1
 8001d36:	d010      	beq.n	8001d5a <USB_OTG_ReadPacket+0x42>
 8001d38:	b128      	cbz	r0, 8001d46 <USB_OTG_ReadPacket+0x2e>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001d3a:	6828      	ldr	r0, [r5, #0]
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001d3c:	2402      	movs	r4, #2
 8001d3e:	42a2      	cmp	r2, r4
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001d40:	f843 0b04 	str.w	r0, [r3], #4
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001d44:	d009      	beq.n	8001d5a <USB_OTG_ReadPacket+0x42>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001d46:	682e      	ldr	r6, [r5, #0]
 8001d48:	4618      	mov	r0, r3
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001d4a:	3402      	adds	r4, #2
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001d4c:	f840 6b04 	str.w	r6, [r0], #4
 8001d50:	682e      	ldr	r6, [r5, #0]
 8001d52:	605e      	str	r6, [r3, #4]
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001d54:	1d03      	adds	r3, r0, #4
 8001d56:	42a2      	cmp	r2, r4
 8001d58:	d1f5      	bne.n	8001d46 <USB_OTG_ReadPacket+0x2e>
 8001d5a:	eb01 0182 	add.w	r1, r1, r2, lsl #2
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
    
  }
  return ((void *)dest);
}
 8001d5e:	4608      	mov	r0, r1
 8001d60:	bc70      	pop	{r4, r5, r6}
 8001d62:	4770      	bx	lr

08001d64 <USB_OTG_SelectCore>:
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
                               USB_OTG_CORE_ID_TypeDef coreID)
{
 8001d64:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  uint32_t i , baseAddress = 0;
  USB_OTG_STS status = USB_OTG_OK;
  
  pdev->cfg.dma_enable       = 0;
 8001d68:	2300      	movs	r3, #0
  
  /* at startup the core is in FS mode */
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8001d6a:	2701      	movs	r7, #1
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
 8001d6c:	2240      	movs	r2, #64	; 0x40
    
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
 8001d6e:	2901      	cmp	r1, #1
                               USB_OTG_CORE_ID_TypeDef coreID)
{
  uint32_t i , baseAddress = 0;
  USB_OTG_STS status = USB_OTG_OK;
  
  pdev->cfg.dma_enable       = 0;
 8001d70:	70c3      	strb	r3, [r0, #3]
  
  /* at startup the core is in FS mode */
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8001d72:	7087      	strb	r7, [r0, #2]
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
 8001d74:	8082      	strh	r2, [r0, #4]
    
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
 8001d76:	f000 80a6 	beq.w	8001ec6 <USB_OTG_SelectCore+0x162>
    
#ifdef USB_OTG_FS_LOW_PWR_MGMT_SUPPORT    
    pdev->cfg.low_power        = 1;    
#endif     
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
 8001d7a:	2900      	cmp	r1, #0
 8001d7c:	f000 808c 	beq.w	8001e98 <USB_OTG_SelectCore+0x134>
 8001d80:	7847      	ldrb	r7, [r0, #1]
 8001d82:	f890 8000 	ldrb.w	r8, [r0]
    pdev->cfg.low_power        = 1;    
#endif 
    
  }
  
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
 8001d86:	60c3      	str	r3, [r0, #12]
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
 8001d88:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8001d8c:	6102      	str	r2, [r0, #16]
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001d8e:	2f00      	cmp	r7, #0
 8001d90:	f000 80b0 	beq.w	8001ef4 <USB_OTG_SelectCore+0x190>
 8001d94:	f44f 6a60 	mov.w	sl, #3584	; 0xe00
 8001d98:	f44f 6988 	mov.w	r9, #1088	; 0x440
 8001d9c:	f44f 6b80 	mov.w	fp, #1024	; 0x400
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
                               USB_OTG_CORE_ID_TypeDef coreID)
{
  uint32_t i , baseAddress = 0;
 8001da0:	469c      	mov	ip, r3
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001da2:	4602      	mov	r2, r0
 8001da4:	f50c 6410 	add.w	r4, ip, #2304	; 0x900
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8001da8:	f842 4f18 	str.w	r4, [r2, #24]!
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001dac:	2401      	movs	r4, #1
 8001dae:	1e7b      	subs	r3, r7, #1
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001db0:	f50c 6130 	add.w	r1, ip, #2816	; 0xb00
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001db4:	42bc      	cmp	r4, r7
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8001db6:	63d1      	str	r1, [r2, #60]	; 0x3c
 8001db8:	ea03 0104 	and.w	r1, r3, r4
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001dbc:	f50c 6312 	add.w	r3, ip, #2336	; 0x920
 8001dc0:	d21c      	bcs.n	8001dfc <USB_OTG_SelectCore+0x98>
 8001dc2:	b151      	cbz	r1, 8001dda <USB_OTG_SelectCore+0x76>
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001dc4:	4602      	mov	r2, r0
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001dc6:	2402      	movs	r4, #2
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8001dc8:	f842 3f1c 	str.w	r3, [r2, #28]!
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001dcc:	f50c 6132 	add.w	r1, ip, #2848	; 0xb20
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001dd0:	42bc      	cmp	r4, r7
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8001dd2:	63d1      	str	r1, [r2, #60]	; 0x3c
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001dd4:	f50c 6314 	add.w	r3, ip, #2368	; 0x940
 8001dd8:	d210      	bcs.n	8001dfc <USB_OTG_SelectCore+0x98>
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001dda:	1d11      	adds	r1, r2, #4
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8001ddc:	6053      	str	r3, [r2, #4]
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001dde:	3402      	adds	r4, #2
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001de0:	3208      	adds	r2, #8
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001de2:	f103 0520 	add.w	r5, r3, #32
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001de6:	f503 7600 	add.w	r6, r3, #512	; 0x200
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001dea:	42bc      	cmp	r4, r7
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001dec:	f503 7308 	add.w	r3, r3, #544	; 0x220
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8001df0:	63ce      	str	r6, [r1, #60]	; 0x3c
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8001df2:	604d      	str	r5, [r1, #4]
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8001df4:	63d3      	str	r3, [r2, #60]	; 0x3c
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001df6:	f105 0320 	add.w	r3, r5, #32
 8001dfa:	d3ee      	bcc.n	8001dda <USB_OTG_SelectCore+0x76>
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
 8001dfc:	f8c0 b014 	str.w	fp, [r0, #20]
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
 8001e00:	f8c0 90cc 	str.w	r9, [r0, #204]	; 0xcc
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001e04:	f1b8 0f00 	cmp.w	r8, #0
 8001e08:	d040      	beq.n	8001e8c <USB_OTG_SelectCore+0x128>
 8001e0a:	f50c 61a0 	add.w	r1, ip, #1280	; 0x500
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001e0e:	ea4f 1548 	mov.w	r5, r8, lsl #5
 8001e12:	f1a5 0420 	sub.w	r4, r5, #32
 8001e16:	4602      	mov	r2, r0
 8001e18:	186d      	adds	r5, r5, r1
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8001e1a:	f50c 63a4 	add.w	r3, ip, #1312	; 0x520
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001e1e:	42ab      	cmp	r3, r5
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8001e20:	f842 1f90 	str.w	r1, [r2, #144]!
 8001e24:	f3c4 1440 	ubfx	r4, r4, #5, #1
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001e28:	d00f      	beq.n	8001e4a <USB_OTG_SelectCore+0xe6>
 8001e2a:	b134      	cbz	r4, 8001e3a <USB_OTG_SelectCore+0xd6>
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001e2c:	4602      	mov	r2, r0
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8001e2e:	f842 3f94 	str.w	r3, [r2, #148]!
 8001e32:	f50c 63a8 	add.w	r3, ip, #1344	; 0x540
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001e36:	42ab      	cmp	r3, r5
 8001e38:	d007      	beq.n	8001e4a <USB_OTG_SelectCore+0xe6>
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8001e3a:	f103 0420 	add.w	r4, r3, #32
 8001e3e:	6053      	str	r3, [r2, #4]
 8001e40:	3340      	adds	r3, #64	; 0x40
 8001e42:	6094      	str	r4, [r2, #8]
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001e44:	3208      	adds	r2, #8
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001e46:	42ab      	cmp	r3, r5
 8001e48:	d1f7      	bne.n	8001e3a <USB_OTG_SelectCore+0xd6>
 8001e4a:	f50c 5180 	add.w	r1, ip, #4096	; 0x1000
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001e4e:	ea4f 3808 	mov.w	r8, r8, lsl #12
 8001e52:	f5a8 5480 	sub.w	r4, r8, #4096	; 0x1000
 8001e56:	4602      	mov	r2, r0
 8001e58:	4488      	add	r8, r1
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8001e5a:	f50c 5300 	add.w	r3, ip, #8192	; 0x2000
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001e5e:	4543      	cmp	r3, r8
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8001e60:	f842 1fd0 	str.w	r1, [r2, #208]!
 8001e64:	f3c4 3400 	ubfx	r4, r4, #12, #1
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001e68:	d010      	beq.n	8001e8c <USB_OTG_SelectCore+0x128>
 8001e6a:	b134      	cbz	r4, 8001e7a <USB_OTG_SelectCore+0x116>
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001e6c:	4602      	mov	r2, r0
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8001e6e:	f842 3fd4 	str.w	r3, [r2, #212]!
 8001e72:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001e76:	4543      	cmp	r3, r8
 8001e78:	d008      	beq.n	8001e8c <USB_OTG_SelectCore+0x128>
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8001e7a:	f503 5480 	add.w	r4, r3, #4096	; 0x1000
 8001e7e:	6053      	str	r3, [r2, #4]
 8001e80:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8001e84:	6094      	str	r4, [r2, #8]
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001e86:	3208      	adds	r2, #8
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001e88:	4543      	cmp	r3, r8
 8001e8a:	d1f6      	bne.n	8001e7a <USB_OTG_SelectCore+0x116>
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
      (i * USB_OTG_DATA_FIFO_SIZE));
  }
  pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
 8001e8c:	f8c0 a10c 	str.w	sl, [r0, #268]	; 0x10c
  
  return status;
}
 8001e90:	2000      	movs	r0, #0
 8001e92:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001e96:	4770      	bx	lr
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001e98:	f44f 69a0 	mov.w	r9, #1280	; 0x500
 8001e9c:	4b19      	ldr	r3, [pc, #100]	; (8001f04 <USB_OTG_SelectCore+0x1a0>)
 8001e9e:	f8a0 9006 	strh.w	r9, [r0, #6]
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
 8001ea2:	f04f 080c 	mov.w	r8, #12
    pdev->cfg.dev_endpoints    = 6 ;
 8001ea6:	2706      	movs	r7, #6
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001ea8:	f8df a064 	ldr.w	sl, [pc, #100]	; 8001f10 <USB_OTG_SelectCore+0x1ac>
 8001eac:	f8df 9064 	ldr.w	r9, [pc, #100]	; 8001f14 <USB_OTG_SelectCore+0x1b0>
 8001eb0:	f8df b064 	ldr.w	fp, [pc, #100]	; 8001f18 <USB_OTG_SelectCore+0x1b4>
 8001eb4:	4a14      	ldr	r2, [pc, #80]	; (8001f08 <USB_OTG_SelectCore+0x1a4>)
#endif     
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
 8001eb6:	72c1      	strb	r1, [r0, #11]
    pdev->cfg.host_channels    = 12 ;
 8001eb8:	f880 8000 	strb.w	r8, [r0]
    pdev->cfg.dev_endpoints    = 6 ;
 8001ebc:	7047      	strb	r7, [r0, #1]
    pdev->cfg.low_power        = 1;    
#endif     
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
 8001ebe:	469c      	mov	ip, r3
    pdev->cfg.low_power        = 1;    
#endif 
    
  }
  
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
 8001ec0:	60c3      	str	r3, [r0, #12]
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
 8001ec2:	6102      	str	r2, [r0, #16]
 8001ec4:	e76d      	b.n	8001da2 <USB_OTG_SelectCore+0x3e>
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
    pdev->cfg.host_channels    = 8 ;
 8001ec6:	f04f 0808 	mov.w	r8, #8
    pdev->cfg.dev_endpoints    = 4 ;
 8001eca:	2704      	movs	r7, #4
    pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
 8001ecc:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
 8001ed0:	72c1      	strb	r1, [r0, #11]
    pdev->cfg.host_channels    = 8 ;
    pdev->cfg.dev_endpoints    = 4 ;
    pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
 8001ed2:	f44f 74a0 	mov.w	r4, #320	; 0x140
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
 8001ed6:	2102      	movs	r1, #2
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
    pdev->cfg.host_channels    = 8 ;
 8001ed8:	f880 8000 	strb.w	r8, [r0]
    pdev->cfg.dev_endpoints    = 4 ;
 8001edc:	7047      	strb	r7, [r0, #1]
    pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
 8001ede:	80c4      	strh	r4, [r0, #6]
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
 8001ee0:	7201      	strb	r1, [r0, #8]
 8001ee2:	f8df a038 	ldr.w	sl, [pc, #56]	; 8001f1c <USB_OTG_SelectCore+0x1b8>
 8001ee6:	f8df 9038 	ldr.w	r9, [pc, #56]	; 8001f20 <USB_OTG_SelectCore+0x1bc>
 8001eea:	f8df b038 	ldr.w	fp, [pc, #56]	; 8001f24 <USB_OTG_SelectCore+0x1c0>
 8001eee:	4a07      	ldr	r2, [pc, #28]	; (8001f0c <USB_OTG_SelectCore+0x1a8>)
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
    
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
 8001ef0:	469c      	mov	ip, r3
 8001ef2:	e7e5      	b.n	8001ec0 <USB_OTG_SelectCore+0x15c>
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001ef4:	f44f 6a60 	mov.w	sl, #3584	; 0xe00
 8001ef8:	f44f 6988 	mov.w	r9, #1088	; 0x440
 8001efc:	f44f 6b80 	mov.w	fp, #1024	; 0x400
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
                               USB_OTG_CORE_ID_TypeDef coreID)
{
  uint32_t i , baseAddress = 0;
 8001f00:	46bc      	mov	ip, r7
 8001f02:	e77b      	b.n	8001dfc <USB_OTG_SelectCore+0x98>
 8001f04:	40040000 	.word	0x40040000
 8001f08:	40040800 	.word	0x40040800
 8001f0c:	50000800 	.word	0x50000800
 8001f10:	40040e00 	.word	0x40040e00
 8001f14:	40040440 	.word	0x40040440
 8001f18:	40040400 	.word	0x40040400
 8001f1c:	50000e00 	.word	0x50000e00
 8001f20:	50000440 	.word	0x50000440
 8001f24:	50000400 	.word	0x50000400

08001f28 <USB_OTG_CoreInit>:
*         device mode or host mode operation.
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
{
 8001f28:	b538      	push	{r3, r4, r5, lr}
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8001f2a:	7a03      	ldrb	r3, [r0, #8]
  USB_OTG_GI2CCTL_TypeDef  i2cctl;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  
  usbcfg.d32 = 0;
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
 8001f2c:	2500      	movs	r5, #0
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8001f2e:	2b01      	cmp	r3, #1
*         device mode or host mode operation.
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
{
 8001f30:	4604      	mov	r4, r0
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8001f32:	d037      	beq.n	8001fa4 <USB_OTG_CoreInit+0x7c>
    }    
  }
  else /* FS interface (embedded Phy or I2C Phy) */
  {
    
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
 8001f34:	f850 3f0c 	ldr.w	r3, [r0, #12]!
 8001f38:	68d9      	ldr	r1, [r3, #12]
    usbcfg.b.physel  = 1; /* FS Interface */
 8001f3a:	f041 0240 	orr.w	r2, r1, #64	; 0x40
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8001f3e:	60da      	str	r2, [r3, #12]
    /* Reset after a PHY select and set Host mode */
    USB_OTG_CoreReset(pdev);
 8001f40:	f7ff fe80 	bl	8001c44 <USB_OTG_CoreReset.clone.1>
    /* Enable the I2C interface and deactivate the power down*/
    gccfg.d32 = 0;
    gccfg.b.pwdn = 1;
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 8001f44:	f894 c008 	ldrb.w	ip, [r4, #8]
    gccfg.b.vbussensingB = 1 ;     
#ifndef VBUS_SENSING_ENABLED
    gccfg.b.disablevbussensing = 1; 
#endif    
    
    if(pdev->cfg.Sof_output)
 8001f48:	7a61      	ldrb	r1, [r4, #9]
    gccfg.d32 = 0;
    gccfg.b.pwdn = 1;
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
    {
      gccfg.b.i2cifen = 1;
 8001f4a:	f1bc 0f03 	cmp.w	ip, #3
 8001f4e:	bf14      	ite	ne
 8001f50:	f44f 3280 	movne.w	r2, #65536	; 0x10000
 8001f54:	f44f 3240 	moveq.w	r2, #196608	; 0x30000
    }   
    gccfg.b.vbussensingA = 1 ;
    gccfg.b.vbussensingB = 1 ;     
#ifndef VBUS_SENSING_ENABLED
    gccfg.b.disablevbussensing = 1; 
 8001f58:	f442 1330 	orr.w	r3, r2, #2883584	; 0x2c0000
#endif    
    
    if(pdev->cfg.Sof_output)
 8001f5c:	b109      	cbz	r1, 8001f62 <USB_OTG_CoreInit+0x3a>
    {
      gccfg.b.sofouten = 1;  
 8001f5e:	f442 1370 	orr.w	r3, r2, #3932160	; 0x3c0000
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 8001f62:	68e1      	ldr	r1, [r4, #12]
    USB_OTG_BSP_mDelay(20);
 8001f64:	2014      	movs	r0, #20
    if(pdev->cfg.Sof_output)
    {
      gccfg.b.sofouten = 1;  
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 8001f66:	638b      	str	r3, [r1, #56]	; 0x38
    USB_OTG_BSP_mDelay(20);
 8001f68:	f001 fd9f 	bl	8003aaa <USB_OTG_BSP_mDelay>
    /* Program GUSBCFG.OtgUtmifsSel to I2C*/
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8001f6c:	68e3      	ldr	r3, [r4, #12]
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 8001f6e:	f894 c008 	ldrb.w	ip, [r4, #8]
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
    USB_OTG_BSP_mDelay(20);
    /* Program GUSBCFG.OtgUtmifsSel to I2C*/
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8001f72:	68da      	ldr	r2, [r3, #12]
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 8001f74:	f1bc 0f03 	cmp.w	ip, #3
    {
      usbcfg.b.otgutmifssel = 1;
 8001f78:	bf08      	it	eq
 8001f7a:	f442 3280 	orreq.w	r2, r2, #65536	; 0x10000
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8001f7e:	60da      	str	r2, [r3, #12]
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 8001f80:	7a20      	ldrb	r0, [r4, #8]
 8001f82:	2803      	cmp	r0, #3
 8001f84:	d03b      	beq.n	8001ffe <USB_OTG_CoreInit+0xd6>
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
      USB_OTG_BSP_mDelay(200);
    }
  }
  /* case the HS core is working in FS mode */
  if(pdev->cfg.dma_enable == 1)
 8001f86:	f894 e003 	ldrb.w	lr, [r4, #3]
 8001f8a:	f1be 0f01 	cmp.w	lr, #1
 8001f8e:	d107      	bne.n	8001fa0 <USB_OTG_CoreInit+0x78>
  {
    
    ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
 8001f90:	68e3      	ldr	r3, [r4, #12]
 8001f92:	689a      	ldr	r2, [r3, #8]
    ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 8001f94:	2105      	movs	r1, #5
 8001f96:	f361 0244 	bfi	r2, r1, #1, #4
    ahbcfg.b.dmaenable = 1;
 8001f9a:	f042 0020 	orr.w	r0, r2, #32
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8001f9e:	6098      	str	r0, [r3, #8]
  usbcfg.b.srpcap = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
  USB_OTG_EnableCommonInt(pdev);
#endif
  return status;
}
 8001fa0:	2000      	movs	r0, #0
 8001fa2:	bd38      	pop	{r3, r4, r5, pc}
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
 8001fa4:	68c2      	ldr	r2, [r0, #12]
    gccfg.b.pwdn = 0;
    
    if (pdev->cfg.Sof_output)
 8001fa6:	7a41      	ldrb	r1, [r0, #9]
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
 8001fa8:	6b93      	ldr	r3, [r2, #56]	; 0x38
    gccfg.b.pwdn = 0;
 8001faa:	f365 4310 	bfi	r3, r5, #16, #1
    
    if (pdev->cfg.Sof_output)
 8001fae:	b109      	cbz	r1, 8001fb4 <USB_OTG_CoreInit+0x8c>
    {
      gccfg.b.sofouten = 1;   
 8001fb0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    }
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 8001fb4:	6393      	str	r3, [r2, #56]	; 0x38
    
    /* Init The ULPI Interface */
    usbcfg.d32 = 0;
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8001fb6:	68d1      	ldr	r1, [r2, #12]
    
    usbcfg.b.physel            = 0; /* HS Interface */
 8001fb8:	f36f 1186 	bfc	r1, #6, #1
#else
 #ifdef USB_OTG_EXTERNAL_VBUS_ENABLED    
    usbcfg.b.ulpi_ext_vbus_drv = 1; /* Use external VBUS */
 #endif
#endif 
    usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
 8001fbc:	f36f 5196 	bfc	r1, #22, #1
    usbcfg.b.ulpi_utmi_sel     = 1; /* ULPI seleInterfacect */
 8001fc0:	f041 0310 	orr.w	r3, r1, #16
    
    usbcfg.b.phyif             = 0; /* 8 bits */
 8001fc4:	f36f 03c3 	bfc	r3, #3, #1
    usbcfg.b.ddrsel            = 0; /* single data rate */
 8001fc8:	f36f 13c7 	bfc	r3, #7, #1
    
    usbcfg.b.ulpi_fsls = 0;
 8001fcc:	f36f 4351 	bfc	r3, #17, #1
    usbcfg.b.ulpi_clk_sus_m = 0;
 8001fd0:	f36f 43d3 	bfc	r3, #19, #1
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8001fd4:	60d3      	str	r3, [r2, #12]
    
    /* Reset after a PHY select  */
    USB_OTG_CoreReset(pdev);
 8001fd6:	f104 000c 	add.w	r0, r4, #12
 8001fda:	f7ff fe33 	bl	8001c44 <USB_OTG_CoreReset.clone.1>
    
    if(pdev->cfg.dma_enable == 1)
 8001fde:	78e0      	ldrb	r0, [r4, #3]
 8001fe0:	2801      	cmp	r0, #1
 8001fe2:	d1dd      	bne.n	8001fa0 <USB_OTG_CoreInit+0x78>
    {
      
      ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 8001fe4:	2005      	movs	r0, #5
 8001fe6:	f360 0544 	bfi	r5, r0, #1, #4
      ahbcfg.b.dmaenable = 1;
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8001fea:	68e2      	ldr	r2, [r4, #12]
    
    if(pdev->cfg.dma_enable == 1)
    {
      
      ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
      ahbcfg.b.dmaenable = 1;
 8001fec:	f045 0520 	orr.w	r5, r5, #32
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8001ff0:	6095      	str	r5, [r2, #8]
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
      USB_OTG_BSP_mDelay(200);
    }
  }
  /* case the HS core is working in FS mode */
  if(pdev->cfg.dma_enable == 1)
 8001ff2:	f894 e003 	ldrb.w	lr, [r4, #3]
 8001ff6:	f1be 0f01 	cmp.w	lr, #1
 8001ffa:	d0c9      	beq.n	8001f90 <USB_OTG_CoreInit+0x68>
 8001ffc:	e7d0      	b.n	8001fa0 <USB_OTG_CoreInit+0x78>
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
    {
      /*Program GI2CCTL.I2CEn*/
      i2cctl.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GI2CCTL);
 8001ffe:	6b19      	ldr	r1, [r3, #48]	; 0x30
      i2cctl.b.i2cdevaddr = 1;
 8002000:	2201      	movs	r2, #1
 8002002:	f362 619b 	bfi	r1, r2, #26, #2
      i2cctl.b.i2cen = 0;
 8002006:	f36f 51d7 	bfc	r1, #23, #1
      i2cctl.b.dat_se0 = 1;
 800200a:	f041 5580 	orr.w	r5, r1, #268435456	; 0x10000000
      i2cctl.b.addr = 0x2D;
 800200e:	202d      	movs	r0, #45	; 0x2d
 8002010:	f360 4516 	bfi	r5, r0, #16, #7
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
 8002014:	631d      	str	r5, [r3, #48]	; 0x30
      
      USB_OTG_BSP_mDelay(200);
 8002016:	20c8      	movs	r0, #200	; 0xc8
 8002018:	f001 fd47 	bl	8003aaa <USB_OTG_BSP_mDelay>
      
      i2cctl.b.i2cen = 1;
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
 800201c:	68e3      	ldr	r3, [r4, #12]
      i2cctl.b.addr = 0x2D;
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
      
      USB_OTG_BSP_mDelay(200);
      
      i2cctl.b.i2cen = 1;
 800201e:	f445 0500 	orr.w	r5, r5, #8388608	; 0x800000
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
 8002022:	631d      	str	r5, [r3, #48]	; 0x30
      USB_OTG_BSP_mDelay(200);
 8002024:	20c8      	movs	r0, #200	; 0xc8
 8002026:	f001 fd40 	bl	8003aaa <USB_OTG_BSP_mDelay>
 800202a:	e7ac      	b.n	8001f86 <USB_OTG_CoreInit+0x5e>

0800202c <USB_OTG_EnableGlobalInt>:
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  
  ahbcfg.d32 = 0;
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
 800202c:	68c3      	ldr	r3, [r0, #12]
 800202e:	6898      	ldr	r0, [r3, #8]
 8002030:	f040 0201 	orr.w	r2, r0, #1
 8002034:	609a      	str	r2, [r3, #8]
  return status;
}
 8002036:	2000      	movs	r0, #0
 8002038:	4770      	bx	lr
 800203a:	bf00      	nop

0800203c <USB_OTG_DisableGlobalInt>:
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  ahbcfg.d32 = 0;
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
 800203c:	68c3      	ldr	r3, [r0, #12]
 800203e:	6898      	ldr	r0, [r3, #8]
 8002040:	f020 0201 	bic.w	r2, r0, #1
 8002044:	609a      	str	r2, [r3, #8]
  return status;
}
 8002046:	2000      	movs	r0, #0
 8002048:	4770      	bx	lr
 800204a:	bf00      	nop

0800204c <USB_OTG_FlushTxFifo>:
* @param  pdev : Selected device
* @param  num : FO num
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
{
 800204c:	b500      	push	{lr}
 800204e:	b083      	sub	sp, #12
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  
  uint32_t count = 0;
  greset.d32 = 0;
 8002050:	2300      	movs	r3, #0
 8002052:	9301      	str	r3, [sp, #4]
  greset.b.txfflsh = 1;
 8002054:	9a01      	ldr	r2, [sp, #4]
  greset.b.txfnum  = num;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8002056:	4b11      	ldr	r3, [pc, #68]	; (800209c <USB_OTG_FlushTxFifo+0x50>)
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  
  uint32_t count = 0;
  greset.d32 = 0;
  greset.b.txfflsh = 1;
 8002058:	f042 0220 	orr.w	r2, r2, #32
 800205c:	9201      	str	r2, [sp, #4]
  greset.b.txfnum  = num;
 800205e:	9a01      	ldr	r2, [sp, #4]
 8002060:	f361 128a 	bfi	r2, r1, #6, #5
 8002064:	9201      	str	r2, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8002066:	9a01      	ldr	r2, [sp, #4]
 8002068:	68c1      	ldr	r1, [r0, #12]
 800206a:	610a      	str	r2, [r1, #16]
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 800206c:	690a      	ldr	r2, [r1, #16]
 800206e:	9201      	str	r2, [sp, #4]
 8002070:	e00a      	b.n	8002088 <USB_OTG_FlushTxFifo+0x3c>
 8002072:	690a      	ldr	r2, [r1, #16]
 8002074:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.txfflsh == 1);
 8002076:	9801      	ldr	r0, [sp, #4]
  greset.b.txfflsh = 1;
  greset.b.txfnum  = num;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8002078:	3b01      	subs	r3, #1
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.txfflsh == 1);
 800207a:	f010 0f20 	tst.w	r0, #32
 800207e:	d007      	beq.n	8002090 <USB_OTG_FlushTxFifo+0x44>
  greset.b.txfflsh = 1;
  greset.b.txfnum  = num;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8002080:	690a      	ldr	r2, [r1, #16]
    if (++count > 200000)
 8002082:	3b01      	subs	r3, #1
  greset.b.txfflsh = 1;
  greset.b.txfnum  = num;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8002084:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 8002086:	d003      	beq.n	8002090 <USB_OTG_FlushTxFifo+0x44>
    {
      break;
    }
  }
  while (greset.b.txfflsh == 1);
 8002088:	9801      	ldr	r0, [sp, #4]
 800208a:	f010 0f20 	tst.w	r0, #32
 800208e:	d1f0      	bne.n	8002072 <USB_OTG_FlushTxFifo+0x26>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 8002090:	2003      	movs	r0, #3
 8002092:	f001 fd00 	bl	8003a96 <USB_OTG_BSP_uDelay>
  return status;
}
 8002096:	2000      	movs	r0, #0
 8002098:	b003      	add	sp, #12
 800209a:	bd00      	pop	{pc}
 800209c:	00030d40 	.word	0x00030d40

080020a0 <USB_OTG_FlushRxFifo>:
* @brief  USB_OTG_FlushRxFifo : Flush a Rx FIFO
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
{
 80020a0:	b500      	push	{lr}
 80020a2:	b083      	sub	sp, #12
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 80020a4:	2300      	movs	r3, #0
 80020a6:	9301      	str	r3, [sp, #4]
  greset.b.rxfflsh = 1;
 80020a8:	9a01      	ldr	r2, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80020aa:	4b0f      	ldr	r3, [pc, #60]	; (80020e8 <USB_OTG_FlushRxFifo+0x48>)
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
  greset.b.rxfflsh = 1;
 80020ac:	f042 0110 	orr.w	r1, r2, #16
 80020b0:	9101      	str	r1, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 80020b2:	9a01      	ldr	r2, [sp, #4]
 80020b4:	68c1      	ldr	r1, [r0, #12]
 80020b6:	610a      	str	r2, [r1, #16]
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80020b8:	690a      	ldr	r2, [r1, #16]
 80020ba:	9201      	str	r2, [sp, #4]
 80020bc:	e00a      	b.n	80020d4 <USB_OTG_FlushRxFifo+0x34>
 80020be:	690a      	ldr	r2, [r1, #16]
 80020c0:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.rxfflsh == 1);
 80020c2:	9801      	ldr	r0, [sp, #4]
  greset.d32 = 0;
  greset.b.rxfflsh = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80020c4:	3b01      	subs	r3, #1
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.rxfflsh == 1);
 80020c6:	f010 0f10 	tst.w	r0, #16
 80020ca:	d007      	beq.n	80020dc <USB_OTG_FlushRxFifo+0x3c>
  greset.d32 = 0;
  greset.b.rxfflsh = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80020cc:	690a      	ldr	r2, [r1, #16]
    if (++count > 200000)
 80020ce:	3b01      	subs	r3, #1
  greset.d32 = 0;
  greset.b.rxfflsh = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80020d0:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 80020d2:	d003      	beq.n	80020dc <USB_OTG_FlushRxFifo+0x3c>
    {
      break;
    }
  }
  while (greset.b.rxfflsh == 1);
 80020d4:	9801      	ldr	r0, [sp, #4]
 80020d6:	f010 0f10 	tst.w	r0, #16
 80020da:	d1f0      	bne.n	80020be <USB_OTG_FlushRxFifo+0x1e>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 80020dc:	2003      	movs	r0, #3
 80020de:	f001 fcda 	bl	8003a96 <USB_OTG_BSP_uDelay>
  return status;
}
 80020e2:	2000      	movs	r0, #0
 80020e4:	b003      	add	sp, #12
 80020e6:	bd00      	pop	{pc}
 80020e8:	00030d40 	.word	0x00030d40

080020ec <USB_OTG_SetCurrentMode>:
USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 80020ec:	68c2      	ldr	r2, [r0, #12]
* @param  pdev : Selected device
* @param  mode :  (Host/device)
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
{
 80020ee:	b508      	push	{r3, lr}
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 80020f0:	68d3      	ldr	r3, [r2, #12]
  
  usbcfg.b.force_host = 0;
  usbcfg.b.force_dev = 0;
  
  if ( mode == HOST_MODE)
 80020f2:	2901      	cmp	r1, #1
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
  
  usbcfg.b.force_host = 0;
 80020f4:	f36f 735d 	bfc	r3, #29, #1
  usbcfg.b.force_dev = 0;
 80020f8:	f36f 739e 	bfc	r3, #30, #1
  
  if ( mode == HOST_MODE)
 80020fc:	d008      	beq.n	8002110 <USB_OTG_SetCurrentMode+0x24>
  {
    usbcfg.b.force_host = 1;
  }
  else if ( mode == DEVICE_MODE)
 80020fe:	b909      	cbnz	r1, 8002104 <USB_OTG_SetCurrentMode+0x18>
  {
    usbcfg.b.force_dev = 1;
 8002100:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
  USB_OTG_BSP_mDelay(50);
 8002104:	2032      	movs	r0, #50	; 0x32
  else if ( mode == DEVICE_MODE)
  {
    usbcfg.b.force_dev = 1;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8002106:	60d3      	str	r3, [r2, #12]
  USB_OTG_BSP_mDelay(50);
 8002108:	f001 fccf 	bl	8003aaa <USB_OTG_BSP_mDelay>
  return status;
}
 800210c:	2000      	movs	r0, #0
 800210e:	bd08      	pop	{r3, pc}
  usbcfg.b.force_host = 0;
  usbcfg.b.force_dev = 0;
  
  if ( mode == HOST_MODE)
  {
    usbcfg.b.force_host = 1;
 8002110:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  {
    usbcfg.b.force_dev = 1;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
  USB_OTG_BSP_mDelay(50);
 8002114:	2032      	movs	r0, #50	; 0x32
  else if ( mode == DEVICE_MODE)
  {
    usbcfg.b.force_dev = 1;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8002116:	60d3      	str	r3, [r2, #12]
  USB_OTG_BSP_mDelay(50);
 8002118:	f001 fcc7 	bl	8003aaa <USB_OTG_BSP_mDelay>
  return status;
}
 800211c:	2000      	movs	r0, #0
 800211e:	bd08      	pop	{r3, pc}

08002120 <USB_OTG_GetMode>:
* @param  pdev : Selected device
* @retval current mode
*/
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 8002120:	68c3      	ldr	r3, [r0, #12]
 8002122:	6958      	ldr	r0, [r3, #20]
}
 8002124:	f000 0001 	and.w	r0, r0, #1
 8002128:	4770      	bx	lr
 800212a:	bf00      	nop

0800212c <USB_OTG_IsDeviceMode>:
* @param  pdev : Selected device
* @retval current mode
*/
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 800212c:	68c0      	ldr	r0, [r0, #12]
 800212e:	6943      	ldr	r3, [r0, #20]
* @param  pdev : Selected device
* @retval num_in_ep
*/
uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_GetMode(pdev) != HOST_MODE);
 8002130:	f013 0f01 	tst.w	r3, #1
}
 8002134:	bf14      	ite	ne
 8002136:	2000      	movne	r0, #0
 8002138:	2001      	moveq	r0, #1
 800213a:	4770      	bx	lr

0800213c <USB_OTG_IsHostMode>:
* @param  pdev : Selected device
* @retval current mode
*/
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 800213c:	68c3      	ldr	r3, [r0, #12]
 800213e:	6958      	ldr	r0, [r3, #20]
* @retval num_in_ep
*/
uint8_t USB_OTG_IsHostMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_GetMode(pdev) == HOST_MODE);
}
 8002140:	f000 0001 	and.w	r0, r0, #1
 8002144:	4770      	bx	lr
 8002146:	bf00      	nop

08002148 <USB_OTG_ReadCoreItr>:
* @retval Status
*/
uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v = 0;
  v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
 8002148:	68c3      	ldr	r3, [r0, #12]
 800214a:	695a      	ldr	r2, [r3, #20]
  v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
 800214c:	6998      	ldr	r0, [r3, #24]
  return v;
}
 800214e:	4010      	ands	r0, r2
 8002150:	4770      	bx	lr
 8002152:	bf00      	nop

08002154 <USB_OTG_ReadOtgItr>:
* @param  pdev : Selected device
* @retval Status
*/
uint32_t USB_OTG_ReadOtgItr (USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32 (&pdev->regs.GREGS->GOTGINT));
 8002154:	68c3      	ldr	r3, [r0, #12]
 8002156:	6858      	ldr	r0, [r3, #4]
}
 8002158:	4770      	bx	lr
 800215a:	bf00      	nop

0800215c <USB_OTG_InitDevSpeed>:
*/
void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
{
  USB_OTG_DCFG_TypeDef   dcfg;
  
  dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
 800215c:	6903      	ldr	r3, [r0, #16]
 800215e:	681a      	ldr	r2, [r3, #0]
  dcfg.b.devspd = speed;
 8002160:	f361 0201 	bfi	r2, r1, #0, #2
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCFG, dcfg.d32);
 8002164:	601a      	str	r2, [r3, #0]
}
 8002166:	4770      	bx	lr

08002168 <USB_OTG_EnableDevInt>:
  USB_OTG_GINTMSK_TypeDef  intmsk;
  
  intmsk.d32 = 0;
  
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
 8002168:	68c3      	ldr	r3, [r0, #12]
USB_OTG_STS USB_OTG_EnableDevInt(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GINTMSK_TypeDef  intmsk;
  
  intmsk.d32 = 0;
 800216a:	2200      	movs	r2, #0
  
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 800216c:	f04f 31ff 	mov.w	r1, #4294967295
  USB_OTG_GINTMSK_TypeDef  intmsk;
  
  intmsk.d32 = 0;
  
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
 8002170:	619a      	str	r2, [r3, #24]
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 8002172:	6159      	str	r1, [r3, #20]
  USB_OTG_GINTMSK_TypeDef  int_mask;
  
  int_mask.d32 = 0;
  /* Clear any pending USB_OTG Interrupts */
#ifndef USE_OTG_MODE
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GOTGINT, 0xFFFFFFFF);
 8002174:	6059      	str	r1, [r3, #4]
#endif
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 8002176:	6159      	str	r1, [r3, #20]
#ifdef USE_OTG_MODE
  int_mask.b.otgintr = 1;
  int_mask.b.sessreqintr = 1;
  int_mask.b.conidstschng = 1;
#endif
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
 8002178:	490a      	ldr	r1, [pc, #40]	; (80021a4 <USB_OTG_EnableDevInt+0x3c>)
 800217a:	6199      	str	r1, [r3, #24]
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
  /* Enable the common interrupts */
  USB_OTG_EnableCommonInt(pdev);
  
  if (pdev->cfg.dma_enable == 0)
 800217c:	f890 c003 	ldrb.w	ip, [r0, #3]
  intmsk.b.incomplisoout    = 1;   
#ifdef VBUS_SENSING_ENABLED
  intmsk.b.sessreqintr    = 1; 
  intmsk.b.otgintr    = 1;    
#endif  
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 8002180:	6998      	ldr	r0, [r3, #24]
  /* Enable the common interrupts */
  USB_OTG_EnableCommonInt(pdev);
  
  if (pdev->cfg.dma_enable == 0)
  {
    intmsk.b.rxstsqlvl = 1;
 8002182:	4594      	cmp	ip, r2
 8002184:	bf14      	ite	ne
 8002186:	4611      	movne	r1, r2
 8002188:	2110      	moveq	r1, #16
  
  /* Enable interrupts matching to the Device mode ONLY */
  intmsk.b.usbsuspend = 1;
  intmsk.b.usbreset   = 1;
  intmsk.b.enumdone   = 1;
  intmsk.b.inepintr   = 1;
 800218a:	f441 2c87 	orr.w	ip, r1, #276480	; 0x43800
  intmsk.b.outepintr  = 1;
  intmsk.b.sofintr    = 1; 
 800218e:	f04c 1108 	orr.w	r1, ip, #524296	; 0x80008

  intmsk.b.incomplisoin    = 1; 
  intmsk.b.incomplisoout    = 1;   
 8002192:	f441 1c40 	orr.w	ip, r1, #3145728	; 0x300000
#ifdef VBUS_SENSING_ENABLED
  intmsk.b.sessreqintr    = 1; 
  intmsk.b.otgintr    = 1;    
#endif  
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 8002196:	ea20 000c 	bic.w	r0, r0, ip
 800219a:	ea40 010c 	orr.w	r1, r0, ip
 800219e:	6199      	str	r1, [r3, #24]
  return status;
}
 80021a0:	4610      	mov	r0, r2
 80021a2:	4770      	bx	lr
 80021a4:	80000800 	.word	0x80000800

080021a8 <USB_OTG_CoreInitDev>:
*         for device mode
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
{
 80021a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  nptxfifosize.d32 = 0;
  txfifosize.d32 = 0;
  msk.d32 = 0;
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
 80021aa:	f8d0 510c 	ldr.w	r5, [r0, #268]	; 0x10c
  /* Device configuration register */
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
 80021ae:	6902      	ldr	r2, [r0, #16]
  USB_OTG_DIEPMSK_TypeDef msk;
  USB_OTG_DTHRCTL_TypeDef dthrctl;  
  
  depctl.d32 = 0;
  dcfg.d32 = 0;
  nptxfifosize.d32 = 0;
 80021b0:	2100      	movs	r1, #0
  txfifosize.d32 = 0;
  msk.d32 = 0;
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
 80021b2:	6029      	str	r1, [r5, #0]
*         for device mode
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
{
 80021b4:	4604      	mov	r4, r0
  msk.d32 = 0;
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
  /* Device configuration register */
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
 80021b6:	6810      	ldr	r0, [r2, #0]
  dcfg.b.perfrint = DCFG_FRAME_INTERVAL_80;
 80021b8:	f361 20cc 	bfi	r0, r1, #11, #2
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32 );
 80021bc:	6010      	str	r0, [r2, #0]
  USB_OTG_DTHRCTL_TypeDef dthrctl;  
  
  depctl.d32 = 0;
  dcfg.d32 = 0;
  nptxfifosize.d32 = 0;
  txfifosize.d32 = 0;
 80021be:	460b      	mov	r3, r1
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
  dcfg.b.perfrint = DCFG_FRAME_INTERVAL_80;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32 );
  
#ifdef USB_OTG_FS_CORE
  if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID  )
 80021c0:	7ae1      	ldrb	r1, [r4, #11]
 80021c2:	2901      	cmp	r1, #1
 80021c4:	d058      	beq.n	8002278 <USB_OTG_CoreInitDev+0xd0>
    txfifosize.b.depth = TX5_FIFO_HS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[4], txfifosize.d32 );
  }
#endif  
  /* Flush the FIFOs */
  USB_OTG_FlushTxFifo(pdev , 0x10); /* all Tx FIFOs */
 80021c6:	2110      	movs	r1, #16
 80021c8:	4620      	mov	r0, r4
 80021ca:	f7ff ff3f 	bl	800204c <USB_OTG_FlushTxFifo>
  USB_OTG_FlushRxFifo(pdev);
 80021ce:	4620      	mov	r0, r4
 80021d0:	f7ff ff66 	bl	80020a0 <USB_OTG_FlushRxFifo>
  /* Clear all pending Device Interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 80021d4:	6925      	ldr	r5, [r4, #16]
 80021d6:	2200      	movs	r2, #0
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 80021d8:	f04f 30ff 	mov.w	r0, #4294967295
#endif  
  /* Flush the FIFOs */
  USB_OTG_FlushTxFifo(pdev , 0x10); /* all Tx FIFOs */
  USB_OTG_FlushRxFifo(pdev);
  /* Clear all pending Device Interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 80021dc:	612a      	str	r2, [r5, #16]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
 80021de:	616a      	str	r2, [r5, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 80021e0:	61a8      	str	r0, [r5, #24]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
 80021e2:	61ea      	str	r2, [r5, #28]
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 80021e4:	7863      	ldrb	r3, [r4, #1]
 80021e6:	2b00      	cmp	r3, #0
 80021e8:	d031      	beq.n	800224e <USB_OTG_CoreInitDev+0xa6>
* @brief  USB_OTG_CoreInitDev : Initializes the USB_OTG controller registers 
*         for device mode
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
 80021ea:	f104 0014 	add.w	r0, r4, #20
    else
    {
      depctl.d32 = 0;
    }
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
 80021ee:	4617      	mov	r7, r2
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 80021f0:	26ff      	movs	r6, #255	; 0xff
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[i]->DIEPCTL);
 80021f2:	f850 3f04 	ldr.w	r3, [r0, #4]!
 80021f6:	6819      	ldr	r1, [r3, #0]
    if (depctl.b.epena)
 80021f8:	f3c1 6e07 	ubfx	lr, r1, #24, #8
 80021fc:	f00e 0c80 	and.w	ip, lr, #128	; 0x80
 8002200:	fa5f f18c 	uxtb.w	r1, ip
    {
      depctl.d32 = 0;
      depctl.b.epdis = 1;
      depctl.b.snak = 1;
 8002204:	2900      	cmp	r1, #0
 8002206:	bf18      	it	ne
 8002208:	f04f 4190 	movne.w	r1, #1207959552	; 0x48000000
    }
    else
    {
      depctl.d32 = 0;
    }
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
 800220c:	6019      	str	r1, [r3, #0]
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
 800220e:	611f      	str	r7, [r3, #16]
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 8002210:	609e      	str	r6, [r3, #8]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8002212:	7863      	ldrb	r3, [r4, #1]
 8002214:	3201      	adds	r2, #1
 8002216:	4293      	cmp	r3, r2
 8002218:	d8eb      	bhi.n	80021f2 <USB_OTG_CoreInitDev+0x4a>
    }
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
  }
  for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
 800221a:	b1c3      	cbz	r3, 800224e <USB_OTG_CoreInitDev+0xa6>
* @brief  USB_OTG_CoreInitDev : Initializes the USB_OTG controller registers 
*         for device mode
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
 800221c:	2200      	movs	r2, #0
 800221e:	f104 0050 	add.w	r0, r4, #80	; 0x50
    else
    {
      depctl.d32 = 0;
    }
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPCTL, depctl.d32);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
 8002222:	4617      	mov	r7, r2
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 8002224:	26ff      	movs	r6, #255	; 0xff
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
  }
  for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
  {
    USB_OTG_DEPCTL_TypeDef  depctl;
    depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[i]->DOEPCTL);
 8002226:	f850 3f04 	ldr.w	r3, [r0, #4]!
 800222a:	6819      	ldr	r1, [r3, #0]
    if (depctl.b.epena)
 800222c:	f3c1 6e07 	ubfx	lr, r1, #24, #8
 8002230:	f00e 0c80 	and.w	ip, lr, #128	; 0x80
 8002234:	fa5f f18c 	uxtb.w	r1, ip
    {
      depctl.d32 = 0;
      depctl.b.epdis = 1;
      depctl.b.snak = 1;
 8002238:	2900      	cmp	r1, #0
 800223a:	bf18      	it	ne
 800223c:	f04f 4190 	movne.w	r1, #1207959552	; 0x48000000
    }
    else
    {
      depctl.d32 = 0;
    }
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPCTL, depctl.d32);
 8002240:	6019      	str	r1, [r3, #0]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
 8002242:	611f      	str	r7, [r3, #16]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 8002244:	609e      	str	r6, [r3, #8]
    }
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
  }
  for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
 8002246:	7863      	ldrb	r3, [r4, #1]
 8002248:	3201      	adds	r2, #1
 800224a:	4293      	cmp	r3, r2
 800224c:	d8eb      	bhi.n	8002226 <USB_OTG_CoreInitDev+0x7e>
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  msk.d32 = 0;
  msk.b.txfifoundrn = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPMSK, msk.d32, msk.d32);
 800224e:	692b      	ldr	r3, [r5, #16]
 8002250:	f443 7080 	orr.w	r0, r3, #256	; 0x100
 8002254:	6128      	str	r0, [r5, #16]
  
  if (pdev->cfg.dma_enable == 1)
 8002256:	78e2      	ldrb	r2, [r4, #3]
 8002258:	2a01      	cmp	r2, #1
 800225a:	d108      	bne.n	800226e <USB_OTG_CoreInitDev+0xc6>
  {
    dthrctl.d32 = 0;
    dthrctl.b.non_iso_thr_en = 1;
    dthrctl.b.iso_thr_en = 1;
    dthrctl.b.tx_thr_len = 64;
 800225c:	2240      	movs	r2, #64	; 0x40
  
  if (pdev->cfg.dma_enable == 1)
  {
    dthrctl.d32 = 0;
    dthrctl.b.non_iso_thr_en = 1;
    dthrctl.b.iso_thr_en = 1;
 800225e:	2003      	movs	r0, #3
    dthrctl.b.tx_thr_len = 64;
 8002260:	f362 008a 	bfi	r0, r2, #2, #9
    dthrctl.b.rx_thr_en = 1;
 8002264:	f440 3180 	orr.w	r1, r0, #65536	; 0x10000
    dthrctl.b.rx_thr_len = 64;
 8002268:	f362 4159 	bfi	r1, r2, #17, #9
    USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DTHRCTL, dthrctl.d32);  
 800226c:	6329      	str	r1, [r5, #48]	; 0x30
  }
  USB_OTG_EnableDevInt(pdev);
 800226e:	4620      	mov	r0, r4
 8002270:	f7ff ff7a 	bl	8002168 <USB_OTG_EnableDevInt>
  return status;
}
 8002274:	2000      	movs	r0, #0
 8002276:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
*/
void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
{
  USB_OTG_DCFG_TypeDef   dcfg;
  
  dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
 8002278:	6816      	ldr	r6, [r2, #0]
    
    /* Set Full speed phy */
    USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
    
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 800227a:	68e0      	ldr	r0, [r4, #12]
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
    
    
    /* EP1 TX*/
    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
 800227c:	27c0      	movs	r7, #192	; 0xc0
    
    /* Set Full speed phy */
    USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
    
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 800227e:	2580      	movs	r5, #128	; 0x80
    
    /* EP0 TX*/
    nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
 8002280:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
    
    
    /* EP1 TX*/
    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
 8002284:	f367 030f 	bfi	r3, r7, #0, #16
void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
{
  USB_OTG_DCFG_TypeDef   dcfg;
  
  dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
  dcfg.b.devspd = speed;
 8002288:	f046 0603 	orr.w	r6, r6, #3
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCFG, dcfg.d32);
 800228c:	6016      	str	r6, [r2, #0]
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
    
    
    /* EP1 TX*/
    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
    txfifosize.b.depth = TX1_FIFO_FS_SIZE;
 800228e:	f365 431f 	bfi	r3, r5, #16, #16
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
    
    /* EP0 TX*/
    nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
 8002292:	f365 010f 	bfi	r1, r5, #0, #16
    txfifosize.b.depth = TX1_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
    
    
    /* EP2 TX*/
    txfifosize.b.startaddr += txfifosize.b.depth;
 8002296:	f44f 72a0 	mov.w	r2, #320	; 0x140
    
    /* Set Full speed phy */
    USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
    
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 800229a:	6245      	str	r5, [r0, #36]	; 0x24
    
    /* EP0 TX*/
    nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
 800229c:	6281      	str	r1, [r0, #40]	; 0x28
    
    
    /* EP1 TX*/
    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
    txfifosize.b.depth = TX1_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
 800229e:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
    
    
    /* EP2 TX*/
    txfifosize.b.startaddr += txfifosize.b.depth;
 80022a2:	f362 030f 	bfi	r3, r2, #0, #16
    txfifosize.b.depth = TX2_FIFO_FS_SIZE;
 80022a6:	f36f 431f 	bfc	r3, #16, #16
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[1], txfifosize.d32 );
 80022aa:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
    
    
    /* EP3 TX*/  
    txfifosize.b.startaddr += txfifosize.b.depth;
    txfifosize.b.depth = TX3_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[2], txfifosize.d32 );
 80022ae:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
 80022b2:	e788      	b.n	80021c6 <USB_OTG_CoreInitDev+0x1e>

080022b4 <USB_OTG_GetDeviceSpeed>:
{
  USB_OTG_DSTS_TypeDef  dsts;
  enum USB_OTG_SPEED speed = USB_SPEED_UNKNOWN;
  
  
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 80022b4:	6900      	ldr	r0, [r0, #16]
 80022b6:	6883      	ldr	r3, [r0, #8]
  
  switch (dsts.b.enumspd)
 80022b8:	f3c3 0341 	ubfx	r3, r3, #1, #2
 80022bc:	1e5a      	subs	r2, r3, #1
 80022be:	2a02      	cmp	r2, #2
 80022c0:	d804      	bhi.n	80022cc <USB_OTG_GetDeviceSpeed+0x18>
 80022c2:	4a03      	ldr	r2, [pc, #12]	; (80022d0 <USB_OTG_GetDeviceSpeed+0x1c>)
 80022c4:	18d1      	adds	r1, r2, r3
 80022c6:	f811 0c01 	ldrb.w	r0, [r1, #-1]
 80022ca:	4770      	bx	lr
 80022cc:	2003      	movs	r0, #3
    speed = USB_SPEED_LOW;
    break;
  }
  
  return speed;
}
 80022ce:	4770      	bx	lr
 80022d0:	0800cdc0 	.word	0x0800cdc0

080022d4 <USB_OTG_EP0Activate>:
  USB_OTG_DEPCTL_TypeDef  diepctl;
  USB_OTG_DCTL_TypeDef    dctl;
  
  dctl.d32 = 0;
  /* Read the Device Status and Endpoint 0 Control registers */
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 80022d4:	6903      	ldr	r3, [r0, #16]
  diepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL);
 80022d6:	6982      	ldr	r2, [r0, #24]
  USB_OTG_DEPCTL_TypeDef  diepctl;
  USB_OTG_DCTL_TypeDef    dctl;
  
  dctl.d32 = 0;
  /* Read the Device Status and Endpoint 0 Control registers */
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 80022d8:	6898      	ldr	r0, [r3, #8]
  diepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL);
 80022da:	6811      	ldr	r1, [r2, #0]
  /* Set the MPS of the IN EP based on the enumeration speed */
  switch (dsts.b.enumspd)
 80022dc:	f3c0 0041 	ubfx	r0, r0, #1, #2
 80022e0:	2802      	cmp	r0, #2
 80022e2:	d008      	beq.n	80022f6 <USB_OTG_EP0Activate+0x22>
  {
  case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
  case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
  case DSTS_ENUMSPD_FS_PHY_48MHZ:
    diepctl.b.mps = DEP0CTL_MPS_64;
 80022e4:	f36f 010a 	bfc	r1, #0, #11
    break;
  case DSTS_ENUMSPD_LS_PHY_6MHZ:
    diepctl.b.mps = DEP0CTL_MPS_8;
    break;
  }
  USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL, diepctl.d32);
 80022e8:	6011      	str	r1, [r2, #0]
  dctl.b.cgnpinnak = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, dctl.d32);
 80022ea:	6859      	ldr	r1, [r3, #4]
 80022ec:	f441 7280 	orr.w	r2, r1, #256	; 0x100
 80022f0:	605a      	str	r2, [r3, #4]
  return status;
}
 80022f2:	2000      	movs	r0, #0
 80022f4:	4770      	bx	lr
  case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
  case DSTS_ENUMSPD_FS_PHY_48MHZ:
    diepctl.b.mps = DEP0CTL_MPS_64;
    break;
  case DSTS_ENUMSPD_LS_PHY_6MHZ:
    diepctl.b.mps = DEP0CTL_MPS_8;
 80022f6:	2003      	movs	r0, #3
 80022f8:	f360 010a 	bfi	r1, r0, #0, #11
    break;
  }
  USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL, diepctl.d32);
 80022fc:	6011      	str	r1, [r2, #0]
  dctl.b.cgnpinnak = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, dctl.d32);
 80022fe:	6859      	ldr	r1, [r3, #4]
 8002300:	f441 7280 	orr.w	r2, r1, #256	; 0x100
 8002304:	605a      	str	r2, [r3, #4]
  return status;
}
 8002306:	2000      	movs	r0, #0
 8002308:	4770      	bx	lr
 800230a:	bf00      	nop

0800230c <USB_OTG_EPActivate>:
* @brief  USB_OTG_EPActivate : Activates an EP
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPActivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 800230c:	b470      	push	{r4, r5, r6}
  
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 800230e:	784b      	ldrb	r3, [r1, #1]
  USB_OTG_DAINT_TypeDef  daintmsk;
  __IO uint32_t *addr;
  
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;
 8002310:	2200      	movs	r2, #0
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 8002312:	2b01      	cmp	r3, #1
 8002314:	d027      	beq.n	8002366 <USB_OTG_EPActivate+0x5a>
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 8002316:	780c      	ldrb	r4, [r1, #0]
 8002318:	eb00 0c84 	add.w	ip, r0, r4, lsl #2
    daintmsk.ep.out = 1 << ep->num;
 800231c:	2501      	movs	r5, #1
 800231e:	fa15 f304 	lsls.w	r3, r5, r4
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 8002322:	f8dc 4054 	ldr.w	r4, [ip, #84]	; 0x54
    daintmsk.ep.out = 1 << ep->num;
 8002326:	f363 421f 	bfi	r2, r3, #16, #16
  }
  /* If the EP is already active don't change the EP Control
  * register. */
  depctl.d32 = USB_OTG_READ_REG32(addr);
 800232a:	6823      	ldr	r3, [r4, #0]
  if (!depctl.b.usbactep)
 800232c:	f3c3 2507 	ubfx	r5, r3, #8, #8
 8002330:	f005 0c80 	and.w	ip, r5, #128	; 0x80
 8002334:	fa5f f58c 	uxtb.w	r5, ip
 8002338:	b975      	cbnz	r5, 8002358 <USB_OTG_EPActivate+0x4c>
  {
    depctl.b.mps    = ep->maxpacket;
 800233a:	688e      	ldr	r6, [r1, #8]
    depctl.b.eptype = ep->type;
 800233c:	78cd      	ldrb	r5, [r1, #3]
    depctl.b.txfnum = ep->tx_fifo_num;
 800233e:	f8b1 c006 	ldrh.w	ip, [r1, #6]
  /* If the EP is already active don't change the EP Control
  * register. */
  depctl.d32 = USB_OTG_READ_REG32(addr);
  if (!depctl.b.usbactep)
  {
    depctl.b.mps    = ep->maxpacket;
 8002342:	f366 030a 	bfi	r3, r6, #0, #11
    depctl.b.eptype = ep->type;
 8002346:	f365 4393 	bfi	r3, r5, #18, #2
    depctl.b.txfnum = ep->tx_fifo_num;
 800234a:	f36c 5399 	bfi	r3, ip, #22, #4
    depctl.b.setd0pid = 1;
 800234e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    depctl.b.usbactep = 1;
 8002352:	f443 4100 	orr.w	r1, r3, #32768	; 0x8000
    USB_OTG_WRITE_REG32(addr, depctl.d32);
 8002356:	6021      	str	r1, [r4, #0]
  {
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, 0, daintmsk.d32);
  }
  else
#endif   
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, 0, daintmsk.d32);
 8002358:	6900      	ldr	r0, [r0, #16]
 800235a:	69c1      	ldr	r1, [r0, #28]
 800235c:	430a      	orrs	r2, r1
 800235e:	61c2      	str	r2, [r0, #28]
  return status;
}
 8002360:	2000      	movs	r0, #0
 8002362:	bc70      	pop	{r4, r5, r6}
 8002364:	4770      	bx	lr
  depctl.d32 = 0;
  daintmsk.d32 = 0;
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 8002366:	780c      	ldrb	r4, [r1, #0]
 8002368:	eb00 0584 	add.w	r5, r0, r4, lsl #2
    daintmsk.ep.in = 1 << ep->num;
 800236c:	40a3      	lsls	r3, r4
 800236e:	f363 020f 	bfi	r2, r3, #0, #16
  depctl.d32 = 0;
  daintmsk.d32 = 0;
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 8002372:	69ac      	ldr	r4, [r5, #24]
 8002374:	e7d9      	b.n	800232a <USB_OTG_EPActivate+0x1e>
 8002376:	bf00      	nop

08002378 <USB_OTG_EPDeactivate>:
* @brief  USB_OTG_EPDeactivate : Deactivates an EP
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPDeactivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 8002378:	b430      	push	{r4, r5}
  __IO uint32_t *addr;
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 800237a:	784a      	ldrb	r2, [r1, #1]
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_DEPCTL_TypeDef  depctl;
  USB_OTG_DAINT_TypeDef  daintmsk;
  __IO uint32_t *addr;
  
  depctl.d32 = 0;
 800237c:	2300      	movs	r3, #0
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 800237e:	2a01      	cmp	r2, #1
  USB_OTG_DEPCTL_TypeDef  depctl;
  USB_OTG_DAINT_TypeDef  daintmsk;
  __IO uint32_t *addr;
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
 8002380:	461c      	mov	r4, r3
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 8002382:	d014      	beq.n	80023ae <USB_OTG_EPDeactivate+0x36>
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 8002384:	7809      	ldrb	r1, [r1, #0]
 8002386:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
    daintmsk.ep.out = 1 << ep->num;
 800238a:	2501      	movs	r5, #1
 800238c:	fa15 f201 	lsls.w	r2, r5, r1
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 8002390:	f8dc 1054 	ldr.w	r1, [ip, #84]	; 0x54
    daintmsk.ep.out = 1 << ep->num;
 8002394:	f362 441f 	bfi	r4, r2, #16, #16
  {
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, daintmsk.d32, 0);
  }
  else
#endif    
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, daintmsk.d32, 0);
 8002398:	6900      	ldr	r0, [r0, #16]
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
    daintmsk.ep.out = 1 << ep->num;
  }
  depctl.b.usbactep = 0;
 800239a:	f36f 33cf 	bfc	r3, #15, #1
  USB_OTG_WRITE_REG32(addr, depctl.d32);
 800239e:	600b      	str	r3, [r1, #0]
  {
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, daintmsk.d32, 0);
  }
  else
#endif    
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, daintmsk.d32, 0);
 80023a0:	69c3      	ldr	r3, [r0, #28]
 80023a2:	ea23 0404 	bic.w	r4, r3, r4
 80023a6:	61c4      	str	r4, [r0, #28]
  return status;
}
 80023a8:	2000      	movs	r0, #0
 80023aa:	bc30      	pop	{r4, r5}
 80023ac:	4770      	bx	lr
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 80023ae:	7809      	ldrb	r1, [r1, #0]
 80023b0:	eb00 0581 	add.w	r5, r0, r1, lsl #2
    daintmsk.ep.in = 1 << ep->num;
 80023b4:	408a      	lsls	r2, r1
 80023b6:	f362 040f 	bfi	r4, r2, #0, #16
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 80023ba:	69a9      	ldr	r1, [r5, #24]
 80023bc:	e7ec      	b.n	8002398 <USB_OTG_EPDeactivate+0x20>
 80023be:	bf00      	nop

080023c0 <USB_OTG_EPStartXfer>:
*         starts the xfer
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPStartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 80023c0:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t fifoemptymsk = 0;  
  
  depctl.d32 = 0;
  deptsiz.d32 = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
 80023c2:	784b      	ldrb	r3, [r1, #1]
 80023c4:	2b01      	cmp	r3, #1
 80023c6:	d041      	beq.n	800244c <USB_OTG_EPStartXfer+0x8c>
    }    
  }
  else
  {
    /* OUT endpoint */
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL));
 80023c8:	f891 c000 	ldrb.w	ip, [r1]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ));
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    if (ep->xfer_len == 0)
 80023cc:	694e      	ldr	r6, [r1, #20]
    }    
  }
  else
  {
    /* OUT endpoint */
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL));
 80023ce:	eb00 038c 	add.w	r3, r0, ip, lsl #2
 80023d2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80023d4:	681c      	ldr	r4, [r3, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ));
 80023d6:	691a      	ldr	r2, [r3, #16]
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    if (ep->xfer_len == 0)
 80023d8:	b1f6      	cbz	r6, 8002418 <USB_OTG_EPStartXfer+0x58>
      deptsiz.b.xfersize = ep->maxpacket;
      deptsiz.b.pktcnt = 1;
    }
    else
    {
      deptsiz.b.pktcnt = (ep->xfer_len + (ep->maxpacket - 1)) / ep->maxpacket;
 80023da:	688f      	ldr	r7, [r1, #8]
 80023dc:	19f5      	adds	r5, r6, r7
 80023de:	3d01      	subs	r5, #1
 80023e0:	fbb5 f5f7 	udiv	r5, r5, r7
 80023e4:	05ad      	lsls	r5, r5, #22
 80023e6:	0dad      	lsrs	r5, r5, #22
 80023e8:	f365 42dc 	bfi	r2, r5, #19, #10
      deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
 80023ec:	fb07 f505 	mul.w	r5, r7, r5
 80023f0:	f365 0212 	bfi	r2, r5, #0, #19
    }
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
 80023f4:	611a      	str	r2, [r3, #16]
    
    if (pdev->cfg.dma_enable == 1)
 80023f6:	78c2      	ldrb	r2, [r0, #3]
 80023f8:	2a01      	cmp	r2, #1
 80023fa:	d017      	beq.n	800242c <USB_OTG_EPStartXfer+0x6c>
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
    }
    
    if (ep->type == EP_TYPE_ISOC)
 80023fc:	78ca      	ldrb	r2, [r1, #3]
 80023fe:	2a01      	cmp	r2, #1
 8002400:	d01e      	beq.n	8002440 <USB_OTG_EPStartXfer+0x80>
      }
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL, depctl.d32);
 8002402:	f891 c000 	ldrb.w	ip, [r1]
 8002406:	eb00 018c 	add.w	r1, r0, ip, lsl #2
        depctl.b.setd0pid = 1;
      }
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 800240a:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL, depctl.d32);
 800240e:	6d48      	ldr	r0, [r1, #84]	; 0x54
 8002410:	6004      	str	r4, [r0, #0]
  }
  return status;
}
 8002412:	2000      	movs	r0, #0
 8002414:	bcf0      	pop	{r4, r5, r6, r7}
 8002416:	4770      	bx	lr
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = ep->maxpacket;
 8002418:	688d      	ldr	r5, [r1, #8]
 800241a:	f365 0212 	bfi	r2, r5, #0, #19
      deptsiz.b.pktcnt = 1;
 800241e:	2501      	movs	r5, #1
 8002420:	f365 42dc 	bfi	r2, r5, #19, #10
    else
    {
      deptsiz.b.pktcnt = (ep->xfer_len + (ep->maxpacket - 1)) / ep->maxpacket;
      deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
    }
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
 8002424:	611a      	str	r2, [r3, #16]
    
    if (pdev->cfg.dma_enable == 1)
 8002426:	78c2      	ldrb	r2, [r0, #3]
 8002428:	2a01      	cmp	r2, #1
 800242a:	d1e7      	bne.n	80023fc <USB_OTG_EPStartXfer+0x3c>
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
 800242c:	780b      	ldrb	r3, [r1, #0]
 800242e:	690a      	ldr	r2, [r1, #16]
 8002430:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
 8002434:	f8dc 3054 	ldr.w	r3, [ip, #84]	; 0x54
 8002438:	615a      	str	r2, [r3, #20]
    }
    
    if (ep->type == EP_TYPE_ISOC)
 800243a:	78ca      	ldrb	r2, [r1, #3]
 800243c:	2a01      	cmp	r2, #1
 800243e:	d1e0      	bne.n	8002402 <USB_OTG_EPStartXfer+0x42>
    {
      if (ep->even_odd_frame)
 8002440:	794b      	ldrb	r3, [r1, #5]
 8002442:	2b00      	cmp	r3, #0
 8002444:	d072      	beq.n	800252c <USB_OTG_EPStartXfer+0x16c>
      {
        depctl.b.setd1pid = 1;
 8002446:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
 800244a:	e7da      	b.n	8002402 <USB_OTG_EPStartXfer+0x42>
  depctl.d32 = 0;
  deptsiz.d32 = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
 800244c:	780d      	ldrb	r5, [r1, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 800244e:	694a      	ldr	r2, [r1, #20]
  depctl.d32 = 0;
  deptsiz.d32 = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
 8002450:	eb00 0485 	add.w	r4, r0, r5, lsl #2
 8002454:	69a5      	ldr	r5, [r4, #24]
 8002456:	682e      	ldr	r6, [r5, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
 8002458:	692c      	ldr	r4, [r5, #16]
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 800245a:	2a00      	cmp	r2, #0
 800245c:	d061      	beq.n	8002522 <USB_OTG_EPStartXfer+0x162>
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      deptsiz.b.xfersize = ep->xfer_len;
      deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
 800245e:	688b      	ldr	r3, [r1, #8]

      if (ep->type == EP_TYPE_ISOC)
 8002460:	78cf      	ldrb	r7, [r1, #3]
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      deptsiz.b.xfersize = ep->xfer_len;
      deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
 8002462:	eb02 0c03 	add.w	ip, r2, r3
 8002466:	f10c 3cff 	add.w	ip, ip, #4294967295
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      deptsiz.b.xfersize = ep->xfer_len;
 800246a:	f362 0412 	bfi	r4, r2, #0, #19
      deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
 800246e:	fbbc f3f3 	udiv	r3, ip, r3
 8002472:	f363 44dc 	bfi	r4, r3, #19, #10

      if (ep->type == EP_TYPE_ISOC)
 8002476:	2f01      	cmp	r7, #1
      {
        deptsiz.b.mc = 1;
 8002478:	bf08      	it	eq
 800247a:	f367 745e 	bfieq	r4, r7, #29, #2
      }       
    }
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ, deptsiz.d32);
 800247e:	612c      	str	r4, [r5, #16]
    
    if (pdev->cfg.dma_enable == 1)
 8002480:	78c5      	ldrb	r5, [r0, #3]
 8002482:	2d01      	cmp	r5, #1
 8002484:	d05f      	beq.n	8002546 <USB_OTG_EPStartXfer+0x186>
    {
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);
    }
    else
    {
      if (ep->type != EP_TYPE_ISOC)
 8002486:	78cb      	ldrb	r3, [r1, #3]
 8002488:	2b01      	cmp	r3, #1
 800248a:	d052      	beq.n	8002532 <USB_OTG_EPStartXfer+0x172>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0)
 800248c:	b162      	cbz	r2, 80024a8 <USB_OTG_EPStartXfer+0xe8>
        {
          fifoemptymsk = 1 << ep->num;
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 800248e:	6903      	ldr	r3, [r0, #16]
      if (ep->type != EP_TYPE_ISOC)
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0)
        {
          fifoemptymsk = 1 << ep->num;
 8002490:	780c      	ldrb	r4, [r1, #0]
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 8002492:	6b5d      	ldr	r5, [r3, #52]	; 0x34
      if (ep->type != EP_TYPE_ISOC)
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0)
        {
          fifoemptymsk = 1 << ep->num;
 8002494:	2701      	movs	r7, #1
 8002496:	fa17 f404 	lsls.w	r4, r7, r4
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 800249a:	432c      	orrs	r4, r5
 800249c:	635c      	str	r4, [r3, #52]	; 0x34
        }
      }
    }
    
    
    if (ep->type == EP_TYPE_ISOC)
 800249e:	f891 c003 	ldrb.w	ip, [r1, #3]
 80024a2:	f1bc 0f01 	cmp.w	ip, #1
 80024a6:	d044      	beq.n	8002532 <USB_OTG_EPStartXfer+0x172>
    } 
    
    /* EP enable, IN data in FIFO */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);
 80024a8:	780d      	ldrb	r5, [r1, #0]
 80024aa:	eb00 0c85 	add.w	ip, r0, r5, lsl #2
      }
    } 
    
    /* EP enable, IN data in FIFO */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 80024ae:	f046 4604 	orr.w	r6, r6, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);
 80024b2:	f8dc 3018 	ldr.w	r3, [ip, #24]
 80024b6:	601e      	str	r6, [r3, #0]

    if (ep->type == EP_TYPE_ISOC)
 80024b8:	78cd      	ldrb	r5, [r1, #3]
 80024ba:	2d01      	cmp	r5, #1
 80024bc:	d1a9      	bne.n	8002412 <USB_OTG_EPStartXfer+0x52>
                                uint8_t             *src, 
                                uint8_t             ch_ep_num, 
                                uint16_t            len)
{
  USB_OTG_STS status = USB_OTG_OK;
  if (pdev->cfg.dma_enable == 0)
 80024be:	78c4      	ldrb	r4, [r0, #3]
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);

    if (ep->type == EP_TYPE_ISOC)
    {
      USB_OTG_WritePacket(pdev, ep->xfer_buff, ep->num, ep->xfer_len);   
 80024c0:	68cb      	ldr	r3, [r1, #12]
 80024c2:	7809      	ldrb	r1, [r1, #0]
                                uint8_t             *src, 
                                uint8_t             ch_ep_num, 
                                uint16_t            len)
{
  USB_OTG_STS status = USB_OTG_OK;
  if (pdev->cfg.dma_enable == 0)
 80024c4:	2c00      	cmp	r4, #0
 80024c6:	d1a4      	bne.n	8002412 <USB_OTG_EPStartXfer+0x52>
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
 80024c8:	b294      	uxth	r4, r2
 80024ca:	1ce2      	adds	r2, r4, #3
    fifo = pdev->regs.DFIFO[ch_ep_num];
 80024cc:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    for (i = 0; i < count32b; i++, src+=4)
 80024d0:	1092      	asrs	r2, r2, #2
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
 80024d2:	f8d0 40d0 	ldr.w	r4, [r0, #208]	; 0xd0
    for (i = 0; i < count32b; i++, src+=4)
 80024d6:	d09c      	beq.n	8002412 <USB_OTG_EPStartXfer+0x52>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 80024d8:	f853 1b04 	ldr.w	r1, [r3], #4
 80024dc:	1e56      	subs	r6, r2, #1
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 80024de:	2a01      	cmp	r2, #1
 80024e0:	f006 0601 	and.w	r6, r6, #1
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 80024e4:	6021      	str	r1, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 80024e6:	4628      	mov	r0, r5
 80024e8:	d093      	beq.n	8002412 <USB_OTG_EPStartXfer+0x52>
 80024ea:	b12e      	cbz	r6, 80024f8 <USB_OTG_EPStartXfer+0x138>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 80024ec:	f853 1b04 	ldr.w	r1, [r3], #4
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 80024f0:	2002      	movs	r0, #2
 80024f2:	4282      	cmp	r2, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 80024f4:	6021      	str	r1, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 80024f6:	d08c      	beq.n	8002412 <USB_OTG_EPStartXfer+0x52>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 80024f8:	4619      	mov	r1, r3
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 80024fa:	3002      	adds	r0, #2
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 80024fc:	f851 5b04 	ldr.w	r5, [r1], #4
 8002500:	6025      	str	r5, [r4, #0]
 8002502:	685d      	ldr	r5, [r3, #4]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8002504:	1d0b      	adds	r3, r1, #4
 8002506:	4282      	cmp	r2, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8002508:	6025      	str	r5, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 800250a:	d082      	beq.n	8002412 <USB_OTG_EPStartXfer+0x52>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 800250c:	4619      	mov	r1, r3
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 800250e:	3002      	adds	r0, #2
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8002510:	f851 5b04 	ldr.w	r5, [r1], #4
 8002514:	6025      	str	r5, [r4, #0]
 8002516:	685d      	ldr	r5, [r3, #4]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8002518:	1d0b      	adds	r3, r1, #4
 800251a:	4282      	cmp	r2, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 800251c:	6025      	str	r5, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 800251e:	d1eb      	bne.n	80024f8 <USB_OTG_EPStartXfer+0x138>
 8002520:	e777      	b.n	8002412 <USB_OTG_EPStartXfer+0x52>
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = 0;
 8002522:	f362 0412 	bfi	r4, r2, #0, #19
      deptsiz.b.pktcnt = 1;
 8002526:	f363 44dc 	bfi	r4, r3, #19, #10
 800252a:	e7a8      	b.n	800247e <USB_OTG_EPStartXfer+0xbe>
      {
        depctl.b.setd1pid = 1;
      }
      else
      {
        depctl.b.setd0pid = 1;
 800252c:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
 8002530:	e767      	b.n	8002402 <USB_OTG_EPStartXfer+0x42>
    }
    
    
    if (ep->type == EP_TYPE_ISOC)
    {
      dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8002532:	6905      	ldr	r5, [r0, #16]
 8002534:	68ab      	ldr	r3, [r5, #8]
      
      if (((dsts.b.soffn)&0x1) == 0)
 8002536:	f413 7f80 	tst.w	r3, #256	; 0x100
      {
        depctl.b.setd1pid = 1;
 800253a:	bf0c      	ite	eq
 800253c:	f046 5600 	orreq.w	r6, r6, #536870912	; 0x20000000
      }
      else
      {
        depctl.b.setd0pid = 1;
 8002540:	f046 5680 	orrne.w	r6, r6, #268435456	; 0x10000000
 8002544:	e7b0      	b.n	80024a8 <USB_OTG_EPStartXfer+0xe8>
    }
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ, deptsiz.d32);
    
    if (pdev->cfg.dma_enable == 1)
    {
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);
 8002546:	780d      	ldrb	r5, [r1, #0]
 8002548:	690c      	ldr	r4, [r1, #16]
 800254a:	eb00 0c85 	add.w	ip, r0, r5, lsl #2
 800254e:	f8dc 3018 	ldr.w	r3, [ip, #24]
 8002552:	615c      	str	r4, [r3, #20]
 8002554:	e7a3      	b.n	800249e <USB_OTG_EPStartXfer+0xde>
 8002556:	bf00      	nop

08002558 <USB_OTG_EP0StartXfer>:
*         starts the xfer
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EP0StartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 8002558:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t fifoemptymsk = 0;
  
  depctl.d32   = 0;
  deptsiz.d32  = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
 800255a:	784b      	ldrb	r3, [r1, #1]
 800255c:	2b01      	cmp	r3, #1
*         starts the xfer
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EP0StartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 800255e:	b082      	sub	sp, #8
  uint32_t fifoemptymsk = 0;
  
  depctl.d32   = 0;
  deptsiz.d32  = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
 8002560:	d02f      	beq.n	80025c2 <USB_OTG_EP0StartXfer+0x6a>
    }
  }
  else
  {
    /* OUT endpoint */
    depctl.d32  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 8002562:	f891 c000 	ldrb.w	ip, [r1]
    deptsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ);
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
 8002566:	694e      	ldr	r6, [r1, #20]
    }
  }
  else
  {
    /* OUT endpoint */
    depctl.d32  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 8002568:	eb00 048c 	add.w	r4, r0, ip, lsl #2
 800256c:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800256e:	681a      	ldr	r2, [r3, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ);
 8002570:	691d      	ldr	r5, [r3, #16]
 8002572:	9500      	str	r5, [sp, #0]
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
 8002574:	b1fe      	cbz	r6, 80025b6 <USB_OTG_EP0StartXfer+0x5e>
      deptsiz.b.xfersize = ep->maxpacket;
      deptsiz.b.pktcnt = 1;
    }
    else
    {
      ep->xfer_len = ep->maxpacket;
 8002576:	688e      	ldr	r6, [r1, #8]
      deptsiz.b.xfersize = ep->maxpacket;
 8002578:	f89d 5000 	ldrb.w	r5, [sp]
      deptsiz.b.pktcnt = 1;
 800257c:	f89d 4002 	ldrb.w	r4, [sp, #2]
      deptsiz.b.xfersize = ep->maxpacket;
      deptsiz.b.pktcnt = 1;
    }
    else
    {
      ep->xfer_len = ep->maxpacket;
 8002580:	614e      	str	r6, [r1, #20]
      deptsiz.b.xfersize = ep->maxpacket;
 8002582:	f366 0506 	bfi	r5, r6, #0, #7
      deptsiz.b.pktcnt = 1;
 8002586:	2601      	movs	r6, #1
 8002588:	f366 04c4 	bfi	r4, r6, #3, #2
      deptsiz.b.pktcnt = 1;
    }
    else
    {
      ep->xfer_len = ep->maxpacket;
      deptsiz.b.xfersize = ep->maxpacket;
 800258c:	f88d 5000 	strb.w	r5, [sp]
      deptsiz.b.pktcnt = 1;
 8002590:	f88d 4002 	strb.w	r4, [sp, #2]
    }
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
 8002594:	9c00      	ldr	r4, [sp, #0]
 8002596:	611c      	str	r4, [r3, #16]
    if (pdev->cfg.dma_enable == 1)
 8002598:	78c3      	ldrb	r3, [r0, #3]
 800259a:	2b01      	cmp	r3, #1
 800259c:	d041      	beq.n	8002622 <USB_OTG_EP0StartXfer+0xca>
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32 (&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL), depctl.d32);
 800259e:	f891 c000 	ldrb.w	ip, [r1]
 80025a2:	eb00 008c 	add.w	r0, r0, ip, lsl #2
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 80025a6:	f042 4104 	orr.w	r1, r2, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32 (&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL), depctl.d32);
 80025aa:	6d42      	ldr	r2, [r0, #84]	; 0x54
 80025ac:	6011      	str	r1, [r2, #0]
    
  }
  return status;
}
 80025ae:	2000      	movs	r0, #0
 80025b0:	b002      	add	sp, #8
 80025b2:	bcf0      	pop	{r4, r5, r6, r7}
 80025b4:	4770      	bx	lr
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = ep->maxpacket;
 80025b6:	f89d 5000 	ldrb.w	r5, [sp]
      deptsiz.b.pktcnt = 1;
 80025ba:	f89d 4002 	ldrb.w	r4, [sp, #2]
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = ep->maxpacket;
 80025be:	688e      	ldr	r6, [r1, #8]
 80025c0:	e7df      	b.n	8002582 <USB_OTG_EP0StartXfer+0x2a>
  depctl.d32   = 0;
  deptsiz.d32  = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    in_regs = pdev->regs.INEP_REGS[0];
 80025c2:	6982      	ldr	r2, [r0, #24]
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 80025c4:	694c      	ldr	r4, [r1, #20]
  deptsiz.d32  = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    in_regs = pdev->regs.INEP_REGS[0];
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
 80025c6:	6815      	ldr	r5, [r2, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
 80025c8:	6916      	ldr	r6, [r2, #16]
 80025ca:	9600      	str	r6, [sp, #0]
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 80025cc:	2c00      	cmp	r4, #0
 80025ce:	d030      	beq.n	8002632 <USB_OTG_EP0StartXfer+0xda>
      deptsiz.b.pktcnt = 1;
      
    }
    else
    {
      if (ep->xfer_len > ep->maxpacket)
 80025d0:	688b      	ldr	r3, [r1, #8]
 80025d2:	429c      	cmp	r4, r3
 80025d4:	d942      	bls.n	800265c <USB_OTG_EP0StartXfer+0x104>
      {
        ep->xfer_len = ep->maxpacket;
        deptsiz.b.xfersize = ep->maxpacket;
 80025d6:	f89d 4000 	ldrb.w	r4, [sp]
    }
    else
    {
      if (ep->xfer_len > ep->maxpacket)
      {
        ep->xfer_len = ep->maxpacket;
 80025da:	614b      	str	r3, [r1, #20]
        deptsiz.b.xfersize = ep->maxpacket;
 80025dc:	f363 0406 	bfi	r4, r3, #0, #7
 80025e0:	f88d 4000 	strb.w	r4, [sp]
      }
      else
      {
        deptsiz.b.xfersize = ep->xfer_len;
      }
      deptsiz.b.pktcnt = 1;
 80025e4:	f89d c002 	ldrb.w	ip, [sp, #2]
 80025e8:	2401      	movs	r4, #1
 80025ea:	f364 0cc4 	bfi	ip, r4, #3, #2
 80025ee:	f88d c002 	strb.w	ip, [sp, #2]
    }
    USB_OTG_WRITE_REG32(&in_regs->DIEPTSIZ, deptsiz.d32);
 80025f2:	9b00      	ldr	r3, [sp, #0]
 80025f4:	6113      	str	r3, [r2, #16]
    
    if (pdev->cfg.dma_enable == 1)
 80025f6:	78c3      	ldrb	r3, [r0, #3]
 80025f8:	2b01      	cmp	r3, #1
 80025fa:	d027      	beq.n	800264c <USB_OTG_EP0StartXfer+0xf4>
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);  
    }
    
    /* EP enable, IN data in FIFO */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 80025fc:	f045 4304 	orr.w	r3, r5, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32(&in_regs->DIEPCTL, depctl.d32);
 8002600:	6013      	str	r3, [r2, #0]
    
    
    
    if (pdev->cfg.dma_enable == 0)
 8002602:	78c2      	ldrb	r2, [r0, #3]
 8002604:	2a00      	cmp	r2, #0
 8002606:	d1d2      	bne.n	80025ae <USB_OTG_EP0StartXfer+0x56>
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0)
 8002608:	694a      	ldr	r2, [r1, #20]
 800260a:	2a00      	cmp	r2, #0
 800260c:	d0cf      	beq.n	80025ae <USB_OTG_EP0StartXfer+0x56>
      {
        {
          fifoemptymsk |= 1 << ep->num;
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 800260e:	6903      	ldr	r3, [r0, #16]
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0)
      {
        {
          fifoemptymsk |= 1 << ep->num;
 8002610:	780a      	ldrb	r2, [r1, #0]
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 8002612:	6b59      	ldr	r1, [r3, #52]	; 0x34
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0)
      {
        {
          fifoemptymsk |= 1 << ep->num;
 8002614:	2001      	movs	r0, #1
 8002616:	fa10 f202 	lsls.w	r2, r0, r2
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 800261a:	ea42 0001 	orr.w	r0, r2, r1
 800261e:	6358      	str	r0, [r3, #52]	; 0x34
 8002620:	e7c5      	b.n	80025ae <USB_OTG_EP0StartXfer+0x56>
      deptsiz.b.pktcnt = 1;
    }
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
    if (pdev->cfg.dma_enable == 1)
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
 8002622:	780b      	ldrb	r3, [r1, #0]
 8002624:	690c      	ldr	r4, [r1, #16]
 8002626:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
 800262a:	f8dc 3054 	ldr.w	r3, [ip, #84]	; 0x54
 800262e:	615c      	str	r4, [r3, #20]
 8002630:	e7b5      	b.n	800259e <USB_OTG_EP0StartXfer+0x46>
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = 0;
 8002632:	f89d 7000 	ldrb.w	r7, [sp]
      deptsiz.b.pktcnt = 1;
 8002636:	f89d 6002 	ldrb.w	r6, [sp, #2]
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = 0;
 800263a:	f364 0706 	bfi	r7, r4, #0, #7
      deptsiz.b.pktcnt = 1;
 800263e:	f363 06c4 	bfi	r6, r3, #3, #2
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = 0;
 8002642:	f88d 7000 	strb.w	r7, [sp]
      deptsiz.b.pktcnt = 1;
 8002646:	f88d 6002 	strb.w	r6, [sp, #2]
 800264a:	e7d2      	b.n	80025f2 <USB_OTG_EP0StartXfer+0x9a>
    }
    USB_OTG_WRITE_REG32(&in_regs->DIEPTSIZ, deptsiz.d32);
    
    if (pdev->cfg.dma_enable == 1)
    {
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);  
 800264c:	780b      	ldrb	r3, [r1, #0]
 800264e:	690c      	ldr	r4, [r1, #16]
 8002650:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
 8002654:	f8dc 3018 	ldr.w	r3, [ip, #24]
 8002658:	615c      	str	r4, [r3, #20]
 800265a:	e7cf      	b.n	80025fc <USB_OTG_EP0StartXfer+0xa4>
        ep->xfer_len = ep->maxpacket;
        deptsiz.b.xfersize = ep->maxpacket;
      }
      else
      {
        deptsiz.b.xfersize = ep->xfer_len;
 800265c:	f89d 3000 	ldrb.w	r3, [sp]
 8002660:	f364 0306 	bfi	r3, r4, #0, #7
 8002664:	f88d 3000 	strb.w	r3, [sp]
 8002668:	e7bc      	b.n	80025e4 <USB_OTG_EP0StartXfer+0x8c>
 800266a:	bf00      	nop

0800266c <USB_OTG_EPSetStall>:
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
 800266c:	784b      	ldrb	r3, [r1, #1]
 800266e:	2b01      	cmp	r3, #1
 8002670:	d00a      	beq.n	8002688 <USB_OTG_EPSetStall+0x1c>
    depctl.b.stall = 1;
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
  }
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 8002672:	7809      	ldrb	r1, [r1, #0]
 8002674:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
 8002678:	f8dc 3054 	ldr.w	r3, [ip, #84]	; 0x54
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 800267c:	681a      	ldr	r2, [r3, #0]
    /* set the stall bit */
    depctl.b.stall = 1;
 800267e:	f442 1000 	orr.w	r0, r2, #2097152	; 0x200000
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
 8002682:	6018      	str	r0, [r3, #0]
  }
  return status;
}
 8002684:	2000      	movs	r0, #0
 8002686:	4770      	bx	lr
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 8002688:	780b      	ldrb	r3, [r1, #0]
 800268a:	eb00 0283 	add.w	r2, r0, r3, lsl #2
 800268e:	6992      	ldr	r2, [r2, #24]
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 8002690:	6813      	ldr	r3, [r2, #0]
    /* set the disable and stall bits */
    if (depctl.b.epena)
 8002692:	f3c3 6c07 	ubfx	ip, r3, #24, #8
 8002696:	f00c 0080 	and.w	r0, ip, #128	; 0x80
 800269a:	b2c1      	uxtb	r1, r0
 800269c:	b109      	cbz	r1, 80026a2 <USB_OTG_EPSetStall+0x36>
    {
      depctl.b.epdis = 1;
 800269e:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    }
    depctl.b.stall = 1;
 80026a2:	f443 1100 	orr.w	r1, r3, #2097152	; 0x200000
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
 80026a6:	6011      	str	r1, [r2, #0]
    /* set the stall bit */
    depctl.b.stall = 1;
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
  }
  return status;
}
 80026a8:	2000      	movs	r0, #0
 80026aa:	4770      	bx	lr

080026ac <USB_OTG_EPClearStall>:
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  
  if (ep->is_in == 1)
 80026ac:	f891 c001 	ldrb.w	ip, [r1, #1]
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 80026b0:	780b      	ldrb	r3, [r1, #0]
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 80026b2:	78c9      	ldrb	r1, [r1, #3]
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  
  if (ep->is_in == 1)
 80026b4:	f1bc 0f01 	cmp.w	ip, #1
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 80026b8:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
 80026bc:	bf0c      	ite	eq
 80026be:	f8dc 2018 	ldreq.w	r2, [ip, #24]
  }
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 80026c2:	f8dc 2054 	ldrne.w	r2, [ip, #84]	; 0x54
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 80026c6:	1e88      	subs	r0, r1, #2
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
  }
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 80026c8:	6813      	ldr	r3, [r2, #0]
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 80026ca:	b2c1      	uxtb	r1, r0
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
 80026cc:	f36f 5355 	bfc	r3, #21, #1
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 80026d0:	2901      	cmp	r1, #1
  {
    depctl.b.setd0pid = 1; /* DATA0 */
 80026d2:	bf98      	it	ls
 80026d4:	f043 5380 	orrls.w	r3, r3, #268435456	; 0x10000000
  }
  USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
 80026d8:	6013      	str	r3, [r2, #0]
  return status;
}
 80026da:	2000      	movs	r0, #0
 80026dc:	4770      	bx	lr
 80026de:	bf00      	nop

080026e0 <USB_OTG_ReadDevAllOutEp_itr>:
* @retval OUT endpoint interrupt bits
*/
uint32_t USB_OTG_ReadDevAllOutEp_itr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v;
  v  = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
 80026e0:	6903      	ldr	r3, [r0, #16]
 80026e2:	699a      	ldr	r2, [r3, #24]
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
 80026e4:	69d9      	ldr	r1, [r3, #28]
 80026e6:	ea01 0002 	and.w	r0, r1, r2
  return ((v & 0xffff0000) >> 16);
}
 80026ea:	0c00      	lsrs	r0, r0, #16
 80026ec:	4770      	bx	lr
 80026ee:	bf00      	nop

080026f0 <USB_OTG_ReadDevOutEP_itr>:
* @retval Device OUT EP Interrupt register
*/
uint32_t USB_OTG_ReadDevOutEP_itr(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
  uint32_t v;
  v  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[epnum]->DOEPINT);
 80026f0:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOEPMSK);
 80026f4:	6902      	ldr	r2, [r0, #16]
* @retval Device OUT EP Interrupt register
*/
uint32_t USB_OTG_ReadDevOutEP_itr(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
  uint32_t v;
  v  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[epnum]->DOEPINT);
 80026f6:	f8dc 1054 	ldr.w	r1, [ip, #84]	; 0x54
 80026fa:	688b      	ldr	r3, [r1, #8]
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOEPMSK);
 80026fc:	6950      	ldr	r0, [r2, #20]
  return v;
}
 80026fe:	4018      	ands	r0, r3
 8002700:	4770      	bx	lr
 8002702:	bf00      	nop

08002704 <USB_OTG_ReadDevAllInEPItr>:
* @retval int status register
*/
uint32_t USB_OTG_ReadDevAllInEPItr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v;
  v = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
 8002704:	6902      	ldr	r2, [r0, #16]
 8002706:	6991      	ldr	r1, [r2, #24]
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
 8002708:	69d3      	ldr	r3, [r2, #28]
 800270a:	ea01 0003 	and.w	r0, r1, r3
  return (v & 0xffff);
}
 800270e:	b280      	uxth	r0, r0
 8002710:	4770      	bx	lr
 8002712:	bf00      	nop

08002714 <USB_OTG_EP0_OutStart>:
* @brief  configures EPO to receive SETUP packets
* @param  None
* @retval : None
*/
void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
{
 8002714:	b082      	sub	sp, #8
  USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
  doeptsize0.d32 = 0;
  doeptsize0.b.supcnt = 3;
  doeptsize0.b.pktcnt = 1;
 8002716:	2201      	movs	r2, #1
* @retval : None
*/
void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
  doeptsize0.d32 = 0;
 8002718:	2300      	movs	r3, #0
  doeptsize0.b.supcnt = 3;
  doeptsize0.b.pktcnt = 1;
 800271a:	2100      	movs	r1, #0
* @retval : None
*/
void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
  doeptsize0.d32 = 0;
 800271c:	9300      	str	r3, [sp, #0]
  doeptsize0.b.supcnt = 3;
  doeptsize0.b.pktcnt = 1;
 800271e:	f362 01c4 	bfi	r1, r2, #3, #2
  doeptsize0.b.xfersize = 8 * 3;
 8002722:	2318      	movs	r3, #24
*/
void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
  doeptsize0.d32 = 0;
  doeptsize0.b.supcnt = 3;
 8002724:	22c0      	movs	r2, #192	; 0xc0
 8002726:	f88d 2003 	strb.w	r2, [sp, #3]
  doeptsize0.b.pktcnt = 1;
 800272a:	f88d 1002 	strb.w	r1, [sp, #2]
  doeptsize0.b.xfersize = 8 * 3;
 800272e:	f88d 3000 	strb.w	r3, [sp]
  USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPTSIZ, doeptsize0.d32 );
 8002732:	6d43      	ldr	r3, [r0, #84]	; 0x54
 8002734:	9900      	ldr	r1, [sp, #0]
 8002736:	6119      	str	r1, [r3, #16]
  
  if (pdev->cfg.dma_enable == 1)
 8002738:	78c2      	ldrb	r2, [r0, #3]
 800273a:	2a01      	cmp	r2, #1
 800273c:	d106      	bne.n	800274c <USB_OTG_EP0_OutStart+0x38>
  {
    USB_OTG_DEPCTL_TypeDef  doepctl;
    doepctl.d32 = 0;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPDMA, 
 800273e:	f500 61b9 	add.w	r1, r0, #1480	; 0x5c8
 8002742:	6159      	str	r1, [r3, #20]
    
    /* EP enable */
    doepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[0]->DOEPCTL);
    doepctl.b.epena = 1;
    doepctl.d32 = 0x80008000;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPCTL, doepctl.d32);
 8002744:	f04f 2080 	mov.w	r0, #2147516416	; 0x80008000
    doepctl.d32 = 0;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPDMA, 
                        (uint32_t)&pdev->dev.setup_packet);
    
    /* EP enable */
    doepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[0]->DOEPCTL);
 8002748:	681a      	ldr	r2, [r3, #0]
    doepctl.b.epena = 1;
    doepctl.d32 = 0x80008000;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPCTL, doepctl.d32);
 800274a:	6018      	str	r0, [r3, #0]
  }
}
 800274c:	b002      	add	sp, #8
 800274e:	4770      	bx	lr

08002750 <USB_OTG_ActiveRemoteWakeup>:
  
  USB_OTG_DCTL_TypeDef     dctl;
  USB_OTG_DSTS_TypeDef     dsts;
  USB_OTG_PCGCCTL_TypeDef  power;  
  
  if (pdev->dev.DevRemoteWakeup) 
 8002750:	f8d0 3114 	ldr.w	r3, [r0, #276]	; 0x114
* @brief  USB_OTG_RemoteWakeup : active remote wakeup signalling
* @param  None
* @retval : None
*/
void USB_OTG_ActiveRemoteWakeup(USB_OTG_CORE_HANDLE *pdev)
{
 8002754:	b510      	push	{r4, lr}
 8002756:	4604      	mov	r4, r0
  
  USB_OTG_DCTL_TypeDef     dctl;
  USB_OTG_DSTS_TypeDef     dsts;
  USB_OTG_PCGCCTL_TypeDef  power;  
  
  if (pdev->dev.DevRemoteWakeup) 
 8002758:	b1db      	cbz	r3, 8002792 <USB_OTG_ActiveRemoteWakeup+0x42>
  {
    dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 800275a:	6903      	ldr	r3, [r0, #16]
 800275c:	689a      	ldr	r2, [r3, #8]
    if(dsts.b.suspsts == 1)
 800275e:	f012 0f01 	tst.w	r2, #1
 8002762:	d016      	beq.n	8002792 <USB_OTG_ActiveRemoteWakeup+0x42>
    {
      if(pdev->cfg.low_power)
 8002764:	7a81      	ldrb	r1, [r0, #10]
 8002766:	b141      	cbz	r1, 800277a <USB_OTG_ActiveRemoteWakeup+0x2a>
      {
        /* un-gate USB Core clock */
        power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
 8002768:	f8d0 210c 	ldr.w	r2, [r0, #268]	; 0x10c
        power.b.gatehclk = 0;
        power.b.stoppclk = 0;
        USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 800276c:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
    {
      if(pdev->cfg.low_power)
      {
        /* un-gate USB Core clock */
        power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
        power.b.gatehclk = 0;
 8002770:	f36f 0241 	bfc	r2, #1, #1
        power.b.stoppclk = 0;
 8002774:	f36f 0200 	bfc	r2, #0, #1
        USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 8002778:	6002      	str	r2, [r0, #0]
      }   
      /* active Remote wakeup signaling */
      dctl.d32 = 0;
      dctl.b.rmtwkupsig = 1;
      USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, 0, dctl.d32);
 800277a:	6859      	ldr	r1, [r3, #4]
 800277c:	f041 0201 	orr.w	r2, r1, #1
 8002780:	605a      	str	r2, [r3, #4]
      USB_OTG_BSP_mDelay(5);
 8002782:	2005      	movs	r0, #5
 8002784:	f001 f991 	bl	8003aaa <USB_OTG_BSP_mDelay>
      USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
 8002788:	6923      	ldr	r3, [r4, #16]
 800278a:	6858      	ldr	r0, [r3, #4]
 800278c:	f020 0101 	bic.w	r1, r0, #1
 8002790:	6059      	str	r1, [r3, #4]
 8002792:	bd10      	pop	{r4, pc}

08002794 <USB_OTG_UngateClock>:
* @param  None
* @retval : None
*/
void USB_OTG_UngateClock(USB_OTG_CORE_HANDLE *pdev)
{
  if(pdev->cfg.low_power)
 8002794:	7a83      	ldrb	r3, [r0, #10]
 8002796:	b16b      	cbz	r3, 80027b4 <USB_OTG_UngateClock+0x20>
  {
    
    USB_OTG_DSTS_TypeDef     dsts;
    USB_OTG_PCGCCTL_TypeDef  power; 
    
    dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8002798:	6902      	ldr	r2, [r0, #16]
 800279a:	6891      	ldr	r1, [r2, #8]
    
    if(dsts.b.suspsts == 1)
 800279c:	f011 0f01 	tst.w	r1, #1
 80027a0:	d008      	beq.n	80027b4 <USB_OTG_UngateClock+0x20>
    {
      /* un-gate USB Core clock */
      power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
 80027a2:	f8d0 310c 	ldr.w	r3, [r0, #268]	; 0x10c
      power.b.gatehclk = 0;
      power.b.stoppclk = 0;
      USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 80027a6:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
    
    if(dsts.b.suspsts == 1)
    {
      /* un-gate USB Core clock */
      power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
      power.b.gatehclk = 0;
 80027aa:	f36f 0341 	bfc	r3, #1, #1
      power.b.stoppclk = 0;
 80027ae:	f36f 0300 	bfc	r3, #0, #1
      USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 80027b2:	6003      	str	r3, [r0, #0]
 80027b4:	4770      	bx	lr
 80027b6:	bf00      	nop

080027b8 <USB_OTG_StopDevice>:
* @brief  Stop the device and clean up fifo's
* @param  None
* @retval : None
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
{
 80027b8:	b570      	push	{r4, r5, r6, lr}
  uint32_t i;
  
  pdev->dev.device_status = 1;
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80027ba:	7843      	ldrb	r3, [r0, #1]
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t i;
  
  pdev->dev.device_status = 1;
 80027bc:	2201      	movs	r2, #1
* @brief  Stop the device and clean up fifo's
* @param  None
* @retval : None
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
{
 80027be:	4604      	mov	r4, r0
  uint32_t i;
  
  pdev->dev.device_status = 1;
 80027c0:	f880 2112 	strb.w	r2, [r0, #274]	; 0x112
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80027c4:	b163      	cbz	r3, 80027e0 <USB_OTG_StopDevice+0x28>
/**
* @brief  Stop the device and clean up fifo's
* @param  None
* @retval : None
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
 80027c6:	f100 0214 	add.w	r2, r0, #20
{
  uint32_t i;
  
  pdev->dev.device_status = 1;
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80027ca:	2300      	movs	r3, #0
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 80027cc:	21ff      	movs	r1, #255	; 0xff
 80027ce:	f852 5f04 	ldr.w	r5, [r2, #4]!
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 80027d2:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
  
  pdev->dev.device_status = 1;
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 80027d4:	60a9      	str	r1, [r5, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 80027d6:	6081      	str	r1, [r0, #8]
{
  uint32_t i;
  
  pdev->dev.device_status = 1;
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80027d8:	7860      	ldrb	r0, [r4, #1]
 80027da:	3301      	adds	r3, #1
 80027dc:	4298      	cmp	r0, r3
 80027de:	d8f6      	bhi.n	80027ce <USB_OTG_StopDevice+0x16>
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }

  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 80027e0:	6923      	ldr	r3, [r4, #16]
 80027e2:	2200      	movs	r2, #0
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
 80027e4:	f04f 31ff 	mov.w	r1, #4294967295
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }

  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 80027e8:	611a      	str	r2, [r3, #16]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
 80027ea:	4620      	mov	r0, r4
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }

  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
 80027ec:	615a      	str	r2, [r3, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
 80027ee:	61da      	str	r2, [r3, #28]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
 80027f0:	6199      	str	r1, [r3, #24]
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
 80027f2:	f7ff fc55 	bl	80020a0 <USB_OTG_FlushRxFifo>
  USB_OTG_FlushTxFifo(pdev ,  0x10 );  
 80027f6:	4620      	mov	r0, r4
 80027f8:	2110      	movs	r1, #16
}
 80027fa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
  USB_OTG_FlushTxFifo(pdev ,  0x10 );  
 80027fe:	e425      	b.n	800204c <USB_OTG_FlushTxFifo>

08002800 <USB_OTG_GetEPStatus>:
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  uint32_t Status = 0;  
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
 8002800:	784b      	ldrb	r3, [r1, #1]
 8002802:	2b01      	cmp	r3, #1
 8002804:	d01a      	beq.n	800283c <USB_OTG_GetEPStatus+0x3c>
      Status = USB_OTG_EP_TX_VALID;     

  }
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 8002806:	780b      	ldrb	r3, [r1, #0]
 8002808:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 800280c:	6d42      	ldr	r2, [r0, #84]	; 0x54
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 800280e:	6811      	ldr	r1, [r2, #0]
    if (depctl.b.stall == 1)  
 8002810:	f3c1 4007 	ubfx	r0, r1, #16, #8
 8002814:	f000 0c20 	and.w	ip, r0, #32
 8002818:	fa5f f38c 	uxtb.w	r3, ip
 800281c:	b95b      	cbnz	r3, 8002836 <USB_OTG_GetEPStatus+0x36>
      Status = USB_OTG_EP_RX_STALL;
    else if (depctl.b.naksts == 1)
 800281e:	f000 0102 	and.w	r1, r0, #2
 8002822:	fa5f fc81 	uxtb.w	ip, r1
      Status = USB_OTG_EP_RX_NAK;
 8002826:	f1bc 0f00 	cmp.w	ip, #0
 800282a:	bf0c      	ite	eq
 800282c:	f44f 5040 	moveq.w	r0, #12288	; 0x3000
 8002830:	f44f 5000 	movne.w	r0, #8192	; 0x2000
 8002834:	4770      	bx	lr
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
    if (depctl.b.stall == 1)  
      Status = USB_OTG_EP_RX_STALL;
 8002836:	f44f 5080 	mov.w	r0, #4096	; 0x1000
      Status = USB_OTG_EP_RX_VALID; 
  } 
  
  /* Return the current status */
  return Status;
}
 800283a:	4770      	bx	lr
  uint32_t Status = 0;  
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 800283c:	7809      	ldrb	r1, [r1, #0]
 800283e:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
 8002842:	f8dc 3018 	ldr.w	r3, [ip, #24]
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 8002846:	6818      	ldr	r0, [r3, #0]
    
    if (depctl.b.stall == 1)  
 8002848:	f3c0 4007 	ubfx	r0, r0, #16, #8
 800284c:	f000 0220 	and.w	r2, r0, #32
 8002850:	b2d1      	uxtb	r1, r2
 8002852:	b939      	cbnz	r1, 8002864 <USB_OTG_GetEPStatus+0x64>
      Status = USB_OTG_EP_TX_STALL;
    else if (depctl.b.naksts == 1)
 8002854:	f000 0002 	and.w	r0, r0, #2
 8002858:	b2c2      	uxtb	r2, r0
      Status = USB_OTG_EP_TX_NAK;
 800285a:	2a00      	cmp	r2, #0
 800285c:	bf0c      	ite	eq
 800285e:	2030      	moveq	r0, #48	; 0x30
 8002860:	2020      	movne	r0, #32
 8002862:	4770      	bx	lr
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
    
    if (depctl.b.stall == 1)  
      Status = USB_OTG_EP_TX_STALL;
 8002864:	2010      	movs	r0, #16
 8002866:	4770      	bx	lr

08002868 <USB_OTG_SetEPStatus>:
*         Status : new Status
*         ep : EP structure
* @retval : None
*/
void USB_OTG_SetEPStatus (USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep , uint32_t Status)
{
 8002868:	b470      	push	{r4, r5, r6}
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;

  /* Process for IN endpoint */
  if (ep->is_in == 1)
 800286a:	784d      	ldrb	r5, [r1, #1]
 800286c:	2d01      	cmp	r5, #1
 800286e:	d016      	beq.n	800289e <USB_OTG_SetEPStatus+0x36>
    else if (Status == USB_OTG_EP_TX_DIS)
      depctl.b.usbactep = 0;
  } 
  else /* Process for OUT endpoint */
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 8002870:	f891 c000 	ldrb.w	ip, [r1]
 8002874:	eb00 068c 	add.w	r6, r0, ip, lsl #2
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);    
    
    if (Status == USB_OTG_EP_RX_STALL)  {
 8002878:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    else if (Status == USB_OTG_EP_TX_DIS)
      depctl.b.usbactep = 0;
  } 
  else /* Process for OUT endpoint */
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 800287c:	6d75      	ldr	r5, [r6, #84]	; 0x54
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);    
 800287e:	682c      	ldr	r4, [r5, #0]
 8002880:	4626      	mov	r6, r4
    
    if (Status == USB_OTG_EP_RX_STALL)  {
 8002882:	d019      	beq.n	80028b8 <USB_OTG_SetEPStatus+0x50>
      depctl.b.stall = 1;
    }
    else if (Status == USB_OTG_EP_RX_NAK)
 8002884:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8002888:	d013      	beq.n	80028b2 <USB_OTG_SetEPStatus+0x4a>
      depctl.b.snak = 1;
    else if (Status == USB_OTG_EP_RX_VALID)
 800288a:	f5b2 5f40 	cmp.w	r2, #12288	; 0x3000
 800288e:	d018      	beq.n	80028c2 <USB_OTG_SetEPStatus+0x5a>
      }  
      depctl.b.cnak = 1;
      depctl.b.usbactep = 1;    
      depctl.b.epena = 1;
    }
    else if (Status == USB_OTG_EP_RX_DIS)
 8002890:	b912      	cbnz	r2, 8002898 <USB_OTG_SetEPStatus+0x30>
    {
      depctl.b.usbactep = 0;    
 8002892:	f362 36cf 	bfi	r6, r2, #15, #1
 8002896:	4634      	mov	r4, r6
    }
  }

  USB_OTG_WRITE_REG32(depctl_addr, depctl.d32); 
 8002898:	602c      	str	r4, [r5, #0]
}
 800289a:	bc70      	pop	{r4, r5, r6}
 800289c:	4770      	bx	lr
  depctl.d32 = 0;

  /* Process for IN endpoint */
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 800289e:	780b      	ldrb	r3, [r1, #0]
 80028a0:	eb00 0483 	add.w	r4, r0, r3, lsl #2
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
    
    if (Status == USB_OTG_EP_TX_STALL)  
 80028a4:	2a10      	cmp	r2, #16
  depctl.d32 = 0;

  /* Process for IN endpoint */
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 80028a6:	69a5      	ldr	r5, [r4, #24]
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 80028a8:	682c      	ldr	r4, [r5, #0]
 80028aa:	4626      	mov	r6, r4
    
    if (Status == USB_OTG_EP_TX_STALL)  
 80028ac:	d018      	beq.n	80028e0 <USB_OTG_SetEPStatus+0x78>
    {
      USB_OTG_EPSetStall(pdev, ep); return;
    }
    else if (Status == USB_OTG_EP_TX_NAK)
 80028ae:	2a20      	cmp	r2, #32
 80028b0:	d105      	bne.n	80028be <USB_OTG_SetEPStatus+0x56>
    
    if (Status == USB_OTG_EP_RX_STALL)  {
      depctl.b.stall = 1;
    }
    else if (Status == USB_OTG_EP_RX_NAK)
      depctl.b.snak = 1;
 80028b2:	f044 6400 	orr.w	r4, r4, #134217728	; 0x8000000
 80028b6:	e7ef      	b.n	8002898 <USB_OTG_SetEPStatus+0x30>
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);    
    
    if (Status == USB_OTG_EP_RX_STALL)  {
      depctl.b.stall = 1;
 80028b8:	f444 1400 	orr.w	r4, r4, #2097152	; 0x200000
 80028bc:	e7ec      	b.n	8002898 <USB_OTG_SetEPStatus+0x30>
    {
      USB_OTG_EPSetStall(pdev, ep); return;
    }
    else if (Status == USB_OTG_EP_TX_NAK)
      depctl.b.snak = 1;
    else if (Status == USB_OTG_EP_TX_VALID)
 80028be:	2a30      	cmp	r2, #48	; 0x30
 80028c0:	d1e6      	bne.n	8002890 <USB_OTG_SetEPStatus+0x28>
    }
    else if (Status == USB_OTG_EP_RX_NAK)
      depctl.b.snak = 1;
    else if (Status == USB_OTG_EP_RX_VALID)
    {
      if (depctl.b.stall == 1)
 80028c2:	f3c4 4c07 	ubfx	ip, r4, #16, #8
 80028c6:	f00c 0320 	and.w	r3, ip, #32
 80028ca:	b2da      	uxtb	r2, r3
 80028cc:	b922      	cbnz	r2, 80028d8 <USB_OTG_SetEPStatus+0x70>
      {  
        ep->even_odd_frame = 0;
        USB_OTG_EPClearStall(pdev, ep);
        return;
      }  
      depctl.b.cnak = 1;
 80028ce:	f044 6080 	orr.w	r0, r4, #67108864	; 0x4000000
      depctl.b.usbactep = 1;    
      depctl.b.epena = 1;
 80028d2:	f040 2480 	orr.w	r4, r0, #2147516416	; 0x80008000
 80028d6:	e7df      	b.n	8002898 <USB_OTG_SetEPStatus+0x30>
      depctl.b.snak = 1;
    else if (Status == USB_OTG_EP_RX_VALID)
    {
      if (depctl.b.stall == 1)
      {  
        ep->even_odd_frame = 0;
 80028d8:	2200      	movs	r2, #0
 80028da:	714a      	strb	r2, [r1, #5]
      depctl.b.usbactep = 0;    
    }
  }

  USB_OTG_WRITE_REG32(depctl_addr, depctl.d32); 
}
 80028dc:	bc70      	pop	{r4, r5, r6}
    else if (Status == USB_OTG_EP_RX_VALID)
    {
      if (depctl.b.stall == 1)
      {  
        ep->even_odd_frame = 0;
        USB_OTG_EPClearStall(pdev, ep);
 80028de:	e6e5      	b.n	80026ac <USB_OTG_EPClearStall>
      depctl.b.usbactep = 0;    
    }
  }

  USB_OTG_WRITE_REG32(depctl_addr, depctl.d32); 
}
 80028e0:	bc70      	pop	{r4, r5, r6}
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
    
    if (Status == USB_OTG_EP_TX_STALL)  
    {
      USB_OTG_EPSetStall(pdev, ep); return;
 80028e2:	e6c3      	b.n	800266c <USB_OTG_EPSetStall>

080028e4 <DCD_Init>:



void DCD_Init(USB_OTG_CORE_HANDLE *pdev , 
              USB_OTG_CORE_ID_TypeDef coreID)
{
 80028e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80028e8:	4604      	mov	r4, r0
  uint32_t i;
  USB_OTG_EP *ep;
  
  USB_OTG_SelectCore (pdev , coreID);
 80028ea:	f7ff fa3b 	bl	8001d64 <USB_OTG_SelectCore>
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80028ee:	7866      	ldrb	r6, [r4, #1]
  uint32_t i;
  USB_OTG_EP *ep;
  
  USB_OTG_SelectCore (pdev , coreID);
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
 80028f0:	2701      	movs	r7, #1
  pdev->dev.device_address = 0;
 80028f2:	2100      	movs	r1, #0
  uint32_t i;
  USB_OTG_EP *ep;
  
  USB_OTG_SelectCore (pdev , coreID);
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
 80028f4:	f884 7112 	strb.w	r7, [r4, #274]	; 0x112
  pdev->dev.device_address = 0;
 80028f8:	f884 1113 	strb.w	r1, [r4, #275]	; 0x113
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80028fc:	2e00      	cmp	r6, #0
 80028fe:	f000 809a 	beq.w	8002a36 <DCD_Init+0x152>
 8002902:	1e73      	subs	r3, r6, #1
    ep->is_in = 1;
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 8002904:	f04f 0e40 	mov.w	lr, #64	; 0x40
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002908:	42b7      	cmp	r7, r6
 800290a:	ea03 0207 	and.w	r2, r3, r7
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
 800290e:	f884 7119 	strb.w	r7, [r4, #281]	; 0x119
    ep->num = i;
 8002912:	f884 1118 	strb.w	r1, [r4, #280]	; 0x118
    ep->tx_fifo_num = i;
 8002916:	f8a4 111e 	strh.w	r1, [r4, #286]	; 0x11e
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 800291a:	f884 111b 	strb.w	r1, [r4, #283]	; 0x11b
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 800291e:	f8c4 e120 	str.w	lr, [r4, #288]	; 0x120
    ep->xfer_buff = 0;
 8002922:	f8c4 1124 	str.w	r1, [r4, #292]	; 0x124
    ep->xfer_len = 0;
 8002926:	f8c4 112c 	str.w	r1, [r4, #300]	; 0x12c
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 800292a:	4638      	mov	r0, r7
 800292c:	f104 0328 	add.w	r3, r4, #40	; 0x28
 8002930:	d234      	bcs.n	800299c <DCD_Init+0xb8>
 8002932:	b192      	cbz	r2, 800295a <DCD_Init+0x76>
 8002934:	2002      	movs	r0, #2
 8002936:	42b0      	cmp	r0, r6
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
 8002938:	f883 7119 	strb.w	r7, [r3, #281]	; 0x119
    ep->num = i;
 800293c:	f883 7118 	strb.w	r7, [r3, #280]	; 0x118
    ep->tx_fifo_num = i;
 8002940:	f8a3 711e 	strh.w	r7, [r3, #286]	; 0x11e
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 8002944:	f883 111b 	strb.w	r1, [r3, #283]	; 0x11b
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 8002948:	f8c3 e120 	str.w	lr, [r3, #288]	; 0x120
    ep->xfer_buff = 0;
 800294c:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
    ep->xfer_len = 0;
 8002950:	f8c3 112c 	str.w	r1, [r3, #300]	; 0x12c
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002954:	f104 0350 	add.w	r3, r4, #80	; 0x50
 8002958:	d220      	bcs.n	800299c <DCD_Init+0xb8>
 800295a:	1c45      	adds	r5, r0, #1
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
    ep->num = i;
 800295c:	f883 0118 	strb.w	r0, [r3, #280]	; 0x118
    ep->tx_fifo_num = i;
 8002960:	f8a3 011e 	strh.w	r0, [r3, #286]	; 0x11e
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002964:	3002      	adds	r0, #2
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
 8002966:	f883 7119 	strb.w	r7, [r3, #281]	; 0x119
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 800296a:	f883 111b 	strb.w	r1, [r3, #283]	; 0x11b
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 800296e:	f8c3 e120 	str.w	lr, [r3, #288]	; 0x120
    ep->xfer_buff = 0;
 8002972:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
    ep->xfer_len = 0;
 8002976:	f8c3 112c 	str.w	r1, [r3, #300]	; 0x12c
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
 800297a:	f883 7141 	strb.w	r7, [r3, #321]	; 0x141
    ep->num = i;
 800297e:	f883 5140 	strb.w	r5, [r3, #320]	; 0x140
    ep->tx_fifo_num = i;
 8002982:	f8a3 5146 	strh.w	r5, [r3, #326]	; 0x146
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 8002986:	f883 1143 	strb.w	r1, [r3, #323]	; 0x143
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 800298a:	f8c3 e148 	str.w	lr, [r3, #328]	; 0x148
    ep->xfer_buff = 0;
 800298e:	f8c3 114c 	str.w	r1, [r3, #332]	; 0x14c
    ep->xfer_len = 0;
 8002992:	f8c3 1154 	str.w	r1, [r3, #340]	; 0x154
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002996:	3350      	adds	r3, #80	; 0x50
 8002998:	42b0      	cmp	r0, r6
 800299a:	d3de      	bcc.n	800295a <DCD_Init+0x76>
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 800299c:	2001      	movs	r0, #1
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 800299e:	2200      	movs	r2, #0
    ep->is_in = 0;
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 80029a0:	2740      	movs	r7, #64	; 0x40
 80029a2:	1e71      	subs	r1, r6, #1
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 80029a4:	42b0      	cmp	r0, r6
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 80029a6:	f884 2371 	strb.w	r2, [r4, #881]	; 0x371
    ep->num = i;
 80029aa:	f884 2370 	strb.w	r2, [r4, #880]	; 0x370
    ep->tx_fifo_num = i;
 80029ae:	f8a4 2376 	strh.w	r2, [r4, #886]	; 0x376
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
 80029b2:	f884 2373 	strb.w	r2, [r4, #883]	; 0x373
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 80029b6:	f8c4 7378 	str.w	r7, [r4, #888]	; 0x378
    ep->xfer_buff = 0;
 80029ba:	f8c4 237c 	str.w	r2, [r4, #892]	; 0x37c
    ep->xfer_len = 0;
 80029be:	f8c4 2384 	str.w	r2, [r4, #900]	; 0x384
 80029c2:	ea01 0100 	and.w	r1, r1, r0
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 80029c6:	f104 0328 	add.w	r3, r4, #40	; 0x28
 80029ca:	d234      	bcs.n	8002a36 <DCD_Init+0x152>
 80029cc:	b191      	cbz	r1, 80029f4 <DCD_Init+0x110>
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
    ep->num = i;
 80029ce:	f883 0370 	strb.w	r0, [r3, #880]	; 0x370
    ep->tx_fifo_num = i;
 80029d2:	f8a3 0376 	strh.w	r0, [r3, #886]	; 0x376
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 80029d6:	2002      	movs	r0, #2
 80029d8:	42b0      	cmp	r0, r6
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 80029da:	f883 2371 	strb.w	r2, [r3, #881]	; 0x371
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
 80029de:	f883 2373 	strb.w	r2, [r3, #883]	; 0x373
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 80029e2:	f8c3 7378 	str.w	r7, [r3, #888]	; 0x378
    ep->xfer_buff = 0;
 80029e6:	f8c3 237c 	str.w	r2, [r3, #892]	; 0x37c
    ep->xfer_len = 0;
 80029ea:	f8c3 2384 	str.w	r2, [r3, #900]	; 0x384
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 80029ee:	f104 0350 	add.w	r3, r4, #80	; 0x50
 80029f2:	d220      	bcs.n	8002a36 <DCD_Init+0x152>
 80029f4:	1c45      	adds	r5, r0, #1
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
    ep->num = i;
 80029f6:	f883 0370 	strb.w	r0, [r3, #880]	; 0x370
    ep->tx_fifo_num = i;
 80029fa:	f8a3 0376 	strh.w	r0, [r3, #886]	; 0x376
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 80029fe:	3002      	adds	r0, #2
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 8002a00:	f883 2371 	strb.w	r2, [r3, #881]	; 0x371
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
 8002a04:	f883 2373 	strb.w	r2, [r3, #883]	; 0x373
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 8002a08:	f8c3 7378 	str.w	r7, [r3, #888]	; 0x378
    ep->xfer_buff = 0;
 8002a0c:	f8c3 237c 	str.w	r2, [r3, #892]	; 0x37c
    ep->xfer_len = 0;
 8002a10:	f8c3 2384 	str.w	r2, [r3, #900]	; 0x384
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 8002a14:	f883 2399 	strb.w	r2, [r3, #921]	; 0x399
    ep->num = i;
 8002a18:	f883 5398 	strb.w	r5, [r3, #920]	; 0x398
    ep->tx_fifo_num = i;
 8002a1c:	f8a3 539e 	strh.w	r5, [r3, #926]	; 0x39e
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
 8002a20:	f883 239b 	strb.w	r2, [r3, #923]	; 0x39b
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 8002a24:	f8c3 73a0 	str.w	r7, [r3, #928]	; 0x3a0
    ep->xfer_buff = 0;
 8002a28:	f8c3 23a4 	str.w	r2, [r3, #932]	; 0x3a4
    ep->xfer_len = 0;
 8002a2c:	f8c3 23ac 	str.w	r2, [r3, #940]	; 0x3ac
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8002a30:	3350      	adds	r3, #80	; 0x50
 8002a32:	42b0      	cmp	r0, r6
 8002a34:	d3de      	bcc.n	80029f4 <DCD_Init+0x110>
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  USB_OTG_DisableGlobalInt(pdev);
 8002a36:	4620      	mov	r0, r4
 8002a38:	f7ff fb00 	bl	800203c <USB_OTG_DisableGlobalInt>
  
  /*Init the Core (common init.) */
  USB_OTG_CoreInit(pdev);
 8002a3c:	4620      	mov	r0, r4
 8002a3e:	f7ff fa73 	bl	8001f28 <USB_OTG_CoreInit>


  /* Force Device Mode*/
  USB_OTG_SetCurrentMode(pdev, DEVICE_MODE);
 8002a42:	2100      	movs	r1, #0
 8002a44:	4620      	mov	r0, r4
 8002a46:	f7ff fb51 	bl	80020ec <USB_OTG_SetCurrentMode>
  
  /* Init Device */
  USB_OTG_CoreInitDev(pdev);
 8002a4a:	4620      	mov	r0, r4
 8002a4c:	f7ff fbac 	bl	80021a8 <USB_OTG_CoreInitDev>
  
  
  /* Enable USB Global interrupt */
  USB_OTG_EnableGlobalInt(pdev);
 8002a50:	4620      	mov	r0, r4
}
 8002a52:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  /* Init Device */
  USB_OTG_CoreInitDev(pdev);
  
  
  /* Enable USB Global interrupt */
  USB_OTG_EnableGlobalInt(pdev);
 8002a56:	f7ff bae9 	b.w	800202c <USB_OTG_EnableGlobalInt>
 8002a5a:	bf00      	nop

08002a5c <DCD_EP_Open>:
*/
uint32_t DCD_EP_Open(USB_OTG_CORE_HANDLE *pdev , 
                     uint8_t ep_addr,
                     uint16_t ep_mps,
                     uint8_t ep_type)
{
 8002a5c:	b538      	push	{r3, r4, r5, lr}
  USB_OTG_EP *ep;
  
  if ((ep_addr & 0x80) == 0x80)
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002a5e:	f001 057f 	and.w	r5, r1, #127	; 0x7f
                     uint16_t ep_mps,
                     uint8_t ep_type)
{
  USB_OTG_EP *ep;
  
  if ((ep_addr & 0x80) == 0x80)
 8002a62:	b2cc      	uxtb	r4, r1
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002a64:	eb05 0185 	add.w	r1, r5, r5, lsl #2
 8002a68:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
                     uint16_t ep_mps,
                     uint8_t ep_type)
{
  USB_OTG_EP *ep;
  
  if ((ep_addr & 0x80) == 0x80)
 8002a6c:	f014 0f80 	tst.w	r4, #128	; 0x80
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002a70:	bf14      	ite	ne
 8002a72:	f501 718c 	addne.w	r1, r1, #280	; 0x118
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8002a76:	f501 715c 	addeq.w	r1, r1, #880	; 0x370
  }
  ep->num   = ep_addr & 0x7F;
 8002a7a:	b2ed      	uxtb	r5, r5
  
  ep->is_in = (0x80 & ep_addr) != 0;
 8002a7c:	09e4      	lsrs	r4, r4, #7
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
 8002a7e:	700d      	strb	r5, [r1, #0]
  
  ep->is_in = (0x80 & ep_addr) != 0;
 8002a80:	704c      	strb	r4, [r1, #1]
  ep->maxpacket = ep_mps;
 8002a82:	608a      	str	r2, [r1, #8]
  ep->type = ep_type;
 8002a84:	70cb      	strb	r3, [r1, #3]
  if (ep->is_in)
 8002a86:	b104      	cbz	r4, 8002a8a <DCD_EP_Open+0x2e>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 8002a88:	80cd      	strh	r5, [r1, #6]
  }
  /* Set initial data PID. */
  if (ep_type == USB_OTG_EP_BULK )
 8002a8a:	2b02      	cmp	r3, #2
 8002a8c:	d101      	bne.n	8002a92 <DCD_EP_Open+0x36>
  {
    ep->data_pid_start = 0;
 8002a8e:	2300      	movs	r3, #0
 8002a90:	710b      	strb	r3, [r1, #4]
  }
  USB_OTG_EPActivate(pdev , ep );
 8002a92:	f7ff fc3b 	bl	800230c <USB_OTG_EPActivate>
  return 0;
}
 8002a96:	2000      	movs	r0, #0
 8002a98:	bd38      	pop	{r3, r4, r5, pc}
 8002a9a:	bf00      	nop

08002a9c <DCD_EP_Close>:
{
  USB_OTG_EP *ep;
  
  if ((ep_addr&0x80) == 0x80)
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002a9c:	f001 027f 	and.w	r2, r1, #127	; 0x7f
* @param pdev: device instance
* @param ep_addr: endpoint address
* @retval : status
*/
uint32_t DCD_EP_Close(USB_OTG_CORE_HANDLE *pdev , uint8_t  ep_addr)
{
 8002aa0:	b508      	push	{r3, lr}
  USB_OTG_EP *ep;
  
  if ((ep_addr&0x80) == 0x80)
 8002aa2:	b2cb      	uxtb	r3, r1
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002aa4:	eb02 0182 	add.w	r1, r2, r2, lsl #2
*/
uint32_t DCD_EP_Close(USB_OTG_CORE_HANDLE *pdev , uint8_t  ep_addr)
{
  USB_OTG_EP *ep;
  
  if ((ep_addr&0x80) == 0x80)
 8002aa8:	f013 0f80 	tst.w	r3, #128	; 0x80
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002aac:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
 8002ab0:	bf14      	ite	ne
 8002ab2:	f501 718c 	addne.w	r1, r1, #280	; 0x118
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8002ab6:	f501 715c 	addeq.w	r1, r1, #880	; 0x370
  }
  ep->num   = ep_addr & 0x7F;
  ep->is_in = (0x80 & ep_addr) != 0;
 8002aba:	09db      	lsrs	r3, r3, #7
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
 8002abc:	700a      	strb	r2, [r1, #0]
  ep->is_in = (0x80 & ep_addr) != 0;
 8002abe:	704b      	strb	r3, [r1, #1]
  USB_OTG_EPDeactivate(pdev , ep );
 8002ac0:	f7ff fc5a 	bl	8002378 <USB_OTG_EPDeactivate>
  return 0;
}
 8002ac4:	2000      	movs	r0, #0
 8002ac6:	bd08      	pop	{r3, pc}

08002ac8 <DCD_EP_PrepareRx>:
                            uint8_t *pbuf,                        
                            uint16_t  buf_len)
{
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8002ac8:	f001 017f 	and.w	r1, r1, #127	; 0x7f
*/
uint32_t   DCD_EP_PrepareRx( USB_OTG_CORE_HANDLE *pdev,
                            uint8_t   ep_addr,
                            uint8_t *pbuf,                        
                            uint16_t  buf_len)
{
 8002acc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8002ace:	eb01 0581 	add.w	r5, r1, r1, lsl #2
 8002ad2:	00ec      	lsls	r4, r5, #3
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
 8002ad4:	1905      	adds	r5, r0, r4
  ep->xfer_len = buf_len;
  ep->xfer_count = 0;
 8002ad6:	2700      	movs	r7, #0
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
 8002ad8:	b2ce      	uxtb	r6, r1
 8002ada:	f885 6370 	strb.w	r6, [r5, #880]	; 0x370
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
  ep->xfer_len = buf_len;
  ep->xfer_count = 0;
  ep->is_in = 0;
 8002ade:	f885 7371 	strb.w	r7, [r5, #881]	; 0x371
  ep->num = ep_addr & 0x7F;
  
  if (pdev->cfg.dma_enable == 1)
 8002ae2:	f890 e003 	ldrb.w	lr, [r0, #3]
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
  ep->xfer_len = buf_len;
 8002ae6:	f8c5 3384 	str.w	r3, [r5, #900]	; 0x384
  ep->xfer_count = 0;
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
  
  if (pdev->cfg.dma_enable == 1)
 8002aea:	f1be 0f01 	cmp.w	lr, #1
                            uint8_t *pbuf,                        
                            uint16_t  buf_len)
{
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8002aee:	f504 745c 	add.w	r4, r4, #880	; 0x370
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
  
  if (pdev->cfg.dma_enable == 1)
  {
    ep->dma_addr = (uint32_t)pbuf;  
 8002af2:	bf08      	it	eq
 8002af4:	b2f6      	uxtbeq	r6, r6
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
 8002af6:	f8c5 237c 	str.w	r2, [r5, #892]	; 0x37c
  ep->xfer_len = buf_len;
  ep->xfer_count = 0;
 8002afa:	f8c5 7388 	str.w	r7, [r5, #904]	; 0x388
                            uint8_t *pbuf,                        
                            uint16_t  buf_len)
{
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8002afe:	eb00 0104 	add.w	r1, r0, r4
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
  
  if (pdev->cfg.dma_enable == 1)
  {
    ep->dma_addr = (uint32_t)pbuf;  
 8002b02:	bf08      	it	eq
 8002b04:	f8c5 2380 	streq.w	r2, [r5, #896]	; 0x380
  }
  
  if ( ep->num == 0 )
 8002b08:	b11e      	cbz	r6, 8002b12 <DCD_EP_PrepareRx+0x4a>
  {
    USB_OTG_EP0StartXfer(pdev , ep);
  }
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
 8002b0a:	f7ff fc59 	bl	80023c0 <USB_OTG_EPStartXfer>
  }
  return 0;
}
 8002b0e:	2000      	movs	r0, #0
 8002b10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ep->dma_addr = (uint32_t)pbuf;  
  }
  
  if ( ep->num == 0 )
  {
    USB_OTG_EP0StartXfer(pdev , ep);
 8002b12:	f7ff fd21 	bl	8002558 <USB_OTG_EP0StartXfer>
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
  }
  return 0;
}
 8002b16:	2000      	movs	r0, #0
 8002b18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002b1a:	bf00      	nop

08002b1c <DCD_EP_Tx>:
*/
uint32_t  DCD_EP_Tx ( USB_OTG_CORE_HANDLE *pdev,
                     uint8_t   ep_addr,
                     uint8_t   *pbuf,
                     uint32_t   buf_len)
{
 8002b1c:	b570      	push	{r4, r5, r6, lr}
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002b1e:	f001 057f 	and.w	r5, r1, #127	; 0x7f
 8002b22:	eb05 0485 	add.w	r4, r5, r5, lsl #2
 8002b26:	00e1      	lsls	r1, r4, #3
  
  /* Setup and start the Transfer */
  ep->is_in = 1;
 8002b28:	1844      	adds	r4, r0, r1
                     uint8_t   *pbuf,
                     uint32_t   buf_len)
{
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002b2a:	f501 768c 	add.w	r6, r1, #280	; 0x118
 8002b2e:	1981      	adds	r1, r0, r6
  
  /* Setup and start the Transfer */
  ep->is_in = 1;
  ep->num = ep_addr & 0x7F;  
  ep->xfer_buff = pbuf;
 8002b30:	f8c4 2124 	str.w	r2, [r4, #292]	; 0x124
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
  
  /* Setup and start the Transfer */
  ep->is_in = 1;
 8002b34:	2601      	movs	r6, #1
  ep->num = ep_addr & 0x7F;  
  ep->xfer_buff = pbuf;
  ep->dma_addr = (uint32_t)pbuf;  
 8002b36:	f8c4 2128 	str.w	r2, [r4, #296]	; 0x128
  ep->xfer_count = 0;
 8002b3a:	2200      	movs	r2, #0
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
  
  /* Setup and start the Transfer */
  ep->is_in = 1;
 8002b3c:	f884 6119 	strb.w	r6, [r4, #281]	; 0x119
  ep->num = ep_addr & 0x7F;  
 8002b40:	f884 5118 	strb.w	r5, [r4, #280]	; 0x118
  ep->xfer_buff = pbuf;
  ep->dma_addr = (uint32_t)pbuf;  
  ep->xfer_count = 0;
 8002b44:	f8c4 2130 	str.w	r2, [r4, #304]	; 0x130
  ep->xfer_len  = buf_len;
 8002b48:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
  
  if ( ep->num == 0 )
 8002b4c:	b11d      	cbz	r5, 8002b56 <DCD_EP_Tx+0x3a>
  {
    USB_OTG_EP0StartXfer(pdev , ep);
  }
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
 8002b4e:	f7ff fc37 	bl	80023c0 <USB_OTG_EPStartXfer>
  }
  return 0;
}
 8002b52:	2000      	movs	r0, #0
 8002b54:	bd70      	pop	{r4, r5, r6, pc}
  ep->xfer_count = 0;
  ep->xfer_len  = buf_len;
  
  if ( ep->num == 0 )
  {
    USB_OTG_EP0StartXfer(pdev , ep);
 8002b56:	f7ff fcff 	bl	8002558 <USB_OTG_EP0StartXfer>
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
  }
  return 0;
}
 8002b5a:	2000      	movs	r0, #0
 8002b5c:	bd70      	pop	{r4, r5, r6, pc}
 8002b5e:	bf00      	nop

08002b60 <DCD_EP_Stall>:
* @retval : status
*/
uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 8002b60:	b2ca      	uxtb	r2, r1
 8002b62:	f012 0f80 	tst.w	r2, #128	; 0x80
* @param pdev: device instance
* @param epnum: endpoint address
* @retval : status
*/
uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
{
 8002b66:	b510      	push	{r4, lr}
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 8002b68:	d111      	bne.n	8002b8e <DCD_EP_Stall+0x2e>
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8002b6a:	eb01 0e81 	add.w	lr, r1, r1, lsl #2
 8002b6e:	eb00 0cce 	add.w	ip, r0, lr, lsl #3
 8002b72:	f50c 735c 	add.w	r3, ip, #880	; 0x370
 8002b76:	f001 017f 	and.w	r1, r1, #127	; 0x7f
  }

  ep->is_stall = 1;
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 8002b7a:	09d2      	lsrs	r2, r2, #7
  else
  {
    ep = &pdev->dev.out_ep[epnum];
  }

  ep->is_stall = 1;
 8002b7c:	2401      	movs	r4, #1
  ep->num   = epnum & 0x7F;
 8002b7e:	7019      	strb	r1, [r3, #0]
  else
  {
    ep = &pdev->dev.out_ep[epnum];
  }

  ep->is_stall = 1;
 8002b80:	709c      	strb	r4, [r3, #2]
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 8002b82:	705a      	strb	r2, [r3, #1]
  
  USB_OTG_EPSetStall(pdev , ep);
 8002b84:	4619      	mov	r1, r3
 8002b86:	f7ff fd71 	bl	800266c <USB_OTG_EPSetStall>
  return (0);
}
 8002b8a:	2000      	movs	r0, #0
 8002b8c:	bd10      	pop	{r4, pc}
uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];
 8002b8e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8002b92:	eb01 0481 	add.w	r4, r1, r1, lsl #2
 8002b96:	eb00 03c4 	add.w	r3, r0, r4, lsl #3
 8002b9a:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8002b9e:	e7ec      	b.n	8002b7a <DCD_EP_Stall+0x1a>

08002ba0 <DCD_EP_ClrStall>:
* @retval : status
*/
uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 8002ba0:	b2ca      	uxtb	r2, r1
 8002ba2:	f012 0f80 	tst.w	r2, #128	; 0x80
* @param pdev: device instance
* @param epnum: endpoint address
* @retval : status
*/
uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
 8002ba6:	b510      	push	{r4, lr}
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 8002ba8:	d111      	bne.n	8002bce <DCD_EP_ClrStall+0x2e>
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8002baa:	eb01 0e81 	add.w	lr, r1, r1, lsl #2
 8002bae:	eb00 0cce 	add.w	ip, r0, lr, lsl #3
 8002bb2:	f50c 735c 	add.w	r3, ip, #880	; 0x370
 8002bb6:	f001 017f 	and.w	r1, r1, #127	; 0x7f
  }
  
  ep->is_stall = 0;  
 8002bba:	2400      	movs	r4, #0
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 8002bbc:	09d2      	lsrs	r2, r2, #7
  {
    ep = &pdev->dev.out_ep[epnum];
  }
  
  ep->is_stall = 0;  
  ep->num   = epnum & 0x7F;
 8002bbe:	7019      	strb	r1, [r3, #0]
  else
  {
    ep = &pdev->dev.out_ep[epnum];
  }
  
  ep->is_stall = 0;  
 8002bc0:	709c      	strb	r4, [r3, #2]
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 8002bc2:	705a      	strb	r2, [r3, #1]
  
  USB_OTG_EPClearStall(pdev , ep);
 8002bc4:	4619      	mov	r1, r3
 8002bc6:	f7ff fd71 	bl	80026ac <USB_OTG_EPClearStall>
  return (0);
}
 8002bca:	4620      	mov	r0, r4
 8002bcc:	bd10      	pop	{r4, pc}
uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
 8002bce:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8002bd2:	eb01 0481 	add.w	r4, r1, r1, lsl #2
 8002bd6:	eb00 03c4 	add.w	r3, r0, r4, lsl #3
 8002bda:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8002bde:	e7ec      	b.n	8002bba <DCD_EP_ClrStall+0x1a>

08002be0 <DCD_EP_Flush>:
* @retval : status
*/
uint32_t  DCD_EP_Flush (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{

  if ((epnum & 0x80) == 0x80)
 8002be0:	f011 0f80 	tst.w	r1, #128	; 0x80
* @param pdev: device instance
* @param epnum: endpoint address
* @retval : status
*/
uint32_t  DCD_EP_Flush (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
 8002be4:	b508      	push	{r3, lr}

  if ((epnum & 0x80) == 0x80)
 8002be6:	d103      	bne.n	8002bf0 <DCD_EP_Flush+0x10>
  {
    USB_OTG_FlushTxFifo(pdev, epnum & 0x7F);
  }
  else
  {
    USB_OTG_FlushRxFifo(pdev);
 8002be8:	f7ff fa5a 	bl	80020a0 <USB_OTG_FlushRxFifo>
  }

  return (0);
}
 8002bec:	2000      	movs	r0, #0
 8002bee:	bd08      	pop	{r3, pc}
uint32_t  DCD_EP_Flush (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{

  if ((epnum & 0x80) == 0x80)
  {
    USB_OTG_FlushTxFifo(pdev, epnum & 0x7F);
 8002bf0:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8002bf4:	f7ff fa2a 	bl	800204c <USB_OTG_FlushTxFifo>
  {
    USB_OTG_FlushRxFifo(pdev);
  }

  return (0);
}
 8002bf8:	2000      	movs	r0, #0
 8002bfa:	bd08      	pop	{r3, pc}

08002bfc <DCD_EP_SetAddress>:
void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
{
  USB_OTG_DCFG_TypeDef  dcfg;
  dcfg.d32 = 0;
  dcfg.b.devaddr = address;
  USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
 8002bfc:	6903      	ldr	r3, [r0, #16]
* @retval : status
*/
void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
{
  USB_OTG_DCFG_TypeDef  dcfg;
  dcfg.d32 = 0;
 8002bfe:	2200      	movs	r2, #0
  dcfg.b.devaddr = address;
  USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
 8002c00:	6818      	ldr	r0, [r3, #0]
*/
void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
{
  USB_OTG_DCFG_TypeDef  dcfg;
  dcfg.d32 = 0;
  dcfg.b.devaddr = address;
 8002c02:	f361 120a 	bfi	r2, r1, #4, #7
  USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
 8002c06:	4302      	orrs	r2, r0
 8002c08:	601a      	str	r2, [r3, #0]
}
 8002c0a:	4770      	bx	lr

08002c0c <DCD_DevConnect>:
*/
void  DCD_DevConnect (USB_OTG_CORE_HANDLE *pdev)
{
#ifndef USE_OTG_MODE
  USB_OTG_DCTL_TypeDef  dctl;
  dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 8002c0c:	6903      	ldr	r3, [r0, #16]
 8002c0e:	685a      	ldr	r2, [r3, #4]
  /* Connect device */
  dctl.b.sftdiscon  = 0;
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
  USB_OTG_BSP_mDelay(3);
 8002c10:	2003      	movs	r0, #3
{
#ifndef USE_OTG_MODE
  USB_OTG_DCTL_TypeDef  dctl;
  dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
  /* Connect device */
  dctl.b.sftdiscon  = 0;
 8002c12:	f36f 0241 	bfc	r2, #1, #1
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
 8002c16:	605a      	str	r2, [r3, #4]
  USB_OTG_BSP_mDelay(3);
 8002c18:	f000 bf47 	b.w	8003aaa <USB_OTG_BSP_mDelay>

08002c1c <DCD_DevDisconnect>:
*/
void  DCD_DevDisconnect (USB_OTG_CORE_HANDLE *pdev)
{
#ifndef USE_OTG_MODE
  USB_OTG_DCTL_TypeDef  dctl;
  dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 8002c1c:	6903      	ldr	r3, [r0, #16]
 8002c1e:	6858      	ldr	r0, [r3, #4]
  /* Disconnect device for 3ms */
  dctl.b.sftdiscon  = 1;
 8002c20:	f040 0202 	orr.w	r2, r0, #2
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
  USB_OTG_BSP_mDelay(3);
 8002c24:	2003      	movs	r0, #3
#ifndef USE_OTG_MODE
  USB_OTG_DCTL_TypeDef  dctl;
  dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
  /* Disconnect device for 3ms */
  dctl.b.sftdiscon  = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
 8002c26:	605a      	str	r2, [r3, #4]
  USB_OTG_BSP_mDelay(3);
 8002c28:	f000 bf3f 	b.w	8003aaa <USB_OTG_BSP_mDelay>

08002c2c <DCD_GetEPStatus>:
uint32_t DCD_GetEPStatus(USB_OTG_CORE_HANDLE *pdev ,uint8_t epnum)
{
  USB_OTG_EP *ep;
  uint32_t Status = 0;  
  
  if ((0x80 & epnum) == 0x80)
 8002c2c:	f011 0f80 	tst.w	r1, #128	; 0x80
 8002c30:	d107      	bne.n	8002c42 <DCD_GetEPStatus+0x16>
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8002c32:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8002c36:	eb00 0cc1 	add.w	ip, r0, r1, lsl #3
 8002c3a:	f50c 715c 	add.w	r1, ip, #880	; 0x370
  }
  
  Status = USB_OTG_GetEPStatus(pdev ,ep);
 8002c3e:	f7ff bddf 	b.w	8002800 <USB_OTG_GetEPStatus>
  USB_OTG_EP *ep;
  uint32_t Status = 0;  
  
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
 8002c42:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 8002c46:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 8002c4a:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
 8002c4e:	f501 718c 	add.w	r1, r1, #280	; 0x118
 8002c52:	e7f4      	b.n	8002c3e <DCD_GetEPStatus+0x12>

08002c54 <DCD_SetEPStatus>:
*/
void DCD_SetEPStatus (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum , uint32_t Status)
{
  USB_OTG_EP *ep;
  
  if ((0x80 & epnum) == 0x80)
 8002c54:	f011 0f80 	tst.w	r1, #128	; 0x80
 8002c58:	d107      	bne.n	8002c6a <DCD_SetEPStatus+0x16>
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8002c5a:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 8002c5e:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
 8002c62:	f501 715c 	add.w	r1, r1, #880	; 0x370
  }
  
   USB_OTG_SetEPStatus(pdev ,ep , Status);
 8002c66:	f7ff bdff 	b.w	8002868 <USB_OTG_SetEPStatus>
{
  USB_OTG_EP *ep;
  
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
 8002c6a:	f001 0c7f 	and.w	ip, r1, #127	; 0x7f
 8002c6e:	eb0c 038c 	add.w	r3, ip, ip, lsl #2
 8002c72:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
 8002c76:	f501 718c 	add.w	r1, r1, #280	; 0x118
 8002c7a:	e7f4      	b.n	8002c66 <DCD_SetEPStatus+0x12>

08002c7c <USBD_OTG_ISR_Handler>:
*         handles all USB Interrupts
* @param  pdev: device instance
* @retval status
*/
uint32_t USBD_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
{
 8002c7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002c80:	b083      	sub	sp, #12
 8002c82:	4606      	mov	r6, r0
  USB_OTG_GINTSTS_TypeDef  gintr_status;
  uint32_t retval = 0;
  
  if (USB_OTG_IsDeviceMode(pdev)) /* ensure that we are in device mode */
 8002c84:	f7ff fa52 	bl	800212c <USB_OTG_IsDeviceMode>
 8002c88:	b910      	cbnz	r0, 8002c90 <USBD_OTG_ISR_Handler+0x14>
      retval |= DCD_OTG_ISR(pdev);
    }   
#endif    
  }
  return retval;
}
 8002c8a:	b003      	add	sp, #12
 8002c8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  USB_OTG_GINTSTS_TypeDef  gintr_status;
  uint32_t retval = 0;
  
  if (USB_OTG_IsDeviceMode(pdev)) /* ensure that we are in device mode */
  {
    gintr_status.d32 = USB_OTG_ReadCoreItr(pdev);
 8002c90:	4630      	mov	r0, r6
 8002c92:	f7ff fa59 	bl	8002148 <USB_OTG_ReadCoreItr>
    if (!gintr_status.d32) /* avoid spurious interrupt */
 8002c96:	4681      	mov	r9, r0
 8002c98:	2800      	cmp	r0, #0
 8002c9a:	d0f6      	beq.n	8002c8a <USBD_OTG_ISR_Handler+0xe>
    {
      return 0;
    }
    
    if (gintr_status.b.outepintr)
 8002c9c:	f3c0 4107 	ubfx	r1, r0, #16, #8
 8002ca0:	f001 0008 	and.w	r0, r1, #8
 8002ca4:	b2c0      	uxtb	r0, r0
 8002ca6:	2800      	cmp	r0, #0
 8002ca8:	f040 8118 	bne.w	8002edc <USBD_OTG_ISR_Handler+0x260>
    {
      retval |= DCD_HandleOutEP_ISR(pdev);
    }    
    
    if (gintr_status.b.inepint)
 8002cac:	f3c9 4e07 	ubfx	lr, r9, #16, #8
 8002cb0:	f00e 0c04 	and.w	ip, lr, #4
 8002cb4:	fa5f f38c 	uxtb.w	r3, ip
 8002cb8:	2b00      	cmp	r3, #0
 8002cba:	d166      	bne.n	8002d8a <USBD_OTG_ISR_Handler+0x10e>
    {
      retval |= DCD_HandleInEP_ISR(pdev);
    }
    
    if (gintr_status.b.modemismatch)
 8002cbc:	f009 0c02 	and.w	ip, r9, #2
 8002cc0:	fa5f f38c 	uxtb.w	r3, ip
 8002cc4:	b113      	cbz	r3, 8002ccc <USBD_OTG_ISR_Handler+0x50>
      USB_OTG_GINTSTS_TypeDef  gintsts;
      
      /* Clear interrupt */
      gintsts.d32 = 0;
      gintsts.b.modemismatch = 1;
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002cc6:	68f2      	ldr	r2, [r6, #12]
    {
      USB_OTG_GINTSTS_TypeDef  gintsts;
      
      /* Clear interrupt */
      gintsts.d32 = 0;
      gintsts.b.modemismatch = 1;
 8002cc8:	2102      	movs	r1, #2
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002cca:	6151      	str	r1, [r2, #20]
    }
    
    if (gintr_status.b.wkupintr)
 8002ccc:	f3c9 6107 	ubfx	r1, r9, #24, #8
 8002cd0:	f001 0c80 	and.w	ip, r1, #128	; 0x80
 8002cd4:	fa5f f38c 	uxtb.w	r3, ip
 8002cd8:	b193      	cbz	r3, 8002d00 <USBD_OTG_ISR_Handler+0x84>
{
  USB_OTG_GINTSTS_TypeDef  gintsts;
  USB_OTG_DCTL_TypeDef     devctl;
  USB_OTG_PCGCCTL_TypeDef  power;
  
  if(pdev->cfg.low_power)
 8002cda:	7ab0      	ldrb	r0, [r6, #10]
 8002cdc:	2800      	cmp	r0, #0
 8002cde:	f040 8204 	bne.w	80030ea <USBD_OTG_ISR_Handler+0x46e>
  }
  
  /* Clear the Remote Wake-up Signaling */
  devctl.d32 = 0;
  devctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, devctl.d32, 0);
 8002ce2:	6933      	ldr	r3, [r6, #16]
  
  /* Inform upper layer by the Resume Event */
  USBD_DCD_INT_fops->Resume (pdev);
 8002ce4:	4aa8      	ldr	r2, [pc, #672]	; (8002f88 <USBD_OTG_ISR_Handler+0x30c>)
  }
  
  /* Clear the Remote Wake-up Signaling */
  devctl.d32 = 0;
  devctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, devctl.d32, 0);
 8002ce6:	6859      	ldr	r1, [r3, #4]
  
  /* Inform upper layer by the Resume Event */
  USBD_DCD_INT_fops->Resume (pdev);
 8002ce8:	6810      	ldr	r0, [r2, #0]
  }
  
  /* Clear the Remote Wake-up Signaling */
  devctl.d32 = 0;
  devctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, devctl.d32, 0);
 8002cea:	f021 0101 	bic.w	r1, r1, #1
 8002cee:	6059      	str	r1, [r3, #4]
  
  /* Inform upper layer by the Resume Event */
  USBD_DCD_INT_fops->Resume (pdev);
 8002cf0:	6982      	ldr	r2, [r0, #24]
 8002cf2:	4630      	mov	r0, r6
 8002cf4:	4790      	blx	r2
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.wkupintr = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002cf6:	68f0      	ldr	r0, [r6, #12]
  /* Inform upper layer by the Resume Event */
  USBD_DCD_INT_fops->Resume (pdev);
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.wkupintr = 1;
 8002cf8:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002cfc:	6141      	str	r1, [r0, #20]
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
    }
    
    if (gintr_status.b.wkupintr)
    {
      retval |= DCD_HandleResume_ISR(pdev);
 8002cfe:	2001      	movs	r0, #1
    }
    
    if (gintr_status.b.usbsuspend)
 8002d00:	f3c9 2107 	ubfx	r1, r9, #8, #8
 8002d04:	f001 0c08 	and.w	ip, r1, #8
 8002d08:	fa5f f38c 	uxtb.w	r3, ip
 8002d0c:	2b00      	cmp	r3, #0
 8002d0e:	f040 81cb 	bne.w	80030a8 <USBD_OTG_ISR_Handler+0x42c>
    {
      retval |= DCD_HandleUSBSuspend_ISR(pdev);
    }
    if (gintr_status.b.sofintr)
 8002d12:	f009 0c08 	and.w	ip, r9, #8
 8002d16:	fa5f f28c 	uxtb.w	r2, ip
 8002d1a:	2a00      	cmp	r2, #0
 8002d1c:	f040 81ba 	bne.w	8003094 <USBD_OTG_ISR_Handler+0x418>
    {
      retval |= DCD_HandleSof_ISR(pdev);
      
    }
    
    if (gintr_status.b.rxstsqlvl)
 8002d20:	f009 0c10 	and.w	ip, r9, #16
 8002d24:	fa5f f38c 	uxtb.w	r3, ip
 8002d28:	2b00      	cmp	r3, #0
 8002d2a:	f040 818d 	bne.w	8003048 <USBD_OTG_ISR_Handler+0x3cc>
    {
      retval |= DCD_HandleRxStatusQueueLevel_ISR(pdev);
      
    }
    
    if (gintr_status.b.usbreset)
 8002d2e:	f3c9 2107 	ubfx	r1, r9, #8, #8
 8002d32:	f001 0c10 	and.w	ip, r1, #16
 8002d36:	fa5f f38c 	uxtb.w	r3, ip
 8002d3a:	2b00      	cmp	r3, #0
 8002d3c:	f040 814a 	bne.w	8002fd4 <USBD_OTG_ISR_Handler+0x358>
    {
      retval |= DCD_HandleUsbReset_ISR(pdev);
      
    }
    if (gintr_status.b.enumdone)
 8002d40:	f3c9 2107 	ubfx	r1, r9, #8, #8
 8002d44:	f001 0c20 	and.w	ip, r1, #32
 8002d48:	fa5f f38c 	uxtb.w	r3, ip
 8002d4c:	2b00      	cmp	r3, #0
 8002d4e:	f040 8128 	bne.w	8002fa2 <USBD_OTG_ISR_Handler+0x326>
    {
      retval |= DCD_HandleEnumDone_ISR(pdev);
    }
    
    if (gintr_status.b.incomplisoin)
 8002d52:	f3c9 4207 	ubfx	r2, r9, #16, #8
 8002d56:	f002 0c10 	and.w	ip, r2, #16
 8002d5a:	fa5f f18c 	uxtb.w	r1, ip
 8002d5e:	2900      	cmp	r1, #0
 8002d60:	f040 8114 	bne.w	8002f8c <USBD_OTG_ISR_Handler+0x310>
    {
      retval |= DCD_IsoINIncomplete_ISR(pdev);
    }

    if (gintr_status.b.incomplisoout)
 8002d64:	f3c9 4107 	ubfx	r1, r9, #16, #8
 8002d68:	f001 0c20 	and.w	ip, r1, #32
 8002d6c:	fa5f f38c 	uxtb.w	r3, ip
 8002d70:	2b00      	cmp	r3, #0
 8002d72:	d08a      	beq.n	8002c8a <USBD_OTG_ISR_Handler+0xe>
{
  USB_OTG_GINTSTS_TypeDef gintsts;  
  
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoOUTIncomplete (pdev); 
 8002d74:	4a84      	ldr	r2, [pc, #528]	; (8002f88 <USBD_OTG_ISR_Handler+0x30c>)
 8002d76:	6811      	ldr	r1, [r2, #0]
 8002d78:	4630      	mov	r0, r6
 8002d7a:	6a0b      	ldr	r3, [r1, #32]
 8002d7c:	4798      	blx	r3
  
  /* Clear interrupt */
  gintsts.b.incomplisoout = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002d7e:	68f0      	ldr	r0, [r6, #12]
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoOUTIncomplete (pdev); 
  
  /* Clear interrupt */
  gintsts.b.incomplisoout = 1;
 8002d80:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002d84:	6142      	str	r2, [r0, #20]
      retval |= DCD_IsoINIncomplete_ISR(pdev);
    }

    if (gintr_status.b.incomplisoout)
    {
      retval |= DCD_IsoOUTIncomplete_ISR(pdev);
 8002d86:	2001      	movs	r0, #1
 8002d88:	e77f      	b.n	8002c8a <USBD_OTG_ISR_Handler+0xe>
  
  uint32_t ep_intr;
  uint32_t epnum = 0;
  uint32_t fifoemptymsk;
  diepint.d32 = 0;
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
 8002d8a:	4630      	mov	r0, r6
 8002d8c:	f7ff fcba 	bl	8002704 <USB_OTG_ReadDevAllInEPItr>
  
  while ( ep_intr )
 8002d90:	4682      	mov	sl, r0
 8002d92:	2800      	cmp	r0, #0
 8002d94:	f000 80a0 	beq.w	8002ed8 <USBD_OTG_ISR_Handler+0x25c>
 8002d98:	4637      	mov	r7, r6
 8002d9a:	4634      	mov	r4, r6
static uint32_t DCD_HandleInEP_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_DIEPINTn_TypeDef  diepint;
  
  uint32_t ep_intr;
  uint32_t epnum = 0;
 8002d9c:	f04f 0b00 	mov.w	fp, #0
      {
        CLEAR_IN_EP_INTR(epnum, inepnakeff);
      }
      if ( diepint.b.epdisabled )
      {
        CLEAR_IN_EP_INTR(epnum, epdisabled);
 8002da0:	f8cd 9004 	str.w	r9, [sp, #4]
 8002da4:	46b0      	mov	r8, r6
  diepint.d32 = 0;
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
  
  while ( ep_intr )
  {
    if (ep_intr&0x1) /* In ITR */
 8002da6:	f01a 0f01 	tst.w	sl, #1
 8002daa:	f000 808a 	beq.w	8002ec2 <USBD_OTG_ISR_Handler+0x246>
* @retval status
*/
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
 8002dae:	f8d8 3010 	ldr.w	r3, [r8, #16]
  diepint.d32 = 0;
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
  
  while ( ep_intr )
  {
    if (ep_intr&0x1) /* In ITR */
 8002db2:	fa5f f68b 	uxtb.w	r6, fp
* @retval status
*/
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
 8002db6:	6919      	ldr	r1, [r3, #16]
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
 8002db8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  msk |= ((emp >> epnum) & 0x1) << 7;
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 8002dba:	eb08 0c86 	add.w	ip, r8, r6, lsl #2
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
  msk |= ((emp >> epnum) & 0x1) << 7;
 8002dbe:	fa32 f506 	lsrs.w	r5, r2, r6
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 8002dc2:	f8dc 0018 	ldr.w	r0, [ip, #24]
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
  msk |= ((emp >> epnum) & 0x1) << 7;
 8002dc6:	01ed      	lsls	r5, r5, #7
 8002dc8:	f005 02ff 	and.w	r2, r5, #255	; 0xff
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 8002dcc:	6880      	ldr	r0, [r0, #8]
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
  msk |= ((emp >> epnum) & 0x1) << 7;
 8002dce:	ea42 0901 	orr.w	r9, r2, r1
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 8002dd2:	ea09 0500 	and.w	r5, r9, r0
  while ( ep_intr )
  {
    if (ep_intr&0x1) /* In ITR */
    {
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
 8002dd6:	b2ed      	uxtb	r5, r5
 8002dd8:	f015 0f01 	tst.w	r5, #1
 8002ddc:	f040 81b7 	bne.w	800314e <USBD_OTG_ISR_Handler+0x4d2>
            /* prepare to rx more setup packets */
            USB_OTG_EP0_OutStart(pdev);
          }
        }           
      }
      if ( diepint.b.ahberr )
 8002de0:	f005 0904 	and.w	r9, r5, #4
 8002de4:	fa5f f389 	uxtb.w	r3, r9
 8002de8:	b113      	cbz	r3, 8002df0 <USBD_OTG_ISR_Handler+0x174>
      {
        CLEAR_IN_EP_INTR(epnum, ahberr);
 8002dea:	69ba      	ldr	r2, [r7, #24]
 8002dec:	2504      	movs	r5, #4
 8002dee:	6095      	str	r5, [r2, #8]
      }
      if ( diepint.b.timeout )
 8002df0:	f005 0008 	and.w	r0, r5, #8
 8002df4:	b2c1      	uxtb	r1, r0
 8002df6:	b111      	cbz	r1, 8002dfe <USBD_OTG_ISR_Handler+0x182>
      {
        CLEAR_IN_EP_INTR(epnum, timeout);
 8002df8:	69bb      	ldr	r3, [r7, #24]
 8002dfa:	2508      	movs	r5, #8
 8002dfc:	609d      	str	r5, [r3, #8]
      }
      if (diepint.b.intktxfemp)
 8002dfe:	f005 0c10 	and.w	ip, r5, #16
 8002e02:	fa5f f28c 	uxtb.w	r2, ip
 8002e06:	b112      	cbz	r2, 8002e0e <USBD_OTG_ISR_Handler+0x192>
      {
        CLEAR_IN_EP_INTR(epnum, intktxfemp);
 8002e08:	69b9      	ldr	r1, [r7, #24]
 8002e0a:	2510      	movs	r5, #16
 8002e0c:	608d      	str	r5, [r1, #8]
      }
      if (diepint.b.intknepmis)
 8002e0e:	f005 0920 	and.w	r9, r5, #32
 8002e12:	fa5f f089 	uxtb.w	r0, r9
 8002e16:	b110      	cbz	r0, 8002e1e <USBD_OTG_ISR_Handler+0x1a2>
      {
        CLEAR_IN_EP_INTR(epnum, intknepmis);
 8002e18:	69bb      	ldr	r3, [r7, #24]
 8002e1a:	2520      	movs	r5, #32
 8002e1c:	609d      	str	r5, [r3, #8]
      }
      if (diepint.b.inepnakeff)
 8002e1e:	f005 0c40 	and.w	ip, r5, #64	; 0x40
 8002e22:	fa5f f28c 	uxtb.w	r2, ip
 8002e26:	b112      	cbz	r2, 8002e2e <USBD_OTG_ISR_Handler+0x1b2>
      {
        CLEAR_IN_EP_INTR(epnum, inepnakeff);
 8002e28:	69b9      	ldr	r1, [r7, #24]
 8002e2a:	2540      	movs	r5, #64	; 0x40
 8002e2c:	608d      	str	r5, [r1, #8]
      }
      if ( diepint.b.epdisabled )
 8002e2e:	f005 0902 	and.w	r9, r5, #2
 8002e32:	fa5f f089 	uxtb.w	r0, r9
 8002e36:	b110      	cbz	r0, 8002e3e <USBD_OTG_ISR_Handler+0x1c2>
      {
        CLEAR_IN_EP_INTR(epnum, epdisabled);
 8002e38:	69bb      	ldr	r3, [r7, #24]
 8002e3a:	2502      	movs	r5, #2
 8002e3c:	609d      	str	r5, [r3, #8]
      }       
      if (diepint.b.emptyintr)
 8002e3e:	f005 0580 	and.w	r5, r5, #128	; 0x80
 8002e42:	b2ed      	uxtb	r5, r5
 8002e44:	2d00      	cmp	r5, #0
 8002e46:	d03c      	beq.n	8002ec2 <USBD_OTG_ISR_Handler+0x246>
  uint32_t len32b;
  txstatus.d32 = 0;
  
  ep = &pdev->dev.in_ep[epnum];    
  
  len = ep->xfer_len - ep->xfer_count;
 8002e48:	f8d4 112c 	ldr.w	r1, [r4, #300]	; 0x12c
 8002e4c:	f8d4 0130 	ldr.w	r0, [r4, #304]	; 0x130
  {
    len = ep->maxpacket;
  }
  
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 8002e50:	69bb      	ldr	r3, [r7, #24]
  if (len > ep->maxpacket)
  {
    len = ep->maxpacket;
  }
  
  len32b = (len + 3) / 4;
 8002e52:	f8d4 2120 	ldr.w	r2, [r4, #288]	; 0x120
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 8002e56:	f8d3 9018 	ldr.w	r9, [r3, #24]
  uint32_t len32b;
  txstatus.d32 = 0;
  
  ep = &pdev->dev.in_ep[epnum];    
  
  len = ep->xfer_len - ep->xfer_count;
 8002e5a:	1a0d      	subs	r5, r1, r0
  if (len > ep->maxpacket)
  {
    len = ep->maxpacket;
  }
  
  len32b = (len + 3) / 4;
 8002e5c:	4295      	cmp	r5, r2
 8002e5e:	bf34      	ite	cc
 8002e60:	46ac      	movcc	ip, r5
 8002e62:	4694      	movcs	ip, r2
 8002e64:	f10c 0c03 	add.w	ip, ip, #3
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002e68:	fa1f f989 	uxth.w	r9, r9
 8002e6c:	ebb9 0f9c 	cmp.w	r9, ip, lsr #2
 8002e70:	d925      	bls.n	8002ebe <USBD_OTG_ISR_Handler+0x242>
 8002e72:	4281      	cmp	r1, r0
 8002e74:	d923      	bls.n	8002ebe <USBD_OTG_ISR_Handler+0x242>
          ep->xfer_count < ep->xfer_len &&
 8002e76:	b311      	cbz	r1, 8002ebe <USBD_OTG_ISR_Handler+0x242>
 8002e78:	f8d4 1124 	ldr.w	r1, [r4, #292]	; 0x124
 8002e7c:	e006      	b.n	8002e8c <USBD_OTG_ISR_Handler+0x210>
 8002e7e:	f8d4 512c 	ldr.w	r5, [r4, #300]	; 0x12c
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002e82:	42aa      	cmp	r2, r5
 8002e84:	d21b      	bcs.n	8002ebe <USBD_OTG_ISR_Handler+0x242>
 8002e86:	1aad      	subs	r5, r5, r2
 8002e88:	f8d4 2120 	ldr.w	r2, [r4, #288]	; 0x120
          ep->xfer_count < ep->xfer_len &&
            ep->xfer_len != 0)
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 8002e8c:	4295      	cmp	r5, r2
 8002e8e:	bf28      	it	cs
 8002e90:	4615      	movcs	r5, r2
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3) / 4;
    
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
 8002e92:	b2ab      	uxth	r3, r5
 8002e94:	4632      	mov	r2, r6
 8002e96:	4640      	mov	r0, r8
 8002e98:	f7fe ff16 	bl	8001cc8 <USB_OTG_WritePacket>
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
 8002e9c:	f8d4 2130 	ldr.w	r2, [r4, #304]	; 0x130
    
    txstatus.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 8002ea0:	69bb      	ldr	r3, [r7, #24]
    }
    len32b = (len + 3) / 4;
    
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
    
    ep->xfer_buff  += len;
 8002ea2:	f8d4 1124 	ldr.w	r1, [r4, #292]	; 0x124
    ep->xfer_count += len;
 8002ea6:	18aa      	adds	r2, r5, r2
 8002ea8:	f8c4 2130 	str.w	r2, [r4, #304]	; 0x130
    
    txstatus.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 8002eac:	6998      	ldr	r0, [r3, #24]
    }
    len32b = (len + 3) / 4;
    
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
    
    ep->xfer_buff  += len;
 8002eae:	1949      	adds	r1, r1, r5
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002eb0:	b280      	uxth	r0, r0
    
    if (len > ep->maxpacket)
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3) / 4;
 8002eb2:	3503      	adds	r5, #3
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002eb4:	ebb0 0f95 	cmp.w	r0, r5, lsr #2
    }
    len32b = (len + 3) / 4;
    
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
    
    ep->xfer_buff  += len;
 8002eb8:	f8c4 1124 	str.w	r1, [r4, #292]	; 0x124
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002ebc:	d8df      	bhi.n	8002e7e <USBD_OTG_ISR_Handler+0x202>
      if (diepint.b.emptyintr)
      {
        
        DCD_WriteEmptyTxFifo(pdev , epnum);
        
        CLEAR_IN_EP_INTR(epnum, emptyintr);
 8002ebe:	2680      	movs	r6, #128	; 0x80
 8002ec0:	609e      	str	r6, [r3, #8]
      }
    }
    epnum++;
    ep_intr >>= 1;
 8002ec2:	3428      	adds	r4, #40	; 0x28
 8002ec4:	3704      	adds	r7, #4
  uint32_t epnum = 0;
  uint32_t fifoemptymsk;
  diepint.d32 = 0;
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
  
  while ( ep_intr )
 8002ec6:	ea5f 0a5a 	movs.w	sl, sl, lsr #1
 8002eca:	d002      	beq.n	8002ed2 <USBD_OTG_ISR_Handler+0x256>
        DCD_WriteEmptyTxFifo(pdev , epnum);
        
        CLEAR_IN_EP_INTR(epnum, emptyintr);
      }
    }
    epnum++;
 8002ecc:	f10b 0b01 	add.w	fp, fp, #1
 8002ed0:	e769      	b.n	8002da6 <USBD_OTG_ISR_Handler+0x12a>
 8002ed2:	f8dd 9004 	ldr.w	r9, [sp, #4]
 8002ed6:	4646      	mov	r6, r8
      retval |= DCD_HandleOutEP_ISR(pdev);
    }    
    
    if (gintr_status.b.inepint)
    {
      retval |= DCD_HandleInEP_ISR(pdev);
 8002ed8:	2001      	movs	r0, #1
 8002eda:	e6ef      	b.n	8002cbc <USBD_OTG_ISR_Handler+0x40>
  uint32_t epnum = 0;
  
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
 8002edc:	4630      	mov	r0, r6
 8002ede:	f7ff fbff 	bl	80026e0 <USB_OTG_ReadDevAllOutEp_itr>
  
  while ( ep_intr )
 8002ee2:	4604      	mov	r4, r0
 8002ee4:	2800      	cmp	r0, #0
 8002ee6:	d04d      	beq.n	8002f84 <USBD_OTG_ISR_Handler+0x308>
      if ( doepint.b.setup )
      {
        
        /* inform the upper layer that a setup packet is available */
        /* SETUP COMPLETE */
        USBD_DCD_INT_fops->SetupStage(pdev);
 8002ee8:	f8df b09c 	ldr.w	fp, [pc, #156]	; 8002f88 <USBD_OTG_ISR_Handler+0x30c>
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
  
  while ( ep_intr )
 8002eec:	4635      	mov	r5, r6
 8002eee:	46b0      	mov	r8, r6
static uint32_t DCD_HandleOutEP_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t ep_intr;
  USB_OTG_DOEPINTn_TypeDef  doepint;
  USB_OTG_DEPXFRSIZ_TypeDef  deptsiz;
  uint32_t epnum = 0;
 8002ef0:	2700      	movs	r7, #0
        CLEAR_OUT_EP_INTR(epnum, epdisabled);
      }
      /* AHB Error */
      if ( doepint.b.ahberr )
      {
        CLEAR_OUT_EP_INTR(epnum, ahberr);
 8002ef2:	46ca      	mov	sl, r9
 8002ef4:	e005      	b.n	8002f02 <USBD_OTG_ISR_Handler+0x286>
        USBD_DCD_INT_fops->SetupStage(pdev);
        CLEAR_OUT_EP_INTR(epnum, setup);
      }
    }
    epnum++;
    ep_intr >>= 1;
 8002ef6:	3504      	adds	r5, #4
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
  
  while ( ep_intr )
 8002ef8:	0864      	lsrs	r4, r4, #1
        USBD_DCD_INT_fops->SetupStage(pdev);
        CLEAR_OUT_EP_INTR(epnum, setup);
      }
    }
    epnum++;
    ep_intr >>= 1;
 8002efa:	f108 0828 	add.w	r8, r8, #40	; 0x28
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
  
  while ( ep_intr )
 8002efe:	d040      	beq.n	8002f82 <USBD_OTG_ISR_Handler+0x306>
        /* SETUP COMPLETE */
        USBD_DCD_INT_fops->SetupStage(pdev);
        CLEAR_OUT_EP_INTR(epnum, setup);
      }
    }
    epnum++;
 8002f00:	3701      	adds	r7, #1
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
  
  while ( ep_intr )
  {
    if (ep_intr&0x1)
 8002f02:	f014 0f01 	tst.w	r4, #1
 8002f06:	d0f6      	beq.n	8002ef6 <USBD_OTG_ISR_Handler+0x27a>
 8002f08:	fa5f f987 	uxtb.w	r9, r7
    {
      
      doepint.d32 = USB_OTG_ReadDevOutEP_itr(pdev, epnum);
 8002f0c:	4630      	mov	r0, r6
 8002f0e:	4649      	mov	r1, r9
 8002f10:	f7ff fbee 	bl	80026f0 <USB_OTG_ReadDevOutEP_itr>
      
      /* Transfer complete */
      if ( doepint.b.xfercompl )
 8002f14:	b2c0      	uxtb	r0, r0
 8002f16:	f010 0f01 	tst.w	r0, #1
 8002f1a:	d013      	beq.n	8002f44 <USBD_OTG_ISR_Handler+0x2c8>
      {
        /* Clear the bit in DOEPINTn for this interrupt */
        CLEAR_OUT_EP_INTR(epnum, xfercompl);
 8002f1c:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8002f1e:	2001      	movs	r0, #1
 8002f20:	6098      	str	r0, [r3, #8]
        if (pdev->cfg.dma_enable == 1)
 8002f22:	78f2      	ldrb	r2, [r6, #3]
 8002f24:	2a01      	cmp	r2, #1
 8002f26:	f000 8142 	beq.w	80031ae <USBD_OTG_ISR_Handler+0x532>
          pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
            deptsiz.b.xfersize;
        }
        /* Inform upper layer: data ready */
        /* RX COMPLETE */
        USBD_DCD_INT_fops->DataOutStage(pdev , epnum);
 8002f2a:	f8db 1000 	ldr.w	r1, [fp]
 8002f2e:	4630      	mov	r0, r6
 8002f30:	680b      	ldr	r3, [r1, #0]
 8002f32:	4649      	mov	r1, r9
 8002f34:	4798      	blx	r3
        
        if (pdev->cfg.dma_enable == 1)
 8002f36:	f896 9003 	ldrb.w	r9, [r6, #3]
 8002f3a:	f1b9 0f01 	cmp.w	r9, #1
 8002f3e:	f000 8129 	beq.w	8003194 <USBD_OTG_ISR_Handler+0x518>
 8002f42:	2001      	movs	r0, #1
            USB_OTG_EP0_OutStart(pdev);
          }
        }        
      }
      /* Endpoint disable  */
      if ( doepint.b.epdisabled )
 8002f44:	f000 0902 	and.w	r9, r0, #2
 8002f48:	fa5f f289 	uxtb.w	r2, r9
 8002f4c:	b112      	cbz	r2, 8002f54 <USBD_OTG_ISR_Handler+0x2d8>
      {
        /* Clear the bit in DOEPINTn for this interrupt */
        CLEAR_OUT_EP_INTR(epnum, epdisabled);
 8002f4e:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8002f50:	2002      	movs	r0, #2
 8002f52:	6098      	str	r0, [r3, #8]
      }
      /* AHB Error */
      if ( doepint.b.ahberr )
 8002f54:	f000 0c04 	and.w	ip, r0, #4
 8002f58:	fa5f f18c 	uxtb.w	r1, ip
 8002f5c:	b111      	cbz	r1, 8002f64 <USBD_OTG_ISR_Handler+0x2e8>
      {
        CLEAR_OUT_EP_INTR(epnum, ahberr);
 8002f5e:	6d6a      	ldr	r2, [r5, #84]	; 0x54
 8002f60:	2004      	movs	r0, #4
 8002f62:	6090      	str	r0, [r2, #8]
      }
      /* Setup Phase Done (control EPs) */
      if ( doepint.b.setup )
 8002f64:	f000 0e08 	and.w	lr, r0, #8
 8002f68:	fa5f f08e 	uxtb.w	r0, lr
 8002f6c:	2800      	cmp	r0, #0
 8002f6e:	d0c2      	beq.n	8002ef6 <USBD_OTG_ISR_Handler+0x27a>
      {
        
        /* inform the upper layer that a setup packet is available */
        /* SETUP COMPLETE */
        USBD_DCD_INT_fops->SetupStage(pdev);
 8002f70:	f8db 1000 	ldr.w	r1, [fp]
 8002f74:	4630      	mov	r0, r6
 8002f76:	688a      	ldr	r2, [r1, #8]
 8002f78:	4790      	blx	r2
        CLEAR_OUT_EP_INTR(epnum, setup);
 8002f7a:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8002f7c:	2108      	movs	r1, #8
 8002f7e:	6099      	str	r1, [r3, #8]
 8002f80:	e7b9      	b.n	8002ef6 <USBD_OTG_ISR_Handler+0x27a>
 8002f82:	46d1      	mov	r9, sl
      return 0;
    }
    
    if (gintr_status.b.outepintr)
    {
      retval |= DCD_HandleOutEP_ISR(pdev);
 8002f84:	2001      	movs	r0, #1
 8002f86:	e691      	b.n	8002cac <USBD_OTG_ISR_Handler+0x30>
 8002f88:	20000130 	.word	0x20000130
{
  USB_OTG_GINTSTS_TypeDef gintsts;  
  
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoINIncomplete (pdev); 
 8002f8c:	488d      	ldr	r0, [pc, #564]	; (80031c4 <USBD_OTG_ISR_Handler+0x548>)
 8002f8e:	6802      	ldr	r2, [r0, #0]
 8002f90:	4630      	mov	r0, r6
 8002f92:	69d1      	ldr	r1, [r2, #28]
 8002f94:	4788      	blx	r1
  
  /* Clear interrupt */
  gintsts.b.incomplisoin = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002f96:	68f3      	ldr	r3, [r6, #12]
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoINIncomplete (pdev); 
  
  /* Clear interrupt */
  gintsts.b.incomplisoin = 1;
 8002f98:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002f9c:	6158      	str	r0, [r3, #20]
      retval |= DCD_HandleEnumDone_ISR(pdev);
    }
    
    if (gintr_status.b.incomplisoin)
    {
      retval |= DCD_IsoINIncomplete_ISR(pdev);
 8002f9e:	2001      	movs	r0, #1
 8002fa0:	e6e0      	b.n	8002d64 <USBD_OTG_ISR_Handler+0xe8>
static uint32_t DCD_HandleEnumDone_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_GINTSTS_TypeDef  gintsts;
  USB_OTG_GUSBCFG_TypeDef  gusbcfg;
  
  USB_OTG_EP0Activate(pdev);
 8002fa2:	4630      	mov	r0, r6
 8002fa4:	f7ff f996 	bl	80022d4 <USB_OTG_EP0Activate>
  
  /* Set USB turn-around time based on device speed and PHY interface. */
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8002fa8:	68f4      	ldr	r4, [r6, #12]
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
 8002faa:	4630      	mov	r0, r6
  USB_OTG_GUSBCFG_TypeDef  gusbcfg;
  
  USB_OTG_EP0Activate(pdev);
  
  /* Set USB turn-around time based on device speed and PHY interface. */
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8002fac:	68e4      	ldr	r4, [r4, #12]
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
 8002fae:	f7ff f981 	bl	80022b4 <USB_OTG_GetDeviceSpeed>
 8002fb2:	2803      	cmp	r0, #3
 8002fb4:	f000 80c1 	beq.w	800313a <USBD_OTG_ISR_Handler+0x4be>
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
    gusbcfg.b.usbtrdtim = 9;
  }
  else
  {
    pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8002fb8:	2001      	movs	r0, #1
    pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;  
 8002fba:	2140      	movs	r1, #64	; 0x40
    gusbcfg.b.usbtrdtim = 5;
 8002fbc:	2305      	movs	r3, #5
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
    gusbcfg.b.usbtrdtim = 9;
  }
  else
  {
    pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8002fbe:	70b0      	strb	r0, [r6, #2]
    pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;  
 8002fc0:	80b1      	strh	r1, [r6, #4]
    gusbcfg.b.usbtrdtim = 5;
 8002fc2:	f363 248d 	bfi	r4, r3, #10, #4
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
 8002fc6:	68f3      	ldr	r3, [r6, #12]
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.enumdone = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, gintsts.d32 );
 8002fc8:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    pdev->cfg.speed            = USB_OTG_SPEED_FULL;
    pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;  
    gusbcfg.b.usbtrdtim = 5;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
 8002fcc:	60dc      	str	r4, [r3, #12]
      retval |= DCD_HandleUsbReset_ISR(pdev);
      
    }
    if (gintr_status.b.enumdone)
    {
      retval |= DCD_HandleEnumDone_ISR(pdev);
 8002fce:	2001      	movs	r0, #1
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.enumdone = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, gintsts.d32 );
 8002fd0:	615a      	str	r2, [r3, #20]
 8002fd2:	e6be      	b.n	8002d52 <USBD_OTG_ISR_Handler+0xd6>
  dcfg.d32 = 0;
  gintsts.d32 = 0;
  
  /* Clear the Remote Wake-up Signaling */
  dctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
 8002fd4:	6930      	ldr	r0, [r6, #16]
 8002fd6:	6843      	ldr	r3, [r0, #4]
  USB_OTG_DCFG_TypeDef     dcfg;
  USB_OTG_DCTL_TypeDef     dctl;
  USB_OTG_GINTSTS_TypeDef  gintsts;
  uint32_t i;
  
  dctl.d32 = 0;
 8002fd8:	2400      	movs	r4, #0
  dcfg.d32 = 0;
  gintsts.d32 = 0;
  
  /* Clear the Remote Wake-up Signaling */
  dctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
 8002fda:	f023 0201 	bic.w	r2, r3, #1
 8002fde:	6042      	str	r2, [r0, #4]
  
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
 8002fe0:	4621      	mov	r1, r4
 8002fe2:	4630      	mov	r0, r6
 8002fe4:	f7ff f832 	bl	800204c <USB_OTG_FlushTxFifo>
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002fe8:	7875      	ldrb	r5, [r6, #1]
 8002fea:	b16d      	cbz	r5, 8003008 <USBD_OTG_ISR_Handler+0x38c>
* @brief  STM32_USBF_OTG_ISR_Handler
*         handles all USB Interrupts
* @param  pdev: device instance
* @retval status
*/
uint32_t USBD_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
 8002fec:	f106 0214 	add.w	r2, r6, #20
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
  
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002ff0:	4623      	mov	r3, r4
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 8002ff2:	21ff      	movs	r1, #255	; 0xff
 8002ff4:	f852 5f04 	ldr.w	r5, [r2, #4]!
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 8002ff8:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 8002ffa:	60a9      	str	r1, [r5, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 8002ffc:	6081      	str	r1, [r0, #8]
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
  
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002ffe:	f896 e001 	ldrb.w	lr, [r6, #1]
 8003002:	3301      	adds	r3, #1
 8003004:	4573      	cmp	r3, lr
 8003006:	d3f5      	bcc.n	8002ff4 <USBD_OTG_ISR_Handler+0x378>
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
  
  daintmsk.ep.in = 1;
 8003008:	2501      	movs	r5, #1
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 800300a:	6933      	ldr	r3, [r6, #16]
  
  daintmsk.ep.in = 1;
 800300c:	f365 040f 	bfi	r4, r5, #0, #16
  
  doepmsk.b.setup = 1;
  doepmsk.b.xfercompl = 1;
  doepmsk.b.ahberr = 1;
  doepmsk.b.epdisabled = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, doepmsk.d32 );
 8003010:	210f      	movs	r1, #15
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8003012:	f04f 32ff 	mov.w	r2, #4294967295
  diepmsk.b.xfercompl = 1;
  diepmsk.b.timeout = 1;
  diepmsk.b.epdisabled = 1;
  diepmsk.b.ahberr = 1;
  diepmsk.b.intknepmis = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, diepmsk.d32 );
 8003016:	202f      	movs	r0, #47	; 0x2f
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
  
  daintmsk.ep.in = 1;
  daintmsk.ep.out = 1;
 8003018:	f365 441f 	bfi	r4, r5, #16, #16
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 800301c:	619a      	str	r2, [r3, #24]
  
  daintmsk.ep.in = 1;
  daintmsk.ep.out = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, daintmsk.d32 );
 800301e:	61dc      	str	r4, [r3, #28]
  
  doepmsk.b.setup = 1;
  doepmsk.b.xfercompl = 1;
  doepmsk.b.ahberr = 1;
  doepmsk.b.epdisabled = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, doepmsk.d32 );
 8003020:	6159      	str	r1, [r3, #20]
  diepmsk.b.xfercompl = 1;
  diepmsk.b.timeout = 1;
  diepmsk.b.epdisabled = 1;
  diepmsk.b.ahberr = 1;
  diepmsk.b.intknepmis = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, diepmsk.d32 );
 8003022:	6118      	str	r0, [r3, #16]
#ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED  
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DINEP1MSK, diepmsk.d32 );
#endif
  /* Reset Device Address */
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
 8003024:	681a      	ldr	r2, [r3, #0]
  dcfg.b.devaddr = 0;
 8003026:	f36f 120a 	bfc	r2, #4, #7
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32);
 800302a:	601a      	str	r2, [r3, #0]
  
  
  /* setup EP0 to receive SETUP packets */
  USB_OTG_EP0_OutStart(pdev);
 800302c:	4630      	mov	r0, r6
 800302e:	f7ff fb71 	bl	8002714 <USB_OTG_EP0_OutStart>
  gintsts.d32 = 0;
  gintsts.b.usbreset = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
  
  /*Reset internal state machine */
  USBD_DCD_INT_fops->Reset(pdev);
 8003032:	4964      	ldr	r1, [pc, #400]	; (80031c4 <USBD_OTG_ISR_Handler+0x548>)
  USB_OTG_EP0_OutStart(pdev);
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbreset = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8003034:	68f2      	ldr	r2, [r6, #12]
  
  /*Reset internal state machine */
  USBD_DCD_INT_fops->Reset(pdev);
 8003036:	680b      	ldr	r3, [r1, #0]
  /* setup EP0 to receive SETUP packets */
  USB_OTG_EP0_OutStart(pdev);
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbreset = 1;
 8003038:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 800303c:	6150      	str	r0, [r2, #20]
  
  /*Reset internal state machine */
  USBD_DCD_INT_fops->Reset(pdev);
 800303e:	6919      	ldr	r1, [r3, #16]
 8003040:	4630      	mov	r0, r6
 8003042:	4788      	blx	r1
      
    }
    
    if (gintr_status.b.usbreset)
    {
      retval |= DCD_HandleUsbReset_ISR(pdev);
 8003044:	4628      	mov	r0, r5
 8003046:	e67b      	b.n	8002d40 <USBD_OTG_ISR_Handler+0xc4>
  USB_OTG_EP *ep;
  
  /* Disable the Rx Status Queue Level interrupt */
  int_mask.d32 = 0;
  int_mask.b.rxstsqlvl = 1;
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32, 0);
 8003048:	68f3      	ldr	r3, [r6, #12]
 800304a:	699d      	ldr	r5, [r3, #24]
 800304c:	f025 0410 	bic.w	r4, r5, #16
 8003050:	619c      	str	r4, [r3, #24]
  
  /* Get the Status from the top of the FIFO */
  status.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRXSTSP );
 8003052:	6a1c      	ldr	r4, [r3, #32]
  
  ep = &pdev->dev.out_ep[status.b.epnum];
  
  switch (status.b.pktsts)
 8003054:	f3c4 4243 	ubfx	r2, r4, #17, #4
 8003058:	2a02      	cmp	r2, #2
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32, 0);
  
  /* Get the Status from the top of the FIFO */
  status.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRXSTSP );
  
  ep = &pdev->dev.out_ep[status.b.epnum];
 800305a:	f004 050f 	and.w	r5, r4, #15
  
  switch (status.b.pktsts)
 800305e:	d04e      	beq.n	80030fe <USBD_OTG_ISR_Handler+0x482>
 8003060:	2a06      	cmp	r2, #6
 8003062:	d111      	bne.n	8003088 <USBD_OTG_ISR_Handler+0x40c>
    break;
  case STS_SETUP_COMP:
    break;
  case STS_SETUP_UPDT:
    /* Copy the setup packet received in FIFO into the setup buffer in RAM */
    USB_OTG_ReadPacket(pdev , pdev->dev.setup_packet, 8);
 8003064:	f506 61b9 	add.w	r1, r6, #1480	; 0x5c8
 8003068:	4630      	mov	r0, r6
 800306a:	2208      	movs	r2, #8
    ep->xfer_count += status.b.bcnt;
 800306c:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    break;
  case STS_SETUP_COMP:
    break;
  case STS_SETUP_UPDT:
    /* Copy the setup packet received in FIFO into the setup buffer in RAM */
    USB_OTG_ReadPacket(pdev , pdev->dev.setup_packet, 8);
 8003070:	f7fe fe52 	bl	8001d18 <USB_OTG_ReadPacket>
    ep->xfer_count += status.b.bcnt;
 8003074:	eb06 0cc5 	add.w	ip, r6, r5, lsl #3
 8003078:	f3c4 140a 	ubfx	r4, r4, #4, #11
 800307c:	f8dc 1388 	ldr.w	r1, [ip, #904]	; 0x388
 8003080:	68f3      	ldr	r3, [r6, #12]
 8003082:	1860      	adds	r0, r4, r1
 8003084:	f8cc 0388 	str.w	r0, [ip, #904]	; 0x388
  default:
    break;
  }
  
  /* Enable the Rx Status Queue Level interrupt */
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, int_mask.d32);
 8003088:	6998      	ldr	r0, [r3, #24]
 800308a:	f040 0210 	orr.w	r2, r0, #16
 800308e:	619a      	str	r2, [r3, #24]
      
    }
    
    if (gintr_status.b.rxstsqlvl)
    {
      retval |= DCD_HandleRxStatusQueueLevel_ISR(pdev);
 8003090:	2001      	movs	r0, #1
 8003092:	e64c      	b.n	8002d2e <USBD_OTG_ISR_Handler+0xb2>
static uint32_t DCD_HandleSof_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_GINTSTS_TypeDef  GINTSTS;
  
  
  USBD_DCD_INT_fops->SOF(pdev);
 8003094:	484b      	ldr	r0, [pc, #300]	; (80031c4 <USBD_OTG_ISR_Handler+0x548>)
 8003096:	6802      	ldr	r2, [r0, #0]
 8003098:	4630      	mov	r0, r6
 800309a:	68d1      	ldr	r1, [r2, #12]
 800309c:	4788      	blx	r1
  
  /* Clear interrupt */
  GINTSTS.d32 = 0;
  GINTSTS.b.sofintr = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, GINTSTS.d32);
 800309e:	68f3      	ldr	r3, [r6, #12]
  
  USBD_DCD_INT_fops->SOF(pdev);
  
  /* Clear interrupt */
  GINTSTS.d32 = 0;
  GINTSTS.b.sofintr = 1;
 80030a0:	2008      	movs	r0, #8
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, GINTSTS.d32);
 80030a2:	6158      	str	r0, [r3, #20]
    {
      retval |= DCD_HandleUSBSuspend_ISR(pdev);
    }
    if (gintr_status.b.sofintr)
    {
      retval |= DCD_HandleSof_ISR(pdev);
 80030a4:	2001      	movs	r0, #1
 80030a6:	e63b      	b.n	8002d20 <USBD_OTG_ISR_Handler+0xa4>
{
  USB_OTG_GINTSTS_TypeDef  gintsts;
  USB_OTG_PCGCCTL_TypeDef  power;
  USB_OTG_DSTS_TypeDef     dsts;
  
  USBD_DCD_INT_fops->Suspend (pdev);      
 80030a8:	4846      	ldr	r0, [pc, #280]	; (80031c4 <USBD_OTG_ISR_Handler+0x548>)
 80030aa:	6803      	ldr	r3, [r0, #0]
 80030ac:	4630      	mov	r0, r6
 80030ae:	695a      	ldr	r2, [r3, #20]
 80030b0:	4790      	blx	r2
  
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 80030b2:	6931      	ldr	r1, [r6, #16]
    
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbsuspend = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 80030b4:	68f3      	ldr	r3, [r6, #12]
  USB_OTG_PCGCCTL_TypeDef  power;
  USB_OTG_DSTS_TypeDef     dsts;
  
  USBD_DCD_INT_fops->Suspend (pdev);      
  
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 80030b6:	6889      	ldr	r1, [r1, #8]
    
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbsuspend = 1;
 80030b8:	f44f 6200 	mov.w	r2, #2048	; 0x800
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 80030bc:	615a      	str	r2, [r3, #20]
  
  if((pdev->cfg.low_power) && (dsts.b.suspsts == 1))
 80030be:	7ab0      	ldrb	r0, [r6, #10]
 80030c0:	b188      	cbz	r0, 80030e6 <USBD_OTG_ISR_Handler+0x46a>
 80030c2:	f011 0f01 	tst.w	r1, #1
 80030c6:	d00e      	beq.n	80030e6 <USBD_OTG_ISR_Handler+0x46a>
  {
	/*  switch-off the clocks */
    power.d32 = 0;
    power.b.stoppclk = 1;
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);  
 80030c8:	f8d6 310c 	ldr.w	r3, [r6, #268]	; 0x10c
    
    power.b.gatehclk = 1;
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);
    
    /* Request to enter Sleep mode after exit from current ISR */
    SCB->SCR |= (SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk);
 80030cc:	4a3e      	ldr	r2, [pc, #248]	; (80031c8 <USBD_OTG_ISR_Handler+0x54c>)
  if((pdev->cfg.low_power) && (dsts.b.suspsts == 1))
  {
	/*  switch-off the clocks */
    power.d32 = 0;
    power.b.stoppclk = 1;
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);  
 80030ce:	6819      	ldr	r1, [r3, #0]
 80030d0:	f041 0001 	orr.w	r0, r1, #1
 80030d4:	6018      	str	r0, [r3, #0]
    
    power.b.gatehclk = 1;
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);
 80030d6:	6819      	ldr	r1, [r3, #0]
 80030d8:	f041 0003 	orr.w	r0, r1, #3
 80030dc:	6018      	str	r0, [r3, #0]
    
    /* Request to enter Sleep mode after exit from current ISR */
    SCB->SCR |= (SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk);
 80030de:	6913      	ldr	r3, [r2, #16]
 80030e0:	f043 0106 	orr.w	r1, r3, #6
 80030e4:	6111      	str	r1, [r2, #16]
      retval |= DCD_HandleResume_ISR(pdev);
    }
    
    if (gintr_status.b.usbsuspend)
    {
      retval |= DCD_HandleUSBSuspend_ISR(pdev);
 80030e6:	2001      	movs	r0, #1
 80030e8:	e613      	b.n	8002d12 <USBD_OTG_ISR_Handler+0x96>
  USB_OTG_PCGCCTL_TypeDef  power;
  
  if(pdev->cfg.low_power)
  {
    /* un-gate USB Core clock */
    power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
 80030ea:	f8d6 310c 	ldr.w	r3, [r6, #268]	; 0x10c
    power.b.gatehclk = 0;
    power.b.stoppclk = 0;
    USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 80030ee:	f8d6 210c 	ldr.w	r2, [r6, #268]	; 0x10c
  
  if(pdev->cfg.low_power)
  {
    /* un-gate USB Core clock */
    power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
    power.b.gatehclk = 0;
 80030f2:	f36f 0341 	bfc	r3, #1, #1
    power.b.stoppclk = 0;
 80030f6:	f36f 0300 	bfc	r3, #0, #1
    USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 80030fa:	6013      	str	r3, [r2, #0]
 80030fc:	e5f1      	b.n	8002ce2 <USBD_OTG_ISR_Handler+0x66>
  switch (status.b.pktsts)
  {
  case STS_GOUT_NAK:
    break;
  case STS_DATA_UPDT:
    if (status.b.bcnt)
 80030fe:	f647 72f0 	movw	r2, #32752	; 0x7ff0
 8003102:	ea04 0102 	and.w	r1, r4, r2
 8003106:	2900      	cmp	r1, #0
 8003108:	d0be      	beq.n	8003088 <USBD_OTG_ISR_Handler+0x40c>
    {
      USB_OTG_ReadPacket(pdev,ep->xfer_buff, status.b.bcnt);
 800310a:	eb05 0e85 	add.w	lr, r5, r5, lsl #2
 800310e:	eb06 05ce 	add.w	r5, r6, lr, lsl #3
 8003112:	f3c4 140a 	ubfx	r4, r4, #4, #11
 8003116:	4622      	mov	r2, r4
 8003118:	f8d5 137c 	ldr.w	r1, [r5, #892]	; 0x37c
 800311c:	4630      	mov	r0, r6
 800311e:	f7fe fdfb 	bl	8001d18 <USB_OTG_ReadPacket>
      ep->xfer_buff += status.b.bcnt;
 8003122:	f8d5 237c 	ldr.w	r2, [r5, #892]	; 0x37c
      ep->xfer_count += status.b.bcnt;
 8003126:	f8d5 1388 	ldr.w	r1, [r5, #904]	; 0x388
 800312a:	68f3      	ldr	r3, [r6, #12]
    break;
  case STS_DATA_UPDT:
    if (status.b.bcnt)
    {
      USB_OTG_ReadPacket(pdev,ep->xfer_buff, status.b.bcnt);
      ep->xfer_buff += status.b.bcnt;
 800312c:	1910      	adds	r0, r2, r4
      ep->xfer_count += status.b.bcnt;
 800312e:	1864      	adds	r4, r4, r1
    break;
  case STS_DATA_UPDT:
    if (status.b.bcnt)
    {
      USB_OTG_ReadPacket(pdev,ep->xfer_buff, status.b.bcnt);
      ep->xfer_buff += status.b.bcnt;
 8003130:	f8c5 037c 	str.w	r0, [r5, #892]	; 0x37c
      ep->xfer_count += status.b.bcnt;
 8003134:	f8c5 4388 	str.w	r4, [r5, #904]	; 0x388
 8003138:	e7a6      	b.n	8003088 <USBD_OTG_ISR_Handler+0x40c>
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
  {
    pdev->cfg.speed            = USB_OTG_SPEED_HIGH;
 800313a:	2200      	movs	r2, #0
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
 800313c:	f44f 7e00 	mov.w	lr, #512	; 0x200
    gusbcfg.b.usbtrdtim = 9;
 8003140:	2009      	movs	r0, #9
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
  {
    pdev->cfg.speed            = USB_OTG_SPEED_HIGH;
 8003142:	70b2      	strb	r2, [r6, #2]
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
 8003144:	f8a6 e004 	strh.w	lr, [r6, #4]
    gusbcfg.b.usbtrdtim = 9;
 8003148:	f360 248d 	bfi	r4, r0, #10, #4
 800314c:	e73b      	b.n	8002fc6 <USBD_OTG_ISR_Handler+0x34a>
      {
        fifoemptymsk = 0x1 << epnum;
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
        CLEAR_IN_EP_INTR(epnum, xfercompl);
        /* TX COMPLETE */
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 800314e:	4d1d      	ldr	r5, [pc, #116]	; (80031c4 <USBD_OTG_ISR_Handler+0x548>)
    {
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
      {
        fifoemptymsk = 0x1 << epnum;
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
 8003150:	6b58      	ldr	r0, [r3, #52]	; 0x34
        CLEAR_IN_EP_INTR(epnum, xfercompl);
        /* TX COMPLETE */
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 8003152:	6829      	ldr	r1, [r5, #0]
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
      {
        fifoemptymsk = 0x1 << epnum;
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
        CLEAR_IN_EP_INTR(epnum, xfercompl);
 8003154:	69ba      	ldr	r2, [r7, #24]
    if (ep_intr&0x1) /* In ITR */
    {
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
      {
        fifoemptymsk = 0x1 << epnum;
 8003156:	2501      	movs	r5, #1
 8003158:	fa05 fe0b 	lsl.w	lr, r5, fp
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
 800315c:	ea20 000e 	bic.w	r0, r0, lr
 8003160:	6358      	str	r0, [r3, #52]	; 0x34
        CLEAR_IN_EP_INTR(epnum, xfercompl);
        /* TX COMPLETE */
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 8003162:	684b      	ldr	r3, [r1, #4]
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
      {
        fifoemptymsk = 0x1 << epnum;
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
        CLEAR_IN_EP_INTR(epnum, xfercompl);
 8003164:	6095      	str	r5, [r2, #8]
        /* TX COMPLETE */
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 8003166:	4640      	mov	r0, r8
 8003168:	4631      	mov	r1, r6
 800316a:	4798      	blx	r3
        
        if (pdev->cfg.dma_enable == 1)
 800316c:	f898 9003 	ldrb.w	r9, [r8, #3]
 8003170:	45a9      	cmp	r9, r5
 8003172:	f47f ae35 	bne.w	8002de0 <USBD_OTG_ISR_Handler+0x164>
        {
          if((epnum == 0) && (pdev->dev.device_state == USB_OTG_EP0_STATUS_IN))
 8003176:	f1bb 0f00 	cmp.w	fp, #0
 800317a:	d104      	bne.n	8003186 <USBD_OTG_ISR_Handler+0x50a>
 800317c:	f898 c111 	ldrb.w	ip, [r8, #273]	; 0x111
 8003180:	f1bc 0f04 	cmp.w	ip, #4
 8003184:	d001      	beq.n	800318a <USBD_OTG_ISR_Handler+0x50e>
          {
            /* prepare to rx more setup packets */
            USB_OTG_EP0_OutStart(pdev);
 8003186:	464d      	mov	r5, r9
 8003188:	e62a      	b.n	8002de0 <USBD_OTG_ISR_Handler+0x164>
 800318a:	4640      	mov	r0, r8
 800318c:	f7ff fac2 	bl	8002714 <USB_OTG_EP0_OutStart>
 8003190:	464d      	mov	r5, r9
 8003192:	e625      	b.n	8002de0 <USBD_OTG_ISR_Handler+0x164>
        /* RX COMPLETE */
        USBD_DCD_INT_fops->DataOutStage(pdev , epnum);
        
        if (pdev->cfg.dma_enable == 1)
        {
          if((epnum == 0) && (pdev->dev.device_state == USB_OTG_EP0_STATUS_OUT))
 8003194:	b927      	cbnz	r7, 80031a0 <USBD_OTG_ISR_Handler+0x524>
 8003196:	f896 e111 	ldrb.w	lr, [r6, #273]	; 0x111
 800319a:	f1be 0f05 	cmp.w	lr, #5
 800319e:	d001      	beq.n	80031a4 <USBD_OTG_ISR_Handler+0x528>
          {
            /* prepare to rx more setup packets */
            USB_OTG_EP0_OutStart(pdev);
 80031a0:	4648      	mov	r0, r9
 80031a2:	e6cf      	b.n	8002f44 <USBD_OTG_ISR_Handler+0x2c8>
 80031a4:	4630      	mov	r0, r6
 80031a6:	f7ff fab5 	bl	8002714 <USB_OTG_EP0_OutStart>
 80031aa:	4648      	mov	r0, r9
 80031ac:	e6ca      	b.n	8002f44 <USBD_OTG_ISR_Handler+0x2c8>
      {
        /* Clear the bit in DOEPINTn for this interrupt */
        CLEAR_OUT_EP_INTR(epnum, xfercompl);
        if (pdev->cfg.dma_enable == 1)
        {
          deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[epnum]->DOEPTSIZ));
 80031ae:	691a      	ldr	r2, [r3, #16]
          /*ToDo : handle more than one single MPS size packet */
          pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
 80031b0:	f8d8 1378 	ldr.w	r1, [r8, #888]	; 0x378
            deptsiz.b.xfersize;
 80031b4:	f3c2 0c12 	ubfx	ip, r2, #0, #19
        CLEAR_OUT_EP_INTR(epnum, xfercompl);
        if (pdev->cfg.dma_enable == 1)
        {
          deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[epnum]->DOEPTSIZ));
          /*ToDo : handle more than one single MPS size packet */
          pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
 80031b8:	ebcc 0301 	rsb	r3, ip, r1
 80031bc:	f8c8 3388 	str.w	r3, [r8, #904]	; 0x388
 80031c0:	e6b3      	b.n	8002f2a <USBD_OTG_ISR_Handler+0x2ae>
 80031c2:	bf00      	nop
 80031c4:	20000130 	.word	0x20000130
 80031c8:	e000ed00 	.word	0xe000ed00

080031cc <USBD_Resume>:
*/

static uint8_t USBD_Resume(USB_OTG_CORE_HANDLE  *pdev)
{
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceResumed(); 
 80031cc:	f8d0 15e4 	ldr.w	r1, [r0, #1508]	; 0x5e4
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Resume(USB_OTG_CORE_HANDLE  *pdev)
{
 80031d0:	b510      	push	{r4, lr}
 80031d2:	4604      	mov	r4, r0
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceResumed(); 
 80031d4:	6908      	ldr	r0, [r1, #16]
 80031d6:	4780      	blx	r0
  pdev->dev.device_status = USB_OTG_CONFIGURED;  
 80031d8:	2303      	movs	r3, #3
 80031da:	f884 3112 	strb.w	r3, [r4, #274]	; 0x112
  return USBD_OK;
}
 80031de:	2000      	movs	r0, #0
 80031e0:	bd10      	pop	{r4, pc}
 80031e2:	bf00      	nop

080031e4 <USBD_Suspend>:
static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev)
{
  
  pdev->dev.device_status  = USB_OTG_SUSPENDED;
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceSuspended(); 
 80031e4:	f8d0 15e4 	ldr.w	r1, [r0, #1508]	; 0x5e4
*/

static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev)
{
  
  pdev->dev.device_status  = USB_OTG_SUSPENDED;
 80031e8:	2204      	movs	r2, #4
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev)
{
 80031ea:	b508      	push	{r3, lr}
  
  pdev->dev.device_status  = USB_OTG_SUSPENDED;
 80031ec:	f880 2112 	strb.w	r2, [r0, #274]	; 0x112
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceSuspended(); 
 80031f0:	68cb      	ldr	r3, [r1, #12]
 80031f2:	4798      	blx	r3
  return USBD_OK;
}
 80031f4:	2000      	movs	r0, #0
 80031f6:	bd08      	pop	{r3, pc}

080031f8 <USBD_SOF>:
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_SOF(USB_OTG_CORE_HANDLE  *pdev)
{
 80031f8:	b508      	push	{r3, lr}
  if(pdev->dev.class_cb->SOF)
 80031fa:	f8d0 35e0 	ldr.w	r3, [r0, #1504]	; 0x5e0
 80031fe:	69db      	ldr	r3, [r3, #28]
 8003200:	b103      	cbz	r3, 8003204 <USBD_SOF+0xc>
  {
    pdev->dev.class_cb->SOF(pdev); 
 8003202:	4798      	blx	r3
  }
  return USBD_OK;
}
 8003204:	2000      	movs	r0, #0
 8003206:	bd08      	pop	{r3, pc}

08003208 <USBD_IsoINIncomplete>:
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoINIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
  pdev->dev.class_cb->IsoINIncomplete(pdev);   
 8003208:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
*         Handle iso in incomplete event
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoINIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
 800320c:	b508      	push	{r3, lr}
  pdev->dev.class_cb->IsoINIncomplete(pdev);   
 800320e:	6a0b      	ldr	r3, [r1, #32]
 8003210:	4798      	blx	r3
  return USBD_OK;
}
 8003212:	2000      	movs	r0, #0
 8003214:	bd08      	pop	{r3, pc}
 8003216:	bf00      	nop

08003218 <USBD_IsoOUTIncomplete>:
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoOUTIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
  pdev->dev.class_cb->IsoOUTIncomplete(pdev);   
 8003218:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
*         Handle iso out incomplete event
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoOUTIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
 800321c:	b508      	push	{r3, lr}
  pdev->dev.class_cb->IsoOUTIncomplete(pdev);   
 800321e:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8003220:	4798      	blx	r3
  return USBD_OK;
}
 8003222:	2000      	movs	r0, #0
 8003224:	bd08      	pop	{r3, pc}
 8003226:	bf00      	nop

08003228 <USBD_Reset>:
*/

static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
{
  /* Open EP0 OUT */
  DCD_EP_Open(pdev,
 8003228:	2100      	movs	r1, #0
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
{
 800322a:	b510      	push	{r4, lr}
  /* Open EP0 OUT */
  DCD_EP_Open(pdev,
 800322c:	460b      	mov	r3, r1
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
{
 800322e:	4604      	mov	r4, r0
  /* Open EP0 OUT */
  DCD_EP_Open(pdev,
 8003230:	2240      	movs	r2, #64	; 0x40
 8003232:	f7ff fc13 	bl	8002a5c <DCD_EP_Open>
              0x00,
              USB_OTG_MAX_EP0_SIZE,
              EP_TYPE_CTRL);
  
  /* Open EP0 IN */
  DCD_EP_Open(pdev,
 8003236:	2180      	movs	r1, #128	; 0x80
 8003238:	2240      	movs	r2, #64	; 0x40
 800323a:	2300      	movs	r3, #0
 800323c:	4620      	mov	r0, r4
 800323e:	f7ff fc0d 	bl	8002a5c <DCD_EP_Open>
              USB_OTG_MAX_EP0_SIZE,
              EP_TYPE_CTRL);
  
  /* Upon Reset call usr call back */
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.usr_cb->DeviceReset(pdev->cfg.speed);
 8003242:	f8d4 15e4 	ldr.w	r1, [r4, #1508]	; 0x5e4
 8003246:	78a0      	ldrb	r0, [r4, #2]
              0x80,
              USB_OTG_MAX_EP0_SIZE,
              EP_TYPE_CTRL);
  
  /* Upon Reset call usr call back */
  pdev->dev.device_status = USB_OTG_DEFAULT;
 8003248:	2201      	movs	r2, #1
 800324a:	f884 2112 	strb.w	r2, [r4, #274]	; 0x112
  pdev->dev.usr_cb->DeviceReset(pdev->cfg.speed);
 800324e:	684b      	ldr	r3, [r1, #4]
 8003250:	4798      	blx	r3
  
  return USBD_OK;
}
 8003252:	2000      	movs	r0, #0
 8003254:	bd10      	pop	{r4, pc}
 8003256:	bf00      	nop

08003258 <USBD_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_SetupStage(USB_OTG_CORE_HANDLE *pdev)
{
 8003258:	b510      	push	{r4, lr}
 800325a:	b082      	sub	sp, #8
  USB_SETUP_REQ req;
  
  USBD_ParseSetupRequest(pdev , &req);
 800325c:	4669      	mov	r1, sp
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_SetupStage(USB_OTG_CORE_HANDLE *pdev)
{
 800325e:	4604      	mov	r4, r0
  USB_SETUP_REQ req;
  
  USBD_ParseSetupRequest(pdev , &req);
 8003260:	f000 f93c 	bl	80034dc <USBD_ParseSetupRequest>
  
  switch (req.bmRequest & 0x1F) 
 8003264:	f89d 1000 	ldrb.w	r1, [sp]
 8003268:	f001 031f 	and.w	r3, r1, #31
 800326c:	2b01      	cmp	r3, #1
 800326e:	d014      	beq.n	800329a <USBD_SetupStage+0x42>
 8003270:	2b02      	cmp	r3, #2
 8003272:	d00d      	beq.n	8003290 <USBD_SetupStage+0x38>
 8003274:	b13b      	cbz	r3, 8003286 <USBD_SetupStage+0x2e>
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &req);   
    break;
    
  default:           
    DCD_EP_Stall(pdev , req.bmRequest & 0x80);
 8003276:	4620      	mov	r0, r4
 8003278:	f001 0180 	and.w	r1, r1, #128	; 0x80
 800327c:	f7ff fc70 	bl	8002b60 <DCD_EP_Stall>
    break;
  }  
  return USBD_OK;
}
 8003280:	2000      	movs	r0, #0
 8003282:	b002      	add	sp, #8
 8003284:	bd10      	pop	{r4, pc}
  USBD_ParseSetupRequest(pdev , &req);
  
  switch (req.bmRequest & 0x1F) 
  {
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &req);
 8003286:	4620      	mov	r0, r4
 8003288:	4669      	mov	r1, sp
 800328a:	f000 f9f1 	bl	8003670 <USBD_StdDevReq>
    break;
 800328e:	e7f7      	b.n	8003280 <USBD_SetupStage+0x28>
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &req);
    break;
    
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &req);   
 8003290:	4620      	mov	r0, r4
 8003292:	4669      	mov	r1, sp
 8003294:	f000 f960 	bl	8003558 <USBD_StdEPReq>
    break;
 8003298:	e7f2      	b.n	8003280 <USBD_SetupStage+0x28>
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &req);
    break;
    
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &req);
 800329a:	4620      	mov	r0, r4
 800329c:	4669      	mov	r1, sp
 800329e:	f000 f9cd 	bl	800363c <USBD_StdItfReq>
    break;
 80032a2:	e7ed      	b.n	8003280 <USBD_SetupStage+0x28>

080032a4 <USBD_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
static uint8_t USBD_DataInStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
 80032a4:	b538      	push	{r3, r4, r5, lr}
 80032a6:	4604      	mov	r4, r0
  USB_OTG_EP *ep;
  
  if(epnum == 0) 
 80032a8:	b929      	cbnz	r1, 80032b6 <USBD_DataInStage+0x12>
  {
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
 80032aa:	f890 3111 	ldrb.w	r3, [r0, #273]	; 0x111
 80032ae:	2b02      	cmp	r3, #2
 80032b0:	d00d      	beq.n	80032ce <USBD_DataInStage+0x2a>
          (pdev->dev.device_status == USB_OTG_CONFIGURED))
  {
    pdev->dev.class_cb->DataIn(pdev, epnum); 
  }  
  return USBD_OK;
}
 80032b2:	2000      	movs	r0, #0
 80032b4:	bd38      	pop	{r3, r4, r5, pc}
          USBD_CtlReceiveStatus(pdev);
        }
      }
    }
  }
  else if((pdev->dev.class_cb->DataIn != NULL)&& 
 80032b6:	f8d0 25e0 	ldr.w	r2, [r0, #1504]	; 0x5e0
 80032ba:	6953      	ldr	r3, [r2, #20]
 80032bc:	2b00      	cmp	r3, #0
 80032be:	d0f8      	beq.n	80032b2 <USBD_DataInStage+0xe>
 80032c0:	f890 c112 	ldrb.w	ip, [r0, #274]	; 0x112
 80032c4:	f1bc 0f03 	cmp.w	ip, #3
 80032c8:	d1f3      	bne.n	80032b2 <USBD_DataInStage+0xe>
          (pdev->dev.device_status == USB_OTG_CONFIGURED))
  {
    pdev->dev.class_cb->DataIn(pdev, epnum); 
 80032ca:	4798      	blx	r3
 80032cc:	e7f1      	b.n	80032b2 <USBD_DataInStage+0xe>
  if(epnum == 0) 
  {
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
    {
      if(ep->rem_data_len > ep->maxpacket)
 80032ce:	f8d0 2134 	ldr.w	r2, [r0, #308]	; 0x134
 80032d2:	f8d0 3120 	ldr.w	r3, [r0, #288]	; 0x120
 80032d6:	429a      	cmp	r2, r3
 80032d8:	d910      	bls.n	80032fc <USBD_DataInStage+0x58>
      {
        ep->rem_data_len -=  ep->maxpacket;
        if(pdev->cfg.dma_enable == 1)
 80032da:	78c1      	ldrb	r1, [r0, #3]
 80032dc:	2901      	cmp	r1, #1
 80032de:	f8d0 1124 	ldr.w	r1, [r0, #292]	; 0x124
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 80032e2:	ebc3 0202 	rsb	r2, r3, r2
        if(pdev->cfg.dma_enable == 1)
        {
          /* in slave mode this, is handled by the TxFifoEmpty ISR */
          ep->xfer_buff += ep->maxpacket;
 80032e6:	bf08      	it	eq
 80032e8:	18c9      	addeq	r1, r1, r3
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 80032ea:	f8c0 2134 	str.w	r2, [r0, #308]	; 0x134
        if(pdev->cfg.dma_enable == 1)
        {
          /* in slave mode this, is handled by the TxFifoEmpty ISR */
          ep->xfer_buff += ep->maxpacket;
 80032ee:	bf08      	it	eq
 80032f0:	f8c0 1124 	streq.w	r1, [r0, #292]	; 0x124
        }
        USBD_CtlContinueSendData (pdev, 
 80032f4:	b292      	uxth	r2, r2
 80032f6:	f000 f8a5 	bl	8003444 <USBD_CtlContinueSendData>
 80032fa:	e7da      	b.n	80032b2 <USBD_DataInStage+0xe>
                                  ep->xfer_buff, 
                                  ep->rem_data_len);
      }
      else
      { /* last packet is MPS multiple, so send ZLP packet */
        if((ep->total_data_len % ep->maxpacket == 0) &&
 80032fc:	f8d0 2138 	ldr.w	r2, [r0, #312]	; 0x138
 8003300:	fbb2 f5f3 	udiv	r5, r2, r3
 8003304:	fb03 2515 	mls	r5, r3, r5, r2
 8003308:	b95d      	cbnz	r5, 8003322 <USBD_DataInStage+0x7e>
 800330a:	4293      	cmp	r3, r2
 800330c:	d809      	bhi.n	8003322 <USBD_DataInStage+0x7e>
           (ep->total_data_len >= ep->maxpacket) &&
 800330e:	f8d0 313c 	ldr.w	r3, [r0, #316]	; 0x13c
 8003312:	429a      	cmp	r2, r3
 8003314:	d205      	bcs.n	8003322 <USBD_DataInStage+0x7e>
             (ep->total_data_len < ep->ctl_data_len ))
        {
          
          USBD_CtlContinueSendData(pdev , NULL, 0);
 8003316:	462a      	mov	r2, r5
 8003318:	f000 f894 	bl	8003444 <USBD_CtlContinueSendData>
          ep->ctl_data_len = 0;
 800331c:	f8c4 513c 	str.w	r5, [r4, #316]	; 0x13c
 8003320:	e7c7      	b.n	80032b2 <USBD_DataInStage+0xe>
        }
        else
        {
          if((pdev->dev.class_cb->EP0_TxSent != NULL)&&
 8003322:	f8d4 05e0 	ldr.w	r0, [r4, #1504]	; 0x5e0
 8003326:	68c3      	ldr	r3, [r0, #12]
 8003328:	b123      	cbz	r3, 8003334 <USBD_DataInStage+0x90>
 800332a:	f894 c112 	ldrb.w	ip, [r4, #274]	; 0x112
 800332e:	f1bc 0f03 	cmp.w	ip, #3
 8003332:	d003      	beq.n	800333c <USBD_DataInStage+0x98>
             (pdev->dev.device_status == USB_OTG_CONFIGURED))
          {
            pdev->dev.class_cb->EP0_TxSent(pdev); 
          }          
          USBD_CtlReceiveStatus(pdev);
 8003334:	4620      	mov	r0, r4
 8003336:	f000 f8b9 	bl	80034ac <USBD_CtlReceiveStatus>
 800333a:	e7ba      	b.n	80032b2 <USBD_DataInStage+0xe>
        else
        {
          if((pdev->dev.class_cb->EP0_TxSent != NULL)&&
             (pdev->dev.device_status == USB_OTG_CONFIGURED))
          {
            pdev->dev.class_cb->EP0_TxSent(pdev); 
 800333c:	4620      	mov	r0, r4
 800333e:	4798      	blx	r3
 8003340:	e7f8      	b.n	8003334 <USBD_DataInStage+0x90>
 8003342:	bf00      	nop

08003344 <USBD_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
static uint8_t USBD_DataOutStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
 8003344:	b510      	push	{r4, lr}
 8003346:	4604      	mov	r4, r0
  USB_OTG_EP *ep;
  
  if(epnum == 0) 
 8003348:	b929      	cbnz	r1, 8003356 <USBD_DataOutStage+0x12>
  {
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
 800334a:	f890 3111 	ldrb.w	r3, [r0, #273]	; 0x111
 800334e:	2b03      	cmp	r3, #3
 8003350:	d00d      	beq.n	800336e <USBD_DataOutStage+0x2a>
          (pdev->dev.device_status == USB_OTG_CONFIGURED))
  {
    pdev->dev.class_cb->DataOut(pdev, epnum); 
  }  
  return USBD_OK;
}
 8003352:	2000      	movs	r0, #0
 8003354:	bd10      	pop	{r4, pc}
        }
        USBD_CtlSendStatus(pdev);
      }
    }
  }
  else if((pdev->dev.class_cb->DataOut != NULL)&&
 8003356:	f8d0 25e0 	ldr.w	r2, [r0, #1504]	; 0x5e0
 800335a:	6993      	ldr	r3, [r2, #24]
 800335c:	2b00      	cmp	r3, #0
 800335e:	d0f8      	beq.n	8003352 <USBD_DataOutStage+0xe>
 8003360:	f890 c112 	ldrb.w	ip, [r0, #274]	; 0x112
 8003364:	f1bc 0f03 	cmp.w	ip, #3
 8003368:	d1f3      	bne.n	8003352 <USBD_DataOutStage+0xe>
          (pdev->dev.device_status == USB_OTG_CONFIGURED))
  {
    pdev->dev.class_cb->DataOut(pdev, epnum); 
 800336a:	4798      	blx	r3
 800336c:	e7f1      	b.n	8003352 <USBD_DataOutStage+0xe>
  if(epnum == 0) 
  {
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
    {
      if(ep->rem_data_len > ep->maxpacket)
 800336e:	f8d0 238c 	ldr.w	r2, [r0, #908]	; 0x38c
 8003372:	f8d0 3378 	ldr.w	r3, [r0, #888]	; 0x378
 8003376:	429a      	cmp	r2, r3
 8003378:	d912      	bls.n	80033a0 <USBD_DataOutStage+0x5c>
      {
        ep->rem_data_len -=  ep->maxpacket;
        
        if(pdev->cfg.dma_enable == 1)
 800337a:	78c1      	ldrb	r1, [r0, #3]
 800337c:	2901      	cmp	r1, #1
 800337e:	f8d0 137c 	ldr.w	r1, [r0, #892]	; 0x37c
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 8003382:	ebc3 0202 	rsb	r2, r3, r2
        
        if(pdev->cfg.dma_enable == 1)
        {
          /* in slave mode this, is handled by the RxSTSQLvl ISR */
          ep->xfer_buff += ep->maxpacket; 
 8003386:	bf04      	itt	eq
 8003388:	18c9      	addeq	r1, r1, r3
 800338a:	f8c0 137c 	streq.w	r1, [r0, #892]	; 0x37c
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 800338e:	f8c0 238c 	str.w	r2, [r0, #908]	; 0x38c
          /* in slave mode this, is handled by the RxSTSQLvl ISR */
          ep->xfer_buff += ep->maxpacket; 
        }        
        USBD_CtlContinueRx (pdev, 
                            ep->xfer_buff,
                            MIN(ep->rem_data_len ,ep->maxpacket));
 8003392:	429a      	cmp	r2, r3
 8003394:	bf28      	it	cs
 8003396:	461a      	movcs	r2, r3
        if(pdev->cfg.dma_enable == 1)
        {
          /* in slave mode this, is handled by the RxSTSQLvl ISR */
          ep->xfer_buff += ep->maxpacket; 
        }        
        USBD_CtlContinueRx (pdev, 
 8003398:	b292      	uxth	r2, r2
 800339a:	f000 f86d 	bl	8003478 <USBD_CtlContinueRx>
 800339e:	e7d8      	b.n	8003352 <USBD_DataOutStage+0xe>
                            ep->xfer_buff,
                            MIN(ep->rem_data_len ,ep->maxpacket));
      }
      else
      {
        if((pdev->dev.class_cb->EP0_RxReady != NULL)&&
 80033a0:	f8d0 35e0 	ldr.w	r3, [r0, #1504]	; 0x5e0
 80033a4:	691b      	ldr	r3, [r3, #16]
 80033a6:	b123      	cbz	r3, 80033b2 <USBD_DataOutStage+0x6e>
 80033a8:	f890 c112 	ldrb.w	ip, [r0, #274]	; 0x112
 80033ac:	f1bc 0f03 	cmp.w	ip, #3
 80033b0:	d003      	beq.n	80033ba <USBD_DataOutStage+0x76>
           (pdev->dev.device_status == USB_OTG_CONFIGURED))
        {
          pdev->dev.class_cb->EP0_RxReady(pdev); 
        }
        USBD_CtlSendStatus(pdev);
 80033b2:	4620      	mov	r0, r4
 80033b4:	f000 f86a 	bl	800348c <USBD_CtlSendStatus>
 80033b8:	e7cb      	b.n	8003352 <USBD_DataOutStage+0xe>
      else
      {
        if((pdev->dev.class_cb->EP0_RxReady != NULL)&&
           (pdev->dev.device_status == USB_OTG_CONFIGURED))
        {
          pdev->dev.class_cb->EP0_RxReady(pdev); 
 80033ba:	4798      	blx	r3
 80033bc:	e7f9      	b.n	80033b2 <USBD_DataOutStage+0x6e>
 80033be:	bf00      	nop

080033c0 <USBD_Init>:
void USBD_Init(USB_OTG_CORE_HANDLE *pdev,
               USB_OTG_CORE_ID_TypeDef coreID,
               USBD_DEVICE *pDevice,                  
               USBD_Class_cb_TypeDef *class_cb, 
               USBD_Usr_cb_TypeDef *usr_cb)
{
 80033c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80033c4:	9d06      	ldr	r5, [sp, #24]
 80033c6:	4604      	mov	r4, r0
 80033c8:	4616      	mov	r6, r2
 80033ca:	461f      	mov	r7, r3
 80033cc:	4688      	mov	r8, r1
  /* Hardware Init */
  USB_OTG_BSP_Init(pdev);  
 80033ce:	f000 fafb 	bl	80039c8 <USB_OTG_BSP_Init>
  pdev->dev.class_cb = class_cb;
  pdev->dev.usr_cb = usr_cb;  
  pdev->dev.usr_device = pDevice;    
  
  /* set USB OTG core params */
  DCD_Init(pdev , coreID);
 80033d2:	4620      	mov	r0, r4
 80033d4:	4641      	mov	r1, r8
  USB_OTG_BSP_Init(pdev);  
  
  USBD_DeInit(pdev);
  
  /*Register class and user callbacks */
  pdev->dev.class_cb = class_cb;
 80033d6:	f8c4 75e0 	str.w	r7, [r4, #1504]	; 0x5e0
  pdev->dev.usr_cb = usr_cb;  
 80033da:	f8c4 55e4 	str.w	r5, [r4, #1508]	; 0x5e4
  pdev->dev.usr_device = pDevice;    
 80033de:	f8c4 65e8 	str.w	r6, [r4, #1512]	; 0x5e8
  
  /* set USB OTG core params */
  DCD_Init(pdev , coreID);
 80033e2:	f7ff fa7f 	bl	80028e4 <DCD_Init>
  
  /* Upon Init call usr callback */
  pdev->dev.usr_cb->Init();
 80033e6:	f8d4 05e4 	ldr.w	r0, [r4, #1508]	; 0x5e4
 80033ea:	6803      	ldr	r3, [r0, #0]
 80033ec:	4798      	blx	r3
  
  /* Enable Interrupts */
  USB_OTG_BSP_EnableInterrupt(pdev);
 80033ee:	4620      	mov	r0, r4
}
 80033f0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  
  /* Upon Init call usr callback */
  pdev->dev.usr_cb->Init();
  
  /* Enable Interrupts */
  USB_OTG_BSP_EnableInterrupt(pdev);
 80033f4:	f000 bb3a 	b.w	8003a6c <USB_OTG_BSP_EnableInterrupt>

080033f8 <USBD_DeInit>:
USBD_Status USBD_DeInit(USB_OTG_CORE_HANDLE *pdev)
{
  /* Software Init */
  
  return USBD_OK;
}
 80033f8:	2000      	movs	r0, #0
 80033fa:	4770      	bx	lr

080033fc <USBD_SetCfg>:
* @retval status
*/

USBD_Status USBD_SetCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
  pdev->dev.class_cb->Init(pdev, cfgidx); 
 80033fc:	f8d0 35e0 	ldr.w	r3, [r0, #1504]	; 0x5e0
* @param  cfgidx: configuration index
* @retval status
*/

USBD_Status USBD_SetCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
 8003400:	b510      	push	{r4, lr}
 8003402:	4604      	mov	r4, r0
  pdev->dev.class_cb->Init(pdev, cfgidx); 
 8003404:	681a      	ldr	r2, [r3, #0]
 8003406:	4790      	blx	r2
  
  /* Upon set config call usr call back */
  pdev->dev.usr_cb->DeviceConfigured();
 8003408:	f8d4 05e4 	ldr.w	r0, [r4, #1508]	; 0x5e4
 800340c:	6883      	ldr	r3, [r0, #8]
 800340e:	4798      	blx	r3
  return USBD_OK; 
}
 8003410:	2000      	movs	r0, #0
 8003412:	bd10      	pop	{r4, pc}

08003414 <USBD_ClrCfg>:
* @param  cfgidx: configuration index
* @retval status: USBD_Status
*/
USBD_Status USBD_ClrCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
  pdev->dev.class_cb->DeInit(pdev, cfgidx);   
 8003414:	f8d0 25e0 	ldr.w	r2, [r0, #1504]	; 0x5e0
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_Status
*/
USBD_Status USBD_ClrCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
 8003418:	b508      	push	{r3, lr}
  pdev->dev.class_cb->DeInit(pdev, cfgidx);   
 800341a:	6853      	ldr	r3, [r2, #4]
 800341c:	4798      	blx	r3
  return USBD_OK;
}
 800341e:	2000      	movs	r0, #0
 8003420:	bd08      	pop	{r3, pc}
 8003422:	bf00      	nop

08003424 <USBD_CtlSendData>:
* @retval status
*/
USBD_Status  USBD_CtlSendData (USB_OTG_CORE_HANDLE  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 8003424:	4613      	mov	r3, r2
 8003426:	460a      	mov	r2, r1
  USBD_Status ret = USBD_OK;
  
  pdev->dev.in_ep[0].total_data_len = len;
  pdev->dev.in_ep[0].rem_data_len   = len;
  pdev->dev.device_state = USB_OTG_EP0_DATA_IN;
 8003428:	2102      	movs	r1, #2
* @retval status
*/
USBD_Status  USBD_CtlSendData (USB_OTG_CORE_HANDLE  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 800342a:	b510      	push	{r4, lr}
  USBD_Status ret = USBD_OK;
  
  pdev->dev.in_ep[0].total_data_len = len;
 800342c:	f8c0 3138 	str.w	r3, [r0, #312]	; 0x138
  pdev->dev.in_ep[0].rem_data_len   = len;
 8003430:	f8c0 3134 	str.w	r3, [r0, #308]	; 0x134
  pdev->dev.device_state = USB_OTG_EP0_DATA_IN;
 8003434:	f880 1111 	strb.w	r1, [r0, #273]	; 0x111

  DCD_EP_Tx (pdev, 0, pbuf, len);
 8003438:	2100      	movs	r1, #0
 800343a:	f7ff fb6f 	bl	8002b1c <DCD_EP_Tx>
 
  return ret;
}
 800343e:	2000      	movs	r0, #0
 8003440:	bd10      	pop	{r4, pc}
 8003442:	bf00      	nop

08003444 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_Status  USBD_CtlContinueSendData (USB_OTG_CORE_HANDLE  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 8003444:	b510      	push	{r4, lr}
 8003446:	460c      	mov	r4, r1
 8003448:	4613      	mov	r3, r2
  USBD_Status ret = USBD_OK;
  
  DCD_EP_Tx (pdev, 0, pbuf, len);
 800344a:	2100      	movs	r1, #0
 800344c:	4622      	mov	r2, r4
 800344e:	f7ff fb65 	bl	8002b1c <DCD_EP_Tx>
  
  
  return ret;
}
 8003452:	2000      	movs	r0, #0
 8003454:	bd10      	pop	{r4, pc}
 8003456:	bf00      	nop

08003458 <USBD_CtlPrepareRx>:
* @retval status
*/
USBD_Status  USBD_CtlPrepareRx (USB_OTG_CORE_HANDLE  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
 8003458:	4613      	mov	r3, r2
 800345a:	460a      	mov	r2, r1
  USBD_Status ret = USBD_OK;
  
  pdev->dev.out_ep[0].total_data_len = len;
  pdev->dev.out_ep[0].rem_data_len   = len;
  pdev->dev.device_state = USB_OTG_EP0_DATA_OUT;
 800345c:	2103      	movs	r1, #3
* @retval status
*/
USBD_Status  USBD_CtlPrepareRx (USB_OTG_CORE_HANDLE  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
 800345e:	b510      	push	{r4, lr}
  USBD_Status ret = USBD_OK;
  
  pdev->dev.out_ep[0].total_data_len = len;
 8003460:	f8c0 3390 	str.w	r3, [r0, #912]	; 0x390
  pdev->dev.out_ep[0].rem_data_len   = len;
 8003464:	f8c0 338c 	str.w	r3, [r0, #908]	; 0x38c
  pdev->dev.device_state = USB_OTG_EP0_DATA_OUT;
 8003468:	f880 1111 	strb.w	r1, [r0, #273]	; 0x111
  
  DCD_EP_PrepareRx (pdev,
 800346c:	2100      	movs	r1, #0
 800346e:	f7ff fb2b 	bl	8002ac8 <DCD_EP_PrepareRx>
                    pbuf,
                    len);
  

  return ret;
}
 8003472:	2000      	movs	r0, #0
 8003474:	bd10      	pop	{r4, pc}
 8003476:	bf00      	nop

08003478 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_Status  USBD_CtlContinueRx (USB_OTG_CORE_HANDLE  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 8003478:	b510      	push	{r4, lr}
 800347a:	460c      	mov	r4, r1
 800347c:	4613      	mov	r3, r2
  USBD_Status ret = USBD_OK;
  
  DCD_EP_PrepareRx (pdev,
 800347e:	2100      	movs	r1, #0
 8003480:	4622      	mov	r2, r4
 8003482:	f7ff fb21 	bl	8002ac8 <DCD_EP_PrepareRx>
                    0,                     
                    pbuf,                         
                    len);
  return ret;
}
 8003486:	2000      	movs	r0, #0
 8003488:	bd10      	pop	{r4, pc}
 800348a:	bf00      	nop

0800348c <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 800348c:	b538      	push	{r3, r4, r5, lr}
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
  DCD_EP_Tx (pdev,
 800348e:	2100      	movs	r1, #0
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
 8003490:	2504      	movs	r5, #4
*         send zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 8003492:	4604      	mov	r4, r0
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
  DCD_EP_Tx (pdev,
 8003494:	460a      	mov	r2, r1
 8003496:	460b      	mov	r3, r1
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
 8003498:	f880 5111 	strb.w	r5, [r0, #273]	; 0x111
  DCD_EP_Tx (pdev,
 800349c:	f7ff fb3e 	bl	8002b1c <DCD_EP_Tx>
             0,
             NULL, 
             0); 
  
  USB_OTG_EP0_OutStart(pdev);  
 80034a0:	4620      	mov	r0, r4
 80034a2:	f7ff f937 	bl	8002714 <USB_OTG_EP0_OutStart>
  
  return ret;
}
 80034a6:	2000      	movs	r0, #0
 80034a8:	bd38      	pop	{r3, r4, r5, pc}
 80034aa:	bf00      	nop

080034ac <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 80034ac:	b538      	push	{r3, r4, r5, lr}
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
  DCD_EP_PrepareRx ( pdev,
 80034ae:	2100      	movs	r1, #0
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
 80034b0:	2505      	movs	r5, #5
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 80034b2:	4604      	mov	r4, r0
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
  DCD_EP_PrepareRx ( pdev,
 80034b4:	460a      	mov	r2, r1
 80034b6:	460b      	mov	r3, r1
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
 80034b8:	f880 5111 	strb.w	r5, [r0, #273]	; 0x111
  DCD_EP_PrepareRx ( pdev,
 80034bc:	f7ff fb04 	bl	8002ac8 <DCD_EP_PrepareRx>
                    0,
                    NULL,
                    0);  

  USB_OTG_EP0_OutStart(pdev);
 80034c0:	4620      	mov	r0, r4
 80034c2:	f7ff f927 	bl	8002714 <USB_OTG_EP0_OutStart>
  
  return ret;
}
 80034c6:	2000      	movs	r0, #0
 80034c8:	bd38      	pop	{r3, r4, r5, pc}
 80034ca:	bf00      	nop

080034cc <USBD_GetRxCount>:
*         epnum: endpoint index
* @retval Rx Data blength
*/
uint16_t  USBD_GetRxCount (USB_OTG_CORE_HANDLE  *pdev , uint8_t epnum)
{
  return pdev->dev.out_ep[epnum].xfer_count;
 80034cc:	eb01 0281 	add.w	r2, r1, r1, lsl #2
 80034d0:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
}
 80034d4:	f8b1 0388 	ldrh.w	r0, [r1, #904]	; 0x388
 80034d8:	4770      	bx	lr
 80034da:	bf00      	nop

080034dc <USBD_ParseSetupRequest>:
*/

void USBD_ParseSetupRequest( USB_OTG_CORE_HANDLE  *pdev,
                            USB_SETUP_REQ *req)
{
  req->bmRequest     = *(uint8_t *)  (pdev->dev.setup_packet);
 80034dc:	f890 25c8 	ldrb.w	r2, [r0, #1480]	; 0x5c8
 80034e0:	700a      	strb	r2, [r1, #0]
  req->bRequest      = *(uint8_t *)  (pdev->dev.setup_packet +  1);
 80034e2:	f890 c5c9 	ldrb.w	ip, [r0, #1481]	; 0x5c9
 80034e6:	f881 c001 	strb.w	ip, [r1, #1]
  req->wValue        = SWAPBYTE      (pdev->dev.setup_packet +  2);
 80034ea:	f890 35cb 	ldrb.w	r3, [r0, #1483]	; 0x5cb
 80034ee:	f890 25ca 	ldrb.w	r2, [r0, #1482]	; 0x5ca
 80034f2:	021b      	lsls	r3, r3, #8
 80034f4:	eb03 0c02 	add.w	ip, r3, r2
 80034f8:	f8a1 c002 	strh.w	ip, [r1, #2]
  req->wIndex        = SWAPBYTE      (pdev->dev.setup_packet +  4);
 80034fc:	f890 35cd 	ldrb.w	r3, [r0, #1485]	; 0x5cd
 8003500:	f890 25cc 	ldrb.w	r2, [r0, #1484]	; 0x5cc
 8003504:	021b      	lsls	r3, r3, #8
 8003506:	eb03 0c02 	add.w	ip, r3, r2
 800350a:	f8a1 c004 	strh.w	ip, [r1, #4]
  req->wLength       = SWAPBYTE      (pdev->dev.setup_packet +  6);
 800350e:	f890 35cf 	ldrb.w	r3, [r0, #1487]	; 0x5cf
 8003512:	f890 25ce 	ldrb.w	r2, [r0, #1486]	; 0x5ce
 8003516:	021b      	lsls	r3, r3, #8
 8003518:	eb03 0c02 	add.w	ip, r3, r2
 800351c:	fa1f f28c 	uxth.w	r2, ip
  
  pdev->dev.in_ep[0].ctl_data_len = req->wLength  ;
  pdev->dev.device_state = USB_OTG_EP0_SETUP;
 8003520:	2301      	movs	r3, #1
{
  req->bmRequest     = *(uint8_t *)  (pdev->dev.setup_packet);
  req->bRequest      = *(uint8_t *)  (pdev->dev.setup_packet +  1);
  req->wValue        = SWAPBYTE      (pdev->dev.setup_packet +  2);
  req->wIndex        = SWAPBYTE      (pdev->dev.setup_packet +  4);
  req->wLength       = SWAPBYTE      (pdev->dev.setup_packet +  6);
 8003522:	80ca      	strh	r2, [r1, #6]
  
  pdev->dev.in_ep[0].ctl_data_len = req->wLength  ;
 8003524:	f8c0 213c 	str.w	r2, [r0, #316]	; 0x13c
  pdev->dev.device_state = USB_OTG_EP0_SETUP;
 8003528:	f880 3111 	strb.w	r3, [r0, #273]	; 0x111
}
 800352c:	4770      	bx	lr
 800352e:	bf00      	nop

08003530 <USBD_CtlError>:
* @retval None
*/

void USBD_CtlError( USB_OTG_CORE_HANDLE  *pdev,
                            USB_SETUP_REQ *req)
{
 8003530:	b510      	push	{r4, lr}
  if((req->bmRequest & 0x80) == 0x80)
 8003532:	f991 3000 	ldrsb.w	r3, [r1]
 8003536:	2b00      	cmp	r3, #0
* @retval None
*/

void USBD_CtlError( USB_OTG_CORE_HANDLE  *pdev,
                            USB_SETUP_REQ *req)
{
 8003538:	4604      	mov	r4, r0
  if((req->bmRequest & 0x80) == 0x80)
 800353a:	db09      	blt.n	8003550 <USBD_CtlError+0x20>
  {
    DCD_EP_Stall(pdev , 0x80);
  }
  else 
  {
    if(req->wLength == 0)
 800353c:	88c9      	ldrh	r1, [r1, #6]
 800353e:	b139      	cbz	r1, 8003550 <USBD_CtlError+0x20>
    {
       DCD_EP_Stall(pdev , 0x80);
    }
    else
    {
      DCD_EP_Stall(pdev , 0);
 8003540:	2100      	movs	r1, #0
 8003542:	f7ff fb0d 	bl	8002b60 <DCD_EP_Stall>
    }
  }
  USB_OTG_EP0_OutStart(pdev);  
 8003546:	4620      	mov	r0, r4
}
 8003548:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    else
    {
      DCD_EP_Stall(pdev , 0);
    }
  }
  USB_OTG_EP0_OutStart(pdev);  
 800354c:	f7ff b8e2 	b.w	8002714 <USB_OTG_EP0_OutStart>
  }
  else 
  {
    if(req->wLength == 0)
    {
       DCD_EP_Stall(pdev , 0x80);
 8003550:	2180      	movs	r1, #128	; 0x80
 8003552:	f7ff fb05 	bl	8002b60 <DCD_EP_Stall>
 8003556:	e7f6      	b.n	8003546 <USBD_CtlError+0x16>

08003558 <USBD_StdEPReq>:
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdEPReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 8003558:	b538      	push	{r3, r4, r5, lr}
  uint8_t   ep_addr;
  USBD_Status ret = USBD_OK; 
  
  ep_addr  = LOBYTE(req->wIndex);   
  
  switch (req->bRequest) 
 800355a:	784b      	ldrb	r3, [r1, #1]
{
  
  uint8_t   ep_addr;
  USBD_Status ret = USBD_OK; 
  
  ep_addr  = LOBYTE(req->wIndex);   
 800355c:	790a      	ldrb	r2, [r1, #4]
  
  switch (req->bRequest) 
 800355e:	2b01      	cmp	r3, #1
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdEPReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 8003560:	460c      	mov	r4, r1
 8003562:	4605      	mov	r5, r0
  uint8_t   ep_addr;
  USBD_Status ret = USBD_OK; 
  
  ep_addr  = LOBYTE(req->wIndex);   
  
  switch (req->bRequest) 
 8003564:	d00e      	beq.n	8003584 <USBD_StdEPReq+0x2c>
 8003566:	d303      	bcc.n	8003570 <USBD_StdEPReq+0x18>
 8003568:	2b03      	cmp	r3, #3
 800356a:	d017      	beq.n	800359c <USBD_StdEPReq+0x44>
    
  default:
    break;
  }
  return ret;
}
 800356c:	2000      	movs	r0, #0
 800356e:	bd38      	pop	{r3, r4, r5, pc}
      break;    
    }
    break;
    
  case USB_REQ_GET_STATUS:                  
    switch (pdev->dev.device_status) 
 8003570:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 8003574:	2b02      	cmp	r3, #2
 8003576:	d009      	beq.n	800358c <USBD_StdEPReq+0x34>
 8003578:	2b03      	cmp	r3, #3
 800357a:	d03c      	beq.n	80035f6 <USBD_StdEPReq+0x9e>
                        (uint8_t *)&USBD_ep_status,
                        2);
      break;
      
    default:                         
       USBD_CtlError(pdev , req);
 800357c:	f7ff ffd8 	bl	8003530 <USBD_CtlError>
    
  default:
    break;
  }
  return ret;
}
 8003580:	2000      	movs	r0, #0
 8003582:	bd38      	pop	{r3, r4, r5, pc}
    }
    break;
    
  case USB_REQ_CLEAR_FEATURE :
    
    switch (pdev->dev.device_status) 
 8003584:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 8003588:	2b02      	cmp	r3, #2
 800358a:	d11f      	bne.n	80035cc <USBD_StdEPReq+0x74>
    
  case USB_REQ_GET_STATUS:                  
    switch (pdev->dev.device_status) 
    {
    case USB_OTG_ADDRESSED:          
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 800358c:	2a00      	cmp	r2, #0
 800358e:	d0ed      	beq.n	800356c <USBD_StdEPReq+0x14>
 8003590:	2a80      	cmp	r2, #128	; 0x80
 8003592:	d0eb      	beq.n	800356c <USBD_StdEPReq+0x14>
      {
        DCD_EP_Stall(pdev , ep_addr);
 8003594:	4611      	mov	r1, r2
 8003596:	f7ff fae3 	bl	8002b60 <DCD_EP_Stall>
 800359a:	e7e7      	b.n	800356c <USBD_StdEPReq+0x14>
  switch (req->bRequest) 
  {
    
  case USB_REQ_SET_FEATURE :
    
    switch (pdev->dev.device_status) 
 800359c:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 80035a0:	2b02      	cmp	r3, #2
 80035a2:	d0f3      	beq.n	800358c <USBD_StdEPReq+0x34>
 80035a4:	2b03      	cmp	r3, #3
 80035a6:	d1e9      	bne.n	800357c <USBD_StdEPReq+0x24>
        DCD_EP_Stall(pdev , ep_addr);
      }
      break;	
      
    case USB_OTG_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 80035a8:	884b      	ldrh	r3, [r1, #2]
 80035aa:	b92b      	cbnz	r3, 80035b8 <USBD_StdEPReq+0x60>
      {
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80035ac:	b122      	cbz	r2, 80035b8 <USBD_StdEPReq+0x60>
 80035ae:	2a80      	cmp	r2, #128	; 0x80
 80035b0:	d002      	beq.n	80035b8 <USBD_StdEPReq+0x60>
        { 
          DCD_EP_Stall(pdev , ep_addr);
 80035b2:	4611      	mov	r1, r2
 80035b4:	f7ff fad4 	bl	8002b60 <DCD_EP_Stall>
          
        }
      }
      pdev->dev.class_cb->Setup (pdev, req);   
 80035b8:	f8d5 15e0 	ldr.w	r1, [r5, #1504]	; 0x5e0
 80035bc:	4628      	mov	r0, r5
 80035be:	688a      	ldr	r2, [r1, #8]
 80035c0:	4621      	mov	r1, r4
 80035c2:	4790      	blx	r2
      USBD_CtlSendStatus(pdev);
 80035c4:	4628      	mov	r0, r5
 80035c6:	f7ff ff61 	bl	800348c <USBD_CtlSendStatus>
      
      break;
 80035ca:	e7cf      	b.n	800356c <USBD_StdEPReq+0x14>
    }
    break;
    
  case USB_REQ_CLEAR_FEATURE :
    
    switch (pdev->dev.device_status) 
 80035cc:	2b03      	cmp	r3, #3
 80035ce:	d1d5      	bne.n	800357c <USBD_StdEPReq+0x24>
        DCD_EP_Stall(pdev , ep_addr);
      }
      break;	
      
    case USB_OTG_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 80035d0:	884b      	ldrh	r3, [r1, #2]
 80035d2:	2b00      	cmp	r3, #0
 80035d4:	d1ca      	bne.n	800356c <USBD_StdEPReq+0x14>
      {
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80035d6:	b152      	cbz	r2, 80035ee <USBD_StdEPReq+0x96>
 80035d8:	2a80      	cmp	r2, #128	; 0x80
 80035da:	d008      	beq.n	80035ee <USBD_StdEPReq+0x96>
        {        
          DCD_EP_ClrStall(pdev , ep_addr);
 80035dc:	4611      	mov	r1, r2
 80035de:	f7ff fadf 	bl	8002ba0 <DCD_EP_ClrStall>
          pdev->dev.class_cb->Setup (pdev, req);
 80035e2:	f8d5 15e0 	ldr.w	r1, [r5, #1504]	; 0x5e0
 80035e6:	4628      	mov	r0, r5
 80035e8:	688a      	ldr	r2, [r1, #8]
 80035ea:	4621      	mov	r1, r4
 80035ec:	4790      	blx	r2
        }
        USBD_CtlSendStatus(pdev);
 80035ee:	4628      	mov	r0, r5
 80035f0:	f7ff ff4c 	bl	800348c <USBD_CtlSendStatus>
 80035f4:	e7ba      	b.n	800356c <USBD_StdEPReq+0x14>
      break;	
      
    case USB_OTG_CONFIGURED:         
      
      
      if ((ep_addr & 0x80)== 0x80)
 80035f6:	f012 0f80 	tst.w	r2, #128	; 0x80
 80035fa:	d10e      	bne.n	800361a <USBD_StdEPReq+0xc2>
          USBD_ep_status = 0x0000;  
        }
      }
      else if ((ep_addr & 0x80)== 0x00)
      {
        if(pdev->dev.out_ep[ep_addr].is_stall)
 80035fc:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8003600:	eb00 03c2 	add.w	r3, r0, r2, lsl #3
 8003604:	f893 3372 	ldrb.w	r3, [r3, #882]	; 0x372
 8003608:	b98b      	cbnz	r3, 800362e <USBD_StdEPReq+0xd6>
          USBD_ep_status = 0x0001;     
        }
        
        else 
        {
          USBD_ep_status = 0x0000;     
 800360a:	4a0b      	ldr	r2, [pc, #44]	; (8003638 <USBD_StdEPReq+0xe0>)
 800360c:	6013      	str	r3, [r2, #0]
        }      
      }
      USBD_CtlSendData (pdev,
 800360e:	4628      	mov	r0, r5
 8003610:	4909      	ldr	r1, [pc, #36]	; (8003638 <USBD_StdEPReq+0xe0>)
 8003612:	2202      	movs	r2, #2
 8003614:	f7ff ff06 	bl	8003424 <USBD_CtlSendData>
                        (uint8_t *)&USBD_ep_status,
                        2);
      break;
 8003618:	e7a8      	b.n	800356c <USBD_StdEPReq+0x14>
    case USB_OTG_CONFIGURED:         
      
      
      if ((ep_addr & 0x80)== 0x80)
      {
        if(pdev->dev.in_ep[ep_addr & 0x7F].is_stall)
 800361a:	f002 0e7f 	and.w	lr, r2, #127	; 0x7f
 800361e:	eb0e 0c8e 	add.w	ip, lr, lr, lsl #2
 8003622:	eb00 00cc 	add.w	r0, r0, ip, lsl #3
 8003626:	f890 311a 	ldrb.w	r3, [r0, #282]	; 0x11a
 800362a:	2b00      	cmp	r3, #0
 800362c:	d0ed      	beq.n	800360a <USBD_StdEPReq+0xb2>
      }
      else if ((ep_addr & 0x80)== 0x00)
      {
        if(pdev->dev.out_ep[ep_addr].is_stall)
        {
          USBD_ep_status = 0x0001;     
 800362e:	4802      	ldr	r0, [pc, #8]	; (8003638 <USBD_StdEPReq+0xe0>)
 8003630:	2101      	movs	r1, #1
 8003632:	6001      	str	r1, [r0, #0]
 8003634:	e7eb      	b.n	800360e <USBD_StdEPReq+0xb6>
 8003636:	bf00      	nop
 8003638:	20000e30 	.word	0x20000e30

0800363c <USBD_StdItfReq>:
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdItfReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 800363c:	b538      	push	{r3, r4, r5, lr}
  USBD_Status ret = USBD_OK; 
  
  switch (pdev->dev.device_status) 
 800363e:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 8003642:	2b03      	cmp	r3, #3
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdItfReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 8003644:	4604      	mov	r4, r0
 8003646:	460d      	mov	r5, r1
  USBD_Status ret = USBD_OK; 
  
  switch (pdev->dev.device_status) 
 8003648:	d003      	beq.n	8003652 <USBD_StdItfReq+0x16>
       USBD_CtlError(pdev , req);
    }
    break;
    
  default:
     USBD_CtlError(pdev , req);
 800364a:	f7ff ff71 	bl	8003530 <USBD_CtlError>
    break;
  }
  return ret;
}
 800364e:	2000      	movs	r0, #0
 8003650:	bd38      	pop	{r3, r4, r5, pc}
  
  switch (pdev->dev.device_status) 
  {
  case USB_OTG_CONFIGURED:
    
    if (LOBYTE(req->wIndex) <= USBD_ITF_MAX_NUM) 
 8003652:	790a      	ldrb	r2, [r1, #4]
 8003654:	2a01      	cmp	r2, #1
 8003656:	d8f8      	bhi.n	800364a <USBD_StdItfReq+0xe>
    {
      pdev->dev.class_cb->Setup (pdev, req); 
 8003658:	f8d0 25e0 	ldr.w	r2, [r0, #1504]	; 0x5e0
 800365c:	6893      	ldr	r3, [r2, #8]
 800365e:	4798      	blx	r3
      
      if((req->wLength == 0)&& (ret == USBD_OK))
 8003660:	88e8      	ldrh	r0, [r5, #6]
 8003662:	2800      	cmp	r0, #0
 8003664:	d1f3      	bne.n	800364e <USBD_StdItfReq+0x12>
      {
         USBD_CtlSendStatus(pdev);
 8003666:	4620      	mov	r0, r4
 8003668:	f7ff ff10 	bl	800348c <USBD_CtlSendStatus>
 800366c:	e7ef      	b.n	800364e <USBD_StdItfReq+0x12>
 800366e:	bf00      	nop

08003670 <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdDevReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 8003670:	b570      	push	{r4, r5, r6, lr}
  USBD_Status ret = USBD_OK;  
  
  switch (req->bRequest) 
 8003672:	784b      	ldrb	r3, [r1, #1]
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdDevReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 8003674:	b082      	sub	sp, #8
 8003676:	460c      	mov	r4, r1
 8003678:	4605      	mov	r5, r0
  USBD_Status ret = USBD_OK;  
  
  switch (req->bRequest) 
 800367a:	2b09      	cmp	r3, #9
 800367c:	d813      	bhi.n	80036a6 <USBD_StdDevReq+0x36>
 800367e:	e8df f003 	tbb	[pc, r3]
 8003682:	2a18      	.short	0x2a18
 8003684:	57124012 	.word	0x57124012
 8003688:	058b1274 	.word	0x058b1274
                           USB_SETUP_REQ *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 800368c:	78a1      	ldrb	r1, [r4, #2]
 800368e:	4e9b      	ldr	r6, [pc, #620]	; (80038fc <USBD_StdDevReq+0x28c>)
  
  if (cfgidx > USBD_CFG_MAX_NUM ) 
 8003690:	2901      	cmp	r1, #1
                           USB_SETUP_REQ *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 8003692:	7131      	strb	r1, [r6, #4]
  
  if (cfgidx > USBD_CFG_MAX_NUM ) 
 8003694:	d807      	bhi.n	80036a6 <USBD_StdDevReq+0x36>
  {            
     USBD_CtlError(pdev , req);                              
  } 
  else 
  {
    switch (pdev->dev.device_status) 
 8003696:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 800369a:	2b02      	cmp	r3, #2
 800369c:	f000 813f 	beq.w	800391e <USBD_StdDevReq+0x2ae>
 80036a0:	2b03      	cmp	r3, #3
 80036a2:	f000 80cd 	beq.w	8003840 <USBD_StdDevReq+0x1d0>
  case USB_REQ_CLEAR_FEATURE:                                   
    USBD_ClrFeature (pdev , req);
    break;
    
  default:  
    USBD_CtlError(pdev , req);
 80036a6:	4621      	mov	r1, r4
 80036a8:	f7ff ff42 	bl	8003530 <USBD_CtlError>
    break;
  }
  
  return ret;
}
 80036ac:	2000      	movs	r0, #0
 80036ae:	b002      	add	sp, #8
 80036b0:	bd70      	pop	{r4, r5, r6, pc}
*/
static void USBD_GetStatus(USB_OTG_CORE_HANDLE  *pdev, 
                           USB_SETUP_REQ *req)
{
  
  switch (pdev->dev.device_status) 
 80036b2:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 80036b6:	1e99      	subs	r1, r3, #2
 80036b8:	2901      	cmp	r1, #1
 80036ba:	d8f4      	bhi.n	80036a6 <USBD_StdDevReq+0x36>
  {
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    
    if (pdev->dev.DevRemoteWakeup) 
 80036bc:	f8d0 0114 	ldr.w	r0, [r0, #276]	; 0x114
 80036c0:	2800      	cmp	r0, #0
 80036c2:	d17e      	bne.n	80037c2 <USBD_StdDevReq+0x152>
    {
      USBD_cfg_status = USB_CONFIG_SELF_POWERED | USB_CONFIG_REMOTE_WAKEUP;                                
    }
    else
    {
      USBD_cfg_status = USB_CONFIG_SELF_POWERED;   
 80036c4:	4b8d      	ldr	r3, [pc, #564]	; (80038fc <USBD_StdDevReq+0x28c>)
 80036c6:	2001      	movs	r0, #1
 80036c8:	60d8      	str	r0, [r3, #12]
    }
    
    USBD_CtlSendData (pdev, 
 80036ca:	4628      	mov	r0, r5
 80036cc:	498c      	ldr	r1, [pc, #560]	; (8003900 <USBD_StdDevReq+0x290>)
 80036ce:	2201      	movs	r2, #1
 80036d0:	f7ff fea8 	bl	8003424 <USBD_CtlSendData>
 80036d4:	e7ea      	b.n	80036ac <USBD_StdDevReq+0x3c>
* @retval status
*/
static void USBD_ClrFeature(USB_OTG_CORE_HANDLE  *pdev, 
                            USB_SETUP_REQ *req)
{
  switch (pdev->dev.device_status)
 80036d6:	f890 2112 	ldrb.w	r2, [r0, #274]	; 0x112
 80036da:	1e91      	subs	r1, r2, #2
 80036dc:	2901      	cmp	r1, #1
 80036de:	d8e2      	bhi.n	80036a6 <USBD_StdDevReq+0x36>
  {
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 80036e0:	f8b4 c002 	ldrh.w	ip, [r4, #2]
 80036e4:	f1bc 0f01 	cmp.w	ip, #1
 80036e8:	d1e0      	bne.n	80036ac <USBD_StdDevReq+0x3c>
    {
      pdev->dev.DevRemoteWakeup = 0; 
      pdev->dev.class_cb->Setup (pdev, req);   
 80036ea:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
  {
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
    {
      pdev->dev.DevRemoteWakeup = 0; 
 80036ee:	2200      	movs	r2, #0
      pdev->dev.class_cb->Setup (pdev, req);   
 80036f0:	688b      	ldr	r3, [r1, #8]
  {
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
    {
      pdev->dev.DevRemoteWakeup = 0; 
 80036f2:	f8c0 2114 	str.w	r2, [r0, #276]	; 0x114
      pdev->dev.class_cb->Setup (pdev, req);   
 80036f6:	4621      	mov	r1, r4
 80036f8:	4798      	blx	r3
      USBD_CtlSendStatus(pdev);
 80036fa:	4628      	mov	r0, r5
 80036fc:	f7ff fec6 	bl	800348c <USBD_CtlSendStatus>
 8003700:	e7d4      	b.n	80036ac <USBD_StdDevReq+0x3c>
{

  USB_OTG_DCTL_TypeDef     dctl;
  uint8_t test_mode = 0;
 
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8003702:	8863      	ldrh	r3, [r4, #2]
 8003704:	2b01      	cmp	r3, #1
 8003706:	f000 811c 	beq.w	8003942 <USBD_StdDevReq+0x2d2>
    pdev->dev.DevRemoteWakeup = 1;  
    pdev->dev.class_cb->Setup (pdev, req);   
    USBD_CtlSendStatus(pdev);
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
 800370a:	2b02      	cmp	r3, #2
 800370c:	d1ce      	bne.n	80036ac <USBD_StdDevReq+0x3c>
           ((req->wIndex & 0xFF) == 0))
 800370e:	88a3      	ldrh	r3, [r4, #4]
    pdev->dev.DevRemoteWakeup = 1;  
    pdev->dev.class_cb->Setup (pdev, req);   
    USBD_CtlSendStatus(pdev);
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
 8003710:	f013 0fff 	tst.w	r3, #255	; 0xff
 8003714:	d1ca      	bne.n	80036ac <USBD_StdDevReq+0x3c>
           ((req->wIndex & 0xFF) == 0))
  {
    dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 8003716:	6901      	ldr	r1, [r0, #16]
    
    test_mode = req->wIndex >> 8;
    switch (test_mode) 
 8003718:	0a1c      	lsrs	r4, r3, #8
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
           ((req->wIndex & 0xFF) == 0))
  {
    dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 800371a:	684a      	ldr	r2, [r1, #4]
    
    test_mode = req->wIndex >> 8;
    switch (test_mode) 
 800371c:	1e63      	subs	r3, r4, #1
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
           ((req->wIndex & 0xFF) == 0))
  {
    dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 800371e:	4610      	mov	r0, r2
    
    test_mode = req->wIndex >> 8;
    switch (test_mode) 
 8003720:	2b04      	cmp	r3, #4
 8003722:	f200 80a4 	bhi.w	800386e <USBD_StdDevReq+0x1fe>
 8003726:	e8df f003 	tbb	[pc, r3]
 800372a:	b1a7      	.short	0xb1a7
 800372c:	b6ac      	.short	0xb6ac
 800372e:	9e          	.byte	0x9e
 800372f:	00          	.byte	0x00
static void USBD_SetAddress(USB_OTG_CORE_HANDLE  *pdev, 
                            USB_SETUP_REQ *req)
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 8003730:	88a3      	ldrh	r3, [r4, #4]
 8003732:	2b00      	cmp	r3, #0
 8003734:	d140      	bne.n	80037b8 <USBD_StdDevReq+0x148>
 8003736:	88e2      	ldrh	r2, [r4, #6]
 8003738:	2a00      	cmp	r2, #0
 800373a:	d13d      	bne.n	80037b8 <USBD_StdDevReq+0x148>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    
    if (pdev->dev.device_status == USB_OTG_CONFIGURED) 
 800373c:	f890 e112 	ldrb.w	lr, [r0, #274]	; 0x112
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8003740:	8862      	ldrh	r2, [r4, #2]
    
    if (pdev->dev.device_status == USB_OTG_CONFIGURED) 
 8003742:	f1be 0f03 	cmp.w	lr, #3
 8003746:	d0ae      	beq.n	80036a6 <USBD_StdDevReq+0x36>
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8003748:	f002 047f 	and.w	r4, r2, #127	; 0x7f
    {
      USBD_CtlError(pdev , req);
    } 
    else 
    {
      pdev->dev.device_address = dev_addr;
 800374c:	f880 4113 	strb.w	r4, [r0, #275]	; 0x113
      DCD_EP_SetAddress(pdev, dev_addr);               
 8003750:	4621      	mov	r1, r4
 8003752:	f7ff fa53 	bl	8002bfc <DCD_EP_SetAddress>
      USBD_CtlSendStatus(pdev);                         
 8003756:	4628      	mov	r0, r5
 8003758:	f7ff fe98 	bl	800348c <USBD_CtlSendStatus>
      
      if (dev_addr != 0) 
 800375c:	2c00      	cmp	r4, #0
 800375e:	f000 80ec 	beq.w	800393a <USBD_StdDevReq+0x2ca>
      {
        pdev->dev.device_status  = USB_OTG_ADDRESSED;
 8003762:	2002      	movs	r0, #2
 8003764:	f885 0112 	strb.w	r0, [r5, #274]	; 0x112
 8003768:	e7a0      	b.n	80036ac <USBD_StdDevReq+0x3c>
                               USB_SETUP_REQ *req)
{
  uint16_t len;
  uint8_t *pbuf;
  
  switch (req->wValue >> 8)
 800376a:	8862      	ldrh	r2, [r4, #2]
 800376c:	0a11      	lsrs	r1, r2, #8
 800376e:	1e4b      	subs	r3, r1, #1
 8003770:	2b06      	cmp	r3, #6
 8003772:	d898      	bhi.n	80036a6 <USBD_StdDevReq+0x36>
 8003774:	a101      	add	r1, pc, #4	; (adr r1, 800377c <USBD_StdDevReq+0x10c>)
 8003776:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 800377a:	bf00      	nop
 800377c:	0800381f 	.word	0x0800381f
 8003780:	080037e1 	.word	0x080037e1
 8003784:	080037cb 	.word	0x080037cb
 8003788:	080036a7 	.word	0x080036a7
 800378c:	080036a7 	.word	0x080036a7
 8003790:	080036a7 	.word	0x080036a7
 8003794:	080036a7 	.word	0x080036a7
*/
static void USBD_GetConfig(USB_OTG_CORE_HANDLE  *pdev, 
                           USB_SETUP_REQ *req)
{
 
  if (req->wLength != 1) 
 8003798:	88e2      	ldrh	r2, [r4, #6]
 800379a:	2a01      	cmp	r2, #1
 800379c:	d183      	bne.n	80036a6 <USBD_StdDevReq+0x36>
  {                   
     USBD_CtlError(pdev , req);
  }
  else 
  {
    switch (pdev->dev.device_status )  
 800379e:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 80037a2:	2b02      	cmp	r3, #2
 80037a4:	f000 80b7 	beq.w	8003916 <USBD_StdDevReq+0x2a6>
 80037a8:	2b03      	cmp	r3, #3
 80037aa:	f47f af7c 	bne.w	80036a6 <USBD_StdDevReq+0x36>
                        1);
      break;
      
    case USB_OTG_CONFIGURED:                   
      
      USBD_CtlSendData (pdev, 
 80037ae:	f500 7188 	add.w	r1, r0, #272	; 0x110
 80037b2:	f7ff fe37 	bl	8003424 <USBD_CtlSendData>
 80037b6:	e779      	b.n	80036ac <USBD_StdDevReq+0x3c>
      }
    }
  } 
  else 
  {
     USBD_CtlError(pdev , req);                        
 80037b8:	4628      	mov	r0, r5
 80037ba:	4621      	mov	r1, r4
 80037bc:	f7ff feb8 	bl	8003530 <USBD_CtlError>
 80037c0:	e774      	b.n	80036ac <USBD_StdDevReq+0x3c>
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    
    if (pdev->dev.DevRemoteWakeup) 
    {
      USBD_cfg_status = USB_CONFIG_SELF_POWERED | USB_CONFIG_REMOTE_WAKEUP;                                
 80037c2:	494e      	ldr	r1, [pc, #312]	; (80038fc <USBD_StdDevReq+0x28c>)
 80037c4:	2203      	movs	r2, #3
 80037c6:	60ca      	str	r2, [r1, #12]
 80037c8:	e77f      	b.n	80036ca <USBD_StdDevReq+0x5a>
    pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    pdev->dev.pConfig_descriptor = pbuf;    
    break;
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
 80037ca:	fa5f fc82 	uxtb.w	ip, r2
 80037ce:	f1bc 0f05 	cmp.w	ip, #5
 80037d2:	f63f af68 	bhi.w	80036a6 <USBD_StdDevReq+0x36>
 80037d6:	e8df f00c 	tbb	[pc, ip]
 80037da:	8795      	.short	0x8795
 80037dc:	636c757e 	.word	0x636c757e
      len = 8;
    }
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetConfigDescriptor(pdev->cfg.speed, &len);
 80037e0:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
 80037e4:	7880      	ldrb	r0, [r0, #2]
 80037e6:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 80037e8:	f10d 0106 	add.w	r1, sp, #6
 80037ec:	4798      	blx	r3
       (pdev->cfg.phy_itface  == USB_OTG_ULPI_PHY))
    {
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetOtherConfigDescriptor(pdev->cfg.speed, &len);
    }
#endif  
    pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 80037ee:	2202      	movs	r2, #2
 80037f0:	7042      	strb	r2, [r0, #1]
      len = 8;
    }
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetConfigDescriptor(pdev->cfg.speed, &len);
 80037f2:	4601      	mov	r1, r0
    {
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetOtherConfigDescriptor(pdev->cfg.speed, &len);
    }
#endif  
    pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    pdev->dev.pConfig_descriptor = pbuf;    
 80037f4:	f8c5 05ec 	str.w	r0, [r5, #1516]	; 0x5ec
  default: 
     USBD_CtlError(pdev , req);
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
 80037f8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80037fc:	2b00      	cmp	r3, #0
 80037fe:	f43f af55 	beq.w	80036ac <USBD_StdDevReq+0x3c>
 8003802:	88e2      	ldrh	r2, [r4, #6]
 8003804:	2a00      	cmp	r2, #0
 8003806:	f43f af51 	beq.w	80036ac <USBD_StdDevReq+0x3c>
  {
    
    len = MIN(len , req->wLength);
 800380a:	429a      	cmp	r2, r3
 800380c:	bf38      	it	cc
 800380e:	4613      	movcc	r3, r2
    
    USBD_CtlSendData (pdev, 
 8003810:	4628      	mov	r0, r5
 8003812:	461a      	mov	r2, r3
  }
  
  if((len != 0)&& (req->wLength != 0))
  {
    
    len = MIN(len , req->wLength);
 8003814:	f8ad 3006 	strh.w	r3, [sp, #6]
    
    USBD_CtlSendData (pdev, 
 8003818:	f7ff fe04 	bl	8003424 <USBD_CtlSendData>
 800381c:	e746      	b.n	80036ac <USBD_StdDevReq+0x3c>
  uint8_t *pbuf;
  
  switch (req->wValue >> 8)
  {
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->dev.usr_device->GetDeviceDescriptor(pdev->cfg.speed, &len);
 800381e:	f8d0 35e8 	ldr.w	r3, [r0, #1512]	; 0x5e8
 8003822:	7880      	ldrb	r0, [r0, #2]
 8003824:	681a      	ldr	r2, [r3, #0]
 8003826:	f10d 0106 	add.w	r1, sp, #6
 800382a:	4790      	blx	r2
    if ((req->wLength == 64) ||( pdev->dev.device_status == USB_OTG_DEFAULT))  
 800382c:	88e2      	ldrh	r2, [r4, #6]
 800382e:	2a40      	cmp	r2, #64	; 0x40
  uint8_t *pbuf;
  
  switch (req->wValue >> 8)
  {
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->dev.usr_device->GetDeviceDescriptor(pdev->cfg.speed, &len);
 8003830:	4601      	mov	r1, r0
    if ((req->wLength == 64) ||( pdev->dev.device_status == USB_OTG_DEFAULT))  
 8003832:	d003      	beq.n	800383c <USBD_StdDevReq+0x1cc>
 8003834:	f895 0112 	ldrb.w	r0, [r5, #274]	; 0x112
 8003838:	2801      	cmp	r0, #1
 800383a:	d1dd      	bne.n	80037f8 <USBD_StdDevReq+0x188>
  default: 
     USBD_CtlError(pdev , req);
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
 800383c:	2308      	movs	r3, #8
 800383e:	e7e1      	b.n	8003804 <USBD_StdDevReq+0x194>
         USBD_CtlSendStatus(pdev);
      }
      break;
      
    case USB_OTG_CONFIGURED:
      if (cfgidx == 0) 
 8003840:	2900      	cmp	r1, #0
 8003842:	f000 8089 	beq.w	8003958 <USBD_StdDevReq+0x2e8>
        pdev->dev.device_config = cfgidx;          
        USBD_ClrCfg(pdev , cfgidx);
        USBD_CtlSendStatus(pdev);
        
      } 
      else  if (cfgidx != pdev->dev.device_config) 
 8003846:	f890 1110 	ldrb.w	r1, [r0, #272]	; 0x110
 800384a:	2901      	cmp	r1, #1
 800384c:	d008      	beq.n	8003860 <USBD_StdDevReq+0x1f0>
      {
        /* Clear old configuration */
        USBD_ClrCfg(pdev , pdev->dev.device_config);
 800384e:	f7ff fde1 	bl	8003414 <USBD_ClrCfg>
        
        /* set new configuration */
        pdev->dev.device_config = cfgidx;
 8003852:	7931      	ldrb	r1, [r6, #4]
        USBD_SetCfg(pdev , cfgidx);
 8003854:	4628      	mov	r0, r5
      {
        /* Clear old configuration */
        USBD_ClrCfg(pdev , pdev->dev.device_config);
        
        /* set new configuration */
        pdev->dev.device_config = cfgidx;
 8003856:	f885 1110 	strb.w	r1, [r5, #272]	; 0x110
        USBD_SetCfg(pdev , cfgidx);
 800385a:	f7ff fdcf 	bl	80033fc <USBD_SetCfg>
        USBD_CtlSendStatus(pdev);
 800385e:	4628      	mov	r0, r5
 8003860:	f7ff fe14 	bl	800348c <USBD_CtlSendStatus>
 8003864:	e722      	b.n	80036ac <USBD_StdDevReq+0x3c>
    case 4: // TEST_PACKET
      dctl.b.tstctl = 4;
      break;
      
    case 5: // TEST_FORCE_ENABLE
      dctl.b.tstctl = 5;
 8003866:	2305      	movs	r3, #5
 8003868:	f363 1006 	bfi	r0, r3, #4, #3
 800386c:	4602      	mov	r2, r0
      break;
    }
    USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
 800386e:	604a      	str	r2, [r1, #4]
    USBD_CtlSendStatus(pdev);
 8003870:	4628      	mov	r0, r5
 8003872:	f7ff fe0b 	bl	800348c <USBD_CtlSendStatus>
 8003876:	e719      	b.n	80036ac <USBD_StdDevReq+0x3c>
    
    test_mode = req->wIndex >> 8;
    switch (test_mode) 
    {
    case 1: // TEST_J
      dctl.b.tstctl = 1;
 8003878:	2201      	movs	r2, #1
 800387a:	f362 1006 	bfi	r0, r2, #4, #3
 800387e:	4602      	mov	r2, r0
 8003880:	e7f5      	b.n	800386e <USBD_StdDevReq+0x1fe>
    case 2: // TEST_K	
      dctl.b.tstctl = 2;
      break;
      
    case 3: // TEST_SE0_NAK
      dctl.b.tstctl = 3;
 8003882:	2403      	movs	r4, #3
 8003884:	f364 1006 	bfi	r0, r4, #4, #3
 8003888:	4602      	mov	r2, r0
 800388a:	e7f0      	b.n	800386e <USBD_StdDevReq+0x1fe>
    case 1: // TEST_J
      dctl.b.tstctl = 1;
      break;
      
    case 2: // TEST_K	
      dctl.b.tstctl = 2;
 800388c:	2302      	movs	r3, #2
 800388e:	f363 1006 	bfi	r0, r3, #4, #3
 8003892:	4602      	mov	r2, r0
 8003894:	e7eb      	b.n	800386e <USBD_StdDevReq+0x1fe>
    case 3: // TEST_SE0_NAK
      dctl.b.tstctl = 3;
      break;
      
    case 4: // TEST_PACKET
      dctl.b.tstctl = 4;
 8003896:	2204      	movs	r2, #4
 8003898:	f362 1006 	bfi	r0, r2, #4, #3
 800389c:	4602      	mov	r2, r0
 800389e:	e7e6      	b.n	800386e <USBD_StdDevReq+0x1fe>
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->dev.usr_device->GetConfigurationStrDescriptor(pdev->cfg.speed, &len);
      break;
      
    case USBD_IDX_INTERFACE_STR:
      pbuf = pdev->dev.usr_device->GetInterfaceStrDescriptor(pdev->cfg.speed, &len);
 80038a0:	f8d0 15e8 	ldr.w	r1, [r0, #1512]	; 0x5e8
 80038a4:	7880      	ldrb	r0, [r0, #2]
 80038a6:	698a      	ldr	r2, [r1, #24]
 80038a8:	f10d 0106 	add.w	r1, sp, #6
 80038ac:	4790      	blx	r2
 80038ae:	4601      	mov	r1, r0
 80038b0:	e7a2      	b.n	80037f8 <USBD_StdDevReq+0x188>
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->dev.usr_device->GetSerialStrDescriptor(pdev->cfg.speed, &len);
      break;
      
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->dev.usr_device->GetConfigurationStrDescriptor(pdev->cfg.speed, &len);
 80038b2:	f8d0 35e8 	ldr.w	r3, [r0, #1512]	; 0x5e8
 80038b6:	7880      	ldrb	r0, [r0, #2]
 80038b8:	695a      	ldr	r2, [r3, #20]
 80038ba:	f10d 0106 	add.w	r1, sp, #6
 80038be:	4790      	blx	r2
 80038c0:	4601      	mov	r1, r0
 80038c2:	e799      	b.n	80037f8 <USBD_StdDevReq+0x188>
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->dev.usr_device->GetProductStrDescriptor(pdev->cfg.speed, &len);
      break;
      
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->dev.usr_device->GetSerialStrDescriptor(pdev->cfg.speed, &len);
 80038c4:	f8d0 15e8 	ldr.w	r1, [r0, #1512]	; 0x5e8
 80038c8:	7880      	ldrb	r0, [r0, #2]
 80038ca:	690b      	ldr	r3, [r1, #16]
 80038cc:	f10d 0106 	add.w	r1, sp, #6
 80038d0:	4798      	blx	r3
 80038d2:	4601      	mov	r1, r0
 80038d4:	e790      	b.n	80037f8 <USBD_StdDevReq+0x188>
    case USBD_IDX_MFC_STR:
      pbuf = pdev->dev.usr_device->GetManufacturerStrDescriptor(pdev->cfg.speed, &len);
      break;
      
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->dev.usr_device->GetProductStrDescriptor(pdev->cfg.speed, &len);
 80038d6:	f8d0 25e8 	ldr.w	r2, [r0, #1512]	; 0x5e8
 80038da:	7880      	ldrb	r0, [r0, #2]
 80038dc:	68d3      	ldr	r3, [r2, #12]
 80038de:	f10d 0106 	add.w	r1, sp, #6
 80038e2:	4798      	blx	r3
 80038e4:	4601      	mov	r1, r0
 80038e6:	e787      	b.n	80037f8 <USBD_StdDevReq+0x188>
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->dev.usr_device->GetLangIDStrDescriptor(pdev->cfg.speed, &len);        
      break;
      
    case USBD_IDX_MFC_STR:
      pbuf = pdev->dev.usr_device->GetManufacturerStrDescriptor(pdev->cfg.speed, &len);
 80038e8:	f8d0 15e8 	ldr.w	r1, [r0, #1512]	; 0x5e8
 80038ec:	7880      	ldrb	r0, [r0, #2]
 80038ee:	688a      	ldr	r2, [r1, #8]
 80038f0:	f10d 0106 	add.w	r1, sp, #6
 80038f4:	4790      	blx	r2
 80038f6:	4601      	mov	r1, r0
 80038f8:	e77e      	b.n	80037f8 <USBD_StdDevReq+0x188>
 80038fa:	bf00      	nop
 80038fc:	20000e30 	.word	0x20000e30
 8003900:	20000e3c 	.word	0x20000e3c
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
    {
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->dev.usr_device->GetLangIDStrDescriptor(pdev->cfg.speed, &len);        
 8003904:	f8d0 35e8 	ldr.w	r3, [r0, #1512]	; 0x5e8
 8003908:	7880      	ldrb	r0, [r0, #2]
 800390a:	685a      	ldr	r2, [r3, #4]
 800390c:	f10d 0106 	add.w	r1, sp, #6
 8003910:	4790      	blx	r2
 8003912:	4601      	mov	r1, r0
 8003914:	e770      	b.n	80037f8 <USBD_StdDevReq+0x188>
  {
    switch (pdev->dev.device_status )  
    {
    case USB_OTG_ADDRESSED:                     
      
      USBD_CtlSendData (pdev, 
 8003916:	4916      	ldr	r1, [pc, #88]	; (8003970 <USBD_StdDevReq+0x300>)
 8003918:	f7ff fd84 	bl	8003424 <USBD_CtlSendData>
 800391c:	e6c6      	b.n	80036ac <USBD_StdDevReq+0x3c>
  else 
  {
    switch (pdev->dev.device_status) 
    {
    case USB_OTG_ADDRESSED:
      if (cfgidx) 
 800391e:	2900      	cmp	r1, #0
 8003920:	d09e      	beq.n	8003860 <USBD_StdDevReq+0x1f0>
      {                                			   							   							   				
        pdev->dev.device_config = cfgidx;
 8003922:	2101      	movs	r1, #1
        pdev->dev.device_status = USB_OTG_CONFIGURED;
 8003924:	2303      	movs	r3, #3
    switch (pdev->dev.device_status) 
    {
    case USB_OTG_ADDRESSED:
      if (cfgidx) 
      {                                			   							   							   				
        pdev->dev.device_config = cfgidx;
 8003926:	f880 1110 	strb.w	r1, [r0, #272]	; 0x110
        pdev->dev.device_status = USB_OTG_CONFIGURED;
 800392a:	f880 3112 	strb.w	r3, [r0, #274]	; 0x112
        USBD_SetCfg(pdev , cfgidx);
 800392e:	f7ff fd65 	bl	80033fc <USBD_SetCfg>
        USBD_CtlSendStatus(pdev);
 8003932:	4628      	mov	r0, r5
 8003934:	f7ff fdaa 	bl	800348c <USBD_CtlSendStatus>
 8003938:	e6b8      	b.n	80036ac <USBD_StdDevReq+0x3c>
      {
        pdev->dev.device_status  = USB_OTG_ADDRESSED;
      } 
      else 
      {
        pdev->dev.device_status  = USB_OTG_DEFAULT; 
 800393a:	2101      	movs	r1, #1
 800393c:	f885 1112 	strb.w	r1, [r5, #274]	; 0x112
 8003940:	e6b4      	b.n	80036ac <USBD_StdDevReq+0x3c>
  uint8_t test_mode = 0;
 
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
  {
    pdev->dev.DevRemoteWakeup = 1;  
    pdev->dev.class_cb->Setup (pdev, req);   
 8003942:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
  USB_OTG_DCTL_TypeDef     dctl;
  uint8_t test_mode = 0;
 
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
  {
    pdev->dev.DevRemoteWakeup = 1;  
 8003946:	f8c0 3114 	str.w	r3, [r0, #276]	; 0x114
    pdev->dev.class_cb->Setup (pdev, req);   
 800394a:	688a      	ldr	r2, [r1, #8]
 800394c:	4621      	mov	r1, r4
 800394e:	4790      	blx	r2
    USBD_CtlSendStatus(pdev);
 8003950:	4628      	mov	r0, r5
        USBD_ClrCfg(pdev , pdev->dev.device_config);
        
        /* set new configuration */
        pdev->dev.device_config = cfgidx;
        USBD_SetCfg(pdev , cfgidx);
        USBD_CtlSendStatus(pdev);
 8003952:	f7ff fd9b 	bl	800348c <USBD_CtlSendStatus>
 8003956:	e6a9      	b.n	80036ac <USBD_StdDevReq+0x3c>
      break;
      
    case USB_OTG_CONFIGURED:
      if (cfgidx == 0) 
      {                           
        pdev->dev.device_status = USB_OTG_ADDRESSED;
 8003958:	2202      	movs	r2, #2
 800395a:	f880 2112 	strb.w	r2, [r0, #274]	; 0x112
        pdev->dev.device_config = cfgidx;          
 800395e:	f880 1110 	strb.w	r1, [r0, #272]	; 0x110
        USBD_ClrCfg(pdev , cfgidx);
 8003962:	f7ff fd57 	bl	8003414 <USBD_ClrCfg>
        USBD_CtlSendStatus(pdev);
 8003966:	4628      	mov	r0, r5
 8003968:	f7ff fd90 	bl	800348c <USBD_CtlSendStatus>
 800396c:	e69e      	b.n	80036ac <USBD_StdDevReq+0x3c>
 800396e:	bf00      	nop
 8003970:	20000e38 	.word	0x20000e38

08003974 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 8003974:	b430      	push	{r4, r5}
  uint8_t idx = 0;
  
  if (desc != NULL) 
 8003976:	b1f8      	cbz	r0, 80039b8 <USBD_GetString+0x44>
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != NULL) 
 8003978:	7803      	ldrb	r3, [r0, #0]
 800397a:	2b00      	cmp	r3, #0
 800397c:	d01e      	beq.n	80039bc <USBD_GetString+0x48>
 800397e:	4604      	mov	r4, r0
 8003980:	2300      	movs	r3, #0
 8003982:	f814 5f01 	ldrb.w	r5, [r4, #1]!
    {
        len++;
 8003986:	3301      	adds	r3, #1
 8003988:	b2db      	uxtb	r3, r3
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != NULL) 
 800398a:	2d00      	cmp	r5, #0
 800398c:	d1f9      	bne.n	8003982 <USBD_GetString+0xe>
 800398e:	005c      	lsls	r4, r3, #1
 8003990:	1ca3      	adds	r3, r4, #2
 8003992:	b2dc      	uxtb	r4, r3
{
  uint8_t idx = 0;
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
 8003994:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 8003996:	2203      	movs	r2, #3
  uint8_t idx = 0;
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
 8003998:	700c      	strb	r4, [r1, #0]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 800399a:	704a      	strb	r2, [r1, #1]
    
    while (*desc != NULL) 
 800399c:	7802      	ldrb	r2, [r0, #0]
 800399e:	b15a      	cbz	r2, 80039b8 <USBD_GetString+0x44>
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 80039a0:	2302      	movs	r3, #2
    
    while (*desc != NULL) 
    {
      unicode[idx++] = *desc++;
      unicode[idx++] =  0x00;
 80039a2:	2500      	movs	r5, #0
 80039a4:	1c5c      	adds	r4, r3, #1
 80039a6:	b2e4      	uxtb	r4, r4
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
    
    while (*desc != NULL) 
    {
      unicode[idx++] = *desc++;
 80039a8:	54ca      	strb	r2, [r1, r3]
      unicode[idx++] =  0x00;
 80039aa:	550d      	strb	r5, [r1, r4]
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
    
    while (*desc != NULL) 
 80039ac:	f810 2f01 	ldrb.w	r2, [r0, #1]!
    {
      unicode[idx++] = *desc++;
      unicode[idx++] =  0x00;
 80039b0:	3302      	adds	r3, #2
 80039b2:	b2db      	uxtb	r3, r3
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
    
    while (*desc != NULL) 
 80039b4:	2a00      	cmp	r2, #0
 80039b6:	d1f5      	bne.n	80039a4 <USBD_GetString+0x30>
    {
      unicode[idx++] = *desc++;
      unicode[idx++] =  0x00;
    }
  } 
}
 80039b8:	bc30      	pop	{r4, r5}
 80039ba:	4770      	bx	lr
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != NULL) 
 80039bc:	2402      	movs	r4, #2
 80039be:	4623      	mov	r3, r4
 80039c0:	e7e8      	b.n	8003994 <USBD_GetString+0x20>
 80039c2:	bf00      	nop

080039c4 <USB_OTG_BSP_ConfigVBUS>:
#include "stm32f4xx_conf.h"


void USB_OTG_BSP_ConfigVBUS(USB_OTG_CORE_HANDLE *pdev) {

}
 80039c4:	4770      	bx	lr

080039c6 <USB_OTG_BSP_DriveVBUS>:

void USB_OTG_BSP_DriveVBUS(USB_OTG_CORE_HANDLE *pdev,uint8_t state) {

}
 80039c6:	4770      	bx	lr

080039c8 <USB_OTG_BSP_Init>:
* @param  None
* @retval None
*/

void USB_OTG_BSP_Init(USB_OTG_CORE_HANDLE *pdev)
{
 80039c8:	b537      	push	{r0, r1, r2, r4, r5, lr}
#endif


 #ifdef USE_USB_OTG_FS

  RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOA , ENABLE);
 80039ca:	2001      	movs	r0, #1
 80039cc:	4601      	mov	r1, r0
 80039ce:	f7fd fc93 	bl	80012f8 <RCC_AHB1PeriphClockCmd>

  /* Configure SOF VBUS ID DM DP Pins */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8  |
 80039d2:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
 80039d6:	9300      	str	r3, [sp, #0]
    GPIO_Pin_9  |
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80039d8:	2302      	movs	r3, #2
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8  |
    GPIO_Pin_9  |
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 80039da:	2503      	movs	r5, #3
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80039dc:	f88d 3004 	strb.w	r3, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 80039e0:	4669      	mov	r1, sp
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80039e2:	3b02      	subs	r3, #2
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 80039e4:	4820      	ldr	r0, [pc, #128]	; (8003a68 <USB_OTG_BSP_Init+0xa0>)
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80039e6:	f88d 3006 	strb.w	r3, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 80039ea:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8  |
    GPIO_Pin_9  |
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 80039ee:	f88d 5005 	strb.w	r5, [sp, #5]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 80039f2:	f7fd fec1 	bl	8001778 <GPIO_Init>

  GPIO_PinAFConfig(GPIOA,GPIO_PinSource8,GPIO_AF_OTG1_FS) ;
 80039f6:	2108      	movs	r1, #8
 80039f8:	220a      	movs	r2, #10
 80039fa:	481b      	ldr	r0, [pc, #108]	; (8003a68 <USB_OTG_BSP_Init+0xa0>)
 80039fc:	f7fd ffb4 	bl	8001968 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_OTG1_FS) ;
 8003a00:	2109      	movs	r1, #9
 8003a02:	220a      	movs	r2, #10
 8003a04:	4818      	ldr	r0, [pc, #96]	; (8003a68 <USB_OTG_BSP_Init+0xa0>)
 8003a06:	f7fd ffaf 	bl	8001968 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource11,GPIO_AF_OTG1_FS) ;
 8003a0a:	210b      	movs	r1, #11
 8003a0c:	220a      	movs	r2, #10
 8003a0e:	4816      	ldr	r0, [pc, #88]	; (8003a68 <USB_OTG_BSP_Init+0xa0>)
 8003a10:	f7fd ffaa 	bl	8001968 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;
 8003a14:	220a      	movs	r2, #10
 8003a16:	210c      	movs	r1, #12
 8003a18:	4813      	ldr	r0, [pc, #76]	; (8003a68 <USB_OTG_BSP_Init+0xa0>)
 8003a1a:	f7fd ffa5 	bl	8001968 <GPIO_PinAFConfig>

  /* this for ID line debug */


  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 8003a1e:	2401      	movs	r4, #1
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;

  /* this for ID line debug */


  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
 8003a20:	f44f 6380 	mov.w	r3, #1024	; 0x400
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8003a24:	4669      	mov	r1, sp
 8003a26:	4810      	ldr	r0, [pc, #64]	; (8003a68 <USB_OTG_BSP_Init+0xa0>)
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;

  /* this for ID line debug */


  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
 8003a28:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 8003a2a:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
 8003a2e:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8003a32:	f88d 5005 	strb.w	r5, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8003a36:	f7fd fe9f 	bl	8001778 <GPIO_Init>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_OTG1_FS) ;
 8003a3a:	210a      	movs	r1, #10
 8003a3c:	460a      	mov	r2, r1
 8003a3e:	480a      	ldr	r0, [pc, #40]	; (8003a68 <USB_OTG_BSP_Init+0xa0>)
 8003a40:	f7fd ff92 	bl	8001968 <GPIO_PinAFConfig>

  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 8003a44:	4621      	mov	r1, r4
 8003a46:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8003a4a:	f7fd fc8d 	bl	8001368 <RCC_APB2PeriphClockCmd>
  RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_OTG_FS, ENABLE) ;
 8003a4e:	2080      	movs	r0, #128	; 0x80
 8003a50:	4621      	mov	r1, r4
 8003a52:	f7fd fc5f 	bl	8001314 <RCC_AHB2PeriphClockCmd>

 #endif //USB_OTG_HS


  /* enable the PWR clock */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
 8003a56:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8003a5a:	4621      	mov	r1, r4
 8003a5c:	f7fd fcbc 	bl	80013d8 <RCC_APB1PeriphResetCmd>
  NVIC_Init(&NVIC_InitStructure);

  EXTI_ClearITPendingBit(EXTI_Line20);
#endif

  EXTI_ClearITPendingBit(EXTI_Line0);
 8003a60:	4620      	mov	r0, r4
 8003a62:	f7fd fdf7 	bl	8001654 <EXTI_ClearITPendingBit>
}
 8003a66:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8003a68:	40020000 	.word	0x40020000

08003a6c <USB_OTG_BSP_EnableInterrupt>:
*         Enabele USB Global interrupt
* @param  None
* @retval None
*/
void USB_OTG_BSP_EnableInterrupt(USB_OTG_CORE_HANDLE *pdev)
{
 8003a6c:	b507      	push	{r0, r1, r2, lr}
  NVIC_InitTypeDef NVIC_InitStructure;

  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
 8003a6e:	f44f 60c0 	mov.w	r0, #1536	; 0x600
 8003a72:	f000 f8f5 	bl	8003c60 <NVIC_PriorityGroupConfig>
#ifdef USE_USB_OTG_HS
  NVIC_InitStructure.NVIC_IRQChannel = OTG_HS_IRQn;
#else
  NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;
 8003a76:	2343      	movs	r3, #67	; 0x43
 8003a78:	f88d 3004 	strb.w	r3, [sp, #4]
#endif
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 11;
 8003a7c:	3b38      	subs	r3, #56	; 0x38
 8003a7e:	f88d 3005 	strb.w	r3, [sp, #5]
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
 8003a82:	3b08      	subs	r3, #8
 8003a84:	f88d 3006 	strb.w	r3, [sp, #6]
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
 8003a88:	a801      	add	r0, sp, #4
#else
  NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;
#endif
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 11;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8003a8a:	3b02      	subs	r3, #2
 8003a8c:	f88d 3007 	strb.w	r3, [sp, #7]
  NVIC_Init(&NVIC_InitStructure);
 8003a90:	f000 f8f0 	bl	8003c74 <NVIC_Init>
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 11;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
#endif
}
 8003a94:	bd0e      	pop	{r1, r2, r3, pc}

08003a96 <USB_OTG_BSP_uDelay>:
* @retval None
*/
void USB_OTG_BSP_uDelay (const uint32_t usec)
{
  uint32_t count = 0;
  const uint32_t utime = (120 * usec / 7);
 8003a96:	2378      	movs	r3, #120	; 0x78
 8003a98:	2207      	movs	r2, #7
 8003a9a:	4343      	muls	r3, r0
 8003a9c:	fbb3 f3f2 	udiv	r3, r3, r2
* @param  usec : Value of delay required in micro sec
* @retval None
*/
void USB_OTG_BSP_uDelay (const uint32_t usec)
{
  uint32_t count = 0;
 8003aa0:	3a07      	subs	r2, #7
  const uint32_t utime = (120 * usec / 7);
  do
  {
    if ( ++count > utime )
 8003aa2:	3201      	adds	r2, #1
 8003aa4:	429a      	cmp	r2, r3
 8003aa6:	d9fc      	bls.n	8003aa2 <USB_OTG_BSP_uDelay+0xc>
    {
      return ;
    }
  }
  while (1);
}
 8003aa8:	4770      	bx	lr

08003aaa <USB_OTG_BSP_mDelay>:
* @param  msec : Value of delay required in milli sec
* @retval None
*/
void USB_OTG_BSP_mDelay (const uint32_t msec)
{
  USB_OTG_BSP_uDelay(msec * 1000);
 8003aaa:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8003aae:	4358      	muls	r0, r3
 8003ab0:	e7f1      	b.n	8003a96 <USB_OTG_BSP_uDelay>
 8003ab2:	bf00      	nop

08003ab4 <VCP_Init>:
 * @param  None
 * @retval Result of the opeartion (USBD_OK in all cases)
 */
static uint16_t VCP_Init(void) {
	return USBD_OK;
}
 8003ab4:	2000      	movs	r0, #0
 8003ab6:	4770      	bx	lr

08003ab8 <VCP_DeInit>:
 * @param  None
 * @retval Result of the opeartion (USBD_OK in all cases)
 */
static uint16_t VCP_DeInit(void) {
	return USBD_OK;
}
 8003ab8:	2000      	movs	r0, #0
 8003aba:	4770      	bx	lr

08003abc <VCP_Ctrl>:
 * @param  Buf: Buffer containing command data (request parameters)
 * @param  Len: Number of data to be sent (in bytes)
 * @retval Result of the opeartion (USBD_OK in all cases)
 */
static uint16_t VCP_Ctrl(uint32_t Cmd, uint8_t* Buf, uint32_t Len) {
	switch (Cmd) {
 8003abc:	2821      	cmp	r0, #33	; 0x21
 8003abe:	d10f      	bne.n	8003ae0 <VCP_Ctrl+0x24>
	case SET_LINE_CODING:
		/* Not  needed for this driver */
		break;

	case GET_LINE_CODING:
		Buf[0] = (uint8_t) (linecoding.bitrate);
 8003ac0:	4b08      	ldr	r3, [pc, #32]	; (8003ae4 <VCP_Ctrl+0x28>)
 8003ac2:	681a      	ldr	r2, [r3, #0]
 8003ac4:	700a      	strb	r2, [r1, #0]
		Buf[1] = (uint8_t) (linecoding.bitrate >> 8);
 8003ac6:	681a      	ldr	r2, [r3, #0]
 8003ac8:	0a12      	lsrs	r2, r2, #8
 8003aca:	704a      	strb	r2, [r1, #1]
		Buf[2] = (uint8_t) (linecoding.bitrate >> 16);
 8003acc:	885a      	ldrh	r2, [r3, #2]
 8003ace:	708a      	strb	r2, [r1, #2]
		Buf[3] = (uint8_t) (linecoding.bitrate >> 24);
 8003ad0:	78da      	ldrb	r2, [r3, #3]
 8003ad2:	70ca      	strb	r2, [r1, #3]
		Buf[4] = linecoding.format;
 8003ad4:	791a      	ldrb	r2, [r3, #4]
 8003ad6:	710a      	strb	r2, [r1, #4]
		Buf[5] = linecoding.paritytype;
 8003ad8:	795a      	ldrb	r2, [r3, #5]
 8003ada:	714a      	strb	r2, [r1, #5]
		Buf[6] = linecoding.datatype;
 8003adc:	799b      	ldrb	r3, [r3, #6]
 8003ade:	718b      	strb	r3, [r1, #6]
	default:
		break;
	}

	return USBD_OK;
}
 8003ae0:	2000      	movs	r0, #0
 8003ae2:	4770      	bx	lr
 8003ae4:	20000134 	.word	0x20000134

08003ae8 <VCP_DataTx>:
 *         this function.
 * @param  Buf: Buffer of data to be sent
 * @param  Len: Number of data to be sent (in bytes)
 * @retval Result of the opeartion: USBD_OK if all operations are OK else VCP_FAIL
 */
static uint16_t VCP_DataTx(uint8_t* Buf, uint32_t Len) {
 8003ae8:	b570      	push	{r4, r5, r6, lr}
	uint32_t i = 0;
 8003aea:	2300      	movs	r3, #0
	while (i < Len) {
 8003aec:	e00c      	b.n	8003b08 <VCP_DataTx+0x20>
		APP_Rx_Buffer[APP_Rx_ptr_in] = *(Buf + i);
 8003aee:	4a08      	ldr	r2, [pc, #32]	; (8003b10 <VCP_DataTx+0x28>)
 8003af0:	5cc6      	ldrb	r6, [r0, r3]
 8003af2:	6814      	ldr	r4, [r2, #0]
 8003af4:	4d07      	ldr	r5, [pc, #28]	; (8003b14 <VCP_DataTx+0x2c>)
 8003af6:	552e      	strb	r6, [r5, r4]
		APP_Rx_ptr_in++;
 8003af8:	3401      	adds	r4, #1
		i++;
 8003afa:	3301      	adds	r3, #1
		/* To avoid buffer overflow */
		if (APP_Rx_ptr_in == APP_RX_DATA_SIZE) {
 8003afc:	f5b4 6f00 	cmp.w	r4, #2048	; 0x800
 */
static uint16_t VCP_DataTx(uint8_t* Buf, uint32_t Len) {
	uint32_t i = 0;
	while (i < Len) {
		APP_Rx_Buffer[APP_Rx_ptr_in] = *(Buf + i);
		APP_Rx_ptr_in++;
 8003b00:	6014      	str	r4, [r2, #0]
		i++;
		/* To avoid buffer overflow */
		if (APP_Rx_ptr_in == APP_RX_DATA_SIZE) {
 8003b02:	d101      	bne.n	8003b08 <VCP_DataTx+0x20>
			APP_Rx_ptr_in = 0;
 8003b04:	2400      	movs	r4, #0
 8003b06:	6014      	str	r4, [r2, #0]
 * @param  Len: Number of data to be sent (in bytes)
 * @retval Result of the opeartion: USBD_OK if all operations are OK else VCP_FAIL
 */
static uint16_t VCP_DataTx(uint8_t* Buf, uint32_t Len) {
	uint32_t i = 0;
	while (i < Len) {
 8003b08:	428b      	cmp	r3, r1
 8003b0a:	d1f0      	bne.n	8003aee <VCP_DataTx+0x6>
			APP_Rx_ptr_in = 0;
		}
	}

	return USBD_OK;
}
 8003b0c:	2000      	movs	r0, #0
 8003b0e:	bd70      	pop	{r4, r5, r6, pc}
 8003b10:	20000e24 	.word	0x20000e24
 8003b14:	200021c0 	.word	0x200021c0

08003b18 <VCP_DataRx>:
		APP_Tx_Buffer[APP_tx_ptr_head] = *(Buf + i);
		APP_tx_ptr_head++;
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
			APP_tx_ptr_head = 0;

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8003b18:	4b0c      	ldr	r3, [pc, #48]	; (8003b4c <VCP_DataRx+0x34>)
#define APP_TX_BUF_SIZE 128
uint8_t APP_Tx_Buffer[APP_TX_BUF_SIZE];
uint32_t APP_tx_ptr_head;
uint32_t APP_tx_ptr_tail;

static uint16_t VCP_DataRx(uint8_t* Buf, uint32_t Len) {
 8003b1a:	b5f0      	push	{r4, r5, r6, r7, lr}
		APP_Tx_Buffer[APP_tx_ptr_head] = *(Buf + i);
		APP_tx_ptr_head++;
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
			APP_tx_ptr_head = 0;

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8003b1c:	681d      	ldr	r5, [r3, #0]
uint32_t APP_tx_ptr_tail;

static uint16_t VCP_DataRx(uint8_t* Buf, uint32_t Len) {
	uint32_t i;

	for (i = 0; i < Len; i++) {
 8003b1e:	2300      	movs	r3, #0
 8003b20:	e00e      	b.n	8003b40 <VCP_DataRx+0x28>
		APP_Tx_Buffer[APP_tx_ptr_head] = *(Buf + i);
 8003b22:	4a0b      	ldr	r2, [pc, #44]	; (8003b50 <VCP_DataRx+0x38>)
 8003b24:	5cc7      	ldrb	r7, [r0, r3]
 8003b26:	6814      	ldr	r4, [r2, #0]
 8003b28:	4e0a      	ldr	r6, [pc, #40]	; (8003b54 <VCP_DataRx+0x3c>)
 8003b2a:	5537      	strb	r7, [r6, r4]
		APP_tx_ptr_head++;
 8003b2c:	3401      	adds	r4, #1
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
 8003b2e:	2c80      	cmp	r4, #128	; 0x80
static uint16_t VCP_DataRx(uint8_t* Buf, uint32_t Len) {
	uint32_t i;

	for (i = 0; i < Len; i++) {
		APP_Tx_Buffer[APP_tx_ptr_head] = *(Buf + i);
		APP_tx_ptr_head++;
 8003b30:	6014      	str	r4, [r2, #0]
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
 8003b32:	d101      	bne.n	8003b38 <VCP_DataRx+0x20>
			APP_tx_ptr_head = 0;
 8003b34:	3c80      	subs	r4, #128	; 0x80
 8003b36:	6014      	str	r4, [r2, #0]

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8003b38:	6812      	ldr	r2, [r2, #0]
 8003b3a:	42aa      	cmp	r2, r5
 8003b3c:	d004      	beq.n	8003b48 <VCP_DataRx+0x30>
uint32_t APP_tx_ptr_tail;

static uint16_t VCP_DataRx(uint8_t* Buf, uint32_t Len) {
	uint32_t i;

	for (i = 0; i < Len; i++) {
 8003b3e:	3301      	adds	r3, #1
 8003b40:	428b      	cmp	r3, r1
 8003b42:	d1ee      	bne.n	8003b22 <VCP_DataRx+0xa>

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
			return USBD_FAIL;
	}

	return USBD_OK;
 8003b44:	2000      	movs	r0, #0
 8003b46:	bdf0      	pop	{r4, r5, r6, r7, pc}
		APP_tx_ptr_head++;
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
			APP_tx_ptr_head = 0;

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
			return USBD_FAIL;
 8003b48:	2002      	movs	r0, #2
	}

	return USBD_OK;
}
 8003b4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003b4c:	20002a74 	.word	0x20002a74
 8003b50:	20002a88 	.word	0x20002a88
 8003b54:	200029f4 	.word	0x200029f4

08003b58 <VCP_put_char>:
 *         Sends one char over the USB serial link.
 * @param  buf: char to be sent
 * @retval none
 */

void VCP_put_char(uint8_t buf) {
 8003b58:	b507      	push	{r0, r1, r2, lr}
 8003b5a:	ab02      	add	r3, sp, #8
	VCP_DataTx(&buf, 1);
 8003b5c:	2101      	movs	r1, #1
 *         Sends one char over the USB serial link.
 * @param  buf: char to be sent
 * @retval none
 */

void VCP_put_char(uint8_t buf) {
 8003b5e:	f803 0d01 	strb.w	r0, [r3, #-1]!
	VCP_DataTx(&buf, 1);
 8003b62:	4618      	mov	r0, r3
 8003b64:	f7ff ffc0 	bl	8003ae8 <VCP_DataTx>
}
 8003b68:	bd0e      	pop	{r1, r2, r3, pc}

08003b6a <VCP_send_str>:

void VCP_send_str(uint8_t* buf) {
	uint32_t i = 0;
 8003b6a:	2100      	movs	r1, #0
	while (*(buf + i)) {
 8003b6c:	e000      	b.n	8003b70 <VCP_send_str+0x6>
		i++;
 8003b6e:	3101      	adds	r1, #1
	VCP_DataTx(&buf, 1);
}

void VCP_send_str(uint8_t* buf) {
	uint32_t i = 0;
	while (*(buf + i)) {
 8003b70:	5c43      	ldrb	r3, [r0, r1]
 8003b72:	2b00      	cmp	r3, #0
 8003b74:	d1fb      	bne.n	8003b6e <VCP_send_str+0x4>
		i++;
	}
	VCP_DataTx(buf, i);
 8003b76:	e7b7      	b.n	8003ae8 <VCP_DataTx>

08003b78 <VCP_send_buffer>:
}

void VCP_send_buffer(uint8_t* buf, int len) {
	VCP_DataTx(buf, len);
 8003b78:	e7b6      	b.n	8003ae8 <VCP_DataTx>

08003b7a <VCP_get_char_test>:

	return USBD_OK;
}

int VCP_get_char_test(void) {
	return APP_tx_ptr_head != APP_tx_ptr_tail;
 8003b7a:	4b04      	ldr	r3, [pc, #16]	; (8003b8c <VCP_get_char_test+0x12>)
 8003b7c:	6818      	ldr	r0, [r3, #0]
 8003b7e:	4b04      	ldr	r3, [pc, #16]	; (8003b90 <VCP_get_char_test+0x16>)
 8003b80:	681b      	ldr	r3, [r3, #0]
}
 8003b82:	1ac0      	subs	r0, r0, r3
 8003b84:	bf18      	it	ne
 8003b86:	2001      	movne	r0, #1
 8003b88:	4770      	bx	lr
 8003b8a:	bf00      	nop
 8003b8c:	20002a88 	.word	0x20002a88
 8003b90:	20002a74 	.word	0x20002a74

08003b94 <VCP_get_char>:

int VCP_get_char(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8003b94:	4b0a      	ldr	r3, [pc, #40]	; (8003bc0 <VCP_get_char+0x2c>)
 8003b96:	490b      	ldr	r1, [pc, #44]	; (8003bc4 <VCP_get_char+0x30>)
 8003b98:	681a      	ldr	r2, [r3, #0]
 8003b9a:	6809      	ldr	r1, [r1, #0]
 8003b9c:	4291      	cmp	r1, r2
 8003b9e:	d00b      	beq.n	8003bb8 <VCP_get_char+0x24>
		return 0;

	*buf = APP_Tx_Buffer[APP_tx_ptr_tail];
 8003ba0:	4909      	ldr	r1, [pc, #36]	; (8003bc8 <VCP_get_char+0x34>)
 8003ba2:	5c8a      	ldrb	r2, [r1, r2]
 8003ba4:	7002      	strb	r2, [r0, #0]
	APP_tx_ptr_tail++;
 8003ba6:	681a      	ldr	r2, [r3, #0]
 8003ba8:	3201      	adds	r2, #1
	if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
 8003baa:	2a80      	cmp	r2, #128	; 0x80
int VCP_get_char(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
		return 0;

	*buf = APP_Tx_Buffer[APP_tx_ptr_tail];
	APP_tx_ptr_tail++;
 8003bac:	601a      	str	r2, [r3, #0]
	if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
 8003bae:	d105      	bne.n	8003bbc <VCP_get_char+0x28>
		APP_tx_ptr_tail = 0;
 8003bb0:	3a80      	subs	r2, #128	; 0x80
 8003bb2:	601a      	str	r2, [r3, #0]

	return 1;
 8003bb4:	2001      	movs	r0, #1
 8003bb6:	4770      	bx	lr
	return APP_tx_ptr_head != APP_tx_ptr_tail;
}

int VCP_get_char(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
		return 0;
 8003bb8:	2000      	movs	r0, #0
 8003bba:	4770      	bx	lr
	*buf = APP_Tx_Buffer[APP_tx_ptr_tail];
	APP_tx_ptr_tail++;
	if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
		APP_tx_ptr_tail = 0;

	return 1;
 8003bbc:	2001      	movs	r0, #1
}
 8003bbe:	4770      	bx	lr
 8003bc0:	20002a74 	.word	0x20002a74
 8003bc4:	20002a88 	.word	0x20002a88
 8003bc8:	200029f4 	.word	0x200029f4

08003bcc <VCP_get_string>:

int VCP_get_string(uint8_t *buf) {
 8003bcc:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8003bce:	4a1f      	ldr	r2, [pc, #124]	; (8003c4c <VCP_get_string+0x80>)
 8003bd0:	4c1f      	ldr	r4, [pc, #124]	; (8003c50 <VCP_get_string+0x84>)
 8003bd2:	6813      	ldr	r3, [r2, #0]
 8003bd4:	6821      	ldr	r1, [r4, #0]
 8003bd6:	4299      	cmp	r1, r3
 8003bd8:	4626      	mov	r6, r4
 8003bda:	d108      	bne.n	8003bee <VCP_get_string+0x22>
 8003bdc:	e033      	b.n	8003c46 <VCP_get_string+0x7a>
		return 0;

	while (!APP_Tx_Buffer[APP_tx_ptr_tail]
			|| APP_Tx_Buffer[APP_tx_ptr_tail] == '\n'
			|| APP_Tx_Buffer[APP_tx_ptr_tail] == '\r') {
		APP_tx_ptr_tail++;
 8003bde:	3301      	adds	r3, #1
		if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
			APP_tx_ptr_tail = 0;
 8003be0:	2b80      	cmp	r3, #128	; 0x80
 8003be2:	bf08      	it	eq
 8003be4:	2300      	moveq	r3, #0
		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8003be6:	4299      	cmp	r1, r3
 8003be8:	d101      	bne.n	8003bee <VCP_get_string+0x22>
 8003bea:	6011      	str	r1, [r2, #0]
 8003bec:	e02b      	b.n	8003c46 <VCP_get_string+0x7a>

int VCP_get_string(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
		return 0;

	while (!APP_Tx_Buffer[APP_tx_ptr_tail]
 8003bee:	4c19      	ldr	r4, [pc, #100]	; (8003c54 <VCP_get_string+0x88>)
			|| APP_Tx_Buffer[APP_tx_ptr_tail] == '\n'
			|| APP_Tx_Buffer[APP_tx_ptr_tail] == '\r') {
		APP_tx_ptr_tail++;
		if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
			APP_tx_ptr_tail = 0;
		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8003bf0:	5ce5      	ldrb	r5, [r4, r3]
 8003bf2:	2d0d      	cmp	r5, #13
 8003bf4:	4625      	mov	r5, r4
 8003bf6:	d803      	bhi.n	8003c00 <VCP_get_string+0x34>
 8003bf8:	56e4      	ldrsb	r4, [r4, r3]
 8003bfa:	4f17      	ldr	r7, [pc, #92]	; (8003c58 <VCP_get_string+0x8c>)
 8003bfc:	40a7      	lsls	r7, r4
 8003bfe:	d4ee      	bmi.n	8003bde <VCP_get_string+0x12>
 8003c00:	6013      	str	r3, [r2, #0]

int VCP_get_string(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
		return 0;

	while (!APP_Tx_Buffer[APP_tx_ptr_tail]
 8003c02:	2300      	movs	r3, #0
			return 0;
	}

	int i = 0;
	do {
		*(buf + i) = APP_Tx_Buffer[i + APP_tx_ptr_tail];
 8003c04:	18ec      	adds	r4, r5, r3
 8003c06:	6811      	ldr	r1, [r2, #0]
 8003c08:	5c61      	ldrb	r1, [r4, r1]
 8003c0a:	54c1      	strb	r1, [r0, r3]
		i++;

		if ((APP_tx_ptr_tail + i) == APP_TX_BUF_SIZE)
 8003c0c:	6811      	ldr	r1, [r2, #0]
	}

	int i = 0;
	do {
		*(buf + i) = APP_Tx_Buffer[i + APP_tx_ptr_tail];
		i++;
 8003c0e:	3301      	adds	r3, #1

		if ((APP_tx_ptr_tail + i) == APP_TX_BUF_SIZE)
 8003c10:	185c      	adds	r4, r3, r1
 8003c12:	2c80      	cmp	r4, #128	; 0x80
			i = -APP_tx_ptr_tail;
 8003c14:	bf08      	it	eq
 8003c16:	424b      	negeq	r3, r1
		if (APP_tx_ptr_head == (APP_tx_ptr_tail + i))
 8003c18:	6834      	ldr	r4, [r6, #0]
 8003c1a:	1859      	adds	r1, r3, r1
 8003c1c:	428c      	cmp	r4, r1
 8003c1e:	d012      	beq.n	8003c46 <VCP_get_string+0x7a>
 8003c20:	5c6c      	ldrb	r4, [r5, r1]
 8003c22:	2c0d      	cmp	r4, #13
 8003c24:	d8ee      	bhi.n	8003c04 <VCP_get_string+0x38>
 8003c26:	4c0b      	ldr	r4, [pc, #44]	; (8003c54 <VCP_get_string+0x88>)
 8003c28:	5661      	ldrsb	r1, [r4, r1]
 8003c2a:	4c0b      	ldr	r4, [pc, #44]	; (8003c58 <VCP_get_string+0x8c>)
 8003c2c:	408c      	lsls	r4, r1
 8003c2e:	d5e9      	bpl.n	8003c04 <VCP_get_string+0x38>

	} while (APP_Tx_Buffer[APP_tx_ptr_tail + i]
			&& APP_Tx_Buffer[APP_tx_ptr_tail + i] != '\n'
			&& APP_Tx_Buffer[APP_tx_ptr_tail + i] != '\r');

	*(buf + i) = 0;
 8003c30:	2100      	movs	r1, #0
 8003c32:	54c1      	strb	r1, [r0, r3]
	APP_tx_ptr_tail += i;
 8003c34:	6811      	ldr	r1, [r2, #0]
 8003c36:	1859      	adds	r1, r3, r1
	if (APP_tx_ptr_tail >= APP_TX_BUF_SIZE)
 8003c38:	297f      	cmp	r1, #127	; 0x7f
	} while (APP_Tx_Buffer[APP_tx_ptr_tail + i]
			&& APP_Tx_Buffer[APP_tx_ptr_tail + i] != '\n'
			&& APP_Tx_Buffer[APP_tx_ptr_tail + i] != '\r');

	*(buf + i) = 0;
	APP_tx_ptr_tail += i;
 8003c3a:	6011      	str	r1, [r2, #0]
	if (APP_tx_ptr_tail >= APP_TX_BUF_SIZE)
 8003c3c:	d904      	bls.n	8003c48 <VCP_get_string+0x7c>
		APP_tx_ptr_tail -= APP_TX_BUF_SIZE;
 8003c3e:	4a03      	ldr	r2, [pc, #12]	; (8003c4c <VCP_get_string+0x80>)
 8003c40:	3980      	subs	r1, #128	; 0x80
 8003c42:	6011      	str	r1, [r2, #0]
 8003c44:	e000      	b.n	8003c48 <VCP_get_string+0x7c>
		i++;

		if ((APP_tx_ptr_tail + i) == APP_TX_BUF_SIZE)
			i = -APP_tx_ptr_tail;
		if (APP_tx_ptr_head == (APP_tx_ptr_tail + i))
			return 0;
 8003c46:	2300      	movs	r3, #0
	*(buf + i) = 0;
	APP_tx_ptr_tail += i;
	if (APP_tx_ptr_tail >= APP_TX_BUF_SIZE)
		APP_tx_ptr_tail -= APP_TX_BUF_SIZE;
	return i;
}
 8003c48:	4618      	mov	r0, r3
 8003c4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003c4c:	20002a74 	.word	0x20002a74
 8003c50:	20002a88 	.word	0x20002a88
 8003c54:	200029f4 	.word	0x200029f4
 8003c58:	80240000 	.word	0x80240000

08003c5c <EVAL_COM_IRQHandler>:
 * @param  None.
 * @retval None.
 */
void EVAL_COM_IRQHandler(void) {

}
 8003c5c:	4770      	bx	lr
 8003c5e:	bf00      	nop

08003c60 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8003c60:	f040 61be 	orr.w	r1, r0, #99614720	; 0x5f00000
 8003c64:	4b02      	ldr	r3, [pc, #8]	; (8003c70 <NVIC_PriorityGroupConfig+0x10>)
 8003c66:	f441 2020 	orr.w	r0, r1, #655360	; 0xa0000
 8003c6a:	60d8      	str	r0, [r3, #12]
}
 8003c6c:	4770      	bx	lr
 8003c6e:	bf00      	nop
 8003c70:	e000ed00 	.word	0xe000ed00

08003c74 <NVIC_Init>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8003c74:	78c3      	ldrb	r3, [r0, #3]
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8003c76:	b470      	push	{r4, r5, r6}
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8003c78:	b963      	cbnz	r3, 8003c94 <NVIC_Init+0x20>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003c7a:	7802      	ldrb	r2, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003c7c:	2101      	movs	r1, #1
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003c7e:	0950      	lsrs	r0, r2, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003c80:	f002 031f 	and.w	r3, r2, #31
 8003c84:	fa11 f203 	lsls.w	r2, r1, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003c88:	3020      	adds	r0, #32
 8003c8a:	4916      	ldr	r1, [pc, #88]	; (8003ce4 <NVIC_Init+0x70>)
 8003c8c:	f841 2020 	str.w	r2, [r1, r0, lsl #2]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 8003c90:	bc70      	pop	{r4, r5, r6}
 8003c92:	4770      	bx	lr
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003c94:	4b14      	ldr	r3, [pc, #80]	; (8003ce8 <NVIC_Init+0x74>)
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8003c96:	7846      	ldrb	r6, [r0, #1]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003c98:	68dc      	ldr	r4, [r3, #12]
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 8003c9a:	7885      	ldrb	r5, [r0, #2]
        
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003c9c:	7801      	ldrb	r1, [r0, #0]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003c9e:	43e2      	mvns	r2, r4
 8003ca0:	f3c2 2202 	ubfx	r2, r2, #8, #3
    tmppre = (0x4 - tmppriority);
 8003ca4:	f1c2 0c04 	rsb	ip, r2, #4
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8003ca8:	fa5f f48c 	uxtb.w	r4, ip
 8003cac:	fa16 f404 	lsls.w	r4, r6, r4
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
 8003cb0:	260f      	movs	r6, #15
 8003cb2:	fa56 f202 	asrs.w	r2, r6, r2
    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
        
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003cb6:	f5a3 6340 	sub.w	r3, r3, #3072	; 0xc00
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 8003cba:	ea02 0c05 	and.w	ip, r2, r5
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8003cbe:	b2e4      	uxtb	r4, r4
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 8003cc0:	ea4c 0204 	orr.w	r2, ip, r4
        
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003cc4:	eb01 0c03 	add.w	ip, r1, r3
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
        
    tmppriority = tmppriority << 0x04;
 8003cc8:	0112      	lsls	r2, r2, #4
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003cca:	f88c 2300 	strb.w	r2, [ip, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003cce:	7800      	ldrb	r0, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003cd0:	2201      	movs	r2, #1
 8003cd2:	f000 031f 	and.w	r3, r0, #31
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003cd6:	0941      	lsrs	r1, r0, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003cd8:	fa12 f003 	lsls.w	r0, r2, r3
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003cdc:	4a01      	ldr	r2, [pc, #4]	; (8003ce4 <NVIC_Init+0x70>)
 8003cde:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
 8003ce2:	e7d5      	b.n	8003c90 <NVIC_Init+0x1c>
 8003ce4:	e000e100 	.word	0xe000e100
 8003ce8:	e000ed00 	.word	0xe000ed00

08003cec <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 8003cec:	f021 4c60 	bic.w	ip, r1, #3758096384	; 0xe0000000
 8003cf0:	f02c 027f 	bic.w	r2, ip, #127	; 0x7f
 8003cf4:	4b02      	ldr	r3, [pc, #8]	; (8003d00 <NVIC_SetVectorTable+0x14>)
 8003cf6:	ea42 0100 	orr.w	r1, r2, r0
 8003cfa:	6099      	str	r1, [r3, #8]
}
 8003cfc:	4770      	bx	lr
 8003cfe:	bf00      	nop
 8003d00:	e000ed00 	.word	0xe000ed00

08003d04 <NVIC_SystemLPConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 8003d04:	b929      	cbnz	r1, 8003d12 <NVIC_SystemLPConfig+0xe>
  {
    SCB->SCR |= LowPowerMode;
  }
  else
  {
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
 8003d06:	4b05      	ldr	r3, [pc, #20]	; (8003d1c <NVIC_SystemLPConfig+0x18>)
 8003d08:	691a      	ldr	r2, [r3, #16]
 8003d0a:	ea22 0100 	bic.w	r1, r2, r0
 8003d0e:	6119      	str	r1, [r3, #16]
 8003d10:	4770      	bx	lr
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    SCB->SCR |= LowPowerMode;
 8003d12:	4b02      	ldr	r3, [pc, #8]	; (8003d1c <NVIC_SystemLPConfig+0x18>)
 8003d14:	691a      	ldr	r2, [r3, #16]
 8003d16:	4310      	orrs	r0, r2
 8003d18:	6118      	str	r0, [r3, #16]
 8003d1a:	4770      	bx	lr
 8003d1c:	e000ed00 	.word	0xe000ed00

08003d20 <SysTick_CLKSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8003d20:	4b04      	ldr	r3, [pc, #16]	; (8003d34 <SysTick_CLKSourceConfig+0x14>)
 8003d22:	681a      	ldr	r2, [r3, #0]
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 8003d24:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8003d26:	bf0c      	ite	eq
 8003d28:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8003d2c:	f022 0204 	bicne.w	r2, r2, #4
 8003d30:	601a      	str	r2, [r3, #0]
 8003d32:	4770      	bx	lr
 8003d34:	e000e010 	.word	0xe000e010

08003d38 <hex>:
 * ************************************************************************************** */
/* bin to ascii lookup table */
static const char h[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
static char* hex(char *p, u8 c)	// Convert 'c' to hex, placing in output *p.
{
		*p++ = h[((c >> 4) & 0x0f)];	// Hi order nibble
 8003d38:	4a06      	ldr	r2, [pc, #24]	; (8003d54 <hex+0x1c>)
 8003d3a:	090b      	lsrs	r3, r1, #4
 * static char* hex(char *p, u8 c)	// Convert 'c' to hex, placing in output *p.
 * ************************************************************************************** */
/* bin to ascii lookup table */
static const char h[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
static char* hex(char *p, u8 c)	// Convert 'c' to hex, placing in output *p.
{
 8003d3c:	b510      	push	{r4, lr}
		*p++ = h[((c >> 4) & 0x0f)];	// Hi order nibble
		*p++ = h[(c & 0x0f)];		// Lo order nibble
 8003d3e:	f001 010f 	and.w	r1, r1, #15
 * ************************************************************************************** */
/* bin to ascii lookup table */
static const char h[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
static char* hex(char *p, u8 c)	// Convert 'c' to hex, placing in output *p.
{
		*p++ = h[((c >> 4) & 0x0f)];	// Hi order nibble
 8003d42:	5cd4      	ldrb	r4, [r2, r3]
 8003d44:	4603      	mov	r3, r0
		*p++ = h[(c & 0x0f)];		// Lo order nibble
 8003d46:	5c52      	ldrb	r2, [r2, r1]
 * ************************************************************************************** */
/* bin to ascii lookup table */
static const char h[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
static char* hex(char *p, u8 c)	// Convert 'c' to hex, placing in output *p.
{
		*p++ = h[((c >> 4) & 0x0f)];	// Hi order nibble
 8003d48:	f803 4b01 	strb.w	r4, [r3], #1
		*p++ = h[(c & 0x0f)];		// Lo order nibble
 8003d4c:	7042      	strb	r2, [r0, #1]
		return p;			// Return new output pointer position
}
 8003d4e:	1c58      	adds	r0, r3, #1
 8003d50:	bd10      	pop	{r4, pc}
 8003d52:	bf00      	nop
 8003d54:	0800cdc4 	.word	0x0800cdc4

08003d58 <strstuff>:
/* Note: It is up to the caller to have the struct initialized, initially and after the 
message has been "consumed."  When there are errors this routine re-initializes.  */

static void strstuff(struct PCTOGATEWAY* ptr, u8 c)
{
	*ptr->cmprs.p++ = c;			// Save binary byte in binary byte array
 8003d58:	6d83      	ldr	r3, [r0, #88]	; 0x58
 * ************************************************************************************** */
/* Note: It is up to the caller to have the struct initialized, initially and after the 
message has been "consumed."  When there are errors this routine re-initializes.  */

static void strstuff(struct PCTOGATEWAY* ptr, u8 c)
{
 8003d5a:	b510      	push	{r4, lr}
	*ptr->cmprs.p++ = c;			// Save binary byte in binary byte array
 8003d5c:	f803 1b01 	strb.w	r1, [r3], #1
 8003d60:	6583      	str	r3, [r0, #88]	; 0x58
	if (ptr->cmprs.ct > 0)			// Skip storing ascii for sequence number
 8003d62:	f9b0 305c 	ldrsh.w	r3, [r0, #92]	; 0x5c
 * ************************************************************************************** */
/* Note: It is up to the caller to have the struct initialized, initially and after the 
message has been "consumed."  When there are errors this routine re-initializes.  */

static void strstuff(struct PCTOGATEWAY* ptr, u8 c)
{
 8003d66:	4604      	mov	r4, r0
	*ptr->cmprs.p++ = c;			// Save binary byte in binary byte array
	if (ptr->cmprs.ct > 0)			// Skip storing ascii for sequence number
 8003d68:	2b00      	cmp	r3, #0
 8003d6a:	dd03      	ble.n	8003d74 <strstuff+0x1c>
		ptr->pasc = hex(ptr->pasc, c);	// Convert 'c' to hex and save in ascii array	
 8003d6c:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8003d6e:	f7ff ffe3 	bl	8003d38 <hex>
 8003d72:	6320      	str	r0, [r4, #48]	; 0x30
	ptr->cmprs.ct += 1;			// Binary byte count
 8003d74:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
 8003d78:	3301      	adds	r3, #1
 8003d7a:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
	return;
}
 8003d7e:	bd10      	pop	{r4, pc}

08003d80 <strwrd>:
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
static void strwrd(u8* pout, u32 x)
{ // Store u32 in byte array
	*pout++ = (u8)x; *pout++ = (x >> 8); *pout++ = (x >> 16); *pout = (x >> 24); return;
 8003d80:	4603      	mov	r3, r0
 8003d82:	0a0a      	lsrs	r2, r1, #8
 8003d84:	f803 1b01 	strb.w	r1, [r3], #1
 8003d88:	7042      	strb	r2, [r0, #1]
 8003d8a:	0c0a      	lsrs	r2, r1, #16
 8003d8c:	0e09      	lsrs	r1, r1, #24
 8003d8e:	705a      	strb	r2, [r3, #1]
 8003d90:	7099      	strb	r1, [r3, #2]
}
 8003d92:	4770      	bx	lr

08003d94 <getwd>:
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
static u32 getwd(u8* p) // Move non-aligned bytes into a 4 byte word
{
	return ((*(p+3) << 24) | (*(p+2) << 16) | (*(p+1) << 8) | (*p + 0));
 8003d94:	7883      	ldrb	r3, [r0, #2]
 8003d96:	78c2      	ldrb	r2, [r0, #3]
 8003d98:	041b      	lsls	r3, r3, #16
 8003d9a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8003d9e:	7802      	ldrb	r2, [r0, #0]
 8003da0:	7840      	ldrb	r0, [r0, #1]
 8003da2:	4313      	orrs	r3, r2
}
 8003da4:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8003da8:	4770      	bx	lr

08003daa <CANgenchksum>:
 * @param	: p = pointer to array to be checksummed
 * @param	: ct = number of bytes to be checksummed
 * @return	: Checksum
 * ************************************************************************************** */
u8 CANgenchksum(u8* p, int ct)
{
 8003daa:	b510      	push	{r4, lr}
	int i = 0;
	u32 x = CHECKSUM_INITIAL;
 8003dac:	f24a 53a5 	movw	r3, #42405	; 0xa5a5
	for (i = 0; i < ct; i++)
 8003db0:	2200      	movs	r2, #0
 8003db2:	e002      	b.n	8003dba <CANgenchksum+0x10>
		x += *p++;
 8003db4:	5c84      	ldrb	r4, [r0, r2]
 * ************************************************************************************** */
u8 CANgenchksum(u8* p, int ct)
{
	int i = 0;
	u32 x = CHECKSUM_INITIAL;
	for (i = 0; i < ct; i++)
 8003db6:	3201      	adds	r2, #1
		x += *p++;
 8003db8:	191b      	adds	r3, r3, r4
 * ************************************************************************************** */
u8 CANgenchksum(u8* p, int ct)
{
	int i = 0;
	u32 x = CHECKSUM_INITIAL;
	for (i = 0; i < ct; i++)
 8003dba:	428a      	cmp	r2, r1
 8003dbc:	dbfa      	blt.n	8003db4 <CANgenchksum+0xa>
		x += *p++;
	x += (x >> 16);	// Add carries into high half word
 8003dbe:	eb03 4313 	add.w	r3, r3, r3, lsr #16
	x += (x >> 16);	// Add carry if previous add generated a carry
 8003dc2:	eb03 4313 	add.w	r3, r3, r3, lsr #16
	x += (x >> 8);  // Add high byte of low half word
 8003dc6:	eb03 2313 	add.w	r3, r3, r3, lsr #8
	x += (x >> 8);  // Add carry if previous add generated a carry
	return (u8)x;
 8003dca:	eb03 2313 	add.w	r3, r3, r3, lsr #8
}
 8003dce:	b2d8      	uxtb	r0, r3
 8003dd0:	bd10      	pop	{r4, pc}

08003dd2 <PC_msg_initg>:
 * @param	: Pointer to gateway message wrapper (see common_can.h)
 * ************************************************************************************** */
void PC_msg_initg(struct PCTOGATEWAY* p)
{
	p->pasc = &p->asc[0];		// Pointer that will store incoming ascii chars
	p->cmprs.p = &p->cmprs.cm[0];	// Pointer that will store incoming binary bytes
 8003dd2:	f100 0340 	add.w	r3, r0, #64	; 0x40
 8003dd6:	6583      	str	r3, [r0, #88]	; 0x58
	p->ctasc = 0;			// Byte counter
 8003dd8:	2300      	movs	r3, #0
 8003dda:	8743      	strh	r3, [r0, #58]	; 0x3a
	p->ct = 0;			// Byte counter
 8003ddc:	8703      	strh	r3, [r0, #56]	; 0x38
	p->cmprs.ct = 0;		// Byte counter
 8003dde:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
	p->chk = CHECKSUM_INITIAL;	// Checksum initial value
 8003de2:	f24a 53a5 	movw	r3, #42405	; 0xa5a5
 8003de6:	6343      	str	r3, [r0, #52]	; 0x34
	p->prev = ~CAN_PC_ESCAPE;	// Begin with received byte not an escape.
 8003de8:	2382      	movs	r3, #130	; 0x82
 * @brief	: Initialize struct for building a gateway message from the PC
 * @param	: Pointer to gateway message wrapper (see common_can.h)
 * ************************************************************************************** */
void PC_msg_initg(struct PCTOGATEWAY* p)
{
	p->pasc = &p->asc[0];		// Pointer that will store incoming ascii chars
 8003dea:	6300      	str	r0, [r0, #48]	; 0x30
	p->cmprs.p = &p->cmprs.cm[0];	// Pointer that will store incoming binary bytes
	p->ctasc = 0;			// Byte counter
	p->ct = 0;			// Byte counter
	p->cmprs.ct = 0;		// Byte counter
	p->chk = CHECKSUM_INITIAL;	// Checksum initial value
	p->prev = ~CAN_PC_ESCAPE;	// Begin with received byte not an escape.
 8003dec:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
	return;
}
 8003df0:	4770      	bx	lr

08003df2 <PC_msg_getASCII>:
//printf("%c",c);
//debugR += 1;
	

	/* End of msg check */
	if (c == '\n')
 8003df2:	290a      	cmp	r1, #10
int debugR;

/* Note: It is up to the caller to have the struct initialized, initially and after the 
message has been "consumed."  When there are errors this routine re-initializes.  */
int PC_msg_getASCII(struct PCTOGATEWAY* ptr, u8 c)
{			
 8003df4:	b538      	push	{r3, r4, r5, lr}
 8003df6:	4604      	mov	r4, r0
//printf("%c",c);
//debugR += 1;
	

	/* End of msg check */
	if (c == '\n')
 8003df8:	d13c      	bne.n	8003e74 <PC_msg_getASCII+0x82>
//xprintf (6,"in ct: %i debugR: %i ctasc: %i \n",i, debugR, ptr->ctasc);
//for (w = 0; w < i; w++)
//xprintf(6,"%02x ",ptr->cmprs.cm[w]);
//xprintf(6,"\n\r");
//debugR = 0;
		*ptr->pasc++ = c;	// Store '\n'
 8003dfa:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8003dfc:	f803 1b01 	strb.w	r1, [r3], #1
		ptr->ctasc -= 2; // Adjust for not storing seq number bytes, but added '\n'
 8003e00:	8f45      	ldrh	r5, [r0, #58]	; 0x3a
//xprintf (6,"in ct: %i debugR: %i ctasc: %i \n",i, debugR, ptr->ctasc);
//for (w = 0; w < i; w++)
//xprintf(6,"%02x ",ptr->cmprs.cm[w]);
//xprintf(6,"\n\r");
//debugR = 0;
		*ptr->pasc++ = c;	// Store '\n'
 8003e02:	6303      	str	r3, [r0, #48]	; 0x30
		ptr->ctasc -= 2; // Adjust for not storing seq number bytes, but added '\n'
 8003e04:	3d02      	subs	r5, #2
 8003e06:	b2ad      	uxth	r5, r5

		ptr->seq = ptr->cmprs.cm[0];		// First binary byte is the sequence number
 8003e08:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
		ptr->cmprs.seq = ptr->cmprs.cm[0];	// Save for binary folk

		/* Check count for even pairing of hex char pairs */
		if ((ptr->ctasc & 0x1) != 0) // Should be odd at this point
 8003e0c:	f015 0f01 	tst.w	r5, #1
//for (w = 0; w < i; w++)
//xprintf(6,"%02x ",ptr->cmprs.cm[w]);
//xprintf(6,"\n\r");
//debugR = 0;
		*ptr->pasc++ = c;	// Store '\n'
		ptr->ctasc -= 2; // Adjust for not storing seq number bytes, but added '\n'
 8003e10:	8745      	strh	r5, [r0, #58]	; 0x3a

		ptr->seq = ptr->cmprs.cm[0];		// First binary byte is the sequence number
 8003e12:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
		ptr->cmprs.seq = ptr->cmprs.cm[0];	// Save for binary folk
 8003e16:	f880 305e 	strb.w	r3, [r0, #94]	; 0x5e

		/* Check count for even pairing of hex char pairs */
		if ((ptr->ctasc & 0x1) != 0) // Should be odd at this point
 8003e1a:	d008      	beq.n	8003e2e <PC_msg_getASCII+0x3c>
		{ // Here, not an even pairing for the binary bytes
			PC_msg_initg(ptr);	// Initialize struct for the next message
 8003e1c:	f7ff ffd9 	bl	8003dd2 <PC_msg_initg>
			PC_oddeven_ct_err += 1;	// Running count of this type of error.
 8003e20:	4b28      	ldr	r3, [pc, #160]	; (8003ec4 <PC_msg_getASCII+0xd2>)
			return -4;	// Return error code.		{	
 8003e22:	f06f 0003 	mvn.w	r0, #3

		/* Check count for even pairing of hex char pairs */
		if ((ptr->ctasc & 0x1) != 0) // Should be odd at this point
		{ // Here, not an even pairing for the binary bytes
			PC_msg_initg(ptr);	// Initialize struct for the next message
			PC_oddeven_ct_err += 1;	// Running count of this type of error.
 8003e26:	681a      	ldr	r2, [r3, #0]
 8003e28:	3201      	adds	r2, #1
 8003e2a:	601a      	str	r2, [r3, #0]
			return -4;	// Return error code.		{	
 8003e2c:	bd38      	pop	{r3, r4, r5, pc}
		}

		if (ptr->ctasc < 5)		// Too few incoming bytes to comprise a valid anything?
 8003e2e:	b22d      	sxth	r5, r5
 8003e30:	2d04      	cmp	r5, #4
 8003e32:	dc08      	bgt.n	8003e46 <PC_msg_getASCII+0x54>
		{ // Here yes.
			PC_msg_initg(ptr);	// Initialize struct for the next message
 8003e34:	f7ff ffcd 	bl	8003dd2 <PC_msg_initg>
			PC_toofew_ct_err += 1;	// Running count of this type of error.
 8003e38:	4b22      	ldr	r3, [pc, #136]	; (8003ec4 <PC_msg_getASCII+0xd2>)
			return -2;	// Return error code.
 8003e3a:	f06f 0001 	mvn.w	r0, #1
		}

		if (ptr->ctasc < 5)		// Too few incoming bytes to comprise a valid anything?
		{ // Here yes.
			PC_msg_initg(ptr);	// Initialize struct for the next message
			PC_toofew_ct_err += 1;	// Running count of this type of error.
 8003e3e:	685a      	ldr	r2, [r3, #4]
 8003e40:	3201      	adds	r2, #1
 8003e42:	605a      	str	r2, [r3, #4]
			return -2;	// Return error code.
 8003e44:	bd38      	pop	{r3, r4, r5, pc}
		}

		/* Binary byte count is the ascii ct divided by 2, less checksum */
		ptr->cmprs.ct = (ptr->ctasc >> 1);	// Number of binary bytes of msg data
 8003e46:	106d      	asrs	r5, r5, #1
 8003e48:	f8a0 505c 	strh.w	r5, [r0, #92]	; 0x5c
					
		/* Check checksum. */	
		x = ptr->cmprs.cm[ptr->cmprs.ct];	// Checksum received
 8003e4c:	b22d      	sxth	r5, r5
		zz=CANgenchksum(&ptr->cmprs.cm[0], (ptr->cmprs.ct));	// Checksum computed
 8003e4e:	3040      	adds	r0, #64	; 0x40
 8003e50:	4629      	mov	r1, r5
 8003e52:	f7ff ffaa 	bl	8003daa <CANgenchksum>

		/* Binary byte count is the ascii ct divided by 2, less checksum */
		ptr->cmprs.ct = (ptr->ctasc >> 1);	// Number of binary bytes of msg data
					
		/* Check checksum. */	
		x = ptr->cmprs.cm[ptr->cmprs.ct];	// Checksum received
 8003e56:	1965      	adds	r5, r4, r5
		zz=CANgenchksum(&ptr->cmprs.cm[0], (ptr->cmprs.ct));	// Checksum computed
//xprintf(6," CHKRCV %02x CMP %02x\n\r",x,zz);

		/* Compute checksum and compare. */
		if (zz  == x)
 8003e58:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 8003e5c:	4283      	cmp	r3, r0
 8003e5e:	d02c      	beq.n	8003eba <PC_msg_getASCII+0xc8>
//printf("CHKSM: %02x %02x %02x  ptr->cmprs.ct: %i ptr->ctasc: %i\n",x,xx,zz,ptr->cmprs.ct, ptr->ctasc);
//int j;
//for (j = 0; j < ptr->cmprs.ct+2; j++)
//  printf("%02x",ptr->cmprs.cm[j]);
//printf("\n");
			PC_msg_initg(ptr);	// Initialize struct for the next message
 8003e60:	4620      	mov	r0, r4
 8003e62:	f7ff ffb6 	bl	8003dd2 <PC_msg_initg>
			PC_chksum_ct_err += 1;	// Running count of checksum errors
 8003e66:	4b17      	ldr	r3, [pc, #92]	; (8003ec4 <PC_msg_getASCII+0xd2>)
			return -1;	// Return error code.
 8003e68:	f04f 30ff 	mov.w	r0, #4294967295
//int j;
//for (j = 0; j < ptr->cmprs.ct+2; j++)
//  printf("%02x",ptr->cmprs.cm[j]);
//printf("\n");
			PC_msg_initg(ptr);	// Initialize struct for the next message
			PC_chksum_ct_err += 1;	// Running count of checksum errors
 8003e6c:	689a      	ldr	r2, [r3, #8]
 8003e6e:	3201      	adds	r2, #1
 8003e70:	609a      	str	r2, [r3, #8]
			return -1;	// Return error code.
 8003e72:	bd38      	pop	{r3, r4, r5, pc}
		}
	}
	if ( (ptr->ctasc & 0x1) == 0) // Even?
 8003e74:	8f43      	ldrh	r3, [r0, #58]	; 0x3a
 8003e76:	4a14      	ldr	r2, [pc, #80]	; (8003ec8 <PC_msg_getASCII+0xd6>)
 8003e78:	f013 0f01 	tst.w	r3, #1
 8003e7c:	6d83      	ldr	r3, [r0, #88]	; 0x58
 8003e7e:	d104      	bne.n	8003e8a <PC_msg_getASCII+0x98>
	{ // Here yes.  Even chars -> hi ord nibble of byte
		*ptr->cmprs.p = (hxbn[c] << 4); // Convert hex char to bin 4 bit
 8003e80:	1852      	adds	r2, r2, r1
 8003e82:	7c12      	ldrb	r2, [r2, #16]
 8003e84:	0112      	lsls	r2, r2, #4
 8003e86:	701a      	strb	r2, [r3, #0]
 8003e88:	e007      	b.n	8003e9a <PC_msg_getASCII+0xa8>
	}
	else
	{ // Here, Odd chars -> low ord nibble of byte
		*ptr->cmprs.p++ |= hxbn[c];	// Add nibble.  Byte complete.  Advance pointer.
 8003e8a:	1852      	adds	r2, r2, r1
 8003e8c:	7c10      	ldrb	r0, [r2, #16]
 8003e8e:	781a      	ldrb	r2, [r3, #0]
 8003e90:	ea40 0202 	orr.w	r2, r0, r2
 8003e94:	f803 2b01 	strb.w	r2, [r3], #1
 8003e98:	65a3      	str	r3, [r4, #88]	; 0x58
	}

	/* Copy incoming chars into asc buffer. */
	*ptr->pasc++ = c; 	// Store incoming chars char array (for those who want raw ascii lines)
 8003e9a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003e9c:	f803 1b01 	strb.w	r1, [r3], #1
 8003ea0:	6323      	str	r3, [r4, #48]	; 0x30
	ptr->ctasc += 1;	// Count incoming chars
 8003ea2:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
 8003ea4:	3301      	adds	r3, #1
 8003ea6:	8763      	strh	r3, [r4, #58]	; 0x3a

	/* Max length check */
	if (ptr->ctasc > 37) 
 8003ea8:	b21b      	sxth	r3, r3
 8003eaa:	2b25      	cmp	r3, #37	; 0x25
 8003eac:	dd07      	ble.n	8003ebe <PC_msg_getASCII+0xcc>
	{ // Here incoming chars exceed the max number for a max size CAN msg
		PC_msg_initg(ptr);	// Initialize struct for the next message
 8003eae:	4620      	mov	r0, r4
 8003eb0:	f7ff ff8f 	bl	8003dd2 <PC_msg_initg>
		return -3;		// Return an error code
 8003eb4:	f06f 0002 	mvn.w	r0, #2
 8003eb8:	bd38      	pop	{r3, r4, r5, pc}
//xprintf(6," CHKRCV %02x CMP %02x\n\r",x,zz);

		/* Compute checksum and compare. */
		if (zz  == x)
		{ // Here checksum good
				return 1;	// $$$$ COMPLETE & SUCCESS $$$$
 8003eba:	2001      	movs	r0, #1
 8003ebc:	bd38      	pop	{r3, r4, r5, pc}
	{ // Here incoming chars exceed the max number for a max size CAN msg
		PC_msg_initg(ptr);	// Initialize struct for the next message
		return -3;		// Return an error code
	}

	return 0;
 8003ebe:	2000      	movs	r0, #0
}
 8003ec0:	bd38      	pop	{r3, r4, r5, pc}
 8003ec2:	bf00      	nop
 8003ec4:	20000e40 	.word	0x20000e40
 8003ec8:	0800cdc4 	.word	0x0800cdc4

08003ecc <PC_msg_get>:

int PC_msg_get(struct PCTOGATEWAY* ptr, u8 c)
{			
	int i;

	switch (c)
 8003ecc:	290a      	cmp	r1, #10
	ptr->cmprs.ct += 1;			// Binary byte count
	return;
}

int PC_msg_get(struct PCTOGATEWAY* ptr, u8 c)
{			
 8003ece:	b570      	push	{r4, r5, r6, lr}
 8003ed0:	4604      	mov	r4, r0
 8003ed2:	460d      	mov	r5, r1
	int i;

	switch (c)
 8003ed4:	d002      	beq.n	8003edc <PC_msg_get+0x10>
 8003ed6:	297d      	cmp	r1, #125	; 0x7d
 8003ed8:	d149      	bne.n	8003f6e <PC_msg_get+0xa2>
 8003eda:	e040      	b.n	8003f5e <PC_msg_get+0x92>
	{
	case CAN_PC_FRAMEBOUNDARY:	// Possible end of message
		if (ptr->prev == CAN_PC_ESCAPE)
 8003edc:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8003ee0:	2b7d      	cmp	r3, #125	; 0x7d
 8003ee2:	d044      	beq.n	8003f6e <PC_msg_get+0xa2>
		{ // Here, previous byte was an escape byte
			strstuff(ptr, c); // Store binary, ascii, and count binary bytes
		}
		else
		{ // Here, frame without preceding escape means End of Message
			i = ptr->cmprs.p - &ptr->cmprs.cm[0] - 1; // Number of bytes received in this frame less chksum
 8003ee4:	6d85      	ldr	r5, [r0, #88]	; 0x58
 8003ee6:	f100 0340 	add.w	r3, r0, #64	; 0x40
 8003eea:	3d01      	subs	r5, #1
 8003eec:	1aed      	subs	r5, r5, r3
			ptr->cmprs.ct = i;	// Save for others
 8003eee:	b2ae      	uxth	r6, r5
			if (i < 3)		// Too few bytes to comprise a valid msg?
 8003ef0:	2d02      	cmp	r5, #2
			strstuff(ptr, c); // Store binary, ascii, and count binary bytes
		}
		else
		{ // Here, frame without preceding escape means End of Message
			i = ptr->cmprs.p - &ptr->cmprs.cm[0] - 1; // Number of bytes received in this frame less chksum
			ptr->cmprs.ct = i;	// Save for others
 8003ef2:	f8a0 605c 	strh.w	r6, [r0, #92]	; 0x5c
			if (i < 3)		// Too few bytes to comprise a valid msg?
 8003ef6:	dc08      	bgt.n	8003f0a <PC_msg_get+0x3e>
			{ // Here yes. (min binary msg plus checksum = 3 bytes)
				PC_msg_initg(ptr);	// Initialize struct for the next message
 8003ef8:	f7ff ff6b 	bl	8003dd2 <PC_msg_initg>
				PC_toofew_ct_err += 1;	// Running count of this type of error.
 8003efc:	4b22      	ldr	r3, [pc, #136]	; (8003f88 <PC_msg_get+0xbc>)
				return -2;	// Return error code.
 8003efe:	f06f 0001 	mvn.w	r0, #1
			i = ptr->cmprs.p - &ptr->cmprs.cm[0] - 1; // Number of bytes received in this frame less chksum
			ptr->cmprs.ct = i;	// Save for others
			if (i < 3)		// Too few bytes to comprise a valid msg?
			{ // Here yes. (min binary msg plus checksum = 3 bytes)
				PC_msg_initg(ptr);	// Initialize struct for the next message
				PC_toofew_ct_err += 1;	// Running count of this type of error.
 8003f02:	685a      	ldr	r2, [r3, #4]
 8003f04:	3201      	adds	r2, #1
 8003f06:	605a      	str	r2, [r3, #4]
				return -2;	// Return error code.
 8003f08:	bd70      	pop	{r4, r5, r6, pc}
			}

			if (i >= (PCTOGATEWAYSIZE/2) )	// Too many bytes to comprise a valid msg?
 8003f0a:	2d17      	cmp	r5, #23
 8003f0c:	dd08      	ble.n	8003f20 <PC_msg_get+0x54>
			{ // Here yes.
				PC_msg_initg(ptr);	// Initialize struct for the next message
 8003f0e:	f7ff ff60 	bl	8003dd2 <PC_msg_initg>
				PC_toomany_ct_err += 1;	// Running count of this type of error.
 8003f12:	4b1d      	ldr	r3, [pc, #116]	; (8003f88 <PC_msg_get+0xbc>)
				return -3;	// Return error code.
 8003f14:	f06f 0002 	mvn.w	r0, #2
			}

			if (i >= (PCTOGATEWAYSIZE/2) )	// Too many bytes to comprise a valid msg?
			{ // Here yes.
				PC_msg_initg(ptr);	// Initialize struct for the next message
				PC_toomany_ct_err += 1;	// Running count of this type of error.
 8003f18:	68da      	ldr	r2, [r3, #12]
 8003f1a:	3201      	adds	r2, #1
 8003f1c:	60da      	str	r2, [r3, #12]
				return -3;	// Return error code.
 8003f1e:	bd70      	pop	{r4, r5, r6, pc}
			}

			/* Check checksum. */	
			if ( (CANgenchksum(&ptr->cmprs.cm[0], i)) == ptr->cmprs.cm[i])
 8003f20:	4618      	mov	r0, r3
 8003f22:	4629      	mov	r1, r5
 8003f24:	f7ff ff41 	bl	8003daa <CANgenchksum>
 8003f28:	1965      	adds	r5, r4, r5
 8003f2a:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 8003f2e:	4283      	cmp	r3, r0
 8003f30:	d10b      	bne.n	8003f4a <PC_msg_get+0x7e>
			{ // Here checksum good
/* If incoming, complete & valid, messages are to be buffered, this is where the index for the
  buffer array would be advanced. */
				ptr->ctasc = (ptr->cmprs.ct * 2) + 1; // Compute byte ct for ascii array
				*ptr->pasc = '\0';	// Zero string terminator JIC a bozo forgot msg ends with '\n'
 8003f32:	6b23      	ldr	r3, [r4, #48]	; 0x30
			/* Check checksum. */	
			if ( (CANgenchksum(&ptr->cmprs.cm[0], i)) == ptr->cmprs.cm[i])
			{ // Here checksum good
/* If incoming, complete & valid, messages are to be buffered, this is where the index for the
  buffer array would be advanced. */
				ptr->ctasc = (ptr->cmprs.ct * 2) + 1; // Compute byte ct for ascii array
 8003f34:	0076      	lsls	r6, r6, #1
 8003f36:	3601      	adds	r6, #1
				*ptr->pasc = '\0';	// Zero string terminator JIC a bozo forgot msg ends with '\n'
 8003f38:	2200      	movs	r2, #0
			/* Check checksum. */	
			if ( (CANgenchksum(&ptr->cmprs.cm[0], i)) == ptr->cmprs.cm[i])
			{ // Here checksum good
/* If incoming, complete & valid, messages are to be buffered, this is where the index for the
  buffer array would be advanced. */
				ptr->ctasc = (ptr->cmprs.ct * 2) + 1; // Compute byte ct for ascii array
 8003f3a:	8766      	strh	r6, [r4, #58]	; 0x3a
				*ptr->pasc = '\0';	// Zero string terminator JIC a bozo forgot msg ends with '\n'
 8003f3c:	701a      	strb	r2, [r3, #0]
				ptr->seq = ptr->cmprs.cm[0];
 8003f3e:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
				return 1;		// $$$$ COMPLETE & SUCCESS $$$$
 8003f42:	2001      	movs	r0, #1
			{ // Here checksum good
/* If incoming, complete & valid, messages are to be buffered, this is where the index for the
  buffer array would be advanced. */
				ptr->ctasc = (ptr->cmprs.ct * 2) + 1; // Compute byte ct for ascii array
				*ptr->pasc = '\0';	// Zero string terminator JIC a bozo forgot msg ends with '\n'
				ptr->seq = ptr->cmprs.cm[0];
 8003f44:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
				return 1;		// $$$$ COMPLETE & SUCCESS $$$$
 8003f48:	bd70      	pop	{r4, r5, r6, pc}
			}
			else
			{ // Here, failed
				PC_msg_initg(ptr);	// Initialize struct for the next message
 8003f4a:	4620      	mov	r0, r4
 8003f4c:	f7ff ff41 	bl	8003dd2 <PC_msg_initg>
				PC_chksum_ct_err += 1;	// Running count of checksum errors
 8003f50:	4b0d      	ldr	r3, [pc, #52]	; (8003f88 <PC_msg_get+0xbc>)
				return -1;		// Return error code.
 8003f52:	f04f 30ff 	mov.w	r0, #4294967295
				return 1;		// $$$$ COMPLETE & SUCCESS $$$$
			}
			else
			{ // Here, failed
				PC_msg_initg(ptr);	// Initialize struct for the next message
				PC_chksum_ct_err += 1;	// Running count of checksum errors
 8003f56:	689a      	ldr	r2, [r3, #8]
 8003f58:	3201      	adds	r2, #1
 8003f5a:	609a      	str	r2, [r3, #8]
				return -1;		// Return error code.
 8003f5c:	bd70      	pop	{r4, r5, r6, pc}
			}
		}			
		break;

	case CAN_PC_ESCAPE: // Possible escape data byte, or escape for next byte.
		if (ptr->prev == CAN_PC_ESCAPE)
 8003f5e:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8003f62:	2b7d      	cmp	r3, #125	; 0x7d
 8003f64:	d105      	bne.n	8003f72 <PC_msg_get+0xa6>
		{
			strstuff(ptr, c); // Store binary, ascii, and count binary bytes
 8003f66:	f7ff fef7 	bl	8003d58 <strstuff>
			c = ~CAN_PC_ESCAPE;		// Set "previous" to not an escape
 8003f6a:	2582      	movs	r5, #130	; 0x82
 8003f6c:	e001      	b.n	8003f72 <PC_msg_get+0xa6>
		}
		break;

	default: // All other bytes come here.
			strstuff(ptr, c); // Store binary, ascii, and count binary bytes
 8003f6e:	f7ff fef3 	bl	8003d58 <strstuff>
		break;
	}
	/* Prevent buffer overflow. */
	if ( ptr->pasc >= (&ptr->asc[0] + PCTOGATEWAYSIZE - 3 ) ) ptr->pasc -= 2; // Hold at end with space to allow '\n' '\0'
 8003f72:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003f74:	f104 022d 	add.w	r2, r4, #45	; 0x2d
 8003f78:	4293      	cmp	r3, r2
 8003f7a:	d301      	bcc.n	8003f80 <PC_msg_get+0xb4>
 8003f7c:	3b02      	subs	r3, #2
 8003f7e:	6323      	str	r3, [r4, #48]	; 0x30

	ptr->prev = c;	// Save previous char for byte stuffing check.
 8003f80:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c

	return 0;	// Return: binary fram not complete
 8003f84:	2000      	movs	r0, #0
}
 8003f86:	bd70      	pop	{r4, r5, r6, pc}
 8003f88:	20000e40 	.word	0x20000e40

08003f8c <CAN_id_valid>:
 *		: -1 = faux CAN msg id bit 0 on
 *              : -2 = faux CAN msg id: 11 bit id, but stray bits in remaining 18 bits
 * ************************************************************************************** */
int CAN_id_valid(u32 id)
{
	if ( (id & 0x1) != 0 ) return -1; // faux ID
 8003f8c:	f010 0f01 	tst.w	r0, #1
 8003f90:	d10b      	bne.n	8003faa <CAN_id_valid+0x1e>
	if ( (id & 0x4) == 0 ) // Check IDE (extended id bit)
 8003f92:	f010 0f04 	tst.w	r0, #4
 8003f96:	d10b      	bne.n	8003fb0 <CAN_id_valid+0x24>
	{ // Here, an 11 bit address is specified
		if ((id & 0x001ffff8) != 0) return -2; // 11 bit id with stray bits in extended field
 8003f98:	4b06      	ldr	r3, [pc, #24]	; (8003fb4 <CAN_id_valid+0x28>)
 8003f9a:	ea00 0303 	and.w	r3, r0, r3
 8003f9e:	2b00      	cmp	r3, #0
 8003fa0:	bf0c      	ite	eq
 8003fa2:	4618      	moveq	r0, r3
 8003fa4:	f06f 0001 	mvnne.w	r0, #1
 8003fa8:	4770      	bx	lr
 *		: -1 = faux CAN msg id bit 0 on
 *              : -2 = faux CAN msg id: 11 bit id, but stray bits in remaining 18 bits
 * ************************************************************************************** */
int CAN_id_valid(u32 id)
{
	if ( (id & 0x1) != 0 ) return -1; // faux ID
 8003faa:	f04f 30ff 	mov.w	r0, #4294967295
 8003fae:	4770      	bx	lr
	if ( (id & 0x4) == 0 ) // Check IDE (extended id bit)
	{ // Here, an 11 bit address is specified
		if ((id & 0x001ffff8) != 0) return -2; // 11 bit id with stray bits in extended field
		return 0; // Here, 11b is OK.
	}
	return 1;	// Here 29 bit is OK.
 8003fb0:	2001      	movs	r0, #1
}
 8003fb2:	4770      	bx	lr
 8003fb4:	001ffff8 	.word	0x001ffff8

08003fb8 <PC_msg_asctobin>:
cc -> payload byte ct (0 - 8)
11... -> payload bytes (0 - 8)
\n is the line terminator of the ascii input
*/
int PC_msg_asctobin(struct PCTOGATEWAY* ptr, char* pin)
{
 8003fb8:	b570      	push	{r4, r5, r6, lr}
 8003fba:	4604      	mov	r4, r0
 8003fbc:	460e      	mov	r6, r1
	int ct = 0;
	u8 x;
	u32 id;

	u8* pcmprs = &ptr->cmprs.cm[0];
 8003fbe:	f100 0540 	add.w	r5, r0, #64	; 0x40
	PC_msg_initg(ptr);	// Reset pointers
 8003fc2:	f7ff ff06 	bl	8003dd2 <PC_msg_initg>
11... -> payload bytes (0 - 8)
\n is the line terminator of the ascii input
*/
int PC_msg_asctobin(struct PCTOGATEWAY* ptr, char* pin)
{
	int ct = 0;
 8003fc6:	2300      	movs	r3, #0

	u8* pcmprs = &ptr->cmprs.cm[0];
	PC_msg_initg(ptr);	// Reset pointers

	
	while  ( (!((*pin == 0) || (*pin == '\n'))) && (ct < PCTOGATEWAYSIZE)  )
 8003fc8:	e010      	b.n	8003fec <PC_msg_asctobin+0x34>
	{
		if ( (ct & 0x1) == 0) // Even?
 8003fca:	f013 0f01 	tst.w	r3, #1
 8003fce:	491b      	ldr	r1, [pc, #108]	; (800403c <PC_msg_asctobin+0x84>)
 8003fd0:	d104      	bne.n	8003fdc <PC_msg_asctobin+0x24>
		{ // Here yes.  Even chars -> hi ord nibble of byte
			*pcmprs = (hxbn[(u8)(*pin)] << 4);
 8003fd2:	188a      	adds	r2, r1, r2
 8003fd4:	7c12      	ldrb	r2, [r2, #16]
 8003fd6:	0112      	lsls	r2, r2, #4
 8003fd8:	702a      	strb	r2, [r5, #0]
 8003fda:	e006      	b.n	8003fea <PC_msg_asctobin+0x32>
		}
		else
		{ // Here, Odd chars -> low ord nibble of byte
			*pcmprs++ |= hxbn[(u8)(*pin)];	// Add nibble.  Byte complete.  Advance pointer.
 8003fdc:	188a      	adds	r2, r1, r2
 8003fde:	7828      	ldrb	r0, [r5, #0]
 8003fe0:	7c12      	ldrb	r2, [r2, #16]
 8003fe2:	ea40 0202 	orr.w	r2, r0, r2
 8003fe6:	f805 2b01 	strb.w	r2, [r5], #1
		}
		pin ++; ct +=1;
 8003fea:	3301      	adds	r3, #1

	u8* pcmprs = &ptr->cmprs.cm[0];
	PC_msg_initg(ptr);	// Reset pointers

	
	while  ( (!((*pin == 0) || (*pin == '\n'))) && (ct < PCTOGATEWAYSIZE)  )
 8003fec:	5cf2      	ldrb	r2, [r6, r3]
 8003fee:	b122      	cbz	r2, 8003ffa <PC_msg_asctobin+0x42>
 8003ff0:	2a0a      	cmp	r2, #10
 8003ff2:	d002      	beq.n	8003ffa <PC_msg_asctobin+0x42>
 8003ff4:	2b30      	cmp	r3, #48	; 0x30
 8003ff6:	d1e8      	bne.n	8003fca <PC_msg_asctobin+0x12>
 8003ff8:	e017      	b.n	800402a <PC_msg_asctobin+0x72>
		{ // Here, Odd chars -> low ord nibble of byte
			*pcmprs++ |= hxbn[(u8)(*pin)];	// Add nibble.  Byte complete.  Advance pointer.
		}
		pin ++; ct +=1;
	}
	if (ct >= PCTOGATEWAYSIZE)	return -5; // Error: run-away (no terminator)
 8003ffa:	2b2f      	cmp	r3, #47	; 0x2f
 8003ffc:	dc15      	bgt.n	800402a <PC_msg_asctobin+0x72>

	/* Compute size of resulting binary msg. */
	ptr->cmprs.ct = (pcmprs - &ptr->cmprs.cm[0]);
 8003ffe:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8004002:	1aed      	subs	r5, r5, r3

	/* Validity check */
	x = (u8)(ptr->cmprs.cm[4]);		// Should be the dlc
 8004004:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
		pin ++; ct +=1;
	}
	if (ct >= PCTOGATEWAYSIZE)	return -5; // Error: run-away (no terminator)

	/* Compute size of resulting binary msg. */
	ptr->cmprs.ct = (pcmprs - &ptr->cmprs.cm[0]);
 8004008:	f8a4 505c 	strh.w	r5, [r4, #92]	; 0x5c

	/* Validity check */
	x = (u8)(ptr->cmprs.cm[4]);		// Should be the dlc
	if ( x > 8 ) return -1;		// Return: too many bytes for payload count
 800400c:	2b08      	cmp	r3, #8
 800400e:	d80f      	bhi.n	8004030 <PC_msg_asctobin+0x78>

	if (ptr->cmprs.ct != (x + 5)) return -2; // Size inconsistent with dlc count
 8004010:	b22d      	sxth	r5, r5
 8004012:	3305      	adds	r3, #5
 8004014:	429d      	cmp	r5, r3
 8004016:	d10e      	bne.n	8004036 <PC_msg_asctobin+0x7e>
	id = (u32)(ptr->cmprs.cm[0]);		// Get ID in binary word form
	if (CAN_id_valid(id) != 0) return -3;	// Bits in extended field, but 11 bit id specified
 8004018:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
 800401c:	f7ff ffb6 	bl	8003f8c <CAN_id_valid>
 8004020:	2800      	cmp	r0, #0
 8004022:	bf18      	it	ne
 8004024:	f06f 0002 	mvnne.w	r0, #2
 8004028:	bd70      	pop	{r4, r5, r6, pc}
		{ // Here, Odd chars -> low ord nibble of byte
			*pcmprs++ |= hxbn[(u8)(*pin)];	// Add nibble.  Byte complete.  Advance pointer.
		}
		pin ++; ct +=1;
	}
	if (ct >= PCTOGATEWAYSIZE)	return -5; // Error: run-away (no terminator)
 800402a:	f06f 0004 	mvn.w	r0, #4
 800402e:	bd70      	pop	{r4, r5, r6, pc}
	/* Compute size of resulting binary msg. */
	ptr->cmprs.ct = (pcmprs - &ptr->cmprs.cm[0]);

	/* Validity check */
	x = (u8)(ptr->cmprs.cm[4]);		// Should be the dlc
	if ( x > 8 ) return -1;		// Return: too many bytes for payload count
 8004030:	f04f 30ff 	mov.w	r0, #4294967295
 8004034:	bd70      	pop	{r4, r5, r6, pc}

	if (ptr->cmprs.ct != (x + 5)) return -2; // Size inconsistent with dlc count
 8004036:	f06f 0001 	mvn.w	r0, #1
	id = (u32)(ptr->cmprs.cm[0]);		// Get ID in binary word form
	if (CAN_id_valid(id) != 0) return -3;	// Bits in extended field, but 11 bit id specified
	
	return 0;
}
 800403a:	bd70      	pop	{r4, r5, r6, pc}
 800403c:	0800cdc4 	.word	0x0800cdc4

08004040 <PC_msg_prep>:
 * ************************************************************************************** */
/*
Note, in the very worst-case the output may be over (2*ct+3) the size of the input.
*/
int PC_msg_prep(u8* pout, int outsize, u8* pin, int ct)
{
 8004040:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004042:	4604      	mov	r4, r0
	u8 *p1 = pin;	// Redundant?
	u8 *p2 = pout;	// Working pointer
	u8 *p2e = pout + outsize; // End of output buffer pointer
 8004044:	1846      	adds	r6, r0, r1
	u8 chk;		// Checksum computed on input bytes
	int i;

	/* Compute chksum on input message. */
	chk = CANgenchksum(pin, ct);
 8004046:	4610      	mov	r0, r2
 8004048:	4619      	mov	r1, r3
 * ************************************************************************************** */
/*
Note, in the very worst-case the output may be over (2*ct+3) the size of the input.
*/
int PC_msg_prep(u8* pout, int outsize, u8* pin, int ct)
{
 800404a:	4615      	mov	r5, r2
 800404c:	461f      	mov	r7, r3
	u8 *p2e = pout + outsize; // End of output buffer pointer
	u8 chk;		// Checksum computed on input bytes
	int i;

	/* Compute chksum on input message. */
	chk = CANgenchksum(pin, ct);
 800404e:	f7ff feac 	bl	8003daa <CANgenchksum>
Note, in the very worst-case the output may be over (2*ct+3) the size of the input.
*/
int PC_msg_prep(u8* pout, int outsize, u8* pin, int ct)
{
	u8 *p1 = pin;	// Redundant?
	u8 *p2 = pout;	// Working pointer
 8004052:	4623      	mov	r3, r4

	/* Compute chksum on input message. */
	chk = CANgenchksum(pin, ct);
	
	/* Set up CAN msg with byte stuffing in output buffer. */
	for (i = 0; i < ct; i++)
 8004054:	2200      	movs	r2, #0
 8004056:	e015      	b.n	8004084 <PC_msg_prep+0x44>
	{
		if ((*p1 == CAN_PC_FRAMEBOUNDARY) || (*p1 == CAN_PC_ESCAPE) )
 8004058:	5ca9      	ldrb	r1, [r5, r2]
 800405a:	290a      	cmp	r1, #10
 800405c:	d001      	beq.n	8004062 <PC_msg_prep+0x22>
 800405e:	297d      	cmp	r1, #125	; 0x7d
 8004060:	d107      	bne.n	8004072 <PC_msg_prep+0x32>
		{
			*p2++ = (CAN_PC_ESCAPE); // Precede the following char with an escape byte
 8004062:	4619      	mov	r1, r3
 8004064:	f04f 0c7d 	mov.w	ip, #125	; 0x7d
 8004068:	f801 cb01 	strb.w	ip, [r1], #1
			if (p2 >= p2e) p2--;  // Prevent some bozo from overrunning the buffer.
 800406c:	42b1      	cmp	r1, r6
 800406e:	bf38      	it	cc
 8004070:	460b      	movcc	r3, r1
		}
		*p2++ = *p1++;		// Place the real byte with precision.
 8004072:	f815 c002 	ldrb.w	ip, [r5, r2]
 8004076:	4619      	mov	r1, r3
 8004078:	f801 cb01 	strb.w	ip, [r1], #1

	/* Compute chksum on input message. */
	chk = CANgenchksum(pin, ct);
	
	/* Set up CAN msg with byte stuffing in output buffer. */
	for (i = 0; i < ct; i++)
 800407c:	3201      	adds	r2, #1
 800407e:	42b1      	cmp	r1, r6
 8004080:	bf38      	it	cc
 8004082:	460b      	movcc	r3, r1
 8004084:	42ba      	cmp	r2, r7
 8004086:	dbe7      	blt.n	8004058 <PC_msg_prep+0x18>
		*p2++ = *p1++;		// Place the real byte with precision.
		if (p2 >= p2e) p2 -= 1; // Prevent buffer overflow by a thoughtless scoundrel.
	}

	/* Set up chksum byte stuffing in output buffer. */
	if ((chk == CAN_PC_FRAMEBOUNDARY) || (chk == CAN_PC_ESCAPE) )
 8004088:	280a      	cmp	r0, #10
 800408a:	d001      	beq.n	8004090 <PC_msg_prep+0x50>
 800408c:	287d      	cmp	r0, #125	; 0x7d
 800408e:	d106      	bne.n	800409e <PC_msg_prep+0x5e>
	{
		*p2++ = (CAN_PC_ESCAPE); // Precede following char with escape
 8004090:	461a      	mov	r2, r3
 8004092:	217d      	movs	r1, #125	; 0x7d
 8004094:	f802 1b01 	strb.w	r1, [r2], #1
		if (p2 >= p2e) p2--;  	// Prevent some jerk from jamming too many bytes.
 8004098:	42b2      	cmp	r2, r6
 800409a:	bf38      	it	cc
 800409c:	4613      	movcc	r3, r2
	}
	*p2++ = chk;			// Quietly place the checksum.
 800409e:	461a      	mov	r2, r3
 80040a0:	f802 0b01 	strb.w	r0, [r2], #1
	if (p2 >= p2e) p2--; 		// Prevent buffer overflow by some nefarious nerd.

	*p2++ = (CAN_PC_FRAMEBOUNDARY);	// Set up End of Frame byte
 80040a4:	42b2      	cmp	r2, r6
 80040a6:	bf28      	it	cs
 80040a8:	461a      	movcs	r2, r3
 80040aa:	230a      	movs	r3, #10
 80040ac:	f802 3b01 	strb.w	r3, [r2], #1

	return (p2 - pout);		// Return number of bytes in output
}
 80040b0:	1b10      	subs	r0, r2, r4
 80040b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080040b4 <PC_msg_prepASCII>:

int PC_msg_prepASCII(char* pout, int outsize, struct PCTOGATECOMPRESSED* p)
{
	u8* pin = &p->cm[0];	// Pointer to CAN binary msg
	char *p2 = pout;	// Working pointer
	char *p2e = pout + outsize - 4; // End of output buffer pointer (less checksum and newline)
 80040b4:	3904      	subs	r1, #4
11 = 1st byte, 22 = 2nd byte, (ascii/hex)
CC = checksum byte (ascii/hex) (checksum is made on binary data, including sequence number byte)
*/

int PC_msg_prepASCII(char* pout, int outsize, struct PCTOGATECOMPRESSED* p)
{
 80040b6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80040ba:	4604      	mov	r4, r0
	u8* pin = &p->cm[0];	// Pointer to CAN binary msg
	char *p2 = pout;	// Working pointer
	char *p2e = pout + outsize - 4; // End of output buffer pointer (less checksum and newline)
 80040bc:	eb00 0801 	add.w	r8, r0, r1
	u8 chk;			// Checksum computed on input bytes
	int i = 0;		// Counter for copying

	/* Compute checksum on binary message, including sequence number */
	chk = CANgenchksum(&p->cm[0], p->ct);
 80040c0:	4610      	mov	r0, r2
 80040c2:	f9b2 101c 	ldrsh.w	r1, [r2, #28]
11 = 1st byte, 22 = 2nd byte, (ascii/hex)
CC = checksum byte (ascii/hex) (checksum is made on binary data, including sequence number byte)
*/

int PC_msg_prepASCII(char* pout, int outsize, struct PCTOGATECOMPRESSED* p)
{
 80040c6:	4616      	mov	r6, r2
	char *p2e = pout + outsize - 4; // End of output buffer pointer (less checksum and newline)
	u8 chk;			// Checksum computed on input bytes
	int i = 0;		// Counter for copying

	/* Compute checksum on binary message, including sequence number */
	chk = CANgenchksum(&p->cm[0], p->ct);
 80040c8:	f7ff fe6f 	bl	8003daa <CANgenchksum>
	
	/* Convert binary input message to ASCII/HEX output message */
	while ((p2 < p2e) && (i++ < p->ct)) 
 80040cc:	2500      	movs	r5, #0
	char *p2e = pout + outsize - 4; // End of output buffer pointer (less checksum and newline)
	u8 chk;			// Checksum computed on input bytes
	int i = 0;		// Counter for copying

	/* Compute checksum on binary message, including sequence number */
	chk = CANgenchksum(&p->cm[0], p->ct);
 80040ce:	4607      	mov	r7, r0
*/

int PC_msg_prepASCII(char* pout, int outsize, struct PCTOGATECOMPRESSED* p)
{
	u8* pin = &p->cm[0];	// Pointer to CAN binary msg
	char *p2 = pout;	// Working pointer
 80040d0:	4620      	mov	r0, r4

	/* Compute checksum on binary message, including sequence number */
	chk = CANgenchksum(&p->cm[0], p->ct);
	
	/* Convert binary input message to ASCII/HEX output message */
	while ((p2 < p2e) && (i++ < p->ct)) 
 80040d2:	e003      	b.n	80040dc <PC_msg_prepASCII+0x28>
		p2 = hex(p2, *pin++);
 80040d4:	5d71      	ldrb	r1, [r6, r5]
 80040d6:	f7ff fe2f 	bl	8003d38 <hex>
 80040da:	3501      	adds	r5, #1

	/* Compute checksum on binary message, including sequence number */
	chk = CANgenchksum(&p->cm[0], p->ct);
	
	/* Convert binary input message to ASCII/HEX output message */
	while ((p2 < p2e) && (i++ < p->ct)) 
 80040dc:	4540      	cmp	r0, r8
 80040de:	d203      	bcs.n	80040e8 <PC_msg_prepASCII+0x34>
 80040e0:	f9b6 301c 	ldrsh.w	r3, [r6, #28]
 80040e4:	429d      	cmp	r5, r3
 80040e6:	dbf5      	blt.n	80040d4 <PC_msg_prepASCII+0x20>
		p2 = hex(p2, *pin++);

	/* Add checksum to line */
	p2 = hex(p2, chk);
 80040e8:	4639      	mov	r1, r7
 80040ea:	f7ff fe25 	bl	8003d38 <hex>

	/* Add terminator we have chosen ('\n') */
	*p2++ = ASCIIMSGTERMINATOR;
 80040ee:	230a      	movs	r3, #10
 80040f0:	f800 3b01 	strb.w	r3, [r0], #1
//if (p->ct >= 16) while(1==1);
	return (p2 - pout);	// Return number of bytes in output	
}
 80040f4:	1b00      	subs	r0, r0, r4
 80040f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080040fa <CANcompress>:
static void strhalfwrd(u8* pout, u32 x)
{ // Store u32 in byte array
	*pout++ = (u8)x; *pout++ = (x >> 8); return;
}
int CANcompress(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pin)
{
 80040fa:	b570      	push	{r4, r5, r6, lr}
 80040fc:	4604      	mov	r4, r0

	u32 i;
	int ret;
	u32 tmp;
	/* Identify id types--11b, 29b, faux CAN id. */
	ret = CAN_id_valid(pin->id);
 80040fe:	6808      	ldr	r0, [r1, #0]
static void strhalfwrd(u8* pout, u32 x)
{ // Store u32 in byte array
	*pout++ = (u8)x; *pout++ = (x >> 8); return;
}
int CANcompress(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pin)
{
 8004100:	460e      	mov	r6, r1

	u32 i;
	int ret;
	u32 tmp;
	/* Identify id types--11b, 29b, faux CAN id. */
	ret = CAN_id_valid(pin->id);
 8004102:	f7ff ff43 	bl	8003f8c <CAN_id_valid>
	if (ret < 0) return ret;	// Return: not a valid CAN bus msg id
 8004106:	2800      	cmp	r0, #0
 8004108:	db3d      	blt.n	8004186 <CANcompress+0x8c>

	pout->cm[0] = pout->seq;	// Place sequence number ahead of CAN msg bytes
 800410a:	7fa3      	ldrb	r3, [r4, #30]
 800410c:	7023      	strb	r3, [r4, #0]

	tmp = (pin->dlc & 0xf);
 800410e:	6875      	ldr	r5, [r6, #4]
 8004110:	f005 050f 	and.w	r5, r5, #15
	
	if (ret > 0)
 8004114:	d015      	beq.n	8004142 <CANcompress+0x48>
	{ // Here, 29 bit id msg
		strwrd( &pout->cm[1], ( pin->id | 0x1 ) ); // Low ord bit ON
 8004116:	6831      	ldr	r1, [r6, #0]
 8004118:	1c60      	adds	r0, r4, #1
 800411a:	f041 0101 	orr.w	r1, r1, #1
 800411e:	f7ff fe2f 	bl	8003d80 <strwrd>

		if (tmp > 8) return -1;	// JIC a bogus count
 8004122:	2d08      	cmp	r5, #8
 8004124:	d82a      	bhi.n	800417c <CANcompress+0x82>
		pout->cm[5] = (u8)tmp;
 8004126:	7165      	strb	r5, [r4, #5]

		for (i = 0; i < tmp; i++)	// Copy payload
 8004128:	2300      	movs	r3, #0
 800412a:	e004      	b.n	8004136 <CANcompress+0x3c>
}
static void strhalfwrd(u8* pout, u32 x)
{ // Store u32 in byte array
	*pout++ = (u8)x; *pout++ = (x >> 8); return;
}
int CANcompress(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pin)
 800412c:	18f1      	adds	r1, r6, r3

		if (tmp > 8) return -1;	// JIC a bogus count
		pout->cm[5] = (u8)tmp;

		for (i = 0; i < tmp; i++)	// Copy payload
			pout->cm[i+6] = pin->cd.u8[i];
 800412e:	7a09      	ldrb	r1, [r1, #8]
}
static void strhalfwrd(u8* pout, u32 x)
{ // Store u32 in byte array
	*pout++ = (u8)x; *pout++ = (x >> 8); return;
}
int CANcompress(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pin)
 8004130:	18e2      	adds	r2, r4, r3

		if (tmp > 8) return -1;	// JIC a bogus count
		pout->cm[5] = (u8)tmp;

		for (i = 0; i < tmp; i++)	// Copy payload
			pout->cm[i+6] = pin->cd.u8[i];
 8004132:	7191      	strb	r1, [r2, #6]
		strwrd( &pout->cm[1], ( pin->id | 0x1 ) ); // Low ord bit ON

		if (tmp > 8) return -1;	// JIC a bogus count
		pout->cm[5] = (u8)tmp;

		for (i = 0; i < tmp; i++)	// Copy payload
 8004134:	3301      	adds	r3, #1
 8004136:	42ab      	cmp	r3, r5
 8004138:	d1f8      	bne.n	800412c <CANcompress+0x32>
			pout->cm[i+6] = pin->cd.u8[i];

		pout->ct = (tmp + 6);	// Save number of bytes in compressed msg
 800413a:	3306      	adds	r3, #6
 800413c:	83a3      	strh	r3, [r4, #28]
		return 0;
 800413e:	2000      	movs	r0, #0
 8004140:	bd70      	pop	{r4, r5, r6, pc}
	}
	/* Here, 11 bit id msg */
	if (tmp > 8) return -2;		// JIC a bogus count
 8004142:	2d08      	cmp	r5, #8
 8004144:	d81d      	bhi.n	8004182 <CANcompress+0x88>

	pout->ct = (tmp + 3);	// Save number of bytes in compressed msg (w seq number)
 8004146:	1ceb      	adds	r3, r5, #3
 8004148:	83a3      	strh	r3, [r4, #28]

	if ((pin->id & 0x2) != 0) // Check RTR bit
 800414a:	6833      	ldr	r3, [r6, #0]
 800414c:	f013 0f02 	tst.w	r3, #2
 8004150:	d109      	bne.n	8004166 <CANcompress+0x6c>
 8004152:	4603      	mov	r3, r0
 8004154:	e004      	b.n	8004160 <CANcompress+0x66>
}
static void strhalfwrd(u8* pout, u32 x)
{ // Store u32 in byte array
	*pout++ = (u8)x; *pout++ = (x >> 8); return;
}
int CANcompress(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pin)
 8004156:	18f1      	adds	r1, r6, r3
		tmp = 9; // RTR code 9 means dlc = 0
	}
	else
	{
		for (i = 0; i < tmp; i++) // Copy payload
			pout->cm[i+3] = pin->cd.u8[i];
 8004158:	7a09      	ldrb	r1, [r1, #8]
}
static void strhalfwrd(u8* pout, u32 x)
{ // Store u32 in byte array
	*pout++ = (u8)x; *pout++ = (x >> 8); return;
}
int CANcompress(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pin)
 800415a:	18e2      	adds	r2, r4, r3
		tmp = 9; // RTR code 9 means dlc = 0
	}
	else
	{
		for (i = 0; i < tmp; i++) // Copy payload
			pout->cm[i+3] = pin->cd.u8[i];
 800415c:	70d1      	strb	r1, [r2, #3]
	{ // Here, give RTR a special dlc count
		tmp = 9; // RTR code 9 means dlc = 0
	}
	else
	{
		for (i = 0; i < tmp; i++) // Copy payload
 800415e:	3301      	adds	r3, #1
 8004160:	42ab      	cmp	r3, r5
 8004162:	d1f8      	bne.n	8004156 <CANcompress+0x5c>
 8004164:	e000      	b.n	8004168 <CANcompress+0x6e>

	pout->ct = (tmp + 3);	// Save number of bytes in compressed msg (w seq number)

	if ((pin->id & 0x2) != 0) // Check RTR bit
	{ // Here, give RTR a special dlc count
		tmp = 9; // RTR code 9 means dlc = 0
 8004166:	2509      	movs	r5, #9
	{
		for (i = 0; i < tmp; i++) // Copy payload
			pout->cm[i+3] = pin->cd.u8[i];
	}
	/* 11b id plus dlc|rtr  */
	strhalfwrd( &pout->cm[1], (pin->id >> 16) );
 8004168:	6833      	ldr	r3, [r6, #0]
 800416a:	0c1a      	lsrs	r2, r3, #16
{ // Store u32 in byte array
	*pout++ = (u8)x; *pout++ = (x >> 8); *pout++ = (x >> 16); *pout = (x >> 24); return;
}
static void strhalfwrd(u8* pout, u32 x)
{ // Store u32 in byte array
	*pout++ = (u8)x; *pout++ = (x >> 8); return;
 800416c:	0e1b      	lsrs	r3, r3, #24
 800416e:	70a3      	strb	r3, [r4, #2]
		for (i = 0; i < tmp; i++) // Copy payload
			pout->cm[i+3] = pin->cd.u8[i];
	}
	/* 11b id plus dlc|rtr  */
	strhalfwrd( &pout->cm[1], (pin->id >> 16) );
	pout->cm[1] &= ~0x1f;
 8004170:	f022 031f 	bic.w	r3, r2, #31
	pout->cm[1] |= (u8)(tmp << 1);	
 8004174:	ea43 0545 	orr.w	r5, r3, r5, lsl #1
 8004178:	7065      	strb	r5, [r4, #1]

	return 0;
 800417a:	bd70      	pop	{r4, r5, r6, pc}
	
	if (ret > 0)
	{ // Here, 29 bit id msg
		strwrd( &pout->cm[1], ( pin->id | 0x1 ) ); // Low ord bit ON

		if (tmp > 8) return -1;	// JIC a bogus count
 800417c:	f04f 30ff 	mov.w	r0, #4294967295
 8004180:	bd70      	pop	{r4, r5, r6, pc}

		pout->ct = (tmp + 6);	// Save number of bytes in compressed msg
		return 0;
	}
	/* Here, 11 bit id msg */
	if (tmp > 8) return -2;		// JIC a bogus count
 8004182:	f06f 0001 	mvn.w	r0, #1
	strhalfwrd( &pout->cm[1], (pin->id >> 16) );
	pout->cm[1] &= ~0x1f;
	pout->cm[1] |= (u8)(tmp << 1);	

	return 0;
}
 8004186:	bd70      	pop	{r4, r5, r6, pc}

08004188 <CANcompress_G>:
 *		: pout->c[] = msg bytes
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANcompress_G(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pcan)
{
 8004188:	b538      	push	{r3, r4, r5, lr}
	u32 i;
	u32 tmp;

	pout->cm[0] = pout->seq;		// Place sequence number ahead of CAN msg bytes
 800418a:	7f83      	ldrb	r3, [r0, #30]
 *		: pout->c[] = msg bytes
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANcompress_G(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pcan)
{
 800418c:	4604      	mov	r4, r0
	u32 i;
	u32 tmp;

	pout->cm[0] = pout->seq;		// Place sequence number ahead of CAN msg bytes
 800418e:	f800 3b01 	strb.w	r3, [r0], #1
 *		: pout->c[] = msg bytes
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANcompress_G(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pcan)
{
 8004192:	460d      	mov	r5, r1
	u32 i;
	u32 tmp;

	pout->cm[0] = pout->seq;		// Place sequence number ahead of CAN msg bytes
	strwrd( &pout->cm[1], pcan->id );	// 
 8004194:	6809      	ldr	r1, [r1, #0]
 8004196:	f7ff fdf3 	bl	8003d80 <strwrd>
	tmp = (pcan->dlc & 0xf);
 800419a:	686a      	ldr	r2, [r5, #4]
 800419c:	f002 020f 	and.w	r2, r2, #15

	if (tmp > 8) return -1;
 80041a0:	2a08      	cmp	r2, #8
 80041a2:	d80d      	bhi.n	80041c0 <CANcompress_G+0x38>
	pout->cm[5] = tmp;
 80041a4:	7162      	strb	r2, [r4, #5]

	for (i = 0; i < tmp; i++)	// Copy payload
 80041a6:	2300      	movs	r3, #0
 80041a8:	e004      	b.n	80041b4 <CANcompress_G+0x2c>
 *		: pout->ct = total number of bytes in compressed msg
 *		: pout->c[] = msg bytes
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANcompress_G(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pcan)
 80041aa:	18e8      	adds	r0, r5, r3

	if (tmp > 8) return -1;
	pout->cm[5] = tmp;

	for (i = 0; i < tmp; i++)	// Copy payload
		pout->cm[i+6] = pcan->cd.u8[i];
 80041ac:	7a00      	ldrb	r0, [r0, #8]
 *		: pout->ct = total number of bytes in compressed msg
 *		: pout->c[] = msg bytes
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANcompress_G(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pcan)
 80041ae:	18e1      	adds	r1, r4, r3

	if (tmp > 8) return -1;
	pout->cm[5] = tmp;

	for (i = 0; i < tmp; i++)	// Copy payload
		pout->cm[i+6] = pcan->cd.u8[i];
 80041b0:	7188      	strb	r0, [r1, #6]
	tmp = (pcan->dlc & 0xf);

	if (tmp > 8) return -1;
	pout->cm[5] = tmp;

	for (i = 0; i < tmp; i++)	// Copy payload
 80041b2:	3301      	adds	r3, #1
 80041b4:	4293      	cmp	r3, r2
 80041b6:	d1f8      	bne.n	80041aa <CANcompress_G+0x22>
		pout->cm[i+6] = pcan->cd.u8[i];

	pout->ct = (tmp + 6);	// Save number of bytes in compressed msg
 80041b8:	3306      	adds	r3, #6
 80041ba:	83a3      	strh	r3, [r4, #28]

	return 0;
 80041bc:	2000      	movs	r0, #0
 80041be:	bd38      	pop	{r3, r4, r5, pc}

	pout->cm[0] = pout->seq;		// Place sequence number ahead of CAN msg bytes
	strwrd( &pout->cm[1], pcan->id );	// 
	tmp = (pcan->dlc & 0xf);

	if (tmp > 8) return -1;
 80041c0:	f04f 30ff 	mov.w	r0, #4294967295
		pout->cm[i+6] = pcan->cd.u8[i];

	pout->ct = (tmp + 6);	// Save number of bytes in compressed msg

	return 0;
}
 80041c4:	bd38      	pop	{r3, r4, r5, pc}

080041c6 <CANuncompress>:
{
	return ((*(p+1) << 8) | (*p + 0));
}

int CANuncompress(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
{
 80041c6:	b570      	push	{r4, r5, r6, lr}
	u32 i;
	u32 tmp = 0;
	if ((pin->cm[1] & 0x01) != 0)	// Is this an 11 bit or 29 bit id?
 80041c8:	784b      	ldrb	r3, [r1, #1]
{
	return ((*(p+1) << 8) | (*p + 0));
}

int CANuncompress(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
{
 80041ca:	460d      	mov	r5, r1
	u32 i;
	u32 tmp = 0;
	if ((pin->cm[1] & 0x01) != 0)	// Is this an 11 bit or 29 bit id?
 80041cc:	f013 0101 	ands.w	r1, r3, #1
{
	return ((*(p+1) << 8) | (*p + 0));
}

int CANuncompress(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
{
 80041d0:	4604      	mov	r4, r0
 80041d2:	8bae      	ldrh	r6, [r5, #28]
	u32 i;
	u32 tmp = 0;
	if ((pin->cm[1] & 0x01) != 0)	// Is this an 11 bit or 29 bit id?
 80041d4:	d019      	beq.n	800420a <CANuncompress+0x44>
	{ // Here, a 29 bit 
		if (pin->ct < 6) return -1;	// Too few bytes to a valid 29b compressed msg
 80041d6:	b236      	sxth	r6, r6
 80041d8:	2e05      	cmp	r6, #5
 80041da:	dd3b      	ble.n	8004254 <CANuncompress+0x8e>
		pout->id = getwd (&pin->cm[1]);	// Get 4 bytes into word format
 80041dc:	1c68      	adds	r0, r5, #1
 80041de:	f7ff fdd9 	bl	8003d94 <getwd>
		pout->id &= ~0x1;		// Low bit OFF (reserved for hardware transmit trigger)
 80041e2:	f020 0001 	bic.w	r0, r0, #1
 80041e6:	6020      	str	r0, [r4, #0]

		tmp = pin->cm[5];		// dlc byte
 80041e8:	796a      	ldrb	r2, [r5, #5]
		if (tmp > 8)	return -2;	// dlc: payload ct too large (> 8)
 80041ea:	2a08      	cmp	r2, #8
 80041ec:	d835      	bhi.n	800425a <CANuncompress+0x94>
		pout->dlc = tmp;
		
		if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count
 80041ee:	1d93      	adds	r3, r2, #6
 80041f0:	429e      	cmp	r6, r3
		pout->id = getwd (&pin->cm[1]);	// Get 4 bytes into word format
		pout->id &= ~0x1;		// Low bit OFF (reserved for hardware transmit trigger)

		tmp = pin->cm[5];		// dlc byte
		if (tmp > 8)	return -2;	// dlc: payload ct too large (> 8)
		pout->dlc = tmp;
 80041f2:	6062      	str	r2, [r4, #4]
		
		if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count
 80041f4:	d134      	bne.n	8004260 <CANuncompress+0x9a>
 80041f6:	2300      	movs	r3, #0
 80041f8:	e004      	b.n	8004204 <CANuncompress+0x3e>
static u32 gethalfwd(u8* p) // Move non-aligned bytes into a 2 byte half-word
{
	return ((*(p+1) << 8) | (*p + 0));
}

int CANuncompress(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
 80041fa:	18e8      	adds	r0, r5, r3
		pout->dlc = tmp;
		
		if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count

		for (i = 0; i < tmp; i++)	// Copy payload
			pout->cd.u8[i] = pin->cm[i + 5];
 80041fc:	7940      	ldrb	r0, [r0, #5]
static u32 gethalfwd(u8* p) // Move non-aligned bytes into a 2 byte half-word
{
	return ((*(p+1) << 8) | (*p + 0));
}

int CANuncompress(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
 80041fe:	18e1      	adds	r1, r4, r3
		pout->dlc = tmp;
		
		if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count

		for (i = 0; i < tmp; i++)	// Copy payload
			pout->cd.u8[i] = pin->cm[i + 5];
 8004200:	7208      	strb	r0, [r1, #8]
		if (tmp > 8)	return -2;	// dlc: payload ct too large (> 8)
		pout->dlc = tmp;
		
		if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count

		for (i = 0; i < tmp; i++)	// Copy payload
 8004202:	3301      	adds	r3, #1
 8004204:	4293      	cmp	r3, r2
 8004206:	d3f8      	bcc.n	80041fa <CANuncompress+0x34>
 8004208:	e022      	b.n	8004250 <CANuncompress+0x8a>
			pout->cd.u8[i] = pin->cm[i + 5];
		return 0;	// Success with 29 bit id msg.
	}
	/* Here, an 11 bit id. */
	if (pin->ct < 3) return -4;		// Too few bytes to a valid 11b compressed msg
 800420a:	b232      	sxth	r2, r6
 800420c:	2a02      	cmp	r2, #2
 800420e:	dd2a      	ble.n	8004266 <CANuncompress+0xa0>
{
	return ((*(p+3) << 24) | (*(p+2) << 16) | (*(p+1) << 8) | (*p + 0));
}
static u32 gethalfwd(u8* p) // Move non-aligned bytes into a 2 byte half-word
{
	return ((*(p+1) << 8) | (*p + 0));
 8004210:	78aa      	ldrb	r2, [r5, #2]
 8004212:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	/* Here, an 11 bit id. */
	if (pin->ct < 3) return -4;		// Too few bytes to a valid 11b compressed msg

	/* Extract id and dlc|rtr from half word */
	tmp = gethalfwd (&pin->cm[1]);		// Get 2 bytes into half word form
	pout->id = ((tmp << 16) & 0xffe00000);	// Positon 11b id with dlc stripped.
 8004216:	095a      	lsrs	r2, r3, #5
	tmp = ((tmp >> 1) & 0xf);		// Extract dlc embedded in id's low ord bits
 8004218:	085b      	lsrs	r3, r3, #1
 800421a:	f003 030f 	and.w	r3, r3, #15
	/* Here, an 11 bit id. */
	if (pin->ct < 3) return -4;		// Too few bytes to a valid 11b compressed msg

	/* Extract id and dlc|rtr from half word */
	tmp = gethalfwd (&pin->cm[1]);		// Get 2 bytes into half word form
	pout->id = ((tmp << 16) & 0xffe00000);	// Positon 11b id with dlc stripped.
 800421e:	0552      	lsls	r2, r2, #21
	tmp = ((tmp >> 1) & 0xf);		// Extract dlc embedded in id's low ord bits
	pout->dlc = tmp;			// Set payload byte ct

	if (tmp > 9)	return -5;		// dlc: payload ct too large (> 8)
 8004220:	2b09      	cmp	r3, #9
	/* Here, an 11 bit id. */
	if (pin->ct < 3) return -4;		// Too few bytes to a valid 11b compressed msg

	/* Extract id and dlc|rtr from half word */
	tmp = gethalfwd (&pin->cm[1]);		// Get 2 bytes into half word form
	pout->id = ((tmp << 16) & 0xffe00000);	// Positon 11b id with dlc stripped.
 8004222:	6002      	str	r2, [r0, #0]
	tmp = ((tmp >> 1) & 0xf);		// Extract dlc embedded in id's low ord bits
	pout->dlc = tmp;			// Set payload byte ct
 8004224:	6043      	str	r3, [r0, #4]

	if (tmp > 9)	return -5;		// dlc: payload ct too large (> 8)
 8004226:	d821      	bhi.n	800426c <CANuncompress+0xa6>
	if (tmp == 9)				// Check for RTR
 8004228:	d103      	bne.n	8004232 <CANuncompress+0x6c>
	{ // Here, dlc count code means RTR
		pout->id |= 0x2;		// Set RTR bit in id
 800422a:	f042 0202 	orr.w	r2, r2, #2
 800422e:	6002      	str	r2, [r0, #0]
		pout->dlc = 0;			// RTR only has zero payload ct
 8004230:	6041      	str	r1, [r0, #4]
	}

	if (pin->ct != (s16)(3 + pout->dlc)) return -6; // dlc doesn't match byte count
 8004232:	6862      	ldr	r2, [r4, #4]
 8004234:	b236      	sxth	r6, r6
 8004236:	1cd3      	adds	r3, r2, #3
 8004238:	b21b      	sxth	r3, r3
 800423a:	429e      	cmp	r6, r3
 800423c:	d119      	bne.n	8004272 <CANuncompress+0xac>
 800423e:	2300      	movs	r3, #0
 8004240:	e004      	b.n	800424c <CANuncompress+0x86>
static u32 gethalfwd(u8* p) // Move non-aligned bytes into a 2 byte half-word
{
	return ((*(p+1) << 8) | (*p + 0));
}

int CANuncompress(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
 8004242:	18e8      	adds	r0, r5, r3
	}

	if (pin->ct != (s16)(3 + pout->dlc)) return -6; // dlc doesn't match byte count

	for (i = 0; i < pout->dlc; i++)		// Copy payload
		pout->cd.u8[i] = pin->cm[i + 3];
 8004244:	78c0      	ldrb	r0, [r0, #3]
static u32 gethalfwd(u8* p) // Move non-aligned bytes into a 2 byte half-word
{
	return ((*(p+1) << 8) | (*p + 0));
}

int CANuncompress(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
 8004246:	18e1      	adds	r1, r4, r3
	}

	if (pin->ct != (s16)(3 + pout->dlc)) return -6; // dlc doesn't match byte count

	for (i = 0; i < pout->dlc; i++)		// Copy payload
		pout->cd.u8[i] = pin->cm[i + 3];
 8004248:	7208      	strb	r0, [r1, #8]
		pout->dlc = 0;			// RTR only has zero payload ct
	}

	if (pin->ct != (s16)(3 + pout->dlc)) return -6; // dlc doesn't match byte count

	for (i = 0; i < pout->dlc; i++)		// Copy payload
 800424a:	3301      	adds	r3, #1
 800424c:	4293      	cmp	r3, r2
 800424e:	d1f8      	bne.n	8004242 <CANuncompress+0x7c>
		pout->cd.u8[i] = pin->cm[i + 3];

	return 0;	// Success with 11 bit id msg.
 8004250:	2000      	movs	r0, #0
 8004252:	bd70      	pop	{r4, r5, r6, pc}
{
	u32 i;
	u32 tmp = 0;
	if ((pin->cm[1] & 0x01) != 0)	// Is this an 11 bit or 29 bit id?
	{ // Here, a 29 bit 
		if (pin->ct < 6) return -1;	// Too few bytes to a valid 29b compressed msg
 8004254:	f04f 30ff 	mov.w	r0, #4294967295
 8004258:	bd70      	pop	{r4, r5, r6, pc}
		pout->id = getwd (&pin->cm[1]);	// Get 4 bytes into word format
		pout->id &= ~0x1;		// Low bit OFF (reserved for hardware transmit trigger)

		tmp = pin->cm[5];		// dlc byte
		if (tmp > 8)	return -2;	// dlc: payload ct too large (> 8)
 800425a:	f06f 0001 	mvn.w	r0, #1
 800425e:	bd70      	pop	{r4, r5, r6, pc}
		pout->dlc = tmp;
		
		if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count
 8004260:	f06f 0002 	mvn.w	r0, #2
 8004264:	bd70      	pop	{r4, r5, r6, pc}
		for (i = 0; i < tmp; i++)	// Copy payload
			pout->cd.u8[i] = pin->cm[i + 5];
		return 0;	// Success with 29 bit id msg.
	}
	/* Here, an 11 bit id. */
	if (pin->ct < 3) return -4;		// Too few bytes to a valid 11b compressed msg
 8004266:	f06f 0003 	mvn.w	r0, #3
 800426a:	bd70      	pop	{r4, r5, r6, pc}
	tmp = gethalfwd (&pin->cm[1]);		// Get 2 bytes into half word form
	pout->id = ((tmp << 16) & 0xffe00000);	// Positon 11b id with dlc stripped.
	tmp = ((tmp >> 1) & 0xf);		// Extract dlc embedded in id's low ord bits
	pout->dlc = tmp;			// Set payload byte ct

	if (tmp > 9)	return -5;		// dlc: payload ct too large (> 8)
 800426c:	f06f 0004 	mvn.w	r0, #4
 8004270:	bd70      	pop	{r4, r5, r6, pc}
	{ // Here, dlc count code means RTR
		pout->id |= 0x2;		// Set RTR bit in id
		pout->dlc = 0;			// RTR only has zero payload ct
	}

	if (pin->ct != (s16)(3 + pout->dlc)) return -6; // dlc doesn't match byte count
 8004272:	f06f 0005 	mvn.w	r0, #5

	for (i = 0; i < pout->dlc; i++)		// Copy payload
		pout->cd.u8[i] = pin->cm[i + 3];

	return 0;	// Success with 11 bit id msg.
}
 8004276:	bd70      	pop	{r4, r5, r6, pc}

08004278 <CANuncompress_G>:
 *		: -3 = dlc doesn't match byte count in a 29 bit id msg
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANuncompress_G(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
{
 8004278:	b570      	push	{r4, r5, r6, lr}
	u32 i;
	u32 tmp = 0;

	if (pin->ct < 6) return -1;		// Too few bytes to a valid msg	
 800427a:	f9b1 601c 	ldrsh.w	r6, [r1, #28]
 *		: -3 = dlc doesn't match byte count in a 29 bit id msg
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANuncompress_G(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
{
 800427e:	4604      	mov	r4, r0
	u32 i;
	u32 tmp = 0;

	if (pin->ct < 6) return -1;		// Too few bytes to a valid msg	
 8004280:	2e05      	cmp	r6, #5
 *		: -3 = dlc doesn't match byte count in a 29 bit id msg
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANuncompress_G(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
{
 8004282:	460d      	mov	r5, r1
	u32 i;
	u32 tmp = 0;

	if (pin->ct < 6) return -1;		// Too few bytes to a valid msg	
 8004284:	dd15      	ble.n	80042b2 <CANuncompress_G+0x3a>
	pout->id = getwd (&pin->cm[1]);		// Get 4 bytes into word format
 8004286:	1c48      	adds	r0, r1, #1
 8004288:	f7ff fd84 	bl	8003d94 <getwd>
 800428c:	6020      	str	r0, [r4, #0]
	tmp = pin->cm[5];			// dlc byte
 800428e:	796a      	ldrb	r2, [r5, #5]
	if (tmp > 8)	return -2;		// dlc: payload ct too large (> 8)
 8004290:	2a08      	cmp	r2, #8
 8004292:	d811      	bhi.n	80042b8 <CANuncompress_G+0x40>
	if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count
 8004294:	1d93      	adds	r3, r2, #6
 8004296:	429e      	cmp	r6, r3
 8004298:	d111      	bne.n	80042be <CANuncompress_G+0x46>
	pout->dlc = tmp;
 800429a:	6062      	str	r2, [r4, #4]
	for (i = 0; i < tmp; i++)		// Copy payload
 800429c:	2300      	movs	r3, #0
 800429e:	e004      	b.n	80042aa <CANuncompress_G+0x32>
 *		: -2 = dlc: payload ct too large (> 8) in a 29 bit id msg
 *		: -3 = dlc doesn't match byte count in a 29 bit id msg
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANuncompress_G(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
 80042a0:	18e8      	adds	r0, r5, r3
	tmp = pin->cm[5];			// dlc byte
	if (tmp > 8)	return -2;		// dlc: payload ct too large (> 8)
	if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count
	pout->dlc = tmp;
	for (i = 0; i < tmp; i++)		// Copy payload
		pout->cd.u8[i] = pin->cm[i + 6];
 80042a2:	7980      	ldrb	r0, [r0, #6]
 *		: -2 = dlc: payload ct too large (> 8) in a 29 bit id msg
 *		: -3 = dlc doesn't match byte count in a 29 bit id msg
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANuncompress_G(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
 80042a4:	18e1      	adds	r1, r4, r3
	tmp = pin->cm[5];			// dlc byte
	if (tmp > 8)	return -2;		// dlc: payload ct too large (> 8)
	if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count
	pout->dlc = tmp;
	for (i = 0; i < tmp; i++)		// Copy payload
		pout->cd.u8[i] = pin->cm[i + 6];
 80042a6:	7208      	strb	r0, [r1, #8]
	pout->id = getwd (&pin->cm[1]);		// Get 4 bytes into word format
	tmp = pin->cm[5];			// dlc byte
	if (tmp > 8)	return -2;		// dlc: payload ct too large (> 8)
	if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count
	pout->dlc = tmp;
	for (i = 0; i < tmp; i++)		// Copy payload
 80042a8:	3301      	adds	r3, #1
 80042aa:	4293      	cmp	r3, r2
 80042ac:	d3f8      	bcc.n	80042a0 <CANuncompress_G+0x28>
		pout->cd.u8[i] = pin->cm[i + 6];
	return 0;	// Success with 29 bit id msg.
 80042ae:	2000      	movs	r0, #0
 80042b0:	bd70      	pop	{r4, r5, r6, pc}
int CANuncompress_G(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
{
	u32 i;
	u32 tmp = 0;

	if (pin->ct < 6) return -1;		// Too few bytes to a valid msg	
 80042b2:	f04f 30ff 	mov.w	r0, #4294967295
 80042b6:	bd70      	pop	{r4, r5, r6, pc}
	pout->id = getwd (&pin->cm[1]);		// Get 4 bytes into word format
	tmp = pin->cm[5];			// dlc byte
	if (tmp > 8)	return -2;		// dlc: payload ct too large (> 8)
 80042b8:	f06f 0001 	mvn.w	r0, #1
 80042bc:	bd70      	pop	{r4, r5, r6, pc}
	if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count
 80042be:	f06f 0002 	mvn.w	r0, #2
	pout->dlc = tmp;
	for (i = 0; i < tmp; i++)		// Copy payload
		pout->cd.u8[i] = pin->cm[i + 6];
	return 0;	// Success with 29 bit id msg.
}
 80042c2:	bd70      	pop	{r4, r5, r6, pc}

080042c4 <USB_PC_get_msg_mode>:
 *              : 1 = ascii-- mode 0 converted to ascii/hex, with '\n' new line framing
 *              : ... other modes in the future?
*/

int USB_PC_get_msg_mode(int fd, struct PCTOGATEWAY* ptr, struct CANRCVBUF* pcan )
{
 80042c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int retstatus;
	int temp = 0;
	char c;

	if (localct <= 0) // Is the buffer empty?
 80042c6:	4d36      	ldr	r5, [pc, #216]	; (80043a0 <USB_PC_get_msg_mode+0xdc>)
 *              : 1 = ascii-- mode 0 converted to ascii/hex, with '\n' new line framing
 *              : ... other modes in the future?
*/

int USB_PC_get_msg_mode(int fd, struct PCTOGATEWAY* ptr, struct CANRCVBUF* pcan )
{
 80042c8:	460c      	mov	r4, r1
	int retstatus;
	int temp = 0;
	char c;

	if (localct <= 0) // Is the buffer empty?
 80042ca:	682b      	ldr	r3, [r5, #0]
 *              : 1 = ascii-- mode 0 converted to ascii/hex, with '\n' new line framing
 *              : ... other modes in the future?
*/

int USB_PC_get_msg_mode(int fd, struct PCTOGATEWAY* ptr, struct CANRCVBUF* pcan )
{
 80042cc:	4616      	mov	r6, r2
	int retstatus;
	int temp = 0;
	char c;

	if (localct <= 0) // Is the buffer empty?
 80042ce:	2b00      	cmp	r3, #0
 80042d0:	dc10      	bgt.n	80042f4 <USB_PC_get_msg_mode+0x30>
	{ // Here yes.
		/* Try to replenish buffer if it is empty. */
		localct = read(fd, localbuf, GETLOCALBUFSZ); // Seek a fist-full, or more, bytes
 80042d2:	1d2f      	adds	r7, r5, #4
 80042d4:	4639      	mov	r1, r7
 80042d6:	f44f 7280 	mov.w	r2, #256	; 0x100
 80042da:	f004 f909 	bl	80084f0 <read>
		if (localct == 0) return  0;	// But, if alas, there were none, return empty handed :(
 80042de:	2800      	cmp	r0, #0
	char c;

	if (localct <= 0) // Is the buffer empty?
	{ // Here yes.
		/* Try to replenish buffer if it is empty. */
		localct = read(fd, localbuf, GETLOCALBUFSZ); // Seek a fist-full, or more, bytes
 80042e0:	6028      	str	r0, [r5, #0]
		if (localct == 0) return  0;	// But, if alas, there were none, return empty handed :(
 80042e2:	d054      	beq.n	800438e <USB_PC_get_msg_mode+0xca>
		if (localct  < 0) return -4;	// Ooops!
 80042e4:	db55      	blt.n	8004392 <USB_PC_get_msg_mode+0xce>

		plocalbuf = &localbuf[0];	// Reset pointer for removing buffer bytes.
 80042e6:	4b2f      	ldr	r3, [pc, #188]	; (80043a4 <USB_PC_get_msg_mode+0xe0>)
 80042e8:	601f      	str	r7, [r3, #0]
debug_inct += localct; // Debug: running ct of bytes
 80042ea:	f8d5 7104 	ldr.w	r7, [r5, #260]	; 0x104
 80042ee:	19c0      	adds	r0, r0, r7
 80042f0:	f8c5 0104 	str.w	r0, [r5, #260]	; 0x104
	}

	switch (ptr->mode_link)	// To use 'switch' for just two cases is lame, but allows for easy addition of more modes.
 80042f4:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
 80042f8:	2b01      	cmp	r3, #1
 80042fa:	d028      	beq.n	800434e <USB_PC_get_msg_mode+0x8a>
 80042fc:	d30f      	bcc.n	800431e <USB_PC_get_msg_mode+0x5a>
 80042fe:	2b02      	cmp	r3, #2
 8004300:	d14a      	bne.n	8004398 <USB_PC_get_msg_mode+0xd4>
 8004302:	e03f      	b.n	8004384 <USB_PC_get_msg_mode+0xc0>
	{
	case 0:	// BINARY Mode (byte stuffing/frame byte format) 
		while (localct > 0)	// Onward through those bytes!
		{
			localct -= 1;		// Like a pacman, take a byte
 8004304:	4a26      	ldr	r2, [pc, #152]	; (80043a0 <USB_PC_get_msg_mode+0xdc>)
 8004306:	3b01      	subs	r3, #1
 8004308:	6013      	str	r3, [r2, #0]
			c = *plocalbuf++;	//   and move one step.
 800430a:	4a26      	ldr	r2, [pc, #152]	; (80043a4 <USB_PC_get_msg_mode+0xe0>)
	
			if ( (retstatus = PC_msg_get(ptr,c)) != 0) // Did this byte complete a msg?
 800430c:	4620      	mov	r0, r4
	{
	case 0:	// BINARY Mode (byte stuffing/frame byte format) 
		while (localct > 0)	// Onward through those bytes!
		{
			localct -= 1;		// Like a pacman, take a byte
			c = *plocalbuf++;	//   and move one step.
 800430e:	6813      	ldr	r3, [r2, #0]
 8004310:	f813 1b01 	ldrb.w	r1, [r3], #1
 8004314:	6013      	str	r3, [r2, #0]
	
			if ( (retstatus = PC_msg_get(ptr,c)) != 0) // Did this byte complete a msg?
 8004316:	f7ff fdd9 	bl	8003ecc <PC_msg_get>
 800431a:	1e07      	subs	r7, r0, #0
 800431c:	d110      	bne.n	8004340 <USB_PC_get_msg_mode+0x7c>
	}

	switch (ptr->mode_link)	// To use 'switch' for just two cases is lame, but allows for easy addition of more modes.
	{
	case 0:	// BINARY Mode (byte stuffing/frame byte format) 
		while (localct > 0)	// Onward through those bytes!
 800431e:	682b      	ldr	r3, [r5, #0]
 8004320:	2b00      	cmp	r3, #0
 8004322:	dcef      	bgt.n	8004304 <USB_PC_get_msg_mode+0x40>
 8004324:	e031      	b.n	800438a <USB_PC_get_msg_mode+0xc6>
		break;

	case 1: // ASCII Mode (ascii/hex only with '\n' newline)
		while (localct > 0)	// Rattle through those chars!
		{
			localct -= 1;		// Count chars
 8004326:	4a1e      	ldr	r2, [pc, #120]	; (80043a0 <USB_PC_get_msg_mode+0xdc>)
 8004328:	3b01      	subs	r3, #1
 800432a:	6013      	str	r3, [r2, #0]
			c = *plocalbuf++;	
 800432c:	4a1d      	ldr	r2, [pc, #116]	; (80043a4 <USB_PC_get_msg_mode+0xe0>)

			if ( (retstatus = PC_msg_getASCII(ptr, c)) != 0) // Did this char complete a msg?
 800432e:	4620      	mov	r0, r4

	case 1: // ASCII Mode (ascii/hex only with '\n' newline)
		while (localct > 0)	// Rattle through those chars!
		{
			localct -= 1;		// Count chars
			c = *plocalbuf++;	
 8004330:	6813      	ldr	r3, [r2, #0]
 8004332:	f813 1b01 	ldrb.w	r1, [r3], #1
 8004336:	6013      	str	r3, [r2, #0]

			if ( (retstatus = PC_msg_getASCII(ptr, c)) != 0) // Did this char complete a msg?
 8004338:	f7ff fd5b 	bl	8003df2 <PC_msg_getASCII>
 800433c:	1e07      	subs	r7, r0, #0
 800433e:	d006      	beq.n	800434e <USB_PC_get_msg_mode+0x8a>
			{ // Here, either a good line, or an error, such as too many or few chars, checksum err, or odd number char pairs
				if (retstatus >= 1)
 8004340:	dd2c      	ble.n	800439c <USB_PC_get_msg_mode+0xd8>
					temp = CANuncompress(pcan, &ptr->cmprs); 
 8004342:	4630      	mov	r0, r6
 8004344:	f104 0140 	add.w	r1, r4, #64	; 0x40
 8004348:	f7ff ff3d 	bl	80041c6 <CANuncompress>
 800434c:	e016      	b.n	800437c <USB_PC_get_msg_mode+0xb8>
			}		
		}
		break;

	case 1: // ASCII Mode (ascii/hex only with '\n' newline)
		while (localct > 0)	// Rattle through those chars!
 800434e:	682b      	ldr	r3, [r5, #0]
 8004350:	2b00      	cmp	r3, #0
 8004352:	dce8      	bgt.n	8004326 <USB_PC_get_msg_mode+0x62>
 8004354:	e019      	b.n	800438a <USB_PC_get_msg_mode+0xc6>
		break;
		
	case 2: // ASCII Mode (Gonzaga project: minimal compression)
		while (localct > 0)	// Rattle through those chars!
		{
			localct -= 1;		// Count chars
 8004356:	4a12      	ldr	r2, [pc, #72]	; (80043a0 <USB_PC_get_msg_mode+0xdc>)
 8004358:	3b01      	subs	r3, #1
 800435a:	6013      	str	r3, [r2, #0]
			c = *plocalbuf++;
 800435c:	4a11      	ldr	r2, [pc, #68]	; (80043a4 <USB_PC_get_msg_mode+0xe0>)
//xprintf(6,"%c",c);

			if ( (retstatus = PC_msg_getASCII(ptr, c)) != 0) // Did this char complete a msg?
 800435e:	4620      	mov	r0, r4
		
	case 2: // ASCII Mode (Gonzaga project: minimal compression)
		while (localct > 0)	// Rattle through those chars!
		{
			localct -= 1;		// Count chars
			c = *plocalbuf++;
 8004360:	6813      	ldr	r3, [r2, #0]
 8004362:	f813 1b01 	ldrb.w	r1, [r3], #1
 8004366:	6013      	str	r3, [r2, #0]
//xprintf(6,"%c",c);

			if ( (retstatus = PC_msg_getASCII(ptr, c)) != 0) // Did this char complete a msg?
 8004368:	f7ff fd43 	bl	8003df2 <PC_msg_getASCII>
 800436c:	1e07      	subs	r7, r0, #0
 800436e:	d009      	beq.n	8004384 <USB_PC_get_msg_mode+0xc0>
			{ // Here, either a good line, or an error, such as too many or few chars, checksum err, or odd number char pairs
				if (retstatus >= 1)
 8004370:	dd14      	ble.n	800439c <USB_PC_get_msg_mode+0xd8>
					temp = CANuncompress_G(pcan, &ptr->cmprs); 
 8004372:	4630      	mov	r0, r6
 8004374:	f104 0140 	add.w	r1, r4, #64	; 0x40
 8004378:	f7ff ff7e 	bl	8004278 <CANuncompress_G>
				if (temp < 0) return temp -= 4;
 800437c:	2800      	cmp	r0, #0
 800437e:	da0d      	bge.n	800439c <USB_PC_get_msg_mode+0xd8>
 8004380:	1f07      	subs	r7, r0, #4
 8004382:	e00b      	b.n	800439c <USB_PC_get_msg_mode+0xd8>
			}		
		}
		break;
		
	case 2: // ASCII Mode (Gonzaga project: minimal compression)
		while (localct > 0)	// Rattle through those chars!
 8004384:	682b      	ldr	r3, [r5, #0]
 8004386:	2b00      	cmp	r3, #0
 8004388:	dce5      	bgt.n	8004356 <USB_PC_get_msg_mode+0x92>

	default:	return -3; // The bozo calling this routine failed miserably setting up the struct.
		break;	
	}

	return 0; // No more bytes to work with, AND msg is not complete...sorry, maybe next time.
 800438a:	2700      	movs	r7, #0
 800438c:	e006      	b.n	800439c <USB_PC_get_msg_mode+0xd8>

	if (localct <= 0) // Is the buffer empty?
	{ // Here yes.
		/* Try to replenish buffer if it is empty. */
		localct = read(fd, localbuf, GETLOCALBUFSZ); // Seek a fist-full, or more, bytes
		if (localct == 0) return  0;	// But, if alas, there were none, return empty handed :(
 800438e:	4607      	mov	r7, r0
 8004390:	e004      	b.n	800439c <USB_PC_get_msg_mode+0xd8>
		if (localct  < 0) return -4;	// Ooops!
 8004392:	f06f 0703 	mvn.w	r7, #3
 8004396:	e001      	b.n	800439c <USB_PC_get_msg_mode+0xd8>
			}		

		}
		break;

	default:	return -3; // The bozo calling this routine failed miserably setting up the struct.
 8004398:	f06f 0702 	mvn.w	r7, #2
		break;	
	}

	return 0; // No more bytes to work with, AND msg is not complete...sorry, maybe next time.
}
 800439c:	4638      	mov	r0, r7
 800439e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80043a0:	20000e54 	.word	0x20000e54
 80043a4:	20000150 	.word	0x20000150

080043a8 <USB_toPC_msgASCII>:
#define BUFFSIZE (PCTOGATEWAYSIZE*2+4)
static char b[BUFFSIZE];	// Sufficiently large output buffer
unsigned int debug_outct = 0; // Debug: Running count of outgoing chars

int USB_toPC_msgASCII(int fd, struct PCTOGATECOMPRESSED* p)
{
 80043a8:	b570      	push	{r4, r5, r6, lr}
	int sz;

	/* Convert binary to ascii, and prepare with sequence number at beginning, plus checksum and newline termination */
	sz = PC_msg_prepASCII(&b[0], BUFFSIZE, p);
 80043aa:	4c07      	ldr	r4, [pc, #28]	; (80043c8 <USB_toPC_msgASCII+0x20>)
#define BUFFSIZE (PCTOGATEWAYSIZE*2+4)
static char b[BUFFSIZE];	// Sufficiently large output buffer
unsigned int debug_outct = 0; // Debug: Running count of outgoing chars

int USB_toPC_msgASCII(int fd, struct PCTOGATECOMPRESSED* p)
{
 80043ac:	4605      	mov	r5, r0
 80043ae:	460a      	mov	r2, r1
	int sz;

	/* Convert binary to ascii, and prepare with sequence number at beginning, plus checksum and newline termination */
	sz = PC_msg_prepASCII(&b[0], BUFFSIZE, p);
 80043b0:	4620      	mov	r0, r4
 80043b2:	2164      	movs	r1, #100	; 0x64
 80043b4:	f7ff fe7e 	bl	80040b4 <PC_msg_prepASCII>

	/* Send to USB or other output */
	return	write(fd, b, sz);
 80043b8:	4621      	mov	r1, r4
int USB_toPC_msgASCII(int fd, struct PCTOGATECOMPRESSED* p)
{
	int sz;

	/* Convert binary to ascii, and prepare with sequence number at beginning, plus checksum and newline termination */
	sz = PC_msg_prepASCII(&b[0], BUFFSIZE, p);
 80043ba:	4602      	mov	r2, r0

	/* Send to USB or other output */
	return	write(fd, b, sz);
 80043bc:	4628      	mov	r0, r5
}
 80043be:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

	/* Convert binary to ascii, and prepare with sequence number at beginning, plus checksum and newline termination */
	sz = PC_msg_prepASCII(&b[0], BUFFSIZE, p);

	/* Send to USB or other output */
	return	write(fd, b, sz);
 80043c2:	f004 b8a3 	b.w	800850c <write>
 80043c6:	bf00      	nop
 80043c8:	20000f5c 	.word	0x20000f5c

080043cc <USB_toPC_msgBIN>:
 * @brief	: fd = file descriptor
 * @param	: p = Pointer to struct with bytes to send to PC
 * @return	: count of bytes written
 * ************************************************************************************** */
int USB_toPC_msgBIN(int fd, struct PCTOGATECOMPRESSED* p)
{
 80043cc:	b510      	push	{r4, lr}
//for (i = 0; i < p->ct; i++)
//  xprintf(6,"%02x ",p->cm[i]);
//xprintf (6,"\n\r");

	/* Make an array with seq number, CAN msg. */
	if (p->ct >= PCTOGATEWAYSIZE) return -1; 	// Prevent overruns
 80043ce:	f9b1 301c 	ldrsh.w	r3, [r1, #28]
 * @brief	: fd = file descriptor
 * @param	: p = Pointer to struct with bytes to send to PC
 * @return	: count of bytes written
 * ************************************************************************************** */
int USB_toPC_msgBIN(int fd, struct PCTOGATECOMPRESSED* p)
{
 80043d2:	b09a      	sub	sp, #104	; 0x68
//for (i = 0; i < p->ct; i++)
//  xprintf(6,"%02x ",p->cm[i]);
//xprintf (6,"\n\r");

	/* Make an array with seq number, CAN msg. */
	if (p->ct >= PCTOGATEWAYSIZE) return -1; 	// Prevent overruns
 80043d4:	2b2f      	cmp	r3, #47	; 0x2f
 * @brief	: fd = file descriptor
 * @param	: p = Pointer to struct with bytes to send to PC
 * @return	: count of bytes written
 * ************************************************************************************** */
int USB_toPC_msgBIN(int fd, struct PCTOGATECOMPRESSED* p)
{
 80043d6:	4604      	mov	r4, r0
 80043d8:	460a      	mov	r2, r1
//for (i = 0; i < p->ct; i++)
//  xprintf(6,"%02x ",p->cm[i]);
//xprintf (6,"\n\r");

	/* Make an array with seq number, CAN msg. */
	if (p->ct >= PCTOGATEWAYSIZE) return -1; 	// Prevent overruns
 80043da:	dc09      	bgt.n	80043f0 <USB_toPC_msgBIN+0x24>
	/* Prepare msg for sending.  Add byte stuffing, framing, and checksum to input bytes. */
	sz = PC_msg_prep(&b[0], BUFFSIZE, &p->cm[0], p->ct);
 80043dc:	2164      	movs	r1, #100	; 0x64
 80043de:	a801      	add	r0, sp, #4
 80043e0:	f7ff fe2e 	bl	8004040 <PC_msg_prep>

	/* Send to USB, or other output per file descriptor. */
	return write(fd, b, sz); // Return count of bytes actually written
 80043e4:	a901      	add	r1, sp, #4
//xprintf (6,"\n\r");

	/* Make an array with seq number, CAN msg. */
	if (p->ct >= PCTOGATEWAYSIZE) return -1; 	// Prevent overruns
	/* Prepare msg for sending.  Add byte stuffing, framing, and checksum to input bytes. */
	sz = PC_msg_prep(&b[0], BUFFSIZE, &p->cm[0], p->ct);
 80043e6:	4602      	mov	r2, r0

	/* Send to USB, or other output per file descriptor. */
	return write(fd, b, sz); // Return count of bytes actually written
 80043e8:	4620      	mov	r0, r4
 80043ea:	f004 f88f 	bl	800850c <write>
 80043ee:	e001      	b.n	80043f4 <USB_toPC_msgBIN+0x28>
//for (i = 0; i < p->ct; i++)
//  xprintf(6,"%02x ",p->cm[i]);
//xprintf (6,"\n\r");

	/* Make an array with seq number, CAN msg. */
	if (p->ct >= PCTOGATEWAYSIZE) return -1; 	// Prevent overruns
 80043f0:	f04f 30ff 	mov.w	r0, #4294967295
	/* Prepare msg for sending.  Add byte stuffing, framing, and checksum to input bytes. */
	sz = PC_msg_prep(&b[0], BUFFSIZE, &p->cm[0], p->ct);

	/* Send to USB, or other output per file descriptor. */
	return write(fd, b, sz); // Return count of bytes actually written
}
 80043f4:	b01a      	add	sp, #104	; 0x68
 80043f6:	bd10      	pop	{r4, pc}

080043f8 <USB_toPC_msg_mode>:
 * @return	: postive = number of bytes written
 *              : negative = error
 *              : -1 = The bozo that called this routine gave us booogus ptr->mode_link|send!
 * ************************************************************************************** */
int USB_toPC_msg_mode(int fd, struct PCTOGATEWAY* ptr, struct CANRCVBUF* pcan)
{
 80043f8:	b570      	push	{r4, r5, r6, lr}
 80043fa:	460d      	mov	r5, r1
	switch (ptr->mode_link)	// 'switch' for just two cases is lame, but allow for many more modes.
 80043fc:	f895 303e 	ldrb.w	r3, [r5, #62]	; 0x3e
 * @return	: postive = number of bytes written
 *              : negative = error
 *              : -1 = The bozo that called this routine gave us booogus ptr->mode_link|send!
 * ************************************************************************************** */
int USB_toPC_msg_mode(int fd, struct PCTOGATEWAY* ptr, struct CANRCVBUF* pcan)
{
 8004400:	4604      	mov	r4, r0
	switch (ptr->mode_link)	// 'switch' for just two cases is lame, but allow for many more modes.
 8004402:	2b01      	cmp	r3, #1
 * @return	: postive = number of bytes written
 *              : negative = error
 *              : -1 = The bozo that called this routine gave us booogus ptr->mode_link|send!
 * ************************************************************************************** */
int USB_toPC_msg_mode(int fd, struct PCTOGATEWAY* ptr, struct CANRCVBUF* pcan)
{
 8004404:	4611      	mov	r1, r2
	switch (ptr->mode_link)	// 'switch' for just two cases is lame, but allow for many more modes.
 8004406:	d00c      	beq.n	8004422 <USB_toPC_msg_mode+0x2a>
 8004408:	d302      	bcc.n	8004410 <USB_toPC_msg_mode+0x18>
 800440a:	2b02      	cmp	r3, #2
 800440c:	d117      	bne.n	800443e <USB_toPC_msg_mode+0x46>
 800440e:	e00d      	b.n	800442c <USB_toPC_msg_mode+0x34>
	{
	case 0:	// BINARY Mode: PC<->gateway
		CANcompress(&ptr->cmprs, pcan);		// Compress
 8004410:	3540      	adds	r5, #64	; 0x40
 8004412:	4628      	mov	r0, r5
 8004414:	f7ff fe71 	bl	80040fa <CANcompress>
		return USB_toPC_msgBIN(fd, &ptr->cmprs);
 8004418:	4620      	mov	r0, r4
 800441a:	4629      	mov	r1, r5
		CANcompress_G(&ptr->cmprs, pcan);	// dlc = one byte the only compression
		return USB_toPC_msgASCII(fd, &ptr->cmprs);
		break;
	}
	return -1;
}
 800441c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
{
	switch (ptr->mode_link)	// 'switch' for just two cases is lame, but allow for many more modes.
	{
	case 0:	// BINARY Mode: PC<->gateway
		CANcompress(&ptr->cmprs, pcan);		// Compress
		return USB_toPC_msgBIN(fd, &ptr->cmprs);
 8004420:	e7d4      	b.n	80043cc <USB_toPC_msgBIN>
		ptr->cmprs.cm[0] = ptr->cmprs.seq;			// Place seq number at beginning

		break; // JIC

	case 1: // ASCII/HEX mode: PC<->gateway (same "strong" compression as case 0 above)
		CANcompress(&ptr->cmprs, pcan);		// Heavy compression
 8004422:	3540      	adds	r5, #64	; 0x40
 8004424:	4628      	mov	r0, r5
 8004426:	f7ff fe68 	bl	80040fa <CANcompress>
 800442a:	e003      	b.n	8004434 <USB_toPC_msg_mode+0x3c>
		return USB_toPC_msgASCII(fd, &ptr->cmprs);
		break; // JIC

	case 2: // ASCII/HEX Gonzaga format (minimal compression)
		CANcompress_G(&ptr->cmprs, pcan);	// dlc = one byte the only compression
 800442c:	3540      	adds	r5, #64	; 0x40
 800442e:	4628      	mov	r0, r5
 8004430:	f7ff feaa 	bl	8004188 <CANcompress_G>
		return USB_toPC_msgASCII(fd, &ptr->cmprs);
 8004434:	4620      	mov	r0, r4
 8004436:	4629      	mov	r1, r5
		break;
	}
	return -1;
}
 8004438:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return USB_toPC_msgASCII(fd, &ptr->cmprs);
		break; // JIC

	case 2: // ASCII/HEX Gonzaga format (minimal compression)
		CANcompress_G(&ptr->cmprs, pcan);	// dlc = one byte the only compression
		return USB_toPC_msgASCII(fd, &ptr->cmprs);
 800443c:	e7b4      	b.n	80043a8 <USB_toPC_msgASCII>
		break;
	}
	return -1;
}
 800443e:	f04f 30ff 	mov.w	r0, #4294967295
 8004442:	bd70      	pop	{r4, r5, r6, pc}

08004444 <USB_toPC_msg_asciican>:
 *              : negative = error
 *              : -1 = The bozo that called this routine gave us booogus ptr->mode_link!
 * @NOTE	: Be sure ptr->mode_link is set!
 * ************************************************************************************** */
int USB_toPC_msg_asciican(int fd, char* pin, struct PCTOGATEWAY* ptr)
{
 8004444:	b530      	push	{r4, r5, lr}
 8004446:	4604      	mov	r4, r0
 8004448:	b085      	sub	sp, #20
	int ret;
	struct CANRCVBUF can;

	/* Convert msg to binary */
	ret = PC_msg_asctobin(ptr, pin);
 800444a:	4610      	mov	r0, r2
 *              : negative = error
 *              : -1 = The bozo that called this routine gave us booogus ptr->mode_link!
 * @NOTE	: Be sure ptr->mode_link is set!
 * ************************************************************************************** */
int USB_toPC_msg_asciican(int fd, char* pin, struct PCTOGATEWAY* ptr)
{
 800444c:	4615      	mov	r5, r2
	int ret;
	struct CANRCVBUF can;

	/* Convert msg to binary */
	ret = PC_msg_asctobin(ptr, pin);
 800444e:	f7ff fdb3 	bl	8003fb8 <PC_msg_asctobin>
	if (ret < 0) return ret;
 8004452:	2800      	cmp	r0, #0
 8004454:	db08      	blt.n	8004468 <USB_toPC_msg_asciican+0x24>


	/* Handle binary msg no differently than others */
	ptr->cmprs.seq = ptr->seq;		// Add sequence number (for PC checking for missing msgs)
 8004456:	f895 303d 	ldrb.w	r3, [r5, #61]	; 0x3d
	
	/* Send as we would any msg that is in binary form. */
	return USB_toPC_msg_mode(fd, ptr, &can);
 800445a:	4620      	mov	r0, r4
	ret = PC_msg_asctobin(ptr, pin);
	if (ret < 0) return ret;


	/* Handle binary msg no differently than others */
	ptr->cmprs.seq = ptr->seq;		// Add sequence number (for PC checking for missing msgs)
 800445c:	f885 305e 	strb.w	r3, [r5, #94]	; 0x5e
	
	/* Send as we would any msg that is in binary form. */
	return USB_toPC_msg_mode(fd, ptr, &can);
 8004460:	4629      	mov	r1, r5
 8004462:	466a      	mov	r2, sp
 8004464:	f7ff ffc8 	bl	80043f8 <USB_toPC_msg_mode>
}
 8004468:	b005      	add	sp, #20
 800446a:	bd30      	pop	{r4, r5, pc}

0800446c <lcd_moveCursor>:
void lcd_printToLine(int uartnumber, int line, char* p) {
	lcd_moveCursor(uartnumber, line, 0);
	lcd_print(uartnumber, p);
}

void lcd_moveCursor(int uartnumber, int row, int col) {
 800446c:	b570      	push	{r4, r5, r6, lr}
 800446e:	460d      	mov	r5, r1
	bsp_uart_putc_uartnum(uartnumber, 254); // move cursor command
 8004470:	21fe      	movs	r1, #254	; 0xfe
void lcd_printToLine(int uartnumber, int line, char* p) {
	lcd_moveCursor(uartnumber, line, 0);
	lcd_print(uartnumber, p);
}

void lcd_moveCursor(int uartnumber, int row, int col) {
 8004472:	4604      	mov	r4, r0
 8004474:	4616      	mov	r6, r2
	bsp_uart_putc_uartnum(uartnumber, 254); // move cursor command
 8004476:	f001 fb14 	bl	8005aa2 <bsp_uart_putc_uartnum>

	// determine position
	if (row == 0) {
 800447a:	b915      	cbnz	r5, 8004482 <lcd_moveCursor+0x16>
		bsp_uart_putc_uartnum(uartnumber, 128 + col);
 800447c:	f1a6 0180 	sub.w	r1, r6, #128	; 0x80
 8004480:	e00d      	b.n	800449e <lcd_moveCursor+0x32>
	} else if (row == 1) {
 8004482:	2d01      	cmp	r5, #1
 8004484:	d102      	bne.n	800448c <lcd_moveCursor+0x20>
		bsp_uart_putc_uartnum(uartnumber, 192 + col);
 8004486:	f1a6 0140 	sub.w	r1, r6, #64	; 0x40
 800448a:	e008      	b.n	800449e <lcd_moveCursor+0x32>
	} else if (row == 2) {
 800448c:	2d02      	cmp	r5, #2
 800448e:	d102      	bne.n	8004496 <lcd_moveCursor+0x2a>
		bsp_uart_putc_uartnum(uartnumber, 148 + col);
 8004490:	f1a6 016c 	sub.w	r1, r6, #108	; 0x6c
 8004494:	e003      	b.n	800449e <lcd_moveCursor+0x32>
	} else if (row == 3) {
 8004496:	2d03      	cmp	r5, #3
 8004498:	d107      	bne.n	80044aa <lcd_moveCursor+0x3e>
		bsp_uart_putc_uartnum(uartnumber, 212 + col);
 800449a:	f1a6 012c 	sub.w	r1, r6, #44	; 0x2c
 800449e:	4620      	mov	r0, r4
 80044a0:	b2c9      	uxtb	r1, r1
	}
 80044a2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	} else if (row == 1) {
		bsp_uart_putc_uartnum(uartnumber, 192 + col);
	} else if (row == 2) {
		bsp_uart_putc_uartnum(uartnumber, 148 + col);
	} else if (row == 3) {
		bsp_uart_putc_uartnum(uartnumber, 212 + col);
 80044a6:	f001 bafc 	b.w	8005aa2 <bsp_uart_putc_uartnum>
 80044aa:	bd70      	pop	{r4, r5, r6, pc}

080044ac <lcd_off>:
void lcd_on(int uartnumber) {
	bsp_uart_putc_uartnum(uartnumber, 254);
	bsp_uart_putc_uartnum(uartnumber, 0x0C); // clear screen
}

void lcd_off(int uartnumber) {
 80044ac:	b510      	push	{r4, lr}
	bsp_uart_putc_uartnum(uartnumber, 254);
 80044ae:	21fe      	movs	r1, #254	; 0xfe
void lcd_on(int uartnumber) {
	bsp_uart_putc_uartnum(uartnumber, 254);
	bsp_uart_putc_uartnum(uartnumber, 0x0C); // clear screen
}

void lcd_off(int uartnumber) {
 80044b0:	4604      	mov	r4, r0
	bsp_uart_putc_uartnum(uartnumber, 254);
 80044b2:	f001 faf6 	bl	8005aa2 <bsp_uart_putc_uartnum>
	bsp_uart_putc_uartnum(uartnumber, 0x08); // clear screen
 80044b6:	4620      	mov	r0, r4
 80044b8:	2108      	movs	r1, #8
}
 80044ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bsp_uart_putc_uartnum(uartnumber, 0x0C); // clear screen
}

void lcd_off(int uartnumber) {
	bsp_uart_putc_uartnum(uartnumber, 254);
	bsp_uart_putc_uartnum(uartnumber, 0x08); // clear screen
 80044be:	f001 baf0 	b.w	8005aa2 <bsp_uart_putc_uartnum>

080044c2 <lcd_on>:
void lcd_clear(int uartnumber) {
	bsp_uart_putc_uartnum(uartnumber, 254);
	bsp_uart_putc_uartnum(uartnumber, 0x01); // clear screen
}

void lcd_on(int uartnumber) {
 80044c2:	b510      	push	{r4, lr}
	bsp_uart_putc_uartnum(uartnumber, 254);
 80044c4:	21fe      	movs	r1, #254	; 0xfe
void lcd_clear(int uartnumber) {
	bsp_uart_putc_uartnum(uartnumber, 254);
	bsp_uart_putc_uartnum(uartnumber, 0x01); // clear screen
}

void lcd_on(int uartnumber) {
 80044c6:	4604      	mov	r4, r0
	bsp_uart_putc_uartnum(uartnumber, 254);
 80044c8:	f001 faeb 	bl	8005aa2 <bsp_uart_putc_uartnum>
	bsp_uart_putc_uartnum(uartnumber, 0x0C); // clear screen
 80044cc:	4620      	mov	r0, r4
 80044ce:	210c      	movs	r1, #12
}
 80044d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bsp_uart_putc_uartnum(uartnumber, 0x01); // clear screen
}

void lcd_on(int uartnumber) {
	bsp_uart_putc_uartnum(uartnumber, 254);
	bsp_uart_putc_uartnum(uartnumber, 0x0C); // clear screen
 80044d4:	f001 bae5 	b.w	8005aa2 <bsp_uart_putc_uartnum>

080044d8 <lcd_clear>:

	lcd_clear(uartnumber);
	lcd_moveCursor(0, 0);
}

void lcd_clear(int uartnumber) {
 80044d8:	b510      	push	{r4, lr}
	bsp_uart_putc_uartnum(uartnumber, 254);
 80044da:	21fe      	movs	r1, #254	; 0xfe

	lcd_clear(uartnumber);
	lcd_moveCursor(0, 0);
}

void lcd_clear(int uartnumber) {
 80044dc:	4604      	mov	r4, r0
	bsp_uart_putc_uartnum(uartnumber, 254);
 80044de:	f001 fae0 	bl	8005aa2 <bsp_uart_putc_uartnum>
	bsp_uart_putc_uartnum(uartnumber, 0x01); // clear screen
 80044e2:	4620      	mov	r0, r4
 80044e4:	2101      	movs	r1, #1
}
 80044e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lcd_moveCursor(0, 0);
}

void lcd_clear(int uartnumber) {
	bsp_uart_putc_uartnum(uartnumber, 254);
	bsp_uart_putc_uartnum(uartnumber, 0x01); // clear screen
 80044ea:	f001 bada 	b.w	8005aa2 <bsp_uart_putc_uartnum>

080044ee <lcd_init>:
*						https://www.sparkfun.com/products/9568
*******************************************************************************/

#include "bsp_uart.h"

void lcd_init(int uartnumber) {
 80044ee:	b513      	push	{r0, r1, r4, lr}
	// 9600 baud
	bsp_uart_int_init_number(uartnumber, 9600, 0, 20, 0xC0);
 80044f0:	23c0      	movs	r3, #192	; 0xc0
*						https://www.sparkfun.com/products/9568
*******************************************************************************/

#include "bsp_uart.h"

void lcd_init(int uartnumber) {
 80044f2:	4604      	mov	r4, r0
	// 9600 baud
	bsp_uart_int_init_number(uartnumber, 9600, 0, 20, 0xC0);
 80044f4:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80044f8:	2200      	movs	r2, #0
 80044fa:	9300      	str	r3, [sp, #0]
 80044fc:	3bac      	subs	r3, #172	; 0xac
 80044fe:	f001 fb7b 	bl	8005bf8 <bsp_uart_int_init_number>

	lcd_off(uartnumber);
 8004502:	4620      	mov	r0, r4
 8004504:	f7ff ffd2 	bl	80044ac <lcd_off>
	lcd_on(uartnumber);
 8004508:	4620      	mov	r0, r4
 800450a:	f7ff ffda 	bl	80044c2 <lcd_on>

	lcd_clear(uartnumber);
 800450e:	4620      	mov	r0, r4
 8004510:	f7ff ffe2 	bl	80044d8 <lcd_clear>
	lcd_moveCursor(0, 0);
 8004514:	2000      	movs	r0, #0
 8004516:	4601      	mov	r1, r0
 8004518:	f7ff ffa8 	bl	800446c <lcd_moveCursor>
}
 800451c:	bd1c      	pop	{r2, r3, r4, pc}

0800451e <lcd_print>:
	bsp_uart_putc_uartnum(uartnumber, 254);
	bsp_uart_putc_uartnum(uartnumber, 0x08); // clear screen
}

void lcd_print(int uartnumber, char* p) {
	bsp_uart_puts_uartnum(uartnumber, p);
 800451e:	f001 bae0 	b.w	8005ae2 <bsp_uart_puts_uartnum>

08004522 <lcd_printToLine>:
}

void lcd_printToLine(int uartnumber, int line, char* p) {
 8004522:	b570      	push	{r4, r5, r6, lr}
 8004524:	4614      	mov	r4, r2
	lcd_moveCursor(uartnumber, line, 0);
 8004526:	2200      	movs	r2, #0

void lcd_print(int uartnumber, char* p) {
	bsp_uart_puts_uartnum(uartnumber, p);
}

void lcd_printToLine(int uartnumber, int line, char* p) {
 8004528:	4605      	mov	r5, r0
	lcd_moveCursor(uartnumber, line, 0);
 800452a:	f7ff ff9f 	bl	800446c <lcd_moveCursor>
	lcd_print(uartnumber, p);
 800452e:	4628      	mov	r0, r5
 8004530:	4621      	mov	r1, r4
}
 8004532:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bsp_uart_puts_uartnum(uartnumber, p);
}

void lcd_printToLine(int uartnumber, int line, char* p) {
	lcd_moveCursor(uartnumber, line, 0);
	lcd_print(uartnumber, p);
 8004536:	e7f2      	b.n	800451e <lcd_print>

08004538 <DISCgpiopins_Config>:
{
/* ----------------------------- PORTA -------------------------------------- */
/* ----------------------------- PORTB -------------------------------------- */
/* ----------------------------- PORTC -------------------------------------- */
/* ----------------------------- PORTD -------------------------------------- */
	RCC_AHB1ENR |= (1<<3);	// Enable port D clocking (p 110, p 148)
 8004538:	4b0d      	ldr	r3, [pc, #52]	; (8004570 <DISCgpiopins_Config+0x38>)
 800453a:	681a      	ldr	r2, [r3, #0]
 800453c:	f042 0208 	orr.w	r2, r2, #8
 8004540:	601a      	str	r2, [r3, #0]

	/* PD12,13,14,15 are the green, orange, red, blue LEDs on the Discovery board */
	GPIOD_MODER    =   (GPIOD_MODER   & (~(0x00ff << 24))) | (0x0055 << 24);	// Mode = General purpose output
 8004542:	4b0c      	ldr	r3, [pc, #48]	; (8004574 <DISCgpiopins_Config+0x3c>)
 8004544:	681a      	ldr	r2, [r3, #0]
 8004546:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 800454a:	f042 42aa 	orr.w	r2, r2, #1426063360	; 0x55000000
 800454e:	601a      	str	r2, [r3, #0]
	GPIOD_OTYPER   =   (GPIOD_OTYPER  & (~(0x000f << 12))) | (0x0000 << 12);	// Type output = push-pull
 8004550:	685a      	ldr	r2, [r3, #4]
 8004552:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
 8004556:	605a      	str	r2, [r3, #4]
	GPIOD_OSPEEDR  =   (GPIOD_OSPEEDR & (~(0x00ff << 24))) | (0x00aa << 24);	// Pin speed = Speed 50 MHz
 8004558:	689a      	ldr	r2, [r3, #8]
 800455a:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 800455e:	f042 422a 	orr.w	r2, r2, #2852126720	; 0xaa000000
 8004562:	609a      	str	r2, [r3, #8]
	GPIOD_PUPDR    =   (GPIOD_PUPDR   & (~(0x00ff << 24))) | (0x0000 << 24);	// Pull up/down = none.
 8004564:	68da      	ldr	r2, [r3, #12]
 8004566:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 800456a:	60da      	str	r2, [r3, #12]

	return;
}
 800456c:	4770      	bx	lr
 800456e:	bf00      	nop
 8004570:	40023830 	.word	0x40023830
 8004574:	40020c00 	.word	0x40020c00

08004578 <DISCgpiopins_default>:
/* ----------------------------- PORTB -------------------------------------- */
/* ----------------------------- PORTC -------------------------------------- */
/* ----------------------------- PORTD -------------------------------------- */
/* ----------------------------- PORTE -------------------------------------- */
	return;
}
 8004578:	4770      	bx	lr

0800457a <f4gpiopins_Config>:
 * void f4gpiopins_Config(volatile u32 * p, u16 pinnumber, struct PINCONFIG * s  );
 * @param	: See comments on each in source code
 * @brief	: Configure one gpio pin 
 ******************************************************************************/
void f4gpiopins_Config(volatile u32 * p, u16 pinnumber, struct PINCONFIG * s)
{
 800457a:	b5f0      	push	{r4, r5, r6, r7, lr}

	/* Make sure bus clocking is enabled so that gpio registers can be accessed (p 110) */
	u32 x = ((u32)p - (u32)GPIOA) >> 10;	// Shift count for enabling RCC_AHB1ENR
 800457c:	f100 443f 	add.w	r4, r0, #3204448256	; 0xbf000000
 8004580:	f504 047e 	add.w	r4, r4, #16646144	; 0xfe0000
	RCC_AHB1ENR |= ((1 << x) & 0x01ff);	// Enable port clocking
 8004584:	2601      	movs	r6, #1
 8004586:	4d29      	ldr	r5, [pc, #164]	; (800462c <f4gpiopins_Config+0xb2>)
 ******************************************************************************/
void f4gpiopins_Config(volatile u32 * p, u16 pinnumber, struct PINCONFIG * s)
{

	/* Make sure bus clocking is enabled so that gpio registers can be accessed (p 110) */
	u32 x = ((u32)p - (u32)GPIOA) >> 10;	// Shift count for enabling RCC_AHB1ENR
 8004588:	0aa3      	lsrs	r3, r4, #10
	RCC_AHB1ENR |= ((1 << x) & 0x01ff);	// Enable port clocking
 800458a:	fa16 f303 	lsls.w	r3, r6, r3
 800458e:	682f      	ldr	r7, [r5, #0]
 8004590:	05db      	lsls	r3, r3, #23
 8004592:	0ddb      	lsrs	r3, r3, #23
 8004594:	433b      	orrs	r3, r7
 8004596:	602b      	str	r3, [r5, #0]
00: Input (reset state)
01: General purpose output mode
10: Alternate function mode
11: Analog mode
*/
	GPIO_MODER(p)  &= ~(0x03 << (pinnumber << 1));		// Reset old mode values
 8004598:	fa11 f306 	lsls.w	r3, r1, r6
 800459c:	2503      	movs	r5, #3
 800459e:	6804      	ldr	r4, [r0, #0]
 80045a0:	409d      	lsls	r5, r3
 80045a2:	43ed      	mvns	r5, r5
 80045a4:	ea05 0404 	and.w	r4, r5, r4
 80045a8:	6004      	str	r4, [r0, #0]
	GPIO_MODER(p)  |= ((s->mode & 0x03) << (pinnumber << 1));	// Add new values
 80045aa:	7817      	ldrb	r7, [r2, #0]
 80045ac:	6804      	ldr	r4, [r0, #0]
 80045ae:	f007 0703 	and.w	r7, r7, #3
 80045b2:	409f      	lsls	r7, r3
 80045b4:	4327      	orrs	r7, r4
 80045b6:	4604      	mov	r4, r0
/* TYPE GPIO_OTYPER
These bits are written by software to configure the output type of the I/O port.
0: Output push-pull (reset state)
1: Output open-drain
*/
	GPIO_MODER(p+1) &= ~(0x01 << pinnumber);		// Reset old type bit
 80045b8:	408e      	lsls	r6, r1
01: General purpose output mode
10: Alternate function mode
11: Analog mode
*/
	GPIO_MODER(p)  &= ~(0x03 << (pinnumber << 1));		// Reset old mode values
	GPIO_MODER(p)  |= ((s->mode & 0x03) << (pinnumber << 1));	// Add new values
 80045ba:	f844 7b04 	str.w	r7, [r4], #4
/* TYPE GPIO_OTYPER
These bits are written by software to configure the output type of the I/O port.
0: Output push-pull (reset state)
1: Output open-drain
*/
	GPIO_MODER(p+1) &= ~(0x01 << pinnumber);		// Reset old type bit
 80045be:	6847      	ldr	r7, [r0, #4]
 80045c0:	ea27 0606 	bic.w	r6, r7, r6
 80045c4:	6046      	str	r6, [r0, #4]
	GPIO_MODER(p+1) |=  ((s->type & 0x01) << pinnumber);// Add new type bit
 80045c6:	7856      	ldrb	r6, [r2, #1]
 80045c8:	6847      	ldr	r7, [r0, #4]
 80045ca:	f006 0601 	and.w	r6, r6, #1
 80045ce:	408e      	lsls	r6, r1
 80045d0:	433e      	orrs	r6, r7
 80045d2:	6046      	str	r6, [r0, #4]
01: 25 MHz Medium speed
10: 50 MHz Fast speed
11: 100 MHz High speed on 30 pF (80 MHz Output max speed on 15 pF)
*/

	GPIO_MODER(p+2) &= ~(0x03 << (pinnumber << 1));		// Reset old speed values
 80045d4:	6886      	ldr	r6, [r0, #8]
 80045d6:	ea05 0606 	and.w	r6, r5, r6
 80045da:	6086      	str	r6, [r0, #8]
	GPIO_MODER(p+2) |= ((s->speed & 0x03) << (pinnumber << 1));// Add new values
 80045dc:	7896      	ldrb	r6, [r2, #2]
 80045de:	6887      	ldr	r7, [r0, #8]
 80045e0:	f006 0603 	and.w	r6, r6, #3
 80045e4:	409e      	lsls	r6, r3
 80045e6:	433e      	orrs	r6, r7
 80045e8:	6086      	str	r6, [r0, #8]
00: No pull-up, pull-down
01: Pull-up
10: Pull-down
11: Reserved
*/
	GPIO_MODER(p+3) &= ~(0x03 << (pinnumber << 1));		// Reset old pupdn values
 80045ea:	68c6      	ldr	r6, [r0, #12]
 80045ec:	4035      	ands	r5, r6
 80045ee:	60c5      	str	r5, [r0, #12]
	GPIO_MODER(p+3) |= ((s->pupdn & 0x03) << (pinnumber << 1));	// Add new values
 80045f0:	78d6      	ldrb	r6, [r2, #3]
 80045f2:	68c5      	ldr	r5, [r0, #12]
 80045f4:	f006 0603 	and.w	r6, r6, #3
 80045f8:	fa16 f303 	lsls.w	r3, r6, r3
 80045fc:	432b      	orrs	r3, r5
                                  1111: AF15
0111: AF7

GPIO_AFRL
*/
	if (pinnumber >= 8)
 80045fe:	2907      	cmp	r1, #7
01: Pull-up
10: Pull-down
11: Reserved
*/
	GPIO_MODER(p+3) &= ~(0x03 << (pinnumber << 1));		// Reset old pupdn values
	GPIO_MODER(p+3) |= ((s->pupdn & 0x03) << (pinnumber << 1));	// Add new values
 8004600:	60c3      	str	r3, [r0, #12]
                                  1111: AF15
0111: AF7

GPIO_AFRL
*/
	if (pinnumber >= 8)
 8004602:	d902      	bls.n	800460a <f4gpiopins_Config+0x90>
	{ // Here, the high register (pins 8 - 15) (p 152)
		pinnumber -= 8;		// adjust shift count 
 8004604:	3908      	subs	r1, #8
 8004606:	b289      	uxth	r1, r1
 8004608:	4620      	mov	r0, r4
		p++;			// Point to high register
	}

	GPIO_MODER(p+8) &= ~(0x0f << (pinnumber << 2));			// Remove old AF settings
 800460a:	6a04      	ldr	r4, [r0, #32]
 800460c:	0089      	lsls	r1, r1, #2
 800460e:	230f      	movs	r3, #15
 8004610:	408b      	lsls	r3, r1
 8004612:	ea24 0303 	bic.w	r3, r4, r3
 8004616:	6203      	str	r3, [r0, #32]
	GPIO_MODER(p+8) |=  ((s->afrl & 0x0f) << (pinnumber << 2));	// Add new settings
 8004618:	7912      	ldrb	r2, [r2, #4]
 800461a:	6a03      	ldr	r3, [r0, #32]
 800461c:	f002 020f 	and.w	r2, r2, #15
 8004620:	fa12 f101 	lsls.w	r1, r2, r1
 8004624:	4319      	orrs	r1, r3
 8004626:	6201      	str	r1, [r0, #32]

	return;
}
 8004628:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800462a:	bf00      	nop
 800462c:	40023830 	.word	0x40023830

08004630 <bitcvt>:
 ----------------------------------------------------------------------------------------------*/
static u8 bitcvt(u8 bit)
{
	if (bit != 0) return 1;
	return 0;
}
 8004630:	3800      	subs	r0, #0
 8004632:	bf18      	it	ne
 8004634:	2001      	movne	r0, #1
 8004636:	4770      	bx	lr

08004638 <loadmbx>:
int unsigned can_debugM = 0;	// Msgs removed from buffer

static void loadmbx(struct CANRCVBUF *px)
{
	/* Load the mailbox with the message. */
	CAN_TIxR (CAN1, CAN_MBOX0) = px->id;		// CAN_TIxR  mailbox   identifier register p 659
 8004638:	6802      	ldr	r2, [r0, #0]
 800463a:	4b07      	ldr	r3, [pc, #28]	; (8004658 <loadmbx+0x20>)
 800463c:	601a      	str	r2, [r3, #0]
	CAN_TDTxR(CAN1, CAN_MBOX0) = px->dlc;		// CAN_TDTxR: mailbox  time & length p 660
 800463e:	6841      	ldr	r1, [r0, #4]
 8004640:	4a06      	ldr	r2, [pc, #24]	; (800465c <loadmbx+0x24>)
 8004642:	6011      	str	r1, [r2, #0]
	CAN_TDLxR(CAN1, CAN_MBOX0) = px->cd.ui[0];	// CAN_TDLxRL mailbox  data low  register p 661 
 8004644:	6881      	ldr	r1, [r0, #8]
 8004646:	6051      	str	r1, [r2, #4]
	CAN_TDHxR(CAN1, CAN_MBOX0) = px->cd.ui[1];	// CAN_TDLxRH mailbox  data low  register p 661 
 8004648:	68c1      	ldr	r1, [r0, #12]
 800464a:	6091      	str	r1, [r2, #8]

	/* Request a transmission */
	CAN_TIxR (CAN1, CAN_MBOX0) |= 0x1;	// Set TXRQ bit in ID register of mailbox p 669
 800464c:	681a      	ldr	r2, [r3, #0]
 800464e:	f042 0201 	orr.w	r2, r2, #1
 8004652:	601a      	str	r2, [r3, #0]

	return;
}
 8004654:	4770      	bx	lr
 8004656:	bf00      	nop
 8004658:	40006580 	.word	0x40006580
 800465c:	40006584 	.word	0x40006584

08004660 <can_init_pod_ldr>:
 * @brief 	: Setup CAN pins and hardware
 * @param	: p = pointer to 'struct CAN_PARAMS' with setup values
 * @return	:  n = remaining counts; 0 = enter init mode timedout;-1 = exit init mode timeout; -2 = bad port
*******************************************************************************/
int can_init_pod_ldr(struct CAN_PARAMS *p)
{
 8004660:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int can_timeout;	// Counter for breaking 'while' loops

	/* Enable clocking to CAN module */
	RCC_APB1ENR |= (1<<25);		// CAN1_EN p 144
 8004662:	4b89      	ldr	r3, [pc, #548]	; (8004888 <can_init_pod_ldr+0x228>)
 8004664:	681a      	ldr	r2, [r3, #0]
 8004666:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 800466a:	601a      	str	r2, [r3, #0]

	 /* Note: calculations for PCLK1 = 36MHz */
//	unsigned int brp = (pclk1_freq / 18) / 500000;	// baudrate is set to 500k bit/s

	/* Setup remapping and configure port pins */
	switch (p->port)
 800466c:	7a03      	ldrb	r3, [r0, #8]
 800466e:	2b02      	cmp	r3, #2
 * @brief 	: Setup CAN pins and hardware
 * @param	: p = pointer to 'struct CAN_PARAMS' with setup values
 * @return	:  n = remaining counts; 0 = enter init mode timedout;-1 = exit init mode timeout; -2 = bad port
*******************************************************************************/
int can_init_pod_ldr(struct CAN_PARAMS *p)
{
 8004670:	4604      	mov	r4, r0

	 /* Note: calculations for PCLK1 = 36MHz */
//	unsigned int brp = (pclk1_freq / 18) / 500000;	// baudrate is set to 500k bit/s

	/* Setup remapping and configure port pins */
	switch (p->port)
 8004672:	d00c      	beq.n	800468e <can_init_pod_ldr+0x2e>
 8004674:	2b03      	cmp	r3, #3
 8004676:	d012      	beq.n	800469e <can_init_pod_ldr+0x3e>
 8004678:	2b00      	cmp	r3, #0
 800467a:	f040 80fc 	bne.w	8004876 <can_init_pod_ldr+0x216>
	{
	case 0:	// CAN on port A

		/*  Setup CAN TXD: PA12 for alternate function push/pull output */
	f4gpiopins_Config ((volatile u32*)GPIOA, 12, (struct PINCONFIG*)&outputaf);
 800467e:	4883      	ldr	r0, [pc, #524]	; (800488c <can_init_pod_ldr+0x22c>)
 8004680:	4a83      	ldr	r2, [pc, #524]	; (8004890 <can_init_pod_ldr+0x230>)
 8004682:	210c      	movs	r1, #12
 8004684:	f7ff ff79 	bl	800457a <f4gpiopins_Config>

		/* Setup CAN RXD: PB11 for input pull up */
	f4gpiopins_Config ((volatile u32*)GPIOA, 11, (struct PINCONFIG*)&inputpup);
 8004688:	4880      	ldr	r0, [pc, #512]	; (800488c <can_init_pod_ldr+0x22c>)
 800468a:	210b      	movs	r1, #11
 800468c:	e00e      	b.n	80046ac <can_init_pod_ldr+0x4c>
		break;

	case 2:	// CAN on port B

		/*  Setup CAN TXD: PB09 for alternate function push/pull output  */
	f4gpiopins_Config ((volatile u32*)GPIOB,  9, (struct PINCONFIG*)&outputaf);
 800468e:	4881      	ldr	r0, [pc, #516]	; (8004894 <can_init_pod_ldr+0x234>)
 8004690:	4a7f      	ldr	r2, [pc, #508]	; (8004890 <can_init_pod_ldr+0x230>)
 8004692:	2109      	movs	r1, #9
 8004694:	f7ff ff71 	bl	800457a <f4gpiopins_Config>

		/* Setup CAN RXD: PB08 for input pull up */
	f4gpiopins_Config ((volatile u32*)GPIOB,  8, (struct PINCONFIG*)&inputpup);
 8004698:	487e      	ldr	r0, [pc, #504]	; (8004894 <can_init_pod_ldr+0x234>)
 800469a:	2108      	movs	r1, #8
 800469c:	e006      	b.n	80046ac <can_init_pod_ldr+0x4c>
		break;

	case 3:	// CAN on port D

		/*  Setup CAN TXD: PD01 for alternate function push/pull  */
	f4gpiopins_Config ((volatile u32*)GPIOD,  1, (struct PINCONFIG*)&outputaf);
 800469e:	487e      	ldr	r0, [pc, #504]	; (8004898 <can_init_pod_ldr+0x238>)
 80046a0:	4a7b      	ldr	r2, [pc, #492]	; (8004890 <can_init_pod_ldr+0x230>)
 80046a2:	2101      	movs	r1, #1
 80046a4:	f7ff ff69 	bl	800457a <f4gpiopins_Config>

		/* Setup CAN RXD: PD00 for input pull up */
	f4gpiopins_Config ((volatile u32*)GPIOD,  0, (struct PINCONFIG*)&inputpup);
 80046a8:	487b      	ldr	r0, [pc, #492]	; (8004898 <can_init_pod_ldr+0x238>)
 80046aa:	2100      	movs	r1, #0
		break;
	}

	/* ---------- Set Initialization mode -------------------- */
	/* Request initialization p 632, 648.  DEBUG freeze bit on */
	CAN_MCR(CAN1) &= CAN_MCR_DBF;	// Clear DBF since it is set coming out RESET
 80046ac:	4d7b      	ldr	r5, [pc, #492]	; (800489c <can_init_pod_ldr+0x23c>)

		/*  Setup CAN TXD: PD01 for alternate function push/pull  */
	f4gpiopins_Config ((volatile u32*)GPIOD,  1, (struct PINCONFIG*)&outputaf);

		/* Setup CAN RXD: PD00 for input pull up */
	f4gpiopins_Config ((volatile u32*)GPIOD,  0, (struct PINCONFIG*)&inputpup);
 80046ae:	4a7c      	ldr	r2, [pc, #496]	; (80048a0 <can_init_pod_ldr+0x240>)
 80046b0:	f7ff ff63 	bl	800457a <f4gpiopins_Config>
		break;
	}

	/* ---------- Set Initialization mode -------------------- */
	/* Request initialization p 632, 648.  DEBUG freeze bit on */
	CAN_MCR(CAN1) &= CAN_MCR_DBF;	// Clear DBF since it is set coming out RESET
 80046b4:	682b      	ldr	r3, [r5, #0]
 80046b6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80046ba:	602b      	str	r3, [r5, #0]
	CAN_MCR(CAN1) = ((bitcvt(p->dbf) << 16) | (CAN_MCR_INRQ) );
 80046bc:	7ba0      	ldrb	r0, [r4, #14]
 80046be:	f7ff ffb7 	bl	8004630 <bitcvt>
 80046c2:	0400      	lsls	r0, r0, #16
 80046c4:	f040 0001 	orr.w	r0, r0, #1

	/* The initialization request (above) causes the INAK bit to be set.  This bit goes off when 11 consecutive
	   recessive bits have been received p 633 */
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
 80046c8:	4b76      	ldr	r3, [pc, #472]	; (80048a4 <can_init_pod_ldr+0x244>)
	}

	/* ---------- Set Initialization mode -------------------- */
	/* Request initialization p 632, 648.  DEBUG freeze bit on */
	CAN_MCR(CAN1) &= CAN_MCR_DBF;	// Clear DBF since it is set coming out RESET
	CAN_MCR(CAN1) = ((bitcvt(p->dbf) << 16) | (CAN_MCR_INRQ) );
 80046ca:	6028      	str	r0, [r5, #0]

	/* The initialization request (above) causes the INAK bit to be set.  This bit goes off when 11 consecutive
	   recessive bits have been received p 633 */
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
	while ( ((CAN_MSR(CAN1) & CAN_MSR_INAK) == 0 ) && (can_timeout-- >= 0) );	// Wait until initialization mode starts or times out
 80046cc:	4a76      	ldr	r2, [pc, #472]	; (80048a8 <can_init_pod_ldr+0x248>)
 80046ce:	6810      	ldr	r0, [r2, #0]
 80046d0:	f010 0001 	ands.w	r0, r0, #1
 80046d4:	d003      	beq.n	80046de <can_init_pod_ldr+0x7e>
	if (can_timeout <= 0 ) return 0;	// Timed out
 80046d6:	2b00      	cmp	r3, #0
 80046d8:	f340 80d0 	ble.w	800487c <can_init_pod_ldr+0x21c>
 80046dc:	e004      	b.n	80046e8 <can_init_pod_ldr+0x88>
	CAN_MCR(CAN1) = ((bitcvt(p->dbf) << 16) | (CAN_MCR_INRQ) );

	/* The initialization request (above) causes the INAK bit to be set.  This bit goes off when 11 consecutive
	   recessive bits have been received p 633 */
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
	while ( ((CAN_MSR(CAN1) & CAN_MSR_INAK) == 0 ) && (can_timeout-- >= 0) );	// Wait until initialization mode starts or times out
 80046de:	3b01      	subs	r3, #1
 80046e0:	f113 0f02 	cmn.w	r3, #2
 80046e4:	d1f2      	bne.n	80046cc <can_init_pod_ldr+0x6c>
 80046e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	/* Compute baud rate prescalar code (BRP), given the baud rate and pclk1_freq, and sampling intervals p 645, fig 233 */
	/* set BTR register so that sample point is at about 72% bit time from bit start */
//	#define TBS1	12	// Bit segment 1
//	#define TBS2	5	// Bit segment 2
	u32 brp;		// Baud rate code
	brp = (pclk1_freq/(1 + (bitcvt(p->tbs1)) + (bitcvt(p->tbs2)))) / p->baudrate;
 80046e8:	7b60      	ldrb	r0, [r4, #13]
	//                         SJW                      TBS2                       TBS1                      BRP
//	CAN_BTR(CAN1) &= ~( ((          0x03) << 24) | ((           0x07) << 20) | ((           0x0F) << 16) | ((          0x1FF) << 0) ); 
//	CAN_BTR(CAN1) |=  ( (((SJW-1) & 0x03) << 24) | (((TBS2-1) & 0x07) << 20) | (((TBS1-1) & 0x0F) << 16) | (((brp-1) & 0x1FF) << 0) );


	CAN_BTR(CAN1) = 0x01230000; 	// Set register to RESET value p 657
 80046ea:	4d70      	ldr	r5, [pc, #448]	; (80048ac <can_init_pod_ldr+0x24c>)
	/* Compute baud rate prescalar code (BRP), given the baud rate and pclk1_freq, and sampling intervals p 645, fig 233 */
	/* set BTR register so that sample point is at about 72% bit time from bit start */
//	#define TBS1	12	// Bit segment 1
//	#define TBS2	5	// Bit segment 2
	u32 brp;		// Baud rate code
	brp = (pclk1_freq/(1 + (bitcvt(p->tbs1)) + (bitcvt(p->tbs2)))) / p->baudrate;
 80046ec:	f7ff ffa0 	bl	8004630 <bitcvt>
 80046f0:	4606      	mov	r6, r0
 80046f2:	7b20      	ldrb	r0, [r4, #12]
 80046f4:	f7ff ff9c 	bl	8004630 <bitcvt>
 80046f8:	4b6d      	ldr	r3, [pc, #436]	; (80048b0 <can_init_pod_ldr+0x250>)
 80046fa:	1836      	adds	r6, r6, r0
 80046fc:	681b      	ldr	r3, [r3, #0]
 80046fe:	3601      	adds	r6, #1
 8004700:	fbb3 f6f6 	udiv	r6, r3, r6
 8004704:	6863      	ldr	r3, [r4, #4]
 8004706:	fbb6 f6f3 	udiv	r6, r6, r3
	//                         SJW                      TBS2                       TBS1                      BRP
//	CAN_BTR(CAN1) &= ~( ((          0x03) << 24) | ((           0x07) << 20) | ((           0x0F) << 16) | ((          0x1FF) << 0) ); 
//	CAN_BTR(CAN1) |=  ( (((SJW-1) & 0x03) << 24) | (((TBS2-1) & 0x07) << 20) | (((TBS1-1) & 0x0F) << 16) | (((brp-1) & 0x1FF) << 0) );


	CAN_BTR(CAN1) = 0x01230000; 	// Set register to RESET value p 657
 800470a:	4b6a      	ldr	r3, [pc, #424]	; (80048b4 <can_init_pod_ldr+0x254>)
 800470c:	602b      	str	r3, [r5, #0]

	CAN_BTR(CAN1) |=    (bitcvt(p->silm)            << 31);	// Silent mode bit
 800470e:	7a60      	ldrb	r0, [r4, #9]
 8004710:	682f      	ldr	r7, [r5, #0]
 8004712:	f7ff ff8d 	bl	8004630 <bitcvt>
 8004716:	ea47 70c0 	orr.w	r0, r7, r0, lsl #31
 800471a:	6028      	str	r0, [r5, #0]
	CAN_BTR(CAN1) |=    (bitcvt(p->lbkm)            << 30);	// Loopback mode bit
 800471c:	7aa0      	ldrb	r0, [r4, #10]
 800471e:	682f      	ldr	r7, [r5, #0]
 8004720:	f7ff ff86 	bl	8004630 <bitcvt>
 8004724:	ea47 7080 	orr.w	r0, r7, r0, lsl #30
 8004728:	6028      	str	r0, [r5, #0]
	CAN_BTR(CAN1) |=  (((bitcvt(p->sjw )-1) & 0x03) << 24);	// Resynchronization jump width
 800472a:	7ae0      	ldrb	r0, [r4, #11]
 800472c:	682f      	ldr	r7, [r5, #0]
 800472e:	f7ff ff7f 	bl	8004630 <bitcvt>
 8004732:	3801      	subs	r0, #1
 8004734:	f000 0003 	and.w	r0, r0, #3
 8004738:	ea47 6700 	orr.w	r7, r7, r0, lsl #24
 800473c:	602f      	str	r7, [r5, #0]
	CAN_BTR(CAN1) |=  (((bitcvt(p->tbs2)-1) & 0x07) << 20);	// Time segment 2
 800473e:	7b20      	ldrb	r0, [r4, #12]
 8004740:	682f      	ldr	r7, [r5, #0]
 8004742:	f7ff ff75 	bl	8004630 <bitcvt>
 8004746:	3801      	subs	r0, #1
 8004748:	f000 0007 	and.w	r0, r0, #7
 800474c:	ea47 5700 	orr.w	r7, r7, r0, lsl #20
 8004750:	602f      	str	r7, [r5, #0]
	CAN_BTR(CAN1) |=  (((bitcvt(p->tbs1)-1) & 0x0F) << 16); // Time segment 1
 8004752:	7b60      	ldrb	r0, [r4, #13]
 8004754:	682f      	ldr	r7, [r5, #0]
 8004756:	f7ff ff6b 	bl	8004630 <bitcvt>
 800475a:	3801      	subs	r0, #1
 800475c:	f000 000f 	and.w	r0, r0, #15
 8004760:	ea47 4700 	orr.w	r7, r7, r0, lsl #16
 8004764:	602f      	str	r7, [r5, #0]
	CAN_BTR(CAN1) |=  (((brp-1)            & 0x3FF)  << 0); // Baud rate prescalar
 8004766:	3e01      	subs	r6, #1
 8004768:	682b      	ldr	r3, [r5, #0]
 800476a:	05b6      	lsls	r6, r6, #22
 800476c:	0db6      	lsrs	r6, r6, #22
 800476e:	431e      	orrs	r6, r3
 8004770:	602e      	str	r6, [r5, #0]
        0: The CAN hardware will automatically retransmit the message until it has been
        successfully transmitted according to the CAN standard.
        1: A message will be transmitted only once, independently of the transmission result
        (successful, error or arbitration lost).
 */
	CAN_MCR(CAN1) &= ~(0xfe);				// Clear bits except for INAQ
 8004772:	f855 3c1c 	ldr.w	r3, [r5, #-28]
 8004776:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
 800477a:	f845 3c1c 	str.w	r3, [r5, #-28]
	CAN_MCR(CAN1) |=  (bitcvt(p->ttcm) << 7);	// Time triggered communication mode
 800477e:	7be0      	ldrb	r0, [r4, #15]
 8004780:	f855 6c1c 	ldr.w	r6, [r5, #-28]
 8004784:	f7ff ff54 	bl	8004630 <bitcvt>
 8004788:	ea46 10c0 	orr.w	r0, r6, r0, lsl #7
 800478c:	f845 0c1c 	str.w	r0, [r5, #-28]
	CAN_MCR(CAN1) |=  (bitcvt(p->abom) << 6);	// Automatic bus-off management
 8004790:	7c20      	ldrb	r0, [r4, #16]
 8004792:	f855 6c1c 	ldr.w	r6, [r5, #-28]
 8004796:	f7ff ff4b 	bl	8004630 <bitcvt>
 800479a:	ea46 1080 	orr.w	r0, r6, r0, lsl #6
 800479e:	f845 0c1c 	str.w	r0, [r5, #-28]
	CAN_MCR(CAN1) |=  (bitcvt(p->awum) << 5);	// Auto WakeUp Mode
 80047a2:	7c60      	ldrb	r0, [r4, #17]
 80047a4:	f855 6c1c 	ldr.w	r6, [r5, #-28]
 80047a8:	f7ff ff42 	bl	8004630 <bitcvt>
 80047ac:	ea46 1040 	orr.w	r0, r6, r0, lsl #5
 80047b0:	f845 0c1c 	str.w	r0, [r5, #-28]
	CAN_MCR(CAN1) |=  (bitcvt(p->nart) << 4);	// No Automatic ReTry (0 = retry; non-zero = auto retry)
 80047b4:	7ca0      	ldrb	r0, [r4, #18]
 80047b6:	f855 6c1c 	ldr.w	r6, [r5, #-28]
 80047ba:	f7ff ff39 	bl	8004630 <bitcvt>
 80047be:	ea46 1000 	orr.w	r0, r6, r0, lsl #4
 80047c2:	f845 0c1c 	str.w	r0, [r5, #-28]

	/* Leave initialization mode */
	CAN_MCR(CAN1) &= ~CAN_MCR_INRQ;
 80047c6:	f855 3c1c 	ldr.w	r3, [r5, #-28]
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
 80047ca:	4a36      	ldr	r2, [pc, #216]	; (80048a4 <can_init_pod_ldr+0x244>)
	CAN_MCR(CAN1) |=  (bitcvt(p->abom) << 6);	// Automatic bus-off management
	CAN_MCR(CAN1) |=  (bitcvt(p->awum) << 5);	// Auto WakeUp Mode
	CAN_MCR(CAN1) |=  (bitcvt(p->nart) << 4);	// No Automatic ReTry (0 = retry; non-zero = auto retry)

	/* Leave initialization mode */
	CAN_MCR(CAN1) &= ~CAN_MCR_INRQ;
 80047cc:	f023 0301 	bic.w	r3, r3, #1
 80047d0:	f845 3c1c 	str.w	r3, [r5, #-28]
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
	while ( ((CAN_MSR(CAN1) & CAN_MSR_INAK) != 0 ) && (can_timeout-- >= 0) );	// Wait until initialization mode starts or times out
 80047d4:	4b34      	ldr	r3, [pc, #208]	; (80048a8 <can_init_pod_ldr+0x248>)
 80047d6:	681b      	ldr	r3, [r3, #0]
 80047d8:	f013 0f01 	tst.w	r3, #1
 80047dc:	d102      	bne.n	80047e4 <can_init_pod_ldr+0x184>
	if (can_timeout <= 0 ) return -1;	// Timed out
 80047de:	2a00      	cmp	r2, #0
 80047e0:	dc07      	bgt.n	80047f2 <can_init_pod_ldr+0x192>
 80047e2:	e04d      	b.n	8004880 <can_init_pod_ldr+0x220>
	CAN_MCR(CAN1) |=  (bitcvt(p->nart) << 4);	// No Automatic ReTry (0 = retry; non-zero = auto retry)

	/* Leave initialization mode */
	CAN_MCR(CAN1) &= ~CAN_MCR_INRQ;
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
	while ( ((CAN_MSR(CAN1) & CAN_MSR_INAK) != 0 ) && (can_timeout-- >= 0) );	// Wait until initialization mode starts or times out
 80047e4:	3a01      	subs	r2, #1
 80047e6:	f112 0f02 	cmn.w	r2, #2
 80047ea:	d1f3      	bne.n	80047d4 <can_init_pod_ldr+0x174>
	if (can_timeout <= 0 ) return -1;	// Timed out
 80047ec:	f04f 30ff 	mov.w	r0, #4294967295
 80047f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

/* CYCCNT counter is in the Cortex-M-series core.  See the following for details 
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html */
	*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
 80047f2:	4b31      	ldr	r3, [pc, #196]	; (80048b8 <can_init_pod_ldr+0x258>)
	// Handles high priority CAN msgs, e.g. RESETALL, TIMESYNCx
	NVICIPR (NVIC_I2C1_EV_IRQ, NVIC_I2C1_EV_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
	NVICISER(NVIC_I2C1_EV_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')

	// Handles non-high priority msgs, e.g. sensor readings
	NVICIPR (NVIC_I2C1_ER_IRQ, NVIC_I2C1_ER_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
 80047f4:	4d31      	ldr	r5, [pc, #196]	; (80048bc <can_init_pod_ldr+0x25c>)
	while ( ((CAN_MSR(CAN1) & CAN_MSR_INAK) != 0 ) && (can_timeout-- >= 0) );	// Wait until initialization mode starts or times out
	if (can_timeout <= 0 ) return -1;	// Timed out

/* CYCCNT counter is in the Cortex-M-series core.  See the following for details 
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html */
	*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
 80047f6:	6819      	ldr	r1, [r3, #0]
	NVICIPR (NVIC_I2C1_EV_IRQ, NVIC_I2C1_EV_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
	NVICISER(NVIC_I2C1_EV_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')

	// Handles non-high priority msgs, e.g. sensor readings
	NVICIPR (NVIC_I2C1_ER_IRQ, NVIC_I2C1_ER_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
	NVICISER(NVIC_I2C1_ER_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')
 80047f8:	4c31      	ldr	r4, [pc, #196]	; (80048c0 <can_init_pod_ldr+0x260>)
	*(volatile unsigned int*)0xE0001000 |= 0x1;	// Enable DTW_CYCCNT (Data Watch cycle counter)

	/* Set and enable interrupt controller for doing software interrupt */
	// Handles high priority CAN msgs, e.g. RESETALL, TIMESYNCx
	NVICIPR (NVIC_I2C1_EV_IRQ, NVIC_I2C1_EV_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
	NVICISER(NVIC_I2C1_EV_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')
 80047fa:	4832      	ldr	r0, [pc, #200]	; (80048c4 <can_init_pod_ldr+0x264>)
	while ( ((CAN_MSR(CAN1) & CAN_MSR_INAK) != 0 ) && (can_timeout-- >= 0) );	// Wait until initialization mode starts or times out
	if (can_timeout <= 0 ) return -1;	// Timed out

/* CYCCNT counter is in the Cortex-M-series core.  See the following for details 
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html */
	*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
 80047fc:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 8004800:	6019      	str	r1, [r3, #0]
	*(volatile unsigned int*)0xE0001000 |= 0x1;	// Enable DTW_CYCCNT (Data Watch cycle counter)
 8004802:	4b31      	ldr	r3, [pc, #196]	; (80048c8 <can_init_pod_ldr+0x268>)
 8004804:	6819      	ldr	r1, [r3, #0]
 8004806:	f041 0101 	orr.w	r1, r1, #1
 800480a:	6019      	str	r1, [r3, #0]

	/* Set and enable interrupt controller for doing software interrupt */
	// Handles high priority CAN msgs, e.g. RESETALL, TIMESYNCx
	NVICIPR (NVIC_I2C1_EV_IRQ, NVIC_I2C1_EV_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
 800480c:	4b2f      	ldr	r3, [pc, #188]	; (80048cc <can_init_pod_ldr+0x26c>)
 800480e:	6819      	ldr	r1, [r3, #0]
 8004810:	f041 4110 	orr.w	r1, r1, #2415919104	; 0x90000000
 8004814:	6019      	str	r1, [r3, #0]
	NVICISER(NVIC_I2C1_EV_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')

	// Handles non-high priority msgs, e.g. sensor readings
	NVICIPR (NVIC_I2C1_ER_IRQ, NVIC_I2C1_ER_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
 8004816:	6829      	ldr	r1, [r5, #0]
	NVICISER(NVIC_I2C1_ER_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')
 8004818:	6826      	ldr	r6, [r4, #0]
	*(volatile unsigned int*)0xE0001000 |= 0x1;	// Enable DTW_CYCCNT (Data Watch cycle counter)

	/* Set and enable interrupt controller for doing software interrupt */
	// Handles high priority CAN msgs, e.g. RESETALL, TIMESYNCx
	NVICIPR (NVIC_I2C1_EV_IRQ, NVIC_I2C1_EV_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
	NVICISER(NVIC_I2C1_EV_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')
 800481a:	6803      	ldr	r3, [r0, #0]
	// Handles non-high priority msgs, e.g. sensor readings
	NVICIPR (NVIC_I2C1_ER_IRQ, NVIC_I2C1_ER_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
	NVICISER(NVIC_I2C1_ER_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')

	// Handles non-high priority msgs, e.g. sensor readings
	NVICIPR (NVIC_I2C2_ER_IRQ, NVIC_I2C2_ER_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
 800481c:	f441 0160 	orr.w	r1, r1, #14680064	; 0xe00000
 8004820:	f041 01a0 	orr.w	r1, r1, #160	; 0xa0
 8004824:	6029      	str	r1, [r5, #0]
	NVICISER(NVIC_I2C2_ER_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')
 8004826:	f046 0105 	orr.w	r1, r6, #5
 800482a:	6021      	str	r1, [r4, #0]
	NVICISER(NVIC_CAN1_RX1_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_SCE_IRQ, NVIC_CAN_SCE_IRQ_PRIORITY );// Set interrupt priority
	NVICISER(NVIC_CAN1_SCE_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_TX_IRQ, NVIC_USB_HP_CAN_TX_IRQ_PRIORITY );// Set interrupt priority
 800482c:	4928      	ldr	r1, [pc, #160]	; (80048d0 <can_init_pod_ldr+0x270>)
	// Handles non-high priority msgs, e.g. sensor readings
	NVICIPR (NVIC_I2C2_ER_IRQ, NVIC_I2C2_ER_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
	NVICISER(NVIC_I2C2_ER_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')

	/* Set and enable interrupt controller for CAN interrupts */
	NVICIPR (NVIC_CAN1_RX1_IRQ, NVIC_CAN_RX1_IRQ_PRIORITY );	// Set interrupt priority
 800482e:	4c29      	ldr	r4, [pc, #164]	; (80048d4 <can_init_pod_ldr+0x274>)
	NVICISER(NVIC_CAN1_RX1_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_SCE_IRQ, NVIC_CAN_SCE_IRQ_PRIORITY );// Set interrupt priority
	NVICISER(NVIC_CAN1_SCE_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_TX_IRQ, NVIC_USB_HP_CAN_TX_IRQ_PRIORITY );// Set interrupt priority
 8004830:	680e      	ldr	r6, [r1, #0]
	// Handles non-high priority msgs, e.g. sensor readings
	NVICIPR (NVIC_I2C2_ER_IRQ, NVIC_I2C2_ER_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
	NVICISER(NVIC_I2C2_ER_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')

	/* Set and enable interrupt controller for CAN interrupts */
	NVICIPR (NVIC_CAN1_RX1_IRQ, NVIC_CAN_RX1_IRQ_PRIORITY );	// Set interrupt priority
 8004832:	6825      	ldr	r5, [r4, #0]
	NVICISER(NVIC_CAN1_RX1_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_SCE_IRQ, NVIC_CAN_SCE_IRQ_PRIORITY );// Set interrupt priority
	NVICISER(NVIC_CAN1_SCE_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_TX_IRQ, NVIC_USB_HP_CAN_TX_IRQ_PRIORITY );// Set interrupt priority
 8004834:	f046 46e0 	orr.w	r6, r6, #1879048192	; 0x70000000
 8004838:	600e      	str	r6, [r1, #0]
	NVICISER(NVIC_CAN1_TX_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_RX0_IRQ, NVIC_USB_LP_CAN_RX0_IRQ_PRIORITY );// Set interrupt priority
 800483a:	4927      	ldr	r1, [pc, #156]	; (80048d8 <can_init_pod_ldr+0x278>)
	NVICISER(NVIC_CAN1_RX0_IRQ);				// Enable interrupt controller
 800483c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
	NVICISER(NVIC_CAN1_SCE_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_TX_IRQ, NVIC_USB_HP_CAN_TX_IRQ_PRIORITY );// Set interrupt priority
	NVICISER(NVIC_CAN1_TX_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_RX0_IRQ, NVIC_USB_LP_CAN_RX0_IRQ_PRIORITY );// Set interrupt priority
 8004840:	ea45 0101 	orr.w	r1, r5, r1
	NVICISER(NVIC_CAN1_RX0_IRQ);				// Enable interrupt controller
 8004844:	f443 03f0 	orr.w	r3, r3, #7864320	; 0x780000
	NVICISER(NVIC_CAN1_SCE_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_TX_IRQ, NVIC_USB_HP_CAN_TX_IRQ_PRIORITY );// Set interrupt priority
	NVICISER(NVIC_CAN1_TX_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_RX0_IRQ, NVIC_USB_LP_CAN_RX0_IRQ_PRIORITY );// Set interrupt priority
 8004848:	6021      	str	r1, [r4, #0]
	NVICISER(NVIC_CAN1_RX0_IRQ);				// Enable interrupt controller
 800484a:	6003      	str	r3, [r0, #0]
	       0: No interrupt generated when state of FMP[1:0] bits are not 00b.
	       1: Interrupt generated when state of FMP[1:0] bits are not 00b.
	   Bit 4 FMPIE1: FIFO message pending interrupt enable
	       0: No interrupt generated when state of FMP[1:0] bits are not 00b.
	       1: Interrupt generated when state of FMP[1:0] bits are not 00b. */
	CAN_IER(CAN1) |= CAN_IER_FMPIE0;	// FIFO 0 p 655
 800484c:	4b23      	ldr	r3, [pc, #140]	; (80048dc <can_init_pod_ldr+0x27c>)
 800484e:	6819      	ldr	r1, [r3, #0]
 8004850:	f041 0102 	orr.w	r1, r1, #2
 8004854:	6019      	str	r1, [r3, #0]
	CAN_IER(CAN1) |= CAN_IER_FMPIE1;	// FIFO 1 p 655
 8004856:	6819      	ldr	r1, [r3, #0]
 8004858:	f041 0110 	orr.w	r1, r1, #16
 800485c:	6019      	str	r1, [r3, #0]
	CAN_IER(CAN1) |= 0x1;	// Bit0: 1: Interrupt generated when RQCPx bit is set. p 656.
 800485e:	6819      	ldr	r1, [r3, #0]
 8004860:	f041 0101 	orr.w	r1, r1, #1
 8004864:	6019      	str	r1, [r3, #0]

	/* Wait until ready */
	while ( (CAN_TSR(CAN1) & CAN_TSR_TME0) == 0);         // Wait for transmit mailbox 0 to be empty
 8004866:	4b1e      	ldr	r3, [pc, #120]	; (80048e0 <can_init_pod_ldr+0x280>)
 8004868:	681b      	ldr	r3, [r3, #0]
 800486a:	f013 6f80 	tst.w	r3, #67108864	; 0x4000000
 800486e:	d0fa      	beq.n	8004866 <can_init_pod_ldr+0x206>

	return (CAN_TIMEOUT - can_timeout);	// Return wait loop count
 8004870:	480c      	ldr	r0, [pc, #48]	; (80048a4 <can_init_pod_ldr+0x244>)
 8004872:	1a80      	subs	r0, r0, r2
 8004874:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		/* Setup CAN RXD: PD00 for input pull up */
	f4gpiopins_Config ((volatile u32*)GPIOD,  0, (struct PINCONFIG*)&inputpup);

		break;
	default:
		return -2;
 8004876:	f06f 0001 	mvn.w	r0, #1
 800487a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* The initialization request (above) causes the INAK bit to be set.  This bit goes off when 11 consecutive
	   recessive bits have been received p 633 */
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
	while ( ((CAN_MSR(CAN1) & CAN_MSR_INAK) == 0 ) && (can_timeout-- >= 0) );	// Wait until initialization mode starts or times out
	if (can_timeout <= 0 ) return 0;	// Timed out
 800487c:	2000      	movs	r0, #0
 800487e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* Leave initialization mode */
	CAN_MCR(CAN1) &= ~CAN_MCR_INRQ;
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
	while ( ((CAN_MSR(CAN1) & CAN_MSR_INAK) != 0 ) && (can_timeout-- >= 0) );	// Wait until initialization mode starts or times out
	if (can_timeout <= 0 ) return -1;	// Timed out
 8004880:	f04f 30ff 	mov.w	r0, #4294967295

	/* Wait until ready */
	while ( (CAN_TSR(CAN1) & CAN_TSR_TME0) == 0);         // Wait for transmit mailbox 0 to be empty

	return (CAN_TIMEOUT - can_timeout);	// Return wait loop count
}
 8004884:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004886:	bf00      	nop
 8004888:	40023840 	.word	0x40023840
 800488c:	40020000 	.word	0x40020000
 8004890:	0800ced4 	.word	0x0800ced4
 8004894:	40020400 	.word	0x40020400
 8004898:	40020c00 	.word	0x40020c00
 800489c:	40006400 	.word	0x40006400
 80048a0:	0800ced9 	.word	0x0800ced9
 80048a4:	005b8d80 	.word	0x005b8d80
 80048a8:	40006404 	.word	0x40006404
 80048ac:	4000641c 	.word	0x4000641c
 80048b0:	200016c4 	.word	0x200016c4
 80048b4:	01230000 	.word	0x01230000
 80048b8:	e000edfc 	.word	0xe000edfc
 80048bc:	e000e420 	.word	0xe000e420
 80048c0:	e000e104 	.word	0xe000e104
 80048c4:	e000e100 	.word	0xe000e100
 80048c8:	e0001000 	.word	0xe0001000
 80048cc:	e000e41c 	.word	0xe000e41c
 80048d0:	e000e410 	.word	0xe000e410
 80048d4:	e000e414 	.word	0xe000e414
 80048d8:	00703070 	.word	0x00703070
 80048dc:	40006414 	.word	0x40006414
 80048e0:	40006408 	.word	0x40006408

080048e4 <can_nxp_setRS_ldr>:
	GPIO_OSPEED_100MHZ, 	// speed: fastest 
	GPIO_PUPD_NONE, 	// pull up/down: none
	0 };			// AFRLy & AFRHy selection: not applicable

void can_nxp_setRS_ldr(int rs, volatile u32 * p, u16 pinnumber )
{
 80048e4:	b570      	push	{r4, r5, r6, lr}
 80048e6:	4606      	mov	r6, r0
 80048e8:	460c      	mov	r4, r1
	// Floating input = resistor controls slope
	// Pin HI = standby;
	// Pin LO = high speed;

	/* Setup the i/o pin as output push-pull */
	f4gpiopins_Config ( p, pinnumber, (struct PINCONFIG*)&outputpp);
 80048ea:	4608      	mov	r0, r1
	GPIO_OSPEED_100MHZ, 	// speed: fastest 
	GPIO_PUPD_NONE, 	// pull up/down: none
	0 };			// AFRLy & AFRHy selection: not applicable

void can_nxp_setRS_ldr(int rs, volatile u32 * p, u16 pinnumber )
{
 80048ec:	4615      	mov	r5, r2
	// Floating input = resistor controls slope
	// Pin HI = standby;
	// Pin LO = high speed;

	/* Setup the i/o pin as output push-pull */
	f4gpiopins_Config ( p, pinnumber, (struct PINCONFIG*)&outputpp);
 80048ee:	4611      	mov	r1, r2
 80048f0:	4a06      	ldr	r2, [pc, #24]	; (800490c <can_nxp_setRS_ldr+0x28>)
 80048f2:	f7ff fe42 	bl	800457a <f4gpiopins_Config>
 80048f6:	2301      	movs	r3, #1


	if (rs == 0)
 80048f8:	b91e      	cbnz	r6, 8004902 <can_nxp_setRS_ldr+0x1e>
		GPIO_BSRR(p) = (1<<(pinnumber+16));	// Set bit LO for SILENT mode
 80048fa:	3510      	adds	r5, #16
 80048fc:	40ab      	lsls	r3, r5
 80048fe:	6623      	str	r3, [r4, #96]	; 0x60
 8004900:	bd70      	pop	{r4, r5, r6, pc}
	else
		GPIO_BSRR(p) = (1<<pinnumber);	// Set bit HI for NORMAL mode
 8004902:	fa13 f505 	lsls.w	r5, r3, r5
 8004906:	6625      	str	r5, [r4, #96]	; 0x60
 8004908:	bd70      	pop	{r4, r5, r6, pc}
 800490a:	bf00      	nop
 800490c:	0800cede 	.word	0x0800cede

08004910 <can_filter_unitid_ldr>:
 * @return	: Nothing for now.
*******************************************************************************/
static u32 myunitid_local;
void can_filter_unitid_ldr(u32 myunitid)
{
	myunitid_local = myunitid;	// Save unit id number locally (for RESET msg checking)
 8004910:	4a14      	ldr	r2, [pc, #80]	; (8004964 <can_filter_unitid_ldr+0x54>)
      the CAN_FA1R register).
      If a filter bank is not used, it is recommended to leave it non active (leave the corresponding
      FACT bit cleared).
*/
	/* CAN filter master register p 665 */
	CAN_FMR(CAN1)  |= CAN_FMR_FINIT;	// FINIT = 1; Initialization mode ON for setting up filter banks
 8004912:	4b15      	ldr	r3, [pc, #84]	; (8004968 <can_filter_unitid_ldr+0x58>)
 * @param	: "my" can id
 * @return	: Nothing for now.
*******************************************************************************/
static u32 myunitid_local;
void can_filter_unitid_ldr(u32 myunitid)
{
 8004914:	b510      	push	{r4, lr}
	myunitid_local = myunitid;	// Save unit id number locally (for RESET msg checking)
 8004916:	6010      	str	r0, [r2, #0]
      the CAN_FA1R register).
      If a filter bank is not used, it is recommended to leave it non active (leave the corresponding
      FACT bit cleared).
*/
	/* CAN filter master register p 665 */
	CAN_FMR(CAN1)  |= CAN_FMR_FINIT;	// FINIT = 1; Initialization mode ON for setting up filter banks
 8004918:	6819      	ldr	r1, [r3, #0]
 800491a:	f041 0101 	orr.w	r1, r1, #1
 800491e:	6019      	str	r1, [r3, #0]
	   or when the FINIT bit of the CAN_FMR register is set. */

	/*   Set 16 bit filter mask and ID p 640 fig 229 */
	// Note: '>>16' is because for 16b scale mode the unit id goes in the low order word.
	// (CANx, <bank>) =  <[15:8] mask>      <[7:0] id>
	CAN_FiR1(CAN1, 0) = CAN_UNITID_MASK | (CAN_RESETALL  >> 16);	// All units accept this msg
 8004920:	4912      	ldr	r1, [pc, #72]	; (800496c <can_filter_unitid_ldr+0x5c>)
 8004922:	f04f 74f0 	mov.w	r4, #31457280	; 0x1e00000
 8004926:	600c      	str	r4, [r1, #0]
	CAN_FiR2(CAN1, 0) = CAN_UNITID_MASK | (CAN_TIMESYNC1 >> 16);	// All units accept this msg
 8004928:	3420      	adds	r4, #32
 800492a:	604c      	str	r4, [r1, #4]
	CAN_FiR1(CAN1, 1) = CAN_UNITID_MASK | (CAN_TIMESYNC2 >> 16);	// All units accept this msg
	CAN_FiR2(CAN1, 1) = CAN_UNITID_MASK | (CAN_TIMESYNC3 >> 16);	// All units accept this msg
	CAN_FiR1(CAN1, 2) = CAN_UNITID_MASK | (myunitid      >> 16);	// 'IAMUNITNUMBER' is unique to this unit
 800492c:	0c00      	lsrs	r0, r0, #16
	/*   Set 16 bit filter mask and ID p 640 fig 229 */
	// Note: '>>16' is because for 16b scale mode the unit id goes in the low order word.
	// (CANx, <bank>) =  <[15:8] mask>      <[7:0] id>
	CAN_FiR1(CAN1, 0) = CAN_UNITID_MASK | (CAN_RESETALL  >> 16);	// All units accept this msg
	CAN_FiR2(CAN1, 0) = CAN_UNITID_MASK | (CAN_TIMESYNC1 >> 16);	// All units accept this msg
	CAN_FiR1(CAN1, 1) = CAN_UNITID_MASK | (CAN_TIMESYNC2 >> 16);	// All units accept this msg
 800492e:	3420      	adds	r4, #32
 8004930:	608c      	str	r4, [r1, #8]
	CAN_FiR2(CAN1, 1) = CAN_UNITID_MASK | (CAN_TIMESYNC3 >> 16);	// All units accept this msg
	CAN_FiR1(CAN1, 2) = CAN_UNITID_MASK | (myunitid      >> 16);	// 'IAMUNITNUMBER' is unique to this unit
 8004932:	f040 70f0 	orr.w	r0, r0, #31457280	; 0x1e00000
	// Note: '>>16' is because for 16b scale mode the unit id goes in the low order word.
	// (CANx, <bank>) =  <[15:8] mask>      <[7:0] id>
	CAN_FiR1(CAN1, 0) = CAN_UNITID_MASK | (CAN_RESETALL  >> 16);	// All units accept this msg
	CAN_FiR2(CAN1, 0) = CAN_UNITID_MASK | (CAN_TIMESYNC1 >> 16);	// All units accept this msg
	CAN_FiR1(CAN1, 1) = CAN_UNITID_MASK | (CAN_TIMESYNC2 >> 16);	// All units accept this msg
	CAN_FiR2(CAN1, 1) = CAN_UNITID_MASK | (CAN_TIMESYNC3 >> 16);	// All units accept this msg
 8004936:	3420      	adds	r4, #32
 8004938:	60cc      	str	r4, [r1, #12]
	CAN_FiR1(CAN1, 2) = CAN_UNITID_MASK | (myunitid      >> 16);	// 'IAMUNITNUMBER' is unique to this unit
 800493a:	6108      	str	r0, [r1, #16]
	CAN_FiR2(CAN1, 2) = CAN_NEVERUSEID;			// Set leftover odd 16b mask|id 
 800493c:	f04f 30ff 	mov.w	r0, #4294967295
 8004940:	6148      	str	r0, [r1, #20]
	can_filt16num = 5;	// Show that filter bank 2, FiR2 is available
 8004942:	2105      	movs	r1, #5
 8004944:	8091      	strh	r1, [r2, #4]
2) Both (32b) registers of the pair must be setup, otherwise the register that is not set will be used in the filtering,
   and this can cause strange results since the mask|id might pass unwanted msgs.
3) Setting a register to zero passes *all* messages, (since the mask is 100% don't cares).
*/
	/* Assign filter to FIFO 1. Default: All messages pass through FIFO p 667 */
	CAN_FFA1R(CAN1) |= 0x3;	// Filter banks 0 and 1 pass through FIFO 1
 8004946:	4a0a      	ldr	r2, [pc, #40]	; (8004970 <can_filter_unitid_ldr+0x60>)
 8004948:	6811      	ldr	r1, [r2, #0]
 800494a:	f041 0103 	orr.w	r1, r1, #3
 800494e:	6011      	str	r1, [r2, #0]
	/* Bits 27:0 FACTx: Filter active
            The software sets this bit to activate Filter x. To modify the Filter x registers (CAN_FxR[0:7]),
            the FACTx bit must be cleared or the FINIT bit of the CAN_FMR register must be set.
            0: Filter x is not active
            1: Filter x is active */
	CAN_FA1R(CAN1) |= 0x7;	// Activate filter banks 0, 1, 2. p 667
 8004950:	6891      	ldr	r1, [r2, #8]
 8004952:	f041 0107 	orr.w	r1, r1, #7
 8004956:	6091      	str	r1, [r2, #8]

	/* Remove filter registers from initialization mode */
	CAN_FMR(CAN1)  &= ~CAN_FMR_FINIT;	// FINIT = 0; Set initialization mode off for filter banks p 665
 8004958:	681a      	ldr	r2, [r3, #0]
 800495a:	f022 0201 	bic.w	r2, r2, #1
 800495e:	601a      	str	r2, [r3, #0]

	return;
}
 8004960:	bd10      	pop	{r4, pc}
 8004962:	bf00      	nop
 8004964:	20000fc8 	.word	0x20000fc8
 8004968:	40006600 	.word	0x40006600
 800496c:	40006640 	.word	0x40006640
 8004970:	40006614 	.word	0x40006614

08004974 <can_filtermask16_add_ldr>:
 NOTE: These mask|ID's assign to the FIFO 0 (default)
*******************************************************************************/
u16 can_filtermask16_add_ldr(u32 m)
{
	/* F103 has 14 banks that can hold two 16 bit mask|ID's */
	if (can_filt16num >= (14 * 2)) return -1;
 8004974:	4a17      	ldr	r2, [pc, #92]	; (80049d4 <can_filtermask16_add_ldr+0x60>)
 8004976:	8893      	ldrh	r3, [r2, #4]
 8004978:	2b1b      	cmp	r3, #27
 * @param	: mask and ID: e.g. (CAN_UNITID_MASK | (CAN_TIMESYNC3 >> 16)
 * @return	: Filter number; negative for you have filled it up!
 NOTE: These mask|ID's assign to the FIFO 0 (default)
*******************************************************************************/
u16 can_filtermask16_add_ldr(u32 m)
{
 800497a:	b510      	push	{r4, lr}
	/* F103 has 14 banks that can hold two 16 bit mask|ID's */
	if (can_filt16num >= (14 * 2)) return -1;
 800497c:	d827      	bhi.n	80049ce <can_filtermask16_add_ldr+0x5a>

	/* CAN filter master register p 665 */
	CAN_FMR(CAN1)  |= CAN_FMR_FINIT;	// FINIT = 1; Initialization mode ON for setting up filter banks
 800497e:	4916      	ldr	r1, [pc, #88]	; (80049d8 <can_filtermask16_add_ldr+0x64>)
 8004980:	680c      	ldr	r4, [r1, #0]

	if ((can_filt16num & 0x1) != 0)	// Does the last filter bank assigned have an used slot?
 8004982:	f013 0f01 	tst.w	r3, #1
{
	/* F103 has 14 banks that can hold two 16 bit mask|ID's */
	if (can_filt16num >= (14 * 2)) return -1;

	/* CAN filter master register p 665 */
	CAN_FMR(CAN1)  |= CAN_FMR_FINIT;	// FINIT = 1; Initialization mode ON for setting up filter banks
 8004986:	f044 0401 	orr.w	r4, r4, #1
 800498a:	600c      	str	r4, [r1, #0]
 800498c:	ea4f 0453 	mov.w	r4, r3, lsr #1

	if ((can_filt16num & 0x1) != 0)	// Does the last filter bank assigned have an used slot?
 8004990:	d004      	beq.n	800499c <can_filtermask16_add_ldr+0x28>
	{ // Here, odd, therefore we can add this to the currently assigned filter bank
		CAN_FiR2(CAN1,(can_filt16num >> 1)) = m;	// Fill the 2nd slot
 8004992:	4b12      	ldr	r3, [pc, #72]	; (80049dc <can_filtermask16_add_ldr+0x68>)
 8004994:	18e3      	adds	r3, r4, r3
 8004996:	00db      	lsls	r3, r3, #3
 8004998:	6058      	str	r0, [r3, #4]
 800499a:	e00e      	b.n	80049ba <can_filtermask16_add_ldr+0x46>
	}
	else
	{ /* Here, the count is even, so a new filter bank must be used */
		CAN_FiR1(CAN1,(can_filt16num >> 1)) = m;	// Fill the 1st slot
 800499c:	4b0f      	ldr	r3, [pc, #60]	; (80049dc <can_filtermask16_add_ldr+0x68>)
 800499e:	b2a4      	uxth	r4, r4
 80049a0:	18e3      	adds	r3, r4, r3
 80049a2:	00db      	lsls	r3, r3, #3
		CAN_FiR2(CAN1,(can_filt16num >> 1)) = CAN_NEVERUSEID;	// Initialize the odd, 2nd 16b mask|id 
 80049a4:	f04f 31ff 	mov.w	r1, #4294967295
	{ // Here, odd, therefore we can add this to the currently assigned filter bank
		CAN_FiR2(CAN1,(can_filt16num >> 1)) = m;	// Fill the 2nd slot
	}
	else
	{ /* Here, the count is even, so a new filter bank must be used */
		CAN_FiR1(CAN1,(can_filt16num >> 1)) = m;	// Fill the 1st slot
 80049a8:	6018      	str	r0, [r3, #0]
		CAN_FiR2(CAN1,(can_filt16num >> 1)) = CAN_NEVERUSEID;	// Initialize the odd, 2nd 16b mask|id 
 80049aa:	6059      	str	r1, [r3, #4]

		/* Activate the newly assigned filter bank */
		CAN_FA1R(CAN1) |= (1 << (can_filt16num >> 1));
 80049ac:	490c      	ldr	r1, [pc, #48]	; (80049e0 <can_filtermask16_add_ldr+0x6c>)
 80049ae:	2301      	movs	r3, #1
 80049b0:	6808      	ldr	r0, [r1, #0]
 80049b2:	fa13 f404 	lsls.w	r4, r3, r4
 80049b6:	4304      	orrs	r4, r0
 80049b8:	600c      	str	r4, [r1, #0]
	}

	/* Update the count of mask|ID's we have set up */
	can_filt16num += 1;	// Show another was added
 80049ba:	8893      	ldrh	r3, [r2, #4]
 80049bc:	3301      	adds	r3, #1
 80049be:	8093      	strh	r3, [r2, #4]

	/* Remove filter registers from initialization mode */
	CAN_FMR(CAN1)  &= ~CAN_FMR_FINIT;	// FINIT = 0; Set initialization mode off for filter banks p 665
 80049c0:	4b05      	ldr	r3, [pc, #20]	; (80049d8 <can_filtermask16_add_ldr+0x64>)
 80049c2:	681a      	ldr	r2, [r3, #0]
 80049c4:	f022 0201 	bic.w	r2, r2, #1
 80049c8:	601a      	str	r2, [r3, #0]
	
	return 0;
 80049ca:	2000      	movs	r0, #0
 80049cc:	bd10      	pop	{r4, pc}
 NOTE: These mask|ID's assign to the FIFO 0 (default)
*******************************************************************************/
u16 can_filtermask16_add_ldr(u32 m)
{
	/* F103 has 14 banks that can hold two 16 bit mask|ID's */
	if (can_filt16num >= (14 * 2)) return -1;
 80049ce:	f64f 70ff 	movw	r0, #65535	; 0xffff

	/* Remove filter registers from initialization mode */
	CAN_FMR(CAN1)  &= ~CAN_FMR_FINIT;	// FINIT = 0; Set initialization mode off for filter banks p 665
	
	return 0;
}
 80049d2:	bd10      	pop	{r4, pc}
 80049d4:	20000fc8 	.word	0x20000fc8
 80049d8:	40006600 	.word	0x40006600
 80049dc:	08000cc8 	.word	0x08000cc8
 80049e0:	4000661c 	.word	0x4000661c

080049e4 <canrcv_get_ldr>:
 * @return	: struct with pointer to buffer, ptr = zero if no new data
 ******************************************************************************/
struct CANRCVBUF* canrcv_get_ldr(void)
{
	struct CANRCVBUF *p;
	if (canbufIDXi == canbufIDXm) return 0;	// Return showing no new data
 80049e4:	4b08      	ldr	r3, [pc, #32]	; (8004a08 <canrcv_get_ldr+0x24>)
 80049e6:	689a      	ldr	r2, [r3, #8]
 80049e8:	68d9      	ldr	r1, [r3, #12]
 80049ea:	4291      	cmp	r1, r2
 80049ec:	d009      	beq.n	8004a02 <canrcv_get_ldr+0x1e>

	p = &canbuf[canbufIDXm];	// Get return pointer value

	canbufIDXm += 1; if (canbufIDXm >= CANRCVBUFSIZE) canbufIDXm = 0; // Wrap around end	
 80049ee:	1c51      	adds	r1, r2, #1
 80049f0:	293f      	cmp	r1, #63	; 0x3f
 80049f2:	6099      	str	r1, [r3, #8]
 80049f4:	dd01      	ble.n	80049fa <canrcv_get_ldr+0x16>
 80049f6:	2100      	movs	r1, #0
 80049f8:	6099      	str	r1, [r3, #8]
	return p;			// Return pointer to buffer
 80049fa:	4804      	ldr	r0, [pc, #16]	; (8004a0c <canrcv_get_ldr+0x28>)
 80049fc:	eb00 1002 	add.w	r0, r0, r2, lsl #4
 8004a00:	4770      	bx	lr
 * @return	: struct with pointer to buffer, ptr = zero if no new data
 ******************************************************************************/
struct CANRCVBUF* canrcv_get_ldr(void)
{
	struct CANRCVBUF *p;
	if (canbufIDXi == canbufIDXm) return 0;	// Return showing no new data
 8004a02:	2000      	movs	r0, #0

	p = &canbuf[canbufIDXm];	// Get return pointer value

	canbufIDXm += 1; if (canbufIDXm >= CANRCVBUFSIZE) canbufIDXm = 0; // Wrap around end	
	return p;			// Return pointer to buffer
}
 8004a04:	4770      	bx	lr
 8004a06:	bf00      	nop
 8004a08:	20000fc8 	.word	0x20000fc8
 8004a0c:	20000fd8 	.word	0x20000fd8

08004a10 <canrcvtim_get_ldr>:
 * @return	: struct with pointer to buffer, ptr = zero if no new data
 ******************************************************************************/
struct CANRCVTIMBUF* canrcvtim_get_ldr(void)
{
	struct CANRCVTIMBUF *p;
	if (canbuftimIDXi == canbuftimIDXm) return 0;	// Return showing no new data
 8004a10:	4b0a      	ldr	r3, [pc, #40]	; (8004a3c <canrcvtim_get_ldr+0x2c>)
 8004a12:	f8d3 2410 	ldr.w	r2, [r3, #1040]	; 0x410
 8004a16:	f8d3 1414 	ldr.w	r1, [r3, #1044]	; 0x414
 8004a1a:	4291      	cmp	r1, r2
 8004a1c:	d00c      	beq.n	8004a38 <canrcvtim_get_ldr+0x28>

	p = &cantimbuf[canbuftimIDXm];	// Get return pointer value	

	/* Advance index ('m' = mainline) */
	canbuftimIDXm += 1; if (canbuftimIDXm >= CANRCVTIMBUFSIZE) canbuftimIDXm = 0;// Reset to beginning
 8004a1e:	1c51      	adds	r1, r2, #1
 8004a20:	290f      	cmp	r1, #15
 8004a22:	f8c3 1410 	str.w	r1, [r3, #1040]	; 0x410
 8004a26:	dd02      	ble.n	8004a2e <canrcvtim_get_ldr+0x1e>
 8004a28:	2100      	movs	r1, #0
 8004a2a:	f8c3 1410 	str.w	r1, [r3, #1040]	; 0x410
	return p;			// Return pointer to buffer
 8004a2e:	4b04      	ldr	r3, [pc, #16]	; (8004a40 <canrcvtim_get_ldr+0x30>)
 8004a30:	2018      	movs	r0, #24
 8004a32:	fb00 3002 	mla	r0, r0, r2, r3
 8004a36:	4770      	bx	lr
 * @return	: struct with pointer to buffer, ptr = zero if no new data
 ******************************************************************************/
struct CANRCVTIMBUF* canrcvtim_get_ldr(void)
{
	struct CANRCVTIMBUF *p;
	if (canbuftimIDXi == canbuftimIDXm) return 0;	// Return showing no new data
 8004a38:	2000      	movs	r0, #0
	p = &cantimbuf[canbuftimIDXm];	// Get return pointer value	

	/* Advance index ('m' = mainline) */
	canbuftimIDXm += 1; if (canbuftimIDXm >= CANRCVTIMBUFSIZE) canbuftimIDXm = 0;// Reset to beginning
	return p;			// Return pointer to buffer
}
 8004a3a:	4770      	bx	lr
 8004a3c:	20000fc8 	.word	0x20000fc8
 8004a40:	200013e0 	.word	0x200013e0

08004a44 <can_msg_txchkbuff_ldr>:
 ******************************************************************************/
int can_msg_txchkbuff_ldr(void)
{
	int temp;
	/* Compute remaining msgs in buffer */
	temp = (canxmtIDXi - canxmtIDXm);
 8004a44:	4b04      	ldr	r3, [pc, #16]	; (8004a58 <can_msg_txchkbuff_ldr+0x14>)
 8004a46:	f8d3 0598 	ldr.w	r0, [r3, #1432]	; 0x598
 8004a4a:	f8d3 359c 	ldr.w	r3, [r3, #1436]	; 0x59c
	if (temp < 0) temp += CANXMTBUFSIZE;
 8004a4e:	1ac0      	subs	r0, r0, r3
 8004a50:	bf48      	it	mi
 8004a52:	3010      	addmi	r0, #16
	
	return	temp-1; // Return number msg remaining buffered
}
 8004a54:	3801      	subs	r0, #1
 8004a56:	4770      	bx	lr
 8004a58:	20000fc8 	.word	0x20000fc8

08004a5c <can_msg_put_ldr>:
 * @param	: pointer to struct with msg: id, dlc, data
 * @return	: number msg remaining buffered
 * ==> NOTE: dlc is expected to be set when this routine is entered.
 ******************************************************************************/
int can_msg_put_ldr(struct CANRCVBUF *px)
{
 8004a5c:	b570      	push	{r4, r5, r6, lr}
	/* Copy msg into buffer */
	canxmtbuf[canxmtIDXm] = *px;	// Add msg to buffer
 8004a5e:	4c15      	ldr	r4, [pc, #84]	; (8004ab4 <can_msg_put_ldr+0x58>)
 8004a60:	c80f      	ldmia	r0, {r0, r1, r2, r3}
 8004a62:	f8d4 659c 	ldr.w	r6, [r4, #1436]	; 0x59c
 8004a66:	eb04 1506 	add.w	r5, r4, r6, lsl #4

	/* Advance buffer index */
	canxmtIDXm += 1; if (canxmtIDXm >= CANXMTBUFSIZE)    canxmtIDXm = 0;
 8004a6a:	3601      	adds	r6, #1
 * ==> NOTE: dlc is expected to be set when this routine is entered.
 ******************************************************************************/
int can_msg_put_ldr(struct CANRCVBUF *px)
{
	/* Copy msg into buffer */
	canxmtbuf[canxmtIDXm] = *px;	// Add msg to buffer
 8004a6c:	f505 65b4 	add.w	r5, r5, #1440	; 0x5a0

	/* Advance buffer index */
	canxmtIDXm += 1; if (canxmtIDXm >= CANXMTBUFSIZE)    canxmtIDXm = 0;
 8004a70:	2e0f      	cmp	r6, #15
 * ==> NOTE: dlc is expected to be set when this routine is entered.
 ******************************************************************************/
int can_msg_put_ldr(struct CANRCVBUF *px)
{
	/* Copy msg into buffer */
	canxmtbuf[canxmtIDXm] = *px;	// Add msg to buffer
 8004a72:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}

	/* Advance buffer index */
	canxmtIDXm += 1; if (canxmtIDXm >= CANXMTBUFSIZE)    canxmtIDXm = 0;
 8004a76:	f8c4 659c 	str.w	r6, [r4, #1436]	; 0x59c
 8004a7a:	dd02      	ble.n	8004a82 <can_msg_put_ldr+0x26>
 8004a7c:	2300      	movs	r3, #0
 8004a7e:	f8c4 359c 	str.w	r3, [r4, #1436]	; 0x59c

can_debugP += 1;	// Msgs added to buffer
 8004a82:	f8d4 36a0 	ldr.w	r3, [r4, #1696]	; 0x6a0
 8004a86:	4a0b      	ldr	r2, [pc, #44]	; (8004ab4 <can_msg_put_ldr+0x58>)
 8004a88:	3301      	adds	r3, #1
 8004a8a:	f8c4 36a0 	str.w	r3, [r4, #1696]	; 0x6a0

	/* Load mailbox if it is empty and the interrupt request bit has been turned off p 655 */
	// Mailbox needs to be loaded if TME0 and RQCP0 bits are mailbox empty and interrupt request serviced 
	if ( (CAN_TSR(CAN1) & (CAN_TSR_TME0 | CAN_TSR_RQCP0)) == CAN_TSR_TME0)  
 8004a8e:	4b0a      	ldr	r3, [pc, #40]	; (8004ab8 <can_msg_put_ldr+0x5c>)
 8004a90:	6819      	ldr	r1, [r3, #0]
 8004a92:	4b0a      	ldr	r3, [pc, #40]	; (8004abc <can_msg_put_ldr+0x60>)
 8004a94:	ea01 0303 	and.w	r3, r1, r3
 8004a98:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8004a9c:	d107      	bne.n	8004aae <can_msg_put_ldr+0x52>
	{ // Here yes.  Mailbox is empty.  Load mailbox, set TXRQ	
		loadmbx(&canxmtbuf[canxmtIDXi]);
 8004a9e:	f8d2 0598 	ldr.w	r0, [r2, #1432]	; 0x598
 8004aa2:	f502 63b4 	add.w	r3, r2, #1440	; 0x5a0
 8004aa6:	eb03 1000 	add.w	r0, r3, r0, lsl #4
 8004aaa:	f7ff fdc5 	bl	8004638 <loadmbx>
	}
	
	return	can_msg_txchkbuff_ldr(); // Return number msg remaining buffered
}
 8004aae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	if ( (CAN_TSR(CAN1) & (CAN_TSR_TME0 | CAN_TSR_RQCP0)) == CAN_TSR_TME0)  
	{ // Here yes.  Mailbox is empty.  Load mailbox, set TXRQ	
		loadmbx(&canxmtbuf[canxmtIDXi]);
	}
	
	return	can_msg_txchkbuff_ldr(); // Return number msg remaining buffered
 8004ab2:	e7c7      	b.n	8004a44 <can_msg_txchkbuff_ldr>
 8004ab4:	20000fc8 	.word	0x20000fc8
 8004ab8:	40006408 	.word	0x40006408
 8004abc:	04000001 	.word	0x04000001

08004ac0 <can_msg_rcv_expand_ldr>:
 * @return	: nothing
 ******************************************************************************/
void can_msg_rcv_expand_ldr(struct CANRCVBUF *px)
{
	int i;
	int temp = (px->dlc & 0xf);	// Get byte count in received msg
 8004ac0:	6842      	ldr	r2, [r0, #4]
 8004ac2:	f002 020f 	and.w	r2, r2, #15
	if (temp > 8) temp = 8;		// JIC the number exceeds the array
 8004ac6:	2a08      	cmp	r2, #8
 * @brief	: Fill bytes not received with zeros
 * @param	: pointer to struct with msg: id, dlc & data
 * @return	: nothing
 ******************************************************************************/
void can_msg_rcv_expand_ldr(struct CANRCVBUF *px)
{
 8004ac8:	b510      	push	{r4, lr}
	int i;
	int temp = (px->dlc & 0xf);	// Get byte count in received msg
	if (temp > 8) temp = 8;		// JIC the number exceeds the array
 8004aca:	dc01      	bgt.n	8004ad0 <can_msg_rcv_expand_ldr+0x10>
	if (temp <= 0) { px->cd.ull = 0; return; }
 8004acc:	b90a      	cbnz	r2, 8004ad2 <can_msg_rcv_expand_ldr+0x12>
 8004ace:	e002      	b.n	8004ad6 <can_msg_rcv_expand_ldr+0x16>
 ******************************************************************************/
void can_msg_rcv_expand_ldr(struct CANRCVBUF *px)
{
	int i;
	int temp = (px->dlc & 0xf);	// Get byte count in received msg
	if (temp > 8) temp = 8;		// JIC the number exceeds the array
 8004ad0:	2208      	movs	r2, #8
 8004ad2:	2307      	movs	r3, #7
 8004ad4:	e008      	b.n	8004ae8 <can_msg_rcv_expand_ldr+0x28>
	if (temp <= 0) { px->cd.ull = 0; return; }
 8004ad6:	2200      	movs	r2, #0
 8004ad8:	2300      	movs	r3, #0
 8004ada:	e9c0 2302 	strd	r2, r3, [r0, #8]
 8004ade:	bd10      	pop	{r4, pc}
 * void can_msg_rcv_expand_ldr(struct CANRCVBUF *px);
 * @brief	: Fill bytes not received with zeros
 * @param	: pointer to struct with msg: id, dlc & data
 * @return	: nothing
 ******************************************************************************/
void can_msg_rcv_expand_ldr(struct CANRCVBUF *px)
 8004ae0:	18c1      	adds	r1, r0, r3
	if (temp > 8) temp = 8;		// JIC the number exceeds the array
	if (temp <= 0) { px->cd.ull = 0; return; }
	
	/* Clear bytes not received. */
	for (i = 7; i >= temp; i--)	// Work from hi-ord byte down
		px->cd.uc[i] = 0;	// Set unsent byte to zero
 8004ae2:	2400      	movs	r4, #0
 8004ae4:	720c      	strb	r4, [r1, #8]
	int temp = (px->dlc & 0xf);	// Get byte count in received msg
	if (temp > 8) temp = 8;		// JIC the number exceeds the array
	if (temp <= 0) { px->cd.ull = 0; return; }
	
	/* Clear bytes not received. */
	for (i = 7; i >= temp; i--)	// Work from hi-ord byte down
 8004ae6:	3b01      	subs	r3, #1
 8004ae8:	4293      	cmp	r3, r2
 8004aea:	daf9      	bge.n	8004ae0 <can_msg_rcv_expand_ldr+0x20>
 8004aec:	bd10      	pop	{r4, pc}

08004aee <can_msg_setsize_ldr>:
 * @param	: pointer to struct with msg: id, dlc & data
 * @return	: nothing
 ******************************************************************************/
void can_msg_setsize_ldr(struct CANRCVBUF *px, int count)
{
	px->dlc &= ~0xf;	// Clear dlc field
 8004aee:	6843      	ldr	r3, [r0, #4]
	px->dlc |= count & 0xf;	// Add new count
 8004af0:	f001 010f 	and.w	r1, r1, #15
 * @param	: pointer to struct with msg: id, dlc & data
 * @return	: nothing
 ******************************************************************************/
void can_msg_setsize_ldr(struct CANRCVBUF *px, int count)
{
	px->dlc &= ~0xf;	// Clear dlc field
 8004af4:	f023 030f 	bic.w	r3, r3, #15
	px->dlc |= count & 0xf;	// Add new count
 8004af8:	4319      	orrs	r1, r3
 8004afa:	6041      	str	r1, [r0, #4]
	return;
}
 8004afc:	4770      	bx	lr

08004afe <canmsg_send_ldr>:
 * @param	: data1 = 1st 4 bytes of payload
 * @param	: data2 = 2nd 4 bytes of payload
 * @brief 	: send CAN msg
 *####################################################################################### */
void canmsg_send_ldr(struct CANRCVBUF * p, int data1, int data2)
{
 8004afe:	b510      	push	{r4, lr}
	p->cd.ui[0] = data1;
 8004b00:	6081      	str	r1, [r0, #8]
	p->cd.ui[1] = data2;
 8004b02:	60c2      	str	r2, [r0, #12]

//	can_msg_rcv_compress(p);	// Set byte count: according to MSB
	can_msg_setsize_ldr(p, 8);	// Set byte count: Fixed xmt
 8004b04:	2108      	movs	r1, #8
 * @param	: data1 = 1st 4 bytes of payload
 * @param	: data2 = 2nd 4 bytes of payload
 * @brief 	: send CAN msg
 *####################################################################################### */
void canmsg_send_ldr(struct CANRCVBUF * p, int data1, int data2)
{
 8004b06:	4604      	mov	r4, r0
	p->cd.ui[0] = data1;
	p->cd.ui[1] = data2;

//	can_msg_rcv_compress(p);	// Set byte count: according to MSB
	can_msg_setsize_ldr(p, 8);	// Set byte count: Fixed xmt
 8004b08:	f7ff fff1 	bl	8004aee <can_msg_setsize_ldr>

 	/* Setup CAN msg in output buffer/queue */
	if ( can_msg_put_ldr(p) <= 0)
 8004b0c:	4620      	mov	r0, r4
 8004b0e:	f7ff ffa5 	bl	8004a5c <can_msg_put_ldr>
 8004b12:	2800      	cmp	r0, #0
 8004b14:	dc05      	bgt.n	8004b22 <canmsg_send_ldr+0x24>
		can_msgovrflow += 1;
 8004b16:	4b03      	ldr	r3, [pc, #12]	; (8004b24 <canmsg_send_ldr+0x26>)
 8004b18:	f8d3 26a4 	ldr.w	r2, [r3, #1700]	; 0x6a4
 8004b1c:	3201      	adds	r2, #1
 8004b1e:	f8c3 26a4 	str.w	r2, [r3, #1700]	; 0x6a4
 8004b22:	bd10      	pop	{r4, pc}
 8004b24:	20000fc8 	.word	0x20000fc8

08004b28 <canmsg_send_ldr_n>:
 *####################################################################################### */
void canmsg_send_ldr_n(struct CANRCVBUF * p, u8* pin, s32 n)
{
	u8* pout = &p->cd.uc[0];	// Pointer into CAN msg payload field

	if (n > 8) n = 8;	if (n < 0) n = 0; // Make sure 'n' is bounded.
 8004b28:	2a08      	cmp	r2, #8
 * @param	: pc = pointer to bytes to send
 * @param	: n = number of bytes to send
 * @brief 	: send CAN msg that is less than 8 bytes
 *####################################################################################### */
void canmsg_send_ldr_n(struct CANRCVBUF * p, u8* pin, s32 n)
{
 8004b2a:	b510      	push	{r4, lr}
	u8* pout = &p->cd.uc[0];	// Pointer into CAN msg payload field

	if (n > 8) n = 8;	if (n < 0) n = 0; // Make sure 'n' is bounded.
 8004b2c:	bfd8      	it	le
 8004b2e:	ea22 72e2 	bicle.w	r2, r2, r2, asr #31
 * @param	: pc = pointer to bytes to send
 * @param	: n = number of bytes to send
 * @brief 	: send CAN msg that is less than 8 bytes
 *####################################################################################### */
void canmsg_send_ldr_n(struct CANRCVBUF * p, u8* pin, s32 n)
{
 8004b32:	4604      	mov	r4, r0
	u8* pout = &p->cd.uc[0];	// Pointer into CAN msg payload field
 8004b34:	f100 0308 	add.w	r3, r0, #8

	if (n > 8) n = 8;	if (n < 0) n = 0; // Make sure 'n' is bounded.
 8004b38:	bfc8      	it	gt
 8004b3a:	2208      	movgt	r2, #8
 8004b3c:	e004      	b.n	8004b48 <canmsg_send_ldr_n+0x20>
	while (n > 0) {*pout++ = *pin++; n -= 1;} // Copy data to payload
 8004b3e:	f811 0b01 	ldrb.w	r0, [r1], #1
 8004b42:	f803 0b01 	strb.w	r0, [r3], #1
 8004b46:	3a01      	subs	r2, #1
 8004b48:	2a00      	cmp	r2, #0
 8004b4a:	dcf8      	bgt.n	8004b3e <canmsg_send_ldr_n+0x16>

//	can_msg_rcv_compress(p);	// Set byte count: according to MSB
	can_msg_setsize_ldr(p, n);	// Set byte count: Fixed xmt
 8004b4c:	4620      	mov	r0, r4
 8004b4e:	4611      	mov	r1, r2
 8004b50:	f7ff ffcd 	bl	8004aee <can_msg_setsize_ldr>

 	/* Setup CAN msg in output buffer/queue */
	if ( can_msg_put_ldr(p) <= 0)
 8004b54:	4620      	mov	r0, r4
 8004b56:	f7ff ff81 	bl	8004a5c <can_msg_put_ldr>
 8004b5a:	2800      	cmp	r0, #0
 8004b5c:	dc05      	bgt.n	8004b6a <canmsg_send_ldr_n+0x42>
		can_msgovrflow += 1;
 8004b5e:	4b03      	ldr	r3, [pc, #12]	; (8004b6c <canmsg_send_ldr_n+0x44>)
 8004b60:	f8d3 26a4 	ldr.w	r2, [r3, #1700]	; 0x6a4
 8004b64:	3201      	adds	r2, #1
 8004b66:	f8c3 26a4 	str.w	r2, [r3, #1700]	; 0x6a4
 8004b6a:	bd10      	pop	{r4, pc}
 8004b6c:	20000fc8 	.word	0x20000fc8

08004b70 <CAN1_TX_IRQHandler>:
–   Transmit mailbox 1 becomes empty, RQCP1 bit in the CAN_TSR register set.
–   Transmit mailbox 2 becomes empty, RQCP2 bit in the CAN_TSR register set. */
u32 can_terr = 0; 	// Count of TERR flags

void CAN1_TX_IRQHandler(void)
{
 8004b70:	b508      	push	{r3, lr}
	int temp;
//while (1==1);
	CAN_TSR(CAN1) = (CAN_TSR_RQCP1 | CAN_TSR_RQCP2);	// JIC mbx 2 & 3 have a flag
 8004b72:	4a19      	ldr	r2, [pc, #100]	; (8004bd8 <CAN1_TX_IRQHandler+0x68>)
 8004b74:	4b19      	ldr	r3, [pc, #100]	; (8004bdc <CAN1_TX_IRQHandler+0x6c>)
 8004b76:	601a      	str	r2, [r3, #0]

	if ((CAN_TSR(CAN1) & CAN_TSR_RQCP0) != 0) // Is mailbox0 RQCP0 (request complete) ON?
 8004b78:	681a      	ldr	r2, [r3, #0]
 8004b7a:	f012 0f01 	tst.w	r2, #1
 8004b7e:	d027      	beq.n	8004bd0 <CAN1_TX_IRQHandler+0x60>
	{ // Here, yes.  
		/* Primitive error handling */
		if ((CAN_TSR(CAN1) & 0x8) != 0) can_terr += 1; // Count errors
 8004b80:	681b      	ldr	r3, [r3, #0]
 8004b82:	f013 0f08 	tst.w	r3, #8
 8004b86:	4b16      	ldr	r3, [pc, #88]	; (8004be0 <CAN1_TX_IRQHandler+0x70>)
 8004b88:	d004      	beq.n	8004b94 <CAN1_TX_IRQHandler+0x24>
 8004b8a:	f8d3 26a8 	ldr.w	r2, [r3, #1704]	; 0x6a8
 8004b8e:	3201      	adds	r2, #1
 8004b90:	f8c3 26a8 	str.w	r2, [r3, #1704]	; 0x6a8

		/* Clear RQCPx  */
		CAN_TSR(CAN1) = CAN_TSR_RQCP0;	// Clear RQPx (which clears TERRx, ALSTx, TXOKx)
 8004b94:	4a11      	ldr	r2, [pc, #68]	; (8004bdc <CAN1_TX_IRQHandler+0x6c>)
 8004b96:	2101      	movs	r1, #1
 8004b98:	6011      	str	r1, [r2, #0]
		
		/* Advance buffer index */
		canxmtIDXi += 1; if (canxmtIDXi >= CANXMTBUFSIZE)    canxmtIDXi = 0;
 8004b9a:	f8d3 2598 	ldr.w	r2, [r3, #1432]	; 0x598
 8004b9e:	1852      	adds	r2, r2, r1
 8004ba0:	2a0f      	cmp	r2, #15
 8004ba2:	f8c3 2598 	str.w	r2, [r3, #1432]	; 0x598
 8004ba6:	dd03      	ble.n	8004bb0 <CAN1_TX_IRQHandler+0x40>
 8004ba8:	4a0d      	ldr	r2, [pc, #52]	; (8004be0 <CAN1_TX_IRQHandler+0x70>)
 8004baa:	3901      	subs	r1, #1
 8004bac:	f8c2 1598 	str.w	r1, [r2, #1432]	; 0x598
can_debugM += 1;	// Buffer msgs loaded to mbx
 8004bb0:	f8d3 26ac 	ldr.w	r2, [r3, #1708]	; 0x6ac
 8004bb4:	3201      	adds	r2, #1
 8004bb6:	f8c3 26ac 	str.w	r2, [r3, #1708]	; 0x6ac

		/* Load more data, if buffer not empty */
		if (canxmtIDXm != canxmtIDXi)	// Are we caught up?
 8004bba:	f8d3 2598 	ldr.w	r2, [r3, #1432]	; 0x598
 8004bbe:	f8d3 359c 	ldr.w	r3, [r3, #1436]	; 0x59c
 8004bc2:	4293      	cmp	r3, r2
 8004bc4:	d004      	beq.n	8004bd0 <CAN1_TX_IRQHandler+0x60>
		{ // Here, no.  Msgs remain in buffer
			loadmbx(&canxmtbuf[canxmtIDXi]);	// Load mailbox, set TXRQ
 8004bc6:	4807      	ldr	r0, [pc, #28]	; (8004be4 <CAN1_TX_IRQHandler+0x74>)
 8004bc8:	eb00 1002 	add.w	r0, r0, r2, lsl #4
 8004bcc:	f7ff fd34 	bl	8004638 <loadmbx>
		}
	}
	temp = CAN_TSR(CAN1);	// JIC Prevent tail-chaining
 8004bd0:	4b02      	ldr	r3, [pc, #8]	; (8004bdc <CAN1_TX_IRQHandler+0x6c>)
 8004bd2:	681b      	ldr	r3, [r3, #0]

	return;
}
 8004bd4:	bd08      	pop	{r3, pc}
 8004bd6:	bf00      	nop
 8004bd8:	00010100 	.word	0x00010100
 8004bdc:	40006408 	.word	0x40006408
 8004be0:	20000fc8 	.word	0x20000fc8
 8004be4:	20001568 	.word	0x20001568

08004be8 <CAN1_RX0_IRQHandler>:
void CAN1_RX0_IRQHandler(void)
{
	int temp;
//while(1==1);
	/* Save message in a circular buffer */
	canbuf[canbufIDXi].id     = CAN_RI0R(CAN1);	// ID, RTR, IDE
 8004be8:	4b11      	ldr	r3, [pc, #68]	; (8004c30 <CAN1_RX0_IRQHandler+0x48>)
 8004bea:	4a12      	ldr	r2, [pc, #72]	; (8004c34 <CAN1_RX0_IRQHandler+0x4c>)
 8004bec:	68d9      	ldr	r1, [r3, #12]
 8004bee:	6810      	ldr	r0, [r2, #0]
 8004bf0:	eb03 1201 	add.w	r2, r3, r1, lsl #4
 8004bf4:	6110      	str	r0, [r2, #16]
	canbuf[canbufIDXi].dlc	  = CAN_RDT0R(CAN1);	// time, data length CAN_RDTxR p 663
 8004bf6:	4810      	ldr	r0, [pc, #64]	; (8004c38 <CAN1_RX0_IRQHandler+0x50>)
 8004bf8:	6800      	ldr	r0, [r0, #0]
 8004bfa:	6150      	str	r0, [r2, #20]
	canbuf[canbufIDXi].cd.ui[0] = CAN_RDL0R(CAN1);	// Data (32b) High, Data (32b) Low
 8004bfc:	480f      	ldr	r0, [pc, #60]	; (8004c3c <CAN1_RX0_IRQHandler+0x54>)
 8004bfe:	6800      	ldr	r0, [r0, #0]
 8004c00:	6190      	str	r0, [r2, #24]
	canbuf[canbufIDXi].cd.ui[1] = CAN_RDH0R(CAN1);	// Data (32b) High, Data (32b) Low
 8004c02:	480f      	ldr	r0, [pc, #60]	; (8004c40 <CAN1_RX0_IRQHandler+0x58>)
 8004c04:	6800      	ldr	r0, [r0, #0]
 8004c06:	61d0      	str	r0, [r2, #28]
//			SCB_AIRCR = (0x5FA << 16) | SCB_AIRCR_SYSRESETREQ;	// Cause a RESET
//	}


	/* Release FIFO 0 */	
	CAN_RF0R(CAN1) |= CAN_RF0R_RFOM0;	// Write bit 5
 8004c08:	4a0e      	ldr	r2, [pc, #56]	; (8004c44 <CAN1_RX0_IRQHandler+0x5c>)
 8004c0a:	6810      	ldr	r0, [r2, #0]
 8004c0c:	f040 0020 	orr.w	r0, r0, #32
 8004c10:	6010      	str	r0, [r2, #0]

	/* Advance index in circular buffer */
	canbufIDXi += 1; if (canbufIDXi >= CANRCVBUFSIZE) canbufIDXi = 0;// Reset to beginning
 8004c12:	1c4a      	adds	r2, r1, #1
 8004c14:	2a3f      	cmp	r2, #63	; 0x3f
 8004c16:	60da      	str	r2, [r3, #12]
 8004c18:	dd01      	ble.n	8004c1e <CAN1_RX0_IRQHandler+0x36>
 8004c1a:	2200      	movs	r2, #0
 8004c1c:	60da      	str	r2, [r3, #12]
		
	/* Trigger a pending interrupt, which will cause a chain of related routines to execute */
	NVICISPR(NVIC_I2C1_ER_IRQ);	// Set pending (low priority) interrupt ('../lib/libusartstm32/nvicdirect.h')
 8004c1e:	4b0a      	ldr	r3, [pc, #40]	; (8004c48 <CAN1_RX0_IRQHandler+0x60>)
 8004c20:	681a      	ldr	r2, [r3, #0]
 8004c22:	f042 0201 	orr.w	r2, r2, #1
 8004c26:	601a      	str	r2, [r3, #0]

	temp = CAN_RF0R(CAN1);	// Read register to avoid tail-chaining
 8004c28:	4b06      	ldr	r3, [pc, #24]	; (8004c44 <CAN1_RX0_IRQHandler+0x5c>)
 8004c2a:	681b      	ldr	r3, [r3, #0]

	return;
}
 8004c2c:	4770      	bx	lr
 8004c2e:	bf00      	nop
 8004c30:	20000fc8 	.word	0x20000fc8
 8004c34:	400065b0 	.word	0x400065b0
 8004c38:	400065b4 	.word	0x400065b4
 8004c3c:	400065b8 	.word	0x400065b8
 8004c40:	400065bc 	.word	0x400065bc
 8004c44:	4000640c 	.word	0x4000640c
 8004c48:	e000e204 	.word	0xe000e204

08004c4c <CAN1_RX1_IRQHandler>:
–   FIFO1 overrun condition, FOVR1 bit in the CAN_RF1R register set. */
void CAN1_RX1_IRQHandler(void)
{ // Here, FMP1 bits are not 00.
	int temp;
//while(1==1);
	fifo1cycnt = *(volatile unsigned int *)0xE0001004; // DWT_CYCNT
 8004c4c:	4b28      	ldr	r3, [pc, #160]	; (8004cf0 <CAN1_RX1_IRQHandler+0xa4>)
 8004c4e:	6818      	ldr	r0, [r3, #0]
 8004c50:	4b28      	ldr	r3, [pc, #160]	; (8004cf4 <CAN1_RX1_IRQHandler+0xa8>)
	fifo1msgflg += 1;
 8004c52:	f8d3 26b4 	ldr.w	r2, [r3, #1716]	; 0x6b4
 8004c56:	3201      	adds	r2, #1
/* p 647,8 The FIFO 1 interrupt can be generated by the following three events (only X = enabled):
X   Reception of a new message, FMP1 bits in the CAN_RF1R register are not ‘00’.
–   FIFO1 full condition, FULL1 bit in the CAN_RF1R register set.
–   FIFO1 overrun condition, FOVR1 bit in the CAN_RF1R register set. */
void CAN1_RX1_IRQHandler(void)
{ // Here, FMP1 bits are not 00.
 8004c58:	b510      	push	{r4, lr}
	int temp;
//while(1==1);
	fifo1cycnt = *(volatile unsigned int *)0xE0001004; // DWT_CYCNT
	fifo1msgflg += 1;
 8004c5a:	f8c3 26b4 	str.w	r2, [r3, #1716]	; 0x6b4

	/* Save time & message in a circular buffer */
	cantimbuf[canbuftimIDXi].U.ull    = fifo1cycnt;// Get current tick time
 8004c5e:	f8d3 2414 	ldr.w	r2, [r3, #1044]	; 0x414
–   FIFO1 overrun condition, FOVR1 bit in the CAN_RF1R register set. */
void CAN1_RX1_IRQHandler(void)
{ // Here, FMP1 bits are not 00.
	int temp;
//while(1==1);
	fifo1cycnt = *(volatile unsigned int *)0xE0001004; // DWT_CYCNT
 8004c62:	f8c3 06b0 	str.w	r0, [r3, #1712]	; 0x6b0
	fifo1msgflg += 1;

	/* Save time & message in a circular buffer */
	cantimbuf[canbuftimIDXi].U.ull    = fifo1cycnt;// Get current tick time
 8004c66:	2418      	movs	r4, #24
 8004c68:	4362      	muls	r2, r4
 8004c6a:	f503 6183 	add.w	r1, r3, #1048	; 0x418
 8004c6e:	188c      	adds	r4, r1, r2
 8004c70:	5088      	str	r0, [r1, r2]
 8004c72:	2100      	movs	r1, #0
 8004c74:	6061      	str	r1, [r4, #4]
	cantimbuf[canbuftimIDXi].R.id     = CAN_RI1R(CAN1);	// ID, RTR, IDE
 8004c76:	4920      	ldr	r1, [pc, #128]	; (8004cf8 <CAN1_RX1_IRQHandler+0xac>)
 8004c78:	189a      	adds	r2, r3, r2
 8004c7a:	6809      	ldr	r1, [r1, #0]
 8004c7c:	f8c2 1420 	str.w	r1, [r2, #1056]	; 0x420
	cantimbuf[canbuftimIDXi].R.dlc	  = CAN_RDT1R(CAN1);	// time, data length CAN_RDTxR p 663
 8004c80:	491e      	ldr	r1, [pc, #120]	; (8004cfc <CAN1_RX1_IRQHandler+0xb0>)
 8004c82:	6809      	ldr	r1, [r1, #0]
 8004c84:	f8c2 1424 	str.w	r1, [r2, #1060]	; 0x424
	cantimbuf[canbuftimIDXi].R.cd.ui[0] = CAN_RDL1R(CAN1);	// Data (32b) Low
 8004c88:	491d      	ldr	r1, [pc, #116]	; (8004d00 <CAN1_RX1_IRQHandler+0xb4>)
 8004c8a:	6809      	ldr	r1, [r1, #0]
 8004c8c:	f8c2 1428 	str.w	r1, [r2, #1064]	; 0x428
	cantimbuf[canbuftimIDXi].R.cd.ui[1] = CAN_RDH1R(CAN1);	// Data (32b) High
 8004c90:	491c      	ldr	r1, [pc, #112]	; (8004d04 <CAN1_RX1_IRQHandler+0xb8>)
 8004c92:	6809      	ldr	r1, [r1, #0]
 8004c94:	f8c2 142c 	str.w	r1, [r2, #1068]	; 0x42c

	/* Release FIFO 1 */	
	CAN_RF1R(CAN1) |= CAN_RF1R_RFOM1;		// Write bit 5 to release FIFO msg
 8004c98:	491b      	ldr	r1, [pc, #108]	; (8004d08 <CAN1_RX1_IRQHandler+0xbc>)
 8004c9a:	6808      	ldr	r0, [r1, #0]
 8004c9c:	f040 0020 	orr.w	r0, r0, #32
 8004ca0:	6008      	str	r0, [r1, #0]
//		SCB_AIRCR = (0x5FA << 16) | SCB_AIRCR_SYSRESETREQ;	// Cause a RESET
//	}

	// Note: in the following the RTR & IDE bits must be off, so it won't be confused with 29 bit addresses
	/* Did some ask to reset the wait loop timeout delay? */
	if ( canbuf[canbufIDXi].id == (CAN_RESETALL | CAN_DATAID_WAITDELAYRESET) )
 8004ca2:	68d9      	ldr	r1, [r3, #12]
 8004ca4:	eb03 1101 	add.w	r1, r3, r1, lsl #4
 8004ca8:	6909      	ldr	r1, [r1, #16]
 8004caa:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
 8004cae:	d10c      	bne.n	8004cca <CAN1_RX1_IRQHandler+0x7e>
	{	if ( (cantimbuf[canbuftimIDXi].R.dlc & 0xf) == 4 )	// Only one 4 byte value allowed
 8004cb0:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
 8004cb4:	f001 010f 	and.w	r1, r1, #15
 8004cb8:	2904      	cmp	r1, #4
 8004cba:	d106      	bne.n	8004cca <CAN1_RX1_IRQHandler+0x7e>
			can_waitdelay_ct += cantimbuf[canbuftimIDXi].R.cd.ui[0];	// Add pay load value to ctr
 8004cbc:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
 8004cc0:	f8d3 26b8 	ldr.w	r2, [r3, #1720]	; 0x6b8
 8004cc4:	188a      	adds	r2, r1, r2
 8004cc6:	f8c3 26b8 	str.w	r2, [r3, #1720]	; 0x6b8
	}
	
	/* Advance index in circular buffer */
	canbuftimIDXi += 1; if (canbuftimIDXi >= CANRCVTIMBUFSIZE) canbuftimIDXi = 0;// Reset to beginning
 8004cca:	f8d3 2414 	ldr.w	r2, [r3, #1044]	; 0x414
 8004cce:	3201      	adds	r2, #1
 8004cd0:	2a0f      	cmp	r2, #15
 8004cd2:	f8c3 2414 	str.w	r2, [r3, #1044]	; 0x414
 8004cd6:	dd03      	ble.n	8004ce0 <CAN1_RX1_IRQHandler+0x94>
 8004cd8:	4b06      	ldr	r3, [pc, #24]	; (8004cf4 <CAN1_RX1_IRQHandler+0xa8>)
 8004cda:	2200      	movs	r2, #0
 8004cdc:	f8c3 2414 	str.w	r2, [r3, #1044]	; 0x414

	/* Trigger a pending interrupt, which will cause a chain of related routines to execute */
	NVICISPR(NVIC_I2C1_EV_IRQ);	// Set pending (low priority) interrupt ('../lib/libusartstm32/nvicdirect.h')
 8004ce0:	4b0a      	ldr	r3, [pc, #40]	; (8004d0c <CAN1_RX1_IRQHandler+0xc0>)
 8004ce2:	681a      	ldr	r2, [r3, #0]
 8004ce4:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8004ce8:	601a      	str	r2, [r3, #0]

	temp = CAN_RF1R(CAN1);	// Read back register to avoid tail-chaining
 8004cea:	4b07      	ldr	r3, [pc, #28]	; (8004d08 <CAN1_RX1_IRQHandler+0xbc>)
 8004cec:	681b      	ldr	r3, [r3, #0]

	return;
}
 8004cee:	bd10      	pop	{r4, pc}
 8004cf0:	e0001004 	.word	0xe0001004
 8004cf4:	20000fc8 	.word	0x20000fc8
 8004cf8:	400065c0 	.word	0x400065c0
 8004cfc:	400065c4 	.word	0x400065c4
 8004d00:	400065c8 	.word	0x400065c8
 8004d04:	400065cc 	.word	0x400065cc
 8004d08:	40006410 	.word	0x40006410
 8004d0c:	e000e200 	.word	0xe000e200

08004d10 <CAN1_SCE_IRQHandler>:
–   Entry into Sleep mode. */
void CAN1_SCE_IRQHandler(void)
{
//while(1==1);
	return;
}
 8004d10:	4770      	bx	lr

08004d12 <I2C1_EV_IRQHandler>:
/*#######################################################################################
 * ISR routine for FIFO 1 (higher than other low priority level)
 *####################################################################################### */
void I2C1_EV_IRQHandler(void)
{
 8004d12:	b508      	push	{r3, lr}
/* This interrupt is caused by the CAN FIFO 1 (time sync message) interrupt for further processing at a low interrupt priority */

	/* Call other routines if an address is set up */
	if (highpriority_ptr != 0)	// Having no address for the following is bad.
 8004d14:	4b02      	ldr	r3, [pc, #8]	; (8004d20 <I2C1_EV_IRQHandler+0xe>)
 8004d16:	f8d3 36bc 	ldr.w	r3, [r3, #1724]	; 0x6bc
 8004d1a:	b103      	cbz	r3, 8004d1e <I2C1_EV_IRQHandler+0xc>
		(*highpriority_ptr)();	// Go do something
 8004d1c:	4798      	blx	r3
 8004d1e:	bd08      	pop	{r3, pc}
 8004d20:	20000fc8 	.word	0x20000fc8

08004d24 <I2C1_ER_IRQHandler>:
}
/*#######################################################################################
 * ISR routine for FIFO 0 low priority level
 *####################################################################################### */
void I2C1_ER_IRQHandler(void)
{
 8004d24:	b508      	push	{r3, lr}
	/* Call other routines if an address is set up */
	if (lowpriority_ptr != 0)	// Having no address for the following is bad.
 8004d26:	4b03      	ldr	r3, [pc, #12]	; (8004d34 <I2C1_ER_IRQHandler+0x10>)
 8004d28:	f8d3 36c0 	ldr.w	r3, [r3, #1728]	; 0x6c0
 8004d2c:	b103      	cbz	r3, 8004d30 <I2C1_ER_IRQHandler+0xc>
		(*lowpriority_ptr)();	// Go do something
 8004d2e:	4798      	blx	r3
 8004d30:	bd08      	pop	{r3, pc}
 8004d32:	bf00      	nop
 8004d34:	20000fc8 	.word	0x20000fc8

08004d38 <I2C2_EV_IRQHandler>:
}
/*#######################################################################################
 * ISR routine for SYSTICK low priority level
 *####################################################################################### */
void I2C2_EV_IRQHandler(void)
{
 8004d38:	b508      	push	{r3, lr}
	/* Call other routines if an address is set up */
	if (systickLOpriority_ptr != 0)	// Having no address for the following is bad.
 8004d3a:	4b03      	ldr	r3, [pc, #12]	; (8004d48 <I2C2_EV_IRQHandler+0x10>)
 8004d3c:	f8d3 36c4 	ldr.w	r3, [r3, #1732]	; 0x6c4
 8004d40:	b103      	cbz	r3, 8004d44 <I2C2_EV_IRQHandler+0xc>
		(*systickLOpriority_ptr)();	// Go do something
 8004d42:	4798      	blx	r3
 8004d44:	bd08      	pop	{r3, pc}
 8004d46:	bf00      	nop
 8004d48:	20000fc8 	.word	0x20000fc8

08004d4c <I2C2_ER_IRQHandler>:
}
/*#######################################################################################
 * ISR routine for very low priority following CAN_sync routine
 *####################################################################################### */
void I2C2_ER_IRQHandler(void)
{
 8004d4c:	b508      	push	{r3, lr}
	/* Call other routines if an address is set up */
	if (fifo1veryLOpriority_ptr != 0)	// Having no address for the following is bad.
 8004d4e:	4b03      	ldr	r3, [pc, #12]	; (8004d5c <I2C2_ER_IRQHandler+0x10>)
 8004d50:	f8d3 36c8 	ldr.w	r3, [r3, #1736]	; 0x6c8
 8004d54:	b103      	cbz	r3, 8004d58 <I2C2_ER_IRQHandler+0xc>
		(*fifo1veryLOpriority_ptr)();	// Go do something
 8004d56:	4798      	blx	r3
 8004d58:	bd08      	pop	{r3, pc}
 8004d5a:	bf00      	nop
 8004d5c:	20000fc8 	.word	0x20000fc8

08004d60 <loop>:
{
	LEDSALL_off;
	return;
}	
static void loop(volatile int ct)
{
 8004d60:	b082      	sub	sp, #8
 8004d62:	9001      	str	r0, [sp, #4]
	while (ct > 0) ct -= 1; 
 8004d64:	e002      	b.n	8004d6c <loop+0xc>
 8004d66:	9b01      	ldr	r3, [sp, #4]
 8004d68:	3b01      	subs	r3, #1
 8004d6a:	9301      	str	r3, [sp, #4]
 8004d6c:	9b01      	ldr	r3, [sp, #4]
 8004d6e:	2b00      	cmp	r3, #0
 8004d70:	dcf9      	bgt.n	8004d66 <loop+0x6>
	return;
}
 8004d72:	b002      	add	sp, #8
 8004d74:	4770      	bx	lr

08004d76 <panic_leds>:
 * @brief	: Configure gpio pins for Discovery F4 board
 ******************************************************************************/
int PanicCount;

void panic_leds(unsigned int count)
{
 8004d76:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	unsigned int i;
	volatile int x;		// Loop ct for timing pause
	volatile int xon;	// Loop ct for timing LED on duration
	volatile int xoff;	// Loop ct for timing LED off duration
	int sw = 0;
PanicCount = count; // Usefull for debugging this
 8004d78:	4b1d      	ldr	r3, [pc, #116]	; (8004df0 <panic_leds+0x7a>)
	/* Have clocks been setup? */
	if (sysclk_freq < 1000000)
 8004d7a:	4a1e      	ldr	r2, [pc, #120]	; (8004df4 <panic_leds+0x7e>)
	unsigned int i;
	volatile int x;		// Loop ct for timing pause
	volatile int xon;	// Loop ct for timing LED on duration
	volatile int xoff;	// Loop ct for timing LED off duration
	int sw = 0;
PanicCount = count; // Usefull for debugging this
 8004d7c:	6018      	str	r0, [r3, #0]
	/* Have clocks been setup? */
	if (sysclk_freq < 1000000)
 8004d7e:	4b1e      	ldr	r3, [pc, #120]	; (8004df8 <panic_leds+0x82>)
 8004d80:	6819      	ldr	r1, [r3, #0]
 8004d82:	4291      	cmp	r1, r2
	{ // Here, no.  We are running on the 8 MHz HSI oscillator
		sysclk_freq = 8000000;	// Set default
 8004d84:	bf9c      	itt	ls
 8004d86:	4d1d      	ldrls	r5, [pc, #116]	; (8004dfc <panic_leds+0x86>)
 8004d88:	601d      	strls	r5, [r3, #0]
		sw = 8000000;	// Not zero
	}

	/* Setup timing for pause */
	x = sysclk_freq/10;
 8004d8a:	681b      	ldr	r3, [r3, #0]
{
	unsigned int i;
	volatile int x;		// Loop ct for timing pause
	volatile int xon;	// Loop ct for timing LED on duration
	volatile int xoff;	// Loop ct for timing LED off duration
	int sw = 0;
 8004d8c:	bf88      	it	hi
 8004d8e:	2500      	movhi	r5, #0
		sysclk_freq = 8000000;	// Set default
		sw = 8000000;	// Not zero
	}

	/* Setup timing for pause */
	x = sysclk_freq/10;
 8004d90:	220a      	movs	r2, #10
 8004d92:	fbb3 f2f2 	udiv	r2, r3, r2
 8004d96:	9203      	str	r2, [sp, #12]

	/* Setup timing for fast flash */
	xon =  sysclk_freq/250;
 8004d98:	22fa      	movs	r2, #250	; 0xfa
 8004d9a:	fbb3 f2f2 	udiv	r2, r3, r2
 8004d9e:	9202      	str	r2, [sp, #8]
	xoff = sysclk_freq/40;
 8004da0:	2228      	movs	r2, #40	; 0x28
 8004da2:	fbb3 f3f2 	udiv	r3, r3, r2
 8004da6:	9301      	str	r3, [sp, #4]

	/* Limit max count */
	if (count == 0) count = 6; // Bogus count

	/* Be sure we have the ports and pins setup for the LEDs */
	RCC_AHB1ENR |= 0x08;	// Enable IO port D
 8004da8:	4b15      	ldr	r3, [pc, #84]	; (8004e00 <panic_leds+0x8a>)
 8004daa:	681a      	ldr	r2, [r3, #0]
 8004dac:	f042 0208 	orr.w	r2, r2, #8
 * @brief	: Configure gpio pins for Discovery F4 board
 ******************************************************************************/
int PanicCount;

void panic_leds(unsigned int count)
{
 8004db0:	4604      	mov	r4, r0

	/* Limit max count */
	if (count == 0) count = 6; // Bogus count

	/* Be sure we have the ports and pins setup for the LEDs */
	RCC_AHB1ENR |= 0x08;	// Enable IO port D
 8004db2:	601a      	str	r2, [r3, #0]
	/* Setup timing for fast flash */
	xon =  sysclk_freq/250;
	xoff = sysclk_freq/40;

	/* Limit max count */
	if (count == 0) count = 6; // Bogus count
 8004db4:	2800      	cmp	r0, #0
 8004db6:	bf08      	it	eq
 8004db8:	2406      	moveq	r4, #6

	/* Be sure we have the ports and pins setup for the LEDs */
	RCC_AHB1ENR |= 0x08;	// Enable IO port D
	DISCgpiopins_Config();	// Configure pins
 8004dba:	f7ff fbbd 	bl	8004538 <DISCgpiopins_Config>

	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	if (sw == 0)
 8004dbe:	b175      	cbz	r5, 8004dde <panic_leds+0x68>
 8004dc0:	e014      	b.n	8004dec <panic_leds+0x76>
#include "libopencm3/stm32/f4/rcc.h"

extern unsigned int	sysclk_freq;	/* 	SYSCLK freq		E.g. 72000000	*/
static void allon(void)
{
	LEDSALL_on;
 8004dc2:	4e10      	ldr	r6, [pc, #64]	; (8004e04 <panic_leds+0x8e>)
 8004dc4:	f44f 4370 	mov.w	r3, #61440	; 0xf000
 8004dc8:	6033      	str	r3, [r6, #0]
	{
		while (1==1)
		{
			for (i = 0; i < count; i++)
			{
				allon();	loop(xon);
 8004dca:	9802      	ldr	r0, [sp, #8]
 8004dcc:	f7ff ffc8 	bl	8004d60 <loop>
	LEDSALL_on;
	return;
}
static void alloff(void)
{
	LEDSALL_off;
 8004dd0:	f04f 4370 	mov.w	r3, #4026531840	; 0xf0000000
 8004dd4:	6033      	str	r3, [r6, #0]
		while (1==1)
		{
			for (i = 0; i < count; i++)
			{
				allon();	loop(xon);
				alloff();	loop(xoff);			
 8004dd6:	9801      	ldr	r0, [sp, #4]
 8004dd8:	f7ff ffc2 	bl	8004d60 <loop>
	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	if (sw == 0)
	{
		while (1==1)
		{
			for (i = 0; i < count; i++)
 8004ddc:	3501      	adds	r5, #1
 8004dde:	42a5      	cmp	r5, r4
 8004de0:	d3ef      	bcc.n	8004dc2 <panic_leds+0x4c>
			{
				allon();	loop(xon);
				alloff();	loop(xoff);			
			}
			loop(x);
 8004de2:	9803      	ldr	r0, [sp, #12]
 8004de4:	f7ff ffbc 	bl	8004d60 <loop>
	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	if (sw == 0)
	{
		while (1==1)
		{
			for (i = 0; i < count; i++)
 8004de8:	2500      	movs	r5, #0
 8004dea:	e7f8      	b.n	8004dde <panic_leds+0x68>
				alloff();	loop(xoff);			
			}
			loop(x);
		}
	}
}
 8004dec:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
 8004dee:	bf00      	nop
 8004df0:	200016a8 	.word	0x200016a8
 8004df4:	000f423f 	.word	0x000f423f
 8004df8:	200016cc 	.word	0x200016cc
 8004dfc:	007a1200 	.word	0x007a1200
 8004e00:	40023830 	.word	0x40023830
 8004e04:	40020c18 	.word	0x40020c18

08004e08 <CAN_gateway_send>:
 * @param	: pg = Pointer to message buffer (see common_can.h)
 * @return	: 0 = OK; -1 = dlc greater than 8; -2 = illegal extended address
 * ************************************************************************************** */

int CAN_gateway_send(struct CANRCVBUF* pg)
{
 8004e08:	b508      	push	{r3, lr}
	/* Check number of bytes in payload and limit to 8. */
	if ((pg->dlc & 0x0f) > 8) 
 8004e0a:	6843      	ldr	r3, [r0, #4]
 8004e0c:	f003 030f 	and.w	r3, r3, #15
 8004e10:	2b08      	cmp	r3, #8
 8004e12:	d80b      	bhi.n	8004e2c <CAN_gateway_send+0x24>
		return -1;	// Payload ct too big
	
	/* Check if an illegal id combination */
	if ( ((pg->id & 0x001ffff9) != 0) && ((pg->id & 0x04) == 0) ) 
 8004e14:	6802      	ldr	r2, [r0, #0]
 8004e16:	4b08      	ldr	r3, [pc, #32]	; (8004e38 <CAN_gateway_send+0x30>)
 8004e18:	ea02 0303 	and.w	r3, r2, r3
 8004e1c:	b113      	cbz	r3, 8004e24 <CAN_gateway_send+0x1c>
 8004e1e:	f012 0f04 	tst.w	r2, #4
 8004e22:	d006      	beq.n	8004e32 <CAN_gateway_send+0x2a>
	{ // Here, in the additional 18 extended id bits one or more are on, but IDE flag is for standard id (11 bits)
		return -2; // Illegal id
	}

	/* Add msg to CAN outgoing buffer. */
	can_msg_put_ldr(pg);
 8004e24:	f7ff fe1a 	bl	8004a5c <can_msg_put_ldr>

	return 0;
 8004e28:	2000      	movs	r0, #0
 8004e2a:	bd08      	pop	{r3, pc}

int CAN_gateway_send(struct CANRCVBUF* pg)
{
	/* Check number of bytes in payload and limit to 8. */
	if ((pg->dlc & 0x0f) > 8) 
		return -1;	// Payload ct too big
 8004e2c:	f04f 30ff 	mov.w	r0, #4294967295
 8004e30:	bd08      	pop	{r3, pc}
	
	/* Check if an illegal id combination */
	if ( ((pg->id & 0x001ffff9) != 0) && ((pg->id & 0x04) == 0) ) 
	{ // Here, in the additional 18 extended id bits one or more are on, but IDE flag is for standard id (11 bits)
		return -2; // Illegal id
 8004e32:	f06f 0001 	mvn.w	r0, #1

	/* Add msg to CAN outgoing buffer. */
	can_msg_put_ldr(pg);

	return 0;
}
 8004e36:	bd08      	pop	{r3, pc}
 8004e38:	001ffff9 	.word	0x001ffff9

08004e3c <spi2rw_init>:
/******************************************************************************
 * void spi2rw_init(void);
 *  @brief Initialize SPI 
*******************************************************************************/ 
void spi2rw_init(void)
{
 8004e3c:	b538      	push	{r3, r4, r5, lr}
	/* Enable bus clocking for SPI2 */
	RCC_APB1ENR |= (1<<14);	// Enable SPI2 clocking
 8004e3e:	4b17      	ldr	r3, [pc, #92]	; (8004e9c <spi2rw_init+0x60>)

	/* Set up pins for SPI2 use. */
	f4gpiopins_Config ((volatile u32*)GPIOB, 12, (struct PINCONFIG*)&outputcs);	// CS
 8004e40:	4c17      	ldr	r4, [pc, #92]	; (8004ea0 <spi2rw_init+0x64>)
 *  @brief Initialize SPI 
*******************************************************************************/ 
void spi2rw_init(void)
{
	/* Enable bus clocking for SPI2 */
	RCC_APB1ENR |= (1<<14);	// Enable SPI2 clocking
 8004e42:	681a      	ldr	r2, [r3, #0]

	/* Set up pins for SPI2 use. */
	f4gpiopins_Config ((volatile u32*)GPIOB, 12, (struct PINCONFIG*)&outputcs);	// CS
 8004e44:	4817      	ldr	r0, [pc, #92]	; (8004ea4 <spi2rw_init+0x68>)
 *  @brief Initialize SPI 
*******************************************************************************/ 
void spi2rw_init(void)
{
	/* Enable bus clocking for SPI2 */
	RCC_APB1ENR |= (1<<14);	// Enable SPI2 clocking
 8004e46:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8004e4a:	601a      	str	r2, [r3, #0]

	/* Set up pins for SPI2 use. */
	f4gpiopins_Config ((volatile u32*)GPIOB, 12, (struct PINCONFIG*)&outputcs);	// CS
 8004e4c:	210c      	movs	r1, #12
 8004e4e:	4622      	mov	r2, r4
	f4gpiopins_Config ((volatile u32*)GPIOB, 13, (struct PINCONFIG*)&outputaf);	// SCK
 8004e50:	1d65      	adds	r5, r4, #5
{
	/* Enable bus clocking for SPI2 */
	RCC_APB1ENR |= (1<<14);	// Enable SPI2 clocking

	/* Set up pins for SPI2 use. */
	f4gpiopins_Config ((volatile u32*)GPIOB, 12, (struct PINCONFIG*)&outputcs);	// CS
 8004e52:	f7ff fb92 	bl	800457a <f4gpiopins_Config>
	f4gpiopins_Config ((volatile u32*)GPIOB, 13, (struct PINCONFIG*)&outputaf);	// SCK
 8004e56:	4813      	ldr	r0, [pc, #76]	; (8004ea4 <spi2rw_init+0x68>)
 8004e58:	210d      	movs	r1, #13
 8004e5a:	462a      	mov	r2, r5
 8004e5c:	f7ff fb8d 	bl	800457a <f4gpiopins_Config>
	f4gpiopins_Config ((volatile u32*)GPIOB, 14, (struct PINCONFIG*)&inputaf);	// MISO
 8004e60:	4810      	ldr	r0, [pc, #64]	; (8004ea4 <spi2rw_init+0x68>)
 8004e62:	210e      	movs	r1, #14
 8004e64:	f104 020a 	add.w	r2, r4, #10
 8004e68:	f7ff fb87 	bl	800457a <f4gpiopins_Config>
	f4gpiopins_Config ((volatile u32*)GPIOB, 15, (struct PINCONFIG*)&outputaf);	// MOSI
 8004e6c:	462a      	mov	r2, r5
 8004e6e:	480d      	ldr	r0, [pc, #52]	; (8004ea4 <spi2rw_init+0x68>)
 8004e70:	210f      	movs	r1, #15
 8004e72:	f7ff fb82 	bl	800457a <f4gpiopins_Config>

	GPIO_BSRR(GPIOB)  = (1<<12);// Set /CS high
 8004e76:	4b0c      	ldr	r3, [pc, #48]	; (8004ea8 <spi2rw_init+0x6c>)
 8004e78:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8004e7c:	601a      	str	r2, [r3, #0]

	// Set divisor to max.  If APB1 is 42 Mhz, then divide by 256 = 164062.5 Hz, 48 us per byte
/* NOTE: The following line is where the "phase" is set for the clock and polarity */
	//          (SSM SSI)  |enable peripheral | baud divisor | master select | CK 1 when idle    | phase  )
	SPI2_CR1 =  (0x3 << 8) |   (1 << 6)       | (0x7 << 3)   |   (1 << 2)    |    (1 << 1)       |  0x01    ;
 8004e7e:	4b0b      	ldr	r3, [pc, #44]	; (8004eac <spi2rw_init+0x70>)
 8004e80:	f240 327f 	movw	r2, #895	; 0x37f
 8004e84:	601a      	str	r2, [r3, #0]
	
	/* SPI-CR2 use default, no interrupt masks enabled at this point */

	/* Set and enable interrupt controller for SPI2 */
	NVICIPR (NVIC_SPI2_IRQ, SPI2_PRIORITY );	// Set interrupt priority
 8004e86:	4b0a      	ldr	r3, [pc, #40]	; (8004eb0 <spi2rw_init+0x74>)
 8004e88:	681a      	ldr	r2, [r3, #0]
 8004e8a:	f042 0250 	orr.w	r2, r2, #80	; 0x50
 8004e8e:	601a      	str	r2, [r3, #0]
	NVICISER(NVIC_SPI2_IRQ);			// Enable interrupt controller for SPI2
 8004e90:	4b08      	ldr	r3, [pc, #32]	; (8004eb4 <spi2rw_init+0x78>)
 8004e92:	681a      	ldr	r2, [r3, #0]
 8004e94:	f042 0210 	orr.w	r2, r2, #16
 8004e98:	601a      	str	r2, [r3, #0]

	return;
}
 8004e9a:	bd38      	pop	{r3, r4, r5, pc}
 8004e9c:	40023840 	.word	0x40023840
 8004ea0:	0800cee3 	.word	0x0800cee3
 8004ea4:	40020400 	.word	0x40020400
 8004ea8:	40020418 	.word	0x40020418
 8004eac:	40003800 	.word	0x40003800
 8004eb0:	e000e424 	.word	0xe000e424
 8004eb4:	e000e104 	.word	0xe000e104

08004eb8 <spi2_busy>:
 * @return	: 0 = /CS line is low; not-zero (busy) = /CS line is high (not busy)
*******************************************************************************/
unsigned short spi2_busy(void)
{
/* The /CS line is used to show if the SPI transfer is in progress */
	return (GPIOB_ODR & (1<<12));	// Return /CS bit
 8004eb8:	4b02      	ldr	r3, [pc, #8]	; (8004ec4 <spi2_busy+0xc>)
 8004eba:	6818      	ldr	r0, [r3, #0]
}
 8004ebc:	f400 5080 	and.w	r0, r0, #4096	; 0x1000
 8004ec0:	4770      	bx	lr
 8004ec2:	bf00      	nop
 8004ec4:	40020414 	.word	0x40020414

08004ec8 <spi2_rw>:
 * @param	: char *pout = pointer to byte array with bytes to output
 * @param	: char *pin  = pointer to byte array to receive bytes coming in
 * @param	: int count  = byte count of number of write/read cycles
*******************************************************************************/
void spi2_rw (char *pout, char * pin, int count)
{
 8004ec8:	b570      	push	{r4, r5, r6, lr}
 8004eca:	4604      	mov	r4, r0
 8004ecc:	460d      	mov	r5, r1
 8004ece:	4616      	mov	r6, r2
	/* The following should not be necessary, but it is here JIC. */
	while ( spi2_busy() == 0 );	// Loop until a prior spi communication is complete
 8004ed0:	f7ff fff2 	bl	8004eb8 <spi2_busy>
 8004ed4:	2800      	cmp	r0, #0
 8004ed6:	d0fb      	beq.n	8004ed0 <spi2_rw+0x8>

	GPIO_BSRR(GPIOB)  = (1<<(12+16));	// Set /CS low (show busy)
 8004ed8:	4b08      	ldr	r3, [pc, #32]	; (8004efc <spi2_rw+0x34>)
 8004eda:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004ede:	601a      	str	r2, [r3, #0]
	spi2_outptr = pout;		// Set pointer for interrupt handler to store outgoing data
	spi2_inptr = pin;		// Set pointer for interrupt handler to store incoming data
 8004ee0:	4b07      	ldr	r3, [pc, #28]	; (8004f00 <spi2_rw+0x38>)
	spi2_cnt = count;		// Set byte count for interrupt handler
	SPI2_DR = *spi2_outptr++;	// Load outgoing byte to start spi cycle
 8004ee2:	4a08      	ldr	r2, [pc, #32]	; (8004f04 <spi2_rw+0x3c>)
	/* The following should not be necessary, but it is here JIC. */
	while ( spi2_busy() == 0 );	// Loop until a prior spi communication is complete

	GPIO_BSRR(GPIOB)  = (1<<(12+16));	// Set /CS low (show busy)
	spi2_outptr = pout;		// Set pointer for interrupt handler to store outgoing data
	spi2_inptr = pin;		// Set pointer for interrupt handler to store incoming data
 8004ee4:	601d      	str	r5, [r3, #0]
	spi2_cnt = count;		// Set byte count for interrupt handler
 8004ee6:	605e      	str	r6, [r3, #4]
	SPI2_DR = *spi2_outptr++;	// Load outgoing byte to start spi cycle
 8004ee8:	f814 1b01 	ldrb.w	r1, [r4], #1
 8004eec:	6011      	str	r1, [r2, #0]
 8004eee:	609c      	str	r4, [r3, #8]
	SPI2_CR2 |= (SPI_CR2_RXNEIE);	// Enable receive buffer loaded (not empty) interrupt
 8004ef0:	4b05      	ldr	r3, [pc, #20]	; (8004f08 <spi2_rw+0x40>)
 8004ef2:	681a      	ldr	r2, [r3, #0]
 8004ef4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8004ef8:	601a      	str	r2, [r3, #0]
	return;
}
 8004efa:	bd70      	pop	{r4, r5, r6, pc}
 8004efc:	40020418 	.word	0x40020418
 8004f00:	200016ac 	.word	0x200016ac
 8004f04:	4000380c 	.word	0x4000380c
 8004f08:	40003804 	.word	0x40003804

08004f0c <SPI2_IRQHandler>:
off (not really necessary), and the i/o pin with the CS line is brought back high. 
*/

	volatile unsigned int dummy;

	if ( (SPI2_SR & SPI_SR_RXNE) != 0)  // Check for bogus interrupt
 8004f0c:	4b15      	ldr	r3, [pc, #84]	; (8004f64 <SPI2_IRQHandler+0x58>)
 8004f0e:	681b      	ldr	r3, [r3, #0]
 8004f10:	f013 0f01 	tst.w	r3, #1
 * ISR routine
 *####################################################################################### */
int spidebug1;

void SPI2_IRQHandler(void)
{      
 8004f14:	b507      	push	{r0, r1, r2, lr}
off (not really necessary), and the i/o pin with the CS line is brought back high. 
*/

	volatile unsigned int dummy;

	if ( (SPI2_SR & SPI_SR_RXNE) != 0)  // Check for bogus interrupt
 8004f16:	d020      	beq.n	8004f5a <SPI2_IRQHandler+0x4e>
	{ /* Here, valid receive interrupt. */
		*spi2_inptr++ = SPI2_DR;	// Get byte that was read
 8004f18:	4b13      	ldr	r3, [pc, #76]	; (8004f68 <SPI2_IRQHandler+0x5c>)
 8004f1a:	4914      	ldr	r1, [pc, #80]	; (8004f6c <SPI2_IRQHandler+0x60>)
 8004f1c:	681a      	ldr	r2, [r3, #0]
 8004f1e:	6808      	ldr	r0, [r1, #0]
 8004f20:	f802 0b01 	strb.w	r0, [r2], #1
 8004f24:	601a      	str	r2, [r3, #0]
		spi2_cnt -= 1;	 		// Decrement byte count
 8004f26:	685a      	ldr	r2, [r3, #4]
 8004f28:	3a01      	subs	r2, #1
		if (spi2_cnt <= 0)		// Have we exhausted the count?
 8004f2a:	2a00      	cmp	r2, #0
	volatile unsigned int dummy;

	if ( (SPI2_SR & SPI_SR_RXNE) != 0)  // Check for bogus interrupt
	{ /* Here, valid receive interrupt. */
		*spi2_inptr++ = SPI2_DR;	// Get byte that was read
		spi2_cnt -= 1;	 		// Decrement byte count
 8004f2c:	605a      	str	r2, [r3, #4]
		if (spi2_cnt <= 0)		// Have we exhausted the count?
 8004f2e:	dc0c      	bgt.n	8004f4a <SPI2_IRQHandler+0x3e>
		{ /* Here, yes, this byte is the reponse from the last byte transmitted */ 
			SPI2_CR2 &= ~SPI_CR2_RXNEIE;	// Turn off RXE interrupt enable
 8004f30:	4a0f      	ldr	r2, [pc, #60]	; (8004f70 <SPI2_IRQHandler+0x64>)
			GPIO_BSRR(GPIOB)  = (1<<12);// Set /CS high (show not busy)
			if (spi2_readdoneptr != 0) // Skip if pointer is NULL
 8004f32:	68db      	ldr	r3, [r3, #12]
	{ /* Here, valid receive interrupt. */
		*spi2_inptr++ = SPI2_DR;	// Get byte that was read
		spi2_cnt -= 1;	 		// Decrement byte count
		if (spi2_cnt <= 0)		// Have we exhausted the count?
		{ /* Here, yes, this byte is the reponse from the last byte transmitted */ 
			SPI2_CR2 &= ~SPI_CR2_RXNEIE;	// Turn off RXE interrupt enable
 8004f34:	6811      	ldr	r1, [r2, #0]
 8004f36:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 8004f3a:	6011      	str	r1, [r2, #0]
			GPIO_BSRR(GPIOB)  = (1<<12);// Set /CS high (show not busy)
 8004f3c:	4a0d      	ldr	r2, [pc, #52]	; (8004f74 <SPI2_IRQHandler+0x68>)
 8004f3e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8004f42:	6011      	str	r1, [r2, #0]
			if (spi2_readdoneptr != 0) // Skip if pointer is NULL
 8004f44:	b163      	cbz	r3, 8004f60 <SPI2_IRQHandler+0x54>
				(*spi2_readdoneptr)();	// In case we want to do something else
 8004f46:	4798      	blx	r3
 8004f48:	e00a      	b.n	8004f60 <SPI2_IRQHandler+0x54>
			return;
		}
		else
		{
spidebug1 +=1;
 8004f4a:	691a      	ldr	r2, [r3, #16]
 8004f4c:	3201      	adds	r2, #1
 8004f4e:	611a      	str	r2, [r3, #16]
			SPI2_DR = *spi2_outptr++;	// Load outgoing byte to start next spi cycle
 8004f50:	689a      	ldr	r2, [r3, #8]
 8004f52:	f812 0b01 	ldrb.w	r0, [r2], #1
 8004f56:	6008      	str	r0, [r1, #0]
 8004f58:	609a      	str	r2, [r3, #8]
		}
	}
	dummy = SPI2_SR; // Prevent tail-chaining.
 8004f5a:	4b02      	ldr	r3, [pc, #8]	; (8004f64 <SPI2_IRQHandler+0x58>)
 8004f5c:	681b      	ldr	r3, [r3, #0]
 8004f5e:	9301      	str	r3, [sp, #4]
	return;
}
 8004f60:	bd0e      	pop	{r1, r2, r3, pc}
 8004f62:	bf00      	nop
 8004f64:	40003808 	.word	0x40003808
 8004f68:	200016ac 	.word	0x200016ac
 8004f6c:	4000380c 	.word	0x4000380c
 8004f70:	40003804 	.word	0x40003804
 8004f74:	40020418 	.word	0x40020418

08004f78 <convert>:
	pclk2_freq  =   hclk_freq/convert(clocks->apb2);	// APB2 driven from AHB
 	return;                                           
}
/* Convert 0,4,5,6,7 input to 1,2,4,8,16 */
unsigned int convert(unsigned int ucX)
{	
 8004f78:	2301      	movs	r3, #1
	return (ucX == 0)?:(1 << (ucX-3) );
 8004f7a:	b118      	cbz	r0, 8004f84 <convert+0xc>
 8004f7c:	3803      	subs	r0, #3
 8004f7e:	fa13 f000 	lsls.w	r0, r3, r0
 8004f82:	4770      	bx	lr
 8004f84:	4618      	mov	r0, r3
}
 8004f86:	4770      	bx	lr

08004f88 <clockspecifysetup>:
 * @brief	: Setup the clocks & bus freq dividers
 * @param	: chase: 0 = use HSI (internal 8 MHz RC osc), 1 = use HSE (external Xtal osc)
 * @return	: static variables are set from input paramaters passed in struct
 ******************************************************************************/
void clockspecifysetup(struct CLOCKS *clocks)
{
 8004f88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004f8a:	4603      	mov	r3, r0
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
	unsigned short sw_pll = 0;		// 0 = pll not used; 1 = pll used
	unsigned short pllp = clocks->pllp;	// Likely the clocks struct was a "const" and we may have to override the value given
 8004f8c:	89c4      	ldrh	r4, [r0, #14]

	/* See Ref manual page 85 figure 9 */
	/* Note: Out of reset, the HSI (internal rc osc) is selected and ready. */


	switch (clocks->hso)	// Select high speed oscillator source
 8004f8e:	781a      	ldrb	r2, [r3, #0]
{
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
	unsigned short sw_pll = 0;		// 0 = pll not used; 1 = pll used
	unsigned short pllp = clocks->pllp;	// Likely the clocks struct was a "const" and we may have to override the value given
	unsigned short pllm = clocks->pllm;
 8004f90:	8a41      	ldrh	r1, [r0, #18]
	unsigned short plln = clocks->plln;
	unsigned short pllq = clocks->pllq;
 8004f92:	899d      	ldrh	r5, [r3, #12]
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
	unsigned short sw_pll = 0;		// 0 = pll not used; 1 = pll used
	unsigned short pllp = clocks->pllp;	// Likely the clocks struct was a "const" and we may have to override the value given
	unsigned short pllm = clocks->pllm;
	unsigned short plln = clocks->plln;
 8004f94:	8a00      	ldrh	r0, [r0, #16]
	unsigned short pllq = clocks->pllq;
	unsigned int	freq = clocks->freq;	
 8004f96:	689e      	ldr	r6, [r3, #8]

	/* See Ref manual page 85 figure 9 */
	/* Note: Out of reset, the HSI (internal rc osc) is selected and ready. */


	switch (clocks->hso)	// Select high speed oscillator source
 8004f98:	2a04      	cmp	r2, #4
 8004f9a:	d834      	bhi.n	8005006 <clockspecifysetup+0x7e>
 8004f9c:	e8df f002 	tbb	[pc, r2]
 8004fa0:	1e110334 	.word	0x1e110334
 8004fa4:	28          	.byte	0x28
 8004fa5:	00          	.byte	0x00
		/* No action needed needed since HSI is already running and ready.  
			This osc as system clock is what got us to this point! */
		freq = 16000000;				// The internal RC osc is always 16MHz
		break;
	case 1: // Use external xtal controlled osc
		RCC_CR = RCC_CR_HSEON;			// Start hi-speed external oscillator
 8004fa6:	4a6a      	ldr	r2, [pc, #424]	; (8005150 <clockspecifysetup+0x1c8>)
 8004fa8:	f44f 3780 	mov.w	r7, #65536	; 0x10000
 8004fac:	6017      	str	r7, [r2, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 8004fae:	4a68      	ldr	r2, [pc, #416]	; (8005150 <clockspecifysetup+0x1c8>)
 8004fb0:	6817      	ldr	r7, [r2, #0]
 8004fb2:	f417 3f00 	tst.w	r7, #131072	; 0x20000
 8004fb6:	d0fa      	beq.n	8004fae <clockspecifysetup+0x26>
		usSW = 0x01;				// SWS = HSE as system clock
RCC_CR &= ~RCC_CR_HSION;	// Turn off HSI osc
 8004fb8:	6817      	ldr	r7, [r2, #0]
 8004fba:	f027 0701 	bic.w	r7, r7, #1
 8004fbe:	6017      	str	r7, [r2, #0]
 8004fc0:	e01f      	b.n	8005002 <clockspecifysetup+0x7a>
		break;
	case 2: // Use external signal input
		RCC_CR = RCC_CR_HSEBYP;			// By-pass external osc and use external signal
 8004fc2:	4a63      	ldr	r2, [pc, #396]	; (8005150 <clockspecifysetup+0x1c8>)
 8004fc4:	f44f 2780 	mov.w	r7, #262144	; 0x40000
 8004fc8:	6017      	str	r7, [r2, #0]
		RCC_CR = RCC_CR_HSEON;			// Start hi-speed external clock
 8004fca:	f44f 3780 	mov.w	r7, #65536	; 0x10000
 8004fce:	6017      	str	r7, [r2, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 8004fd0:	4a5f      	ldr	r2, [pc, #380]	; (8005150 <clockspecifysetup+0x1c8>)
 8004fd2:	6812      	ldr	r2, [r2, #0]
 8004fd4:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8004fd8:	d0fa      	beq.n	8004fd0 <clockspecifysetup+0x48>
 8004fda:	e012      	b.n	8005002 <clockspecifysetup+0x7a>
		usSW = 0x01;				// SWS = HSE as system clock
		break;
	case 3: // Use remapped external osc *xtal*
//$$$		AFIO_MAPR |= (1 << 15); 		// Bit 15 PD01_REMAP: Port D0/Port D1 mapping on OSC_IN/OSC_OUT		
		RCC_CR = RCC_CR_HSEON;			// Start oscillators hi-speed internal and external
 8004fdc:	4a5c      	ldr	r2, [pc, #368]	; (8005150 <clockspecifysetup+0x1c8>)
 8004fde:	f44f 3780 	mov.w	r7, #65536	; 0x10000
 8004fe2:	6017      	str	r7, [r2, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 8004fe4:	4a5a      	ldr	r2, [pc, #360]	; (8005150 <clockspecifysetup+0x1c8>)
 8004fe6:	6812      	ldr	r2, [r2, #0]
 8004fe8:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8004fec:	d0fa      	beq.n	8004fe4 <clockspecifysetup+0x5c>
 8004fee:	e008      	b.n	8005002 <clockspecifysetup+0x7a>
		usSW = 0x01;				// SWS = HSE as system clock
		break;
	case 4: // Use remapped external osc *signal*
//$$$		AFIO_MAPR |= (1 << 15); 		// Bit 15 PD01_REMAP: Port D0/Port D1 mapping on OSC_IN/OSC_OUT		
		RCC_CR = RCC_CR_HSEBYP;			// By-pass external osc and use external signal
 8004ff0:	4a57      	ldr	r2, [pc, #348]	; (8005150 <clockspecifysetup+0x1c8>)
 8004ff2:	f44f 2780 	mov.w	r7, #262144	; 0x40000
 8004ff6:	6017      	str	r7, [r2, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 8004ff8:	4a55      	ldr	r2, [pc, #340]	; (8005150 <clockspecifysetup+0x1c8>)
 8004ffa:	6812      	ldr	r2, [r2, #0]
 8004ffc:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8005000:	d0fa      	beq.n	8004ff8 <clockspecifysetup+0x70>
		usSW = 0x01;				// SWS = HSE as system clock
 8005002:	2201      	movs	r2, #1
 8005004:	e002      	b.n	800500c <clockspecifysetup+0x84>
 8005006:	e7fe      	b.n	8005006 <clockspecifysetup+0x7e>
	switch (clocks->hso)	// Select high speed oscillator source
	{
	case 0:	// Use internal 16 Mhz rc osc
		/* No action needed needed since HSI is already running and ready.  
			This osc as system clock is what got us to this point! */
		freq = 16000000;				// The internal RC osc is always 16MHz
 8005008:	4e52      	ldr	r6, [pc, #328]	; (8005154 <clockspecifysetup+0x1cc>)
 * @param	: chase: 0 = use HSI (internal 8 MHz RC osc), 1 = use HSE (external Xtal osc)
 * @return	: static variables are set from input paramaters passed in struct
 ******************************************************************************/
void clockspecifysetup(struct CLOCKS *clocks)
{
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
 800500a:	2200      	movs	r2, #0
This register is used to configure the PLL clock outputs according to the formulas:
●    f(VCO clock) = f(PLL clock input) × (PLLN / PLLM)
●    f(PLL general clock output) = f(VCO clock) / PLLP
●    f(USB OTG FS, SDIO, RNG clock output) = f(VCO clock) / PLLQ
*/
	if ( (plln != 0) && (pllm != 0) ) // Is PLL multiplier/divider specifed?
 800500c:	2800      	cmp	r0, #0
 800500e:	d041      	beq.n	8005094 <clockspecifysetup+0x10c>
 8005010:	2900      	cmp	r1, #0
 8005012:	d041      	beq.n	8005098 <clockspecifysetup+0x110>
	{ // Here, yes the PLL is to be used

		/* Make sure pllp is valid */
		if ((clocks->pllp >> 1) == 0 ) pllp = 2;
 8005014:	89df      	ldrh	r7, [r3, #14]
 8005016:	087f      	lsrs	r7, r7, #1
 8005018:	d003      	beq.n	8005022 <clockspecifysetup+0x9a>
		if ((clocks->pllp >> 1) >  4 ) pllp = 8;
 800501a:	2f04      	cmp	r7, #4
 800501c:	bf88      	it	hi
 800501e:	2408      	movhi	r4, #8
 8005020:	e000      	b.n	8005024 <clockspecifysetup+0x9c>
*/
	if ( (plln != 0) && (pllm != 0) ) // Is PLL multiplier/divider specifed?
	{ // Here, yes the PLL is to be used

		/* Make sure pllp is valid */
		if ((clocks->pllp >> 1) == 0 ) pllp = 2;
 8005022:	2402      	movs	r4, #2
		if ((clocks->pllp >> 1) >  4 ) pllp = 8;

		/* Make sure plln, pllm is within range */
		if (plln > 432 ) while (1==1);
 8005024:	f5b0 7fd8 	cmp.w	r0, #432	; 0x1b0
 8005028:	d900      	bls.n	800502c <clockspecifysetup+0xa4>
 800502a:	e7fe      	b.n	800502a <clockspecifysetup+0xa2>
		if (plln <   2 ) while (1==1);
 800502c:	2801      	cmp	r0, #1
 800502e:	d100      	bne.n	8005032 <clockspecifysetup+0xaa>
 8005030:	e7fe      	b.n	8005030 <clockspecifysetup+0xa8>
		if (pllm >  64 ) while (1==1);
 8005032:	2940      	cmp	r1, #64	; 0x40
 8005034:	d900      	bls.n	8005038 <clockspecifysetup+0xb0>
 8005036:	e7fe      	b.n	8005036 <clockspecifysetup+0xae>
		if (pllm <   2 ) while (1==1);	
 8005038:	2901      	cmp	r1, #1
 800503a:	d100      	bne.n	800503e <clockspecifysetup+0xb6>
 800503c:	e7fe      	b.n	800503c <clockspecifysetup+0xb4>

		/* Divider for 48 MHz peripherals */
		if ((pllq == 0) || (pllq > 15)) pllq = 15;	
 800503e:	1e6f      	subs	r7, r5, #1
 8005040:	b2bf      	uxth	r7, r7
 8005042:	2f0e      	cmp	r7, #14
 8005044:	bf88      	it	hi
 8005046:	250f      	movhi	r5, #15

		vco_freq = (freq * clocks->plln) / clocks->pllm; 	// VCO freq
 8005048:	8a1f      	ldrh	r7, [r3, #16]
 800504a:	437e      	muls	r6, r7
 800504c:	8a5f      	ldrh	r7, [r3, #18]
 800504e:	fbb6 f6f7 	udiv	r6, r6, r7

		/* Don't blast ahead if the VCO freq is out of range */
		if (vco_freq > 432000000) while(1==1); 	// SCREWED
 8005052:	4f41      	ldr	r7, [pc, #260]	; (8005158 <clockspecifysetup+0x1d0>)
 8005054:	42be      	cmp	r6, r7
 8005056:	d900      	bls.n	800505a <clockspecifysetup+0xd2>
 8005058:	e7fe      	b.n	8005058 <clockspecifysetup+0xd0>
		if (vco_freq < 64) 	  while(1==1); 	// SCREWED
 800505a:	2e3f      	cmp	r6, #63	; 0x3f
 800505c:	d800      	bhi.n	8005060 <clockspecifysetup+0xd8>
 800505e:	e7fe      	b.n	800505e <clockspecifysetup+0xd6>
		
		sysclk_freq = vco_freq / pllp;
 8005060:	4f3e      	ldr	r7, [pc, #248]	; (800515c <clockspecifysetup+0x1d4>)
 8005062:	fbb6 f6f4 	udiv	r6, r6, r4
 8005066:	603e      	str	r6, [r7, #0]

		/* Don't blast ahead if the sysclk freq is too high */
		if (sysclk_freq > 168000000)	while(1==1); // SCREWED
 8005068:	4f3d      	ldr	r7, [pc, #244]	; (8005160 <clockspecifysetup+0x1d8>)
 800506a:	42be      	cmp	r6, r7
 800506c:	d900      	bls.n	8005070 <clockspecifysetup+0xe8>
 800506e:	e7fe      	b.n	800506e <clockspecifysetup+0xe6>

		/* Setup PLL counts */
		RCC_PLLCFGR = (pllq << 24) | ( (clocks->pllsrc & 0x01) << 22) | ( pllp << 16) | ( (plln & 0x01ff) << 6) | (pllm);
 8005070:	785e      	ldrb	r6, [r3, #1]
 8005072:	05c0      	lsls	r0, r0, #23
 8005074:	0dc0      	lsrs	r0, r0, #23
 8005076:	f006 0601 	and.w	r6, r6, #1
 800507a:	0180      	lsls	r0, r0, #6
 800507c:	ea40 5086 	orr.w	r0, r0, r6, lsl #22
 8005080:	ea40 0101 	orr.w	r1, r0, r1
 8005084:	ea41 4404 	orr.w	r4, r1, r4, lsl #16
 8005088:	4836      	ldr	r0, [pc, #216]	; (8005164 <clockspecifysetup+0x1dc>)
 800508a:	ea44 6505 	orr.w	r5, r4, r5, lsl #24
 800508e:	6005      	str	r5, [r0, #0]

		sw_pll = 1;
 8005090:	2601      	movs	r6, #1
 8005092:	e002      	b.n	800509a <clockspecifysetup+0x112>
 ******************************************************************************/
void clockspecifysetup(struct CLOCKS *clocks)
{
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
	unsigned short sw_pll = 0;		// 0 = pll not used; 1 = pll used
 8005094:	4606      	mov	r6, r0
 8005096:	e000      	b.n	800509a <clockspecifysetup+0x112>
 8005098:	460e      	mov	r6, r1

		sw_pll = 1;
	}

	/* Determine number of flash wait states p 55.  2.7-3.6v ONLY */
	if (sysclk_freq >  30) ws = 1;
 800509a:	4930      	ldr	r1, [pc, #192]	; (800515c <clockspecifysetup+0x1d4>)
 800509c:	680c      	ldr	r4, [r1, #0]
 800509e:	2c1e      	cmp	r4, #30
 80050a0:	d94e      	bls.n	8005140 <clockspecifysetup+0x1b8>
	if (sysclk_freq >  60) ws = 2;
 80050a2:	2c3c      	cmp	r4, #60	; 0x3c
 80050a4:	d94e      	bls.n	8005144 <clockspecifysetup+0x1bc>
	if (sysclk_freq >  90) ws = 3;
 80050a6:	2c5a      	cmp	r4, #90	; 0x5a
 80050a8:	d94e      	bls.n	8005148 <clockspecifysetup+0x1c0>
	if (sysclk_freq > 120) ws = 4;
 80050aa:	2c78      	cmp	r4, #120	; 0x78
 80050ac:	d94e      	bls.n	800514c <clockspecifysetup+0x1c4>
 80050ae:	2c96      	cmp	r4, #150	; 0x96
 80050b0:	bf8c      	ite	hi
 80050b2:	2105      	movhi	r1, #5
 80050b4:	2104      	movls	r1, #4
	if (sysclk_freq > 150) ws = 5;

	/* Set wait states in register */
	FLASH_ACR |= ws;
 80050b6:	482c      	ldr	r0, [pc, #176]	; (8005168 <clockspecifysetup+0x1e0>)
 80050b8:	6805      	ldr	r5, [r0, #0]
 80050ba:	ea41 0505 	orr.w	r5, r1, r5
 80050be:	6005      	str	r5, [r0, #0]

	/* Wait for register to become effective p 55 */
	while ((FLASH_ACR & 0x07) != ws);
 80050c0:	4829      	ldr	r0, [pc, #164]	; (8005168 <clockspecifysetup+0x1e0>)
 80050c2:	6800      	ldr	r0, [r0, #0]
 80050c4:	f000 0007 	and.w	r0, r0, #7
 80050c8:	4288      	cmp	r0, r1
 80050ca:	d1f9      	bne.n	80050c0 <clockspecifysetup+0x138>


	/* Clock configuraton register (Ref manual, page 97)	*/
	// Setup up bus dividers
	RCC_CFGR = (clocks->apb2  << 13)  |	/* (3b) PPRE2: ABP2 prescaler bit code	(4-7)		*/ 
 80050cc:	78dd      	ldrb	r5, [r3, #3]
		   (clocks->apb1  << 10)  |	/* (3b) PPRE1: APB1 prescaler bit code	(4-7)		*/ 
 80050ce:	7898      	ldrb	r0, [r3, #2]
		   (clocks->ahb   <<  4)  ;	/* (4b) HPRE:  AHB  prescaler bit code	(8-15)		*/
 80050d0:	791b      	ldrb	r3, [r3, #4]
	while ((FLASH_ACR & 0x07) != ws);


	/* Clock configuraton register (Ref manual, page 97)	*/
	// Setup up bus dividers
	RCC_CFGR = (clocks->apb2  << 13)  |	/* (3b) PPRE2: ABP2 prescaler bit code	(4-7)		*/ 
 80050d2:	4926      	ldr	r1, [pc, #152]	; (800516c <clockspecifysetup+0x1e4>)
 80050d4:	036f      	lsls	r7, r5, #13
 80050d6:	ea47 2780 	orr.w	r7, r7, r0, lsl #10
		   (clocks->apb1  << 10)  |	/* (3b) PPRE1: APB1 prescaler bit code	(4-7)		*/ 
 80050da:	ea47 1703 	orr.w	r7, r7, r3, lsl #4
		   (clocks->ahb   <<  4)  ;	/* (4b) HPRE:  AHB  prescaler bit code	(8-15)		*/


	if (sw_pll == 1)	// Are we using the PLL?
 80050de:	2e01      	cmp	r6, #1
	while ((FLASH_ACR & 0x07) != ws);


	/* Clock configuraton register (Ref manual, page 97)	*/
	// Setup up bus dividers
	RCC_CFGR = (clocks->apb2  << 13)  |	/* (3b) PPRE2: ABP2 prescaler bit code	(4-7)		*/ 
 80050e0:	600f      	str	r7, [r1, #0]
		   (clocks->apb1  << 10)  |	/* (3b) PPRE1: APB1 prescaler bit code	(4-7)		*/ 
		   (clocks->ahb   <<  4)  ;	/* (4b) HPRE:  AHB  prescaler bit code	(8-15)		*/


	if (sw_pll == 1)	// Are we using the PLL?
 80050e2:	d10a      	bne.n	80050fa <clockspecifysetup+0x172>
	{ // Here yes, start PLL
		// Enable PLL
		RCC_CR |= (1<<24);			// PLLON:  Turn PLL on
 80050e4:	4a1a      	ldr	r2, [pc, #104]	; (8005150 <clockspecifysetup+0x1c8>)
 80050e6:	6811      	ldr	r1, [r2, #0]
 80050e8:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 80050ec:	6011      	str	r1, [r2, #0]
		while ((RCC_CR & (1<<25) ) == 0);	// PLLRDY: Wait for PLL to become ready
 80050ee:	4a18      	ldr	r2, [pc, #96]	; (8005150 <clockspecifysetup+0x1c8>)
 80050f0:	6812      	ldr	r2, [r2, #0]
 80050f2:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 80050f6:	d0fa      	beq.n	80050ee <clockspecifysetup+0x166>

		// Select PLL as system clock source 
		usSW = 0x02;				// Change the usSW code for PLL
 80050f8:	2202      	movs	r2, #2
	}

	

	/* Switch the system clock source to the one specified */
	RCC_CFGR = (RCC_CFGR & ~0x03) | usSW;		// Set system clock source (it has been running on HSI (internal 8 MHz rc clock)
 80050fa:	491c      	ldr	r1, [pc, #112]	; (800516c <clockspecifysetup+0x1e4>)
 80050fc:	680e      	ldr	r6, [r1, #0]
 80050fe:	f026 0603 	bic.w	r6, r6, #3
 8005102:	ea42 0606 	orr.w	r6, r2, r6
 8005106:	600e      	str	r6, [r1, #0]
	while ( (RCC_CFGR & 0x0c) != (unsigned short)(usSW << 2) );	// Wait until system is running on the clock source
 8005108:	0092      	lsls	r2, r2, #2
 800510a:	4918      	ldr	r1, [pc, #96]	; (800516c <clockspecifysetup+0x1e4>)
 800510c:	6809      	ldr	r1, [r1, #0]
 800510e:	f001 010c 	and.w	r1, r1, #12
 8005112:	4291      	cmp	r1, r2
 8005114:	d1f9      	bne.n	800510a <clockspecifysetup+0x182>


	/* Compute static variables with bus freqs that other routines will use to for their setup */
	hclk_freq   = sysclk_freq/ahbtbl[(clocks->ahb)];	// AHB bus freq = sysclck/ ahb bus divider
 8005116:	4a16      	ldr	r2, [pc, #88]	; (8005170 <clockspecifysetup+0x1e8>)
 8005118:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800511c:	fbb4 f4f3 	udiv	r4, r4, r3
 8005120:	4b14      	ldr	r3, [pc, #80]	; (8005174 <clockspecifysetup+0x1ec>)
 8005122:	601c      	str	r4, [r3, #0]
	pclk1_freq  =   hclk_freq/convert(clocks->apb1);	// APB1 driven from AHB (must not exceed 36 MHz)
 8005124:	f7ff ff28 	bl	8004f78 <convert>
 8005128:	4b13      	ldr	r3, [pc, #76]	; (8005178 <clockspecifysetup+0x1f0>)
 800512a:	fbb4 f0f0 	udiv	r0, r4, r0
 800512e:	6018      	str	r0, [r3, #0]
	pclk2_freq  =   hclk_freq/convert(clocks->apb2);	// APB2 driven from AHB
 8005130:	4628      	mov	r0, r5
 8005132:	f7ff ff21 	bl	8004f78 <convert>
 8005136:	4b11      	ldr	r3, [pc, #68]	; (800517c <clockspecifysetup+0x1f4>)
 8005138:	fbb4 f0f0 	udiv	r0, r4, r0
 800513c:	6018      	str	r0, [r3, #0]
 	return;                                           
}
 800513e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 * @return	: static variables are set from input paramaters passed in struct
 ******************************************************************************/
void clockspecifysetup(struct CLOCKS *clocks)
{
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
 8005140:	2100      	movs	r1, #0
 8005142:	e7b8      	b.n	80050b6 <clockspecifysetup+0x12e>

		sw_pll = 1;
	}

	/* Determine number of flash wait states p 55.  2.7-3.6v ONLY */
	if (sysclk_freq >  30) ws = 1;
 8005144:	2101      	movs	r1, #1
 8005146:	e7b6      	b.n	80050b6 <clockspecifysetup+0x12e>
	if (sysclk_freq >  60) ws = 2;
 8005148:	2102      	movs	r1, #2
 800514a:	e7b4      	b.n	80050b6 <clockspecifysetup+0x12e>
	if (sysclk_freq >  90) ws = 3;
 800514c:	2103      	movs	r1, #3
 800514e:	e7b2      	b.n	80050b6 <clockspecifysetup+0x12e>
 8005150:	40023800 	.word	0x40023800
 8005154:	00f42400 	.word	0x00f42400
 8005158:	19bfcc00 	.word	0x19bfcc00
 800515c:	200016cc 	.word	0x200016cc
 8005160:	0a037a00 	.word	0x0a037a00
 8005164:	40023804 	.word	0x40023804
 8005168:	40023c00 	.word	0x40023c00
 800516c:	40023808 	.word	0x40023808
 8005170:	0800cef2 	.word	0x0800cef2
 8005174:	200016c0 	.word	0x200016c0
 8005178:	200016c4 	.word	0x200016c4
 800517c:	200016c8 	.word	0x200016c8

08005180 <clockI2Ssetup>:
int clockI2Ssetup(unsigned int R, unsigned int N)
{
	int i = 10000;	// Anti-hang loop counter
	
	/* Check input value ranges */
	if (R <   2) return 1;
 8005180:	2801      	cmp	r0, #1
 * @param	: R = valid range: 2-7 (3 bits)
 * @param	: N = valid range: 192-432 (9 bits). 
 * @return	: 0 = OK; 1 = failed
 ******************************************************************************/
int clockI2Ssetup(unsigned int R, unsigned int N)
{
 8005182:	b530      	push	{r4, r5, lr}
	int i = 10000;	// Anti-hang loop counter
	
	/* Check input value ranges */
	if (R <   2) return 1;
 8005184:	d91f      	bls.n	80051c6 <clockI2Ssetup+0x46>
	if (R >   7) return 1;
 8005186:	2807      	cmp	r0, #7
 8005188:	d81d      	bhi.n	80051c6 <clockI2Ssetup+0x46>
	if (N < 192) return 1;
 800518a:	29bf      	cmp	r1, #191	; 0xbf
 800518c:	d91b      	bls.n	80051c6 <clockI2Ssetup+0x46>
	if (N > 432) return 1;
 800518e:	f5b1 7fd8 	cmp.w	r1, #432	; 0x1b0
 8005192:	d81a      	bhi.n	80051ca <clockI2Ssetup+0x4a>

	/* Turn PLL off and reset counters */
	RCC_CR &= ~(1<<26);			// Disable PLL2I2S if previously enabled (p 92)
 8005194:	4b0e      	ldr	r3, [pc, #56]	; (80051d0 <clockI2Ssetup+0x50>)
	while ( (RCC_CR & (1<<27)) == 1 );	// Be sure it is not ready (p 93)
	RCC_PLLI2SCFGR &= ~(0x70007fc0) ;	// Reset current R & N setttings (p 132)
 8005196:	4c0f      	ldr	r4, [pc, #60]	; (80051d4 <clockI2Ssetup+0x54>)
	if (R >   7) return 1;
	if (N < 192) return 1;
	if (N > 432) return 1;

	/* Turn PLL off and reset counters */
	RCC_CR &= ~(1<<26);			// Disable PLL2I2S if previously enabled (p 92)
 8005198:	681a      	ldr	r2, [r3, #0]
 800519a:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 800519e:	601a      	str	r2, [r3, #0]
	while ( (RCC_CR & (1<<27)) == 1 );	// Be sure it is not ready (p 93)
 80051a0:	681a      	ldr	r2, [r3, #0]
	RCC_PLLI2SCFGR &= ~(0x70007fc0) ;	// Reset current R & N setttings (p 132)
 80051a2:	4a0d      	ldr	r2, [pc, #52]	; (80051d8 <clockI2Ssetup+0x58>)
 80051a4:	6815      	ldr	r5, [r2, #0]
 80051a6:	ea05 0404 	and.w	r4, r5, r4
 80051aa:	6014      	str	r4, [r2, #0]

	/* Set up new PLL counters (p 132) */
	RCC_PLLI2SCFGR |= (R << 28) | (N << 6) ;
 80051ac:	6814      	ldr	r4, [r2, #0]
 80051ae:	ea44 7000 	orr.w	r0, r4, r0, lsl #28
 80051b2:	ea40 1181 	orr.w	r1, r0, r1, lsl #6
 80051b6:	6011      	str	r1, [r2, #0]

	/* Enable PLL */
	RCC_CR |= (1<<26);	// Enable bit
 80051b8:	681a      	ldr	r2, [r3, #0]
 80051ba:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 80051be:	601a      	str	r2, [r3, #0]

	/* Wait for it to come ready, but don't allow to hang forever. (p 93) */
	while ( ((RCC_CR & (1<<27)) == 1) && (--i > 0) );
 80051c0:	681b      	ldr	r3, [r3, #0]
	if ( i < 0 ) return 1;		// Timed out

	return 0;
 80051c2:	2000      	movs	r0, #0
 80051c4:	bd30      	pop	{r4, r5, pc}
	int i = 10000;	// Anti-hang loop counter
	
	/* Check input value ranges */
	if (R <   2) return 1;
	if (R >   7) return 1;
	if (N < 192) return 1;
 80051c6:	2001      	movs	r0, #1
 80051c8:	bd30      	pop	{r4, r5, pc}
	if (N > 432) return 1;
 80051ca:	2001      	movs	r0, #1
	/* Wait for it to come ready, but don't allow to hang forever. (p 93) */
	while ( ((RCC_CR & (1<<27)) == 1) && (--i > 0) );
	if ( i < 0 ) return 1;		// Timed out

	return 0;
}
 80051cc:	bd30      	pop	{r4, r5, pc}
 80051ce:	bf00      	nop
 80051d0:	40023800 	.word	0x40023800
 80051d4:	8fff803f 	.word	0x8fff803f
 80051d8:	40023884 	.word	0x40023884

080051dc <nvic_dma_stream_vector_add>:
 * @param	: stream_number = 0-7 for stream selected
 * @return	: 0 = OK; -1 = irq number out of range; -2 or less = stream already in use
******************************************************************************/
int nvic_dma_stream_vector_add(void(*p)(u32*), u32* q, u32 dma_irq_number, u32 stream_number)
{
	if (stream_number > 7) return -1;	// JIC a bozo sent a bad number
 80051dc:	2b07      	cmp	r3, #7
 * @param	: dma_irq_number = nvic irq number
 * @param	: stream_number = 0-7 for stream selected
 * @return	: 0 = OK; -1 = irq number out of range; -2 or less = stream already in use
******************************************************************************/
int nvic_dma_stream_vector_add(void(*p)(u32*), u32* q, u32 dma_irq_number, u32 stream_number)
{
 80051de:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (stream_number > 7) return -1;	// JIC a bozo sent a bad number
 80051e0:	d863      	bhi.n	80052aa <nvic_dma_stream_vector_add+0xce>

	/* Convert DMA irq number (vector position) to an index 0 - 7 */
	// --------- DMA1 -----------
	if ((dma_irq_number >= DMASTRM10) && (dma_irq_number <= DMASTRM16))
 80051e2:	f1a2 040b 	sub.w	r4, r2, #11
 80051e6:	2c06      	cmp	r4, #6
 80051e8:	d815      	bhi.n	8005216 <nvic_dma_stream_vector_add+0x3a>
	{
		if ((dma1_stream_use & (1 << stream_number)) != 0) return -2; 	// Already setup
 80051ea:	4a39      	ldr	r2, [pc, #228]	; (80052d0 <nvic_dma_stream_vector_add+0xf4>)
 80051ec:	7815      	ldrb	r5, [r2, #0]
 80051ee:	fa55 f603 	asrs.w	r6, r5, r3
 80051f2:	f016 0601 	ands.w	r6, r6, #1
 80051f6:	d15b      	bne.n	80052b0 <nvic_dma_stream_vector_add+0xd4>
		dma1_stream_use |=     (1 << stream_number);			// Set bit to show used
 80051f8:	2701      	movs	r7, #1
 80051fa:	fa17 f303 	lsls.w	r3, r7, r3
 80051fe:	ea43 0505 	orr.w	r5, r3, r5
 8005202:	7015      	strb	r5, [r2, #0]
		dma1[(dma_irq_number - DMASTRM10)].jmp  = p; // Pointer to IRQ handler
		dma1[(dma_irq_number - DMASTRM10)].base = q; // Pointer to control block
		RCC_AHB1ENR |= (1<<21); // Enable DMA1 clocking
 8005204:	4b33      	ldr	r3, [pc, #204]	; (80052d4 <nvic_dma_stream_vector_add+0xf8>)
	// --------- DMA1 -----------
	if ((dma_irq_number >= DMASTRM10) && (dma_irq_number <= DMASTRM16))
	{
		if ((dma1_stream_use & (1 << stream_number)) != 0) return -2; 	// Already setup
		dma1_stream_use |=     (1 << stream_number);			// Set bit to show used
		dma1[(dma_irq_number - DMASTRM10)].jmp  = p; // Pointer to IRQ handler
 8005206:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 800520a:	6050      	str	r0, [r2, #4]
		dma1[(dma_irq_number - DMASTRM10)].base = q; // Pointer to control block
 800520c:	6091      	str	r1, [r2, #8]
		RCC_AHB1ENR |= (1<<21); // Enable DMA1 clocking
 800520e:	681a      	ldr	r2, [r3, #0]
 8005210:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8005214:	e046      	b.n	80052a4 <nvic_dma_stream_vector_add+0xc8>
		return 0;
	}
	if (dma_irq_number == DMASTRM17)
 8005216:	2a2f      	cmp	r2, #47	; 0x2f
 8005218:	d110      	bne.n	800523c <nvic_dma_stream_vector_add+0x60>
	{
		if ((dma1_stream_use & 0x80) != 0) return -3; 	// Already setup
 800521a:	4b2d      	ldr	r3, [pc, #180]	; (80052d0 <nvic_dma_stream_vector_add+0xf4>)
 800521c:	781a      	ldrb	r2, [r3, #0]
 800521e:	f012 0f80 	tst.w	r2, #128	; 0x80
 8005222:	d148      	bne.n	80052b6 <nvic_dma_stream_vector_add+0xda>
		dma1_stream_use |=     0x80;			// Set bit to show used
 8005224:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8005228:	701a      	strb	r2, [r3, #0]
		dma1[7].jmp  = p; 
 800522a:	63d8      	str	r0, [r3, #60]	; 0x3c
		dma1[7].base = q;
 800522c:	6419      	str	r1, [r3, #64]	; 0x40
		RCC_AHB1ENR |= (1<<21); // Enable DMA1 clocking
 800522e:	4b29      	ldr	r3, [pc, #164]	; (80052d4 <nvic_dma_stream_vector_add+0xf8>)
 8005230:	681a      	ldr	r2, [r3, #0]
 8005232:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8005236:	601a      	str	r2, [r3, #0]
		return 0;
 8005238:	2000      	movs	r0, #0
 800523a:	bdf0      	pop	{r4, r5, r6, r7, pc}

	// --------- DMA2 -----------
	}
	if ( (dma_irq_number >= DMASTRM20) && (dma_irq_number <= DMASTRM24 ))
 800523c:	f1a2 0438 	sub.w	r4, r2, #56	; 0x38
 8005240:	2c04      	cmp	r4, #4
 8005242:	d813      	bhi.n	800526c <nvic_dma_stream_vector_add+0x90>
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -4; 	// Already setup
 8005244:	4a22      	ldr	r2, [pc, #136]	; (80052d0 <nvic_dma_stream_vector_add+0xf4>)
 8005246:	f892 5044 	ldrb.w	r5, [r2, #68]	; 0x44
 800524a:	fa55 f603 	asrs.w	r6, r5, r3
 800524e:	f016 0601 	ands.w	r6, r6, #1
 8005252:	d133      	bne.n	80052bc <nvic_dma_stream_vector_add+0xe0>
		dma2_stream_use |=     (1 << stream_number);			// Set bit to show used
 8005254:	2701      	movs	r7, #1
 8005256:	fa17 f303 	lsls.w	r3, r7, r3
 800525a:	ea43 0505 	orr.w	r5, r3, r5
 800525e:	f882 5044 	strb.w	r5, [r2, #68]	; 0x44
		dma2[dma_irq_number - DMASTRM20].jmp  = p; 
 8005262:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 8005266:	6490      	str	r0, [r2, #72]	; 0x48
		dma2[dma_irq_number - DMASTRM20].base = q;
 8005268:	64d1      	str	r1, [r2, #76]	; 0x4c
 800526a:	e017      	b.n	800529c <nvic_dma_stream_vector_add+0xc0>
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
		return 0;
	}
	if ( (dma_irq_number >= DMASTRM25) && (dma_irq_number <= DMASTRM27 ))
 800526c:	f1a2 0444 	sub.w	r4, r2, #68	; 0x44
 8005270:	2c02      	cmp	r4, #2
 8005272:	d826      	bhi.n	80052c2 <nvic_dma_stream_vector_add+0xe6>
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -5; 	// Already setup
 8005274:	4c16      	ldr	r4, [pc, #88]	; (80052d0 <nvic_dma_stream_vector_add+0xf4>)
 8005276:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
 800527a:	fa55 f603 	asrs.w	r6, r5, r3
 800527e:	f016 0601 	ands.w	r6, r6, #1
 8005282:	d121      	bne.n	80052c8 <nvic_dma_stream_vector_add+0xec>
		dma2_stream_use |=     (1 << stream_number);			// Set bit to show used
 8005284:	2701      	movs	r7, #1
 8005286:	fa17 f303 	lsls.w	r3, r7, r3
 800528a:	ea43 0505 	orr.w	r5, r3, r5
		dma2[dma_irq_number - DMASTRM25 + 5].jmp  = p; 
 800528e:	3a3f      	subs	r2, #63	; 0x3f
		return 0;
	}
	if ( (dma_irq_number >= DMASTRM25) && (dma_irq_number <= DMASTRM27 ))
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -5; 	// Already setup
		dma2_stream_use |=     (1 << stream_number);			// Set bit to show used
 8005290:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
		dma2[dma_irq_number - DMASTRM25 + 5].jmp  = p; 
 8005294:	eb04 04c2 	add.w	r4, r4, r2, lsl #3
 8005298:	64a0      	str	r0, [r4, #72]	; 0x48
		dma2[dma_irq_number - DMASTRM25 + 5].base = q; 
 800529a:	64e1      	str	r1, [r4, #76]	; 0x4c
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
 800529c:	4b0d      	ldr	r3, [pc, #52]	; (80052d4 <nvic_dma_stream_vector_add+0xf8>)
 800529e:	681a      	ldr	r2, [r3, #0]
 80052a0:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 80052a4:	601a      	str	r2, [r3, #0]
		return 0;
 80052a6:	4630      	mov	r0, r6
 80052a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 * @param	: stream_number = 0-7 for stream selected
 * @return	: 0 = OK; -1 = irq number out of range; -2 or less = stream already in use
******************************************************************************/
int nvic_dma_stream_vector_add(void(*p)(u32*), u32* q, u32 dma_irq_number, u32 stream_number)
{
	if (stream_number > 7) return -1;	// JIC a bozo sent a bad number
 80052aa:	f04f 30ff 	mov.w	r0, #4294967295
 80052ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

	/* Convert DMA irq number (vector position) to an index 0 - 7 */
	// --------- DMA1 -----------
	if ((dma_irq_number >= DMASTRM10) && (dma_irq_number <= DMASTRM16))
	{
		if ((dma1_stream_use & (1 << stream_number)) != 0) return -2; 	// Already setup
 80052b0:	f06f 0001 	mvn.w	r0, #1
 80052b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		RCC_AHB1ENR |= (1<<21); // Enable DMA1 clocking
		return 0;
	}
	if (dma_irq_number == DMASTRM17)
	{
		if ((dma1_stream_use & 0x80) != 0) return -3; 	// Already setup
 80052b6:	f06f 0002 	mvn.w	r0, #2
 80052ba:	bdf0      	pop	{r4, r5, r6, r7, pc}

	// --------- DMA2 -----------
	}
	if ( (dma_irq_number >= DMASTRM20) && (dma_irq_number <= DMASTRM24 ))
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -4; 	// Already setup
 80052bc:	f06f 0003 	mvn.w	r0, #3
 80052c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		dma2[dma_irq_number - DMASTRM25 + 5].jmp  = p; 
		dma2[dma_irq_number - DMASTRM25 + 5].base = q; 
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
		return 0;
	}
	return -7;
 80052c2:	f06f 0006 	mvn.w	r0, #6
 80052c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
		return 0;
	}
	if ( (dma_irq_number >= DMASTRM25) && (dma_irq_number <= DMASTRM27 ))
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -5; 	// Already setup
 80052c8:	f06f 0004 	mvn.w	r0, #4
		dma2[dma_irq_number - DMASTRM25 + 5].base = q; 
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
		return 0;
	}
	return -7;
}
 80052cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80052ce:	bf00      	nop
 80052d0:	200016d0 	.word	0x200016d0
 80052d4:	40023830 	.word	0x40023830

080052d8 <DMA1_Stream0_IRQHandler>:
/* IRQ vectors for DMA streams points to the following.
   The following dispatches them to the routines of interest, along with one 32b pointer. */
//                                (*(  (void (**)(void))APPJUMP)   )(            );


void DMA1_Stream0_IRQHandler (void){(*dma1[0].jmp)(dma1[0].base); return;} 
 80052d8:	4a02      	ldr	r2, [pc, #8]	; (80052e4 <DMA1_Stream0_IRQHandler+0xc>)
 80052da:	b508      	push	{r3, lr}
 80052dc:	6890      	ldr	r0, [r2, #8]
 80052de:	6853      	ldr	r3, [r2, #4]
 80052e0:	4798      	blx	r3
 80052e2:	bd08      	pop	{r3, pc}
 80052e4:	200016d0 	.word	0x200016d0

080052e8 <DMA1_Stream1_IRQHandler>:
void DMA1_Stream1_IRQHandler (void){(*dma1[1].jmp)(dma1[1].base); return;}	
 80052e8:	4a02      	ldr	r2, [pc, #8]	; (80052f4 <DMA1_Stream1_IRQHandler+0xc>)
 80052ea:	b508      	push	{r3, lr}
 80052ec:	6910      	ldr	r0, [r2, #16]
 80052ee:	68d3      	ldr	r3, [r2, #12]
 80052f0:	4798      	blx	r3
 80052f2:	bd08      	pop	{r3, pc}
 80052f4:	200016d0 	.word	0x200016d0

080052f8 <DMA1_Stream2_IRQHandler>:
void DMA1_Stream2_IRQHandler (void){(*dma1[2].jmp)(dma1[2].base); return;}	
 80052f8:	4a02      	ldr	r2, [pc, #8]	; (8005304 <DMA1_Stream2_IRQHandler+0xc>)
 80052fa:	b508      	push	{r3, lr}
 80052fc:	6990      	ldr	r0, [r2, #24]
 80052fe:	6953      	ldr	r3, [r2, #20]
 8005300:	4798      	blx	r3
 8005302:	bd08      	pop	{r3, pc}
 8005304:	200016d0 	.word	0x200016d0

08005308 <DMA1_Stream3_IRQHandler>:
void DMA1_Stream3_IRQHandler (void){(*dma1[3].jmp)(dma1[3].base); return;}	
 8005308:	4a02      	ldr	r2, [pc, #8]	; (8005314 <DMA1_Stream3_IRQHandler+0xc>)
 800530a:	b508      	push	{r3, lr}
 800530c:	6a10      	ldr	r0, [r2, #32]
 800530e:	69d3      	ldr	r3, [r2, #28]
 8005310:	4798      	blx	r3
 8005312:	bd08      	pop	{r3, pc}
 8005314:	200016d0 	.word	0x200016d0

08005318 <DMA1_Stream4_IRQHandler>:
void DMA1_Stream4_IRQHandler (void){(*dma1[4].jmp)(dma1[4].base); return;}	
 8005318:	4a02      	ldr	r2, [pc, #8]	; (8005324 <DMA1_Stream4_IRQHandler+0xc>)
 800531a:	b508      	push	{r3, lr}
 800531c:	6a90      	ldr	r0, [r2, #40]	; 0x28
 800531e:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8005320:	4798      	blx	r3
 8005322:	bd08      	pop	{r3, pc}
 8005324:	200016d0 	.word	0x200016d0

08005328 <DMA1_Stream5_IRQHandler>:
void DMA1_Stream5_IRQHandler (void){(*dma1[5].jmp)(dma1[5].base); return;}	
 8005328:	4a02      	ldr	r2, [pc, #8]	; (8005334 <DMA1_Stream5_IRQHandler+0xc>)
 800532a:	b508      	push	{r3, lr}
 800532c:	6b10      	ldr	r0, [r2, #48]	; 0x30
 800532e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8005330:	4798      	blx	r3
 8005332:	bd08      	pop	{r3, pc}
 8005334:	200016d0 	.word	0x200016d0

08005338 <DMA1_Stream6_IRQHandler>:
void DMA1_Stream6_IRQHandler (void){(*dma1[6].jmp)(dma1[6].base); return;}	
 8005338:	4a02      	ldr	r2, [pc, #8]	; (8005344 <DMA1_Stream6_IRQHandler+0xc>)
 800533a:	b508      	push	{r3, lr}
 800533c:	6b90      	ldr	r0, [r2, #56]	; 0x38
 800533e:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8005340:	4798      	blx	r3
 8005342:	bd08      	pop	{r3, pc}
 8005344:	200016d0 	.word	0x200016d0

08005348 <DMA1_Stream7_IRQHandler>:
void DMA1_Stream7_IRQHandler (void){(*dma1[7].jmp)(dma1[7].base); return;}	
 8005348:	4a02      	ldr	r2, [pc, #8]	; (8005354 <DMA1_Stream7_IRQHandler+0xc>)
 800534a:	b508      	push	{r3, lr}
 800534c:	6c10      	ldr	r0, [r2, #64]	; 0x40
 800534e:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8005350:	4798      	blx	r3
 8005352:	bd08      	pop	{r3, pc}
 8005354:	200016d0 	.word	0x200016d0

08005358 <DMA2_Stream0_IRQHandler>:

void DMA2_Stream0_IRQHandler (void){(*dma2[0].jmp)(dma2[0].base); return;}	
 8005358:	4a02      	ldr	r2, [pc, #8]	; (8005364 <DMA2_Stream0_IRQHandler+0xc>)
 800535a:	b508      	push	{r3, lr}
 800535c:	6cd0      	ldr	r0, [r2, #76]	; 0x4c
 800535e:	6c93      	ldr	r3, [r2, #72]	; 0x48
 8005360:	4798      	blx	r3
 8005362:	bd08      	pop	{r3, pc}
 8005364:	200016d0 	.word	0x200016d0

08005368 <DMA2_Stream1_IRQHandler>:
void DMA2_Stream1_IRQHandler (void){(*dma2[1].jmp)(dma2[1].base); return;}	
 8005368:	4a02      	ldr	r2, [pc, #8]	; (8005374 <DMA2_Stream1_IRQHandler+0xc>)
 800536a:	b508      	push	{r3, lr}
 800536c:	6d50      	ldr	r0, [r2, #84]	; 0x54
 800536e:	6d13      	ldr	r3, [r2, #80]	; 0x50
 8005370:	4798      	blx	r3
 8005372:	bd08      	pop	{r3, pc}
 8005374:	200016d0 	.word	0x200016d0

08005378 <DMA2_Stream2_IRQHandler>:
void DMA2_Stream2_IRQHandler (void){(*dma2[2].jmp)(dma2[2].base); return;}	
 8005378:	4a02      	ldr	r2, [pc, #8]	; (8005384 <DMA2_Stream2_IRQHandler+0xc>)
 800537a:	b508      	push	{r3, lr}
 800537c:	6dd0      	ldr	r0, [r2, #92]	; 0x5c
 800537e:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8005380:	4798      	blx	r3
 8005382:	bd08      	pop	{r3, pc}
 8005384:	200016d0 	.word	0x200016d0

08005388 <DMA2_Stream3_IRQHandler>:
void DMA2_Stream3_IRQHandler (void){(*dma2[3].jmp)(dma2[3].base); return;}	
 8005388:	4a02      	ldr	r2, [pc, #8]	; (8005394 <DMA2_Stream3_IRQHandler+0xc>)
 800538a:	b508      	push	{r3, lr}
 800538c:	6e50      	ldr	r0, [r2, #100]	; 0x64
 800538e:	6e13      	ldr	r3, [r2, #96]	; 0x60
 8005390:	4798      	blx	r3
 8005392:	bd08      	pop	{r3, pc}
 8005394:	200016d0 	.word	0x200016d0

08005398 <DMA2_Stream4_IRQHandler>:
void DMA2_Stream4_IRQHandler (void){(*dma2[4].jmp)(dma2[4].base); return;}	
 8005398:	4a02      	ldr	r2, [pc, #8]	; (80053a4 <DMA2_Stream4_IRQHandler+0xc>)
 800539a:	b508      	push	{r3, lr}
 800539c:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 800539e:	6e93      	ldr	r3, [r2, #104]	; 0x68
 80053a0:	4798      	blx	r3
 80053a2:	bd08      	pop	{r3, pc}
 80053a4:	200016d0 	.word	0x200016d0

080053a8 <DMA2_Stream5_IRQHandler>:

void DMA2_Stream5_IRQHandler (void){(*dma2[5].jmp)(dma2[5].base); return;}
 80053a8:	4a02      	ldr	r2, [pc, #8]	; (80053b4 <DMA2_Stream5_IRQHandler+0xc>)
 80053aa:	b508      	push	{r3, lr}
 80053ac:	6f50      	ldr	r0, [r2, #116]	; 0x74
 80053ae:	6f13      	ldr	r3, [r2, #112]	; 0x70
 80053b0:	4798      	blx	r3
 80053b2:	bd08      	pop	{r3, pc}
 80053b4:	200016d0 	.word	0x200016d0

080053b8 <DMA2_Stream6_IRQHandler>:
void DMA2_Stream6_IRQHandler (void){(*dma2[6].jmp)(dma2[6].base); return;}	
 80053b8:	4a02      	ldr	r2, [pc, #8]	; (80053c4 <DMA2_Stream6_IRQHandler+0xc>)
 80053ba:	b508      	push	{r3, lr}
 80053bc:	6fd0      	ldr	r0, [r2, #124]	; 0x7c
 80053be:	6f93      	ldr	r3, [r2, #120]	; 0x78
 80053c0:	4798      	blx	r3
 80053c2:	bd08      	pop	{r3, pc}
 80053c4:	200016d0 	.word	0x200016d0

080053c8 <DMA2_Stream7_IRQHandler>:
void DMA2_Stream7_IRQHandler (void){(*dma2[7].jmp)(dma2[7].base); return;}	
 80053c8:	4a03      	ldr	r2, [pc, #12]	; (80053d8 <DMA2_Stream7_IRQHandler+0x10>)
 80053ca:	b508      	push	{r3, lr}
 80053cc:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84
 80053d0:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 80053d4:	4798      	blx	r3
 80053d6:	bd08      	pop	{r3, pc}
 80053d8:	200016d0 	.word	0x200016d0

080053dc <rxbuff_adv>:
 * @param	: pctl = pointer to control block
 * @param	: p = pointer to be advanced
 * @return	: new pointer 'p'
*******************************************************************************/
static u8* rxbuff_adv (struct CB_UART* pctl, u8* p)
{
 80053dc:	4603      	mov	r3, r0
	p += 1; if (p >= pctl->rxbuff_end) p = pctl->rxbuff_base;
 80053de:	1c48      	adds	r0, r1, #1
 80053e0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80053e2:	4290      	cmp	r0, r2
 80053e4:	bf28      	it	cs
 80053e6:	6ad8      	ldrcs	r0, [r3, #44]	; 0x2c
	return p;
}
 80053e8:	4770      	bx	lr

080053ea <txbuff_adv>:
 * @param	: pctl = pointer to control block
 * @param	: p = pointer to be advanced
 * @return	: new pointer 'p'
*******************************************************************************/
static u8* txbuff_adv (struct CB_UART* pctl, u8* p)
{
 80053ea:	4603      	mov	r3, r0
	p += 1; if (p >= pctl->txbuff_end) p = pctl->txbuff_base;
 80053ec:	1c48      	adds	r0, r1, #1
 80053ee:	699a      	ldr	r2, [r3, #24]
 80053f0:	4290      	cmp	r0, r2
 80053f2:	bf28      	it	cs
 80053f4:	6958      	ldrcs	r0, [r3, #20]
	return p;
}
 80053f6:	4770      	bx	lr

080053f8 <common_dma>:
   routine. */
	int tmp;
	u8* ptmp;

	/* Are there bytes buffered? (Certainly yes if entered from mainline.) */  
	tmp = (pctl->txbuff_in - pctl->txbuff_out);
 80053f8:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80053fa:	6a02      	ldr	r2, [r0, #32]
 80053fc:	1ad2      	subs	r2, r2, r3
	if (tmp == 0) return;	
 80053fe:	2a00      	cmp	r2, #0
 * @brief	: Set up a disabled (idle) DMA to send if there are byte buffered
 * @param	: pctl = pointer to uart control block
 *####################################################################################### */

static void common_dma(struct CB_UART* pctl)
{
 8005400:	b530      	push	{r4, r5, lr}
	int tmp;
	u8* ptmp;

	/* Are there bytes buffered? (Certainly yes if entered from mainline.) */  
	tmp = (pctl->txbuff_in - pctl->txbuff_out);
	if (tmp == 0) return;	
 8005402:	d022      	beq.n	800544a <common_dma+0x52>
 8005404:	68c1      	ldr	r1, [r0, #12]

	if (tmp < 0)	// Wrap around check.
 8005406:	da07      	bge.n	8005418 <common_dma+0x20>
	{ // Here, there is wrap-around, so send what remains in (non-circular) buffer.
	  // (Upon the next DMA interrupt what remains after the wrap-around will be sent.)

		// Compute number of bytes remaining to the end of the buffer
		tmp = (pctl->txbuff_end - pctl->txbuff_out); 			// Remaining ct
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; 	// Set TX mem address
 8005408:	6804      	ldr	r4, [r0, #0]
	if (tmp < 0)	// Wrap around check.
	{ // Here, there is wrap-around, so send what remains in (non-circular) buffer.
	  // (Upon the next DMA interrupt what remains after the wrap-around will be sent.)

		// Compute number of bytes remaining to the end of the buffer
		tmp = (pctl->txbuff_end - pctl->txbuff_out); 			// Remaining ct
 800540a:	6982      	ldr	r2, [r0, #24]
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; 	// Set TX mem address
 800540c:	2518      	movs	r5, #24
 800540e:	fb05 4101 	mla	r1, r5, r1, r4
	if (tmp < 0)	// Wrap around check.
	{ // Here, there is wrap-around, so send what remains in (non-circular) buffer.
	  // (Upon the next DMA interrupt what remains after the wrap-around will be sent.)

		// Compute number of bytes remaining to the end of the buffer
		tmp = (pctl->txbuff_end - pctl->txbuff_out); 			// Remaining ct
 8005412:	1ad2      	subs	r2, r2, r3
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; 	// Set TX mem address
 8005414:	61cb      	str	r3, [r1, #28]
 8005416:	e008      	b.n	800542a <common_dma+0x32>
		pctl->txbuff_dmanext = pctl->txbuff_base;				// Save new start ptr
	}
	else
	{ // Here, no wrap around, so all buffered bytes can be sent with one setting
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; // Set TX mem address
 8005418:	6804      	ldr	r4, [r0, #0]
 800541a:	2518      	movs	r5, #24
 800541c:	fb05 4101 	mla	r1, r5, r1, r4
 8005420:	61cb      	str	r3, [r1, #28]
// redundant	tmp = pctl->txbuff_in - pctl->txbuff_out);		// Number of bytes to send
		ptmp = tmp + pctl->txbuff_out;
		if (ptmp >= pctl->txbuff_end)
 8005422:	6981      	ldr	r1, [r0, #24]
	}
	else
	{ // Here, no wrap around, so all buffered bytes can be sent with one setting
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; // Set TX mem address
// redundant	tmp = pctl->txbuff_in - pctl->txbuff_out);		// Number of bytes to send
		ptmp = tmp + pctl->txbuff_out;
 8005424:	189b      	adds	r3, r3, r2
		if (ptmp >= pctl->txbuff_end)
 8005426:	428b      	cmp	r3, r1
 8005428:	d300      	bcc.n	800542c <common_dma+0x34>
			ptmp = pctl->txbuff_base;
 800542a:	6943      	ldr	r3, [r0, #20]
		pctl->txbuff_dmanext = ptmp;				// Save new start ptr
	}

	DMA_SNDTR(pctl->idma,pctl->txdma_stream)  = tmp;		// Set number of bytes
 800542c:	6804      	ldr	r4, [r0, #0]
 800542e:	68c1      	ldr	r1, [r0, #12]
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; // Set TX mem address
// redundant	tmp = pctl->txbuff_in - pctl->txbuff_out);		// Number of bytes to send
		ptmp = tmp + pctl->txbuff_out;
		if (ptmp >= pctl->txbuff_end)
			ptmp = pctl->txbuff_base;
		pctl->txbuff_dmanext = ptmp;				// Save new start ptr
 8005430:	6283      	str	r3, [r0, #40]	; 0x28
	}

	DMA_SNDTR(pctl->idma,pctl->txdma_stream)  = tmp;		// Set number of bytes
 8005432:	2318      	movs	r3, #24
 8005434:	4359      	muls	r1, r3
 8005436:	3414      	adds	r4, #20
 8005438:	5062      	str	r2, [r4, r1]
	DMA_SCR (pctl->idma,pctl->txdma_stream) |= 0x1;		// Enable DMA and away we go!
 800543a:	6802      	ldr	r2, [r0, #0]
 800543c:	68c1      	ldr	r1, [r0, #12]
 800543e:	3210      	adds	r2, #16
 8005440:	434b      	muls	r3, r1
 8005442:	58d1      	ldr	r1, [r2, r3]
 8005444:	f041 0101 	orr.w	r1, r1, #1
 8005448:	50d1      	str	r1, [r2, r3]
 800544a:	bd30      	pop	{r4, r5, pc}

0800544c <DMA_UART_IRQHandler>:
{
	/* The following is for consistency in the code in this file. ('nvic_dma_mgr.c' uses volatile u32*) */
	struct CB_UART* pctl = (struct CB_UART*)pall;

	/* Clear all interrupt flags for this DMA stream */
	if (pctl->txdma_stream > 3)
 800544c:	68c3      	ldr	r3, [r0, #12]
 800544e:	4a0a      	ldr	r2, [pc, #40]	; (8005478 <DMA_UART_IRQHandler+0x2c>)
 8005450:	2b03      	cmp	r3, #3
 8005452:	d908      	bls.n	8005466 <DMA_UART_IRQHandler+0x1a>
	{// High register
		DMA_HIFCR(pctl->idma) = (0x3d << tcif_tbl[pctl->txdma_stream-4]);
 8005454:	18d3      	adds	r3, r2, r3
 8005456:	6801      	ldr	r1, [r0, #0]
 8005458:	f813 3c04 	ldrb.w	r3, [r3, #-4]
 800545c:	223d      	movs	r2, #61	; 0x3d
 800545e:	fa12 f303 	lsls.w	r3, r2, r3
 8005462:	60cb      	str	r3, [r1, #12]
 8005464:	e005      	b.n	8005472 <DMA_UART_IRQHandler+0x26>
	}
	else
	{ // Low register
		DMA_LIFCR(pctl->idma) = (0x3d << tcif_tbl[pctl->txdma_stream]);
 8005466:	5cd3      	ldrb	r3, [r2, r3]
 8005468:	6801      	ldr	r1, [r0, #0]
 800546a:	223d      	movs	r2, #61	; 0x3d
 800546c:	fa12 f303 	lsls.w	r3, r2, r3
 8005470:	608b      	str	r3, [r1, #8]
	}
	pctl->txbuff_out = pctl->txbuff_dmanext; // Update where in the buffer we have xmitted
 8005472:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8005474:	6243      	str	r3, [r0, #36]	; 0x24

	/* Here, check if there are bytes buffered and if so, figure out how to send them. */
	common_dma(pctl);
 8005476:	e7bf      	b.n	80053f8 <common_dma>
 8005478:	0800cf14 	.word	0x0800cf14

0800547c <bsp_panic>:
static void common_dma(struct CB_UART* pctl);

/* Error trapping */
int PANIC_x;	// Global variable to look at.
void bsp_panic (int x)
{ PANIC_x = x; panic_leds(7); } // Save code, and flash LEDs 7x
 800547c:	4b02      	ldr	r3, [pc, #8]	; (8005488 <bsp_panic+0xc>)
 800547e:	6018      	str	r0, [r3, #0]
 8005480:	2007      	movs	r0, #7
 8005482:	f7ff bc78 	b.w	8004d76 <panic_leds>
 8005486:	bf00      	nop
 8005488:	20001758 	.word	0x20001758

0800548c <mapindex>:
 * @brief	: Edit & Map register base address to control block index & enable APBxENR
 * @param	: p = pointer to register base
 * @return	: 0 - 7 = OK; panic_leds for fail
******************************************************************************/	
static int mapindex(volatile u32 iuart)
{
 800548c:	b507      	push	{r0, r1, r2, lr}
 800548e:	9001      	str	r0, [sp, #4]
	int idx;

	/* Index v register base */
	switch (iuart)
 8005490:	9b01      	ldr	r3, [sp, #4]
 8005492:	4a21      	ldr	r2, [pc, #132]	; (8005518 <mapindex+0x8c>)
 8005494:	4293      	cmp	r3, r2
 8005496:	d030      	beq.n	80054fa <mapindex+0x6e>
 8005498:	d806      	bhi.n	80054a8 <mapindex+0x1c>
 800549a:	4a20      	ldr	r2, [pc, #128]	; (800551c <mapindex+0x90>)
 800549c:	4293      	cmp	r3, r2
 800549e:	d01e      	beq.n	80054de <mapindex+0x52>
 80054a0:	4a1f      	ldr	r2, [pc, #124]	; (8005520 <mapindex+0x94>)
 80054a2:	4293      	cmp	r3, r2
 80054a4:	d109      	bne.n	80054ba <mapindex+0x2e>
 80054a6:	e021      	b.n	80054ec <mapindex+0x60>
 80054a8:	4a1e      	ldr	r2, [pc, #120]	; (8005524 <mapindex+0x98>)
 80054aa:	4293      	cmp	r3, r2
 80054ac:	d009      	beq.n	80054c2 <mapindex+0x36>
 80054ae:	4a1e      	ldr	r2, [pc, #120]	; (8005528 <mapindex+0x9c>)
 80054b0:	4293      	cmp	r3, r2
 80054b2:	d00d      	beq.n	80054d0 <mapindex+0x44>
 80054b4:	4a1d      	ldr	r2, [pc, #116]	; (800552c <mapindex+0xa0>)
 80054b6:	4293      	cmp	r3, r2
 80054b8:	d026      	beq.n	8005508 <mapindex+0x7c>
	case UART4:	idx =  3; break;
	case UART5:	idx =  4; break;
	case USART6:	idx =  5; break;

	default:
		bsp_panic(-61);	// No match for request
 80054ba:	f06f 003c 	mvn.w	r0, #60	; 0x3c
 80054be:	f7ff ffdd 	bl	800547c <bsp_panic>
	}
	/* Enable USART/UART module on appropriate bus */
	switch (idx)
	{
	case 0:	RCC_AHB2ENR |= (1 << 4); break;
 80054c2:	4b1b      	ldr	r3, [pc, #108]	; (8005530 <mapindex+0xa4>)
 80054c4:	681a      	ldr	r2, [r3, #0]
 80054c6:	f042 0210 	orr.w	r2, r2, #16
 80054ca:	601a      	str	r2, [r3, #0]
 80054cc:	2000      	movs	r0, #0
 80054ce:	e021      	b.n	8005514 <mapindex+0x88>
	case 5:	RCC_AHB2ENR |= (1 << 5); break;	
 80054d0:	4b17      	ldr	r3, [pc, #92]	; (8005530 <mapindex+0xa4>)
 80054d2:	681a      	ldr	r2, [r3, #0]
 80054d4:	f042 0220 	orr.w	r2, r2, #32
 80054d8:	601a      	str	r2, [r3, #0]
 80054da:	2005      	movs	r0, #5
 80054dc:	e01a      	b.n	8005514 <mapindex+0x88>

	case 1:	RCC_AHB1ENR |= (1 << 17); break;
 80054de:	4b15      	ldr	r3, [pc, #84]	; (8005534 <mapindex+0xa8>)
 80054e0:	681a      	ldr	r2, [r3, #0]
 80054e2:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 80054e6:	601a      	str	r2, [r3, #0]
 80054e8:	2001      	movs	r0, #1
 80054ea:	e013      	b.n	8005514 <mapindex+0x88>
	case 2:	RCC_AHB1ENR |= (1 << 18); break;
 80054ec:	4b11      	ldr	r3, [pc, #68]	; (8005534 <mapindex+0xa8>)
 80054ee:	681a      	ldr	r2, [r3, #0]
 80054f0:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 80054f4:	601a      	str	r2, [r3, #0]
 80054f6:	2002      	movs	r0, #2
 80054f8:	e00c      	b.n	8005514 <mapindex+0x88>
	case 3:	RCC_AHB1ENR |= (1 << 19); break;
 80054fa:	4b0e      	ldr	r3, [pc, #56]	; (8005534 <mapindex+0xa8>)
 80054fc:	681a      	ldr	r2, [r3, #0]
 80054fe:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8005502:	601a      	str	r2, [r3, #0]
 8005504:	2003      	movs	r0, #3
 8005506:	e005      	b.n	8005514 <mapindex+0x88>
	case 4:	RCC_AHB1ENR |= (1 << 20); break;
 8005508:	4b0a      	ldr	r3, [pc, #40]	; (8005534 <mapindex+0xa8>)
 800550a:	681a      	ldr	r2, [r3, #0]
 800550c:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8005510:	601a      	str	r2, [r3, #0]
 8005512:	2004      	movs	r0, #4
	default:
		bsp_panic(-62);	// Wrong
	}

	return idx;
}
 8005514:	bd0e      	pop	{r1, r2, r3, pc}
 8005516:	bf00      	nop
 8005518:	40004c00 	.word	0x40004c00
 800551c:	40004400 	.word	0x40004400
 8005520:	40004800 	.word	0x40004800
 8005524:	40011000 	.word	0x40011000
 8005528:	40011400 	.word	0x40011400
 800552c:	40005000 	.word	0x40005000
 8005530:	40023834 	.word	0x40023834
 8005534:	40023830 	.word	0x40023830

08005538 <getbuff>:
 * @param	: rxbuffsize = requested size of rx buffer
 * @param	: txbuffsize = requested size of rx buffer
 * @return	: 0 = OK; -1; fail = led trap
******************************************************************************/	
static int getbuff(int idx, u32 rxbuffsize, u32 txbuffsize)
{
 8005538:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800553a:	4604      	mov	r4, r0
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
 800553c:	4f13      	ldr	r7, [pc, #76]	; (800558c <getbuff+0x54>)
 800553e:	4608      	mov	r0, r1
 * @param	: rxbuffsize = requested size of rx buffer
 * @param	: txbuffsize = requested size of rx buffer
 * @return	: 0 = OK; -1; fail = led trap
******************************************************************************/	
static int getbuff(int idx, u32 rxbuffsize, u32 txbuffsize)
{
 8005540:	460d      	mov	r5, r1
 8005542:	4616      	mov	r6, r2
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
 8005544:	f000 ffc4 	bl	80064d0 <malloc>
 8005548:	01a3      	lsls	r3, r4, #6
 800554a:	18fb      	adds	r3, r7, r3
 800554c:	6318      	str	r0, [r3, #48]	; 0x30
 800554e:	b910      	cbnz	r0, 8005556 <getbuff+0x1e>
 8005550:	380d      	subs	r0, #13
 8005552:	f7ff ff93 	bl	800547c <bsp_panic>
	if ((cb_uart[idx].txbuff_base = malloc(txbuffsize)) == NULL) bsp_panic(-14);	// malloc failed to obtain tx buffer
 8005556:	4630      	mov	r0, r6
 8005558:	f000 ffba 	bl	80064d0 <malloc>
 800555c:	01a4      	lsls	r4, r4, #6
 800555e:	193b      	adds	r3, r7, r4
 8005560:	6198      	str	r0, [r3, #24]
 8005562:	b910      	cbnz	r0, 800556a <getbuff+0x32>
 8005564:	380e      	subs	r0, #14
 8005566:	f7ff ff89 	bl	800547c <bsp_panic>
	cb_uart[idx].rxbuff_end  = cb_uart[idx].rxbuff_base + rxbuffsize;
 800556a:	193c      	adds	r4, r7, r4
	cb_uart[idx].txbuff_dmanext = cb_uart[idx].txbuff_base;
	cb_uart[idx].rxbuff_in   = cb_uart[idx].rxbuff_base;
	cb_uart[idx].txbuff_in   = cb_uart[idx].txbuff_base;
	
	return 0;
}
 800556c:	2000      	movs	r0, #0
static int getbuff(int idx, u32 rxbuffsize, u32 txbuffsize)
{
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
	if ((cb_uart[idx].txbuff_base = malloc(txbuffsize)) == NULL) bsp_panic(-14);	// malloc failed to obtain tx buffer
	cb_uart[idx].rxbuff_end  = cb_uart[idx].rxbuff_base + rxbuffsize;
 800556e:	6b22      	ldr	r2, [r4, #48]	; 0x30
	cb_uart[idx].txbuff_end  = cb_uart[idx].txbuff_base + txbuffsize;
	cb_uart[idx].rxbuff_size = rxbuffsize;
 8005570:	63a5      	str	r5, [r4, #56]	; 0x38
static int getbuff(int idx, u32 rxbuffsize, u32 txbuffsize)
{
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
	if ((cb_uart[idx].txbuff_base = malloc(txbuffsize)) == NULL) bsp_panic(-14);	// malloc failed to obtain tx buffer
	cb_uart[idx].rxbuff_end  = cb_uart[idx].rxbuff_base + rxbuffsize;
 8005572:	1953      	adds	r3, r2, r5
 8005574:	6363      	str	r3, [r4, #52]	; 0x34
	cb_uart[idx].txbuff_end  = cb_uart[idx].txbuff_base + txbuffsize;
 8005576:	69a3      	ldr	r3, [r4, #24]
	cb_uart[idx].rxbuff_size = rxbuffsize;
	cb_uart[idx].txbuff_size = txbuffsize;
 8005578:	6226      	str	r6, [r4, #32]
{
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
	if ((cb_uart[idx].txbuff_base = malloc(txbuffsize)) == NULL) bsp_panic(-14);	// malloc failed to obtain tx buffer
	cb_uart[idx].rxbuff_end  = cb_uart[idx].rxbuff_base + rxbuffsize;
	cb_uart[idx].txbuff_end  = cb_uart[idx].txbuff_base + txbuffsize;
 800557a:	1999      	adds	r1, r3, r6
 800557c:	61e1      	str	r1, [r4, #28]
	cb_uart[idx].rxbuff_size = rxbuffsize;
	cb_uart[idx].txbuff_size = txbuffsize;
	cb_uart[idx].rxbuff_out  = cb_uart[idx].rxbuff_base;
 800557e:	6422      	str	r2, [r4, #64]	; 0x40
	cb_uart[idx].txbuff_out  = cb_uart[idx].txbuff_base;
 8005580:	62a3      	str	r3, [r4, #40]	; 0x28
	cb_uart[idx].txbuff_dmanext = cb_uart[idx].txbuff_base;
 8005582:	62e3      	str	r3, [r4, #44]	; 0x2c
	cb_uart[idx].rxbuff_in   = cb_uart[idx].rxbuff_base;
 8005584:	63e2      	str	r2, [r4, #60]	; 0x3c
	cb_uart[idx].txbuff_in   = cb_uart[idx].txbuff_base;
 8005586:	6263      	str	r3, [r4, #36]	; 0x24
	
	return 0;
}
 8005588:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800558a:	bf00      	nop
 800558c:	20001758 	.word	0x20001758

08005590 <uartnumber_to_baseaddr>:
*******************************************************************************/
static u32 uartnumber_to_baseaddr(u32 uartnumber)
{
	u32 iuart = 0;
	/* Convert uart number to uart register base address */
	switch (uartnumber)
 8005590:	3801      	subs	r0, #1
 * @brief	: Map uart number (1-6) to uart module base address
 * @param	: uartnumber = (1 -6), e.g. 2 = USART2
 * @return	: USART/UART base address, e.g. USART2 = 0x40004400
*******************************************************************************/
static u32 uartnumber_to_baseaddr(u32 uartnumber)
{
 8005592:	b508      	push	{r3, lr}
	u32 iuart = 0;
	/* Convert uart number to uart register base address */
	switch (uartnumber)
 8005594:	2805      	cmp	r0, #5
 8005596:	d80e      	bhi.n	80055b6 <uartnumber_to_baseaddr+0x26>
 8005598:	e8df f000 	tbb	[pc, r0]
 800559c:	07051303 	.word	0x07051303
 80055a0:	0b09      	.short	0x0b09
	{
	case 1:	iuart = USART1;	break;
 80055a2:	4809      	ldr	r0, [pc, #36]	; (80055c8 <uartnumber_to_baseaddr+0x38>)
 80055a4:	bd08      	pop	{r3, pc}
	case 2:	iuart = USART2;	break;
	case 3:	iuart = USART3;	break;
 80055a6:	4809      	ldr	r0, [pc, #36]	; (80055cc <uartnumber_to_baseaddr+0x3c>)
 80055a8:	bd08      	pop	{r3, pc}
	case 4:	iuart =  UART4;	break;
 80055aa:	4809      	ldr	r0, [pc, #36]	; (80055d0 <uartnumber_to_baseaddr+0x40>)
 80055ac:	bd08      	pop	{r3, pc}
	case 5:	iuart =  UART5;	break;
 80055ae:	4809      	ldr	r0, [pc, #36]	; (80055d4 <uartnumber_to_baseaddr+0x44>)
 80055b0:	bd08      	pop	{r3, pc}
	case 6:	iuart = USART6;	break;
 80055b2:	4809      	ldr	r0, [pc, #36]	; (80055d8 <uartnumber_to_baseaddr+0x48>)
 80055b4:	bd08      	pop	{r3, pc}

	default:
		bsp_panic(-66);	// No match for request
 80055b6:	f06f 0041 	mvn.w	r0, #65	; 0x41
 80055ba:	f7ff ff5f 	bl	800547c <bsp_panic>
 * @param	: uartnumber = (1 -6), e.g. 2 = USART2
 * @return	: USART/UART base address, e.g. USART2 = 0x40004400
*******************************************************************************/
static u32 uartnumber_to_baseaddr(u32 uartnumber)
{
	u32 iuart = 0;
 80055be:	2000      	movs	r0, #0
 80055c0:	bd08      	pop	{r3, pc}
	/* Convert uart number to uart register base address */
	switch (uartnumber)
	{
	case 1:	iuart = USART1;	break;
	case 2:	iuart = USART2;	break;
 80055c2:	4806      	ldr	r0, [pc, #24]	; (80055dc <uartnumber_to_baseaddr+0x4c>)
	default:
		bsp_panic(-66);	// No match for request
	}	
	return iuart;

}
 80055c4:	bd08      	pop	{r3, pc}
 80055c6:	bf00      	nop
 80055c8:	40011000 	.word	0x40011000
 80055cc:	40004800 	.word	0x40004800
 80055d0:	40004c00 	.word	0x40004c00
 80055d4:	40005000 	.word	0x40005000
 80055d8:	40011400 	.word	0x40011400
 80055dc:	40004400 	.word	0x40004400

080055e0 <irq_given_datastream>:
{
	u32	dma;
	int	num;
};
static struct IRQNUM irq_given_datastream(u32 iuart, int dmastream)
{
 80055e0:	b570      	push	{r4, r5, r6, lr}
	struct IRQNUM irqnum = {0,0}; 
	if (dmastream < 0) bsp_panic(-714);
 80055e2:	1e16      	subs	r6, r2, #0
{
	u32	dma;
	int	num;
};
static struct IRQNUM irq_given_datastream(u32 iuart, int dmastream)
{
 80055e4:	4604      	mov	r4, r0
 80055e6:	460d      	mov	r5, r1
	struct IRQNUM irqnum = {0,0}; 
	if (dmastream < 0) bsp_panic(-714);
 80055e8:	da02      	bge.n	80055f0 <irq_given_datastream+0x10>
 80055ea:	480f      	ldr	r0, [pc, #60]	; (8005628 <irq_given_datastream+0x48>)
 80055ec:	f7ff ff46 	bl	800547c <bsp_panic>

	if ((iuart == USART1) || (iuart == USART6))
 80055f0:	4b0e      	ldr	r3, [pc, #56]	; (800562c <irq_given_datastream+0x4c>)
 80055f2:	429d      	cmp	r5, r3
 80055f4:	d002      	beq.n	80055fc <irq_given_datastream+0x1c>
 80055f6:	4b0e      	ldr	r3, [pc, #56]	; (8005630 <irq_given_datastream+0x50>)
 80055f8:	429d      	cmp	r5, r3
 80055fa:	d108      	bne.n	800560e <irq_given_datastream+0x2e>
	{
		irqnum.dma = DMA2_BASE;
		if (dmastream > 4)	// Determine IRQ number for the stream 
 80055fc:	2e04      	cmp	r6, #4
 80055fe:	4b0d      	ldr	r3, [pc, #52]	; (8005634 <irq_given_datastream+0x54>)
 8005600:	dd02      	ble.n	8005608 <irq_given_datastream+0x28>
 8005602:	6023      	str	r3, [r4, #0]
		{ irqnum.num = (DMASTRM25 + dmastream - 5); return irqnum;}
 8005604:	363f      	adds	r6, #63	; 0x3f
 8005606:	e00b      	b.n	8005620 <irq_given_datastream+0x40>
 8005608:	6023      	str	r3, [r4, #0]
		else
		{ irqnum.num = (DMASTRM20 + dmastream); return irqnum;}
 800560a:	3638      	adds	r6, #56	; 0x38
 800560c:	e008      	b.n	8005620 <irq_given_datastream+0x40>
	}

	irqnum.dma = DMA1_BASE;
	if (dmastream == 7)
 800560e:	2e07      	cmp	r6, #7
 8005610:	4b09      	ldr	r3, [pc, #36]	; (8005638 <irq_given_datastream+0x58>)
 8005612:	d103      	bne.n	800561c <irq_given_datastream+0x3c>
 8005614:	6023      	str	r3, [r4, #0]
 8005616:	232f      	movs	r3, #47	; 0x2f
 8005618:	6063      	str	r3, [r4, #4]
		{ irqnum.num = (DMASTRM17); return irqnum;}
 800561a:	e002      	b.n	8005622 <irq_given_datastream+0x42>
 800561c:	6023      	str	r3, [r4, #0]
	else
		{ irqnum.num = (DMASTRM10 + dmastream); return irqnum;}
 800561e:	360b      	adds	r6, #11
		{ irqnum.num = (DMASTRM20 + dmastream); return irqnum;}
	}

	irqnum.dma = DMA1_BASE;
	if (dmastream == 7)
		{ irqnum.num = (DMASTRM17); return irqnum;}
 8005620:	6066      	str	r6, [r4, #4]
	else
		{ irqnum.num = (DMASTRM10 + dmastream); return irqnum;}

	bsp_panic(-715);	// Shouldn't happen
	return irqnum;
}
 8005622:	4620      	mov	r0, r4
 8005624:	bd70      	pop	{r4, r5, r6, pc}
 8005626:	bf00      	nop
 8005628:	fffffd36 	.word	0xfffffd36
 800562c:	40011000 	.word	0x40011000
 8005630:	40011400 	.word	0x40011400
 8005634:	40026400 	.word	0x40026400
 8005638:	40026000 	.word	0x40026000

0800563c <bsp_uart_open>:
 * @return	: control block pointer
******************************************************************************/	
static const char* open_name[8] = {"tty1", "tty2", "tty3", "tty4", "tty5", "tty6", "tty7", "tty8"};

struct CB_UART* bsp_uart_open(const char *name)
{
 800563c:	b570      	push	{r4, r5, r6, lr}
	int i;
	for (i = 0; i < 8; i++)
	{
		if (strcmp(name, open_name[i]) == 0) break;
	}
	if (i >= 8) return (struct CB_UART*)-1;
 800563e:	4d09      	ldr	r5, [pc, #36]	; (8005664 <bsp_uart_open+0x28>)
 * @return	: control block pointer
******************************************************************************/	
static const char* open_name[8] = {"tty1", "tty2", "tty3", "tty4", "tty5", "tty6", "tty7", "tty8"};

struct CB_UART* bsp_uart_open(const char *name)
{
 8005640:	4606      	mov	r6, r0
	int i;
	for (i = 0; i < 8; i++)
 8005642:	2400      	movs	r4, #0
	{
		if (strcmp(name, open_name[i]) == 0) break;
 8005644:	4630      	mov	r0, r6
 8005646:	f855 1f04 	ldr.w	r1, [r5, #4]!
 800564a:	f001 fb2d 	bl	8006ca8 <strcmp>
 800564e:	b128      	cbz	r0, 800565c <bsp_uart_open+0x20>
static const char* open_name[8] = {"tty1", "tty2", "tty3", "tty4", "tty5", "tty6", "tty7", "tty8"};

struct CB_UART* bsp_uart_open(const char *name)
{
	int i;
	for (i = 0; i < 8; i++)
 8005650:	3401      	adds	r4, #1
 8005652:	2c08      	cmp	r4, #8
 8005654:	d1f6      	bne.n	8005644 <bsp_uart_open+0x8>
	{
		if (strcmp(name, open_name[i]) == 0) break;
	}
	if (i >= 8) return (struct CB_UART*)-1;
 8005656:	f04f 30ff 	mov.w	r0, #4294967295
 800565a:	bd70      	pop	{r4, r5, r6, pc}
	
	return &cb_uart[i];	// Return control block ptr to 'open'
 800565c:	4802      	ldr	r0, [pc, #8]	; (8005668 <bsp_uart_open+0x2c>)
 800565e:	01a4      	lsls	r4, r4, #6
 8005660:	1900      	adds	r0, r0, r4
}
 8005662:	bd70      	pop	{r4, r5, r6, pc}
 8005664:	0800cf14 	.word	0x0800cf14
 8005668:	2000175c 	.word	0x2000175c

0800566c <bsp_uart_dma_init>:
 * @param	: dmastreamtx: DMA stream number for TX (0 - 7)
 * @param	: dma_tx_int_priority: interrupt priority, (0x00 - 0xf0) e.g. 0xc0, low 4 bits zero
 * @return	: 0 = success; fail traps to 'panic_leds'
*******************************************************************************/
int bsp_uart_dma_init(u32 iuart, u32 baud, u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority)
{
 800566c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005670:	b08b      	sub	sp, #44	; 0x2c
 8005672:	4604      	mov	r4, r0
 8005674:	9f14      	ldr	r7, [sp, #80]	; 0x50
 8005676:	9101      	str	r1, [sp, #4]
	u32 dma_channel_number_rx = 4;	// Initialize to prevent compiler warning
	u32 dma_channel_number_tx = 5;	


	/* Be sure arguments passed are within range */
	if (dmastreamrx > 7) bsp_panic(-1);
 8005678:	2f07      	cmp	r7, #7
 * @param	: dmastreamtx: DMA stream number for TX (0 - 7)
 * @param	: dma_tx_int_priority: interrupt priority, (0x00 - 0xf0) e.g. 0xc0, low 4 bits zero
 * @return	: 0 = success; fail traps to 'panic_leds'
*******************************************************************************/
int bsp_uart_dma_init(u32 iuart, u32 baud, u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority)
{
 800567a:	9202      	str	r2, [sp, #8]
 800567c:	9303      	str	r3, [sp, #12]
 800567e:	f8dd a054 	ldr.w	sl, [sp, #84]	; 0x54
	u32 dma_channel_number_rx = 4;	// Initialize to prevent compiler warning
	u32 dma_channel_number_tx = 5;	


	/* Be sure arguments passed are within range */
	if (dmastreamrx > 7) bsp_panic(-1);
 8005682:	d903      	bls.n	800568c <bsp_uart_dma_init+0x20>
 8005684:	f04f 30ff 	mov.w	r0, #4294967295
 8005688:	f7ff fef8 	bl	800547c <bsp_panic>
	if (dmastreamtx > 7) bsp_panic(-2);
 800568c:	f1ba 0f07 	cmp.w	sl, #7
 8005690:	d903      	bls.n	800569a <bsp_uart_dma_init+0x2e>
 8005692:	f06f 0001 	mvn.w	r0, #1
 8005696:	f7ff fef1 	bl	800547c <bsp_panic>
	if ((dma_tx_int_priority & 0xffffff0f) != 0) bsp_panic(-3); // Bogus priority
 800569a:	9916      	ldr	r1, [sp, #88]	; 0x58
 800569c:	f031 01f0 	bics.w	r1, r1, #240	; 0xf0
 80056a0:	d003      	beq.n	80056aa <bsp_uart_dma_init+0x3e>
 80056a2:	f06f 0002 	mvn.w	r0, #2
 80056a6:	f7ff fee9 	bl	800547c <bsp_panic>
	
	cb_Idx = mapindex(iuart);	// Map usart/uart register base to control block index
 80056aa:	4620      	mov	r0, r4
 80056ac:	f7ff feee 	bl	800548c <mapindex>

	/* Convert dma stream to dma base and irq number */
	dma_irq_number_tx = irq_given_datastream(iuart, dmastreamtx); // TX
 80056b0:	4621      	mov	r1, r4
 80056b2:	4652      	mov	r2, sl
	/* Be sure arguments passed are within range */
	if (dmastreamrx > 7) bsp_panic(-1);
	if (dmastreamtx > 7) bsp_panic(-2);
	if ((dma_tx_int_priority & 0xffffff0f) != 0) bsp_panic(-3); // Bogus priority
	
	cb_Idx = mapindex(iuart);	// Map usart/uart register base to control block index
 80056b4:	4683      	mov	fp, r0

	/* Convert dma stream to dma base and irq number */
	dma_irq_number_tx = irq_given_datastream(iuart, dmastreamtx); // TX
 80056b6:	a806      	add	r0, sp, #24
 80056b8:	f7ff ff92 	bl	80055e0 <irq_given_datastream>
	dma_irq_number_rx = irq_given_datastream(iuart, dmastreamrx); // RX
 80056bc:	a804      	add	r0, sp, #16
 80056be:	4621      	mov	r1, r4
 80056c0:	463a      	mov	r2, r7
	if ((dma_tx_int_priority & 0xffffff0f) != 0) bsp_panic(-3); // Bogus priority
	
	cb_Idx = mapindex(iuart);	// Map usart/uart register base to control block index

	/* Convert dma stream to dma base and irq number */
	dma_irq_number_tx = irq_given_datastream(iuart, dmastreamtx); // TX
 80056c2:	9e06      	ldr	r6, [sp, #24]
 80056c4:	9d07      	ldr	r5, [sp, #28]
	dma_irq_number_rx = irq_given_datastream(iuart, dmastreamrx); // RX
 80056c6:	f7ff ff8b 	bl	80055e0 <irq_given_datastream>
	
	/* The DMA determined should be the same...mostly a debugging issue. */
	if (dma_irq_number_tx.dma != dma_irq_number_rx.dma) bsp_panic(-333);
 80056ca:	9b04      	ldr	r3, [sp, #16]
	
	cb_Idx = mapindex(iuart);	// Map usart/uart register base to control block index

	/* Convert dma stream to dma base and irq number */
	dma_irq_number_tx = irq_given_datastream(iuart, dmastreamtx); // TX
	dma_irq_number_rx = irq_given_datastream(iuart, dmastreamrx); // RX
 80056cc:	f8dd 9014 	ldr.w	r9, [sp, #20]
	
	/* The DMA determined should be the same...mostly a debugging issue. */
	if (dma_irq_number_tx.dma != dma_irq_number_rx.dma) bsp_panic(-333);
 80056d0:	429e      	cmp	r6, r3
 80056d2:	d003      	beq.n	80056dc <bsp_uart_dma_init+0x70>
 80056d4:	f46f 70a6 	mvn.w	r0, #332	; 0x14c
 80056d8:	f7ff fed0 	bl	800547c <bsp_panic>
	dma_x = dma_irq_number_tx.dma;	// Lazy way of dealing with it later

	/* Set dma stream interrupt to revector to this routine; check if dma is in use. */
	tmp = nvic_dma_stream_vector_add( (void(*)(u32*))&DMA_UART_IRQHandler, (u32*)&cb_uart[cb_Idx], dma_irq_number_tx.num, dmastreamtx);
 80056dc:	4a85      	ldr	r2, [pc, #532]	; (80058f4 <bsp_uart_dma_init+0x288>)
 80056de:	4886      	ldr	r0, [pc, #536]	; (80058f8 <bsp_uart_dma_init+0x28c>)
 80056e0:	ea4f 138b 	mov.w	r3, fp, lsl #6
 80056e4:	eb02 0803 	add.w	r8, r2, r3
 80056e8:	4641      	mov	r1, r8
 80056ea:	462a      	mov	r2, r5
 80056ec:	4653      	mov	r3, sl
 80056ee:	f7ff fd75 	bl	80051dc <nvic_dma_stream_vector_add>
	if (tmp != 0) bsp_panic(-30 + tmp);
 80056f2:	b110      	cbz	r0, 80056fa <bsp_uart_dma_init+0x8e>
 80056f4:	381e      	subs	r0, #30
 80056f6:	f7ff fec1 	bl	800547c <bsp_panic>

	/* RX doesn't interrupt, but we need to show that the stream has been taken */
	tmp = nvic_dma_stream_vector_add( (void(*)(u32*))&DMA_UART_IRQHandler, (u32*)&cb_uart[cb_Idx], dma_irq_number_rx.num, dmastreamrx);
 80056fa:	487f      	ldr	r0, [pc, #508]	; (80058f8 <bsp_uart_dma_init+0x28c>)
 80056fc:	4641      	mov	r1, r8
 80056fe:	464a      	mov	r2, r9
 8005700:	463b      	mov	r3, r7
 8005702:	f7ff fd6b 	bl	80051dc <nvic_dma_stream_vector_add>
	if (tmp != 0) bsp_panic(-130 + tmp);
 8005706:	b110      	cbz	r0, 800570e <bsp_uart_dma_init+0xa2>
 8005708:	3882      	subs	r0, #130	; 0x82
 800570a:	f7ff feb7 	bl	800547c <bsp_panic>


	/* Load some parameters that might be important. */
	cb_uart[cb_Idx].idma = dma_x;	// Save dma register base address
 800570e:	4a7b      	ldr	r2, [pc, #492]	; (80058fc <bsp_uart_dma_init+0x290>)
 8005710:	ea4f 138b 	mov.w	r3, fp, lsl #6
 8005714:	18d3      	adds	r3, r2, r3
	cb_uart[cb_Idx].rxdma_stream = dmastreamrx; // Save stream number
	cb_uart[cb_Idx].txdma_stream = dmastreamtx; // Save stream number
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
	cb_uart[cb_Idx].flag = 2;	// Show this setup for dma driven
 8005716:	2102      	movs	r1, #2
	tmp = nvic_dma_stream_vector_add( (void(*)(u32*))&DMA_UART_IRQHandler, (u32*)&cb_uart[cb_Idx], dma_irq_number_rx.num, dmastreamrx);
	if (tmp != 0) bsp_panic(-130 + tmp);


	/* Load some parameters that might be important. */
	cb_uart[cb_Idx].idma = dma_x;	// Save dma register base address
 8005718:	605e      	str	r6, [r3, #4]
	cb_uart[cb_Idx].rxdma_stream = dmastreamrx; // Save stream number
 800571a:	60df      	str	r7, [r3, #12]
	cb_uart[cb_Idx].txdma_stream = dmastreamtx; // Save stream number
 800571c:	f8c3 a010 	str.w	sl, [r3, #16]
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
 8005720:	609c      	str	r4, [r3, #8]
	cb_uart[cb_Idx].flag = 2;	// Show this setup for dma driven
 8005722:	6159      	str	r1, [r3, #20]

	/* Find DMA channel numbers for RX and TX, given stream number */
	switch (dma_x)
 8005724:	4b76      	ldr	r3, [pc, #472]	; (8005900 <bsp_uart_dma_init+0x294>)
 8005726:	429e      	cmp	r6, r3
 8005728:	d003      	beq.n	8005732 <bsp_uart_dma_init+0xc6>
 800572a:	4b76      	ldr	r3, [pc, #472]	; (8005904 <bsp_uart_dma_init+0x298>)
 800572c:	429e      	cmp	r6, r3
 800572e:	d11f      	bne.n	8005770 <bsp_uart_dma_init+0x104>
 8005730:	e00f      	b.n	8005752 <bsp_uart_dma_init+0xe6>
	{
	case DMA1_BASE:
		if (dma1_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
 8005732:	f007 0207 	and.w	r2, r7, #7
 8005736:	4b74      	ldr	r3, [pc, #464]	; (8005908 <bsp_uart_dma_init+0x29c>)
 8005738:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800573c:	42a1      	cmp	r1, r4
 800573e:	d01b      	beq.n	8005778 <bsp_uart_dma_init+0x10c>
		if (dma1_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
 8005740:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8005744:	6a1b      	ldr	r3, [r3, #32]
 8005746:	42a3      	cmp	r3, r4
 8005748:	d022      	beq.n	8005790 <bsp_uart_dma_init+0x124>
		bsp_panic(-6);	// RX stream specified is not compatible with UART/DMA1
 800574a:	f06f 0005 	mvn.w	r0, #5
 800574e:	f7ff fe95 	bl	800547c <bsp_panic>

	case DMA2_BASE:
		if (dma2_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
 8005752:	4b6d      	ldr	r3, [pc, #436]	; (8005908 <bsp_uart_dma_init+0x29c>)
 8005754:	f007 0207 	and.w	r2, r7, #7
 8005758:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800575c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800575e:	42a2      	cmp	r2, r4
 8005760:	d00a      	beq.n	8005778 <bsp_uart_dma_init+0x10c>
		if (dma2_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
 8005762:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8005764:	42a3      	cmp	r3, r4
 8005766:	d00a      	beq.n	800577e <bsp_uart_dma_init+0x112>
		bsp_panic(-7);	// RX stream specified is not compatible with UART/DMA2
 8005768:	f06f 0006 	mvn.w	r0, #6
 800576c:	f7ff fe86 	bl	800547c <bsp_panic>
	default:
		bsp_panic(-8);	// Something seriously wrong here!
 8005770:	f06f 0007 	mvn.w	r0, #7
 8005774:	f7ff fe82 	bl	800547c <bsp_panic>
		if (dma1_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
		if (dma1_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
		bsp_panic(-6);	// RX stream specified is not compatible with UART/DMA1

	case DMA2_BASE:
		if (dma2_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
 8005778:	f04f 0904 	mov.w	r9, #4
 800577c:	e001      	b.n	8005782 <bsp_uart_dma_init+0x116>
		if (dma2_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
 800577e:	f04f 0905 	mov.w	r9, #5
	default:
		bsp_panic(-8);	// Something seriously wrong here!

	}

	switch (dma_x)
 8005782:	4b5f      	ldr	r3, [pc, #380]	; (8005900 <bsp_uart_dma_init+0x294>)
 8005784:	429e      	cmp	r6, r3
 8005786:	d005      	beq.n	8005794 <bsp_uart_dma_init+0x128>
 8005788:	4b5e      	ldr	r3, [pc, #376]	; (8005904 <bsp_uart_dma_init+0x298>)
 800578a:	429e      	cmp	r6, r3
 800578c:	d128      	bne.n	80057e0 <bsp_uart_dma_init+0x174>
 800578e:	e016      	b.n	80057be <bsp_uart_dma_init+0x152>
	/* Find DMA channel numbers for RX and TX, given stream number */
	switch (dma_x)
	{
	case DMA1_BASE:
		if (dma1_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
		if (dma1_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
 8005790:	f04f 0905 	mov.w	r9, #5
	}

	switch (dma_x)
	{
	case DMA1_BASE:
		if (dma1_txstreamtbl_4[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 4; break;}
 8005794:	4b5c      	ldr	r3, [pc, #368]	; (8005908 <bsp_uart_dma_init+0x29c>)
 8005796:	f00a 0207 	and.w	r2, sl, #7
 800579a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800579e:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 80057a2:	42a2      	cmp	r2, r4
 80057a4:	d024      	beq.n	80057f0 <bsp_uart_dma_init+0x184>
		if (dma1_txstreamtbl_5[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 5; break;}
 80057a6:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 80057aa:	42a2      	cmp	r2, r4
 80057ac:	d023      	beq.n	80057f6 <bsp_uart_dma_init+0x18a>
		if (dma1_txstreamtbl_7[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 7; break;}
 80057ae:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 80057b2:	42a3      	cmp	r3, r4
 80057b4:	d019      	beq.n	80057ea <bsp_uart_dma_init+0x17e>
		bsp_panic(-9);	// TX stream specified is not compatible with UART/DMA1
 80057b6:	f06f 0008 	mvn.w	r0, #8
 80057ba:	f7ff fe5f 	bl	800547c <bsp_panic>

	case DMA2_BASE:
		if (dma2_txstreamtbl_4[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 4; break;}
 80057be:	4b52      	ldr	r3, [pc, #328]	; (8005908 <bsp_uart_dma_init+0x29c>)
 80057c0:	f00a 0207 	and.w	r2, sl, #7
 80057c4:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80057c8:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80057cc:	42a2      	cmp	r2, r4
 80057ce:	d00f      	beq.n	80057f0 <bsp_uart_dma_init+0x184>
		if (dma2_txstreamtbl_5[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 5; break;}
 80057d0:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 80057d4:	42a3      	cmp	r3, r4
 80057d6:	d00e      	beq.n	80057f6 <bsp_uart_dma_init+0x18a>
		bsp_panic(-10);	// TX stream specified is not compatible with UART/DMA2
 80057d8:	f06f 0009 	mvn.w	r0, #9
 80057dc:	f7ff fe4e 	bl	800547c <bsp_panic>
	default:
		bsp_panic(-11);	// Something seriously wrong here!
 80057e0:	f06f 000a 	mvn.w	r0, #10
 80057e4:	f7ff fe4a 	bl	800547c <bsp_panic>
 80057e8:	e005      	b.n	80057f6 <bsp_uart_dma_init+0x18a>
	switch (dma_x)
	{
	case DMA1_BASE:
		if (dma1_txstreamtbl_4[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 4; break;}
		if (dma1_txstreamtbl_5[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 5; break;}
		if (dma1_txstreamtbl_7[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 7; break;}
 80057ea:	f04f 0807 	mov.w	r8, #7
 80057ee:	e004      	b.n	80057fa <bsp_uart_dma_init+0x18e>
		bsp_panic(-9);	// TX stream specified is not compatible with UART/DMA1

	case DMA2_BASE:
		if (dma2_txstreamtbl_4[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 4; break;}
 80057f0:	f04f 0804 	mov.w	r8, #4
 80057f4:	e001      	b.n	80057fa <bsp_uart_dma_init+0x18e>
		if (dma2_txstreamtbl_5[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 5; break;}
 80057f6:	f04f 0805 	mov.w	r8, #5
	default:
		bsp_panic(-11);	// Something seriously wrong here!

	}
static u32 qqq;
	qqq = dma_channel_number_rx;
 80057fa:	4a40      	ldr	r2, [pc, #256]	; (80058fc <bsp_uart_dma_init+0x290>)
/* At this point we (should!) have a good DMA channel and stream that associates with the UART. */

	/* Set up UART pins, port & uart clockings.  THIS IS BOARD SPECIFIC */
	if (uart_pins(iuart, &uartpins) != 0) bsp_panic(-15);
 80057fc:	4620      	mov	r0, r4
	default:
		bsp_panic(-11);	// Something seriously wrong here!

	}
static u32 qqq;
	qqq = dma_channel_number_rx;
 80057fe:	f8c2 9204 	str.w	r9, [r2, #516]	; 0x204
/* At this point we (should!) have a good DMA channel and stream that associates with the UART. */

	/* Set up UART pins, port & uart clockings.  THIS IS BOARD SPECIFIC */
	if (uart_pins(iuart, &uartpins) != 0) bsp_panic(-15);
 8005802:	a908      	add	r1, sp, #32
 8005804:	f000 fa52 	bl	8005cac <uart_pins>
 8005808:	b118      	cbz	r0, 8005812 <bsp_uart_dma_init+0x1a6>
 800580a:	f06f 000e 	mvn.w	r0, #14
 800580e:	f7ff fe35 	bl	800547c <bsp_panic>

	/* Setup baud rate */
	usartx_setbaud (iuart, uartpins.pclk, baud);
 8005812:	4620      	mov	r0, r4
 8005814:	9908      	ldr	r1, [sp, #32]
 8005816:	9a01      	ldr	r2, [sp, #4]
 8005818:	f000 fb12 	bl	8005e40 <usartx_setbaud>

	/* Obtain some buffer space */
	getbuff(cb_Idx, rxbuffsize, txbuffsize);
 800581c:	4658      	mov	r0, fp
 800581e:	9902      	ldr	r1, [sp, #8]
 8005820:	9a03      	ldr	r2, [sp, #12]
 8005822:	f7ff fe89 	bl	8005538 <getbuff>

	/* ---------- Set up UART ----------------------------------------------------------------------------------- */

	/* Set up CR1 ---------------------------------------------------- */
	USART_CR1(iuart) |= (1<<13) | (1<<3) | (1<<2);// Set Usart enable, tx enable, rx enable
 8005826:	68e3      	ldr	r3, [r4, #12]
	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 8005828:	4934      	ldr	r1, [pc, #208]	; (80058fc <bsp_uart_dma_init+0x290>)
	getbuff(cb_Idx, rxbuffsize, txbuffsize);

	/* ---------- Set up UART ----------------------------------------------------------------------------------- */

	/* Set up CR1 ---------------------------------------------------- */
	USART_CR1(iuart) |= (1<<13) | (1<<3) | (1<<2);// Set Usart enable, tx enable, rx enable
 800582a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800582e:	f043 030c 	orr.w	r3, r3, #12
 8005832:	60e3      	str	r3, [r4, #12]

	/* Hook up usart tx and rx to dma channels */
	USART_CR3(iuart) |= (1<<7) | (1<<6);
 8005834:	6963      	ldr	r3, [r4, #20]
 8005836:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800583a:	6163      	str	r3, [r4, #20]
	/* After reset CR2 is 0x0000 and this is just fine */

	/* --------- Set up the DMA channels ------------------------------------------------------------------------ */

	/* Set peripheral address for RX */
	DMA_SPAR(dma_x,dmastreamrx) = (u32*)(iuart + 0x04); // Address of uart DR register
 800583c:	2318      	movs	r3, #24
 800583e:	fb03 6707 	mla	r7, r3, r7, r6
	/* Set peripheral address for TX */
	DMA_SPAR(dma_x,dmastreamtx) = (u32*)(iuart + 0x04); // Address of uart DR register

	/* DMA stream configuration register--RX p 325 */
	//                                       Channel number     | MINC    | CIRC   | Per->Mem 
	DMA_SCR(dma_x,dmastreamrx) = ( (dma_channel_number_rx<< 25) | (1<<10) | (1<<8) | (0x0<<6) );   
 8005842:	ea4f 6949 	mov.w	r9, r9, lsl #25

	/* Set peripheral address for RX */
	DMA_SPAR(dma_x,dmastreamrx) = (u32*)(iuart + 0x04); // Address of uart DR register

	/* Set peripheral address for TX */
	DMA_SPAR(dma_x,dmastreamtx) = (u32*)(iuart + 0x04); // Address of uart DR register
 8005846:	fb03 660a 	mla	r6, r3, sl, r6
	/* After reset CR2 is 0x0000 and this is just fine */

	/* --------- Set up the DMA channels ------------------------------------------------------------------------ */

	/* Set peripheral address for RX */
	DMA_SPAR(dma_x,dmastreamrx) = (u32*)(iuart + 0x04); // Address of uart DR register
 800584a:	3404      	adds	r4, #4
	/* Set peripheral address for TX */
	DMA_SPAR(dma_x,dmastreamtx) = (u32*)(iuart + 0x04); // Address of uart DR register

	/* DMA stream configuration register--RX p 325 */
	//                                       Channel number     | MINC    | CIRC   | Per->Mem 
	DMA_SCR(dma_x,dmastreamrx) = ( (dma_channel_number_rx<< 25) | (1<<10) | (1<<8) | (0x0<<6) );   
 800584c:	f449 63a0 	orr.w	r3, r9, #1280	; 0x500

	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));
 8005850:	ea4f 6848 	mov.w	r8, r8, lsl #25
	/* After reset CR2 is 0x0000 and this is just fine */

	/* --------- Set up the DMA channels ------------------------------------------------------------------------ */

	/* Set peripheral address for RX */
	DMA_SPAR(dma_x,dmastreamrx) = (u32*)(iuart + 0x04); // Address of uart DR register
 8005854:	61bc      	str	r4, [r7, #24]

	/* Set peripheral address for TX */
	DMA_SPAR(dma_x,dmastreamtx) = (u32*)(iuart + 0x04); // Address of uart DR register
 8005856:	61b4      	str	r4, [r6, #24]

	/* DMA stream configuration register--RX p 325 */
	//                                       Channel number     | MINC    | CIRC   | Per->Mem 
	DMA_SCR(dma_x,dmastreamrx) = ( (dma_channel_number_rx<< 25) | (1<<10) | (1<<8) | (0x0<<6) );   
 8005858:	613b      	str	r3, [r7, #16]

	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));
 800585a:	f448 3382 	orr.w	r3, r8, #66560	; 0x10400
 800585e:	f043 0340 	orr.w	r3, r3, #64	; 0x40

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 8005862:	ea4f 1b8b 	mov.w	fp, fp, lsl #6
	//                                       Channel number     | MINC    | CIRC   | Per->Mem 
	DMA_SCR(dma_x,dmastreamrx) = ( (dma_channel_number_rx<< 25) | (1<<10) | (1<<8) | (0x0<<6) );   

	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));
 8005866:	6133      	str	r3, [r6, #16]

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 8005868:	eb01 030b 	add.w	r3, r1, fp

	/* Set the number of bytes in the RX buff */
	DMA_SNDTR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_size;

	/* DMA for TX interrupts */
	NVICIPR (dma_irq_number_tx.num,dma_tx_int_priority);	// Set dma interrupt priority (tx)
 800586c:	2d00      	cmp	r5, #0
	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 800586e:	6b1a      	ldr	r2, [r3, #48]	; 0x30

	/* Set the number of bytes in the RX buff */
	DMA_SNDTR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_size;
 8005870:	6b9b      	ldr	r3, [r3, #56]	; 0x38
	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 8005872:	61fa      	str	r2, [r7, #28]

	/* Set the number of bytes in the RX buff */
	DMA_SNDTR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_size;
 8005874:	617b      	str	r3, [r7, #20]

	/* DMA for TX interrupts */
	NVICIPR (dma_irq_number_tx.num,dma_tx_int_priority);	// Set dma interrupt priority (tx)
 8005876:	4b25      	ldr	r3, [pc, #148]	; (800590c <bsp_uart_dma_init+0x2a0>)
 8005878:	462a      	mov	r2, r5
 800587a:	bfb8      	it	lt
 800587c:	1cea      	addlt	r2, r5, #3
 800587e:	f022 0203 	bic.w	r2, r2, #3
 8005882:	ea05 0303 	and.w	r3, r5, r3
 8005886:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
 800588a:	2b00      	cmp	r3, #0
 800588c:	f502 4264 	add.w	r2, r2, #58368	; 0xe400
 8005890:	da03      	bge.n	800589a <bsp_uart_dma_init+0x22e>
 8005892:	3b01      	subs	r3, #1
 8005894:	f063 0303 	orn	r3, r3, #3
 8005898:	3301      	adds	r3, #1
 800589a:	9916      	ldr	r1, [sp, #88]	; 0x58
 800589c:	00db      	lsls	r3, r3, #3
 800589e:	fa11 f303 	lsls.w	r3, r1, r3
 80058a2:	6811      	ldr	r1, [r2, #0]
	NVICISER(dma_irq_number_tx.num);			// Enable dma interrupt (tx)
 80058a4:	2d00      	cmp	r5, #0

	/* Set the number of bytes in the RX buff */
	DMA_SNDTR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_size;

	/* DMA for TX interrupts */
	NVICIPR (dma_irq_number_tx.num,dma_tx_int_priority);	// Set dma interrupt priority (tx)
 80058a6:	ea41 0303 	orr.w	r3, r1, r3
 80058aa:	6013      	str	r3, [r2, #0]
	NVICISER(dma_irq_number_tx.num);			// Enable dma interrupt (tx)
 80058ac:	462b      	mov	r3, r5
 80058ae:	bfb8      	it	lt
 80058b0:	f105 031f 	addlt.w	r3, r5, #31
 80058b4:	115a      	asrs	r2, r3, #5
 80058b6:	4b16      	ldr	r3, [pc, #88]	; (8005910 <bsp_uart_dma_init+0x2a4>)
 80058b8:	18d3      	adds	r3, r2, r3
 80058ba:	009a      	lsls	r2, r3, #2
 80058bc:	4b15      	ldr	r3, [pc, #84]	; (8005914 <bsp_uart_dma_init+0x2a8>)
 80058be:	ea05 0303 	and.w	r3, r5, r3
 80058c2:	2b00      	cmp	r3, #0
 80058c4:	da03      	bge.n	80058ce <bsp_uart_dma_init+0x262>
 80058c6:	3b01      	subs	r3, #1
 80058c8:	f063 031f 	orn	r3, r3, #31
 80058cc:	3301      	adds	r3, #1
 80058ce:	2101      	movs	r1, #1
 80058d0:	fa11 f303 	lsls.w	r3, r1, r3
 80058d4:	6811      	ldr	r1, [r2, #0]
 80058d6:	ea41 0303 	orr.w	r3, r1, r3
 80058da:	6013      	str	r3, [r2, #0]

	/* Final enabling of DMA */
	DMA_SCR(dma_x,dmastreamrx) |= (0x1);		// Enable rx stream
 80058dc:	693b      	ldr	r3, [r7, #16]
 80058de:	f043 0301 	orr.w	r3, r3, #1
 80058e2:	613b      	str	r3, [r7, #16]
	DMA_SCR(dma_x,dmastreamtx) |= ((1<<4));	// TCIE (xfer complete interrupt), not enable stream
 80058e4:	6933      	ldr	r3, [r6, #16]
 80058e6:	f043 0310 	orr.w	r3, r3, #16
 80058ea:	6133      	str	r3, [r6, #16]

	return 0;	// SUCCESS!
}
 80058ec:	2000      	movs	r0, #0
 80058ee:	b00b      	add	sp, #44	; 0x2c
 80058f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80058f4:	2000175c 	.word	0x2000175c
 80058f8:	0800544d 	.word	0x0800544d
 80058fc:	20001758 	.word	0x20001758
 8005900:	40026000 	.word	0x40026000
 8005904:	40026400 	.word	0x40026400
 8005908:	20000158 	.word	0x20000158
 800590c:	80000003 	.word	0x80000003
 8005910:	38003840 	.word	0x38003840
 8005914:	8000001f 	.word	0x8000001f

08005918 <bsp_uart_dma_init_number>:
 * int bsp_uart_dma_init_number(u32 uartnumber, u32 baud,u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority);
 * @brief	: A wrapper for 'int bsp_uart_dma_init' with uart number (1-6) rather than uart base address as the first argument
 * @return	: Same as bsp_uart_dma_init
*******************************************************************************/
int bsp_uart_dma_init_number(u32 uartnumber, u32 baud,u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority)
{
 8005918:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800591c:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8005920:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
 8005924:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8005926:	460e      	mov	r6, r1
 8005928:	4615      	mov	r5, r2
 800592a:	461c      	mov	r4, r3
	u32 iuart = uartnumber_to_baseaddr(uartnumber);
 800592c:	f7ff fe30 	bl	8005590 <uartnumber_to_baseaddr>
	return  bsp_uart_dma_init(iuart, baud, rxbuffsize, txbuffsize, dmastreamrx, dmastreamtx, dma_tx_int_priority);
 8005930:	4631      	mov	r1, r6
 8005932:	462a      	mov	r2, r5
 8005934:	4623      	mov	r3, r4
 8005936:	f8cd 9020 	str.w	r9, [sp, #32]
 800593a:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
 800593e:	970a      	str	r7, [sp, #40]	; 0x28
}
 8005940:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 * @return	: Same as bsp_uart_dma_init
*******************************************************************************/
int bsp_uart_dma_init_number(u32 uartnumber, u32 baud,u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority)
{
	u32 iuart = uartnumber_to_baseaddr(uartnumber);
	return  bsp_uart_dma_init(iuart, baud, rxbuffsize, txbuffsize, dmastreamrx, dmastreamtx, dma_tx_int_priority);
 8005944:	e692      	b.n	800566c <bsp_uart_dma_init>

08005946 <bsp_uart_getcount_ptr>:
*******************************************************************************/
int bsp_uart_getcount_ptr(struct CB_UART* pctl)
{
	int	Diff;

	if (pctl->flag == 1)
 8005946:	6902      	ldr	r2, [r0, #16]
 8005948:	2a01      	cmp	r2, #1
 * @brief	: Get the number of bytes buffered
 * @param	: pctl = pointer uart control block
 * @return	: number of chars in currently buffered.
*******************************************************************************/
int bsp_uart_getcount_ptr(struct CB_UART* pctl)
{
 800594a:	4603      	mov	r3, r0
	int	Diff;

	if (pctl->flag == 1)
 800594c:	d101      	bne.n	8005952 <bsp_uart_getcount_ptr+0xc>
	{ // Here, interrupt driven uart
		Diff = (int)(pctl->rxbuff_in - pctl->rxbuff_out);
 800594e:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8005950:	e009      	b.n	8005966 <bsp_uart_getcount_ptr+0x20>
		if (Diff < 0)
			Diff += pctl->rxbuff_size;  // Adjust for wrap
		return Diff;
	}

	if (pctl->flag == 2)
 8005952:	2a02      	cmp	r2, #2
 8005954:	d10d      	bne.n	8005972 <bsp_uart_getcount_ptr+0x2c>
	{ // Here, DMA driven uart
		/* Difference between where we are taking out chars, and where DMA is/was storing */
		Diff = ( pctl->rxbuff_end - DMA_SNDTR(pctl->idma,pctl->rxdma_stream) - pctl->rxbuff_out );
 8005956:	6801      	ldr	r1, [r0, #0]
 8005958:	6882      	ldr	r2, [r0, #8]
 800595a:	2018      	movs	r0, #24
 800595c:	4342      	muls	r2, r0
 800595e:	3114      	adds	r1, #20
 8005960:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8005962:	588a      	ldr	r2, [r1, r2]
 8005964:	1a80      	subs	r0, r0, r2
 8005966:	6bda      	ldr	r2, [r3, #60]	; 0x3c
		if (Diff < 0)
 8005968:	1a80      	subs	r0, r0, r2
 800596a:	d503      	bpl.n	8005974 <bsp_uart_getcount_ptr+0x2e>
			Diff += pctl->rxbuff_size;  // Adjust for wrap
 800596c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800596e:	18c0      	adds	r0, r0, r3
 8005970:	4770      	bx	lr
		return Diff;
	}
	return 0;	// Something wrong if we got here.
 8005972:	2000      	movs	r0, #0
}
 8005974:	4770      	bx	lr

08005976 <bsp_uart_getcount_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_getcount_uartnum(int uartnum)	// Select by uart number (1 - n)
{
	if ( ((uartnum - 1) < 0) || ((uartnum - 1) > 7) ) return 0;
 8005976:	3801      	subs	r0, #1
 8005978:	2807      	cmp	r0, #7
 800597a:	d803      	bhi.n	8005984 <bsp_uart_getcount_uartnum+0xe>
	return bsp_uart_getcount_ptr(&cb_uart[uartnum - 1]);
 800597c:	4b02      	ldr	r3, [pc, #8]	; (8005988 <bsp_uart_getcount_uartnum+0x12>)
 800597e:	0180      	lsls	r0, r0, #6
 8005980:	1818      	adds	r0, r3, r0
 8005982:	e7e0      	b.n	8005946 <bsp_uart_getcount_ptr>
}
 8005984:	2000      	movs	r0, #0
 8005986:	4770      	bx	lr
 8005988:	2000175c 	.word	0x2000175c

0800598c <bsp_uart_getc_ptr>:
 * @brief	: Get one char
 * @param	: pctl = pointer uart control block
 * @return	: char from buffer
*******************************************************************************/
char bsp_uart_getc_ptr(struct CB_UART* pctl)
{
 800598c:	b538      	push	{r3, r4, r5, lr}
 800598e:	4604      	mov	r4, r0
	char	c;
	u32 	i = 0;
 8005990:	2500      	movs	r5, #0

	/* Hang waiting for incoming bytes if bozo caller didn't check char count. */
	while (( bsp_uart_getcount_ptr(pctl) == 0)  && (i++ < 50000) ) ;
 8005992:	4620      	mov	r0, r4
 8005994:	f7ff ffd7 	bl	8005946 <bsp_uart_getcount_ptr>
 8005998:	b120      	cbz	r0, 80059a4 <bsp_uart_getc_ptr+0x18>
	if (i >= 50000) panic_leds(-50);
 800599a:	f24c 334f 	movw	r3, #49999	; 0xc34f
 800599e:	429d      	cmp	r5, r3
 80059a0:	d909      	bls.n	80059b6 <bsp_uart_getc_ptr+0x2a>
 80059a2:	e004      	b.n	80059ae <bsp_uart_getc_ptr+0x22>
{
	char	c;
	u32 	i = 0;

	/* Hang waiting for incoming bytes if bozo caller didn't check char count. */
	while (( bsp_uart_getcount_ptr(pctl) == 0)  && (i++ < 50000) ) ;
 80059a4:	3501      	adds	r5, #1
 80059a6:	f24c 3351 	movw	r3, #50001	; 0xc351
 80059aa:	429d      	cmp	r5, r3
 80059ac:	d1f1      	bne.n	8005992 <bsp_uart_getc_ptr+0x6>
	if (i >= 50000) panic_leds(-50);
 80059ae:	f06f 0031 	mvn.w	r0, #49	; 0x31
 80059b2:	f7ff f9e0 	bl	8004d76 <panic_leds>

	c = *pctl->rxbuff_out;
 80059b6:	6be1      	ldr	r1, [r4, #60]	; 0x3c
	pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
 80059b8:	4620      	mov	r0, r4

	/* Hang waiting for incoming bytes if bozo caller didn't check char count. */
	while (( bsp_uart_getcount_ptr(pctl) == 0)  && (i++ < 50000) ) ;
	if (i >= 50000) panic_leds(-50);

	c = *pctl->rxbuff_out;
 80059ba:	780d      	ldrb	r5, [r1, #0]
	pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
 80059bc:	f7ff fd0e 	bl	80053dc <rxbuff_adv>
 80059c0:	63e0      	str	r0, [r4, #60]	; 0x3c
	return c;
}
 80059c2:	4628      	mov	r0, r5
 80059c4:	bd38      	pop	{r3, r4, r5, pc}

080059c6 <bsp_uart_getc_uartnum>:
/* ---------------------------------------------------------------------------- */
char bsp_uart_getc_uartnum(int uartnum)	// Select by uart number (1 - n)
{
	if (((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 80059c6:	3801      	subs	r0, #1
 80059c8:	2807      	cmp	r0, #7
 80059ca:	d803      	bhi.n	80059d4 <bsp_uart_getc_uartnum+0xe>
	return bsp_uart_getc_ptr(&cb_uart[uartnum - 1]);
 80059cc:	4b02      	ldr	r3, [pc, #8]	; (80059d8 <bsp_uart_getc_uartnum+0x12>)
 80059ce:	0180      	lsls	r0, r0, #6
 80059d0:	1818      	adds	r0, r3, r0
 80059d2:	e7db      	b.n	800598c <bsp_uart_getc_ptr>
}
 80059d4:	2000      	movs	r0, #0
 80059d6:	4770      	bx	lr
 80059d8:	2000175c 	.word	0x2000175c

080059dc <bsp_uart_getn_ptr>:
 * @param	: pchr = pointer to output char buffer
 * @param	: len = number of bytes requested
 * @return	: number of chars actually transferred
*******************************************************************************/
int bsp_uart_getn_ptr(struct CB_UART* pctl, char *pchr, int len)
{
 80059dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80059de:	4604      	mov	r4, r0
 80059e0:	460d      	mov	r5, r1
 80059e2:	4617      	mov	r7, r2
	int 	i;
	int 	ct;

	ct = bsp_uart_getcount_ptr(pctl);
 80059e4:	f7ff ffaf 	bl	8005946 <bsp_uart_getcount_ptr>
	if (ct == 0) return 0;
 80059e8:	4606      	mov	r6, r0
 80059ea:	b178      	cbz	r0, 8005a0c <bsp_uart_getn_ptr+0x30>
 80059ec:	42be      	cmp	r6, r7
 80059ee:	bfa8      	it	ge
 80059f0:	463e      	movge	r6, r7

	if (ct > len) ct = len; // Check fo more ready than requested

	for (i = 0; i < ct; i++)
 80059f2:	2700      	movs	r7, #0
 80059f4:	e008      	b.n	8005a08 <bsp_uart_getn_ptr+0x2c>
	{
		*pchr++ = *pctl->rxbuff_out;	// Copy from buffer to output
 80059f6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80059f8:	781b      	ldrb	r3, [r3, #0]
 80059fa:	55eb      	strb	r3, [r5, r7]
		pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
 80059fc:	4620      	mov	r0, r4
 80059fe:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8005a00:	f7ff fcec 	bl	80053dc <rxbuff_adv>
	ct = bsp_uart_getcount_ptr(pctl);
	if (ct == 0) return 0;

	if (ct > len) ct = len; // Check fo more ready than requested

	for (i = 0; i < ct; i++)
 8005a04:	3701      	adds	r7, #1
	{
		*pchr++ = *pctl->rxbuff_out;	// Copy from buffer to output
		pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
 8005a06:	63e0      	str	r0, [r4, #60]	; 0x3c
	ct = bsp_uart_getcount_ptr(pctl);
	if (ct == 0) return 0;

	if (ct > len) ct = len; // Check fo more ready than requested

	for (i = 0; i < ct; i++)
 8005a08:	42b7      	cmp	r7, r6
 8005a0a:	dbf4      	blt.n	80059f6 <bsp_uart_getn_ptr+0x1a>
	{
		*pchr++ = *pctl->rxbuff_out;	// Copy from buffer to output
		pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
	}
	return ct; // Return number transfered.
}
 8005a0c:	4630      	mov	r0, r6
 8005a0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005a10 <bsp_uart_getn_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_getn_uartnum(int uartnum, char *pchr, int len)	// Select by uart number (1 - n)
{
	if ( ((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 8005a10:	3801      	subs	r0, #1
 8005a12:	2807      	cmp	r0, #7
 8005a14:	d803      	bhi.n	8005a1e <bsp_uart_getn_uartnum+0xe>
	return bsp_uart_getn_ptr(&cb_uart[uartnum - 1],  pchr, len);
 8005a16:	4b03      	ldr	r3, [pc, #12]	; (8005a24 <bsp_uart_getn_uartnum+0x14>)
 8005a18:	0180      	lsls	r0, r0, #6
 8005a1a:	1818      	adds	r0, r3, r0
 8005a1c:	e7de      	b.n	80059dc <bsp_uart_getn_ptr>
}
 8005a1e:	2000      	movs	r0, #0
 8005a20:	4770      	bx	lr
 8005a22:	bf00      	nop
 8005a24:	2000175c 	.word	0x2000175c

08005a28 <bsp_uart_start_dma>:
 * @param	: pctl: control block poiner
 * @return	:
*******************************************************************************/
void bsp_uart_start_dma(struct CB_UART* pctl)
{
	if (pctl->flag != 2) return;	// Return, not DMA driven
 8005a28:	6902      	ldr	r2, [r0, #16]
 8005a2a:	2a02      	cmp	r2, #2
 * @brief	: If DMA driven uart, start DMA sending if not already sending
 * @param	: pctl: control block poiner
 * @return	:
*******************************************************************************/
void bsp_uart_start_dma(struct CB_UART* pctl)
{
 8005a2c:	b510      	push	{r4, lr}
	if (pctl->flag != 2) return;	// Return, not DMA driven
 8005a2e:	d10f      	bne.n	8005a50 <bsp_uart_start_dma+0x28>
	
	/* Are we already running? */
	// First look at the enable bit
	if ((DMA_SCR(pctl->idma, pctl->txdma_stream) & 0x1) != 0) return;	// Already running
 8005a30:	6801      	ldr	r1, [r0, #0]
 8005a32:	68c2      	ldr	r2, [r0, #12]
 8005a34:	2418      	movs	r4, #24
 8005a36:	4362      	muls	r2, r4
 8005a38:	3110      	adds	r1, #16
 8005a3a:	5889      	ldr	r1, [r1, r2]
 8005a3c:	f011 0f01 	tst.w	r1, #1
 8005a40:	d106      	bne.n	8005a50 <bsp_uart_start_dma+0x28>


	// Check if the counter has gone to zero
	if ( DMA_SNDTR(pctl->idma,pctl->txdma_stream) != 0) return;
 8005a42:	6803      	ldr	r3, [r0, #0]
 8005a44:	3314      	adds	r3, #20
 8005a46:	589b      	ldr	r3, [r3, r2]
 8005a48:	b913      	cbnz	r3, 8005a50 <bsp_uart_start_dma+0x28>
	
	/* Not running.  If there are any to send, set up the DMA. */
	common_dma(pctl);

	return;
}
 8005a4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

	// Check if the counter has gone to zero
	if ( DMA_SNDTR(pctl->idma,pctl->txdma_stream) != 0) return;
	
	/* Not running.  If there are any to send, set up the DMA. */
	common_dma(pctl);
 8005a4e:	e4d3      	b.n	80053f8 <common_dma>
 8005a50:	bd10      	pop	{r4, pc}

08005a52 <bsp_uart_send_int>:
 * @param	: pctl = pointer uart control block
 * @return	: 
*******************************************************************************/
void bsp_uart_send_int(struct CB_UART* pctl)
{
	if (pctl->flag != 1) return;	// Return not interrupt drive & initialized
 8005a52:	6903      	ldr	r3, [r0, #16]
 8005a54:	2b01      	cmp	r3, #1
 8005a56:	d109      	bne.n	8005a6c <bsp_uart_send_int+0x1a>

	if ((USART_CR1(pctl->iuart) & USART_CR1_TXEIE) != 0) // Already enabled?
 8005a58:	6843      	ldr	r3, [r0, #4]
 8005a5a:	68db      	ldr	r3, [r3, #12]
 8005a5c:	f013 0f80 	tst.w	r3, #128	; 0x80
 8005a60:	d104      	bne.n	8005a6c <bsp_uart_send_int+0x1a>
		return;

	USART_CR1(pctl->iuart) |= USART_CR1_TXEIE ;	// Enable interrupt
 8005a62:	6843      	ldr	r3, [r0, #4]
 8005a64:	68da      	ldr	r2, [r3, #12]
 8005a66:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8005a6a:	60da      	str	r2, [r3, #12]
 8005a6c:	4770      	bx	lr

08005a6e <bsp_uart_putc_ptr>:
 * @param	: Char to be sent
 * @return	: 1 = one char add; 0 = no chars added; -1 = pctl was null
 * NOTE: this does not start an idle DMA, but starts an idle interrupt driven uart
*******************************************************************************/
int bsp_uart_putc_ptr(struct CB_UART* pctl, char c) // Select by control block ptr
{
 8005a6e:	b570      	push	{r4, r5, r6, lr}
 8005a70:	460e      	mov	r6, r1
	u8* p;

	if (pctl == 0) return -1;
 8005a72:	4604      	mov	r4, r0
 8005a74:	b180      	cbz	r0, 8005a98 <bsp_uart_putc_ptr+0x2a>

	/* Check if buffer filled.  Return zero if full. */
	p = txbuff_adv(pctl, pctl->txbuff_in); 	// Advance input pointer (circularly)
 8005a76:	6a05      	ldr	r5, [r0, #32]
 8005a78:	4629      	mov	r1, r5
 8005a7a:	f7ff fcb6 	bl	80053ea <txbuff_adv>
	if (p == pctl->txbuff_out)  return 0; 	// Return zero, rather than overwrite buffer
 8005a7e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005a80:	4298      	cmp	r0, r3
 8005a82:	d00c      	beq.n	8005a9e <bsp_uart_putc_ptr+0x30>

	*pctl->txbuff_in = (u8)c;		// Store char
 8005a84:	702e      	strb	r6, [r5, #0]

	/* Update the input buffer pointer to the next position. */
	pctl->txbuff_in = p;
 8005a86:	6220      	str	r0, [r4, #32]

	/* Start sending if non-dma */
	bsp_uart_send_int(pctl);
 8005a88:	4620      	mov	r0, r4
 8005a8a:	f7ff ffe2 	bl	8005a52 <bsp_uart_send_int>

	/* Start sending: if dma and not idle. */
	bsp_uart_start_dma(pctl); 
 8005a8e:	4620      	mov	r0, r4
 8005a90:	f7ff ffca 	bl	8005a28 <bsp_uart_start_dma>

 	return 1; // Return byte count stored.
 8005a94:	2001      	movs	r0, #1
 8005a96:	bd70      	pop	{r4, r5, r6, pc}
*******************************************************************************/
int bsp_uart_putc_ptr(struct CB_UART* pctl, char c) // Select by control block ptr
{
	u8* p;

	if (pctl == 0) return -1;
 8005a98:	f04f 30ff 	mov.w	r0, #4294967295
 8005a9c:	bd70      	pop	{r4, r5, r6, pc}

	/* Check if buffer filled.  Return zero if full. */
	p = txbuff_adv(pctl, pctl->txbuff_in); 	// Advance input pointer (circularly)
	if (p == pctl->txbuff_out)  return 0; 	// Return zero, rather than overwrite buffer
 8005a9e:	2000      	movs	r0, #0

	/* Start sending: if dma and not idle. */
	bsp_uart_start_dma(pctl); 

 	return 1; // Return byte count stored.
}
 8005aa0:	bd70      	pop	{r4, r5, r6, pc}

08005aa2 <bsp_uart_putc_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_putc_uartnum(int uartnum, char c)	// Select by uart number (1 - n)
{
	if (((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 8005aa2:	3801      	subs	r0, #1
 8005aa4:	2807      	cmp	r0, #7
 8005aa6:	d803      	bhi.n	8005ab0 <bsp_uart_putc_uartnum+0xe>
	return bsp_uart_putc_ptr(&cb_uart[uartnum - 1], c);
 8005aa8:	4b02      	ldr	r3, [pc, #8]	; (8005ab4 <bsp_uart_putc_uartnum+0x12>)
 8005aaa:	0180      	lsls	r0, r0, #6
 8005aac:	1818      	adds	r0, r3, r0
 8005aae:	e7de      	b.n	8005a6e <bsp_uart_putc_ptr>
}
 8005ab0:	2000      	movs	r0, #0
 8005ab2:	4770      	bx	lr
 8005ab4:	2000175c 	.word	0x2000175c

08005ab8 <bsp_uart_puts_ptr>:
 * @param	: p = pointer to buffer with bytes to be added
 * @return	: count of bytes added to buffer
 * NOTE: this starts either DMA or interrupt driven 
*******************************************************************************/
int bsp_uart_puts_ptr(struct CB_UART* pctl, char* p) // Select: control blk ptr
{
 8005ab8:	b570      	push	{r4, r5, r6, lr}
 8005aba:	460d      	mov	r5, r1
	u32 ct = 0;
	int ret;

	if (pctl == 0) return -1;	// Pointer not set
 8005abc:	4606      	mov	r6, r0
 8005abe:	b168      	cbz	r0, 8005adc <bsp_uart_puts_ptr+0x24>
 8005ac0:	2400      	movs	r4, #0
 8005ac2:	e006      	b.n	8005ad2 <bsp_uart_puts_ptr+0x1a>
	
	while (*p != 0)
	{
		ret = bsp_uart_putc_ptr(pctl, *p);	// Put char
 8005ac4:	4630      	mov	r0, r6
 8005ac6:	f7ff ffd2 	bl	8005a6e <bsp_uart_putc_ptr>
		if (ret > 0)
 8005aca:	2800      	cmp	r0, #0
		{ // Here, one byte was stored in buffer
			ct += ret;	// Add to count loaded
 8005acc:	bfc4      	itt	gt
 8005ace:	1824      	addgt	r4, r4, r0
			p++;
 8005ad0:	3501      	addgt	r5, #1
	u32 ct = 0;
	int ret;

	if (pctl == 0) return -1;	// Pointer not set
	
	while (*p != 0)
 8005ad2:	7829      	ldrb	r1, [r5, #0]
 8005ad4:	2900      	cmp	r1, #0
 8005ad6:	d1f5      	bne.n	8005ac4 <bsp_uart_puts_ptr+0xc>
			ct += ret;	// Add to count loaded
			p++;
		} // Note: loop hangs when buffer is full
	}

	return ct;
 8005ad8:	4620      	mov	r0, r4
 8005ada:	bd70      	pop	{r4, r5, r6, pc}
int bsp_uart_puts_ptr(struct CB_UART* pctl, char* p) // Select: control blk ptr
{
	u32 ct = 0;
	int ret;

	if (pctl == 0) return -1;	// Pointer not set
 8005adc:	f04f 30ff 	mov.w	r0, #4294967295
			p++;
		} // Note: loop hangs when buffer is full
	}

	return ct;
}
 8005ae0:	bd70      	pop	{r4, r5, r6, pc}

08005ae2 <bsp_uart_puts_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_puts_uartnum(int uartnum,char* p)	// Select by uart number (1 - n)
{
	if (((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 8005ae2:	3801      	subs	r0, #1
 8005ae4:	2807      	cmp	r0, #7
 8005ae6:	d803      	bhi.n	8005af0 <bsp_uart_puts_uartnum+0xe>
	return bsp_uart_puts_ptr(&cb_uart[uartnum - 1], p);
 8005ae8:	4b02      	ldr	r3, [pc, #8]	; (8005af4 <bsp_uart_puts_uartnum+0x12>)
 8005aea:	0180      	lsls	r0, r0, #6
 8005aec:	1818      	adds	r0, r3, r0
 8005aee:	e7e3      	b.n	8005ab8 <bsp_uart_puts_ptr>
}
 8005af0:	2000      	movs	r0, #0
 8005af2:	4770      	bx	lr
 8005af4:	2000175c 	.word	0x2000175c

08005af8 <bsp_uart_putn_ptr>:
 * @param	: count = number of bytes to be added
 * @return	: count of bytes added to buffer
 * NOTE: this starts either DMA or interrupt driven 
*******************************************************************************/
int bsp_uart_putn_ptr(struct CB_UART* pctl, char* p, int len ) // Select: control blk ptr
{
 8005af8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005afa:	460c      	mov	r4, r1
 8005afc:	4616      	mov	r6, r2
	u32 ct = len;
	int ret;
/* 'ct' and 'len' separate in case we decide to change it to return when the ct loaded is not equal len. */
	if (pctl == 0) return -1;	// Pointer not set
 8005afe:	4607      	mov	r7, r0
 8005b00:	b170      	cbz	r0, 8005b20 <bsp_uart_putn_ptr+0x28>
 8005b02:	4615      	mov	r5, r2
 8005b04:	e008      	b.n	8005b18 <bsp_uart_putn_ptr+0x20>
	
	while (len > 0)
	{
		while ((ret = bsp_uart_putc_ptr(pctl, *p)) == 0) ; // Loop if full 
 8005b06:	4638      	mov	r0, r7
 8005b08:	7821      	ldrb	r1, [r4, #0]
 8005b0a:	f7ff ffb0 	bl	8005a6e <bsp_uart_putc_ptr>
 8005b0e:	2800      	cmp	r0, #0
 8005b10:	d0f9      	beq.n	8005b06 <bsp_uart_putn_ptr+0xe>
		if (ret < 0 ) return ret; // Error.
 8005b12:	db07      	blt.n	8005b24 <bsp_uart_putn_ptr+0x2c>
		p++;		// 
 8005b14:	3401      	adds	r4, #1
		len -= 1;	// Decrement input count
 8005b16:	3d01      	subs	r5, #1
	u32 ct = len;
	int ret;
/* 'ct' and 'len' separate in case we decide to change it to return when the ct loaded is not equal len. */
	if (pctl == 0) return -1;	// Pointer not set
	
	while (len > 0)
 8005b18:	2d00      	cmp	r5, #0
 8005b1a:	dcf4      	bgt.n	8005b06 <bsp_uart_putn_ptr+0xe>
		while ((ret = bsp_uart_putc_ptr(pctl, *p)) == 0) ; // Loop if full 
		if (ret < 0 ) return ret; // Error.
		p++;		// 
		len -= 1;	// Decrement input count
	}
	return (ct - len);	// Return count added to buffer
 8005b1c:	1b70      	subs	r0, r6, r5
 8005b1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
int bsp_uart_putn_ptr(struct CB_UART* pctl, char* p, int len ) // Select: control blk ptr
{
	u32 ct = len;
	int ret;
/* 'ct' and 'len' separate in case we decide to change it to return when the ct loaded is not equal len. */
	if (pctl == 0) return -1;	// Pointer not set
 8005b20:	f04f 30ff 	mov.w	r0, #4294967295
		if (ret < 0 ) return ret; // Error.
		p++;		// 
		len -= 1;	// Decrement input count
	}
	return (ct - len);	// Return count added to buffer
}
 8005b24:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005b26 <bsp_uart_putn_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_putn_uartnum(int uartnum, char* p, int len )	// Select by uart number (1 - n)
{
	if (((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 8005b26:	3801      	subs	r0, #1
 8005b28:	2807      	cmp	r0, #7
 8005b2a:	d803      	bhi.n	8005b34 <bsp_uart_putn_uartnum+0xe>
	return bsp_uart_putn_ptr(&cb_uart[uartnum - 1], p, len);
 8005b2c:	4b02      	ldr	r3, [pc, #8]	; (8005b38 <bsp_uart_putn_uartnum+0x12>)
 8005b2e:	0180      	lsls	r0, r0, #6
 8005b30:	1818      	adds	r0, r3, r0
 8005b32:	e7e1      	b.n	8005af8 <bsp_uart_putn_ptr>
}
 8005b34:	2000      	movs	r0, #0
 8005b36:	4770      	bx	lr
 8005b38:	2000175c 	.word	0x2000175c

08005b3c <bsp_uart_int_init>:
 * @param	: uart_int_priority: interrupt priority, (0x00 - 0xf0) e.g. 0xc0, low 4 bits zero
 * @return	: 0 = success; fail traps to 'panic_leds'
*******************************************************************************/

int bsp_uart_int_init(u32 iuart, u32 baud, u32 rxbuffsize, u32 txbuffsize,  u32 uart_int_priority)
{
 8005b3c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8005b40:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
	u32 cb_Idx;
	struct UARTPINS uartpins;

	if ((uart_int_priority & 0xf) != 0) bsp_panic(-3); // Bogus priority
 8005b44:	f018 0f0f 	tst.w	r8, #15
 * @param	: uart_int_priority: interrupt priority, (0x00 - 0xf0) e.g. 0xc0, low 4 bits zero
 * @return	: 0 = success; fail traps to 'panic_leds'
*******************************************************************************/

int bsp_uart_int_init(u32 iuart, u32 baud, u32 rxbuffsize, u32 txbuffsize,  u32 uart_int_priority)
{
 8005b48:	4604      	mov	r4, r0
 8005b4a:	460e      	mov	r6, r1
 8005b4c:	4615      	mov	r5, r2
 8005b4e:	4699      	mov	r9, r3
	u32 cb_Idx;
	struct UARTPINS uartpins;

	if ((uart_int_priority & 0xf) != 0) bsp_panic(-3); // Bogus priority
 8005b50:	d003      	beq.n	8005b5a <bsp_uart_int_init+0x1e>
 8005b52:	f06f 0002 	mvn.w	r0, #2
 8005b56:	f7ff fc91 	bl	800547c <bsp_panic>
	
	/* Map usart/uart register base to control block index & and enable APBxENR for USART/UART */
	cb_Idx = mapindex(iuart);	
 8005b5a:	4620      	mov	r0, r4
 8005b5c:	f7ff fc96 	bl	800548c <mapindex>
		
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
 8005b60:	4b23      	ldr	r3, [pc, #140]	; (8005bf0 <bsp_uart_int_init+0xb4>)
 8005b62:	0182      	lsls	r2, r0, #6
 8005b64:	1899      	adds	r1, r3, r2
	struct UARTPINS uartpins;

	if ((uart_int_priority & 0xf) != 0) bsp_panic(-3); // Bogus priority
	
	/* Map usart/uart register base to control block index & and enable APBxENR for USART/UART */
	cb_Idx = mapindex(iuart);	
 8005b66:	4607      	mov	r7, r0
		
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
	cb_uart[cb_Idx].flag = 1;	// Show this setup for interrupt driven
 8005b68:	2001      	movs	r0, #1
 8005b6a:	6148      	str	r0, [r1, #20]
	if ((uart_int_priority & 0xf) != 0) bsp_panic(-3); // Bogus priority
	
	/* Map usart/uart register base to control block index & and enable APBxENR for USART/UART */
	cb_Idx = mapindex(iuart);	
		
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
 8005b6c:	608c      	str	r4, [r1, #8]
	cb_uart[cb_Idx].flag = 1;	// Show this setup for interrupt driven

	/* Mapping adjusted file number to a control block pointer */
	cb_map[cb_Idx] = &cb_uart[cb_Idx];
 8005b6e:	eb03 0187 	add.w	r1, r3, r7, lsl #2
 8005b72:	3304      	adds	r3, #4
 8005b74:	189a      	adds	r2, r3, r2
 8005b76:	f8c1 2208 	str.w	r2, [r1, #520]	; 0x208

	/* Set up UART pins, port & uart clockings.  THIS IS BOARD SPECIFIC */
	if (uart_pins(iuart, &uartpins) != 0) bsp_panic(-15);
 8005b7a:	4620      	mov	r0, r4
 8005b7c:	4669      	mov	r1, sp
 8005b7e:	f000 f895 	bl	8005cac <uart_pins>
 8005b82:	b118      	cbz	r0, 8005b8c <bsp_uart_int_init+0x50>
 8005b84:	f06f 000e 	mvn.w	r0, #14
 8005b88:	f7ff fc78 	bl	800547c <bsp_panic>

	/* Setup baud rate */
	usartx_setbaud (iuart, uartpins.pclk, baud);
 8005b8c:	4620      	mov	r0, r4
 8005b8e:	9900      	ldr	r1, [sp, #0]
 8005b90:	4632      	mov	r2, r6
 8005b92:	f000 f955 	bl	8005e40 <usartx_setbaud>

	/* Obtain some buffer space */
	getbuff(cb_Idx, rxbuffsize, txbuffsize);
 8005b96:	4629      	mov	r1, r5
 8005b98:	464a      	mov	r2, r9
 8005b9a:	4638      	mov	r0, r7
 8005b9c:	f7ff fccc 	bl	8005538 <getbuff>
	/* Setup CR2 ------------------------------------------------------------------- */
	/* After reset CR2 is 0x0000 and this is just fine */

	/* Set up CR1 ---------------------------------------------------- */
	//                    UE       RXNEIE    TE       RE
	USART_CR1(iuart) |= (1<<13) | (1<<5) | (1<<3) | (1<<2);
 8005ba0:	68e3      	ldr	r3, [r4, #12]
 8005ba2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8005ba6:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
 8005baa:	60e3      	str	r3, [r4, #12]

	/* UART interrupt */
	NVICIPR (uartpins.irqnumber, uart_int_priority);	// Set uart interrupt priority (tx)
 8005bac:	9a01      	ldr	r2, [sp, #4]
 8005bae:	f022 0303 	bic.w	r3, r2, #3
 8005bb2:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8005bb6:	f503 4364 	add.w	r3, r3, #58368	; 0xe400
 8005bba:	f002 0203 	and.w	r2, r2, #3
 8005bbe:	00d2      	lsls	r2, r2, #3
 8005bc0:	fa08 f802 	lsl.w	r8, r8, r2
 8005bc4:	681a      	ldr	r2, [r3, #0]
 8005bc6:	ea42 0208 	orr.w	r2, r2, r8
 8005bca:	601a      	str	r2, [r3, #0]
	NVICISER(uartpins.irqnumber);				// Enable interrupt
 8005bcc:	9a01      	ldr	r2, [sp, #4]
 8005bce:	4b09      	ldr	r3, [pc, #36]	; (8005bf4 <bsp_uart_int_init+0xb8>)
 8005bd0:	0951      	lsrs	r1, r2, #5
 8005bd2:	18cb      	adds	r3, r1, r3
 8005bd4:	009b      	lsls	r3, r3, #2
 8005bd6:	2101      	movs	r1, #1
 8005bd8:	f002 021f 	and.w	r2, r2, #31
 8005bdc:	fa11 f202 	lsls.w	r2, r1, r2
 8005be0:	6819      	ldr	r1, [r3, #0]
 8005be2:	ea41 0202 	orr.w	r2, r1, r2
 8005be6:	601a      	str	r2, [r3, #0]
	
	return 0;
}
 8005be8:	2000      	movs	r0, #0
 8005bea:	e8bd 83fe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, pc}
 8005bee:	bf00      	nop
 8005bf0:	20001758 	.word	0x20001758
 8005bf4:	38003840 	.word	0x38003840

08005bf8 <bsp_uart_int_init_number>:
 * int bsp_uart_int_init_number(u32 uartnumber, u32 baud,u32 rxbuffsize, u32 txbuffsize, u32 dma_tx_int_priority);
 * @brief	: A wrapper for 'int bsp_uart_int_init' with uart number (1-6) rather than uart base address as the first argument
 * @return	: Same as bsp_uart_int_init
*******************************************************************************/
int bsp_uart_int_init_number(u32 uartnumber, u32 baud, u32 rxbuffsize, u32 txbuffsize,  u32 uart_int_priority)
{
 8005bf8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005bfc:	9f06      	ldr	r7, [sp, #24]
 8005bfe:	460e      	mov	r6, r1
 8005c00:	4615      	mov	r5, r2
 8005c02:	461c      	mov	r4, r3
	u32 iuart = uartnumber_to_baseaddr(uartnumber);
 8005c04:	f7ff fcc4 	bl	8005590 <uartnumber_to_baseaddr>
	return  bsp_uart_int_init(iuart, baud, rxbuffsize, txbuffsize, uart_int_priority);
 8005c08:	4631      	mov	r1, r6
 8005c0a:	462a      	mov	r2, r5
 8005c0c:	4623      	mov	r3, r4
 8005c0e:	9706      	str	r7, [sp, #24]
}
 8005c10:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 * @return	: Same as bsp_uart_int_init
*******************************************************************************/
int bsp_uart_int_init_number(u32 uartnumber, u32 baud, u32 rxbuffsize, u32 txbuffsize,  u32 uart_int_priority)
{
	u32 iuart = uartnumber_to_baseaddr(uartnumber);
	return  bsp_uart_int_init(iuart, baud, rxbuffsize, txbuffsize, uart_int_priority);
 8005c14:	e792      	b.n	8005b3c <bsp_uart_int_init>

08005c16 <UART_IRQHandler>:
void  UART8_IRQHandler(void) {UART_IRQHandler(&cb_uart[7]); return;}

void UART_IRQHandler(struct CB_UART* pctl)
{
	/* Receive */
	if ((USART_SR(pctl->iuart) & USART_SR_RXNE) != 0) // Receive reg loaded?
 8005c16:	6843      	ldr	r3, [r0, #4]
 8005c18:	681b      	ldr	r3, [r3, #0]
 8005c1a:	f013 0f20 	tst.w	r3, #32
void USART6_IRQHandler(void) {UART_IRQHandler(&cb_uart[5]); return;}
void  UART7_IRQHandler(void) {UART_IRQHandler(&cb_uart[6]); return;}
void  UART8_IRQHandler(void) {UART_IRQHandler(&cb_uart[7]); return;}

void UART_IRQHandler(struct CB_UART* pctl)
{
 8005c1e:	b510      	push	{r4, lr}
 8005c20:	4604      	mov	r4, r0
	/* Receive */
	if ((USART_SR(pctl->iuart) & USART_SR_RXNE) != 0) // Receive reg loaded?
 8005c22:	d007      	beq.n	8005c34 <UART_IRQHandler+0x1e>
	{  // Here, receive interrupt flag is on. 
		*pctl->rxbuff_in = USART_DR(pctl->iuart);// Read and store char
 8005c24:	6843      	ldr	r3, [r0, #4]
 8005c26:	685a      	ldr	r2, [r3, #4]
 8005c28:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8005c2a:	701a      	strb	r2, [r3, #0]

		/* Advance pointers to line buffers and array of counts and reset when end reached */	
		pctl->rxbuff_in = rxbuff_adv(pctl, pctl->rxbuff_in);	// Advance pointers common routine
 8005c2c:	6b81      	ldr	r1, [r0, #56]	; 0x38
 8005c2e:	f7ff fbd5 	bl	80053dc <rxbuff_adv>
 8005c32:	63a0      	str	r0, [r4, #56]	; 0x38
	}

	/* Transmit */
	if ( (USART_CR1(pctl->iuart) & USART_CR1_TXEIE) != 0)
 8005c34:	6863      	ldr	r3, [r4, #4]
 8005c36:	68db      	ldr	r3, [r3, #12]
 8005c38:	f013 0f80 	tst.w	r3, #128	; 0x80
 8005c3c:	d014      	beq.n	8005c68 <UART_IRQHandler+0x52>
	{  // Here, yes.  Transmit interrupts are enabled so check if a tx interrupt
		if ( (USART_SR(pctl->iuart) & USART_SR_TXE) != 0) // Transmit register empty?
 8005c3e:	6863      	ldr	r3, [r4, #4]
 8005c40:	681b      	ldr	r3, [r3, #0]
 8005c42:	f013 0f80 	tst.w	r3, #128	; 0x80
 8005c46:	d00f      	beq.n	8005c68 <UART_IRQHandler+0x52>
		{ // Here, yes.
			USART_DR(pctl->iuart) = *pctl->txbuff_out;// Send next char, step pointer
 8005c48:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8005c4a:	6863      	ldr	r3, [r4, #4]
 8005c4c:	780a      	ldrb	r2, [r1, #0]

			/* Advance output pointer */
			pctl->txbuff_out = txbuff_adv(pctl, pctl->txbuff_out);
 8005c4e:	4620      	mov	r0, r4
	/* Transmit */
	if ( (USART_CR1(pctl->iuart) & USART_CR1_TXEIE) != 0)
	{  // Here, yes.  Transmit interrupts are enabled so check if a tx interrupt
		if ( (USART_SR(pctl->iuart) & USART_SR_TXE) != 0) // Transmit register empty?
		{ // Here, yes.
			USART_DR(pctl->iuart) = *pctl->txbuff_out;// Send next char, step pointer
 8005c50:	605a      	str	r2, [r3, #4]

			/* Advance output pointer */
			pctl->txbuff_out = txbuff_adv(pctl, pctl->txbuff_out);
 8005c52:	f7ff fbca 	bl	80053ea <txbuff_adv>

			/* Was the last byte loaded the last to send? */		
			if (pctl->txbuff_out == pctl->txbuff_in)
 8005c56:	6a23      	ldr	r3, [r4, #32]
		if ( (USART_SR(pctl->iuart) & USART_SR_TXE) != 0) // Transmit register empty?
		{ // Here, yes.
			USART_DR(pctl->iuart) = *pctl->txbuff_out;// Send next char, step pointer

			/* Advance output pointer */
			pctl->txbuff_out = txbuff_adv(pctl, pctl->txbuff_out);
 8005c58:	6260      	str	r0, [r4, #36]	; 0x24

			/* Was the last byte loaded the last to send? */		
			if (pctl->txbuff_out == pctl->txbuff_in)
 8005c5a:	4298      	cmp	r0, r3
 8005c5c:	d104      	bne.n	8005c68 <UART_IRQHandler+0x52>
			{ // Here yes. 
				USART_CR1(pctl->iuart) &= ~USART_CR1_TXEIE;		// Disable Tx interrupt	
 8005c5e:	6863      	ldr	r3, [r4, #4]
 8005c60:	68da      	ldr	r2, [r3, #12]
 8005c62:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8005c66:	60da      	str	r2, [r3, #12]
 8005c68:	bd10      	pop	{r4, pc}

08005c6a <UART8_IRQHandler>:
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
void  UART5_IRQHandler(void) {UART_IRQHandler(&cb_uart[4]); return;}
void USART6_IRQHandler(void) {UART_IRQHandler(&cb_uart[5]); return;}
void  UART7_IRQHandler(void) {UART_IRQHandler(&cb_uart[6]); return;}
void  UART8_IRQHandler(void) {UART_IRQHandler(&cb_uart[7]); return;}
 8005c6a:	4801      	ldr	r0, [pc, #4]	; (8005c70 <UART8_IRQHandler+0x6>)
 8005c6c:	e7d3      	b.n	8005c16 <UART_IRQHandler>
 8005c6e:	bf00      	nop
 8005c70:	2000191c 	.word	0x2000191c

08005c74 <UART7_IRQHandler>:
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
void  UART5_IRQHandler(void) {UART_IRQHandler(&cb_uart[4]); return;}
void USART6_IRQHandler(void) {UART_IRQHandler(&cb_uart[5]); return;}
void  UART7_IRQHandler(void) {UART_IRQHandler(&cb_uart[6]); return;}
 8005c74:	4800      	ldr	r0, [pc, #0]	; (8005c78 <UART7_IRQHandler+0x4>)
 8005c76:	e7ce      	b.n	8005c16 <UART_IRQHandler>
 8005c78:	200018dc 	.word	0x200018dc

08005c7c <USART6_IRQHandler>:
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
void  UART5_IRQHandler(void) {UART_IRQHandler(&cb_uart[4]); return;}
void USART6_IRQHandler(void) {UART_IRQHandler(&cb_uart[5]); return;}
 8005c7c:	4800      	ldr	r0, [pc, #0]	; (8005c80 <USART6_IRQHandler+0x4>)
 8005c7e:	e7ca      	b.n	8005c16 <UART_IRQHandler>
 8005c80:	2000189c 	.word	0x2000189c

08005c84 <UART5_IRQHandler>:
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
void  UART5_IRQHandler(void) {UART_IRQHandler(&cb_uart[4]); return;}
 8005c84:	4800      	ldr	r0, [pc, #0]	; (8005c88 <UART5_IRQHandler+0x4>)
 8005c86:	e7c6      	b.n	8005c16 <UART_IRQHandler>
 8005c88:	2000185c 	.word	0x2000185c

08005c8c <UART4_IRQHandler>:
/* USART/UART interrupts use a common IRQ handler.  Pass the control block pointer. */
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
 8005c8c:	4800      	ldr	r0, [pc, #0]	; (8005c90 <UART4_IRQHandler+0x4>)
 8005c8e:	e7c2      	b.n	8005c16 <UART_IRQHandler>
 8005c90:	2000181c 	.word	0x2000181c

08005c94 <USART3_IRQHandler>:
 *####################################################################################### */
/* USART/UART interrupts use a common IRQ handler.  Pass the control block pointer. */
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
 8005c94:	4800      	ldr	r0, [pc, #0]	; (8005c98 <USART3_IRQHandler+0x4>)
 8005c96:	e7be      	b.n	8005c16 <UART_IRQHandler>
 8005c98:	200017dc 	.word	0x200017dc

08005c9c <USART2_IRQHandler>:
 * ISR routine
 *####################################################################################### */
/* USART/UART interrupts use a common IRQ handler.  Pass the control block pointer. */
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
 8005c9c:	4800      	ldr	r0, [pc, #0]	; (8005ca0 <USART2_IRQHandler+0x4>)
 8005c9e:	e7ba      	b.n	8005c16 <UART_IRQHandler>
 8005ca0:	2000179c 	.word	0x2000179c

08005ca4 <USART1_IRQHandler>:
/*#######################################################################################
 * ISR routine
 *####################################################################################### */
/* USART/UART interrupts use a common IRQ handler.  Pass the control block pointer. */
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
 8005ca4:	4800      	ldr	r0, [pc, #0]	; (8005ca8 <USART1_IRQHandler+0x4>)
 8005ca6:	e7b6      	b.n	8005c16 <UART_IRQHandler>
 8005ca8:	2000175c 	.word	0x2000175c

08005cac <uart_pins>:
 * @param	: p = pointer to register base
 * @param	: pu = pointer to struct with return values
 * @return	: Edit check--0 = OK; not OK - panic_leds(8)
******************************************************************************/	
int uart_pins(u32 iuart, struct UARTPINS* pu)
{
 8005cac:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

	struct PINCONFIG	pin_uarttx = { \
 8005cae:	4a56      	ldr	r2, [pc, #344]	; (8005e08 <uart_pins+0x15c>)
 * @param	: p = pointer to register base
 * @param	: pu = pointer to struct with return values
 * @return	: Edit check--0 = OK; not OK - panic_leds(8)
******************************************************************************/	
int uart_pins(u32 iuart, struct UARTPINS* pu)
{
 8005cb0:	4603      	mov	r3, r0

	struct PINCONFIG	pin_uarttx = { \
 8005cb2:	6810      	ldr	r0, [r2, #0]
 8005cb4:	9002      	str	r0, [sp, #8]
 8005cb6:	7910      	ldrb	r0, [r2, #4]
 8005cb8:	f88d 000c 	strb.w	r0, [sp, #12]
		GPIO_OTYPE_PP, 		// output type: push-pull 		
		GPIO_OSPEED_100MHZ, 	// speed: highest drive level
		GPIO_PUPD_NONE, 	// pull up/down: none
		0 };			// Alternate function code: to be filled in

	struct PINCONFIG	pin_uartrx = { \
 8005cbc:	f852 0f05 	ldr.w	r0, [r2, #5]!
 8005cc0:	7912      	ldrb	r2, [r2, #4]
 8005cc2:	9000      	str	r0, [sp, #0]
 8005cc4:	f88d 2004 	strb.w	r2, [sp, #4]
	u32	txport;
	u32	rxport;

	/* THIS IS BOARD SPECIFIC */
	// Set ports, pins, alternate function code, bus clock freq, and enable peripheral clock
	switch (iuart)
 8005cc8:	4a50      	ldr	r2, [pc, #320]	; (8005e0c <uart_pins+0x160>)
 8005cca:	4293      	cmp	r3, r2
 8005ccc:	d04f      	beq.n	8005d6e <uart_pins+0xc2>
 8005cce:	d807      	bhi.n	8005ce0 <uart_pins+0x34>
 8005cd0:	4a4f      	ldr	r2, [pc, #316]	; (8005e10 <uart_pins+0x164>)
 8005cd2:	4293      	cmp	r3, r2
 8005cd4:	d023      	beq.n	8005d1e <uart_pins+0x72>
 8005cd6:	4a4f      	ldr	r2, [pc, #316]	; (8005e14 <uart_pins+0x168>)
 8005cd8:	4293      	cmp	r3, r2
 8005cda:	f040 8091 	bne.w	8005e00 <uart_pins+0x154>
 8005cde:	e032      	b.n	8005d46 <uart_pins+0x9a>
 8005ce0:	4a4d      	ldr	r2, [pc, #308]	; (8005e18 <uart_pins+0x16c>)
 8005ce2:	4293      	cmp	r3, r2
 8005ce4:	d007      	beq.n	8005cf6 <uart_pins+0x4a>
 8005ce6:	4a4d      	ldr	r2, [pc, #308]	; (8005e1c <uart_pins+0x170>)
 8005ce8:	4293      	cmp	r3, r2
 8005cea:	d068      	beq.n	8005dbe <uart_pins+0x112>
 8005cec:	4a4c      	ldr	r2, [pc, #304]	; (8005e20 <uart_pins+0x174>)
 8005cee:	4293      	cmp	r3, r2
 8005cf0:	f040 8086 	bne.w	8005e00 <uart_pins+0x154>
 8005cf4:	e04f      	b.n	8005d96 <uart_pins+0xea>
	{
		case USART1:
			rxport = GPIOA; txport = GPIOA; txpin = 9; rxpin = 10; af = 7; pu->pclk = pclk2_freq;
 8005cf6:	4b4b      	ldr	r3, [pc, #300]	; (8005e24 <uart_pins+0x178>)
 8005cf8:	4c4b      	ldr	r4, [pc, #300]	; (8005e28 <uart_pins+0x17c>)
 8005cfa:	681b      	ldr	r3, [r3, #0]
 8005cfc:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x01;	// Port A
 8005cfe:	4b4b      	ldr	r3, [pc, #300]	; (8005e2c <uart_pins+0x180>)
 8005d00:	681a      	ldr	r2, [r3, #0]
 8005d02:	f042 0201 	orr.w	r2, r2, #1
 8005d06:	601a      	str	r2, [r3, #0]
//			rxport = GPIOB; txport = GPIOB; txpin = 6; rxpin =  7; af = 7; pu->pclk = pclk2_freq;
//			RCC_AHB1ENR |= 0x02;	// Port B
			RCC_APB2ENR |= (1<<4); // Enable peripheral clock
 8005d08:	695a      	ldr	r2, [r3, #20]
 8005d0a:	f042 0210 	orr.w	r2, r2, #16
 8005d0e:	615a      	str	r2, [r3, #20]
			pu->irqnumber = UART1_IRQ_NUMBER;
 8005d10:	2325      	movs	r3, #37	; 0x25
 8005d12:	604b      	str	r3, [r1, #4]
	/* THIS IS BOARD SPECIFIC */
	// Set ports, pins, alternate function code, bus clock freq, and enable peripheral clock
	switch (iuart)
	{
		case USART1:
			rxport = GPIOA; txport = GPIOA; txpin = 9; rxpin = 10; af = 7; pu->pclk = pclk2_freq;
 8005d14:	4620      	mov	r0, r4
 8005d16:	2607      	movs	r6, #7
 8005d18:	2109      	movs	r1, #9
 8005d1a:	250a      	movs	r5, #10
			RCC_AHB1ENR |= 0x01;	// Port A
//			rxport = GPIOB; txport = GPIOB; txpin = 6; rxpin =  7; af = 7; pu->pclk = pclk2_freq;
//			RCC_AHB1ENR |= 0x02;	// Port B
			RCC_APB2ENR |= (1<<4); // Enable peripheral clock
			pu->irqnumber = UART1_IRQ_NUMBER;
			break;
 8005d1c:	e062      	b.n	8005de4 <uart_pins+0x138>

		case (u32)USART2:
			rxport = GPIOA; txport = GPIOA; txpin = 2; rxpin =  3; af = 7; pu->pclk = pclk1_freq;
 8005d1e:	4b44      	ldr	r3, [pc, #272]	; (8005e30 <uart_pins+0x184>)
 8005d20:	4c41      	ldr	r4, [pc, #260]	; (8005e28 <uart_pins+0x17c>)
 8005d22:	681b      	ldr	r3, [r3, #0]
 8005d24:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x01;	// Port A
 8005d26:	4b41      	ldr	r3, [pc, #260]	; (8005e2c <uart_pins+0x180>)
 8005d28:	681a      	ldr	r2, [r3, #0]
 8005d2a:	f042 0201 	orr.w	r2, r2, #1
 8005d2e:	601a      	str	r2, [r3, #0]
//			rxport = GPIOD; txport = GPIOD; txpin = 5; rxpin =  6; af = 7; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x08;	// Port D
			RCC_APB1ENR |= (1<<17); // Enable peripheral clock
 8005d30:	691a      	ldr	r2, [r3, #16]
 8005d32:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8005d36:	611a      	str	r2, [r3, #16]
			pu->irqnumber = UART2_IRQ_NUMBER;
 8005d38:	2326      	movs	r3, #38	; 0x26
 8005d3a:	604b      	str	r3, [r1, #4]
			RCC_APB2ENR |= (1<<4); // Enable peripheral clock
			pu->irqnumber = UART1_IRQ_NUMBER;
			break;

		case (u32)USART2:
			rxport = GPIOA; txport = GPIOA; txpin = 2; rxpin =  3; af = 7; pu->pclk = pclk1_freq;
 8005d3c:	4620      	mov	r0, r4
 8005d3e:	2607      	movs	r6, #7
 8005d40:	2102      	movs	r1, #2
 8005d42:	2503      	movs	r5, #3
			RCC_AHB1ENR |= 0x01;	// Port A
//			rxport = GPIOD; txport = GPIOD; txpin = 5; rxpin =  6; af = 7; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x08;	// Port D
			RCC_APB1ENR |= (1<<17); // Enable peripheral clock
			pu->irqnumber = UART2_IRQ_NUMBER;
			break;
 8005d44:	e04e      	b.n	8005de4 <uart_pins+0x138>
			
		case (u32)USART3:
			rxport = GPIOB; txport = GPIOB; txpin = 10; rxpin = 11; af = 7; pu->pclk = pclk1_freq;
 8005d46:	4b3a      	ldr	r3, [pc, #232]	; (8005e30 <uart_pins+0x184>)
 8005d48:	4c3a      	ldr	r4, [pc, #232]	; (8005e34 <uart_pins+0x188>)
 8005d4a:	681b      	ldr	r3, [r3, #0]
 8005d4c:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x02;	// Port B
 8005d4e:	4b37      	ldr	r3, [pc, #220]	; (8005e2c <uart_pins+0x180>)
 8005d50:	681a      	ldr	r2, [r3, #0]
 8005d52:	f042 0202 	orr.w	r2, r2, #2
 8005d56:	601a      	str	r2, [r3, #0]
//			rxport = GPIOD; txport = GPIOD; txpin =  8; rxpin =  9; af = 7; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x08;	// Port D
			RCC_APB1ENR |= (1<<18); // Enable peripheral clock
 8005d58:	691a      	ldr	r2, [r3, #16]
 8005d5a:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8005d5e:	611a      	str	r2, [r3, #16]
			pu->irqnumber = UART3_IRQ_NUMBER;
 8005d60:	2327      	movs	r3, #39	; 0x27
 8005d62:	604b      	str	r3, [r1, #4]
			RCC_APB1ENR |= (1<<17); // Enable peripheral clock
			pu->irqnumber = UART2_IRQ_NUMBER;
			break;
			
		case (u32)USART3:
			rxport = GPIOB; txport = GPIOB; txpin = 10; rxpin = 11; af = 7; pu->pclk = pclk1_freq;
 8005d64:	4620      	mov	r0, r4
 8005d66:	2607      	movs	r6, #7
 8005d68:	210a      	movs	r1, #10
 8005d6a:	250b      	movs	r5, #11
			RCC_AHB1ENR |= 0x02;	// Port B
//			rxport = GPIOD; txport = GPIOD; txpin =  8; rxpin =  9; af = 7; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x08;	// Port D
			RCC_APB1ENR |= (1<<18); // Enable peripheral clock
			pu->irqnumber = UART3_IRQ_NUMBER;
			break;
 8005d6c:	e03a      	b.n	8005de4 <uart_pins+0x138>

		case (u32)UART4:
			rxport = GPIOA; txport = GPIOA; txpin =  0; rxpin =  1; af = 8; pu->pclk = pclk1_freq;
 8005d6e:	4b30      	ldr	r3, [pc, #192]	; (8005e30 <uart_pins+0x184>)
 8005d70:	4c2d      	ldr	r4, [pc, #180]	; (8005e28 <uart_pins+0x17c>)
 8005d72:	681b      	ldr	r3, [r3, #0]
 8005d74:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x01;	// Port A
 8005d76:	4b2d      	ldr	r3, [pc, #180]	; (8005e2c <uart_pins+0x180>)
 8005d78:	681a      	ldr	r2, [r3, #0]
 8005d7a:	f042 0201 	orr.w	r2, r2, #1
 8005d7e:	601a      	str	r2, [r3, #0]
//			rxport = GPIOC; txport = GPIOC; txpin = 10; rxpin = 11; af = 8; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x04;	// Port C
			RCC_APB1ENR |= (1<<19); // Enable peripheral clock
 8005d80:	691a      	ldr	r2, [r3, #16]
 8005d82:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8005d86:	611a      	str	r2, [r3, #16]
			pu->irqnumber = UART4_IRQ_NUMBER;
 8005d88:	2334      	movs	r3, #52	; 0x34
 8005d8a:	604b      	str	r3, [r1, #4]
			RCC_APB1ENR |= (1<<18); // Enable peripheral clock
			pu->irqnumber = UART3_IRQ_NUMBER;
			break;

		case (u32)UART4:
			rxport = GPIOA; txport = GPIOA; txpin =  0; rxpin =  1; af = 8; pu->pclk = pclk1_freq;
 8005d8c:	4620      	mov	r0, r4
 8005d8e:	2608      	movs	r6, #8
 8005d90:	2100      	movs	r1, #0
 8005d92:	2501      	movs	r5, #1
			RCC_AHB1ENR |= 0x01;	// Port A
//			rxport = GPIOC; txport = GPIOC; txpin = 10; rxpin = 11; af = 8; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x04;	// Port C
			RCC_APB1ENR |= (1<<19); // Enable peripheral clock
			pu->irqnumber = UART4_IRQ_NUMBER;
			break;
 8005d94:	e026      	b.n	8005de4 <uart_pins+0x138>

		case (u32)UART5:
			txport = GPIOC; rxport = GPIOD; txpin = 12; rxpin =  2; af = 8; pu->pclk = pclk1_freq;
 8005d96:	4b26      	ldr	r3, [pc, #152]	; (8005e30 <uart_pins+0x184>)
 8005d98:	4c27      	ldr	r4, [pc, #156]	; (8005e38 <uart_pins+0x18c>)
 8005d9a:	681b      	ldr	r3, [r3, #0]
 8005d9c:	4827      	ldr	r0, [pc, #156]	; (8005e3c <uart_pins+0x190>)
 8005d9e:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x06;	// Port C & D
 8005da0:	4b22      	ldr	r3, [pc, #136]	; (8005e2c <uart_pins+0x180>)
 8005da2:	681a      	ldr	r2, [r3, #0]
 8005da4:	f042 0206 	orr.w	r2, r2, #6
 8005da8:	601a      	str	r2, [r3, #0]
			RCC_APB1ENR |= (1<<20); // Enable peripheral clock
 8005daa:	691a      	ldr	r2, [r3, #16]
 8005dac:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8005db0:	611a      	str	r2, [r3, #16]
			pu->irqnumber = UART5_IRQ_NUMBER;
 8005db2:	2335      	movs	r3, #53	; 0x35
 8005db4:	604b      	str	r3, [r1, #4]
			RCC_APB1ENR |= (1<<19); // Enable peripheral clock
			pu->irqnumber = UART4_IRQ_NUMBER;
			break;

		case (u32)UART5:
			txport = GPIOC; rxport = GPIOD; txpin = 12; rxpin =  2; af = 8; pu->pclk = pclk1_freq;
 8005db6:	2608      	movs	r6, #8
 8005db8:	210c      	movs	r1, #12
 8005dba:	2502      	movs	r5, #2
			RCC_AHB1ENR |= 0x06;	// Port C & D
			RCC_APB1ENR |= (1<<20); // Enable peripheral clock
			pu->irqnumber = UART5_IRQ_NUMBER;
			break;
 8005dbc:	e012      	b.n	8005de4 <uart_pins+0x138>

		case (u32)USART6:
			txport = GPIOC; rxport = GPIOC; txpin =  6; rxpin =  7; af = 8; pu->pclk = pclk2_freq;
 8005dbe:	4b19      	ldr	r3, [pc, #100]	; (8005e24 <uart_pins+0x178>)
 8005dc0:	4c1e      	ldr	r4, [pc, #120]	; (8005e3c <uart_pins+0x190>)
 8005dc2:	681b      	ldr	r3, [r3, #0]
 8005dc4:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x04;	// Port C
 8005dc6:	4b19      	ldr	r3, [pc, #100]	; (8005e2c <uart_pins+0x180>)
 8005dc8:	681a      	ldr	r2, [r3, #0]
 8005dca:	f042 0204 	orr.w	r2, r2, #4
 8005dce:	601a      	str	r2, [r3, #0]
			RCC_APB2ENR |= (1<<5); 	// Enable peripheral clock
 8005dd0:	695a      	ldr	r2, [r3, #20]
 8005dd2:	f042 0220 	orr.w	r2, r2, #32
 8005dd6:	615a      	str	r2, [r3, #20]
			pu->irqnumber = UART6_IRQ_NUMBER;			
 8005dd8:	2347      	movs	r3, #71	; 0x47
 8005dda:	604b      	str	r3, [r1, #4]
			RCC_APB1ENR |= (1<<20); // Enable peripheral clock
			pu->irqnumber = UART5_IRQ_NUMBER;
			break;

		case (u32)USART6:
			txport = GPIOC; rxport = GPIOC; txpin =  6; rxpin =  7; af = 8; pu->pclk = pclk2_freq;
 8005ddc:	4620      	mov	r0, r4
 8005dde:	2608      	movs	r6, #8
 8005de0:	2106      	movs	r1, #6
 8005de2:	2507      	movs	r5, #7
			return -1;	// Pin assignments: Shouldn't happen
	}

	/* Configure tx pin */
	pin_uarttx.afrl = af;
	f4gpiopins_Config ((volatile u32*)txport, txpin, (struct PINCONFIG*)&pin_uarttx);
 8005de4:	aa02      	add	r2, sp, #8
		default:
			return -1;	// Pin assignments: Shouldn't happen
	}

	/* Configure tx pin */
	pin_uarttx.afrl = af;
 8005de6:	f88d 600c 	strb.w	r6, [sp, #12]
	f4gpiopins_Config ((volatile u32*)txport, txpin, (struct PINCONFIG*)&pin_uarttx);
 8005dea:	f7fe fbc6 	bl	800457a <f4gpiopins_Config>

	/* Configure rx pin */
	pin_uartrx.afrl = af;
	f4gpiopins_Config ((volatile u32*)rxport, rxpin, (struct PINCONFIG*)&pin_uartrx);
 8005dee:	4620      	mov	r0, r4
 8005df0:	4629      	mov	r1, r5
 8005df2:	466a      	mov	r2, sp
	/* Configure tx pin */
	pin_uarttx.afrl = af;
	f4gpiopins_Config ((volatile u32*)txport, txpin, (struct PINCONFIG*)&pin_uarttx);

	/* Configure rx pin */
	pin_uartrx.afrl = af;
 8005df4:	f88d 6004 	strb.w	r6, [sp, #4]
	f4gpiopins_Config ((volatile u32*)rxport, rxpin, (struct PINCONFIG*)&pin_uartrx);
 8005df8:	f7fe fbbf 	bl	800457a <f4gpiopins_Config>

	return 0;
 8005dfc:	2000      	movs	r0, #0
 8005dfe:	e001      	b.n	8005e04 <uart_pins+0x158>
			RCC_APB2ENR |= (1<<5); 	// Enable peripheral clock
			pu->irqnumber = UART6_IRQ_NUMBER;			
			break;

		default:
			return -1;	// Pin assignments: Shouldn't happen
 8005e00:	f04f 30ff 	mov.w	r0, #4294967295
	/* Configure rx pin */
	pin_uartrx.afrl = af;
	f4gpiopins_Config ((volatile u32*)rxport, rxpin, (struct PINCONFIG*)&pin_uartrx);

	return 0;
}
 8005e04:	b004      	add	sp, #16
 8005e06:	bd70      	pop	{r4, r5, r6, pc}
 8005e08:	0800cf38 	.word	0x0800cf38
 8005e0c:	40004c00 	.word	0x40004c00
 8005e10:	40004400 	.word	0x40004400
 8005e14:	40004800 	.word	0x40004800
 8005e18:	40011000 	.word	0x40011000
 8005e1c:	40011400 	.word	0x40011400
 8005e20:	40005000 	.word	0x40005000
 8005e24:	200016c8 	.word	0x200016c8
 8005e28:	40020000 	.word	0x40020000
 8005e2c:	40023830 	.word	0x40023830
 8005e30:	200016c4 	.word	0x200016c4
 8005e34:	40020400 	.word	0x40020400
 8005e38:	40020c00 	.word	0x40020c00
 8005e3c:	40020800 	.word	0x40020800

08005e40 <usartx_setbaud>:
	u32 tmpreg = 0x00;
	u32 fractionaldivider = 0x00;
	u32 integerdivider = 0x00;

	/* Determine the integer part */
	integerdivider = ((0x19 * pclk_freq) / (0x04 * u32BaudRate));
 8005e40:	2319      	movs	r3, #25
 8005e42:	434b      	muls	r3, r1
 8005e44:	0092      	lsls	r2, r2, #2
 8005e46:	fbb3 f3f2 	udiv	r3, r3, r2
	tmpreg = (integerdivider / 0x64) << 0x04;
 8005e4a:	2164      	movs	r1, #100	; 0x64
 * void usartx_setbaud (u32 usartx, u32 pclk_freq, u32 u32BaudRate);
 * @brief	: set baudrate register (BRR)
 * @param	: u32BaudRate is the baud rate.
******************************************************************************/
void usartx_setbaud (u32 usartx, u32 pclk_freq, u32 u32BaudRate)
{
 8005e4c:	b510      	push	{r4, lr}
	u32 fractionaldivider = 0x00;
	u32 integerdivider = 0x00;

	/* Determine the integer part */
	integerdivider = ((0x19 * pclk_freq) / (0x04 * u32BaudRate));
	tmpreg = (integerdivider / 0x64) << 0x04;
 8005e4e:	fbb3 f4f1 	udiv	r4, r3, r1
 8005e52:	0124      	lsls	r4, r4, #4

	/* Determine the fractional part */
	fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
 8005e54:	0922      	lsrs	r2, r4, #4
 8005e56:	fb01 3312 	mls	r3, r1, r2, r3
	tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((u8)0x0F);
 8005e5a:	011b      	lsls	r3, r3, #4
 8005e5c:	3332      	adds	r3, #50	; 0x32
 8005e5e:	fbb3 f1f1 	udiv	r1, r3, r1
 8005e62:	f001 010f 	and.w	r1, r1, #15
 8005e66:	ea41 0404 	orr.w	r4, r1, r4

	/* Set USART BRR --------------------------------------------------------------- */
	  USART_BRR(usartx) = (u16)tmpreg;
 8005e6a:	b2a4      	uxth	r4, r4
 8005e6c:	6084      	str	r4, [r0, #8]
	return;
}
 8005e6e:	bd10      	pop	{r4, pc}

08005e70 <__aeabi_drsub>:
 8005e70:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8005e74:	e002      	b.n	8005e7c <__adddf3>
 8005e76:	bf00      	nop

08005e78 <__aeabi_dsub>:
 8005e78:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08005e7c <__adddf3>:
 8005e7c:	b530      	push	{r4, r5, lr}
 8005e7e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8005e82:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8005e86:	ea94 0f05 	teq	r4, r5
 8005e8a:	bf08      	it	eq
 8005e8c:	ea90 0f02 	teqeq	r0, r2
 8005e90:	bf1f      	itttt	ne
 8005e92:	ea54 0c00 	orrsne.w	ip, r4, r0
 8005e96:	ea55 0c02 	orrsne.w	ip, r5, r2
 8005e9a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8005e9e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8005ea2:	f000 80e2 	beq.w	800606a <__adddf3+0x1ee>
 8005ea6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8005eaa:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8005eae:	bfb8      	it	lt
 8005eb0:	426d      	neglt	r5, r5
 8005eb2:	dd0c      	ble.n	8005ece <__adddf3+0x52>
 8005eb4:	442c      	add	r4, r5
 8005eb6:	ea80 0202 	eor.w	r2, r0, r2
 8005eba:	ea81 0303 	eor.w	r3, r1, r3
 8005ebe:	ea82 0000 	eor.w	r0, r2, r0
 8005ec2:	ea83 0101 	eor.w	r1, r3, r1
 8005ec6:	ea80 0202 	eor.w	r2, r0, r2
 8005eca:	ea81 0303 	eor.w	r3, r1, r3
 8005ece:	2d36      	cmp	r5, #54	; 0x36
 8005ed0:	bf88      	it	hi
 8005ed2:	bd30      	pophi	{r4, r5, pc}
 8005ed4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8005ed8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8005edc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8005ee0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8005ee4:	d002      	beq.n	8005eec <__adddf3+0x70>
 8005ee6:	4240      	negs	r0, r0
 8005ee8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8005eec:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8005ef0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8005ef4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8005ef8:	d002      	beq.n	8005f00 <__adddf3+0x84>
 8005efa:	4252      	negs	r2, r2
 8005efc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8005f00:	ea94 0f05 	teq	r4, r5
 8005f04:	f000 80a7 	beq.w	8006056 <__adddf3+0x1da>
 8005f08:	f1a4 0401 	sub.w	r4, r4, #1
 8005f0c:	f1d5 0e20 	rsbs	lr, r5, #32
 8005f10:	db0d      	blt.n	8005f2e <__adddf3+0xb2>
 8005f12:	fa02 fc0e 	lsl.w	ip, r2, lr
 8005f16:	fa22 f205 	lsr.w	r2, r2, r5
 8005f1a:	1880      	adds	r0, r0, r2
 8005f1c:	f141 0100 	adc.w	r1, r1, #0
 8005f20:	fa03 f20e 	lsl.w	r2, r3, lr
 8005f24:	1880      	adds	r0, r0, r2
 8005f26:	fa43 f305 	asr.w	r3, r3, r5
 8005f2a:	4159      	adcs	r1, r3
 8005f2c:	e00e      	b.n	8005f4c <__adddf3+0xd0>
 8005f2e:	f1a5 0520 	sub.w	r5, r5, #32
 8005f32:	f10e 0e20 	add.w	lr, lr, #32
 8005f36:	2a01      	cmp	r2, #1
 8005f38:	fa03 fc0e 	lsl.w	ip, r3, lr
 8005f3c:	bf28      	it	cs
 8005f3e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8005f42:	fa43 f305 	asr.w	r3, r3, r5
 8005f46:	18c0      	adds	r0, r0, r3
 8005f48:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8005f4c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8005f50:	d507      	bpl.n	8005f62 <__adddf3+0xe6>
 8005f52:	f04f 0e00 	mov.w	lr, #0
 8005f56:	f1dc 0c00 	rsbs	ip, ip, #0
 8005f5a:	eb7e 0000 	sbcs.w	r0, lr, r0
 8005f5e:	eb6e 0101 	sbc.w	r1, lr, r1
 8005f62:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8005f66:	d31b      	bcc.n	8005fa0 <__adddf3+0x124>
 8005f68:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8005f6c:	d30c      	bcc.n	8005f88 <__adddf3+0x10c>
 8005f6e:	0849      	lsrs	r1, r1, #1
 8005f70:	ea5f 0030 	movs.w	r0, r0, rrx
 8005f74:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8005f78:	f104 0401 	add.w	r4, r4, #1
 8005f7c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8005f80:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8005f84:	f080 809a 	bcs.w	80060bc <__adddf3+0x240>
 8005f88:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8005f8c:	bf08      	it	eq
 8005f8e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8005f92:	f150 0000 	adcs.w	r0, r0, #0
 8005f96:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8005f9a:	ea41 0105 	orr.w	r1, r1, r5
 8005f9e:	bd30      	pop	{r4, r5, pc}
 8005fa0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8005fa4:	4140      	adcs	r0, r0
 8005fa6:	eb41 0101 	adc.w	r1, r1, r1
 8005faa:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8005fae:	f1a4 0401 	sub.w	r4, r4, #1
 8005fb2:	d1e9      	bne.n	8005f88 <__adddf3+0x10c>
 8005fb4:	f091 0f00 	teq	r1, #0
 8005fb8:	bf04      	itt	eq
 8005fba:	4601      	moveq	r1, r0
 8005fbc:	2000      	moveq	r0, #0
 8005fbe:	fab1 f381 	clz	r3, r1
 8005fc2:	bf08      	it	eq
 8005fc4:	3320      	addeq	r3, #32
 8005fc6:	f1a3 030b 	sub.w	r3, r3, #11
 8005fca:	f1b3 0220 	subs.w	r2, r3, #32
 8005fce:	da0c      	bge.n	8005fea <__adddf3+0x16e>
 8005fd0:	320c      	adds	r2, #12
 8005fd2:	dd08      	ble.n	8005fe6 <__adddf3+0x16a>
 8005fd4:	f102 0c14 	add.w	ip, r2, #20
 8005fd8:	f1c2 020c 	rsb	r2, r2, #12
 8005fdc:	fa01 f00c 	lsl.w	r0, r1, ip
 8005fe0:	fa21 f102 	lsr.w	r1, r1, r2
 8005fe4:	e00c      	b.n	8006000 <__adddf3+0x184>
 8005fe6:	f102 0214 	add.w	r2, r2, #20
 8005fea:	bfd8      	it	le
 8005fec:	f1c2 0c20 	rsble	ip, r2, #32
 8005ff0:	fa01 f102 	lsl.w	r1, r1, r2
 8005ff4:	fa20 fc0c 	lsr.w	ip, r0, ip
 8005ff8:	bfdc      	itt	le
 8005ffa:	ea41 010c 	orrle.w	r1, r1, ip
 8005ffe:	4090      	lslle	r0, r2
 8006000:	1ae4      	subs	r4, r4, r3
 8006002:	bfa2      	ittt	ge
 8006004:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8006008:	4329      	orrge	r1, r5
 800600a:	bd30      	popge	{r4, r5, pc}
 800600c:	ea6f 0404 	mvn.w	r4, r4
 8006010:	3c1f      	subs	r4, #31
 8006012:	da1c      	bge.n	800604e <__adddf3+0x1d2>
 8006014:	340c      	adds	r4, #12
 8006016:	dc0e      	bgt.n	8006036 <__adddf3+0x1ba>
 8006018:	f104 0414 	add.w	r4, r4, #20
 800601c:	f1c4 0220 	rsb	r2, r4, #32
 8006020:	fa20 f004 	lsr.w	r0, r0, r4
 8006024:	fa01 f302 	lsl.w	r3, r1, r2
 8006028:	ea40 0003 	orr.w	r0, r0, r3
 800602c:	fa21 f304 	lsr.w	r3, r1, r4
 8006030:	ea45 0103 	orr.w	r1, r5, r3
 8006034:	bd30      	pop	{r4, r5, pc}
 8006036:	f1c4 040c 	rsb	r4, r4, #12
 800603a:	f1c4 0220 	rsb	r2, r4, #32
 800603e:	fa20 f002 	lsr.w	r0, r0, r2
 8006042:	fa01 f304 	lsl.w	r3, r1, r4
 8006046:	ea40 0003 	orr.w	r0, r0, r3
 800604a:	4629      	mov	r1, r5
 800604c:	bd30      	pop	{r4, r5, pc}
 800604e:	fa21 f004 	lsr.w	r0, r1, r4
 8006052:	4629      	mov	r1, r5
 8006054:	bd30      	pop	{r4, r5, pc}
 8006056:	f094 0f00 	teq	r4, #0
 800605a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800605e:	bf06      	itte	eq
 8006060:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8006064:	3401      	addeq	r4, #1
 8006066:	3d01      	subne	r5, #1
 8006068:	e74e      	b.n	8005f08 <__adddf3+0x8c>
 800606a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800606e:	bf18      	it	ne
 8006070:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8006074:	d029      	beq.n	80060ca <__adddf3+0x24e>
 8006076:	ea94 0f05 	teq	r4, r5
 800607a:	bf08      	it	eq
 800607c:	ea90 0f02 	teqeq	r0, r2
 8006080:	d005      	beq.n	800608e <__adddf3+0x212>
 8006082:	ea54 0c00 	orrs.w	ip, r4, r0
 8006086:	bf04      	itt	eq
 8006088:	4619      	moveq	r1, r3
 800608a:	4610      	moveq	r0, r2
 800608c:	bd30      	pop	{r4, r5, pc}
 800608e:	ea91 0f03 	teq	r1, r3
 8006092:	bf1e      	ittt	ne
 8006094:	2100      	movne	r1, #0
 8006096:	2000      	movne	r0, #0
 8006098:	bd30      	popne	{r4, r5, pc}
 800609a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800609e:	d105      	bne.n	80060ac <__adddf3+0x230>
 80060a0:	0040      	lsls	r0, r0, #1
 80060a2:	4149      	adcs	r1, r1
 80060a4:	bf28      	it	cs
 80060a6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80060aa:	bd30      	pop	{r4, r5, pc}
 80060ac:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80060b0:	bf3c      	itt	cc
 80060b2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80060b6:	bd30      	popcc	{r4, r5, pc}
 80060b8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80060bc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80060c0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80060c4:	f04f 0000 	mov.w	r0, #0
 80060c8:	bd30      	pop	{r4, r5, pc}
 80060ca:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80060ce:	bf1a      	itte	ne
 80060d0:	4619      	movne	r1, r3
 80060d2:	4610      	movne	r0, r2
 80060d4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80060d8:	bf1c      	itt	ne
 80060da:	460b      	movne	r3, r1
 80060dc:	4602      	movne	r2, r0
 80060de:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80060e2:	bf06      	itte	eq
 80060e4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80060e8:	ea91 0f03 	teqeq	r1, r3
 80060ec:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80060f0:	bd30      	pop	{r4, r5, pc}
 80060f2:	bf00      	nop

080060f4 <__aeabi_ui2d>:
 80060f4:	f090 0f00 	teq	r0, #0
 80060f8:	bf04      	itt	eq
 80060fa:	2100      	moveq	r1, #0
 80060fc:	4770      	bxeq	lr
 80060fe:	b530      	push	{r4, r5, lr}
 8006100:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8006104:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8006108:	f04f 0500 	mov.w	r5, #0
 800610c:	f04f 0100 	mov.w	r1, #0
 8006110:	e750      	b.n	8005fb4 <__adddf3+0x138>
 8006112:	bf00      	nop

08006114 <__aeabi_i2d>:
 8006114:	f090 0f00 	teq	r0, #0
 8006118:	bf04      	itt	eq
 800611a:	2100      	moveq	r1, #0
 800611c:	4770      	bxeq	lr
 800611e:	b530      	push	{r4, r5, lr}
 8006120:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8006124:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8006128:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800612c:	bf48      	it	mi
 800612e:	4240      	negmi	r0, r0
 8006130:	f04f 0100 	mov.w	r1, #0
 8006134:	e73e      	b.n	8005fb4 <__adddf3+0x138>
 8006136:	bf00      	nop

08006138 <__aeabi_f2d>:
 8006138:	0042      	lsls	r2, r0, #1
 800613a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800613e:	ea4f 0131 	mov.w	r1, r1, rrx
 8006142:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8006146:	bf1f      	itttt	ne
 8006148:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800614c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8006150:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8006154:	4770      	bxne	lr
 8006156:	f092 0f00 	teq	r2, #0
 800615a:	bf14      	ite	ne
 800615c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8006160:	4770      	bxeq	lr
 8006162:	b530      	push	{r4, r5, lr}
 8006164:	f44f 7460 	mov.w	r4, #896	; 0x380
 8006168:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800616c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8006170:	e720      	b.n	8005fb4 <__adddf3+0x138>
 8006172:	bf00      	nop

08006174 <__aeabi_ul2d>:
 8006174:	ea50 0201 	orrs.w	r2, r0, r1
 8006178:	bf08      	it	eq
 800617a:	4770      	bxeq	lr
 800617c:	b530      	push	{r4, r5, lr}
 800617e:	f04f 0500 	mov.w	r5, #0
 8006182:	e00a      	b.n	800619a <__aeabi_l2d+0x16>

08006184 <__aeabi_l2d>:
 8006184:	ea50 0201 	orrs.w	r2, r0, r1
 8006188:	bf08      	it	eq
 800618a:	4770      	bxeq	lr
 800618c:	b530      	push	{r4, r5, lr}
 800618e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8006192:	d502      	bpl.n	800619a <__aeabi_l2d+0x16>
 8006194:	4240      	negs	r0, r0
 8006196:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800619a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800619e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80061a2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80061a6:	f43f aedc 	beq.w	8005f62 <__adddf3+0xe6>
 80061aa:	f04f 0203 	mov.w	r2, #3
 80061ae:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80061b2:	bf18      	it	ne
 80061b4:	3203      	addne	r2, #3
 80061b6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80061ba:	bf18      	it	ne
 80061bc:	3203      	addne	r2, #3
 80061be:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80061c2:	f1c2 0320 	rsb	r3, r2, #32
 80061c6:	fa00 fc03 	lsl.w	ip, r0, r3
 80061ca:	fa20 f002 	lsr.w	r0, r0, r2
 80061ce:	fa01 fe03 	lsl.w	lr, r1, r3
 80061d2:	ea40 000e 	orr.w	r0, r0, lr
 80061d6:	fa21 f102 	lsr.w	r1, r1, r2
 80061da:	4414      	add	r4, r2
 80061dc:	e6c1      	b.n	8005f62 <__adddf3+0xe6>
 80061de:	bf00      	nop

080061e0 <__aeabi_fmul>:
 80061e0:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80061e4:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80061e8:	bf1e      	ittt	ne
 80061ea:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80061ee:	ea92 0f0c 	teqne	r2, ip
 80061f2:	ea93 0f0c 	teqne	r3, ip
 80061f6:	d06f      	beq.n	80062d8 <__aeabi_fmul+0xf8>
 80061f8:	441a      	add	r2, r3
 80061fa:	ea80 0c01 	eor.w	ip, r0, r1
 80061fe:	0240      	lsls	r0, r0, #9
 8006200:	bf18      	it	ne
 8006202:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 8006206:	d01e      	beq.n	8006246 <__aeabi_fmul+0x66>
 8006208:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800620c:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 8006210:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 8006214:	fba0 3101 	umull	r3, r1, r0, r1
 8006218:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 800621c:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8006220:	bf3e      	ittt	cc
 8006222:	0049      	lslcc	r1, r1, #1
 8006224:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 8006228:	005b      	lslcc	r3, r3, #1
 800622a:	ea40 0001 	orr.w	r0, r0, r1
 800622e:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 8006232:	2afd      	cmp	r2, #253	; 0xfd
 8006234:	d81d      	bhi.n	8006272 <__aeabi_fmul+0x92>
 8006236:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 800623a:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 800623e:	bf08      	it	eq
 8006240:	f020 0001 	biceq.w	r0, r0, #1
 8006244:	4770      	bx	lr
 8006246:	f090 0f00 	teq	r0, #0
 800624a:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 800624e:	bf08      	it	eq
 8006250:	0249      	lsleq	r1, r1, #9
 8006252:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8006256:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 800625a:	3a7f      	subs	r2, #127	; 0x7f
 800625c:	bfc2      	ittt	gt
 800625e:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8006262:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8006266:	4770      	bxgt	lr
 8006268:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 800626c:	f04f 0300 	mov.w	r3, #0
 8006270:	3a01      	subs	r2, #1
 8006272:	dc5d      	bgt.n	8006330 <__aeabi_fmul+0x150>
 8006274:	f112 0f19 	cmn.w	r2, #25
 8006278:	bfdc      	itt	le
 800627a:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 800627e:	4770      	bxle	lr
 8006280:	f1c2 0200 	rsb	r2, r2, #0
 8006284:	0041      	lsls	r1, r0, #1
 8006286:	fa21 f102 	lsr.w	r1, r1, r2
 800628a:	f1c2 0220 	rsb	r2, r2, #32
 800628e:	fa00 fc02 	lsl.w	ip, r0, r2
 8006292:	ea5f 0031 	movs.w	r0, r1, rrx
 8006296:	f140 0000 	adc.w	r0, r0, #0
 800629a:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 800629e:	bf08      	it	eq
 80062a0:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80062a4:	4770      	bx	lr
 80062a6:	f092 0f00 	teq	r2, #0
 80062aa:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80062ae:	bf02      	ittt	eq
 80062b0:	0040      	lsleq	r0, r0, #1
 80062b2:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80062b6:	3a01      	subeq	r2, #1
 80062b8:	d0f9      	beq.n	80062ae <__aeabi_fmul+0xce>
 80062ba:	ea40 000c 	orr.w	r0, r0, ip
 80062be:	f093 0f00 	teq	r3, #0
 80062c2:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80062c6:	bf02      	ittt	eq
 80062c8:	0049      	lsleq	r1, r1, #1
 80062ca:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80062ce:	3b01      	subeq	r3, #1
 80062d0:	d0f9      	beq.n	80062c6 <__aeabi_fmul+0xe6>
 80062d2:	ea41 010c 	orr.w	r1, r1, ip
 80062d6:	e78f      	b.n	80061f8 <__aeabi_fmul+0x18>
 80062d8:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80062dc:	ea92 0f0c 	teq	r2, ip
 80062e0:	bf18      	it	ne
 80062e2:	ea93 0f0c 	teqne	r3, ip
 80062e6:	d00a      	beq.n	80062fe <__aeabi_fmul+0x11e>
 80062e8:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80062ec:	bf18      	it	ne
 80062ee:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80062f2:	d1d8      	bne.n	80062a6 <__aeabi_fmul+0xc6>
 80062f4:	ea80 0001 	eor.w	r0, r0, r1
 80062f8:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80062fc:	4770      	bx	lr
 80062fe:	f090 0f00 	teq	r0, #0
 8006302:	bf17      	itett	ne
 8006304:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 8006308:	4608      	moveq	r0, r1
 800630a:	f091 0f00 	teqne	r1, #0
 800630e:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 8006312:	d014      	beq.n	800633e <__aeabi_fmul+0x15e>
 8006314:	ea92 0f0c 	teq	r2, ip
 8006318:	d101      	bne.n	800631e <__aeabi_fmul+0x13e>
 800631a:	0242      	lsls	r2, r0, #9
 800631c:	d10f      	bne.n	800633e <__aeabi_fmul+0x15e>
 800631e:	ea93 0f0c 	teq	r3, ip
 8006322:	d103      	bne.n	800632c <__aeabi_fmul+0x14c>
 8006324:	024b      	lsls	r3, r1, #9
 8006326:	bf18      	it	ne
 8006328:	4608      	movne	r0, r1
 800632a:	d108      	bne.n	800633e <__aeabi_fmul+0x15e>
 800632c:	ea80 0001 	eor.w	r0, r0, r1
 8006330:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8006334:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8006338:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 800633c:	4770      	bx	lr
 800633e:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8006342:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 8006346:	4770      	bx	lr

08006348 <__aeabi_fdiv>:
 8006348:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800634c:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8006350:	bf1e      	ittt	ne
 8006352:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8006356:	ea92 0f0c 	teqne	r2, ip
 800635a:	ea93 0f0c 	teqne	r3, ip
 800635e:	d069      	beq.n	8006434 <__aeabi_fdiv+0xec>
 8006360:	eba2 0203 	sub.w	r2, r2, r3
 8006364:	ea80 0c01 	eor.w	ip, r0, r1
 8006368:	0249      	lsls	r1, r1, #9
 800636a:	ea4f 2040 	mov.w	r0, r0, lsl #9
 800636e:	d037      	beq.n	80063e0 <__aeabi_fdiv+0x98>
 8006370:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8006374:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 8006378:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 800637c:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8006380:	428b      	cmp	r3, r1
 8006382:	bf38      	it	cc
 8006384:	005b      	lslcc	r3, r3, #1
 8006386:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 800638a:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 800638e:	428b      	cmp	r3, r1
 8006390:	bf24      	itt	cs
 8006392:	1a5b      	subcs	r3, r3, r1
 8006394:	ea40 000c 	orrcs.w	r0, r0, ip
 8006398:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 800639c:	bf24      	itt	cs
 800639e:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 80063a2:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80063a6:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 80063aa:	bf24      	itt	cs
 80063ac:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 80063b0:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80063b4:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 80063b8:	bf24      	itt	cs
 80063ba:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 80063be:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80063c2:	011b      	lsls	r3, r3, #4
 80063c4:	bf18      	it	ne
 80063c6:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 80063ca:	d1e0      	bne.n	800638e <__aeabi_fdiv+0x46>
 80063cc:	2afd      	cmp	r2, #253	; 0xfd
 80063ce:	f63f af50 	bhi.w	8006272 <__aeabi_fmul+0x92>
 80063d2:	428b      	cmp	r3, r1
 80063d4:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80063d8:	bf08      	it	eq
 80063da:	f020 0001 	biceq.w	r0, r0, #1
 80063de:	4770      	bx	lr
 80063e0:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80063e4:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80063e8:	327f      	adds	r2, #127	; 0x7f
 80063ea:	bfc2      	ittt	gt
 80063ec:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80063f0:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80063f4:	4770      	bxgt	lr
 80063f6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80063fa:	f04f 0300 	mov.w	r3, #0
 80063fe:	3a01      	subs	r2, #1
 8006400:	e737      	b.n	8006272 <__aeabi_fmul+0x92>
 8006402:	f092 0f00 	teq	r2, #0
 8006406:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 800640a:	bf02      	ittt	eq
 800640c:	0040      	lsleq	r0, r0, #1
 800640e:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8006412:	3a01      	subeq	r2, #1
 8006414:	d0f9      	beq.n	800640a <__aeabi_fdiv+0xc2>
 8006416:	ea40 000c 	orr.w	r0, r0, ip
 800641a:	f093 0f00 	teq	r3, #0
 800641e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8006422:	bf02      	ittt	eq
 8006424:	0049      	lsleq	r1, r1, #1
 8006426:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 800642a:	3b01      	subeq	r3, #1
 800642c:	d0f9      	beq.n	8006422 <__aeabi_fdiv+0xda>
 800642e:	ea41 010c 	orr.w	r1, r1, ip
 8006432:	e795      	b.n	8006360 <__aeabi_fdiv+0x18>
 8006434:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8006438:	ea92 0f0c 	teq	r2, ip
 800643c:	d108      	bne.n	8006450 <__aeabi_fdiv+0x108>
 800643e:	0242      	lsls	r2, r0, #9
 8006440:	f47f af7d 	bne.w	800633e <__aeabi_fmul+0x15e>
 8006444:	ea93 0f0c 	teq	r3, ip
 8006448:	f47f af70 	bne.w	800632c <__aeabi_fmul+0x14c>
 800644c:	4608      	mov	r0, r1
 800644e:	e776      	b.n	800633e <__aeabi_fmul+0x15e>
 8006450:	ea93 0f0c 	teq	r3, ip
 8006454:	d104      	bne.n	8006460 <__aeabi_fdiv+0x118>
 8006456:	024b      	lsls	r3, r1, #9
 8006458:	f43f af4c 	beq.w	80062f4 <__aeabi_fmul+0x114>
 800645c:	4608      	mov	r0, r1
 800645e:	e76e      	b.n	800633e <__aeabi_fmul+0x15e>
 8006460:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8006464:	bf18      	it	ne
 8006466:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 800646a:	d1ca      	bne.n	8006402 <__aeabi_fdiv+0xba>
 800646c:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 8006470:	f47f af5c 	bne.w	800632c <__aeabi_fmul+0x14c>
 8006474:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 8006478:	f47f af3c 	bne.w	80062f4 <__aeabi_fmul+0x114>
 800647c:	e75f      	b.n	800633e <__aeabi_fmul+0x15e>
 800647e:	bf00      	nop

08006480 <__libc_init_array>:
 8006480:	b570      	push	{r4, r5, r6, lr}
 8006482:	f24d 2644 	movw	r6, #53828	; 0xd244
 8006486:	f24d 2544 	movw	r5, #53828	; 0xd244
 800648a:	f6c0 0600 	movt	r6, #2048	; 0x800
 800648e:	f6c0 0500 	movt	r5, #2048	; 0x800
 8006492:	1b76      	subs	r6, r6, r5
 8006494:	10b6      	asrs	r6, r6, #2
 8006496:	d006      	beq.n	80064a6 <__libc_init_array+0x26>
 8006498:	2400      	movs	r4, #0
 800649a:	f855 3b04 	ldr.w	r3, [r5], #4
 800649e:	3401      	adds	r4, #1
 80064a0:	4798      	blx	r3
 80064a2:	42a6      	cmp	r6, r4
 80064a4:	d1f9      	bne.n	800649a <__libc_init_array+0x1a>
 80064a6:	f24d 2644 	movw	r6, #53828	; 0xd244
 80064aa:	f24d 2544 	movw	r5, #53828	; 0xd244
 80064ae:	f6c0 0600 	movt	r6, #2048	; 0x800
 80064b2:	f6c0 0500 	movt	r5, #2048	; 0x800
 80064b6:	1b76      	subs	r6, r6, r5
 80064b8:	f7fa fd8f 	bl	8000fda <_init>
 80064bc:	10b6      	asrs	r6, r6, #2
 80064be:	d006      	beq.n	80064ce <__libc_init_array+0x4e>
 80064c0:	2400      	movs	r4, #0
 80064c2:	f855 3b04 	ldr.w	r3, [r5], #4
 80064c6:	3401      	adds	r4, #1
 80064c8:	4798      	blx	r3
 80064ca:	42a6      	cmp	r6, r4
 80064cc:	d1f9      	bne.n	80064c2 <__libc_init_array+0x42>
 80064ce:	bd70      	pop	{r4, r5, r6, pc}

080064d0 <malloc>:
 80064d0:	f240 2378 	movw	r3, #632	; 0x278
 80064d4:	4601      	mov	r1, r0
 80064d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80064da:	6818      	ldr	r0, [r3, #0]
 80064dc:	f000 b808 	b.w	80064f0 <_malloc_r>

080064e0 <free>:
 80064e0:	f240 2378 	movw	r3, #632	; 0x278
 80064e4:	4601      	mov	r1, r0
 80064e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80064ea:	6818      	ldr	r0, [r3, #0]
 80064ec:	f003 ba82 	b.w	80099f4 <_free_r>

080064f0 <_malloc_r>:
 80064f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80064f4:	f101 040b 	add.w	r4, r1, #11
 80064f8:	2c16      	cmp	r4, #22
 80064fa:	b083      	sub	sp, #12
 80064fc:	4606      	mov	r6, r0
 80064fe:	d931      	bls.n	8006564 <_malloc_r+0x74>
 8006500:	f024 0407 	bic.w	r4, r4, #7
 8006504:	0fe3      	lsrs	r3, r4, #31
 8006506:	428c      	cmp	r4, r1
 8006508:	bf2c      	ite	cs
 800650a:	4619      	movcs	r1, r3
 800650c:	f043 0101 	orrcc.w	r1, r3, #1
 8006510:	2900      	cmp	r1, #0
 8006512:	d130      	bne.n	8006576 <_malloc_r+0x86>
 8006514:	4630      	mov	r0, r6
 8006516:	f000 faa9 	bl	8006a6c <__malloc_lock>
 800651a:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
 800651e:	d22f      	bcs.n	8006580 <_malloc_r+0x90>
 8006520:	ea4f 0cd4 	mov.w	ip, r4, lsr #3
 8006524:	f240 356c 	movw	r5, #876	; 0x36c
 8006528:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800652c:	eb05 02cc 	add.w	r2, r5, ip, lsl #3
 8006530:	462f      	mov	r7, r5
 8006532:	68d3      	ldr	r3, [r2, #12]
 8006534:	4293      	cmp	r3, r2
 8006536:	f000 822d 	beq.w	8006994 <_malloc_r+0x4a4>
 800653a:	685c      	ldr	r4, [r3, #4]
 800653c:	f103 0808 	add.w	r8, r3, #8
 8006540:	68da      	ldr	r2, [r3, #12]
 8006542:	4630      	mov	r0, r6
 8006544:	f024 0403 	bic.w	r4, r4, #3
 8006548:	6899      	ldr	r1, [r3, #8]
 800654a:	191b      	adds	r3, r3, r4
 800654c:	685c      	ldr	r4, [r3, #4]
 800654e:	60ca      	str	r2, [r1, #12]
 8006550:	f044 0401 	orr.w	r4, r4, #1
 8006554:	6091      	str	r1, [r2, #8]
 8006556:	605c      	str	r4, [r3, #4]
 8006558:	f000 fa8a 	bl	8006a70 <__malloc_unlock>
 800655c:	4640      	mov	r0, r8
 800655e:	b003      	add	sp, #12
 8006560:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006564:	2300      	movs	r3, #0
 8006566:	2410      	movs	r4, #16
 8006568:	428c      	cmp	r4, r1
 800656a:	bf2c      	ite	cs
 800656c:	4619      	movcs	r1, r3
 800656e:	f043 0101 	orrcc.w	r1, r3, #1
 8006572:	2900      	cmp	r1, #0
 8006574:	d0ce      	beq.n	8006514 <_malloc_r+0x24>
 8006576:	230c      	movs	r3, #12
 8006578:	f04f 0800 	mov.w	r8, #0
 800657c:	6033      	str	r3, [r6, #0]
 800657e:	e7ed      	b.n	800655c <_malloc_r+0x6c>
 8006580:	ea5f 2c54 	movs.w	ip, r4, lsr #9
 8006584:	bf04      	itt	eq
 8006586:	ea4f 0cd4 	moveq.w	ip, r4, lsr #3
 800658a:	ea4f 00cc 	moveq.w	r0, ip, lsl #3
 800658e:	f040 8086 	bne.w	800669e <_malloc_r+0x1ae>
 8006592:	f240 356c 	movw	r5, #876	; 0x36c
 8006596:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800659a:	1828      	adds	r0, r5, r0
 800659c:	462f      	mov	r7, r5
 800659e:	68c3      	ldr	r3, [r0, #12]
 80065a0:	4298      	cmp	r0, r3
 80065a2:	d106      	bne.n	80065b2 <_malloc_r+0xc2>
 80065a4:	e00d      	b.n	80065c2 <_malloc_r+0xd2>
 80065a6:	2900      	cmp	r1, #0
 80065a8:	f280 8179 	bge.w	800689e <_malloc_r+0x3ae>
 80065ac:	68db      	ldr	r3, [r3, #12]
 80065ae:	4298      	cmp	r0, r3
 80065b0:	d007      	beq.n	80065c2 <_malloc_r+0xd2>
 80065b2:	685a      	ldr	r2, [r3, #4]
 80065b4:	f022 0203 	bic.w	r2, r2, #3
 80065b8:	1b11      	subs	r1, r2, r4
 80065ba:	290f      	cmp	r1, #15
 80065bc:	ddf3      	ble.n	80065a6 <_malloc_r+0xb6>
 80065be:	f10c 3cff 	add.w	ip, ip, #4294967295
 80065c2:	f10c 0c01 	add.w	ip, ip, #1
 80065c6:	4abd      	ldr	r2, [pc, #756]	; (80068bc <_malloc_r+0x3cc>)
 80065c8:	6893      	ldr	r3, [r2, #8]
 80065ca:	429a      	cmp	r2, r3
 80065cc:	bf08      	it	eq
 80065ce:	6878      	ldreq	r0, [r7, #4]
 80065d0:	d024      	beq.n	800661c <_malloc_r+0x12c>
 80065d2:	6858      	ldr	r0, [r3, #4]
 80065d4:	f020 0003 	bic.w	r0, r0, #3
 80065d8:	1b01      	subs	r1, r0, r4
 80065da:	290f      	cmp	r1, #15
 80065dc:	f300 81c0 	bgt.w	8006960 <_malloc_r+0x470>
 80065e0:	2900      	cmp	r1, #0
 80065e2:	60d2      	str	r2, [r2, #12]
 80065e4:	6092      	str	r2, [r2, #8]
 80065e6:	f280 8094 	bge.w	8006712 <_malloc_r+0x222>
 80065ea:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 80065ee:	f080 8177 	bcs.w	80068e0 <_malloc_r+0x3f0>
 80065f2:	08c0      	lsrs	r0, r0, #3
 80065f4:	f04f 0e01 	mov.w	lr, #1
 80065f8:	f8d7 8004 	ldr.w	r8, [r7, #4]
 80065fc:	eb07 01c0 	add.w	r1, r7, r0, lsl #3
 8006600:	1080      	asrs	r0, r0, #2
 8006602:	fa0e f000 	lsl.w	r0, lr, r0
 8006606:	60d9      	str	r1, [r3, #12]
 8006608:	f8d1 e008 	ldr.w	lr, [r1, #8]
 800660c:	ea40 0008 	orr.w	r0, r0, r8
 8006610:	6078      	str	r0, [r7, #4]
 8006612:	f8c3 e008 	str.w	lr, [r3, #8]
 8006616:	f8ce 300c 	str.w	r3, [lr, #12]
 800661a:	608b      	str	r3, [r1, #8]
 800661c:	f04f 0e01 	mov.w	lr, #1
 8006620:	ea4f 03ac 	mov.w	r3, ip, asr #2
 8006624:	fa0e fe03 	lsl.w	lr, lr, r3
 8006628:	4586      	cmp	lr, r0
 800662a:	d87d      	bhi.n	8006728 <_malloc_r+0x238>
 800662c:	ea10 0f0e 	tst.w	r0, lr
 8006630:	d108      	bne.n	8006644 <_malloc_r+0x154>
 8006632:	f02c 0c03 	bic.w	ip, ip, #3
 8006636:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 800663a:	f10c 0c04 	add.w	ip, ip, #4
 800663e:	ea10 0f0e 	tst.w	r0, lr
 8006642:	d0f8      	beq.n	8006636 <_malloc_r+0x146>
 8006644:	eb07 0acc 	add.w	sl, r7, ip, lsl #3
 8006648:	46e1      	mov	r9, ip
 800664a:	46d0      	mov	r8, sl
 800664c:	f8d8 000c 	ldr.w	r0, [r8, #12]
 8006650:	4580      	cmp	r8, r0
 8006652:	d107      	bne.n	8006664 <_malloc_r+0x174>
 8006654:	e196      	b.n	8006984 <_malloc_r+0x494>
 8006656:	2b00      	cmp	r3, #0
 8006658:	f280 81a6 	bge.w	80069a8 <_malloc_r+0x4b8>
 800665c:	68c0      	ldr	r0, [r0, #12]
 800665e:	4580      	cmp	r8, r0
 8006660:	f000 8190 	beq.w	8006984 <_malloc_r+0x494>
 8006664:	6841      	ldr	r1, [r0, #4]
 8006666:	f021 0103 	bic.w	r1, r1, #3
 800666a:	1b0b      	subs	r3, r1, r4
 800666c:	2b0f      	cmp	r3, #15
 800666e:	ddf2      	ble.n	8006656 <_malloc_r+0x166>
 8006670:	4680      	mov	r8, r0
 8006672:	68c5      	ldr	r5, [r0, #12]
 8006674:	1901      	adds	r1, r0, r4
 8006676:	f044 0e01 	orr.w	lr, r4, #1
 800667a:	f858 7f08 	ldr.w	r7, [r8, #8]!
 800667e:	f043 0401 	orr.w	r4, r3, #1
 8006682:	f8c0 e004 	str.w	lr, [r0, #4]
 8006686:	4630      	mov	r0, r6
 8006688:	604c      	str	r4, [r1, #4]
 800668a:	60fd      	str	r5, [r7, #12]
 800668c:	60af      	str	r7, [r5, #8]
 800668e:	60d1      	str	r1, [r2, #12]
 8006690:	6091      	str	r1, [r2, #8]
 8006692:	60ca      	str	r2, [r1, #12]
 8006694:	608a      	str	r2, [r1, #8]
 8006696:	50cb      	str	r3, [r1, r3]
 8006698:	f000 f9ea 	bl	8006a70 <__malloc_unlock>
 800669c:	e75e      	b.n	800655c <_malloc_r+0x6c>
 800669e:	f1bc 0f04 	cmp.w	ip, #4
 80066a2:	bf9e      	ittt	ls
 80066a4:	ea4f 1c94 	movls.w	ip, r4, lsr #6
 80066a8:	f10c 0c38 	addls.w	ip, ip, #56	; 0x38
 80066ac:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 80066b0:	f67f af6f 	bls.w	8006592 <_malloc_r+0xa2>
 80066b4:	f1bc 0f14 	cmp.w	ip, #20
 80066b8:	bf9c      	itt	ls
 80066ba:	f10c 0c5b 	addls.w	ip, ip, #91	; 0x5b
 80066be:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 80066c2:	f67f af66 	bls.w	8006592 <_malloc_r+0xa2>
 80066c6:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
 80066ca:	bf9e      	ittt	ls
 80066cc:	ea4f 3c14 	movls.w	ip, r4, lsr #12
 80066d0:	f10c 0c6e 	addls.w	ip, ip, #110	; 0x6e
 80066d4:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 80066d8:	f67f af5b 	bls.w	8006592 <_malloc_r+0xa2>
 80066dc:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
 80066e0:	bf9e      	ittt	ls
 80066e2:	ea4f 3cd4 	movls.w	ip, r4, lsr #15
 80066e6:	f10c 0c77 	addls.w	ip, ip, #119	; 0x77
 80066ea:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 80066ee:	f67f af50 	bls.w	8006592 <_malloc_r+0xa2>
 80066f2:	f240 5354 	movw	r3, #1364	; 0x554
 80066f6:	459c      	cmp	ip, r3
 80066f8:	bf95      	itete	ls
 80066fa:	ea4f 4c94 	movls.w	ip, r4, lsr #18
 80066fe:	f44f 707c 	movhi.w	r0, #1008	; 0x3f0
 8006702:	f10c 0c7c 	addls.w	ip, ip, #124	; 0x7c
 8006706:	f04f 0c7e 	movhi.w	ip, #126	; 0x7e
 800670a:	bf98      	it	ls
 800670c:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8006710:	e73f      	b.n	8006592 <_malloc_r+0xa2>
 8006712:	181a      	adds	r2, r3, r0
 8006714:	f103 0808 	add.w	r8, r3, #8
 8006718:	4630      	mov	r0, r6
 800671a:	6853      	ldr	r3, [r2, #4]
 800671c:	f043 0301 	orr.w	r3, r3, #1
 8006720:	6053      	str	r3, [r2, #4]
 8006722:	f000 f9a5 	bl	8006a70 <__malloc_unlock>
 8006726:	e719      	b.n	800655c <_malloc_r+0x6c>
 8006728:	f8d7 8008 	ldr.w	r8, [r7, #8]
 800672c:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8006730:	f023 0903 	bic.w	r9, r3, #3
 8006734:	454c      	cmp	r4, r9
 8006736:	ebc4 0209 	rsb	r2, r4, r9
 800673a:	bf94      	ite	ls
 800673c:	2300      	movls	r3, #0
 800673e:	2301      	movhi	r3, #1
 8006740:	2a0f      	cmp	r2, #15
 8006742:	bfd8      	it	le
 8006744:	f043 0301 	orrle.w	r3, r3, #1
 8006748:	2b00      	cmp	r3, #0
 800674a:	f000 80b9 	beq.w	80068c0 <_malloc_r+0x3d0>
 800674e:	f641 1a80 	movw	sl, #6528	; 0x1980
 8006752:	f8d5 3408 	ldr.w	r3, [r5, #1032]	; 0x408
 8006756:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 800675a:	4630      	mov	r0, r6
 800675c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8006760:	f8da 2000 	ldr.w	r2, [sl]
 8006764:	f102 0b10 	add.w	fp, r2, #16
 8006768:	44a3      	add	fp, r4
 800676a:	bf1f      	itttt	ne
 800676c:	f50b 6b7e 	addne.w	fp, fp, #4064	; 0xfe0
 8006770:	f10b 0b1f 	addne.w	fp, fp, #31
 8006774:	f42b 6b7e 	bicne.w	fp, fp, #4064	; 0xfe0
 8006778:	f02b 0b1f 	bicne.w	fp, fp, #31
 800677c:	4659      	mov	r1, fp
 800677e:	f7fa fa57 	bl	8000c30 <_sbrk_r>
 8006782:	f1b0 3fff 	cmp.w	r0, #4294967295
 8006786:	4603      	mov	r3, r0
 8006788:	f000 8118 	beq.w	80069bc <_malloc_r+0x4cc>
 800678c:	eb08 0109 	add.w	r1, r8, r9
 8006790:	4281      	cmp	r1, r0
 8006792:	f200 8110 	bhi.w	80069b6 <_malloc_r+0x4c6>
 8006796:	f8da 2004 	ldr.w	r2, [sl, #4]
 800679a:	4281      	cmp	r1, r0
 800679c:	445a      	add	r2, fp
 800679e:	f8ca 2004 	str.w	r2, [sl, #4]
 80067a2:	f000 813e 	beq.w	8006a22 <_malloc_r+0x532>
 80067a6:	f8d5 e408 	ldr.w	lr, [r5, #1032]	; 0x408
 80067aa:	f240 356c 	movw	r5, #876	; 0x36c
 80067ae:	f2c2 0500 	movt	r5, #8192	; 0x2000
 80067b2:	f1be 3fff 	cmp.w	lr, #4294967295
 80067b6:	bf17      	itett	ne
 80067b8:	1882      	addne	r2, r0, r2
 80067ba:	f8c5 0408 	streq.w	r0, [r5, #1032]	; 0x408
 80067be:	ebc1 0102 	rsbne	r1, r1, r2
 80067c2:	f8ca 1004 	strne.w	r1, [sl, #4]
 80067c6:	f010 0507 	ands.w	r5, r0, #7
 80067ca:	bf17      	itett	ne
 80067cc:	f1c5 0508 	rsbne	r5, r5, #8
 80067d0:	f44f 5580 	moveq.w	r5, #4096	; 0x1000
 80067d4:	1943      	addne	r3, r0, r5
 80067d6:	f505 5580 	addne.w	r5, r5, #4096	; 0x1000
 80067da:	eb03 020b 	add.w	r2, r3, fp
 80067de:	4630      	mov	r0, r6
 80067e0:	9301      	str	r3, [sp, #4]
 80067e2:	0512      	lsls	r2, r2, #20
 80067e4:	0d12      	lsrs	r2, r2, #20
 80067e6:	1aad      	subs	r5, r5, r2
 80067e8:	4629      	mov	r1, r5
 80067ea:	f7fa fa21 	bl	8000c30 <_sbrk_r>
 80067ee:	9b01      	ldr	r3, [sp, #4]
 80067f0:	f1b0 3fff 	cmp.w	r0, #4294967295
 80067f4:	f000 812c 	beq.w	8006a50 <_malloc_r+0x560>
 80067f8:	1ac1      	subs	r1, r0, r3
 80067fa:	1949      	adds	r1, r1, r5
 80067fc:	f041 0101 	orr.w	r1, r1, #1
 8006800:	f8da 2004 	ldr.w	r2, [sl, #4]
 8006804:	45b8      	cmp	r8, r7
 8006806:	f641 1b80 	movw	fp, #6528	; 0x1980
 800680a:	60bb      	str	r3, [r7, #8]
 800680c:	442a      	add	r2, r5
 800680e:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 8006812:	6059      	str	r1, [r3, #4]
 8006814:	f8ca 2004 	str.w	r2, [sl, #4]
 8006818:	d017      	beq.n	800684a <_malloc_r+0x35a>
 800681a:	f1b9 0f0f 	cmp.w	r9, #15
 800681e:	f240 80e1 	bls.w	80069e4 <_malloc_r+0x4f4>
 8006822:	f1a9 030c 	sub.w	r3, r9, #12
 8006826:	f8d8 5004 	ldr.w	r5, [r8, #4]
 800682a:	f023 0307 	bic.w	r3, r3, #7
 800682e:	2005      	movs	r0, #5
 8006830:	eb08 0103 	add.w	r1, r8, r3
 8006834:	2b0f      	cmp	r3, #15
 8006836:	f005 0501 	and.w	r5, r5, #1
 800683a:	ea43 0505 	orr.w	r5, r3, r5
 800683e:	f8c8 5004 	str.w	r5, [r8, #4]
 8006842:	6048      	str	r0, [r1, #4]
 8006844:	6088      	str	r0, [r1, #8]
 8006846:	f200 80fb 	bhi.w	8006a40 <_malloc_r+0x550>
 800684a:	f8da 102c 	ldr.w	r1, [sl, #44]	; 0x2c
 800684e:	f641 1380 	movw	r3, #6528	; 0x1980
 8006852:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006856:	428a      	cmp	r2, r1
 8006858:	f8da 1030 	ldr.w	r1, [sl, #48]	; 0x30
 800685c:	bf88      	it	hi
 800685e:	62da      	strhi	r2, [r3, #44]	; 0x2c
 8006860:	f641 1380 	movw	r3, #6528	; 0x1980
 8006864:	428a      	cmp	r2, r1
 8006866:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800686a:	f240 80a7 	bls.w	80069bc <_malloc_r+0x4cc>
 800686e:	f8d7 8008 	ldr.w	r8, [r7, #8]
 8006872:	631a      	str	r2, [r3, #48]	; 0x30
 8006874:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8006878:	f023 0303 	bic.w	r3, r3, #3
 800687c:	429c      	cmp	r4, r3
 800687e:	ebc4 0203 	rsb	r2, r4, r3
 8006882:	bf94      	ite	ls
 8006884:	2300      	movls	r3, #0
 8006886:	2301      	movhi	r3, #1
 8006888:	2a0f      	cmp	r2, #15
 800688a:	bfd8      	it	le
 800688c:	f043 0301 	orrle.w	r3, r3, #1
 8006890:	b1b3      	cbz	r3, 80068c0 <_malloc_r+0x3d0>
 8006892:	4630      	mov	r0, r6
 8006894:	f04f 0800 	mov.w	r8, #0
 8006898:	f000 f8ea 	bl	8006a70 <__malloc_unlock>
 800689c:	e65e      	b.n	800655c <_malloc_r+0x6c>
 800689e:	189a      	adds	r2, r3, r2
 80068a0:	68d9      	ldr	r1, [r3, #12]
 80068a2:	689c      	ldr	r4, [r3, #8]
 80068a4:	f103 0808 	add.w	r8, r3, #8
 80068a8:	6855      	ldr	r5, [r2, #4]
 80068aa:	4630      	mov	r0, r6
 80068ac:	f045 0301 	orr.w	r3, r5, #1
 80068b0:	60e1      	str	r1, [r4, #12]
 80068b2:	608c      	str	r4, [r1, #8]
 80068b4:	6053      	str	r3, [r2, #4]
 80068b6:	f000 f8db 	bl	8006a70 <__malloc_unlock>
 80068ba:	e64f      	b.n	800655c <_malloc_r+0x6c>
 80068bc:	20000374 	.word	0x20000374
 80068c0:	eb08 0304 	add.w	r3, r8, r4
 80068c4:	f042 0201 	orr.w	r2, r2, #1
 80068c8:	f044 0401 	orr.w	r4, r4, #1
 80068cc:	4630      	mov	r0, r6
 80068ce:	f8c8 4004 	str.w	r4, [r8, #4]
 80068d2:	f108 0808 	add.w	r8, r8, #8
 80068d6:	605a      	str	r2, [r3, #4]
 80068d8:	60bb      	str	r3, [r7, #8]
 80068da:	f000 f8c9 	bl	8006a70 <__malloc_unlock>
 80068de:	e63d      	b.n	800655c <_malloc_r+0x6c>
 80068e0:	0a41      	lsrs	r1, r0, #9
 80068e2:	2904      	cmp	r1, #4
 80068e4:	bf9c      	itt	ls
 80068e6:	ea4f 1e90 	movls.w	lr, r0, lsr #6
 80068ea:	f10e 0e38 	addls.w	lr, lr, #56	; 0x38
 80068ee:	d91d      	bls.n	800692c <_malloc_r+0x43c>
 80068f0:	2914      	cmp	r1, #20
 80068f2:	bf98      	it	ls
 80068f4:	f101 0e5b 	addls.w	lr, r1, #91	; 0x5b
 80068f8:	d918      	bls.n	800692c <_malloc_r+0x43c>
 80068fa:	2954      	cmp	r1, #84	; 0x54
 80068fc:	bf9c      	itt	ls
 80068fe:	ea4f 3e10 	movls.w	lr, r0, lsr #12
 8006902:	f10e 0e6e 	addls.w	lr, lr, #110	; 0x6e
 8006906:	d911      	bls.n	800692c <_malloc_r+0x43c>
 8006908:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
 800690c:	bf9c      	itt	ls
 800690e:	ea4f 3ed0 	movls.w	lr, r0, lsr #15
 8006912:	f10e 0e77 	addls.w	lr, lr, #119	; 0x77
 8006916:	d909      	bls.n	800692c <_malloc_r+0x43c>
 8006918:	f240 5e54 	movw	lr, #1364	; 0x554
 800691c:	4571      	cmp	r1, lr
 800691e:	bf96      	itet	ls
 8006920:	ea4f 4e90 	movls.w	lr, r0, lsr #18
 8006924:	f04f 0e7e 	movhi.w	lr, #126	; 0x7e
 8006928:	f10e 0e7c 	addls.w	lr, lr, #124	; 0x7c
 800692c:	eb07 08ce 	add.w	r8, r7, lr, lsl #3
 8006930:	f8d8 1008 	ldr.w	r1, [r8, #8]
 8006934:	4541      	cmp	r1, r8
 8006936:	d103      	bne.n	8006940 <_malloc_r+0x450>
 8006938:	e047      	b.n	80069ca <_malloc_r+0x4da>
 800693a:	6889      	ldr	r1, [r1, #8]
 800693c:	4588      	cmp	r8, r1
 800693e:	d005      	beq.n	800694c <_malloc_r+0x45c>
 8006940:	f8d1 e004 	ldr.w	lr, [r1, #4]
 8006944:	f02e 0e03 	bic.w	lr, lr, #3
 8006948:	4570      	cmp	r0, lr
 800694a:	d3f6      	bcc.n	800693a <_malloc_r+0x44a>
 800694c:	f8d1 e00c 	ldr.w	lr, [r1, #12]
 8006950:	f8c3 e00c 	str.w	lr, [r3, #12]
 8006954:	6099      	str	r1, [r3, #8]
 8006956:	6878      	ldr	r0, [r7, #4]
 8006958:	60cb      	str	r3, [r1, #12]
 800695a:	f8ce 3008 	str.w	r3, [lr, #8]
 800695e:	e65d      	b.n	800661c <_malloc_r+0x12c>
 8006960:	191d      	adds	r5, r3, r4
 8006962:	f041 0701 	orr.w	r7, r1, #1
 8006966:	60d5      	str	r5, [r2, #12]
 8006968:	f044 0401 	orr.w	r4, r4, #1
 800696c:	6095      	str	r5, [r2, #8]
 800696e:	4630      	mov	r0, r6
 8006970:	605c      	str	r4, [r3, #4]
 8006972:	f103 0808 	add.w	r8, r3, #8
 8006976:	60ea      	str	r2, [r5, #12]
 8006978:	60aa      	str	r2, [r5, #8]
 800697a:	606f      	str	r7, [r5, #4]
 800697c:	5069      	str	r1, [r5, r1]
 800697e:	f000 f877 	bl	8006a70 <__malloc_unlock>
 8006982:	e5eb      	b.n	800655c <_malloc_r+0x6c>
 8006984:	f109 0901 	add.w	r9, r9, #1
 8006988:	f019 0f03 	tst.w	r9, #3
 800698c:	d02f      	beq.n	80069ee <_malloc_r+0x4fe>
 800698e:	f108 0808 	add.w	r8, r8, #8
 8006992:	e65b      	b.n	800664c <_malloc_r+0x15c>
 8006994:	f103 0208 	add.w	r2, r3, #8
 8006998:	695b      	ldr	r3, [r3, #20]
 800699a:	429a      	cmp	r2, r3
 800699c:	bf08      	it	eq
 800699e:	f10c 0c02 	addeq.w	ip, ip, #2
 80069a2:	f43f ae10 	beq.w	80065c6 <_malloc_r+0xd6>
 80069a6:	e5c8      	b.n	800653a <_malloc_r+0x4a>
 80069a8:	4680      	mov	r8, r0
 80069aa:	1843      	adds	r3, r0, r1
 80069ac:	68c2      	ldr	r2, [r0, #12]
 80069ae:	4630      	mov	r0, r6
 80069b0:	f858 1f08 	ldr.w	r1, [r8, #8]!
 80069b4:	e5ca      	b.n	800654c <_malloc_r+0x5c>
 80069b6:	45b8      	cmp	r8, r7
 80069b8:	f43f aeed 	beq.w	8006796 <_malloc_r+0x2a6>
 80069bc:	f8d7 8008 	ldr.w	r8, [r7, #8]
 80069c0:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80069c4:	f023 0303 	bic.w	r3, r3, #3
 80069c8:	e758      	b.n	800687c <_malloc_r+0x38c>
 80069ca:	f04f 0901 	mov.w	r9, #1
 80069ce:	f8d7 8004 	ldr.w	r8, [r7, #4]
 80069d2:	ea4f 00ae 	mov.w	r0, lr, asr #2
 80069d6:	468e      	mov	lr, r1
 80069d8:	fa09 f000 	lsl.w	r0, r9, r0
 80069dc:	ea48 0000 	orr.w	r0, r8, r0
 80069e0:	6078      	str	r0, [r7, #4]
 80069e2:	e7b5      	b.n	8006950 <_malloc_r+0x460>
 80069e4:	4698      	mov	r8, r3
 80069e6:	2201      	movs	r2, #1
 80069e8:	605a      	str	r2, [r3, #4]
 80069ea:	2300      	movs	r3, #0
 80069ec:	e746      	b.n	800687c <_malloc_r+0x38c>
 80069ee:	4651      	mov	r1, sl
 80069f0:	f01c 0f03 	tst.w	ip, #3
 80069f4:	460b      	mov	r3, r1
 80069f6:	f10c 3cff 	add.w	ip, ip, #4294967295
 80069fa:	d02c      	beq.n	8006a56 <_malloc_r+0x566>
 80069fc:	f853 1908 	ldr.w	r1, [r3], #-8
 8006a00:	4299      	cmp	r1, r3
 8006a02:	d0f5      	beq.n	80069f0 <_malloc_r+0x500>
 8006a04:	687b      	ldr	r3, [r7, #4]
 8006a06:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 8006a0a:	459e      	cmp	lr, r3
 8006a0c:	f63f ae8c 	bhi.w	8006728 <_malloc_r+0x238>
 8006a10:	f1be 0f00 	cmp.w	lr, #0
 8006a14:	f43f ae88 	beq.w	8006728 <_malloc_r+0x238>
 8006a18:	ea1e 0f03 	tst.w	lr, r3
 8006a1c:	d020      	beq.n	8006a60 <_malloc_r+0x570>
 8006a1e:	46cc      	mov	ip, r9
 8006a20:	e610      	b.n	8006644 <_malloc_r+0x154>
 8006a22:	ea4f 5e01 	mov.w	lr, r1, lsl #20
 8006a26:	ea4f 5e1e 	mov.w	lr, lr, lsr #20
 8006a2a:	f1be 0f00 	cmp.w	lr, #0
 8006a2e:	f47f aeba 	bne.w	80067a6 <_malloc_r+0x2b6>
 8006a32:	68bb      	ldr	r3, [r7, #8]
 8006a34:	eb0b 0109 	add.w	r1, fp, r9
 8006a38:	f041 0101 	orr.w	r1, r1, #1
 8006a3c:	6059      	str	r1, [r3, #4]
 8006a3e:	e704      	b.n	800684a <_malloc_r+0x35a>
 8006a40:	4630      	mov	r0, r6
 8006a42:	f108 0108 	add.w	r1, r8, #8
 8006a46:	f002 ffd5 	bl	80099f4 <_free_r>
 8006a4a:	f8db 2004 	ldr.w	r2, [fp, #4]
 8006a4e:	e6fc      	b.n	800684a <_malloc_r+0x35a>
 8006a50:	2101      	movs	r1, #1
 8006a52:	2500      	movs	r5, #0
 8006a54:	e6d4      	b.n	8006800 <_malloc_r+0x310>
 8006a56:	687b      	ldr	r3, [r7, #4]
 8006a58:	ea23 030e 	bic.w	r3, r3, lr
 8006a5c:	607b      	str	r3, [r7, #4]
 8006a5e:	e7d1      	b.n	8006a04 <_malloc_r+0x514>
 8006a60:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 8006a64:	f109 0904 	add.w	r9, r9, #4
 8006a68:	e7d6      	b.n	8006a18 <_malloc_r+0x528>
 8006a6a:	bf00      	nop

08006a6c <__malloc_lock>:
 8006a6c:	4770      	bx	lr
 8006a6e:	bf00      	nop

08006a70 <__malloc_unlock>:
 8006a70:	4770      	bx	lr
 8006a72:	bf00      	nop

08006a74 <setbuf>:
 8006a74:	2900      	cmp	r1, #0
 8006a76:	bf0c      	ite	eq
 8006a78:	2202      	moveq	r2, #2
 8006a7a:	2200      	movne	r2, #0
 8006a7c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006a80:	f000 b800 	b.w	8006a84 <setvbuf>

08006a84 <setvbuf>:
 8006a84:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8006a88:	f240 2578 	movw	r5, #632	; 0x278
 8006a8c:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8006a90:	4604      	mov	r4, r0
 8006a92:	460e      	mov	r6, r1
 8006a94:	4617      	mov	r7, r2
 8006a96:	6828      	ldr	r0, [r5, #0]
 8006a98:	4698      	mov	r8, r3
 8006a9a:	b110      	cbz	r0, 8006aa2 <setvbuf+0x1e>
 8006a9c:	6983      	ldr	r3, [r0, #24]
 8006a9e:	2b00      	cmp	r3, #0
 8006aa0:	d05a      	beq.n	8006b58 <setvbuf+0xd4>
 8006aa2:	f64c 7368 	movw	r3, #53096	; 0xcf68
 8006aa6:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006aaa:	429c      	cmp	r4, r3
 8006aac:	d05c      	beq.n	8006b68 <setvbuf+0xe4>
 8006aae:	f64c 7388 	movw	r3, #53128	; 0xcf88
 8006ab2:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006ab6:	429c      	cmp	r4, r3
 8006ab8:	d059      	beq.n	8006b6e <setvbuf+0xea>
 8006aba:	f64c 73a8 	movw	r3, #53160	; 0xcfa8
 8006abe:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006ac2:	429c      	cmp	r4, r3
 8006ac4:	bf04      	itt	eq
 8006ac6:	682b      	ldreq	r3, [r5, #0]
 8006ac8:	68dc      	ldreq	r4, [r3, #12]
 8006aca:	2f02      	cmp	r7, #2
 8006acc:	bf94      	ite	ls
 8006ace:	f04f 0900 	movls.w	r9, #0
 8006ad2:	f04f 0901 	movhi.w	r9, #1
 8006ad6:	ea59 79d8 	orrs.w	r9, r9, r8, lsr #31
 8006ada:	bf18      	it	ne
 8006adc:	f04f 30ff 	movne.w	r0, #4294967295
 8006ae0:	d001      	beq.n	8006ae6 <setvbuf+0x62>
 8006ae2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006ae6:	6828      	ldr	r0, [r5, #0]
 8006ae8:	4621      	mov	r1, r4
 8006aea:	f002 fd29 	bl	8009540 <_fflush_r>
 8006aee:	89a2      	ldrh	r2, [r4, #12]
 8006af0:	f240 2378 	movw	r3, #632	; 0x278
 8006af4:	f8c4 9004 	str.w	r9, [r4, #4]
 8006af8:	f012 0f80 	tst.w	r2, #128	; 0x80
 8006afc:	f8c4 9018 	str.w	r9, [r4, #24]
 8006b00:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006b04:	d136      	bne.n	8006b74 <setvbuf+0xf0>
 8006b06:	2f02      	cmp	r7, #2
 8006b08:	f64f 737c 	movw	r3, #65404	; 0xff7c
 8006b0c:	ea02 0303 	and.w	r3, r2, r3
 8006b10:	81a3      	strh	r3, [r4, #12]
 8006b12:	d035      	beq.n	8006b80 <setvbuf+0xfc>
 8006b14:	2e00      	cmp	r6, #0
 8006b16:	d041      	beq.n	8006b9c <setvbuf+0x118>
 8006b18:	2f01      	cmp	r7, #1
 8006b1a:	6829      	ldr	r1, [r5, #0]
 8006b1c:	bf01      	itttt	eq
 8006b1e:	f043 0301 	orreq.w	r3, r3, #1
 8006b22:	81a3      	strheq	r3, [r4, #12]
 8006b24:	f1c8 0200 	rsbeq	r2, r8, #0
 8006b28:	61a2      	streq	r2, [r4, #24]
 8006b2a:	b29b      	uxth	r3, r3
 8006b2c:	f249 7235 	movw	r2, #38709	; 0x9735
 8006b30:	f013 0008 	ands.w	r0, r3, #8
 8006b34:	f6c0 0200 	movt	r2, #2048	; 0x800
 8006b38:	628a      	str	r2, [r1, #40]	; 0x28
 8006b3a:	6026      	str	r6, [r4, #0]
 8006b3c:	6126      	str	r6, [r4, #16]
 8006b3e:	f8c4 8014 	str.w	r8, [r4, #20]
 8006b42:	d0ce      	beq.n	8006ae2 <setvbuf+0x5e>
 8006b44:	f013 0f03 	tst.w	r3, #3
 8006b48:	f04f 0000 	mov.w	r0, #0
 8006b4c:	bf0c      	ite	eq
 8006b4e:	4643      	moveq	r3, r8
 8006b50:	4603      	movne	r3, r0
 8006b52:	60a3      	str	r3, [r4, #8]
 8006b54:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006b58:	f002 fe10 	bl	800977c <__sinit>
 8006b5c:	f64c 7368 	movw	r3, #53096	; 0xcf68
 8006b60:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006b64:	429c      	cmp	r4, r3
 8006b66:	d1a2      	bne.n	8006aae <setvbuf+0x2a>
 8006b68:	682b      	ldr	r3, [r5, #0]
 8006b6a:	685c      	ldr	r4, [r3, #4]
 8006b6c:	e7ad      	b.n	8006aca <setvbuf+0x46>
 8006b6e:	682b      	ldr	r3, [r5, #0]
 8006b70:	689c      	ldr	r4, [r3, #8]
 8006b72:	e7aa      	b.n	8006aca <setvbuf+0x46>
 8006b74:	6818      	ldr	r0, [r3, #0]
 8006b76:	6921      	ldr	r1, [r4, #16]
 8006b78:	f002 ff3c 	bl	80099f4 <_free_r>
 8006b7c:	89a2      	ldrh	r2, [r4, #12]
 8006b7e:	e7c2      	b.n	8006b06 <setvbuf+0x82>
 8006b80:	2000      	movs	r0, #0
 8006b82:	f104 0247 	add.w	r2, r4, #71	; 0x47
 8006b86:	f043 0302 	orr.w	r3, r3, #2
 8006b8a:	6022      	str	r2, [r4, #0]
 8006b8c:	81a3      	strh	r3, [r4, #12]
 8006b8e:	2300      	movs	r3, #0
 8006b90:	6122      	str	r2, [r4, #16]
 8006b92:	60a3      	str	r3, [r4, #8]
 8006b94:	2301      	movs	r3, #1
 8006b96:	6163      	str	r3, [r4, #20]
 8006b98:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006b9c:	f1b8 0f00 	cmp.w	r8, #0
 8006ba0:	bf08      	it	eq
 8006ba2:	f44f 6880 	moveq.w	r8, #1024	; 0x400
 8006ba6:	4640      	mov	r0, r8
 8006ba8:	f7ff fc92 	bl	80064d0 <malloc>
 8006bac:	4606      	mov	r6, r0
 8006bae:	b128      	cbz	r0, 8006bbc <setvbuf+0x138>
 8006bb0:	89a3      	ldrh	r3, [r4, #12]
 8006bb2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006bb6:	b29b      	uxth	r3, r3
 8006bb8:	81a3      	strh	r3, [r4, #12]
 8006bba:	e7ad      	b.n	8006b18 <setvbuf+0x94>
 8006bbc:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8006bc0:	f7ff fc86 	bl	80064d0 <malloc>
 8006bc4:	4606      	mov	r6, r0
 8006bc6:	b918      	cbnz	r0, 8006bd0 <setvbuf+0x14c>
 8006bc8:	89a3      	ldrh	r3, [r4, #12]
 8006bca:	f04f 30ff 	mov.w	r0, #4294967295
 8006bce:	e7d8      	b.n	8006b82 <setvbuf+0xfe>
 8006bd0:	f44f 6880 	mov.w	r8, #1024	; 0x400
 8006bd4:	e7ec      	b.n	8006bb0 <setvbuf+0x12c>
 8006bd6:	bf00      	nop

08006bd8 <_snprintf_r>:
 8006bd8:	b408      	push	{r3}
 8006bda:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006bdc:	1e14      	subs	r4, r2, #0
 8006bde:	b09c      	sub	sp, #112	; 0x70
 8006be0:	4605      	mov	r5, r0
 8006be2:	db25      	blt.n	8006c30 <_snprintf_r+0x58>
 8006be4:	ae22      	add	r6, sp, #136	; 0x88
 8006be6:	f44f 7302 	mov.w	r3, #520	; 0x208
 8006bea:	9101      	str	r1, [sp, #4]
 8006bec:	bf08      	it	eq
 8006bee:	4627      	moveq	r7, r4
 8006bf0:	f8ad 3010 	strh.w	r3, [sp, #16]
 8006bf4:	4633      	mov	r3, r6
 8006bf6:	9105      	str	r1, [sp, #20]
 8006bf8:	a901      	add	r1, sp, #4
 8006bfa:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8006bfc:	bf18      	it	ne
 8006bfe:	1e67      	subne	r7, r4, #1
 8006c00:	961b      	str	r6, [sp, #108]	; 0x6c
 8006c02:	9703      	str	r7, [sp, #12]
 8006c04:	9706      	str	r7, [sp, #24]
 8006c06:	f04f 37ff 	mov.w	r7, #4294967295
 8006c0a:	f8ad 7012 	strh.w	r7, [sp, #18]
 8006c0e:	f000 f939 	bl	8006e84 <_svfprintf_r>
 8006c12:	f1b0 3fff 	cmp.w	r0, #4294967295
 8006c16:	db08      	blt.n	8006c2a <_snprintf_r+0x52>
 8006c18:	b114      	cbz	r4, 8006c20 <_snprintf_r+0x48>
 8006c1a:	9b01      	ldr	r3, [sp, #4]
 8006c1c:	2200      	movs	r2, #0
 8006c1e:	701a      	strb	r2, [r3, #0]
 8006c20:	b01c      	add	sp, #112	; 0x70
 8006c22:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8006c26:	b001      	add	sp, #4
 8006c28:	4770      	bx	lr
 8006c2a:	238b      	movs	r3, #139	; 0x8b
 8006c2c:	602b      	str	r3, [r5, #0]
 8006c2e:	e7f3      	b.n	8006c18 <_snprintf_r+0x40>
 8006c30:	238b      	movs	r3, #139	; 0x8b
 8006c32:	f04f 30ff 	mov.w	r0, #4294967295
 8006c36:	602b      	str	r3, [r5, #0]
 8006c38:	e7f2      	b.n	8006c20 <_snprintf_r+0x48>
 8006c3a:	bf00      	nop

08006c3c <snprintf>:
 8006c3c:	b40c      	push	{r2, r3}
 8006c3e:	f240 2378 	movw	r3, #632	; 0x278
 8006c42:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006c44:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006c48:	1e0c      	subs	r4, r1, #0
 8006c4a:	b09d      	sub	sp, #116	; 0x74
 8006c4c:	681d      	ldr	r5, [r3, #0]
 8006c4e:	db26      	blt.n	8006c9e <snprintf+0x62>
 8006c50:	ae23      	add	r6, sp, #140	; 0x8c
 8006c52:	f44f 7302 	mov.w	r3, #520	; 0x208
 8006c56:	9001      	str	r0, [sp, #4]
 8006c58:	a901      	add	r1, sp, #4
 8006c5a:	f8ad 3010 	strh.w	r3, [sp, #16]
 8006c5e:	4633      	mov	r3, r6
 8006c60:	9005      	str	r0, [sp, #20]
 8006c62:	4628      	mov	r0, r5
 8006c64:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8006c66:	bf08      	it	eq
 8006c68:	4627      	moveq	r7, r4
 8006c6a:	961b      	str	r6, [sp, #108]	; 0x6c
 8006c6c:	bf18      	it	ne
 8006c6e:	1e67      	subne	r7, r4, #1
 8006c70:	9703      	str	r7, [sp, #12]
 8006c72:	9706      	str	r7, [sp, #24]
 8006c74:	f04f 37ff 	mov.w	r7, #4294967295
 8006c78:	f8ad 7012 	strh.w	r7, [sp, #18]
 8006c7c:	f000 f902 	bl	8006e84 <_svfprintf_r>
 8006c80:	f1b0 3fff 	cmp.w	r0, #4294967295
 8006c84:	db08      	blt.n	8006c98 <snprintf+0x5c>
 8006c86:	b114      	cbz	r4, 8006c8e <snprintf+0x52>
 8006c88:	9b01      	ldr	r3, [sp, #4]
 8006c8a:	2200      	movs	r2, #0
 8006c8c:	701a      	strb	r2, [r3, #0]
 8006c8e:	b01d      	add	sp, #116	; 0x74
 8006c90:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8006c94:	b002      	add	sp, #8
 8006c96:	4770      	bx	lr
 8006c98:	238b      	movs	r3, #139	; 0x8b
 8006c9a:	602b      	str	r3, [r5, #0]
 8006c9c:	e7f3      	b.n	8006c86 <snprintf+0x4a>
 8006c9e:	238b      	movs	r3, #139	; 0x8b
 8006ca0:	f04f 30ff 	mov.w	r0, #4294967295
 8006ca4:	602b      	str	r3, [r5, #0]
 8006ca6:	e7f2      	b.n	8006c8e <snprintf+0x52>

08006ca8 <strcmp>:
 8006ca8:	ea80 0201 	eor.w	r2, r0, r1
 8006cac:	f012 0f03 	tst.w	r2, #3
 8006cb0:	d13a      	bne.n	8006d28 <strcmp_unaligned>
 8006cb2:	f010 0203 	ands.w	r2, r0, #3
 8006cb6:	f020 0003 	bic.w	r0, r0, #3
 8006cba:	f021 0103 	bic.w	r1, r1, #3
 8006cbe:	f850 cb04 	ldr.w	ip, [r0], #4
 8006cc2:	bf08      	it	eq
 8006cc4:	f851 3b04 	ldreq.w	r3, [r1], #4
 8006cc8:	d00d      	beq.n	8006ce6 <strcmp+0x3e>
 8006cca:	f082 0203 	eor.w	r2, r2, #3
 8006cce:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8006cd2:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8006cd6:	fa23 f202 	lsr.w	r2, r3, r2
 8006cda:	f851 3b04 	ldr.w	r3, [r1], #4
 8006cde:	ea4c 0c02 	orr.w	ip, ip, r2
 8006ce2:	ea43 0302 	orr.w	r3, r3, r2
 8006ce6:	bf00      	nop
 8006ce8:	f1ac 3201 	sub.w	r2, ip, #16843009	; 0x1010101
 8006cec:	459c      	cmp	ip, r3
 8006cee:	bf01      	itttt	eq
 8006cf0:	ea22 020c 	biceq.w	r2, r2, ip
 8006cf4:	f012 3f80 	tsteq.w	r2, #2155905152	; 0x80808080
 8006cf8:	f850 cb04 	ldreq.w	ip, [r0], #4
 8006cfc:	f851 3b04 	ldreq.w	r3, [r1], #4
 8006d00:	d0f2      	beq.n	8006ce8 <strcmp+0x40>
 8006d02:	ea4f 600c 	mov.w	r0, ip, lsl #24
 8006d06:	ea4f 2c1c 	mov.w	ip, ip, lsr #8
 8006d0a:	2801      	cmp	r0, #1
 8006d0c:	bf28      	it	cs
 8006d0e:	ebb0 6f03 	cmpcs.w	r0, r3, lsl #24
 8006d12:	bf08      	it	eq
 8006d14:	0a1b      	lsreq	r3, r3, #8
 8006d16:	d0f4      	beq.n	8006d02 <strcmp+0x5a>
 8006d18:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8006d1c:	ea4f 6010 	mov.w	r0, r0, lsr #24
 8006d20:	eba0 0003 	sub.w	r0, r0, r3
 8006d24:	4770      	bx	lr
 8006d26:	bf00      	nop

08006d28 <strcmp_unaligned>:
 8006d28:	f010 0f03 	tst.w	r0, #3
 8006d2c:	d00a      	beq.n	8006d44 <strcmp_unaligned+0x1c>
 8006d2e:	f810 2b01 	ldrb.w	r2, [r0], #1
 8006d32:	f811 3b01 	ldrb.w	r3, [r1], #1
 8006d36:	2a01      	cmp	r2, #1
 8006d38:	bf28      	it	cs
 8006d3a:	429a      	cmpcs	r2, r3
 8006d3c:	d0f4      	beq.n	8006d28 <strcmp_unaligned>
 8006d3e:	eba2 0003 	sub.w	r0, r2, r3
 8006d42:	4770      	bx	lr
 8006d44:	f84d 5d04 	str.w	r5, [sp, #-4]!
 8006d48:	f84d 4d04 	str.w	r4, [sp, #-4]!
 8006d4c:	f04f 0201 	mov.w	r2, #1
 8006d50:	ea42 2202 	orr.w	r2, r2, r2, lsl #8
 8006d54:	ea42 4202 	orr.w	r2, r2, r2, lsl #16
 8006d58:	f001 0c03 	and.w	ip, r1, #3
 8006d5c:	f021 0103 	bic.w	r1, r1, #3
 8006d60:	f850 4b04 	ldr.w	r4, [r0], #4
 8006d64:	f851 5b04 	ldr.w	r5, [r1], #4
 8006d68:	f1bc 0f02 	cmp.w	ip, #2
 8006d6c:	d026      	beq.n	8006dbc <strcmp_unaligned+0x94>
 8006d6e:	d84b      	bhi.n	8006e08 <strcmp_unaligned+0xe0>
 8006d70:	f024 4c7f 	bic.w	ip, r4, #4278190080	; 0xff000000
 8006d74:	ebbc 2f15 	cmp.w	ip, r5, lsr #8
 8006d78:	eba4 0302 	sub.w	r3, r4, r2
 8006d7c:	ea23 0304 	bic.w	r3, r3, r4
 8006d80:	d10d      	bne.n	8006d9e <strcmp_unaligned+0x76>
 8006d82:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 8006d86:	bf08      	it	eq
 8006d88:	f851 5b04 	ldreq.w	r5, [r1], #4
 8006d8c:	d10a      	bne.n	8006da4 <strcmp_unaligned+0x7c>
 8006d8e:	ea8c 0c04 	eor.w	ip, ip, r4
 8006d92:	ebbc 6f05 	cmp.w	ip, r5, lsl #24
 8006d96:	d10c      	bne.n	8006db2 <strcmp_unaligned+0x8a>
 8006d98:	f850 4b04 	ldr.w	r4, [r0], #4
 8006d9c:	e7e8      	b.n	8006d70 <strcmp_unaligned+0x48>
 8006d9e:	ea4f 2515 	mov.w	r5, r5, lsr #8
 8006da2:	e05c      	b.n	8006e5e <strcmp_unaligned+0x136>
 8006da4:	f033 437f 	bics.w	r3, r3, #4278190080	; 0xff000000
 8006da8:	d152      	bne.n	8006e50 <strcmp_unaligned+0x128>
 8006daa:	780d      	ldrb	r5, [r1, #0]
 8006dac:	ea4f 6c14 	mov.w	ip, r4, lsr #24
 8006db0:	e055      	b.n	8006e5e <strcmp_unaligned+0x136>
 8006db2:	ea4f 6c14 	mov.w	ip, r4, lsr #24
 8006db6:	f005 05ff 	and.w	r5, r5, #255	; 0xff
 8006dba:	e050      	b.n	8006e5e <strcmp_unaligned+0x136>
 8006dbc:	ea4f 4c04 	mov.w	ip, r4, lsl #16
 8006dc0:	eba4 0302 	sub.w	r3, r4, r2
 8006dc4:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 8006dc8:	ea23 0304 	bic.w	r3, r3, r4
 8006dcc:	ebbc 4f15 	cmp.w	ip, r5, lsr #16
 8006dd0:	d117      	bne.n	8006e02 <strcmp_unaligned+0xda>
 8006dd2:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 8006dd6:	bf08      	it	eq
 8006dd8:	f851 5b04 	ldreq.w	r5, [r1], #4
 8006ddc:	d107      	bne.n	8006dee <strcmp_unaligned+0xc6>
 8006dde:	ea8c 0c04 	eor.w	ip, ip, r4
 8006de2:	ebbc 4f05 	cmp.w	ip, r5, lsl #16
 8006de6:	d108      	bne.n	8006dfa <strcmp_unaligned+0xd2>
 8006de8:	f850 4b04 	ldr.w	r4, [r0], #4
 8006dec:	e7e6      	b.n	8006dbc <strcmp_unaligned+0x94>
 8006dee:	041b      	lsls	r3, r3, #16
 8006df0:	d12e      	bne.n	8006e50 <strcmp_unaligned+0x128>
 8006df2:	880d      	ldrh	r5, [r1, #0]
 8006df4:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 8006df8:	e031      	b.n	8006e5e <strcmp_unaligned+0x136>
 8006dfa:	ea4f 4505 	mov.w	r5, r5, lsl #16
 8006dfe:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 8006e02:	ea4f 4515 	mov.w	r5, r5, lsr #16
 8006e06:	e02a      	b.n	8006e5e <strcmp_unaligned+0x136>
 8006e08:	f004 0cff 	and.w	ip, r4, #255	; 0xff
 8006e0c:	ebbc 6f15 	cmp.w	ip, r5, lsr #24
 8006e10:	eba4 0302 	sub.w	r3, r4, r2
 8006e14:	ea23 0304 	bic.w	r3, r3, r4
 8006e18:	d10d      	bne.n	8006e36 <strcmp_unaligned+0x10e>
 8006e1a:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 8006e1e:	bf08      	it	eq
 8006e20:	f851 5b04 	ldreq.w	r5, [r1], #4
 8006e24:	d10a      	bne.n	8006e3c <strcmp_unaligned+0x114>
 8006e26:	ea8c 0c04 	eor.w	ip, ip, r4
 8006e2a:	ebbc 2f05 	cmp.w	ip, r5, lsl #8
 8006e2e:	d10a      	bne.n	8006e46 <strcmp_unaligned+0x11e>
 8006e30:	f850 4b04 	ldr.w	r4, [r0], #4
 8006e34:	e7e8      	b.n	8006e08 <strcmp_unaligned+0xe0>
 8006e36:	ea4f 6515 	mov.w	r5, r5, lsr #24
 8006e3a:	e010      	b.n	8006e5e <strcmp_unaligned+0x136>
 8006e3c:	f014 0fff 	tst.w	r4, #255	; 0xff
 8006e40:	d006      	beq.n	8006e50 <strcmp_unaligned+0x128>
 8006e42:	f851 5b04 	ldr.w	r5, [r1], #4
 8006e46:	ea4f 2c14 	mov.w	ip, r4, lsr #8
 8006e4a:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
 8006e4e:	e006      	b.n	8006e5e <strcmp_unaligned+0x136>
 8006e50:	f04f 0000 	mov.w	r0, #0
 8006e54:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006e58:	f85d 5b04 	ldr.w	r5, [sp], #4
 8006e5c:	4770      	bx	lr
 8006e5e:	f00c 02ff 	and.w	r2, ip, #255	; 0xff
 8006e62:	f005 00ff 	and.w	r0, r5, #255	; 0xff
 8006e66:	2801      	cmp	r0, #1
 8006e68:	bf28      	it	cs
 8006e6a:	4290      	cmpcs	r0, r2
 8006e6c:	bf04      	itt	eq
 8006e6e:	ea4f 2c1c 	moveq.w	ip, ip, lsr #8
 8006e72:	0a2d      	lsreq	r5, r5, #8
 8006e74:	d0f3      	beq.n	8006e5e <strcmp_unaligned+0x136>
 8006e76:	eba2 0000 	sub.w	r0, r2, r0
 8006e7a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006e7e:	f85d 5b04 	ldr.w	r5, [sp], #4
 8006e82:	4770      	bx	lr

08006e84 <_svfprintf_r>:
 8006e84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006e88:	b0c5      	sub	sp, #276	; 0x114
 8006e8a:	4614      	mov	r4, r2
 8006e8c:	9312      	str	r3, [sp, #72]	; 0x48
 8006e8e:	910c      	str	r1, [sp, #48]	; 0x30
 8006e90:	9011      	str	r0, [sp, #68]	; 0x44
 8006e92:	f002 ff11 	bl	8009cb8 <_localeconv_r>
 8006e96:	6800      	ldr	r0, [r0, #0]
 8006e98:	9019      	str	r0, [sp, #100]	; 0x64
 8006e9a:	f003 fe3d 	bl	800ab18 <strlen>
 8006e9e:	901c      	str	r0, [sp, #112]	; 0x70
 8006ea0:	980c      	ldr	r0, [sp, #48]	; 0x30
 8006ea2:	8983      	ldrh	r3, [r0, #12]
 8006ea4:	f013 0f80 	tst.w	r3, #128	; 0x80
 8006ea8:	d003      	beq.n	8006eb2 <_svfprintf_r+0x2e>
 8006eaa:	6903      	ldr	r3, [r0, #16]
 8006eac:	2b00      	cmp	r3, #0
 8006eae:	f001 816f 	beq.w	8008190 <_svfprintf_r+0x130c>
 8006eb2:	f10d 0a7c 	add.w	sl, sp, #124	; 0x7c
 8006eb6:	2300      	movs	r3, #0
 8006eb8:	4656      	mov	r6, sl
 8006eba:	f10d 01f7 	add.w	r1, sp, #247	; 0xf7
 8006ebe:	930e      	str	r3, [sp, #56]	; 0x38
 8006ec0:	9409      	str	r4, [sp, #36]	; 0x24
 8006ec2:	931a      	str	r3, [sp, #104]	; 0x68
 8006ec4:	931b      	str	r3, [sp, #108]	; 0x6c
 8006ec6:	9317      	str	r3, [sp, #92]	; 0x5c
 8006ec8:	931d      	str	r3, [sp, #116]	; 0x74
 8006eca:	930f      	str	r3, [sp, #60]	; 0x3c
 8006ecc:	9107      	str	r1, [sp, #28]
 8006ece:	f8cd a0e4 	str.w	sl, [sp, #228]	; 0xe4
 8006ed2:	933b      	str	r3, [sp, #236]	; 0xec
 8006ed4:	933a      	str	r3, [sp, #232]	; 0xe8
 8006ed6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8006ed8:	7813      	ldrb	r3, [r2, #0]
 8006eda:	f1b3 0225 	subs.w	r2, r3, #37	; 0x25
 8006ede:	bf18      	it	ne
 8006ee0:	2201      	movne	r2, #1
 8006ee2:	2b00      	cmp	r3, #0
 8006ee4:	bf0c      	ite	eq
 8006ee6:	2300      	moveq	r3, #0
 8006ee8:	f002 0301 	andne.w	r3, r2, #1
 8006eec:	2b00      	cmp	r3, #0
 8006eee:	f000 80bd 	beq.w	800706c <_svfprintf_r+0x1e8>
 8006ef2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006ef4:	1c5a      	adds	r2, r3, #1
 8006ef6:	4617      	mov	r7, r2
 8006ef8:	3201      	adds	r2, #1
 8006efa:	783b      	ldrb	r3, [r7, #0]
 8006efc:	1e19      	subs	r1, r3, #0
 8006efe:	bf18      	it	ne
 8006f00:	2101      	movne	r1, #1
 8006f02:	2b25      	cmp	r3, #37	; 0x25
 8006f04:	bf0c      	ite	eq
 8006f06:	2300      	moveq	r3, #0
 8006f08:	f001 0301 	andne.w	r3, r1, #1
 8006f0c:	2b00      	cmp	r3, #0
 8006f0e:	d1f2      	bne.n	8006ef6 <_svfprintf_r+0x72>
 8006f10:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8006f12:	ebb7 0804 	subs.w	r8, r7, r4
 8006f16:	d010      	beq.n	8006f3a <_svfprintf_r+0xb6>
 8006f18:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006f1a:	9809      	ldr	r0, [sp, #36]	; 0x24
 8006f1c:	3401      	adds	r4, #1
 8006f1e:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006f20:	2c07      	cmp	r4, #7
 8006f22:	f8c6 8004 	str.w	r8, [r6, #4]
 8006f26:	6030      	str	r0, [r6, #0]
 8006f28:	4445      	add	r5, r8
 8006f2a:	943a      	str	r4, [sp, #232]	; 0xe8
 8006f2c:	953b      	str	r5, [sp, #236]	; 0xec
 8006f2e:	f300 8081 	bgt.w	8007034 <_svfprintf_r+0x1b0>
 8006f32:	3608      	adds	r6, #8
 8006f34:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8006f36:	4441      	add	r1, r8
 8006f38:	910f      	str	r1, [sp, #60]	; 0x3c
 8006f3a:	783b      	ldrb	r3, [r7, #0]
 8006f3c:	2b00      	cmp	r3, #0
 8006f3e:	f000 8081 	beq.w	8007044 <_svfprintf_r+0x1c0>
 8006f42:	1c7c      	adds	r4, r7, #1
 8006f44:	2200      	movs	r2, #0
 8006f46:	2300      	movs	r3, #0
 8006f48:	920d      	str	r2, [sp, #52]	; 0x34
 8006f4a:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
 8006f4e:	2520      	movs	r5, #32
 8006f50:	9409      	str	r4, [sp, #36]	; 0x24
 8006f52:	212b      	movs	r1, #43	; 0x2b
 8006f54:	787b      	ldrb	r3, [r7, #1]
 8006f56:	f04f 37ff 	mov.w	r7, #4294967295
 8006f5a:	9208      	str	r2, [sp, #32]
 8006f5c:	4622      	mov	r2, r4
 8006f5e:	3201      	adds	r2, #1
 8006f60:	f1a3 0020 	sub.w	r0, r3, #32
 8006f64:	2858      	cmp	r0, #88	; 0x58
 8006f66:	f200 831c 	bhi.w	80075a2 <_svfprintf_r+0x71e>
 8006f6a:	e8df f010 	tbh	[pc, r0, lsl #1]
 8006f6e:	032d      	.short	0x032d
 8006f70:	031a031a 	.word	0x031a031a
 8006f74:	031a0336 	.word	0x031a0336
 8006f78:	031a031a 	.word	0x031a031a
 8006f7c:	031a031a 	.word	0x031a031a
 8006f80:	03c7031a 	.word	0x03c7031a
 8006f84:	031a0081 	.word	0x031a0081
 8006f88:	0085005d 	.word	0x0085005d
 8006f8c:	009f031a 	.word	0x009f031a
 8006f90:	00a500a5 	.word	0x00a500a5
 8006f94:	00a500a5 	.word	0x00a500a5
 8006f98:	00a500a5 	.word	0x00a500a5
 8006f9c:	00a500a5 	.word	0x00a500a5
 8006fa0:	031a00a5 	.word	0x031a00a5
 8006fa4:	031a031a 	.word	0x031a031a
 8006fa8:	031a031a 	.word	0x031a031a
 8006fac:	031a031a 	.word	0x031a031a
 8006fb0:	031a031a 	.word	0x031a031a
 8006fb4:	00b7031a 	.word	0x00b7031a
 8006fb8:	031a0241 	.word	0x031a0241
 8006fbc:	031a0241 	.word	0x031a0241
 8006fc0:	031a031a 	.word	0x031a031a
 8006fc4:	027f031a 	.word	0x027f031a
 8006fc8:	031a031a 	.word	0x031a031a
 8006fcc:	031a0285 	.word	0x031a0285
 8006fd0:	031a031a 	.word	0x031a031a
 8006fd4:	031a031a 	.word	0x031a031a
 8006fd8:	031a02a3 	.word	0x031a02a3
 8006fdc:	02b2031a 	.word	0x02b2031a
 8006fe0:	031a031a 	.word	0x031a031a
 8006fe4:	031a031a 	.word	0x031a031a
 8006fe8:	031a031a 	.word	0x031a031a
 8006fec:	031a031a 	.word	0x031a031a
 8006ff0:	031a031a 	.word	0x031a031a
 8006ff4:	033c0354 	.word	0x033c0354
 8006ff8:	02410241 	.word	0x02410241
 8006ffc:	034e0241 	.word	0x034e0241
 8007000:	031a033c 	.word	0x031a033c
 8007004:	030b031a 	.word	0x030b031a
 8007008:	039a031a 	.word	0x039a031a
 800700c:	037e0368 	.word	0x037e0368
 8007010:	031a02dd 	.word	0x031a02dd
 8007014:	031a02e3 	.word	0x031a02e3
 8007018:	031a03ab 	.word	0x031a03ab
 800701c:	03d2031a 	.word	0x03d2031a
 8007020:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007022:	9012      	str	r0, [sp, #72]	; 0x48
 8007024:	425b      	negs	r3, r3
 8007026:	930d      	str	r3, [sp, #52]	; 0x34
 8007028:	9c08      	ldr	r4, [sp, #32]
 800702a:	f044 0404 	orr.w	r4, r4, #4
 800702e:	9408      	str	r4, [sp, #32]
 8007030:	7813      	ldrb	r3, [r2, #0]
 8007032:	e794      	b.n	8006f5e <_svfprintf_r+0xda>
 8007034:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007036:	aa39      	add	r2, sp, #228	; 0xe4
 8007038:	990c      	ldr	r1, [sp, #48]	; 0x30
 800703a:	f003 fd9d 	bl	800ab78 <__ssprint_r>
 800703e:	b940      	cbnz	r0, 8007052 <_svfprintf_r+0x1ce>
 8007040:	4656      	mov	r6, sl
 8007042:	e777      	b.n	8006f34 <_svfprintf_r+0xb0>
 8007044:	9b3b      	ldr	r3, [sp, #236]	; 0xec
 8007046:	b123      	cbz	r3, 8007052 <_svfprintf_r+0x1ce>
 8007048:	9811      	ldr	r0, [sp, #68]	; 0x44
 800704a:	aa39      	add	r2, sp, #228	; 0xe4
 800704c:	990c      	ldr	r1, [sp, #48]	; 0x30
 800704e:	f003 fd93 	bl	800ab78 <__ssprint_r>
 8007052:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007054:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8007056:	898b      	ldrh	r3, [r1, #12]
 8007058:	f013 0f40 	tst.w	r3, #64	; 0x40
 800705c:	bf18      	it	ne
 800705e:	f04f 32ff 	movne.w	r2, #4294967295
 8007062:	920f      	str	r2, [sp, #60]	; 0x3c
 8007064:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007066:	b045      	add	sp, #276	; 0x114
 8007068:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800706c:	9f09      	ldr	r7, [sp, #36]	; 0x24
 800706e:	e764      	b.n	8006f3a <_svfprintf_r+0xb6>
 8007070:	f88d 110f 	strb.w	r1, [sp, #271]	; 0x10f
 8007074:	7813      	ldrb	r3, [r2, #0]
 8007076:	e772      	b.n	8006f5e <_svfprintf_r+0xda>
 8007078:	f812 3b01 	ldrb.w	r3, [r2], #1
 800707c:	2b2a      	cmp	r3, #42	; 0x2a
 800707e:	f001 81fc 	beq.w	800847a <_svfprintf_r+0x15f6>
 8007082:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 8007086:	2809      	cmp	r0, #9
 8007088:	f201 81ac 	bhi.w	80083e4 <_svfprintf_r+0x1560>
 800708c:	4614      	mov	r4, r2
 800708e:	2700      	movs	r7, #0
 8007090:	f814 3b01 	ldrb.w	r3, [r4], #1
 8007094:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 8007098:	eb00 0747 	add.w	r7, r0, r7, lsl #1
 800709c:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 80070a0:	2809      	cmp	r0, #9
 80070a2:	4622      	mov	r2, r4
 80070a4:	d9f4      	bls.n	8007090 <_svfprintf_r+0x20c>
 80070a6:	ea47 77e7 	orr.w	r7, r7, r7, asr #31
 80070aa:	e759      	b.n	8006f60 <_svfprintf_r+0xdc>
 80070ac:	9b08      	ldr	r3, [sp, #32]
 80070ae:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80070b2:	9308      	str	r3, [sp, #32]
 80070b4:	7813      	ldrb	r3, [r2, #0]
 80070b6:	e752      	b.n	8006f5e <_svfprintf_r+0xda>
 80070b8:	4614      	mov	r4, r2
 80070ba:	2000      	movs	r0, #0
 80070bc:	f1a3 0830 	sub.w	r8, r3, #48	; 0x30
 80070c0:	f814 3b01 	ldrb.w	r3, [r4], #1
 80070c4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80070c8:	f1a3 0c30 	sub.w	ip, r3, #48	; 0x30
 80070cc:	4622      	mov	r2, r4
 80070ce:	f1bc 0f09 	cmp.w	ip, #9
 80070d2:	eb08 0040 	add.w	r0, r8, r0, lsl #1
 80070d6:	d9f1      	bls.n	80070bc <_svfprintf_r+0x238>
 80070d8:	900d      	str	r0, [sp, #52]	; 0x34
 80070da:	e741      	b.n	8006f60 <_svfprintf_r+0xdc>
 80070dc:	9209      	str	r2, [sp, #36]	; 0x24
 80070de:	9a08      	ldr	r2, [sp, #32]
 80070e0:	9316      	str	r3, [sp, #88]	; 0x58
 80070e2:	f042 0210 	orr.w	r2, r2, #16
 80070e6:	9208      	str	r2, [sp, #32]
 80070e8:	9b08      	ldr	r3, [sp, #32]
 80070ea:	f013 0f20 	tst.w	r3, #32
 80070ee:	f000 8281 	beq.w	80075f4 <_svfprintf_r+0x770>
 80070f2:	9c12      	ldr	r4, [sp, #72]	; 0x48
 80070f4:	1de3      	adds	r3, r4, #7
 80070f6:	f023 0307 	bic.w	r3, r3, #7
 80070fa:	f103 0008 	add.w	r0, r3, #8
 80070fe:	9012      	str	r0, [sp, #72]	; 0x48
 8007100:	e9d3 4500 	ldrd	r4, r5, [r3]
 8007104:	2c00      	cmp	r4, #0
 8007106:	f175 0200 	sbcs.w	r2, r5, #0
 800710a:	f2c0 85cd 	blt.w	8007ca8 <_svfprintf_r+0xe24>
 800710e:	ea54 0305 	orrs.w	r3, r4, r5
 8007112:	f04f 0301 	mov.w	r3, #1
 8007116:	bf0c      	ite	eq
 8007118:	2200      	moveq	r2, #0
 800711a:	2201      	movne	r2, #1
 800711c:	2f00      	cmp	r7, #0
 800711e:	bfa2      	ittt	ge
 8007120:	9908      	ldrge	r1, [sp, #32]
 8007122:	f021 0180 	bicge.w	r1, r1, #128	; 0x80
 8007126:	9108      	strge	r1, [sp, #32]
 8007128:	2f00      	cmp	r7, #0
 800712a:	bf18      	it	ne
 800712c:	f042 0201 	orrne.w	r2, r2, #1
 8007130:	2a00      	cmp	r2, #0
 8007132:	f000 83ac 	beq.w	800788e <_svfprintf_r+0xa0a>
 8007136:	2b01      	cmp	r3, #1
 8007138:	f000 84fe 	beq.w	8007b38 <_svfprintf_r+0xcb4>
 800713c:	2b02      	cmp	r3, #2
 800713e:	f000 84de 	beq.w	8007afe <_svfprintf_r+0xc7a>
 8007142:	f10d 0bbc 	add.w	fp, sp, #188	; 0xbc
 8007146:	f10b 0327 	add.w	r3, fp, #39	; 0x27
 800714a:	08ea      	lsrs	r2, r5, #3
 800714c:	ea4f 08d4 	mov.w	r8, r4, lsr #3
 8007150:	ea48 7845 	orr.w	r8, r8, r5, lsl #29
 8007154:	f004 0407 	and.w	r4, r4, #7
 8007158:	4611      	mov	r1, r2
 800715a:	f104 0230 	add.w	r2, r4, #48	; 0x30
 800715e:	460d      	mov	r5, r1
 8007160:	4644      	mov	r4, r8
 8007162:	469c      	mov	ip, r3
 8007164:	701a      	strb	r2, [r3, #0]
 8007166:	3b01      	subs	r3, #1
 8007168:	ea54 0005 	orrs.w	r0, r4, r5
 800716c:	d1ed      	bne.n	800714a <_svfprintf_r+0x2c6>
 800716e:	9908      	ldr	r1, [sp, #32]
 8007170:	f8cd c04c 	str.w	ip, [sp, #76]	; 0x4c
 8007174:	f011 0f01 	tst.w	r1, #1
 8007178:	f040 8588 	bne.w	8007c8c <_svfprintf_r+0xe08>
 800717c:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8007180:	ebcc 020b 	rsb	r2, ip, fp
 8007184:	9210      	str	r2, [sp, #64]	; 0x40
 8007186:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 800718a:	2000      	movs	r0, #0
 800718c:	9c10      	ldr	r4, [sp, #64]	; 0x40
 800718e:	9714      	str	r7, [sp, #80]	; 0x50
 8007190:	42bc      	cmp	r4, r7
 8007192:	bfb8      	it	lt
 8007194:	463c      	movlt	r4, r7
 8007196:	9018      	str	r0, [sp, #96]	; 0x60
 8007198:	940a      	str	r4, [sp, #40]	; 0x28
 800719a:	b112      	cbz	r2, 80071a2 <_svfprintf_r+0x31e>
 800719c:	980a      	ldr	r0, [sp, #40]	; 0x28
 800719e:	3001      	adds	r0, #1
 80071a0:	900a      	str	r0, [sp, #40]	; 0x28
 80071a2:	9908      	ldr	r1, [sp, #32]
 80071a4:	f011 0b02 	ands.w	fp, r1, #2
 80071a8:	d002      	beq.n	80071b0 <_svfprintf_r+0x32c>
 80071aa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80071ac:	3302      	adds	r3, #2
 80071ae:	930a      	str	r3, [sp, #40]	; 0x28
 80071b0:	9c08      	ldr	r4, [sp, #32]
 80071b2:	f014 0484 	ands.w	r4, r4, #132	; 0x84
 80071b6:	9415      	str	r4, [sp, #84]	; 0x54
 80071b8:	f040 82cd 	bne.w	8007756 <_svfprintf_r+0x8d2>
 80071bc:	980d      	ldr	r0, [sp, #52]	; 0x34
 80071be:	990a      	ldr	r1, [sp, #40]	; 0x28
 80071c0:	1a47      	subs	r7, r0, r1
 80071c2:	2f00      	cmp	r7, #0
 80071c4:	f340 82c7 	ble.w	8007756 <_svfprintf_r+0x8d2>
 80071c8:	2f10      	cmp	r7, #16
 80071ca:	f341 8065 	ble.w	8008298 <_svfprintf_r+0x1414>
 80071ce:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80071d0:	f64c 7848 	movw	r8, #53064	; 0xcf48
 80071d4:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80071d6:	f6c0 0800 	movt	r8, #2048	; 0x800
 80071da:	4629      	mov	r1, r5
 80071dc:	f04f 0910 	mov.w	r9, #16
 80071e0:	4622      	mov	r2, r4
 80071e2:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 80071e4:	4644      	mov	r4, r8
 80071e6:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 80071ea:	e002      	b.n	80071f2 <_svfprintf_r+0x36e>
 80071ec:	3f10      	subs	r7, #16
 80071ee:	2f10      	cmp	r7, #16
 80071f0:	dd1b      	ble.n	800722a <_svfprintf_r+0x3a6>
 80071f2:	3201      	adds	r2, #1
 80071f4:	6034      	str	r4, [r6, #0]
 80071f6:	f8c6 9004 	str.w	r9, [r6, #4]
 80071fa:	3110      	adds	r1, #16
 80071fc:	3608      	adds	r6, #8
 80071fe:	2a07      	cmp	r2, #7
 8007200:	923a      	str	r2, [sp, #232]	; 0xe8
 8007202:	f106 0308 	add.w	r3, r6, #8
 8007206:	913b      	str	r1, [sp, #236]	; 0xec
 8007208:	ddf0      	ble.n	80071ec <_svfprintf_r+0x368>
 800720a:	4640      	mov	r0, r8
 800720c:	4629      	mov	r1, r5
 800720e:	aa39      	add	r2, sp, #228	; 0xe4
 8007210:	4656      	mov	r6, sl
 8007212:	f003 fcb1 	bl	800ab78 <__ssprint_r>
 8007216:	f10a 0308 	add.w	r3, sl, #8
 800721a:	2800      	cmp	r0, #0
 800721c:	f47f af19 	bne.w	8007052 <_svfprintf_r+0x1ce>
 8007220:	3f10      	subs	r7, #16
 8007222:	993b      	ldr	r1, [sp, #236]	; 0xec
 8007224:	2f10      	cmp	r7, #16
 8007226:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 8007228:	dce3      	bgt.n	80071f2 <_svfprintf_r+0x36e>
 800722a:	46a0      	mov	r8, r4
 800722c:	460d      	mov	r5, r1
 800722e:	4614      	mov	r4, r2
 8007230:	3401      	adds	r4, #1
 8007232:	f8c6 8000 	str.w	r8, [r6]
 8007236:	2c07      	cmp	r4, #7
 8007238:	6077      	str	r7, [r6, #4]
 800723a:	443d      	add	r5, r7
 800723c:	943a      	str	r4, [sp, #232]	; 0xe8
 800723e:	953b      	str	r5, [sp, #236]	; 0xec
 8007240:	f300 827e 	bgt.w	8007740 <_svfprintf_r+0x8bc>
 8007244:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8007248:	461e      	mov	r6, r3
 800724a:	b16a      	cbz	r2, 8007268 <_svfprintf_r+0x3e4>
 800724c:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 800724e:	ab43      	add	r3, sp, #268	; 0x10c
 8007250:	3303      	adds	r3, #3
 8007252:	6033      	str	r3, [r6, #0]
 8007254:	3401      	adds	r4, #1
 8007256:	2301      	movs	r3, #1
 8007258:	2c07      	cmp	r4, #7
 800725a:	6073      	str	r3, [r6, #4]
 800725c:	441d      	add	r5, r3
 800725e:	943a      	str	r4, [sp, #232]	; 0xe8
 8007260:	953b      	str	r5, [sp, #236]	; 0xec
 8007262:	f300 83e9 	bgt.w	8007a38 <_svfprintf_r+0xbb4>
 8007266:	3608      	adds	r6, #8
 8007268:	f1bb 0f00 	cmp.w	fp, #0
 800726c:	d00c      	beq.n	8007288 <_svfprintf_r+0x404>
 800726e:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007270:	ab43      	add	r3, sp, #268	; 0x10c
 8007272:	6033      	str	r3, [r6, #0]
 8007274:	2302      	movs	r3, #2
 8007276:	3401      	adds	r4, #1
 8007278:	6073      	str	r3, [r6, #4]
 800727a:	2c07      	cmp	r4, #7
 800727c:	441d      	add	r5, r3
 800727e:	943a      	str	r4, [sp, #232]	; 0xe8
 8007280:	953b      	str	r5, [sp, #236]	; 0xec
 8007282:	f300 83ce 	bgt.w	8007a22 <_svfprintf_r+0xb9e>
 8007286:	3608      	adds	r6, #8
 8007288:	9a15      	ldr	r2, [sp, #84]	; 0x54
 800728a:	2a80      	cmp	r2, #128	; 0x80
 800728c:	f000 8310 	beq.w	80078b0 <_svfprintf_r+0xa2c>
 8007290:	9914      	ldr	r1, [sp, #80]	; 0x50
 8007292:	9810      	ldr	r0, [sp, #64]	; 0x40
 8007294:	1a0f      	subs	r7, r1, r0
 8007296:	2f00      	cmp	r7, #0
 8007298:	f340 835b 	ble.w	8007952 <_svfprintf_r+0xace>
 800729c:	2f10      	cmp	r7, #16
 800729e:	f340 85eb 	ble.w	8007e78 <_svfprintf_r+0xff4>
 80072a2:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80072a4:	462a      	mov	r2, r5
 80072a6:	f8df 8a98 	ldr.w	r8, [pc, #2712]	; 8007d40 <_svfprintf_r+0xebc>
 80072aa:	f04f 0b10 	mov.w	fp, #16
 80072ae:	4623      	mov	r3, r4
 80072b0:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 80072b2:	4644      	mov	r4, r8
 80072b4:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 80072b8:	e002      	b.n	80072c0 <_svfprintf_r+0x43c>
 80072ba:	3f10      	subs	r7, #16
 80072bc:	2f10      	cmp	r7, #16
 80072be:	dd1b      	ble.n	80072f8 <_svfprintf_r+0x474>
 80072c0:	3301      	adds	r3, #1
 80072c2:	6034      	str	r4, [r6, #0]
 80072c4:	f8c6 b004 	str.w	fp, [r6, #4]
 80072c8:	3210      	adds	r2, #16
 80072ca:	3608      	adds	r6, #8
 80072cc:	2b07      	cmp	r3, #7
 80072ce:	933a      	str	r3, [sp, #232]	; 0xe8
 80072d0:	f106 0908 	add.w	r9, r6, #8
 80072d4:	923b      	str	r2, [sp, #236]	; 0xec
 80072d6:	ddf0      	ble.n	80072ba <_svfprintf_r+0x436>
 80072d8:	4640      	mov	r0, r8
 80072da:	4629      	mov	r1, r5
 80072dc:	aa39      	add	r2, sp, #228	; 0xe4
 80072de:	f10a 0908 	add.w	r9, sl, #8
 80072e2:	f003 fc49 	bl	800ab78 <__ssprint_r>
 80072e6:	4656      	mov	r6, sl
 80072e8:	2800      	cmp	r0, #0
 80072ea:	f47f aeb2 	bne.w	8007052 <_svfprintf_r+0x1ce>
 80072ee:	3f10      	subs	r7, #16
 80072f0:	9a3b      	ldr	r2, [sp, #236]	; 0xec
 80072f2:	2f10      	cmp	r7, #16
 80072f4:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 80072f6:	dce3      	bgt.n	80072c0 <_svfprintf_r+0x43c>
 80072f8:	46a0      	mov	r8, r4
 80072fa:	4615      	mov	r5, r2
 80072fc:	461c      	mov	r4, r3
 80072fe:	3401      	adds	r4, #1
 8007300:	f8c6 8000 	str.w	r8, [r6]
 8007304:	2c07      	cmp	r4, #7
 8007306:	6077      	str	r7, [r6, #4]
 8007308:	443d      	add	r5, r7
 800730a:	943a      	str	r4, [sp, #232]	; 0xe8
 800730c:	953b      	str	r5, [sp, #236]	; 0xec
 800730e:	f300 837d 	bgt.w	8007a0c <_svfprintf_r+0xb88>
 8007312:	9a08      	ldr	r2, [sp, #32]
 8007314:	f412 7f80 	tst.w	r2, #256	; 0x100
 8007318:	f040 824e 	bne.w	80077b8 <_svfprintf_r+0x934>
 800731c:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 800731e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007320:	3401      	adds	r4, #1
 8007322:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8007324:	2c07      	cmp	r4, #7
 8007326:	441d      	add	r5, r3
 8007328:	f8c9 3004 	str.w	r3, [r9, #4]
 800732c:	f8c9 0000 	str.w	r0, [r9]
 8007330:	953b      	str	r5, [sp, #236]	; 0xec
 8007332:	943a      	str	r4, [sp, #232]	; 0xe8
 8007334:	f300 8235 	bgt.w	80077a2 <_svfprintf_r+0x91e>
 8007338:	f109 0908 	add.w	r9, r9, #8
 800733c:	9c08      	ldr	r4, [sp, #32]
 800733e:	f014 0f04 	tst.w	r4, #4
 8007342:	d046      	beq.n	80073d2 <_svfprintf_r+0x54e>
 8007344:	980d      	ldr	r0, [sp, #52]	; 0x34
 8007346:	990a      	ldr	r1, [sp, #40]	; 0x28
 8007348:	1a46      	subs	r6, r0, r1
 800734a:	2e00      	cmp	r6, #0
 800734c:	dd41      	ble.n	80073d2 <_svfprintf_r+0x54e>
 800734e:	2e10      	cmp	r6, #16
 8007350:	f340 87da 	ble.w	8008308 <_svfprintf_r+0x1484>
 8007354:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007356:	f64c 7848 	movw	r8, #53064	; 0xcf48
 800735a:	f6c0 0800 	movt	r8, #2048	; 0x800
 800735e:	2710      	movs	r7, #16
 8007360:	4623      	mov	r3, r4
 8007362:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 8007366:	4644      	mov	r4, r8
 8007368:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 800736c:	e002      	b.n	8007374 <_svfprintf_r+0x4f0>
 800736e:	3e10      	subs	r6, #16
 8007370:	2e10      	cmp	r6, #16
 8007372:	dd19      	ble.n	80073a8 <_svfprintf_r+0x524>
 8007374:	3301      	adds	r3, #1
 8007376:	3510      	adds	r5, #16
 8007378:	2b07      	cmp	r3, #7
 800737a:	f8c9 4000 	str.w	r4, [r9]
 800737e:	f8c9 7004 	str.w	r7, [r9, #4]
 8007382:	f109 0908 	add.w	r9, r9, #8
 8007386:	933a      	str	r3, [sp, #232]	; 0xe8
 8007388:	953b      	str	r5, [sp, #236]	; 0xec
 800738a:	ddf0      	ble.n	800736e <_svfprintf_r+0x4ea>
 800738c:	4640      	mov	r0, r8
 800738e:	4659      	mov	r1, fp
 8007390:	aa39      	add	r2, sp, #228	; 0xe4
 8007392:	46d1      	mov	r9, sl
 8007394:	f003 fbf0 	bl	800ab78 <__ssprint_r>
 8007398:	2800      	cmp	r0, #0
 800739a:	f47f ae5a 	bne.w	8007052 <_svfprintf_r+0x1ce>
 800739e:	3e10      	subs	r6, #16
 80073a0:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80073a2:	2e10      	cmp	r6, #16
 80073a4:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 80073a6:	dce5      	bgt.n	8007374 <_svfprintf_r+0x4f0>
 80073a8:	46a0      	mov	r8, r4
 80073aa:	461c      	mov	r4, r3
 80073ac:	3401      	adds	r4, #1
 80073ae:	f8c9 8000 	str.w	r8, [r9]
 80073b2:	2c07      	cmp	r4, #7
 80073b4:	f8c9 6004 	str.w	r6, [r9, #4]
 80073b8:	4435      	add	r5, r6
 80073ba:	943a      	str	r4, [sp, #232]	; 0xe8
 80073bc:	953b      	str	r5, [sp, #236]	; 0xec
 80073be:	dd08      	ble.n	80073d2 <_svfprintf_r+0x54e>
 80073c0:	9811      	ldr	r0, [sp, #68]	; 0x44
 80073c2:	aa39      	add	r2, sp, #228	; 0xe4
 80073c4:	990c      	ldr	r1, [sp, #48]	; 0x30
 80073c6:	f003 fbd7 	bl	800ab78 <__ssprint_r>
 80073ca:	2800      	cmp	r0, #0
 80073cc:	f47f ae41 	bne.w	8007052 <_svfprintf_r+0x1ce>
 80073d0:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80073d2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80073d4:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80073d6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80073d8:	429c      	cmp	r4, r3
 80073da:	bfac      	ite	ge
 80073dc:	1912      	addge	r2, r2, r4
 80073de:	18d2      	addlt	r2, r2, r3
 80073e0:	920f      	str	r2, [sp, #60]	; 0x3c
 80073e2:	2d00      	cmp	r5, #0
 80073e4:	f040 8303 	bne.w	80079ee <_svfprintf_r+0xb6a>
 80073e8:	2000      	movs	r0, #0
 80073ea:	4656      	mov	r6, sl
 80073ec:	903a      	str	r0, [sp, #232]	; 0xe8
 80073ee:	e572      	b.n	8006ed6 <_svfprintf_r+0x52>
 80073f0:	9908      	ldr	r1, [sp, #32]
 80073f2:	461d      	mov	r5, r3
 80073f4:	9209      	str	r2, [sp, #36]	; 0x24
 80073f6:	f011 0f08 	tst.w	r1, #8
 80073fa:	9316      	str	r3, [sp, #88]	; 0x58
 80073fc:	f000 8487 	beq.w	8007d0e <_svfprintf_r+0xe8a>
 8007400:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8007402:	1dd3      	adds	r3, r2, #7
 8007404:	f023 0307 	bic.w	r3, r3, #7
 8007408:	f103 0408 	add.w	r4, r3, #8
 800740c:	9412      	str	r4, [sp, #72]	; 0x48
 800740e:	6818      	ldr	r0, [r3, #0]
 8007410:	901a      	str	r0, [sp, #104]	; 0x68
 8007412:	685b      	ldr	r3, [r3, #4]
 8007414:	931b      	str	r3, [sp, #108]	; 0x6c
 8007416:	981a      	ldr	r0, [sp, #104]	; 0x68
 8007418:	991b      	ldr	r1, [sp, #108]	; 0x6c
 800741a:	f003 faeb 	bl	800a9f4 <__fpclassifyd>
 800741e:	2801      	cmp	r0, #1
 8007420:	f040 8450 	bne.w	8007cc4 <_svfprintf_r+0xe40>
 8007424:	981a      	ldr	r0, [sp, #104]	; 0x68
 8007426:	2200      	movs	r2, #0
 8007428:	2300      	movs	r3, #0
 800742a:	991b      	ldr	r1, [sp, #108]	; 0x6c
 800742c:	f005 f86c 	bl	800c508 <__aeabi_dcmplt>
 8007430:	2800      	cmp	r0, #0
 8007432:	f040 871c 	bne.w	800826e <_svfprintf_r+0x13ea>
 8007436:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 800743a:	2003      	movs	r0, #3
 800743c:	f24d 13e0 	movw	r3, #53728	; 0xd1e0
 8007440:	f24d 11dc 	movw	r1, #53724	; 0xd1dc
 8007444:	900a      	str	r0, [sp, #40]	; 0x28
 8007446:	9816      	ldr	r0, [sp, #88]	; 0x58
 8007448:	f6c0 0100 	movt	r1, #2048	; 0x800
 800744c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8007450:	2400      	movs	r4, #0
 8007452:	2847      	cmp	r0, #71	; 0x47
 8007454:	bfd8      	it	le
 8007456:	460b      	movle	r3, r1
 8007458:	9908      	ldr	r1, [sp, #32]
 800745a:	9313      	str	r3, [sp, #76]	; 0x4c
 800745c:	2303      	movs	r3, #3
 800745e:	f021 0180 	bic.w	r1, r1, #128	; 0x80
 8007462:	9414      	str	r4, [sp, #80]	; 0x50
 8007464:	9108      	str	r1, [sp, #32]
 8007466:	9310      	str	r3, [sp, #64]	; 0x40
 8007468:	9418      	str	r4, [sp, #96]	; 0x60
 800746a:	e696      	b.n	800719a <_svfprintf_r+0x316>
 800746c:	9c08      	ldr	r4, [sp, #32]
 800746e:	f044 0408 	orr.w	r4, r4, #8
 8007472:	9408      	str	r4, [sp, #32]
 8007474:	7813      	ldrb	r3, [r2, #0]
 8007476:	e572      	b.n	8006f5e <_svfprintf_r+0xda>
 8007478:	9908      	ldr	r1, [sp, #32]
 800747a:	9209      	str	r2, [sp, #36]	; 0x24
 800747c:	f041 0110 	orr.w	r1, r1, #16
 8007480:	9108      	str	r1, [sp, #32]
 8007482:	9a08      	ldr	r2, [sp, #32]
 8007484:	9316      	str	r3, [sp, #88]	; 0x58
 8007486:	f012 0320 	ands.w	r3, r2, #32
 800748a:	f000 80df 	beq.w	800764c <_svfprintf_r+0x7c8>
 800748e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8007490:	1dda      	adds	r2, r3, #7
 8007492:	2300      	movs	r3, #0
 8007494:	f022 0207 	bic.w	r2, r2, #7
 8007498:	f102 0408 	add.w	r4, r2, #8
 800749c:	9412      	str	r4, [sp, #72]	; 0x48
 800749e:	e9d2 4500 	ldrd	r4, r5, [r2]
 80074a2:	ea54 0005 	orrs.w	r0, r4, r5
 80074a6:	bf0c      	ite	eq
 80074a8:	2200      	moveq	r2, #0
 80074aa:	2201      	movne	r2, #1
 80074ac:	2000      	movs	r0, #0
 80074ae:	f88d 010f 	strb.w	r0, [sp, #271]	; 0x10f
 80074b2:	e633      	b.n	800711c <_svfprintf_r+0x298>
 80074b4:	9c08      	ldr	r4, [sp, #32]
 80074b6:	9209      	str	r2, [sp, #36]	; 0x24
 80074b8:	f044 0410 	orr.w	r4, r4, #16
 80074bc:	9408      	str	r4, [sp, #32]
 80074be:	9808      	ldr	r0, [sp, #32]
 80074c0:	9316      	str	r3, [sp, #88]	; 0x58
 80074c2:	f010 0f20 	tst.w	r0, #32
 80074c6:	f000 8104 	beq.w	80076d2 <_svfprintf_r+0x84e>
 80074ca:	9912      	ldr	r1, [sp, #72]	; 0x48
 80074cc:	2301      	movs	r3, #1
 80074ce:	1dca      	adds	r2, r1, #7
 80074d0:	e7e0      	b.n	8007494 <_svfprintf_r+0x610>
 80074d2:	9209      	str	r2, [sp, #36]	; 0x24
 80074d4:	f24d 11ec 	movw	r1, #53740	; 0xd1ec
 80074d8:	9a08      	ldr	r2, [sp, #32]
 80074da:	f6c0 0100 	movt	r1, #2048	; 0x800
 80074de:	9316      	str	r3, [sp, #88]	; 0x58
 80074e0:	f012 0f20 	tst.w	r2, #32
 80074e4:	9117      	str	r1, [sp, #92]	; 0x5c
 80074e6:	f000 8120 	beq.w	800772a <_svfprintf_r+0x8a6>
 80074ea:	9c12      	ldr	r4, [sp, #72]	; 0x48
 80074ec:	1de3      	adds	r3, r4, #7
 80074ee:	f023 0307 	bic.w	r3, r3, #7
 80074f2:	f103 0008 	add.w	r0, r3, #8
 80074f6:	9012      	str	r0, [sp, #72]	; 0x48
 80074f8:	e9d3 4500 	ldrd	r4, r5, [r3]
 80074fc:	ea54 0205 	orrs.w	r2, r4, r5
 8007500:	9b08      	ldr	r3, [sp, #32]
 8007502:	bf0c      	ite	eq
 8007504:	2200      	moveq	r2, #0
 8007506:	2201      	movne	r2, #1
 8007508:	4213      	tst	r3, r2
 800750a:	f000 8369 	beq.w	8007be0 <_svfprintf_r+0xd5c>
 800750e:	9816      	ldr	r0, [sp, #88]	; 0x58
 8007510:	2330      	movs	r3, #48	; 0x30
 8007512:	9908      	ldr	r1, [sp, #32]
 8007514:	2201      	movs	r2, #1
 8007516:	f88d 310c 	strb.w	r3, [sp, #268]	; 0x10c
 800751a:	2302      	movs	r3, #2
 800751c:	f041 0102 	orr.w	r1, r1, #2
 8007520:	f88d 010d 	strb.w	r0, [sp, #269]	; 0x10d
 8007524:	9108      	str	r1, [sp, #32]
 8007526:	e7c1      	b.n	80074ac <_svfprintf_r+0x628>
 8007528:	9808      	ldr	r0, [sp, #32]
 800752a:	f040 0020 	orr.w	r0, r0, #32
 800752e:	9008      	str	r0, [sp, #32]
 8007530:	7813      	ldrb	r3, [r2, #0]
 8007532:	e514      	b.n	8006f5e <_svfprintf_r+0xda>
 8007534:	9209      	str	r2, [sp, #36]	; 0x24
 8007536:	2100      	movs	r1, #0
 8007538:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800753a:	9316      	str	r3, [sp, #88]	; 0x58
 800753c:	f88d 110f 	strb.w	r1, [sp, #271]	; 0x10f
 8007540:	1d14      	adds	r4, r2, #4
 8007542:	6813      	ldr	r3, [r2, #0]
 8007544:	9313      	str	r3, [sp, #76]	; 0x4c
 8007546:	2b00      	cmp	r3, #0
 8007548:	f000 86f0 	beq.w	800832c <_svfprintf_r+0x14a8>
 800754c:	2f00      	cmp	r7, #0
 800754e:	f2c0 8693 	blt.w	8008278 <_svfprintf_r+0x13f4>
 8007552:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8007554:	2100      	movs	r1, #0
 8007556:	463a      	mov	r2, r7
 8007558:	f002 fbbe 	bl	8009cd8 <memchr>
 800755c:	2800      	cmp	r0, #0
 800755e:	f000 8736 	beq.w	80083ce <_svfprintf_r+0x154a>
 8007562:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8007564:	1ac0      	subs	r0, r0, r3
 8007566:	9010      	str	r0, [sp, #64]	; 0x40
 8007568:	42b8      	cmp	r0, r7
 800756a:	f340 84f4 	ble.w	8007f56 <_svfprintf_r+0x10d2>
 800756e:	2000      	movs	r0, #0
 8007570:	ea27 71e7 	bic.w	r1, r7, r7, asr #31
 8007574:	9014      	str	r0, [sp, #80]	; 0x50
 8007576:	910a      	str	r1, [sp, #40]	; 0x28
 8007578:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 800757c:	9412      	str	r4, [sp, #72]	; 0x48
 800757e:	9710      	str	r7, [sp, #64]	; 0x40
 8007580:	9018      	str	r0, [sp, #96]	; 0x60
 8007582:	e60a      	b.n	800719a <_svfprintf_r+0x316>
 8007584:	7813      	ldrb	r3, [r2, #0]
 8007586:	2b6c      	cmp	r3, #108	; 0x6c
 8007588:	bf0b      	itete	eq
 800758a:	9b08      	ldreq	r3, [sp, #32]
 800758c:	9c08      	ldrne	r4, [sp, #32]
 800758e:	f043 0320 	orreq.w	r3, r3, #32
 8007592:	f044 0410 	orrne.w	r4, r4, #16
 8007596:	bf0a      	itet	eq
 8007598:	9308      	streq	r3, [sp, #32]
 800759a:	9408      	strne	r4, [sp, #32]
 800759c:	f812 3f01 	ldrbeq.w	r3, [r2, #1]!
 80075a0:	e4dd      	b.n	8006f5e <_svfprintf_r+0xda>
 80075a2:	9209      	str	r2, [sp, #36]	; 0x24
 80075a4:	9316      	str	r3, [sp, #88]	; 0x58
 80075a6:	2b00      	cmp	r3, #0
 80075a8:	f43f ad4c 	beq.w	8007044 <_svfprintf_r+0x1c0>
 80075ac:	2200      	movs	r2, #0
 80075ae:	2101      	movs	r1, #1
 80075b0:	f88d 30bc 	strb.w	r3, [sp, #188]	; 0xbc
 80075b4:	ac2f      	add	r4, sp, #188	; 0xbc
 80075b6:	2300      	movs	r3, #0
 80075b8:	910a      	str	r1, [sp, #40]	; 0x28
 80075ba:	9110      	str	r1, [sp, #64]	; 0x40
 80075bc:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
 80075c0:	9214      	str	r2, [sp, #80]	; 0x50
 80075c2:	9218      	str	r2, [sp, #96]	; 0x60
 80075c4:	9413      	str	r4, [sp, #76]	; 0x4c
 80075c6:	e5ec      	b.n	80071a2 <_svfprintf_r+0x31e>
 80075c8:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
 80075cc:	2b00      	cmp	r3, #0
 80075ce:	f040 839b 	bne.w	8007d08 <_svfprintf_r+0xe84>
 80075d2:	f88d 510f 	strb.w	r5, [sp, #271]	; 0x10f
 80075d6:	7813      	ldrb	r3, [r2, #0]
 80075d8:	e4c1      	b.n	8006f5e <_svfprintf_r+0xda>
 80075da:	9808      	ldr	r0, [sp, #32]
 80075dc:	f040 0001 	orr.w	r0, r0, #1
 80075e0:	9008      	str	r0, [sp, #32]
 80075e2:	7813      	ldrb	r3, [r2, #0]
 80075e4:	e4bb      	b.n	8006f5e <_svfprintf_r+0xda>
 80075e6:	9316      	str	r3, [sp, #88]	; 0x58
 80075e8:	9b08      	ldr	r3, [sp, #32]
 80075ea:	9209      	str	r2, [sp, #36]	; 0x24
 80075ec:	f013 0f20 	tst.w	r3, #32
 80075f0:	f47f ad7f 	bne.w	80070f2 <_svfprintf_r+0x26e>
 80075f4:	9908      	ldr	r1, [sp, #32]
 80075f6:	f011 0f10 	tst.w	r1, #16
 80075fa:	f000 83a3 	beq.w	8007d44 <_svfprintf_r+0xec0>
 80075fe:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8007600:	6814      	ldr	r4, [r2, #0]
 8007602:	3204      	adds	r2, #4
 8007604:	9212      	str	r2, [sp, #72]	; 0x48
 8007606:	17e5      	asrs	r5, r4, #31
 8007608:	e57c      	b.n	8007104 <_svfprintf_r+0x280>
 800760a:	9808      	ldr	r0, [sp, #32]
 800760c:	f040 0040 	orr.w	r0, r0, #64	; 0x40
 8007610:	9008      	str	r0, [sp, #32]
 8007612:	7813      	ldrb	r3, [r2, #0]
 8007614:	e4a3      	b.n	8006f5e <_svfprintf_r+0xda>
 8007616:	9316      	str	r3, [sp, #88]	; 0x58
 8007618:	2101      	movs	r1, #1
 800761a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800761c:	2000      	movs	r0, #0
 800761e:	9209      	str	r2, [sp, #36]	; 0x24
 8007620:	2200      	movs	r2, #0
 8007622:	1d1c      	adds	r4, r3, #4
 8007624:	910a      	str	r1, [sp, #40]	; 0x28
 8007626:	681b      	ldr	r3, [r3, #0]
 8007628:	9412      	str	r4, [sp, #72]	; 0x48
 800762a:	9110      	str	r1, [sp, #64]	; 0x40
 800762c:	a92f      	add	r1, sp, #188	; 0xbc
 800762e:	f88d 010f 	strb.w	r0, [sp, #271]	; 0x10f
 8007632:	9214      	str	r2, [sp, #80]	; 0x50
 8007634:	9218      	str	r2, [sp, #96]	; 0x60
 8007636:	9113      	str	r1, [sp, #76]	; 0x4c
 8007638:	f88d 30bc 	strb.w	r3, [sp, #188]	; 0xbc
 800763c:	e5b1      	b.n	80071a2 <_svfprintf_r+0x31e>
 800763e:	9209      	str	r2, [sp, #36]	; 0x24
 8007640:	9a08      	ldr	r2, [sp, #32]
 8007642:	9316      	str	r3, [sp, #88]	; 0x58
 8007644:	f012 0320 	ands.w	r3, r2, #32
 8007648:	f47f af21 	bne.w	800748e <_svfprintf_r+0x60a>
 800764c:	9908      	ldr	r1, [sp, #32]
 800764e:	f011 0210 	ands.w	r2, r1, #16
 8007652:	f000 8391 	beq.w	8007d78 <_svfprintf_r+0xef4>
 8007656:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8007658:	6822      	ldr	r2, [r4, #0]
 800765a:	3404      	adds	r4, #4
 800765c:	2500      	movs	r5, #0
 800765e:	9412      	str	r4, [sp, #72]	; 0x48
 8007660:	4614      	mov	r4, r2
 8007662:	3a00      	subs	r2, #0
 8007664:	bf18      	it	ne
 8007666:	2201      	movne	r2, #1
 8007668:	e720      	b.n	80074ac <_svfprintf_r+0x628>
 800766a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800766c:	2178      	movs	r1, #120	; 0x78
 800766e:	9c08      	ldr	r4, [sp, #32]
 8007670:	2500      	movs	r5, #0
 8007672:	9209      	str	r2, [sp, #36]	; 0x24
 8007674:	f24d 2000 	movw	r0, #53760	; 0xd200
 8007678:	681a      	ldr	r2, [r3, #0]
 800767a:	f044 0402 	orr.w	r4, r4, #2
 800767e:	3304      	adds	r3, #4
 8007680:	9408      	str	r4, [sp, #32]
 8007682:	9312      	str	r3, [sp, #72]	; 0x48
 8007684:	4614      	mov	r4, r2
 8007686:	2330      	movs	r3, #48	; 0x30
 8007688:	3a00      	subs	r2, #0
 800768a:	f88d 310c 	strb.w	r3, [sp, #268]	; 0x10c
 800768e:	bf18      	it	ne
 8007690:	2201      	movne	r2, #1
 8007692:	f6c0 0000 	movt	r0, #2048	; 0x800
 8007696:	f88d 110d 	strb.w	r1, [sp, #269]	; 0x10d
 800769a:	9017      	str	r0, [sp, #92]	; 0x5c
 800769c:	2302      	movs	r3, #2
 800769e:	9116      	str	r1, [sp, #88]	; 0x58
 80076a0:	e704      	b.n	80074ac <_svfprintf_r+0x628>
 80076a2:	9209      	str	r2, [sp, #36]	; 0x24
 80076a4:	9a08      	ldr	r2, [sp, #32]
 80076a6:	f012 0f20 	tst.w	r2, #32
 80076aa:	f000 8358 	beq.w	8007d5e <_svfprintf_r+0xeda>
 80076ae:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80076b0:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 80076b2:	9812      	ldr	r0, [sp, #72]	; 0x48
 80076b4:	6819      	ldr	r1, [r3, #0]
 80076b6:	4622      	mov	r2, r4
 80076b8:	17e3      	asrs	r3, r4, #31
 80076ba:	3004      	adds	r0, #4
 80076bc:	9012      	str	r0, [sp, #72]	; 0x48
 80076be:	e9c1 2300 	strd	r2, r3, [r1]
 80076c2:	e408      	b.n	8006ed6 <_svfprintf_r+0x52>
 80076c4:	9808      	ldr	r0, [sp, #32]
 80076c6:	9209      	str	r2, [sp, #36]	; 0x24
 80076c8:	f010 0f20 	tst.w	r0, #32
 80076cc:	9316      	str	r3, [sp, #88]	; 0x58
 80076ce:	f47f aefc 	bne.w	80074ca <_svfprintf_r+0x646>
 80076d2:	9908      	ldr	r1, [sp, #32]
 80076d4:	f011 0f10 	tst.w	r1, #16
 80076d8:	f040 8291 	bne.w	8007bfe <_svfprintf_r+0xd7a>
 80076dc:	9808      	ldr	r0, [sp, #32]
 80076de:	f010 0f40 	tst.w	r0, #64	; 0x40
 80076e2:	f000 828c 	beq.w	8007bfe <_svfprintf_r+0xd7a>
 80076e6:	9912      	ldr	r1, [sp, #72]	; 0x48
 80076e8:	2301      	movs	r3, #1
 80076ea:	2500      	movs	r5, #0
 80076ec:	880a      	ldrh	r2, [r1, #0]
 80076ee:	3104      	adds	r1, #4
 80076f0:	9112      	str	r1, [sp, #72]	; 0x48
 80076f2:	4614      	mov	r4, r2
 80076f4:	3a00      	subs	r2, #0
 80076f6:	bf18      	it	ne
 80076f8:	2201      	movne	r2, #1
 80076fa:	e6d7      	b.n	80074ac <_svfprintf_r+0x628>
 80076fc:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80076fe:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8007700:	681b      	ldr	r3, [r3, #0]
 8007702:	1d20      	adds	r0, r4, #4
 8007704:	2b00      	cmp	r3, #0
 8007706:	930d      	str	r3, [sp, #52]	; 0x34
 8007708:	f6ff ac8a 	blt.w	8007020 <_svfprintf_r+0x19c>
 800770c:	7813      	ldrb	r3, [r2, #0]
 800770e:	9012      	str	r0, [sp, #72]	; 0x48
 8007710:	e425      	b.n	8006f5e <_svfprintf_r+0xda>
 8007712:	9209      	str	r2, [sp, #36]	; 0x24
 8007714:	f24d 2000 	movw	r0, #53760	; 0xd200
 8007718:	9a08      	ldr	r2, [sp, #32]
 800771a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800771e:	9316      	str	r3, [sp, #88]	; 0x58
 8007720:	f012 0f20 	tst.w	r2, #32
 8007724:	9017      	str	r0, [sp, #92]	; 0x5c
 8007726:	f47f aee0 	bne.w	80074ea <_svfprintf_r+0x666>
 800772a:	9908      	ldr	r1, [sp, #32]
 800772c:	f011 0f10 	tst.w	r1, #16
 8007730:	f000 82fa 	beq.w	8007d28 <_svfprintf_r+0xea4>
 8007734:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8007736:	2500      	movs	r5, #0
 8007738:	6814      	ldr	r4, [r2, #0]
 800773a:	3204      	adds	r2, #4
 800773c:	9212      	str	r2, [sp, #72]	; 0x48
 800773e:	e6dd      	b.n	80074fc <_svfprintf_r+0x678>
 8007740:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007742:	aa39      	add	r2, sp, #228	; 0xe4
 8007744:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007746:	f003 fa17 	bl	800ab78 <__ssprint_r>
 800774a:	2800      	cmp	r0, #0
 800774c:	f47f ac81 	bne.w	8007052 <_svfprintf_r+0x1ce>
 8007750:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8007754:	4656      	mov	r6, sl
 8007756:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007758:	e577      	b.n	800724a <_svfprintf_r+0x3c6>
 800775a:	9a08      	ldr	r2, [sp, #32]
 800775c:	f012 0f01 	tst.w	r2, #1
 8007760:	f040 80fd 	bne.w	800795e <_svfprintf_r+0xada>
 8007764:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007766:	3501      	adds	r5, #1
 8007768:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800776a:	2301      	movs	r3, #1
 800776c:	3401      	adds	r4, #1
 800776e:	f8c9 3004 	str.w	r3, [r9, #4]
 8007772:	2c07      	cmp	r4, #7
 8007774:	f8c9 2000 	str.w	r2, [r9]
 8007778:	953b      	str	r5, [sp, #236]	; 0xec
 800777a:	943a      	str	r4, [sp, #232]	; 0xe8
 800777c:	f300 851f 	bgt.w	80081be <_svfprintf_r+0x133a>
 8007780:	f109 0b08 	add.w	fp, r9, #8
 8007784:	f10b 0908 	add.w	r9, fp, #8
 8007788:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 800778a:	3401      	adds	r4, #1
 800778c:	2c07      	cmp	r4, #7
 800778e:	441d      	add	r5, r3
 8007790:	f8cb 3004 	str.w	r3, [fp, #4]
 8007794:	ab3e      	add	r3, sp, #248	; 0xf8
 8007796:	f8cb 3000 	str.w	r3, [fp]
 800779a:	953b      	str	r5, [sp, #236]	; 0xec
 800779c:	943a      	str	r4, [sp, #232]	; 0xe8
 800779e:	f77f adcd 	ble.w	800733c <_svfprintf_r+0x4b8>
 80077a2:	9811      	ldr	r0, [sp, #68]	; 0x44
 80077a4:	aa39      	add	r2, sp, #228	; 0xe4
 80077a6:	990c      	ldr	r1, [sp, #48]	; 0x30
 80077a8:	f003 f9e6 	bl	800ab78 <__ssprint_r>
 80077ac:	2800      	cmp	r0, #0
 80077ae:	f47f ac50 	bne.w	8007052 <_svfprintf_r+0x1ce>
 80077b2:	46d1      	mov	r9, sl
 80077b4:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80077b6:	e5c1      	b.n	800733c <_svfprintf_r+0x4b8>
 80077b8:	9916      	ldr	r1, [sp, #88]	; 0x58
 80077ba:	2965      	cmp	r1, #101	; 0x65
 80077bc:	f340 80cb 	ble.w	8007956 <_svfprintf_r+0xad2>
 80077c0:	981a      	ldr	r0, [sp, #104]	; 0x68
 80077c2:	2200      	movs	r2, #0
 80077c4:	2300      	movs	r3, #0
 80077c6:	991b      	ldr	r1, [sp, #108]	; 0x6c
 80077c8:	f004 fe94 	bl	800c4f4 <__aeabi_dcmpeq>
 80077cc:	2800      	cmp	r0, #0
 80077ce:	f000 813e 	beq.w	8007a4e <_svfprintf_r+0xbca>
 80077d2:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80077d4:	f24d 231c 	movw	r3, #53788	; 0xd21c
 80077d8:	f6c0 0300 	movt	r3, #2048	; 0x800
 80077dc:	f8c9 3000 	str.w	r3, [r9]
 80077e0:	3401      	adds	r4, #1
 80077e2:	2301      	movs	r3, #1
 80077e4:	2c07      	cmp	r4, #7
 80077e6:	f8c9 3004 	str.w	r3, [r9, #4]
 80077ea:	441d      	add	r5, r3
 80077ec:	943a      	str	r4, [sp, #232]	; 0xe8
 80077ee:	953b      	str	r5, [sp, #236]	; 0xec
 80077f0:	bfd8      	it	le
 80077f2:	f109 0908 	addle.w	r9, r9, #8
 80077f6:	f300 8346 	bgt.w	8007e86 <_svfprintf_r+0x1002>
 80077fa:	9b42      	ldr	r3, [sp, #264]	; 0x108
 80077fc:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80077fe:	4293      	cmp	r3, r2
 8007800:	db04      	blt.n	800780c <_svfprintf_r+0x988>
 8007802:	9b08      	ldr	r3, [sp, #32]
 8007804:	f013 0f01 	tst.w	r3, #1
 8007808:	f43f ad98 	beq.w	800733c <_svfprintf_r+0x4b8>
 800780c:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 800780e:	981c      	ldr	r0, [sp, #112]	; 0x70
 8007810:	3401      	adds	r4, #1
 8007812:	9919      	ldr	r1, [sp, #100]	; 0x64
 8007814:	2c07      	cmp	r4, #7
 8007816:	4405      	add	r5, r0
 8007818:	f8c9 0004 	str.w	r0, [r9, #4]
 800781c:	bfd8      	it	le
 800781e:	f109 0308 	addle.w	r3, r9, #8
 8007822:	f8c9 1000 	str.w	r1, [r9]
 8007826:	953b      	str	r5, [sp, #236]	; 0xec
 8007828:	943a      	str	r4, [sp, #232]	; 0xe8
 800782a:	f300 83bc 	bgt.w	8007fa6 <_svfprintf_r+0x1122>
 800782e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8007830:	1e56      	subs	r6, r2, #1
 8007832:	2e00      	cmp	r6, #0
 8007834:	f340 831d 	ble.w	8007e72 <_svfprintf_r+0xfee>
 8007838:	2e10      	cmp	r6, #16
 800783a:	f340 85e8 	ble.w	800840e <_svfprintf_r+0x158a>
 800783e:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007840:	2710      	movs	r7, #16
 8007842:	f8df 84fc 	ldr.w	r8, [pc, #1276]	; 8007d40 <_svfprintf_r+0xebc>
 8007846:	4622      	mov	r2, r4
 8007848:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 800784c:	4644      	mov	r4, r8
 800784e:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8007852:	e003      	b.n	800785c <_svfprintf_r+0x9d8>
 8007854:	3e10      	subs	r6, #16
 8007856:	2e10      	cmp	r6, #16
 8007858:	f340 81c4 	ble.w	8007be4 <_svfprintf_r+0xd60>
 800785c:	3201      	adds	r2, #1
 800785e:	601c      	str	r4, [r3, #0]
 8007860:	605f      	str	r7, [r3, #4]
 8007862:	3510      	adds	r5, #16
 8007864:	3308      	adds	r3, #8
 8007866:	2a07      	cmp	r2, #7
 8007868:	923a      	str	r2, [sp, #232]	; 0xe8
 800786a:	f103 0908 	add.w	r9, r3, #8
 800786e:	953b      	str	r5, [sp, #236]	; 0xec
 8007870:	ddf0      	ble.n	8007854 <_svfprintf_r+0x9d0>
 8007872:	4640      	mov	r0, r8
 8007874:	4659      	mov	r1, fp
 8007876:	aa39      	add	r2, sp, #228	; 0xe4
 8007878:	f10a 0908 	add.w	r9, sl, #8
 800787c:	f003 f97c 	bl	800ab78 <__ssprint_r>
 8007880:	4653      	mov	r3, sl
 8007882:	2800      	cmp	r0, #0
 8007884:	f47f abe5 	bne.w	8007052 <_svfprintf_r+0x1ce>
 8007888:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800788a:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 800788c:	e7e2      	b.n	8007854 <_svfprintf_r+0x9d0>
 800788e:	2b00      	cmp	r3, #0
 8007890:	f040 80b7 	bne.w	8007a02 <_svfprintf_r+0xb7e>
 8007894:	9c08      	ldr	r4, [sp, #32]
 8007896:	f014 0f01 	tst.w	r4, #1
 800789a:	f000 812b 	beq.w	8007af4 <_svfprintf_r+0xc70>
 800789e:	2001      	movs	r0, #1
 80078a0:	2330      	movs	r3, #48	; 0x30
 80078a2:	f10d 01e3 	add.w	r1, sp, #227	; 0xe3
 80078a6:	9010      	str	r0, [sp, #64]	; 0x40
 80078a8:	f88d 30e3 	strb.w	r3, [sp, #227]	; 0xe3
 80078ac:	9113      	str	r1, [sp, #76]	; 0x4c
 80078ae:	e46a      	b.n	8007186 <_svfprintf_r+0x302>
 80078b0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80078b2:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80078b4:	1b1f      	subs	r7, r3, r4
 80078b6:	2f00      	cmp	r7, #0
 80078b8:	f77f acea 	ble.w	8007290 <_svfprintf_r+0x40c>
 80078bc:	2f10      	cmp	r7, #16
 80078be:	f340 8569 	ble.w	8008394 <_svfprintf_r+0x1510>
 80078c2:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80078c4:	4633      	mov	r3, r6
 80078c6:	f8df 8478 	ldr.w	r8, [pc, #1144]	; 8007d40 <_svfprintf_r+0xebc>
 80078ca:	f04f 0910 	mov.w	r9, #16
 80078ce:	4622      	mov	r2, r4
 80078d0:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 80078d4:	4644      	mov	r4, r8
 80078d6:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 80078da:	e002      	b.n	80078e2 <_svfprintf_r+0xa5e>
 80078dc:	3f10      	subs	r7, #16
 80078de:	2f10      	cmp	r7, #16
 80078e0:	dd1b      	ble.n	800791a <_svfprintf_r+0xa96>
 80078e2:	3201      	adds	r2, #1
 80078e4:	601c      	str	r4, [r3, #0]
 80078e6:	f8c3 9004 	str.w	r9, [r3, #4]
 80078ea:	3510      	adds	r5, #16
 80078ec:	3308      	adds	r3, #8
 80078ee:	2a07      	cmp	r2, #7
 80078f0:	923a      	str	r2, [sp, #232]	; 0xe8
 80078f2:	f103 0608 	add.w	r6, r3, #8
 80078f6:	953b      	str	r5, [sp, #236]	; 0xec
 80078f8:	ddf0      	ble.n	80078dc <_svfprintf_r+0xa58>
 80078fa:	4640      	mov	r0, r8
 80078fc:	4659      	mov	r1, fp
 80078fe:	aa39      	add	r2, sp, #228	; 0xe4
 8007900:	f10a 0608 	add.w	r6, sl, #8
 8007904:	f003 f938 	bl	800ab78 <__ssprint_r>
 8007908:	4653      	mov	r3, sl
 800790a:	2800      	cmp	r0, #0
 800790c:	f47f aba1 	bne.w	8007052 <_svfprintf_r+0x1ce>
 8007910:	3f10      	subs	r7, #16
 8007912:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007914:	2f10      	cmp	r7, #16
 8007916:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 8007918:	dce3      	bgt.n	80078e2 <_svfprintf_r+0xa5e>
 800791a:	46a0      	mov	r8, r4
 800791c:	4614      	mov	r4, r2
 800791e:	3401      	adds	r4, #1
 8007920:	f8c3 8000 	str.w	r8, [r3]
 8007924:	2c07      	cmp	r4, #7
 8007926:	605f      	str	r7, [r3, #4]
 8007928:	443d      	add	r5, r7
 800792a:	943a      	str	r4, [sp, #232]	; 0xe8
 800792c:	953b      	str	r5, [sp, #236]	; 0xec
 800792e:	f77f acaf 	ble.w	8007290 <_svfprintf_r+0x40c>
 8007932:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007934:	aa39      	add	r2, sp, #228	; 0xe4
 8007936:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007938:	f003 f91e 	bl	800ab78 <__ssprint_r>
 800793c:	2800      	cmp	r0, #0
 800793e:	f47f ab88 	bne.w	8007052 <_svfprintf_r+0x1ce>
 8007942:	9914      	ldr	r1, [sp, #80]	; 0x50
 8007944:	4656      	mov	r6, sl
 8007946:	9810      	ldr	r0, [sp, #64]	; 0x40
 8007948:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800794a:	1a0f      	subs	r7, r1, r0
 800794c:	2f00      	cmp	r7, #0
 800794e:	f73f aca5 	bgt.w	800729c <_svfprintf_r+0x418>
 8007952:	46b1      	mov	r9, r6
 8007954:	e4dd      	b.n	8007312 <_svfprintf_r+0x48e>
 8007956:	990e      	ldr	r1, [sp, #56]	; 0x38
 8007958:	2901      	cmp	r1, #1
 800795a:	f77f aefe 	ble.w	800775a <_svfprintf_r+0x8d6>
 800795e:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007960:	3501      	adds	r5, #1
 8007962:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8007964:	3401      	adds	r4, #1
 8007966:	f8c9 3000 	str.w	r3, [r9]
 800796a:	2301      	movs	r3, #1
 800796c:	2c07      	cmp	r4, #7
 800796e:	f8c9 3004 	str.w	r3, [r9, #4]
 8007972:	bfd8      	it	le
 8007974:	f109 0908 	addle.w	r9, r9, #8
 8007978:	953b      	str	r5, [sp, #236]	; 0xec
 800797a:	943a      	str	r4, [sp, #232]	; 0xe8
 800797c:	bfd8      	it	le
 800797e:	f109 0608 	addle.w	r6, r9, #8
 8007982:	f300 8141 	bgt.w	8007c08 <_svfprintf_r+0xd84>
 8007986:	3401      	adds	r4, #1
 8007988:	991c      	ldr	r1, [sp, #112]	; 0x70
 800798a:	9819      	ldr	r0, [sp, #100]	; 0x64
 800798c:	2c07      	cmp	r4, #7
 800798e:	440d      	add	r5, r1
 8007990:	bfd8      	it	le
 8007992:	f106 0b08 	addle.w	fp, r6, #8
 8007996:	f8c9 1004 	str.w	r1, [r9, #4]
 800799a:	f8c9 0000 	str.w	r0, [r9]
 800799e:	943a      	str	r4, [sp, #232]	; 0xe8
 80079a0:	953b      	str	r5, [sp, #236]	; 0xec
 80079a2:	f300 813f 	bgt.w	8007c24 <_svfprintf_r+0xda0>
 80079a6:	981a      	ldr	r0, [sp, #104]	; 0x68
 80079a8:	2200      	movs	r2, #0
 80079aa:	2300      	movs	r3, #0
 80079ac:	991b      	ldr	r1, [sp, #108]	; 0x6c
 80079ae:	f004 fda1 	bl	800c4f4 <__aeabi_dcmpeq>
 80079b2:	2800      	cmp	r0, #0
 80079b4:	f040 80ce 	bne.w	8007b54 <_svfprintf_r+0xcd0>
 80079b8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80079ba:	3401      	adds	r4, #1
 80079bc:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80079be:	1e5a      	subs	r2, r3, #1
 80079c0:	6072      	str	r2, [r6, #4]
 80079c2:	1c43      	adds	r3, r0, #1
 80079c4:	2c07      	cmp	r4, #7
 80079c6:	6033      	str	r3, [r6, #0]
 80079c8:	4415      	add	r5, r2
 80079ca:	943a      	str	r4, [sp, #232]	; 0xe8
 80079cc:	953b      	str	r5, [sp, #236]	; 0xec
 80079ce:	f77f aed9 	ble.w	8007784 <_svfprintf_r+0x900>
 80079d2:	9811      	ldr	r0, [sp, #68]	; 0x44
 80079d4:	aa39      	add	r2, sp, #228	; 0xe4
 80079d6:	990c      	ldr	r1, [sp, #48]	; 0x30
 80079d8:	f003 f8ce 	bl	800ab78 <__ssprint_r>
 80079dc:	2800      	cmp	r0, #0
 80079de:	f47f ab38 	bne.w	8007052 <_svfprintf_r+0x1ce>
 80079e2:	f10a 0908 	add.w	r9, sl, #8
 80079e6:	46d3      	mov	fp, sl
 80079e8:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80079ea:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80079ec:	e6cc      	b.n	8007788 <_svfprintf_r+0x904>
 80079ee:	9811      	ldr	r0, [sp, #68]	; 0x44
 80079f0:	aa39      	add	r2, sp, #228	; 0xe4
 80079f2:	990c      	ldr	r1, [sp, #48]	; 0x30
 80079f4:	f003 f8c0 	bl	800ab78 <__ssprint_r>
 80079f8:	2800      	cmp	r0, #0
 80079fa:	f43f acf5 	beq.w	80073e8 <_svfprintf_r+0x564>
 80079fe:	f7ff bb28 	b.w	8007052 <_svfprintf_r+0x1ce>
 8007a02:	9210      	str	r2, [sp, #64]	; 0x40
 8007a04:	aa39      	add	r2, sp, #228	; 0xe4
 8007a06:	9213      	str	r2, [sp, #76]	; 0x4c
 8007a08:	f7ff bbbd 	b.w	8007186 <_svfprintf_r+0x302>
 8007a0c:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007a0e:	aa39      	add	r2, sp, #228	; 0xe4
 8007a10:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007a12:	f003 f8b1 	bl	800ab78 <__ssprint_r>
 8007a16:	2800      	cmp	r0, #0
 8007a18:	f47f ab1b 	bne.w	8007052 <_svfprintf_r+0x1ce>
 8007a1c:	46d1      	mov	r9, sl
 8007a1e:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007a20:	e477      	b.n	8007312 <_svfprintf_r+0x48e>
 8007a22:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007a24:	aa39      	add	r2, sp, #228	; 0xe4
 8007a26:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007a28:	f003 f8a6 	bl	800ab78 <__ssprint_r>
 8007a2c:	2800      	cmp	r0, #0
 8007a2e:	f47f ab10 	bne.w	8007052 <_svfprintf_r+0x1ce>
 8007a32:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007a34:	4656      	mov	r6, sl
 8007a36:	e427      	b.n	8007288 <_svfprintf_r+0x404>
 8007a38:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007a3a:	aa39      	add	r2, sp, #228	; 0xe4
 8007a3c:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007a3e:	f003 f89b 	bl	800ab78 <__ssprint_r>
 8007a42:	2800      	cmp	r0, #0
 8007a44:	f47f ab05 	bne.w	8007052 <_svfprintf_r+0x1ce>
 8007a48:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007a4a:	4656      	mov	r6, sl
 8007a4c:	e40c      	b.n	8007268 <_svfprintf_r+0x3e4>
 8007a4e:	9e42      	ldr	r6, [sp, #264]	; 0x108
 8007a50:	2e00      	cmp	r6, #0
 8007a52:	f340 8223 	ble.w	8007e9c <_svfprintf_r+0x1018>
 8007a56:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 8007a58:	9c18      	ldr	r4, [sp, #96]	; 0x60
 8007a5a:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8007a5c:	42a6      	cmp	r6, r4
 8007a5e:	bfa8      	it	ge
 8007a60:	4626      	movge	r6, r4
 8007a62:	990e      	ldr	r1, [sp, #56]	; 0x38
 8007a64:	2e00      	cmp	r6, #0
 8007a66:	eb00 0b01 	add.w	fp, r0, r1
 8007a6a:	dd0e      	ble.n	8007a8a <_svfprintf_r+0xc06>
 8007a6c:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007a6e:	19ad      	adds	r5, r5, r6
 8007a70:	f8c9 0000 	str.w	r0, [r9]
 8007a74:	3401      	adds	r4, #1
 8007a76:	f8c9 6004 	str.w	r6, [r9, #4]
 8007a7a:	2c07      	cmp	r4, #7
 8007a7c:	953b      	str	r5, [sp, #236]	; 0xec
 8007a7e:	943a      	str	r4, [sp, #232]	; 0xe8
 8007a80:	bfd8      	it	le
 8007a82:	f109 0908 	addle.w	r9, r9, #8
 8007a86:	f300 8411 	bgt.w	80082ac <_svfprintf_r+0x1428>
 8007a8a:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8007a8c:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
 8007a90:	1b96      	subs	r6, r2, r6
 8007a92:	2e00      	cmp	r6, #0
 8007a94:	f340 83e9 	ble.w	800826a <_svfprintf_r+0x13e6>
 8007a98:	2e10      	cmp	r6, #16
 8007a9a:	f340 84e1 	ble.w	8008460 <_svfprintf_r+0x15dc>
 8007a9e:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007aa0:	4629      	mov	r1, r5
 8007aa2:	f8df 829c 	ldr.w	r8, [pc, #668]	; 8007d40 <_svfprintf_r+0xebc>
 8007aa6:	2710      	movs	r7, #16
 8007aa8:	4622      	mov	r2, r4
 8007aaa:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8007aac:	4644      	mov	r4, r8
 8007aae:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8007ab2:	e003      	b.n	8007abc <_svfprintf_r+0xc38>
 8007ab4:	3e10      	subs	r6, #16
 8007ab6:	2e10      	cmp	r6, #16
 8007ab8:	f340 8170 	ble.w	8007d9c <_svfprintf_r+0xf18>
 8007abc:	3201      	adds	r2, #1
 8007abe:	3110      	adds	r1, #16
 8007ac0:	2a07      	cmp	r2, #7
 8007ac2:	f8c9 4000 	str.w	r4, [r9]
 8007ac6:	f8c9 7004 	str.w	r7, [r9, #4]
 8007aca:	f109 0908 	add.w	r9, r9, #8
 8007ace:	923a      	str	r2, [sp, #232]	; 0xe8
 8007ad0:	f109 0308 	add.w	r3, r9, #8
 8007ad4:	913b      	str	r1, [sp, #236]	; 0xec
 8007ad6:	dded      	ble.n	8007ab4 <_svfprintf_r+0xc30>
 8007ad8:	4640      	mov	r0, r8
 8007ada:	4629      	mov	r1, r5
 8007adc:	aa39      	add	r2, sp, #228	; 0xe4
 8007ade:	46d1      	mov	r9, sl
 8007ae0:	f003 f84a 	bl	800ab78 <__ssprint_r>
 8007ae4:	f10a 0308 	add.w	r3, sl, #8
 8007ae8:	2800      	cmp	r0, #0
 8007aea:	f47f aab2 	bne.w	8007052 <_svfprintf_r+0x1ce>
 8007aee:	993b      	ldr	r1, [sp, #236]	; 0xec
 8007af0:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 8007af2:	e7df      	b.n	8007ab4 <_svfprintf_r+0xc30>
 8007af4:	9310      	str	r3, [sp, #64]	; 0x40
 8007af6:	ab39      	add	r3, sp, #228	; 0xe4
 8007af8:	9313      	str	r3, [sp, #76]	; 0x4c
 8007afa:	f7ff bb44 	b.w	8007186 <_svfprintf_r+0x302>
 8007afe:	f10d 0bbc 	add.w	fp, sp, #188	; 0xbc
 8007b02:	9917      	ldr	r1, [sp, #92]	; 0x5c
 8007b04:	f10b 0027 	add.w	r0, fp, #39	; 0x27
 8007b08:	f004 020f 	and.w	r2, r4, #15
 8007b0c:	0923      	lsrs	r3, r4, #4
 8007b0e:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 8007b12:	ea4f 1c15 	mov.w	ip, r5, lsr #4
 8007b16:	5c8a      	ldrb	r2, [r1, r2]
 8007b18:	461c      	mov	r4, r3
 8007b1a:	4603      	mov	r3, r0
 8007b1c:	4665      	mov	r5, ip
 8007b1e:	3801      	subs	r0, #1
 8007b20:	701a      	strb	r2, [r3, #0]
 8007b22:	ea54 0205 	orrs.w	r2, r4, r5
 8007b26:	d1ef      	bne.n	8007b08 <_svfprintf_r+0xc84>
 8007b28:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8007b2c:	9313      	str	r3, [sp, #76]	; 0x4c
 8007b2e:	ebc3 030b 	rsb	r3, r3, fp
 8007b32:	9310      	str	r3, [sp, #64]	; 0x40
 8007b34:	f7ff bb27 	b.w	8007186 <_svfprintf_r+0x302>
 8007b38:	2c0a      	cmp	r4, #10
 8007b3a:	f175 0100 	sbcs.w	r1, r5, #0
 8007b3e:	d27f      	bcs.n	8007c40 <_svfprintf_r+0xdbc>
 8007b40:	3430      	adds	r4, #48	; 0x30
 8007b42:	2201      	movs	r2, #1
 8007b44:	f10d 03e3 	add.w	r3, sp, #227	; 0xe3
 8007b48:	9210      	str	r2, [sp, #64]	; 0x40
 8007b4a:	f88d 40e3 	strb.w	r4, [sp, #227]	; 0xe3
 8007b4e:	9313      	str	r3, [sp, #76]	; 0x4c
 8007b50:	f7ff bb19 	b.w	8007186 <_svfprintf_r+0x302>
 8007b54:	990e      	ldr	r1, [sp, #56]	; 0x38
 8007b56:	1e4f      	subs	r7, r1, #1
 8007b58:	2f00      	cmp	r7, #0
 8007b5a:	bfdc      	itt	le
 8007b5c:	f106 0908 	addle.w	r9, r6, #8
 8007b60:	46b3      	movle	fp, r6
 8007b62:	f77f ae11 	ble.w	8007788 <_svfprintf_r+0x904>
 8007b66:	2f10      	cmp	r7, #16
 8007b68:	bfd8      	it	le
 8007b6a:	f8df 81d4 	ldrle.w	r8, [pc, #468]	; 8007d40 <_svfprintf_r+0xebc>
 8007b6e:	dd2c      	ble.n	8007bca <_svfprintf_r+0xd46>
 8007b70:	f8df 81cc 	ldr.w	r8, [pc, #460]	; 8007d40 <_svfprintf_r+0xebc>
 8007b74:	4623      	mov	r3, r4
 8007b76:	462a      	mov	r2, r5
 8007b78:	f04f 0910 	mov.w	r9, #16
 8007b7c:	4644      	mov	r4, r8
 8007b7e:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8007b80:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8007b84:	e002      	b.n	8007b8c <_svfprintf_r+0xd08>
 8007b86:	3f10      	subs	r7, #16
 8007b88:	2f10      	cmp	r7, #16
 8007b8a:	dd1b      	ble.n	8007bc4 <_svfprintf_r+0xd40>
 8007b8c:	3301      	adds	r3, #1
 8007b8e:	6034      	str	r4, [r6, #0]
 8007b90:	f8c6 9004 	str.w	r9, [r6, #4]
 8007b94:	3210      	adds	r2, #16
 8007b96:	3608      	adds	r6, #8
 8007b98:	2b07      	cmp	r3, #7
 8007b9a:	933a      	str	r3, [sp, #232]	; 0xe8
 8007b9c:	f106 0b08 	add.w	fp, r6, #8
 8007ba0:	923b      	str	r2, [sp, #236]	; 0xec
 8007ba2:	ddf0      	ble.n	8007b86 <_svfprintf_r+0xd02>
 8007ba4:	4640      	mov	r0, r8
 8007ba6:	4629      	mov	r1, r5
 8007ba8:	aa39      	add	r2, sp, #228	; 0xe4
 8007baa:	f10a 0b08 	add.w	fp, sl, #8
 8007bae:	f002 ffe3 	bl	800ab78 <__ssprint_r>
 8007bb2:	4656      	mov	r6, sl
 8007bb4:	2800      	cmp	r0, #0
 8007bb6:	f47f aa4c 	bne.w	8007052 <_svfprintf_r+0x1ce>
 8007bba:	3f10      	subs	r7, #16
 8007bbc:	9a3b      	ldr	r2, [sp, #236]	; 0xec
 8007bbe:	2f10      	cmp	r7, #16
 8007bc0:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 8007bc2:	dce3      	bgt.n	8007b8c <_svfprintf_r+0xd08>
 8007bc4:	46a0      	mov	r8, r4
 8007bc6:	4615      	mov	r5, r2
 8007bc8:	461c      	mov	r4, r3
 8007bca:	3401      	adds	r4, #1
 8007bcc:	f8c6 8000 	str.w	r8, [r6]
 8007bd0:	2c07      	cmp	r4, #7
 8007bd2:	6077      	str	r7, [r6, #4]
 8007bd4:	443d      	add	r5, r7
 8007bd6:	943a      	str	r4, [sp, #232]	; 0xe8
 8007bd8:	953b      	str	r5, [sp, #236]	; 0xec
 8007bda:	f77f add3 	ble.w	8007784 <_svfprintf_r+0x900>
 8007bde:	e6f8      	b.n	80079d2 <_svfprintf_r+0xb4e>
 8007be0:	2302      	movs	r3, #2
 8007be2:	e463      	b.n	80074ac <_svfprintf_r+0x628>
 8007be4:	46a0      	mov	r8, r4
 8007be6:	4614      	mov	r4, r2
 8007be8:	3401      	adds	r4, #1
 8007bea:	f8c3 8000 	str.w	r8, [r3]
 8007bee:	2c07      	cmp	r4, #7
 8007bf0:	605e      	str	r6, [r3, #4]
 8007bf2:	4435      	add	r5, r6
 8007bf4:	943a      	str	r4, [sp, #232]	; 0xe8
 8007bf6:	953b      	str	r5, [sp, #236]	; 0xec
 8007bf8:	f77f aba0 	ble.w	800733c <_svfprintf_r+0x4b8>
 8007bfc:	e5d1      	b.n	80077a2 <_svfprintf_r+0x91e>
 8007bfe:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8007c00:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8007c02:	681a      	ldr	r2, [r3, #0]
 8007c04:	2301      	movs	r3, #1
 8007c06:	e528      	b.n	800765a <_svfprintf_r+0x7d6>
 8007c08:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007c0a:	aa39      	add	r2, sp, #228	; 0xe4
 8007c0c:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007c0e:	f002 ffb3 	bl	800ab78 <__ssprint_r>
 8007c12:	2800      	cmp	r0, #0
 8007c14:	f47f aa1d 	bne.w	8007052 <_svfprintf_r+0x1ce>
 8007c18:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007c1a:	f10a 0608 	add.w	r6, sl, #8
 8007c1e:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007c20:	46d1      	mov	r9, sl
 8007c22:	e6b0      	b.n	8007986 <_svfprintf_r+0xb02>
 8007c24:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007c26:	aa39      	add	r2, sp, #228	; 0xe4
 8007c28:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007c2a:	f002 ffa5 	bl	800ab78 <__ssprint_r>
 8007c2e:	2800      	cmp	r0, #0
 8007c30:	f47f aa0f 	bne.w	8007052 <_svfprintf_r+0x1ce>
 8007c34:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007c36:	f10a 0b08 	add.w	fp, sl, #8
 8007c3a:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007c3c:	4656      	mov	r6, sl
 8007c3e:	e6b2      	b.n	80079a6 <_svfprintf_r+0xb22>
 8007c40:	f10d 0bbc 	add.w	fp, sp, #188	; 0xbc
 8007c44:	46b1      	mov	r9, r6
 8007c46:	f10b 0827 	add.w	r8, fp, #39	; 0x27
 8007c4a:	4620      	mov	r0, r4
 8007c4c:	4629      	mov	r1, r5
 8007c4e:	220a      	movs	r2, #10
 8007c50:	2300      	movs	r3, #0
 8007c52:	f004 fca9 	bl	800c5a8 <__aeabi_uldivmod>
 8007c56:	4646      	mov	r6, r8
 8007c58:	4620      	mov	r0, r4
 8007c5a:	4629      	mov	r1, r5
 8007c5c:	2300      	movs	r3, #0
 8007c5e:	f108 38ff 	add.w	r8, r8, #4294967295
 8007c62:	f102 0430 	add.w	r4, r2, #48	; 0x30
 8007c66:	220a      	movs	r2, #10
 8007c68:	7034      	strb	r4, [r6, #0]
 8007c6a:	f004 fc9d 	bl	800c5a8 <__aeabi_uldivmod>
 8007c6e:	4604      	mov	r4, r0
 8007c70:	460d      	mov	r5, r1
 8007c72:	ea54 0005 	orrs.w	r0, r4, r5
 8007c76:	d1e8      	bne.n	8007c4a <_svfprintf_r+0xdc6>
 8007c78:	9613      	str	r6, [sp, #76]	; 0x4c
 8007c7a:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8007c7e:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8007c80:	464e      	mov	r6, r9
 8007c82:	ebc1 010b 	rsb	r1, r1, fp
 8007c86:	9110      	str	r1, [sp, #64]	; 0x40
 8007c88:	f7ff ba7d 	b.w	8007186 <_svfprintf_r+0x302>
 8007c8c:	2a30      	cmp	r2, #48	; 0x30
 8007c8e:	f000 8333 	beq.w	80082f8 <_svfprintf_r+0x1474>
 8007c92:	9313      	str	r3, [sp, #76]	; 0x4c
 8007c94:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8007c98:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8007c9a:	ebc3 040b 	rsb	r4, r3, fp
 8007c9e:	2330      	movs	r3, #48	; 0x30
 8007ca0:	9410      	str	r4, [sp, #64]	; 0x40
 8007ca2:	7003      	strb	r3, [r0, #0]
 8007ca4:	f7ff ba6f 	b.w	8007186 <_svfprintf_r+0x302>
 8007ca8:	4264      	negs	r4, r4
 8007caa:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 8007cae:	232d      	movs	r3, #45	; 0x2d
 8007cb0:	ea54 0005 	orrs.w	r0, r4, r5
 8007cb4:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
 8007cb8:	bf0c      	ite	eq
 8007cba:	2200      	moveq	r2, #0
 8007cbc:	2201      	movne	r2, #1
 8007cbe:	2301      	movs	r3, #1
 8007cc0:	f7ff ba2c 	b.w	800711c <_svfprintf_r+0x298>
 8007cc4:	981a      	ldr	r0, [sp, #104]	; 0x68
 8007cc6:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8007cc8:	f002 fe94 	bl	800a9f4 <__fpclassifyd>
 8007ccc:	2800      	cmp	r0, #0
 8007cce:	f040 8175 	bne.w	8007fbc <_svfprintf_r+0x1138>
 8007cd2:	9014      	str	r0, [sp, #80]	; 0x50
 8007cd4:	f24d 13e8 	movw	r3, #53736	; 0xd1e8
 8007cd8:	f24d 12e4 	movw	r2, #53732	; 0xd1e4
 8007cdc:	9816      	ldr	r0, [sp, #88]	; 0x58
 8007cde:	f6c0 0200 	movt	r2, #2048	; 0x800
 8007ce2:	f6c0 0300 	movt	r3, #2048	; 0x800
 8007ce6:	2847      	cmp	r0, #71	; 0x47
 8007ce8:	bfd8      	it	le
 8007cea:	4613      	movle	r3, r2
 8007cec:	9313      	str	r3, [sp, #76]	; 0x4c
 8007cee:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8007cf0:	2403      	movs	r4, #3
 8007cf2:	9908      	ldr	r1, [sp, #32]
 8007cf4:	940a      	str	r4, [sp, #40]	; 0x28
 8007cf6:	f021 0180 	bic.w	r1, r1, #128	; 0x80
 8007cfa:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8007cfe:	9108      	str	r1, [sp, #32]
 8007d00:	9410      	str	r4, [sp, #64]	; 0x40
 8007d02:	9318      	str	r3, [sp, #96]	; 0x60
 8007d04:	f7ff ba49 	b.w	800719a <_svfprintf_r+0x316>
 8007d08:	7813      	ldrb	r3, [r2, #0]
 8007d0a:	f7ff b928 	b.w	8006f5e <_svfprintf_r+0xda>
 8007d0e:	9912      	ldr	r1, [sp, #72]	; 0x48
 8007d10:	1dcb      	adds	r3, r1, #7
 8007d12:	f023 0307 	bic.w	r3, r3, #7
 8007d16:	f103 0208 	add.w	r2, r3, #8
 8007d1a:	9212      	str	r2, [sp, #72]	; 0x48
 8007d1c:	681c      	ldr	r4, [r3, #0]
 8007d1e:	941a      	str	r4, [sp, #104]	; 0x68
 8007d20:	685b      	ldr	r3, [r3, #4]
 8007d22:	931b      	str	r3, [sp, #108]	; 0x6c
 8007d24:	f7ff bb77 	b.w	8007416 <_svfprintf_r+0x592>
 8007d28:	9b08      	ldr	r3, [sp, #32]
 8007d2a:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007d2e:	f000 8126 	beq.w	8007f7e <_svfprintf_r+0x10fa>
 8007d32:	9812      	ldr	r0, [sp, #72]	; 0x48
 8007d34:	2500      	movs	r5, #0
 8007d36:	8804      	ldrh	r4, [r0, #0]
 8007d38:	3004      	adds	r0, #4
 8007d3a:	9012      	str	r0, [sp, #72]	; 0x48
 8007d3c:	f7ff bbde 	b.w	80074fc <_svfprintf_r+0x678>
 8007d40:	0800cf58 	.word	0x0800cf58
 8007d44:	9b08      	ldr	r3, [sp, #32]
 8007d46:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007d4a:	f000 8111 	beq.w	8007f70 <_svfprintf_r+0x10ec>
 8007d4e:	9812      	ldr	r0, [sp, #72]	; 0x48
 8007d50:	f9b0 4000 	ldrsh.w	r4, [r0]
 8007d54:	3004      	adds	r0, #4
 8007d56:	9012      	str	r0, [sp, #72]	; 0x48
 8007d58:	17e5      	asrs	r5, r4, #31
 8007d5a:	f7ff b9d3 	b.w	8007104 <_svfprintf_r+0x280>
 8007d5e:	9908      	ldr	r1, [sp, #32]
 8007d60:	f011 0f10 	tst.w	r1, #16
 8007d64:	f000 8112 	beq.w	8007f8c <_svfprintf_r+0x1108>
 8007d68:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8007d6a:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 8007d6c:	6813      	ldr	r3, [r2, #0]
 8007d6e:	3204      	adds	r2, #4
 8007d70:	9212      	str	r2, [sp, #72]	; 0x48
 8007d72:	601c      	str	r4, [r3, #0]
 8007d74:	f7ff b8af 	b.w	8006ed6 <_svfprintf_r+0x52>
 8007d78:	9808      	ldr	r0, [sp, #32]
 8007d7a:	f010 0340 	ands.w	r3, r0, #64	; 0x40
 8007d7e:	f000 81fc 	beq.w	800817a <_svfprintf_r+0x12f6>
 8007d82:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8007d84:	2500      	movs	r5, #0
 8007d86:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8007d88:	8819      	ldrh	r1, [r3, #0]
 8007d8a:	3404      	adds	r4, #4
 8007d8c:	4613      	mov	r3, r2
 8007d8e:	9412      	str	r4, [sp, #72]	; 0x48
 8007d90:	1e0a      	subs	r2, r1, #0
 8007d92:	460c      	mov	r4, r1
 8007d94:	bf18      	it	ne
 8007d96:	2201      	movne	r2, #1
 8007d98:	f7ff bb88 	b.w	80074ac <_svfprintf_r+0x628>
 8007d9c:	46a0      	mov	r8, r4
 8007d9e:	460d      	mov	r5, r1
 8007da0:	4614      	mov	r4, r2
 8007da2:	3401      	adds	r4, #1
 8007da4:	f8c9 8000 	str.w	r8, [r9]
 8007da8:	2c07      	cmp	r4, #7
 8007daa:	f8c9 6004 	str.w	r6, [r9, #4]
 8007dae:	4435      	add	r5, r6
 8007db0:	943a      	str	r4, [sp, #232]	; 0xe8
 8007db2:	953b      	str	r5, [sp, #236]	; 0xec
 8007db4:	f300 82af 	bgt.w	8008316 <_svfprintf_r+0x1492>
 8007db8:	9a42      	ldr	r2, [sp, #264]	; 0x108
 8007dba:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 8007dbc:	42a2      	cmp	r2, r4
 8007dbe:	db4a      	blt.n	8007e56 <_svfprintf_r+0xfd2>
 8007dc0:	9808      	ldr	r0, [sp, #32]
 8007dc2:	f010 0f01 	tst.w	r0, #1
 8007dc6:	d146      	bne.n	8007e56 <_svfprintf_r+0xfd2>
 8007dc8:	9c13      	ldr	r4, [sp, #76]	; 0x4c
 8007dca:	9818      	ldr	r0, [sp, #96]	; 0x60
 8007dcc:	1821      	adds	r1, r4, r0
 8007dce:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 8007dd0:	ebc1 070b 	rsb	r7, r1, fp
 8007dd4:	1aa2      	subs	r2, r4, r2
 8007dd6:	42ba      	cmp	r2, r7
 8007dd8:	bfb8      	it	lt
 8007dda:	4617      	movlt	r7, r2
 8007ddc:	2f00      	cmp	r7, #0
 8007dde:	dd0a      	ble.n	8007df6 <_svfprintf_r+0xf72>
 8007de0:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007de2:	19ed      	adds	r5, r5, r7
 8007de4:	6019      	str	r1, [r3, #0]
 8007de6:	3401      	adds	r4, #1
 8007de8:	605f      	str	r7, [r3, #4]
 8007dea:	2c07      	cmp	r4, #7
 8007dec:	953b      	str	r5, [sp, #236]	; 0xec
 8007dee:	943a      	str	r4, [sp, #232]	; 0xe8
 8007df0:	f300 8274 	bgt.w	80082dc <_svfprintf_r+0x1458>
 8007df4:	3308      	adds	r3, #8
 8007df6:	ea27 76e7 	bic.w	r6, r7, r7, asr #31
 8007dfa:	1b96      	subs	r6, r2, r6
 8007dfc:	2e00      	cmp	r6, #0
 8007dfe:	dd38      	ble.n	8007e72 <_svfprintf_r+0xfee>
 8007e00:	2e10      	cmp	r6, #16
 8007e02:	f340 8304 	ble.w	800840e <_svfprintf_r+0x158a>
 8007e06:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007e08:	2710      	movs	r7, #16
 8007e0a:	f8df 86b4 	ldr.w	r8, [pc, #1716]	; 80084c0 <_svfprintf_r+0x163c>
 8007e0e:	4622      	mov	r2, r4
 8007e10:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 8007e14:	4644      	mov	r4, r8
 8007e16:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8007e1a:	e003      	b.n	8007e24 <_svfprintf_r+0xfa0>
 8007e1c:	3e10      	subs	r6, #16
 8007e1e:	2e10      	cmp	r6, #16
 8007e20:	f77f aee0 	ble.w	8007be4 <_svfprintf_r+0xd60>
 8007e24:	3201      	adds	r2, #1
 8007e26:	601c      	str	r4, [r3, #0]
 8007e28:	605f      	str	r7, [r3, #4]
 8007e2a:	3510      	adds	r5, #16
 8007e2c:	3308      	adds	r3, #8
 8007e2e:	2a07      	cmp	r2, #7
 8007e30:	923a      	str	r2, [sp, #232]	; 0xe8
 8007e32:	f103 0908 	add.w	r9, r3, #8
 8007e36:	953b      	str	r5, [sp, #236]	; 0xec
 8007e38:	ddf0      	ble.n	8007e1c <_svfprintf_r+0xf98>
 8007e3a:	4640      	mov	r0, r8
 8007e3c:	4659      	mov	r1, fp
 8007e3e:	aa39      	add	r2, sp, #228	; 0xe4
 8007e40:	f10a 0908 	add.w	r9, sl, #8
 8007e44:	f002 fe98 	bl	800ab78 <__ssprint_r>
 8007e48:	4653      	mov	r3, sl
 8007e4a:	2800      	cmp	r0, #0
 8007e4c:	f47f a901 	bne.w	8007052 <_svfprintf_r+0x1ce>
 8007e50:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007e52:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 8007e54:	e7e2      	b.n	8007e1c <_svfprintf_r+0xf98>
 8007e56:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007e58:	991c      	ldr	r1, [sp, #112]	; 0x70
 8007e5a:	3401      	adds	r4, #1
 8007e5c:	9819      	ldr	r0, [sp, #100]	; 0x64
 8007e5e:	2c07      	cmp	r4, #7
 8007e60:	440d      	add	r5, r1
 8007e62:	6059      	str	r1, [r3, #4]
 8007e64:	6018      	str	r0, [r3, #0]
 8007e66:	953b      	str	r5, [sp, #236]	; 0xec
 8007e68:	943a      	str	r4, [sp, #232]	; 0xe8
 8007e6a:	f300 822b 	bgt.w	80082c4 <_svfprintf_r+0x1440>
 8007e6e:	3308      	adds	r3, #8
 8007e70:	e7aa      	b.n	8007dc8 <_svfprintf_r+0xf44>
 8007e72:	4699      	mov	r9, r3
 8007e74:	f7ff ba62 	b.w	800733c <_svfprintf_r+0x4b8>
 8007e78:	f106 0908 	add.w	r9, r6, #8
 8007e7c:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007e7e:	f8df 8640 	ldr.w	r8, [pc, #1600]	; 80084c0 <_svfprintf_r+0x163c>
 8007e82:	f7ff ba3c 	b.w	80072fe <_svfprintf_r+0x47a>
 8007e86:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007e88:	aa39      	add	r2, sp, #228	; 0xe4
 8007e8a:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007e8c:	f002 fe74 	bl	800ab78 <__ssprint_r>
 8007e90:	2800      	cmp	r0, #0
 8007e92:	f47f a8de 	bne.w	8007052 <_svfprintf_r+0x1ce>
 8007e96:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007e98:	46d1      	mov	r9, sl
 8007e9a:	e4ae      	b.n	80077fa <_svfprintf_r+0x976>
 8007e9c:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007e9e:	f24d 231c 	movw	r3, #53788	; 0xd21c
 8007ea2:	f6c0 0300 	movt	r3, #2048	; 0x800
 8007ea6:	f8c9 3000 	str.w	r3, [r9]
 8007eaa:	3401      	adds	r4, #1
 8007eac:	2301      	movs	r3, #1
 8007eae:	2c07      	cmp	r4, #7
 8007eb0:	f8c9 3004 	str.w	r3, [r9, #4]
 8007eb4:	441d      	add	r5, r3
 8007eb6:	943a      	str	r4, [sp, #232]	; 0xe8
 8007eb8:	953b      	str	r5, [sp, #236]	; 0xec
 8007eba:	bfd8      	it	le
 8007ebc:	f109 0908 	addle.w	r9, r9, #8
 8007ec0:	f300 818c 	bgt.w	80081dc <_svfprintf_r+0x1358>
 8007ec4:	b936      	cbnz	r6, 8007ed4 <_svfprintf_r+0x1050>
 8007ec6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8007ec8:	b923      	cbnz	r3, 8007ed4 <_svfprintf_r+0x1050>
 8007eca:	9c08      	ldr	r4, [sp, #32]
 8007ecc:	f014 0f01 	tst.w	r4, #1
 8007ed0:	f43f aa34 	beq.w	800733c <_svfprintf_r+0x4b8>
 8007ed4:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007ed6:	981c      	ldr	r0, [sp, #112]	; 0x70
 8007ed8:	3401      	adds	r4, #1
 8007eda:	9919      	ldr	r1, [sp, #100]	; 0x64
 8007edc:	2c07      	cmp	r4, #7
 8007ede:	4405      	add	r5, r0
 8007ee0:	f8c9 0004 	str.w	r0, [r9, #4]
 8007ee4:	f8c9 1000 	str.w	r1, [r9]
 8007ee8:	bfd8      	it	le
 8007eea:	f109 0908 	addle.w	r9, r9, #8
 8007eee:	953b      	str	r5, [sp, #236]	; 0xec
 8007ef0:	943a      	str	r4, [sp, #232]	; 0xe8
 8007ef2:	f300 81ab 	bgt.w	800824c <_svfprintf_r+0x13c8>
 8007ef6:	4276      	negs	r6, r6
 8007ef8:	2e00      	cmp	r6, #0
 8007efa:	f340 8198 	ble.w	800822e <_svfprintf_r+0x13aa>
 8007efe:	2e10      	cmp	r6, #16
 8007f00:	bfd8      	it	le
 8007f02:	f8df 85bc 	ldrle.w	r8, [pc, #1468]	; 80084c0 <_svfprintf_r+0x163c>
 8007f06:	f340 817a 	ble.w	80081fe <_svfprintf_r+0x137a>
 8007f0a:	f8df 85b4 	ldr.w	r8, [pc, #1460]	; 80084c0 <_svfprintf_r+0x163c>
 8007f0e:	4623      	mov	r3, r4
 8007f10:	2710      	movs	r7, #16
 8007f12:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 8007f16:	4644      	mov	r4, r8
 8007f18:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8007f1c:	e003      	b.n	8007f26 <_svfprintf_r+0x10a2>
 8007f1e:	3e10      	subs	r6, #16
 8007f20:	2e10      	cmp	r6, #16
 8007f22:	f340 816a 	ble.w	80081fa <_svfprintf_r+0x1376>
 8007f26:	3301      	adds	r3, #1
 8007f28:	3510      	adds	r5, #16
 8007f2a:	2b07      	cmp	r3, #7
 8007f2c:	f8c9 4000 	str.w	r4, [r9]
 8007f30:	f8c9 7004 	str.w	r7, [r9, #4]
 8007f34:	f109 0908 	add.w	r9, r9, #8
 8007f38:	933a      	str	r3, [sp, #232]	; 0xe8
 8007f3a:	953b      	str	r5, [sp, #236]	; 0xec
 8007f3c:	ddef      	ble.n	8007f1e <_svfprintf_r+0x109a>
 8007f3e:	4640      	mov	r0, r8
 8007f40:	4659      	mov	r1, fp
 8007f42:	aa39      	add	r2, sp, #228	; 0xe4
 8007f44:	46d1      	mov	r9, sl
 8007f46:	f002 fe17 	bl	800ab78 <__ssprint_r>
 8007f4a:	2800      	cmp	r0, #0
 8007f4c:	f47f a881 	bne.w	8007052 <_svfprintf_r+0x1ce>
 8007f50:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007f52:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 8007f54:	e7e3      	b.n	8007f1e <_svfprintf_r+0x109a>
 8007f56:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007f58:	2200      	movs	r2, #0
 8007f5a:	9412      	str	r4, [sp, #72]	; 0x48
 8007f5c:	2400      	movs	r4, #0
 8007f5e:	9214      	str	r2, [sp, #80]	; 0x50
 8007f60:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8007f64:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8007f68:	930a      	str	r3, [sp, #40]	; 0x28
 8007f6a:	9418      	str	r4, [sp, #96]	; 0x60
 8007f6c:	f7ff b915 	b.w	800719a <_svfprintf_r+0x316>
 8007f70:	9912      	ldr	r1, [sp, #72]	; 0x48
 8007f72:	680c      	ldr	r4, [r1, #0]
 8007f74:	3104      	adds	r1, #4
 8007f76:	9112      	str	r1, [sp, #72]	; 0x48
 8007f78:	17e5      	asrs	r5, r4, #31
 8007f7a:	f7ff b8c3 	b.w	8007104 <_svfprintf_r+0x280>
 8007f7e:	9912      	ldr	r1, [sp, #72]	; 0x48
 8007f80:	2500      	movs	r5, #0
 8007f82:	680c      	ldr	r4, [r1, #0]
 8007f84:	3104      	adds	r1, #4
 8007f86:	9112      	str	r1, [sp, #72]	; 0x48
 8007f88:	f7ff bab8 	b.w	80074fc <_svfprintf_r+0x678>
 8007f8c:	9808      	ldr	r0, [sp, #32]
 8007f8e:	f010 0f40 	tst.w	r0, #64	; 0x40
 8007f92:	f000 810c 	beq.w	80081ae <_svfprintf_r+0x132a>
 8007f96:	9912      	ldr	r1, [sp, #72]	; 0x48
 8007f98:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8007f9a:	680b      	ldr	r3, [r1, #0]
 8007f9c:	3104      	adds	r1, #4
 8007f9e:	9112      	str	r1, [sp, #72]	; 0x48
 8007fa0:	801a      	strh	r2, [r3, #0]
 8007fa2:	f7fe bf98 	b.w	8006ed6 <_svfprintf_r+0x52>
 8007fa6:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007fa8:	aa39      	add	r2, sp, #228	; 0xe4
 8007faa:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007fac:	f002 fde4 	bl	800ab78 <__ssprint_r>
 8007fb0:	2800      	cmp	r0, #0
 8007fb2:	f47f a84e 	bne.w	8007052 <_svfprintf_r+0x1ce>
 8007fb6:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007fb8:	4653      	mov	r3, sl
 8007fba:	e438      	b.n	800782e <_svfprintf_r+0x9aa>
 8007fbc:	f1b7 3fff 	cmp.w	r7, #4294967295
 8007fc0:	f000 8151 	beq.w	8008266 <_svfprintf_r+0x13e2>
 8007fc4:	9c16      	ldr	r4, [sp, #88]	; 0x58
 8007fc6:	f1a4 0e67 	sub.w	lr, r4, #103	; 0x67
 8007fca:	f1de 0300 	rsbs	r3, lr, #0
 8007fce:	eb43 030e 	adc.w	r3, r3, lr
 8007fd2:	2c47      	cmp	r4, #71	; 0x47
 8007fd4:	bf08      	it	eq
 8007fd6:	f043 0301 	orreq.w	r3, r3, #1
 8007fda:	b113      	cbz	r3, 8007fe2 <_svfprintf_r+0x115e>
 8007fdc:	2f00      	cmp	r7, #0
 8007fde:	bf08      	it	eq
 8007fe0:	2701      	moveq	r7, #1
 8007fe2:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8007fe4:	9808      	ldr	r0, [sp, #32]
 8007fe6:	2b00      	cmp	r3, #0
 8007fe8:	f440 7080 	orr.w	r0, r0, #256	; 0x100
 8007fec:	9008      	str	r0, [sp, #32]
 8007fee:	f2c0 8201 	blt.w	80083f4 <_svfprintf_r+0x1570>
 8007ff2:	f8dd 906c 	ldr.w	r9, [sp, #108]	; 0x6c
 8007ff6:	2200      	movs	r2, #0
 8007ff8:	9214      	str	r2, [sp, #80]	; 0x50
 8007ffa:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8007ffc:	f1a3 0466 	sub.w	r4, r3, #102	; 0x66
 8008000:	f1d4 0b00 	rsbs	fp, r4, #0
 8008004:	eb4b 0b04 	adc.w	fp, fp, r4
 8008008:	2b46      	cmp	r3, #70	; 0x46
 800800a:	bf08      	it	eq
 800800c:	f04b 0b01 	orreq.w	fp, fp, #1
 8008010:	f1bb 0f00 	cmp.w	fp, #0
 8008014:	f040 81bb 	bne.w	800838e <_svfprintf_r+0x150a>
 8008018:	2b45      	cmp	r3, #69	; 0x45
 800801a:	d002      	beq.n	8008022 <_svfprintf_r+0x119e>
 800801c:	2b65      	cmp	r3, #101	; 0x65
 800801e:	f040 81e6 	bne.w	80083ee <_svfprintf_r+0x156a>
 8008022:	f107 0801 	add.w	r8, r7, #1
 8008026:	2302      	movs	r3, #2
 8008028:	9c1a      	ldr	r4, [sp, #104]	; 0x68
 800802a:	a942      	add	r1, sp, #264	; 0x108
 800802c:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
 8008030:	9300      	str	r3, [sp, #0]
 8008032:	940a      	str	r4, [sp, #40]	; 0x28
 8008034:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 8008038:	9811      	ldr	r0, [sp, #68]	; 0x44
 800803a:	9102      	str	r1, [sp, #8]
 800803c:	a941      	add	r1, sp, #260	; 0x104
 800803e:	f8cd 8004 	str.w	r8, [sp, #4]
 8008042:	9103      	str	r1, [sp, #12]
 8008044:	a940      	add	r1, sp, #256	; 0x100
 8008046:	9104      	str	r1, [sp, #16]
 8008048:	f000 fb1c 	bl	8008684 <_dtoa_r>
 800804c:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800804e:	f1b2 0367 	subs.w	r3, r2, #103	; 0x67
 8008052:	bf18      	it	ne
 8008054:	2301      	movne	r3, #1
 8008056:	2a47      	cmp	r2, #71	; 0x47
 8008058:	bf0c      	ite	eq
 800805a:	2300      	moveq	r3, #0
 800805c:	f003 0301 	andne.w	r3, r3, #1
 8008060:	9013      	str	r0, [sp, #76]	; 0x4c
 8008062:	b923      	cbnz	r3, 800806e <_svfprintf_r+0x11ea>
 8008064:	9b08      	ldr	r3, [sp, #32]
 8008066:	f013 0f01 	tst.w	r3, #1
 800806a:	f000 81e1 	beq.w	8008430 <_svfprintf_r+0x15ac>
 800806e:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8008070:	eb00 0408 	add.w	r4, r0, r8
 8008074:	f1bb 0f00 	cmp.w	fp, #0
 8008078:	d005      	beq.n	8008086 <_svfprintf_r+0x1202>
 800807a:	7803      	ldrb	r3, [r0, #0]
 800807c:	2b30      	cmp	r3, #48	; 0x30
 800807e:	f000 81e2 	beq.w	8008446 <_svfprintf_r+0x15c2>
 8008082:	9b42      	ldr	r3, [sp, #264]	; 0x108
 8008084:	18e4      	adds	r4, r4, r3
 8008086:	981a      	ldr	r0, [sp, #104]	; 0x68
 8008088:	2200      	movs	r2, #0
 800808a:	2300      	movs	r3, #0
 800808c:	4649      	mov	r1, r9
 800808e:	f004 fa31 	bl	800c4f4 <__aeabi_dcmpeq>
 8008092:	2800      	cmp	r0, #0
 8008094:	f000 8185 	beq.w	80083a2 <_svfprintf_r+0x151e>
 8008098:	4623      	mov	r3, r4
 800809a:	9440      	str	r4, [sp, #256]	; 0x100
 800809c:	9916      	ldr	r1, [sp, #88]	; 0x58
 800809e:	9c13      	ldr	r4, [sp, #76]	; 0x4c
 80080a0:	f1a1 0067 	sub.w	r0, r1, #103	; 0x67
 80080a4:	4242      	negs	r2, r0
 80080a6:	ebc4 0303 	rsb	r3, r4, r3
 80080aa:	eb42 0200 	adc.w	r2, r2, r0
 80080ae:	930e      	str	r3, [sp, #56]	; 0x38
 80080b0:	2947      	cmp	r1, #71	; 0x47
 80080b2:	bf14      	ite	ne
 80080b4:	4613      	movne	r3, r2
 80080b6:	f042 0301 	orreq.w	r3, r2, #1
 80080ba:	2b00      	cmp	r3, #0
 80080bc:	f000 8148 	beq.w	8008350 <_svfprintf_r+0x14cc>
 80080c0:	9b42      	ldr	r3, [sp, #264]	; 0x108
 80080c2:	f113 0f03 	cmn.w	r3, #3
 80080c6:	9310      	str	r3, [sp, #64]	; 0x40
 80080c8:	db02      	blt.n	80080d0 <_svfprintf_r+0x124c>
 80080ca:	429f      	cmp	r7, r3
 80080cc:	f280 8174 	bge.w	80083b8 <_svfprintf_r+0x1534>
 80080d0:	9816      	ldr	r0, [sp, #88]	; 0x58
 80080d2:	3802      	subs	r0, #2
 80080d4:	9016      	str	r0, [sp, #88]	; 0x58
 80080d6:	3b01      	subs	r3, #1
 80080d8:	9a16      	ldr	r2, [sp, #88]	; 0x58
 80080da:	2b00      	cmp	r3, #0
 80080dc:	9342      	str	r3, [sp, #264]	; 0x108
 80080de:	f88d 20f8 	strb.w	r2, [sp, #248]	; 0xf8
 80080e2:	f2c0 81c3 	blt.w	800846c <_svfprintf_r+0x15e8>
 80080e6:	222b      	movs	r2, #43	; 0x2b
 80080e8:	f88d 20f9 	strb.w	r2, [sp, #249]	; 0xf9
 80080ec:	2b09      	cmp	r3, #9
 80080ee:	f340 8186 	ble.w	80083fe <_svfprintf_r+0x157a>
 80080f2:	f246 6467 	movw	r4, #26215	; 0x6667
 80080f6:	f10d 00f6 	add.w	r0, sp, #246	; 0xf6
 80080fa:	f2c6 6466 	movt	r4, #26214	; 0x6666
 80080fe:	fb84 2103 	smull	r2, r1, r4, r3
 8008102:	17da      	asrs	r2, r3, #31
 8008104:	4605      	mov	r5, r0
 8008106:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
 800810a:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 800810e:	eba3 0141 	sub.w	r1, r3, r1, lsl #1
 8008112:	4613      	mov	r3, r2
 8008114:	3130      	adds	r1, #48	; 0x30
 8008116:	2a09      	cmp	r2, #9
 8008118:	f800 1901 	strb.w	r1, [r0], #-1
 800811c:	dcef      	bgt.n	80080fe <_svfprintf_r+0x127a>
 800811e:	3330      	adds	r3, #48	; 0x30
 8008120:	1e6a      	subs	r2, r5, #1
 8008122:	f805 3c01 	strb.w	r3, [r5, #-1]
 8008126:	f10d 03f7 	add.w	r3, sp, #247	; 0xf7
 800812a:	429a      	cmp	r2, r3
 800812c:	f080 81c4 	bcs.w	80084b8 <_svfprintf_r+0x1634>
 8008130:	f10d 03fa 	add.w	r3, sp, #250	; 0xfa
 8008134:	f812 1b01 	ldrb.w	r1, [r2], #1
 8008138:	f803 1b01 	strb.w	r1, [r3], #1
 800813c:	4619      	mov	r1, r3
 800813e:	9c07      	ldr	r4, [sp, #28]
 8008140:	4294      	cmp	r4, r2
 8008142:	d8f7      	bhi.n	8008134 <_svfprintf_r+0x12b0>
 8008144:	ab3e      	add	r3, sp, #248	; 0xf8
 8008146:	980e      	ldr	r0, [sp, #56]	; 0x38
 8008148:	1acb      	subs	r3, r1, r3
 800814a:	990e      	ldr	r1, [sp, #56]	; 0x38
 800814c:	1818      	adds	r0, r3, r0
 800814e:	931d      	str	r3, [sp, #116]	; 0x74
 8008150:	2901      	cmp	r1, #1
 8008152:	9010      	str	r0, [sp, #64]	; 0x40
 8008154:	f340 816e 	ble.w	8008434 <_svfprintf_r+0x15b0>
 8008158:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800815a:	2400      	movs	r4, #0
 800815c:	9418      	str	r4, [sp, #96]	; 0x60
 800815e:	3301      	adds	r3, #1
 8008160:	9310      	str	r3, [sp, #64]	; 0x40
 8008162:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8008164:	2b00      	cmp	r3, #0
 8008166:	f040 8107 	bne.w	8008378 <_svfprintf_r+0x14f4>
 800816a:	9c10      	ldr	r4, [sp, #64]	; 0x40
 800816c:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8008170:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
 8008174:	940a      	str	r4, [sp, #40]	; 0x28
 8008176:	f7ff b810 	b.w	800719a <_svfprintf_r+0x316>
 800817a:	9812      	ldr	r0, [sp, #72]	; 0x48
 800817c:	2500      	movs	r5, #0
 800817e:	6802      	ldr	r2, [r0, #0]
 8008180:	3004      	adds	r0, #4
 8008182:	9012      	str	r0, [sp, #72]	; 0x48
 8008184:	4614      	mov	r4, r2
 8008186:	3a00      	subs	r2, #0
 8008188:	bf18      	it	ne
 800818a:	2201      	movne	r2, #1
 800818c:	f7ff b98e 	b.w	80074ac <_svfprintf_r+0x628>
 8008190:	2140      	movs	r1, #64	; 0x40
 8008192:	9811      	ldr	r0, [sp, #68]	; 0x44
 8008194:	f7fe f9ac 	bl	80064f0 <_malloc_r>
 8008198:	990c      	ldr	r1, [sp, #48]	; 0x30
 800819a:	6008      	str	r0, [r1, #0]
 800819c:	6108      	str	r0, [r1, #16]
 800819e:	2800      	cmp	r0, #0
 80081a0:	f000 8182 	beq.w	80084a8 <_svfprintf_r+0x1624>
 80081a4:	980c      	ldr	r0, [sp, #48]	; 0x30
 80081a6:	2340      	movs	r3, #64	; 0x40
 80081a8:	6143      	str	r3, [r0, #20]
 80081aa:	f7fe be82 	b.w	8006eb2 <_svfprintf_r+0x2e>
 80081ae:	9c12      	ldr	r4, [sp, #72]	; 0x48
 80081b0:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80081b2:	6823      	ldr	r3, [r4, #0]
 80081b4:	3404      	adds	r4, #4
 80081b6:	9412      	str	r4, [sp, #72]	; 0x48
 80081b8:	6018      	str	r0, [r3, #0]
 80081ba:	f7fe be8c 	b.w	8006ed6 <_svfprintf_r+0x52>
 80081be:	9811      	ldr	r0, [sp, #68]	; 0x44
 80081c0:	aa39      	add	r2, sp, #228	; 0xe4
 80081c2:	990c      	ldr	r1, [sp, #48]	; 0x30
 80081c4:	f002 fcd8 	bl	800ab78 <__ssprint_r>
 80081c8:	2800      	cmp	r0, #0
 80081ca:	f47e af42 	bne.w	8007052 <_svfprintf_r+0x1ce>
 80081ce:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80081d0:	f10d 0984 	add.w	r9, sp, #132	; 0x84
 80081d4:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80081d6:	46d3      	mov	fp, sl
 80081d8:	f7ff bad6 	b.w	8007788 <_svfprintf_r+0x904>
 80081dc:	9811      	ldr	r0, [sp, #68]	; 0x44
 80081de:	aa39      	add	r2, sp, #228	; 0xe4
 80081e0:	990c      	ldr	r1, [sp, #48]	; 0x30
 80081e2:	f002 fcc9 	bl	800ab78 <__ssprint_r>
 80081e6:	2800      	cmp	r0, #0
 80081e8:	f47e af33 	bne.w	8007052 <_svfprintf_r+0x1ce>
 80081ec:	9e42      	ldr	r6, [sp, #264]	; 0x108
 80081ee:	46d1      	mov	r9, sl
 80081f0:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80081f2:	2e00      	cmp	r6, #0
 80081f4:	f47f ae6e 	bne.w	8007ed4 <_svfprintf_r+0x1050>
 80081f8:	e665      	b.n	8007ec6 <_svfprintf_r+0x1042>
 80081fa:	46a0      	mov	r8, r4
 80081fc:	461c      	mov	r4, r3
 80081fe:	3401      	adds	r4, #1
 8008200:	f8c9 8000 	str.w	r8, [r9]
 8008204:	2c07      	cmp	r4, #7
 8008206:	f8c9 6004 	str.w	r6, [r9, #4]
 800820a:	4435      	add	r5, r6
 800820c:	943a      	str	r4, [sp, #232]	; 0xe8
 800820e:	953b      	str	r5, [sp, #236]	; 0xec
 8008210:	bfd8      	it	le
 8008212:	f109 0908 	addle.w	r9, r9, #8
 8008216:	dd0a      	ble.n	800822e <_svfprintf_r+0x13aa>
 8008218:	9811      	ldr	r0, [sp, #68]	; 0x44
 800821a:	aa39      	add	r2, sp, #228	; 0xe4
 800821c:	990c      	ldr	r1, [sp, #48]	; 0x30
 800821e:	f002 fcab 	bl	800ab78 <__ssprint_r>
 8008222:	2800      	cmp	r0, #0
 8008224:	f47e af15 	bne.w	8007052 <_svfprintf_r+0x1ce>
 8008228:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800822a:	46d1      	mov	r9, sl
 800822c:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 800822e:	3401      	adds	r4, #1
 8008230:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8008232:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8008234:	2c07      	cmp	r4, #7
 8008236:	441d      	add	r5, r3
 8008238:	f8c9 3004 	str.w	r3, [r9, #4]
 800823c:	f8c9 2000 	str.w	r2, [r9]
 8008240:	943a      	str	r4, [sp, #232]	; 0xe8
 8008242:	953b      	str	r5, [sp, #236]	; 0xec
 8008244:	f77f a878 	ble.w	8007338 <_svfprintf_r+0x4b4>
 8008248:	f7ff baab 	b.w	80077a2 <_svfprintf_r+0x91e>
 800824c:	9811      	ldr	r0, [sp, #68]	; 0x44
 800824e:	aa39      	add	r2, sp, #228	; 0xe4
 8008250:	990c      	ldr	r1, [sp, #48]	; 0x30
 8008252:	f002 fc91 	bl	800ab78 <__ssprint_r>
 8008256:	2800      	cmp	r0, #0
 8008258:	f47e aefb 	bne.w	8007052 <_svfprintf_r+0x1ce>
 800825c:	9e42      	ldr	r6, [sp, #264]	; 0x108
 800825e:	46d1      	mov	r9, sl
 8008260:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8008262:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8008264:	e647      	b.n	8007ef6 <_svfprintf_r+0x1072>
 8008266:	2706      	movs	r7, #6
 8008268:	e6bb      	b.n	8007fe2 <_svfprintf_r+0x115e>
 800826a:	464b      	mov	r3, r9
 800826c:	e5a4      	b.n	8007db8 <_svfprintf_r+0xf34>
 800826e:	222d      	movs	r2, #45	; 0x2d
 8008270:	f88d 210f 	strb.w	r2, [sp, #271]	; 0x10f
 8008274:	f7ff b8e1 	b.w	800743a <_svfprintf_r+0x5b6>
 8008278:	9813      	ldr	r0, [sp, #76]	; 0x4c
 800827a:	2100      	movs	r1, #0
 800827c:	9114      	str	r1, [sp, #80]	; 0x50
 800827e:	f002 fc4b 	bl	800ab18 <strlen>
 8008282:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8008284:	9412      	str	r4, [sp, #72]	; 0x48
 8008286:	9318      	str	r3, [sp, #96]	; 0x60
 8008288:	ea20 72e0 	bic.w	r2, r0, r0, asr #31
 800828c:	9010      	str	r0, [sp, #64]	; 0x40
 800828e:	920a      	str	r2, [sp, #40]	; 0x28
 8008290:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8008294:	f7fe bf81 	b.w	800719a <_svfprintf_r+0x316>
 8008298:	f64c 7848 	movw	r8, #53064	; 0xcf48
 800829c:	f106 0308 	add.w	r3, r6, #8
 80082a0:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80082a2:	f6c0 0800 	movt	r8, #2048	; 0x800
 80082a6:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80082a8:	f7fe bfc2 	b.w	8007230 <_svfprintf_r+0x3ac>
 80082ac:	9811      	ldr	r0, [sp, #68]	; 0x44
 80082ae:	aa39      	add	r2, sp, #228	; 0xe4
 80082b0:	990c      	ldr	r1, [sp, #48]	; 0x30
 80082b2:	f002 fc61 	bl	800ab78 <__ssprint_r>
 80082b6:	2800      	cmp	r0, #0
 80082b8:	f47e aecb 	bne.w	8007052 <_svfprintf_r+0x1ce>
 80082bc:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80082be:	46d1      	mov	r9, sl
 80082c0:	f7ff bbe3 	b.w	8007a8a <_svfprintf_r+0xc06>
 80082c4:	9811      	ldr	r0, [sp, #68]	; 0x44
 80082c6:	aa39      	add	r2, sp, #228	; 0xe4
 80082c8:	990c      	ldr	r1, [sp, #48]	; 0x30
 80082ca:	f002 fc55 	bl	800ab78 <__ssprint_r>
 80082ce:	2800      	cmp	r0, #0
 80082d0:	f47e aebf 	bne.w	8007052 <_svfprintf_r+0x1ce>
 80082d4:	9a42      	ldr	r2, [sp, #264]	; 0x108
 80082d6:	4653      	mov	r3, sl
 80082d8:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80082da:	e575      	b.n	8007dc8 <_svfprintf_r+0xf44>
 80082dc:	9811      	ldr	r0, [sp, #68]	; 0x44
 80082de:	aa39      	add	r2, sp, #228	; 0xe4
 80082e0:	990c      	ldr	r1, [sp, #48]	; 0x30
 80082e2:	f002 fc49 	bl	800ab78 <__ssprint_r>
 80082e6:	2800      	cmp	r0, #0
 80082e8:	f47e aeb3 	bne.w	8007052 <_svfprintf_r+0x1ce>
 80082ec:	9a42      	ldr	r2, [sp, #264]	; 0x108
 80082ee:	4653      	mov	r3, sl
 80082f0:	980e      	ldr	r0, [sp, #56]	; 0x38
 80082f2:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80082f4:	1a82      	subs	r2, r0, r2
 80082f6:	e57e      	b.n	8007df6 <_svfprintf_r+0xf72>
 80082f8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80082fa:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 80082fe:	ebc3 030b 	rsb	r3, r3, fp
 8008302:	9310      	str	r3, [sp, #64]	; 0x40
 8008304:	f7fe bf3f 	b.w	8007186 <_svfprintf_r+0x302>
 8008308:	f64c 7848 	movw	r8, #53064	; 0xcf48
 800830c:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 800830e:	f6c0 0800 	movt	r8, #2048	; 0x800
 8008312:	f7ff b84b 	b.w	80073ac <_svfprintf_r+0x528>
 8008316:	9811      	ldr	r0, [sp, #68]	; 0x44
 8008318:	aa39      	add	r2, sp, #228	; 0xe4
 800831a:	990c      	ldr	r1, [sp, #48]	; 0x30
 800831c:	f002 fc2c 	bl	800ab78 <__ssprint_r>
 8008320:	2800      	cmp	r0, #0
 8008322:	f47e ae96 	bne.w	8007052 <_svfprintf_r+0x1ce>
 8008326:	4653      	mov	r3, sl
 8008328:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800832a:	e545      	b.n	8007db8 <_svfprintf_r+0xf34>
 800832c:	2f06      	cmp	r7, #6
 800832e:	bf28      	it	cs
 8008330:	2706      	movcs	r7, #6
 8008332:	f24d 2014 	movw	r0, #53780	; 0xd214
 8008336:	ea27 71e7 	bic.w	r1, r7, r7, asr #31
 800833a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800833e:	461a      	mov	r2, r3
 8008340:	9710      	str	r7, [sp, #64]	; 0x40
 8008342:	910a      	str	r1, [sp, #40]	; 0x28
 8008344:	9412      	str	r4, [sp, #72]	; 0x48
 8008346:	9314      	str	r3, [sp, #80]	; 0x50
 8008348:	9318      	str	r3, [sp, #96]	; 0x60
 800834a:	9013      	str	r0, [sp, #76]	; 0x4c
 800834c:	f7fe bf25 	b.w	800719a <_svfprintf_r+0x316>
 8008350:	9916      	ldr	r1, [sp, #88]	; 0x58
 8008352:	2966      	cmp	r1, #102	; 0x66
 8008354:	f040 808f 	bne.w	8008476 <_svfprintf_r+0x15f2>
 8008358:	9b42      	ldr	r3, [sp, #264]	; 0x108
 800835a:	2b00      	cmp	r3, #0
 800835c:	9310      	str	r3, [sp, #64]	; 0x40
 800835e:	f340 8098 	ble.w	8008492 <_svfprintf_r+0x160e>
 8008362:	b91f      	cbnz	r7, 800836c <_svfprintf_r+0x14e8>
 8008364:	9808      	ldr	r0, [sp, #32]
 8008366:	f010 0f01 	tst.w	r0, #1
 800836a:	d002      	beq.n	8008372 <_svfprintf_r+0x14ee>
 800836c:	1c5a      	adds	r2, r3, #1
 800836e:	19d2      	adds	r2, r2, r7
 8008370:	9210      	str	r2, [sp, #64]	; 0x40
 8008372:	9318      	str	r3, [sp, #96]	; 0x60
 8008374:	9516      	str	r5, [sp, #88]	; 0x58
 8008376:	e6f4      	b.n	8008162 <_svfprintf_r+0x12de>
 8008378:	9810      	ldr	r0, [sp, #64]	; 0x40
 800837a:	222d      	movs	r2, #45	; 0x2d
 800837c:	2100      	movs	r1, #0
 800837e:	f88d 210f 	strb.w	r2, [sp, #271]	; 0x10f
 8008382:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 8008386:	9114      	str	r1, [sp, #80]	; 0x50
 8008388:	900a      	str	r0, [sp, #40]	; 0x28
 800838a:	f7fe bf07 	b.w	800719c <_svfprintf_r+0x318>
 800838e:	46b8      	mov	r8, r7
 8008390:	2303      	movs	r3, #3
 8008392:	e649      	b.n	8008028 <_svfprintf_r+0x11a4>
 8008394:	4633      	mov	r3, r6
 8008396:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8008398:	3608      	adds	r6, #8
 800839a:	f8df 8124 	ldr.w	r8, [pc, #292]	; 80084c0 <_svfprintf_r+0x163c>
 800839e:	f7ff babe 	b.w	800791e <_svfprintf_r+0xa9a>
 80083a2:	9b40      	ldr	r3, [sp, #256]	; 0x100
 80083a4:	429c      	cmp	r4, r3
 80083a6:	f67f ae79 	bls.w	800809c <_svfprintf_r+0x1218>
 80083aa:	2230      	movs	r2, #48	; 0x30
 80083ac:	f803 2b01 	strb.w	r2, [r3], #1
 80083b0:	42a3      	cmp	r3, r4
 80083b2:	9340      	str	r3, [sp, #256]	; 0x100
 80083b4:	d1fa      	bne.n	80083ac <_svfprintf_r+0x1528>
 80083b6:	e671      	b.n	800809c <_svfprintf_r+0x1218>
 80083b8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80083ba:	4293      	cmp	r3, r2
 80083bc:	db2e      	blt.n	800841c <_svfprintf_r+0x1598>
 80083be:	9c08      	ldr	r4, [sp, #32]
 80083c0:	f014 0f01 	tst.w	r4, #1
 80083c4:	d03d      	beq.n	8008442 <_svfprintf_r+0x15be>
 80083c6:	1c58      	adds	r0, r3, #1
 80083c8:	2567      	movs	r5, #103	; 0x67
 80083ca:	9010      	str	r0, [sp, #64]	; 0x40
 80083cc:	e7d1      	b.n	8008372 <_svfprintf_r+0x14ee>
 80083ce:	ea27 72e7 	bic.w	r2, r7, r7, asr #31
 80083d2:	9014      	str	r0, [sp, #80]	; 0x50
 80083d4:	920a      	str	r2, [sp, #40]	; 0x28
 80083d6:	9412      	str	r4, [sp, #72]	; 0x48
 80083d8:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 80083dc:	9710      	str	r7, [sp, #64]	; 0x40
 80083de:	9018      	str	r0, [sp, #96]	; 0x60
 80083e0:	f7fe bedb 	b.w	800719a <_svfprintf_r+0x316>
 80083e4:	2700      	movs	r7, #0
 80083e6:	ea47 77e7 	orr.w	r7, r7, r7, asr #31
 80083ea:	f7fe bdb9 	b.w	8006f60 <_svfprintf_r+0xdc>
 80083ee:	46b8      	mov	r8, r7
 80083f0:	2302      	movs	r3, #2
 80083f2:	e619      	b.n	8008028 <_svfprintf_r+0x11a4>
 80083f4:	212d      	movs	r1, #45	; 0x2d
 80083f6:	f103 4900 	add.w	r9, r3, #2147483648	; 0x80000000
 80083fa:	9114      	str	r1, [sp, #80]	; 0x50
 80083fc:	e5fd      	b.n	8007ffa <_svfprintf_r+0x1176>
 80083fe:	3330      	adds	r3, #48	; 0x30
 8008400:	2230      	movs	r2, #48	; 0x30
 8008402:	a93f      	add	r1, sp, #252	; 0xfc
 8008404:	f88d 20fa 	strb.w	r2, [sp, #250]	; 0xfa
 8008408:	f88d 30fb 	strb.w	r3, [sp, #251]	; 0xfb
 800840c:	e69a      	b.n	8008144 <_svfprintf_r+0x12c0>
 800840e:	f103 0908 	add.w	r9, r3, #8
 8008412:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8008414:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 80084c0 <_svfprintf_r+0x163c>
 8008418:	f7ff bbe6 	b.w	8007be8 <_svfprintf_r+0xd64>
 800841c:	2b00      	cmp	r3, #0
 800841e:	990e      	ldr	r1, [sp, #56]	; 0x38
 8008420:	bfd4      	ite	le
 8008422:	f1c3 0202 	rsble	r2, r3, #2
 8008426:	2201      	movgt	r2, #1
 8008428:	1852      	adds	r2, r2, r1
 800842a:	2567      	movs	r5, #103	; 0x67
 800842c:	9210      	str	r2, [sp, #64]	; 0x40
 800842e:	e7a0      	b.n	8008372 <_svfprintf_r+0x14ee>
 8008430:	9b40      	ldr	r3, [sp, #256]	; 0x100
 8008432:	e633      	b.n	800809c <_svfprintf_r+0x1218>
 8008434:	9a08      	ldr	r2, [sp, #32]
 8008436:	f012 0301 	ands.w	r3, r2, #1
 800843a:	f47f ae8d 	bne.w	8008158 <_svfprintf_r+0x12d4>
 800843e:	9318      	str	r3, [sp, #96]	; 0x60
 8008440:	e68f      	b.n	8008162 <_svfprintf_r+0x12de>
 8008442:	2567      	movs	r5, #103	; 0x67
 8008444:	e795      	b.n	8008372 <_svfprintf_r+0x14ee>
 8008446:	981a      	ldr	r0, [sp, #104]	; 0x68
 8008448:	2200      	movs	r2, #0
 800844a:	2300      	movs	r3, #0
 800844c:	4649      	mov	r1, r9
 800844e:	f004 f851 	bl	800c4f4 <__aeabi_dcmpeq>
 8008452:	2800      	cmp	r0, #0
 8008454:	f47f ae15 	bne.w	8008082 <_svfprintf_r+0x11fe>
 8008458:	f1c8 0301 	rsb	r3, r8, #1
 800845c:	9342      	str	r3, [sp, #264]	; 0x108
 800845e:	e610      	b.n	8008082 <_svfprintf_r+0x11fe>
 8008460:	f109 0308 	add.w	r3, r9, #8
 8008464:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8008466:	f8df 8058 	ldr.w	r8, [pc, #88]	; 80084c0 <_svfprintf_r+0x163c>
 800846a:	e49a      	b.n	8007da2 <_svfprintf_r+0xf1e>
 800846c:	222d      	movs	r2, #45	; 0x2d
 800846e:	425b      	negs	r3, r3
 8008470:	f88d 20f9 	strb.w	r2, [sp, #249]	; 0xf9
 8008474:	e63a      	b.n	80080ec <_svfprintf_r+0x1268>
 8008476:	9b42      	ldr	r3, [sp, #264]	; 0x108
 8008478:	e62d      	b.n	80080d6 <_svfprintf_r+0x1252>
 800847a:	9812      	ldr	r0, [sp, #72]	; 0x48
 800847c:	6807      	ldr	r7, [r0, #0]
 800847e:	3004      	adds	r0, #4
 8008480:	2f00      	cmp	r7, #0
 8008482:	f6bf a943 	bge.w	800770c <_svfprintf_r+0x888>
 8008486:	7813      	ldrb	r3, [r2, #0]
 8008488:	f04f 37ff 	mov.w	r7, #4294967295
 800848c:	9012      	str	r0, [sp, #72]	; 0x48
 800848e:	f7fe bd66 	b.w	8006f5e <_svfprintf_r+0xda>
 8008492:	b91f      	cbnz	r7, 800849c <_svfprintf_r+0x1618>
 8008494:	9908      	ldr	r1, [sp, #32]
 8008496:	f011 0f01 	tst.w	r1, #1
 800849a:	d002      	beq.n	80084a2 <_svfprintf_r+0x161e>
 800849c:	3702      	adds	r7, #2
 800849e:	9710      	str	r7, [sp, #64]	; 0x40
 80084a0:	e767      	b.n	8008372 <_svfprintf_r+0x14ee>
 80084a2:	2201      	movs	r2, #1
 80084a4:	9210      	str	r2, [sp, #64]	; 0x40
 80084a6:	e764      	b.n	8008372 <_svfprintf_r+0x14ee>
 80084a8:	9c11      	ldr	r4, [sp, #68]	; 0x44
 80084aa:	f04f 32ff 	mov.w	r2, #4294967295
 80084ae:	230c      	movs	r3, #12
 80084b0:	920f      	str	r2, [sp, #60]	; 0x3c
 80084b2:	6023      	str	r3, [r4, #0]
 80084b4:	f7fe bdd6 	b.w	8007064 <_svfprintf_r+0x1e0>
 80084b8:	f10d 01fa 	add.w	r1, sp, #250	; 0xfa
 80084bc:	e642      	b.n	8008144 <_svfprintf_r+0x12c0>
 80084be:	bf00      	nop
 80084c0:	0800cf58 	.word	0x0800cf58

080084c4 <open>:
 80084c4:	b40e      	push	{r1, r2, r3}
 80084c6:	f240 2378 	movw	r3, #632	; 0x278
 80084ca:	b510      	push	{r4, lr}
 80084cc:	b083      	sub	sp, #12
 80084ce:	ac05      	add	r4, sp, #20
 80084d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80084d4:	4601      	mov	r1, r0
 80084d6:	f854 2b04 	ldr.w	r2, [r4], #4
 80084da:	6818      	ldr	r0, [r3, #0]
 80084dc:	9b06      	ldr	r3, [sp, #24]
 80084de:	3404      	adds	r4, #4
 80084e0:	9401      	str	r4, [sp, #4]
 80084e2:	f002 f9cf 	bl	800a884 <_open_r>
 80084e6:	b003      	add	sp, #12
 80084e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80084ec:	b003      	add	sp, #12
 80084ee:	4770      	bx	lr

080084f0 <read>:
 80084f0:	b430      	push	{r4, r5}
 80084f2:	f240 2478 	movw	r4, #632	; 0x278
 80084f6:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80084fa:	460d      	mov	r5, r1
 80084fc:	4613      	mov	r3, r2
 80084fe:	4601      	mov	r1, r0
 8008500:	462a      	mov	r2, r5
 8008502:	6820      	ldr	r0, [r4, #0]
 8008504:	bc30      	pop	{r4, r5}
 8008506:	f002 b9d3 	b.w	800a8b0 <_read_r>
 800850a:	bf00      	nop

0800850c <write>:
 800850c:	b430      	push	{r4, r5}
 800850e:	f240 2478 	movw	r4, #632	; 0x278
 8008512:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8008516:	460d      	mov	r5, r1
 8008518:	4613      	mov	r3, r2
 800851a:	4601      	mov	r1, r0
 800851c:	462a      	mov	r2, r5
 800851e:	6820      	ldr	r0, [r4, #0]
 8008520:	bc30      	pop	{r4, r5}
 8008522:	f000 b801 	b.w	8008528 <_write_r>
 8008526:	bf00      	nop

08008528 <_write_r>:
 8008528:	b538      	push	{r3, r4, r5, lr}
 800852a:	f642 248c 	movw	r4, #10892	; 0x2a8c
 800852e:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8008532:	4605      	mov	r5, r0
 8008534:	4608      	mov	r0, r1
 8008536:	4611      	mov	r1, r2
 8008538:	461a      	mov	r2, r3
 800853a:	2300      	movs	r3, #0
 800853c:	6023      	str	r3, [r4, #0]
 800853e:	f7f8 fb8b 	bl	8000c58 <_write>
 8008542:	f1b0 3fff 	cmp.w	r0, #4294967295
 8008546:	d000      	beq.n	800854a <_write_r+0x22>
 8008548:	bd38      	pop	{r3, r4, r5, pc}
 800854a:	6823      	ldr	r3, [r4, #0]
 800854c:	2b00      	cmp	r3, #0
 800854e:	d0fb      	beq.n	8008548 <_write_r+0x20>
 8008550:	602b      	str	r3, [r5, #0]
 8008552:	bd38      	pop	{r3, r4, r5, pc}
 8008554:	0000      	movs	r0, r0
	...

08008558 <quorem>:
 8008558:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800855c:	b083      	sub	sp, #12
 800855e:	6903      	ldr	r3, [r0, #16]
 8008560:	4681      	mov	r9, r0
 8008562:	690d      	ldr	r5, [r1, #16]
 8008564:	9101      	str	r1, [sp, #4]
 8008566:	429d      	cmp	r5, r3
 8008568:	f300 8089 	bgt.w	800867e <quorem+0x126>
 800856c:	1cea      	adds	r2, r5, #3
 800856e:	f101 0414 	add.w	r4, r1, #20
 8008572:	f100 0814 	add.w	r8, r0, #20
 8008576:	3d01      	subs	r5, #1
 8008578:	0092      	lsls	r2, r2, #2
 800857a:	188b      	adds	r3, r1, r2
 800857c:	1882      	adds	r2, r0, r2
 800857e:	1d1f      	adds	r7, r3, #4
 8008580:	6859      	ldr	r1, [r3, #4]
 8008582:	6850      	ldr	r0, [r2, #4]
 8008584:	3101      	adds	r1, #1
 8008586:	f003 fc0f 	bl	800bda8 <__aeabi_uidiv>
 800858a:	4606      	mov	r6, r0
 800858c:	2800      	cmp	r0, #0
 800858e:	d03c      	beq.n	800860a <quorem+0xb2>
 8008590:	2000      	movs	r0, #0
 8008592:	4642      	mov	r2, r8
 8008594:	4623      	mov	r3, r4
 8008596:	4686      	mov	lr, r0
 8008598:	f853 cb04 	ldr.w	ip, [r3], #4
 800859c:	6811      	ldr	r1, [r2, #0]
 800859e:	fa1f fb8c 	uxth.w	fp, ip
 80085a2:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 80085a6:	fa1f fa81 	uxth.w	sl, r1
 80085aa:	fb0b 0b06 	mla	fp, fp, r6, r0
 80085ae:	44d6      	add	lr, sl
 80085b0:	fb0c f006 	mul.w	r0, ip, r6
 80085b4:	eb00 401b 	add.w	r0, r0, fp, lsr #16
 80085b8:	fa1f fb8b 	uxth.w	fp, fp
 80085bc:	ebcb 0a0e 	rsb	sl, fp, lr
 80085c0:	fa1f fe80 	uxth.w	lr, r0
 80085c4:	0c00      	lsrs	r0, r0, #16
 80085c6:	ebce 4e11 	rsb	lr, lr, r1, lsr #16
 80085ca:	429f      	cmp	r7, r3
 80085cc:	eb0e 4e2a 	add.w	lr, lr, sl, asr #16
 80085d0:	fa1f fc8a 	uxth.w	ip, sl
 80085d4:	ea4c 410e 	orr.w	r1, ip, lr, lsl #16
 80085d8:	ea4f 4e2e 	mov.w	lr, lr, asr #16
 80085dc:	f842 1b04 	str.w	r1, [r2], #4
 80085e0:	d2da      	bcs.n	8008598 <quorem+0x40>
 80085e2:	1d2a      	adds	r2, r5, #4
 80085e4:	eb09 0382 	add.w	r3, r9, r2, lsl #2
 80085e8:	6859      	ldr	r1, [r3, #4]
 80085ea:	b971      	cbnz	r1, 800860a <quorem+0xb2>
 80085ec:	4598      	cmp	r8, r3
 80085ee:	d20a      	bcs.n	8008606 <quorem+0xae>
 80085f0:	f859 2022 	ldr.w	r2, [r9, r2, lsl #2]
 80085f4:	b93a      	cbnz	r2, 8008606 <quorem+0xae>
 80085f6:	3b04      	subs	r3, #4
 80085f8:	e002      	b.n	8008600 <quorem+0xa8>
 80085fa:	f853 2904 	ldr.w	r2, [r3], #-4
 80085fe:	b912      	cbnz	r2, 8008606 <quorem+0xae>
 8008600:	3d01      	subs	r5, #1
 8008602:	4598      	cmp	r8, r3
 8008604:	d3f9      	bcc.n	80085fa <quorem+0xa2>
 8008606:	f8c9 5010 	str.w	r5, [r9, #16]
 800860a:	4648      	mov	r0, r9
 800860c:	9901      	ldr	r1, [sp, #4]
 800860e:	f001 ff21 	bl	800a454 <__mcmp>
 8008612:	2800      	cmp	r0, #0
 8008614:	db2f      	blt.n	8008676 <quorem+0x11e>
 8008616:	3601      	adds	r6, #1
 8008618:	4643      	mov	r3, r8
 800861a:	f04f 0c00 	mov.w	ip, #0
 800861e:	f854 0b04 	ldr.w	r0, [r4], #4
 8008622:	6819      	ldr	r1, [r3, #0]
 8008624:	fa1f fa80 	uxth.w	sl, r0
 8008628:	0c00      	lsrs	r0, r0, #16
 800862a:	b28a      	uxth	r2, r1
 800862c:	ebc0 4111 	rsb	r1, r0, r1, lsr #16
 8008630:	ebca 0202 	rsb	r2, sl, r2
 8008634:	42a7      	cmp	r7, r4
 8008636:	4494      	add	ip, r2
 8008638:	eb01 422c 	add.w	r2, r1, ip, asr #16
 800863c:	fa1f fc8c 	uxth.w	ip, ip
 8008640:	ea4c 4102 	orr.w	r1, ip, r2, lsl #16
 8008644:	ea4f 4c22 	mov.w	ip, r2, asr #16
 8008648:	f843 1b04 	str.w	r1, [r3], #4
 800864c:	d2e7      	bcs.n	800861e <quorem+0xc6>
 800864e:	1d2a      	adds	r2, r5, #4
 8008650:	eb09 0382 	add.w	r3, r9, r2, lsl #2
 8008654:	6859      	ldr	r1, [r3, #4]
 8008656:	b971      	cbnz	r1, 8008676 <quorem+0x11e>
 8008658:	4598      	cmp	r8, r3
 800865a:	d20a      	bcs.n	8008672 <quorem+0x11a>
 800865c:	f859 2022 	ldr.w	r2, [r9, r2, lsl #2]
 8008660:	b93a      	cbnz	r2, 8008672 <quorem+0x11a>
 8008662:	3b04      	subs	r3, #4
 8008664:	e002      	b.n	800866c <quorem+0x114>
 8008666:	f853 2904 	ldr.w	r2, [r3], #-4
 800866a:	b912      	cbnz	r2, 8008672 <quorem+0x11a>
 800866c:	3d01      	subs	r5, #1
 800866e:	4598      	cmp	r8, r3
 8008670:	d3f9      	bcc.n	8008666 <quorem+0x10e>
 8008672:	f8c9 5010 	str.w	r5, [r9, #16]
 8008676:	4630      	mov	r0, r6
 8008678:	b003      	add	sp, #12
 800867a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800867e:	2000      	movs	r0, #0
 8008680:	e7fa      	b.n	8008678 <quorem+0x120>
 8008682:	bf00      	nop

08008684 <_dtoa_r>:
 8008684:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008688:	b09f      	sub	sp, #124	; 0x7c
 800868a:	6a45      	ldr	r5, [r0, #36]	; 0x24
 800868c:	4604      	mov	r4, r0
 800868e:	4690      	mov	r8, r2
 8008690:	4699      	mov	r9, r3
 8008692:	9e2b      	ldr	r6, [sp, #172]	; 0xac
 8008694:	2d00      	cmp	r5, #0
 8008696:	f000 8390 	beq.w	8008dba <_dtoa_r+0x736>
 800869a:	682b      	ldr	r3, [r5, #0]
 800869c:	b153      	cbz	r3, 80086b4 <_dtoa_r+0x30>
 800869e:	686a      	ldr	r2, [r5, #4]
 80086a0:	2501      	movs	r5, #1
 80086a2:	4619      	mov	r1, r3
 80086a4:	4095      	lsls	r5, r2
 80086a6:	609d      	str	r5, [r3, #8]
 80086a8:	605a      	str	r2, [r3, #4]
 80086aa:	f001 fc91 	bl	8009fd0 <_Bfree>
 80086ae:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80086b0:	2200      	movs	r2, #0
 80086b2:	601a      	str	r2, [r3, #0]
 80086b4:	f1b9 0500 	subs.w	r5, r9, #0
 80086b8:	f2c0 80d3 	blt.w	8008862 <_dtoa_r+0x1de>
 80086bc:	2300      	movs	r3, #0
 80086be:	6033      	str	r3, [r6, #0]
 80086c0:	2300      	movs	r3, #0
 80086c2:	461a      	mov	r2, r3
 80086c4:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 80086c8:	f6c7 72f0 	movt	r2, #32752	; 0x7ff0
 80086cc:	ea05 0303 	and.w	r3, r5, r3
 80086d0:	4293      	cmp	r3, r2
 80086d2:	f000 80af 	beq.w	8008834 <_dtoa_r+0x1b0>
 80086d6:	2200      	movs	r2, #0
 80086d8:	2300      	movs	r3, #0
 80086da:	4640      	mov	r0, r8
 80086dc:	4649      	mov	r1, r9
 80086de:	e9cd 8902 	strd	r8, r9, [sp, #8]
 80086e2:	2601      	movs	r6, #1
 80086e4:	f003 ff06 	bl	800c4f4 <__aeabi_dcmpeq>
 80086e8:	b988      	cbnz	r0, 800870e <_dtoa_r+0x8a>
 80086ea:	f016 0fff 	tst.w	r6, #255	; 0xff
 80086ee:	d112      	bne.n	8008716 <_dtoa_r+0x92>
 80086f0:	982a      	ldr	r0, [sp, #168]	; 0xa8
 80086f2:	2301      	movs	r3, #1
 80086f4:	992c      	ldr	r1, [sp, #176]	; 0xb0
 80086f6:	6003      	str	r3, [r0, #0]
 80086f8:	f24d 201c 	movw	r0, #53788	; 0xd21c
 80086fc:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008700:	b111      	cbz	r1, 8008708 <_dtoa_r+0x84>
 8008702:	4b7b      	ldr	r3, [pc, #492]	; (80088f0 <_dtoa_r+0x26c>)
 8008704:	1e58      	subs	r0, r3, #1
 8008706:	600b      	str	r3, [r1, #0]
 8008708:	b01f      	add	sp, #124	; 0x7c
 800870a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800870e:	2600      	movs	r6, #0
 8008710:	f016 0fff 	tst.w	r6, #255	; 0xff
 8008714:	d0ec      	beq.n	80086f0 <_dtoa_r+0x6c>
 8008716:	4620      	mov	r0, r4
 8008718:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800871c:	a91c      	add	r1, sp, #112	; 0x70
 800871e:	9100      	str	r1, [sp, #0]
 8008720:	a91d      	add	r1, sp, #116	; 0x74
 8008722:	9101      	str	r1, [sp, #4]
 8008724:	f001 ffaa 	bl	800a67c <__d2b>
 8008728:	f3c5 560a 	ubfx	r6, r5, #20, #11
 800872c:	4682      	mov	sl, r0
 800872e:	2e00      	cmp	r6, #0
 8008730:	f000 80ac 	beq.w	800888c <_dtoa_r+0x208>
 8008734:	9803      	ldr	r0, [sp, #12]
 8008736:	f5a6 767e 	sub.w	r6, r6, #1016	; 0x3f8
 800873a:	9f1d      	ldr	r7, [sp, #116]	; 0x74
 800873c:	3e07      	subs	r6, #7
 800873e:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
 8008742:	2100      	movs	r1, #0
 8008744:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 8008748:	9116      	str	r1, [sp, #88]	; 0x58
 800874a:	f043 537e 	orr.w	r3, r3, #1065353216	; 0x3f800000
 800874e:	f443 03e0 	orr.w	r3, r3, #7340032	; 0x700000
 8008752:	9303      	str	r3, [sp, #12]
 8008754:	2300      	movs	r3, #0
 8008756:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800875a:	2200      	movs	r2, #0
 800875c:	f6c3 73f8 	movt	r3, #16376	; 0x3ff8
 8008760:	f7fd fb8a 	bl	8005e78 <__aeabi_dsub>
 8008764:	a35c      	add	r3, pc, #368	; (adr r3, 80088d8 <_dtoa_r+0x254>)
 8008766:	e9d3 2300 	ldrd	r2, r3, [r3]
 800876a:	f003 fc5b 	bl	800c024 <__aeabi_dmul>
 800876e:	a35c      	add	r3, pc, #368	; (adr r3, 80088e0 <_dtoa_r+0x25c>)
 8008770:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008774:	f7fd fb82 	bl	8005e7c <__adddf3>
 8008778:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800877c:	4630      	mov	r0, r6
 800877e:	f7fd fcc9 	bl	8006114 <__aeabi_i2d>
 8008782:	a359      	add	r3, pc, #356	; (adr r3, 80088e8 <_dtoa_r+0x264>)
 8008784:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008788:	f003 fc4c 	bl	800c024 <__aeabi_dmul>
 800878c:	4602      	mov	r2, r0
 800878e:	460b      	mov	r3, r1
 8008790:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8008794:	f7fd fb72 	bl	8005e7c <__adddf3>
 8008798:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800879c:	f003 fedc 	bl	800c558 <__aeabi_d2iz>
 80087a0:	2200      	movs	r2, #0
 80087a2:	2300      	movs	r3, #0
 80087a4:	4605      	mov	r5, r0
 80087a6:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80087aa:	f003 fead 	bl	800c508 <__aeabi_dcmplt>
 80087ae:	b140      	cbz	r0, 80087c2 <_dtoa_r+0x13e>
 80087b0:	4628      	mov	r0, r5
 80087b2:	f7fd fcaf 	bl	8006114 <__aeabi_i2d>
 80087b6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80087ba:	f003 fe9b 	bl	800c4f4 <__aeabi_dcmpeq>
 80087be:	b900      	cbnz	r0, 80087c2 <_dtoa_r+0x13e>
 80087c0:	3d01      	subs	r5, #1
 80087c2:	2d16      	cmp	r5, #22
 80087c4:	f200 8255 	bhi.w	8008c72 <_dtoa_r+0x5ee>
 80087c8:	f64c 71d8 	movw	r1, #53208	; 0xcfd8
 80087cc:	4642      	mov	r2, r8
 80087ce:	f6c0 0100 	movt	r1, #2048	; 0x800
 80087d2:	464b      	mov	r3, r9
 80087d4:	eb01 01c5 	add.w	r1, r1, r5, lsl #3
 80087d8:	e9d1 0100 	ldrd	r0, r1, [r1]
 80087dc:	f003 feb2 	bl	800c544 <__aeabi_dcmpgt>
 80087e0:	2800      	cmp	r0, #0
 80087e2:	f000 8300 	beq.w	8008de6 <_dtoa_r+0x762>
 80087e6:	3d01      	subs	r5, #1
 80087e8:	2000      	movs	r0, #0
 80087ea:	9015      	str	r0, [sp, #84]	; 0x54
 80087ec:	3f01      	subs	r7, #1
 80087ee:	1bbe      	subs	r6, r7, r6
 80087f0:	f100 82f4 	bmi.w	8008ddc <_dtoa_r+0x758>
 80087f4:	2000      	movs	r0, #0
 80087f6:	960b      	str	r6, [sp, #44]	; 0x2c
 80087f8:	900d      	str	r0, [sp, #52]	; 0x34
 80087fa:	2d00      	cmp	r5, #0
 80087fc:	f2c0 82e6 	blt.w	8008dcc <_dtoa_r+0x748>
 8008800:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8008802:	2200      	movs	r2, #0
 8008804:	9511      	str	r5, [sp, #68]	; 0x44
 8008806:	1949      	adds	r1, r1, r5
 8008808:	920f      	str	r2, [sp, #60]	; 0x3c
 800880a:	910b      	str	r1, [sp, #44]	; 0x2c
 800880c:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800880e:	2a09      	cmp	r2, #9
 8008810:	d870      	bhi.n	80088f4 <_dtoa_r+0x270>
 8008812:	2a05      	cmp	r2, #5
 8008814:	f340 8690 	ble.w	8009538 <_dtoa_r+0xeb4>
 8008818:	2700      	movs	r7, #0
 800881a:	3a04      	subs	r2, #4
 800881c:	9228      	str	r2, [sp, #160]	; 0xa0
 800881e:	9828      	ldr	r0, [sp, #160]	; 0xa0
 8008820:	1e83      	subs	r3, r0, #2
 8008822:	2b03      	cmp	r3, #3
 8008824:	f200 840a 	bhi.w	800903c <_dtoa_r+0x9b8>
 8008828:	e8df f013 	tbh	[pc, r3, lsl #1]
 800882c:	03ec0402 	.word	0x03ec0402
 8008830:	040503cc 	.word	0x040503cc
 8008834:	982a      	ldr	r0, [sp, #168]	; 0xa8
 8008836:	f242 730f 	movw	r3, #9999	; 0x270f
 800883a:	6003      	str	r3, [r0, #0]
 800883c:	f24d 202c 	movw	r0, #53804	; 0xd22c
 8008840:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008844:	f1b8 0f00 	cmp.w	r8, #0
 8008848:	d011      	beq.n	800886e <_dtoa_r+0x1ea>
 800884a:	992c      	ldr	r1, [sp, #176]	; 0xb0
 800884c:	2900      	cmp	r1, #0
 800884e:	f43f af5b 	beq.w	8008708 <_dtoa_r+0x84>
 8008852:	78c2      	ldrb	r2, [r0, #3]
 8008854:	1cc3      	adds	r3, r0, #3
 8008856:	b10a      	cbz	r2, 800885c <_dtoa_r+0x1d8>
 8008858:	f100 0308 	add.w	r3, r0, #8
 800885c:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
 800885e:	6013      	str	r3, [r2, #0]
 8008860:	e752      	b.n	8008708 <_dtoa_r+0x84>
 8008862:	f025 4500 	bic.w	r5, r5, #2147483648	; 0x80000000
 8008866:	2301      	movs	r3, #1
 8008868:	46a9      	mov	r9, r5
 800886a:	6033      	str	r3, [r6, #0]
 800886c:	e728      	b.n	80086c0 <_dtoa_r+0x3c>
 800886e:	f24d 2220 	movw	r2, #53792	; 0xd220
 8008872:	f24d 232c 	movw	r3, #53804	; 0xd22c
 8008876:	f3c5 0013 	ubfx	r0, r5, #0, #20
 800887a:	f6c0 0200 	movt	r2, #2048	; 0x800
 800887e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008882:	2800      	cmp	r0, #0
 8008884:	bf0c      	ite	eq
 8008886:	4610      	moveq	r0, r2
 8008888:	4618      	movne	r0, r3
 800888a:	e7de      	b.n	800884a <_dtoa_r+0x1c6>
 800888c:	9f1d      	ldr	r7, [sp, #116]	; 0x74
 800888e:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8008890:	18fb      	adds	r3, r7, r3
 8008892:	f503 6386 	add.w	r3, r3, #1072	; 0x430
 8008896:	1c9e      	adds	r6, r3, #2
 8008898:	2e20      	cmp	r6, #32
 800889a:	bfdc      	itt	le
 800889c:	f1c6 0020 	rsble	r0, r6, #32
 80088a0:	fa08 f000 	lslle.w	r0, r8, r0
 80088a4:	dd07      	ble.n	80088b6 <_dtoa_r+0x232>
 80088a6:	f1c6 0040 	rsb	r0, r6, #64	; 0x40
 80088aa:	3b1e      	subs	r3, #30
 80088ac:	4085      	lsls	r5, r0
 80088ae:	fa28 f303 	lsr.w	r3, r8, r3
 80088b2:	ea45 0003 	orr.w	r0, r5, r3
 80088b6:	2201      	movs	r2, #1
 80088b8:	9216      	str	r2, [sp, #88]	; 0x58
 80088ba:	f7fd fc1b 	bl	80060f4 <__aeabi_ui2d>
 80088be:	f5a6 6686 	sub.w	r6, r6, #1072	; 0x430
 80088c2:	3e03      	subs	r6, #3
 80088c4:	460b      	mov	r3, r1
 80088c6:	4602      	mov	r2, r0
 80088c8:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80088cc:	9b03      	ldr	r3, [sp, #12]
 80088ce:	f1a3 73f8 	sub.w	r3, r3, #32505856	; 0x1f00000
 80088d2:	9303      	str	r3, [sp, #12]
 80088d4:	e73e      	b.n	8008754 <_dtoa_r+0xd0>
 80088d6:	bf00      	nop
 80088d8:	636f4361 	.word	0x636f4361
 80088dc:	3fd287a7 	.word	0x3fd287a7
 80088e0:	8b60c8b3 	.word	0x8b60c8b3
 80088e4:	3fc68a28 	.word	0x3fc68a28
 80088e8:	509f79fb 	.word	0x509f79fb
 80088ec:	3fd34413 	.word	0x3fd34413
 80088f0:	0800d21d 	.word	0x0800d21d
 80088f4:	2000      	movs	r0, #0
 80088f6:	f04f 31ff 	mov.w	r1, #4294967295
 80088fa:	4607      	mov	r7, r0
 80088fc:	2201      	movs	r2, #1
 80088fe:	9028      	str	r0, [sp, #160]	; 0xa0
 8008900:	910e      	str	r1, [sp, #56]	; 0x38
 8008902:	9210      	str	r2, [sp, #64]	; 0x40
 8008904:	910a      	str	r1, [sp, #40]	; 0x28
 8008906:	9029      	str	r0, [sp, #164]	; 0xa4
 8008908:	6a66      	ldr	r6, [r4, #36]	; 0x24
 800890a:	2300      	movs	r3, #0
 800890c:	6073      	str	r3, [r6, #4]
 800890e:	4620      	mov	r0, r4
 8008910:	6871      	ldr	r1, [r6, #4]
 8008912:	f001 fb29 	bl	8009f68 <_Balloc>
 8008916:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008918:	6030      	str	r0, [r6, #0]
 800891a:	681b      	ldr	r3, [r3, #0]
 800891c:	930c      	str	r3, [sp, #48]	; 0x30
 800891e:	2f00      	cmp	r7, #0
 8008920:	f000 80de 	beq.w	8008ae0 <_dtoa_r+0x45c>
 8008924:	2d00      	cmp	r5, #0
 8008926:	4640      	mov	r0, r8
 8008928:	4649      	mov	r1, r9
 800892a:	e9cd 8908 	strd	r8, r9, [sp, #32]
 800892e:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8008932:	f340 842e 	ble.w	8009192 <_dtoa_r+0xb0e>
 8008936:	f64c 73d8 	movw	r3, #53208	; 0xcfd8
 800893a:	f005 020f 	and.w	r2, r5, #15
 800893e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008942:	112e      	asrs	r6, r5, #4
 8008944:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008948:	f016 0f10 	tst.w	r6, #16
 800894c:	bf08      	it	eq
 800894e:	f04f 0802 	moveq.w	r8, #2
 8008952:	e9d3 0100 	ldrd	r0, r1, [r3]
 8008956:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
 800895a:	f040 8247 	bne.w	8008dec <_dtoa_r+0x768>
 800895e:	b1be      	cbz	r6, 8008990 <_dtoa_r+0x30c>
 8008960:	f24d 07a0 	movw	r7, #53408	; 0xd0a0
 8008964:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 8008968:	f6c0 0700 	movt	r7, #2048	; 0x800
 800896c:	f016 0f01 	tst.w	r6, #1
 8008970:	4610      	mov	r0, r2
 8008972:	4619      	mov	r1, r3
 8008974:	d007      	beq.n	8008986 <_dtoa_r+0x302>
 8008976:	e9d7 2300 	ldrd	r2, r3, [r7]
 800897a:	f108 0801 	add.w	r8, r8, #1
 800897e:	f003 fb51 	bl	800c024 <__aeabi_dmul>
 8008982:	4602      	mov	r2, r0
 8008984:	460b      	mov	r3, r1
 8008986:	3708      	adds	r7, #8
 8008988:	1076      	asrs	r6, r6, #1
 800898a:	d1ef      	bne.n	800896c <_dtoa_r+0x2e8>
 800898c:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
 8008990:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8008994:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 8008998:	f003 fc6e 	bl	800c278 <__aeabi_ddiv>
 800899c:	e9cd 0108 	strd	r0, r1, [sp, #32]
 80089a0:	9915      	ldr	r1, [sp, #84]	; 0x54
 80089a2:	2900      	cmp	r1, #0
 80089a4:	d038      	beq.n	8008a18 <_dtoa_r+0x394>
 80089a6:	2300      	movs	r3, #0
 80089a8:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80089ac:	2200      	movs	r2, #0
 80089ae:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
 80089b2:	2601      	movs	r6, #1
 80089b4:	f003 fda8 	bl	800c508 <__aeabi_dcmplt>
 80089b8:	2800      	cmp	r0, #0
 80089ba:	f000 8301 	beq.w	8008fc0 <_dtoa_r+0x93c>
 80089be:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80089c0:	2a00      	cmp	r2, #0
 80089c2:	bfd4      	ite	le
 80089c4:	2600      	movle	r6, #0
 80089c6:	f006 0601 	andgt.w	r6, r6, #1
 80089ca:	b32e      	cbz	r6, 8008a18 <_dtoa_r+0x394>
 80089cc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80089ce:	2b00      	cmp	r3, #0
 80089d0:	f340 8082 	ble.w	8008ad8 <_dtoa_r+0x454>
 80089d4:	2300      	movs	r3, #0
 80089d6:	2200      	movs	r2, #0
 80089d8:	f2c4 0324 	movt	r3, #16420	; 0x4024
 80089dc:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80089e0:	f003 fb20 	bl	800c024 <__aeabi_dmul>
 80089e4:	e9cd 0108 	strd	r0, r1, [sp, #32]
 80089e8:	f108 0001 	add.w	r0, r8, #1
 80089ec:	1e69      	subs	r1, r5, #1
 80089ee:	9112      	str	r1, [sp, #72]	; 0x48
 80089f0:	f7fd fb90 	bl	8006114 <__aeabi_i2d>
 80089f4:	4602      	mov	r2, r0
 80089f6:	460b      	mov	r3, r1
 80089f8:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80089fc:	f003 fb12 	bl	800c024 <__aeabi_dmul>
 8008a00:	2300      	movs	r3, #0
 8008a02:	2200      	movs	r2, #0
 8008a04:	f2c4 031c 	movt	r3, #16412	; 0x401c
 8008a08:	f7fd fa38 	bl	8005e7c <__adddf3>
 8008a0c:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
 8008a10:	4680      	mov	r8, r0
 8008a12:	f1a1 7950 	sub.w	r9, r1, #54525952	; 0x3400000
 8008a16:	e23c      	b.n	8008e92 <_dtoa_r+0x80e>
 8008a18:	4640      	mov	r0, r8
 8008a1a:	f7fd fb7b 	bl	8006114 <__aeabi_i2d>
 8008a1e:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8008a22:	f003 faff 	bl	800c024 <__aeabi_dmul>
 8008a26:	2300      	movs	r3, #0
 8008a28:	2200      	movs	r2, #0
 8008a2a:	f2c4 031c 	movt	r3, #16412	; 0x401c
 8008a2e:	f7fd fa25 	bl	8005e7c <__adddf3>
 8008a32:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8008a34:	f1a1 7650 	sub.w	r6, r1, #54525952	; 0x3400000
 8008a38:	4680      	mov	r8, r0
 8008a3a:	46b1      	mov	r9, r6
 8008a3c:	2a00      	cmp	r2, #0
 8008a3e:	f040 8225 	bne.w	8008e8c <_dtoa_r+0x808>
 8008a42:	2300      	movs	r3, #0
 8008a44:	2200      	movs	r2, #0
 8008a46:	f2c4 0314 	movt	r3, #16404	; 0x4014
 8008a4a:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8008a4e:	f7fd fa13 	bl	8005e78 <__aeabi_dsub>
 8008a52:	4642      	mov	r2, r8
 8008a54:	4633      	mov	r3, r6
 8008a56:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8008a5a:	f003 fd73 	bl	800c544 <__aeabi_dcmpgt>
 8008a5e:	2800      	cmp	r0, #0
 8008a60:	f040 820f 	bne.w	8008e82 <_dtoa_r+0x7fe>
 8008a64:	4642      	mov	r2, r8
 8008a66:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8008a6a:	f106 4300 	add.w	r3, r6, #2147483648	; 0x80000000
 8008a6e:	f003 fd4b 	bl	800c508 <__aeabi_dcmplt>
 8008a72:	2800      	cmp	r0, #0
 8008a74:	d030      	beq.n	8008ad8 <_dtoa_r+0x454>
 8008a76:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 8008a7a:	f8cd b020 	str.w	fp, [sp, #32]
 8008a7e:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 8008a80:	2700      	movs	r7, #0
 8008a82:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8008a84:	43dd      	mvns	r5, r3
 8008a86:	4659      	mov	r1, fp
 8008a88:	4620      	mov	r0, r4
 8008a8a:	f001 faa1 	bl	8009fd0 <_Bfree>
 8008a8e:	9908      	ldr	r1, [sp, #32]
 8008a90:	b171      	cbz	r1, 8008ab0 <_dtoa_r+0x42c>
 8008a92:	1e3b      	subs	r3, r7, #0
 8008a94:	bf18      	it	ne
 8008a96:	2301      	movne	r3, #1
 8008a98:	428f      	cmp	r7, r1
 8008a9a:	bf0c      	ite	eq
 8008a9c:	2300      	moveq	r3, #0
 8008a9e:	f003 0301 	andne.w	r3, r3, #1
 8008aa2:	2b00      	cmp	r3, #0
 8008aa4:	f040 835e 	bne.w	8009164 <_dtoa_r+0xae0>
 8008aa8:	4620      	mov	r0, r4
 8008aaa:	9908      	ldr	r1, [sp, #32]
 8008aac:	f001 fa90 	bl	8009fd0 <_Bfree>
 8008ab0:	4620      	mov	r0, r4
 8008ab2:	4651      	mov	r1, sl
 8008ab4:	f001 fa8c 	bl	8009fd0 <_Bfree>
 8008ab8:	2300      	movs	r3, #0
 8008aba:	7033      	strb	r3, [r6, #0]
 8008abc:	3501      	adds	r5, #1
 8008abe:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 8008ac0:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 8008ac2:	6015      	str	r5, [r2, #0]
 8008ac4:	2b00      	cmp	r3, #0
 8008ac6:	f000 8418 	beq.w	80092fa <_dtoa_r+0xc76>
 8008aca:	601e      	str	r6, [r3, #0]
 8008acc:	980c      	ldr	r0, [sp, #48]	; 0x30
 8008ace:	e61b      	b.n	8008708 <_dtoa_r+0x84>
 8008ad0:	9d18      	ldr	r5, [sp, #96]	; 0x60
 8008ad2:	f8dd a05c 	ldr.w	sl, [sp, #92]	; 0x5c
 8008ad6:	9c08      	ldr	r4, [sp, #32]
 8008ad8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8008adc:	4680      	mov	r8, r0
 8008ade:	4689      	mov	r9, r1
 8008ae0:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8008ae2:	43df      	mvns	r7, r3
 8008ae4:	0fff      	lsrs	r7, r7, #31
 8008ae6:	2d0e      	cmp	r5, #14
 8008ae8:	bfcc      	ite	gt
 8008aea:	2700      	movgt	r7, #0
 8008aec:	f007 0701 	andle.w	r7, r7, #1
 8008af0:	2f00      	cmp	r7, #0
 8008af2:	f000 80c1 	beq.w	8008c78 <_dtoa_r+0x5f4>
 8008af6:	f64c 73d8 	movw	r3, #53208	; 0xcfd8
 8008afa:	9929      	ldr	r1, [sp, #164]	; 0xa4
 8008afc:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008b00:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8008b02:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 8008b06:	0fcf      	lsrs	r7, r1, #31
 8008b08:	e9d3 0100 	ldrd	r0, r1, [r3]
 8008b0c:	2a00      	cmp	r2, #0
 8008b0e:	bfcc      	ite	gt
 8008b10:	2700      	movgt	r7, #0
 8008b12:	f007 0701 	andle.w	r7, r7, #1
 8008b16:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8008b1a:	2f00      	cmp	r7, #0
 8008b1c:	f040 819e 	bne.w	8008e5c <_dtoa_r+0x7d8>
 8008b20:	4602      	mov	r2, r0
 8008b22:	460b      	mov	r3, r1
 8008b24:	4640      	mov	r0, r8
 8008b26:	4649      	mov	r1, r9
 8008b28:	e9cd 8904 	strd	r8, r9, [sp, #16]
 8008b2c:	f003 fba4 	bl	800c278 <__aeabi_ddiv>
 8008b30:	f003 fd12 	bl	800c558 <__aeabi_d2iz>
 8008b34:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8008b36:	4681      	mov	r9, r0
 8008b38:	f7fd faec 	bl	8006114 <__aeabi_i2d>
 8008b3c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8008b40:	f003 fa70 	bl	800c024 <__aeabi_dmul>
 8008b44:	4602      	mov	r2, r0
 8008b46:	460b      	mov	r3, r1
 8008b48:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8008b4c:	f7fd f994 	bl	8005e78 <__aeabi_dsub>
 8008b50:	f109 0330 	add.w	r3, r9, #48	; 0x30
 8008b54:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8008b58:	f806 3b01 	strb.w	r3, [r6], #1
 8008b5c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8008b5e:	2a01      	cmp	r2, #1
 8008b60:	d056      	beq.n	8008c10 <_dtoa_r+0x58c>
 8008b62:	2300      	movs	r3, #0
 8008b64:	2200      	movs	r2, #0
 8008b66:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8008b6a:	f04f 0801 	mov.w	r8, #1
 8008b6e:	f003 fa59 	bl	800c024 <__aeabi_dmul>
 8008b72:	2200      	movs	r2, #0
 8008b74:	2300      	movs	r3, #0
 8008b76:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8008b7a:	f003 fcbb 	bl	800c4f4 <__aeabi_dcmpeq>
 8008b7e:	b100      	cbz	r0, 8008b82 <_dtoa_r+0x4fe>
 8008b80:	46b8      	mov	r8, r7
 8008b82:	f018 0fff 	tst.w	r8, #255	; 0xff
 8008b86:	d093      	beq.n	8008ab0 <_dtoa_r+0x42c>
 8008b88:	990a      	ldr	r1, [sp, #40]	; 0x28
 8008b8a:	4637      	mov	r7, r6
 8008b8c:	980c      	ldr	r0, [sp, #48]	; 0x30
 8008b8e:	46a0      	mov	r8, r4
 8008b90:	9507      	str	r5, [sp, #28]
 8008b92:	eb00 0b01 	add.w	fp, r0, r1
 8008b96:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
 8008b9a:	465d      	mov	r5, fp
 8008b9c:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 8008ba0:	e00d      	b.n	8008bbe <_dtoa_r+0x53a>
 8008ba2:	f003 fa3f 	bl	800c024 <__aeabi_dmul>
 8008ba6:	2200      	movs	r2, #0
 8008ba8:	2300      	movs	r3, #0
 8008baa:	4682      	mov	sl, r0
 8008bac:	468b      	mov	fp, r1
 8008bae:	f003 fca1 	bl	800c4f4 <__aeabi_dcmpeq>
 8008bb2:	b100      	cbz	r0, 8008bb6 <_dtoa_r+0x532>
 8008bb4:	2400      	movs	r4, #0
 8008bb6:	f014 0fff 	tst.w	r4, #255	; 0xff
 8008bba:	f000 840f 	beq.w	80093dc <_dtoa_r+0xd58>
 8008bbe:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8008bc2:	4650      	mov	r0, sl
 8008bc4:	4659      	mov	r1, fp
 8008bc6:	2401      	movs	r4, #1
 8008bc8:	f003 fb56 	bl	800c278 <__aeabi_ddiv>
 8008bcc:	f003 fcc4 	bl	800c558 <__aeabi_d2iz>
 8008bd0:	4681      	mov	r9, r0
 8008bd2:	f7fd fa9f 	bl	8006114 <__aeabi_i2d>
 8008bd6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8008bda:	f109 0630 	add.w	r6, r9, #48	; 0x30
 8008bde:	f003 fa21 	bl	800c024 <__aeabi_dmul>
 8008be2:	4602      	mov	r2, r0
 8008be4:	460b      	mov	r3, r1
 8008be6:	4650      	mov	r0, sl
 8008be8:	4659      	mov	r1, fp
 8008bea:	f7fd f945 	bl	8005e78 <__aeabi_dsub>
 8008bee:	2300      	movs	r3, #0
 8008bf0:	f807 6b01 	strb.w	r6, [r7], #1
 8008bf4:	2200      	movs	r2, #0
 8008bf6:	42af      	cmp	r7, r5
 8008bf8:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8008bfc:	463e      	mov	r6, r7
 8008bfe:	4682      	mov	sl, r0
 8008c00:	468b      	mov	fp, r1
 8008c02:	d1ce      	bne.n	8008ba2 <_dtoa_r+0x51e>
 8008c04:	e9cd ab04 	strd	sl, fp, [sp, #16]
 8008c08:	4644      	mov	r4, r8
 8008c0a:	9d07      	ldr	r5, [sp, #28]
 8008c0c:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 8008c10:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8008c14:	4602      	mov	r2, r0
 8008c16:	460b      	mov	r3, r1
 8008c18:	f7fd f930 	bl	8005e7c <__adddf3>
 8008c1c:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8008c20:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8008c24:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8008c28:	f003 fc6e 	bl	800c508 <__aeabi_dcmplt>
 8008c2c:	b960      	cbnz	r0, 8008c48 <_dtoa_r+0x5c4>
 8008c2e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8008c32:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8008c36:	f003 fc5d 	bl	800c4f4 <__aeabi_dcmpeq>
 8008c3a:	2800      	cmp	r0, #0
 8008c3c:	f43f af38 	beq.w	8008ab0 <_dtoa_r+0x42c>
 8008c40:	f019 0f01 	tst.w	r9, #1
 8008c44:	f43f af34 	beq.w	8008ab0 <_dtoa_r+0x42c>
 8008c48:	9512      	str	r5, [sp, #72]	; 0x48
 8008c4a:	980c      	ldr	r0, [sp, #48]	; 0x30
 8008c4c:	4633      	mov	r3, r6
 8008c4e:	f813 1c01 	ldrb.w	r1, [r3, #-1]
 8008c52:	1e5a      	subs	r2, r3, #1
 8008c54:	461e      	mov	r6, r3
 8008c56:	4613      	mov	r3, r2
 8008c58:	2939      	cmp	r1, #57	; 0x39
 8008c5a:	f040 83e1 	bne.w	8009420 <_dtoa_r+0xd9c>
 8008c5e:	4283      	cmp	r3, r0
 8008c60:	d1f5      	bne.n	8008c4e <_dtoa_r+0x5ca>
 8008c62:	980c      	ldr	r0, [sp, #48]	; 0x30
 8008c64:	2131      	movs	r1, #49	; 0x31
 8008c66:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8008c68:	1c5d      	adds	r5, r3, #1
 8008c6a:	2330      	movs	r3, #48	; 0x30
 8008c6c:	7003      	strb	r3, [r0, #0]
 8008c6e:	7011      	strb	r1, [r2, #0]
 8008c70:	e71e      	b.n	8008ab0 <_dtoa_r+0x42c>
 8008c72:	2101      	movs	r1, #1
 8008c74:	9115      	str	r1, [sp, #84]	; 0x54
 8008c76:	e5b9      	b.n	80087ec <_dtoa_r+0x168>
 8008c78:	9910      	ldr	r1, [sp, #64]	; 0x40
 8008c7a:	2900      	cmp	r1, #0
 8008c7c:	f040 80c7 	bne.w	8008e0e <_dtoa_r+0x78a>
 8008c80:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8008c82:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 8008c84:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 8008c86:	9308      	str	r3, [sp, #32]
 8008c88:	2e00      	cmp	r6, #0
 8008c8a:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8008c8c:	bfd4      	ite	le
 8008c8e:	2300      	movle	r3, #0
 8008c90:	2301      	movgt	r3, #1
 8008c92:	2800      	cmp	r0, #0
 8008c94:	bfd4      	ite	le
 8008c96:	2300      	movle	r3, #0
 8008c98:	f003 0301 	andgt.w	r3, r3, #1
 8008c9c:	b14b      	cbz	r3, 8008cb2 <_dtoa_r+0x62e>
 8008c9e:	4603      	mov	r3, r0
 8008ca0:	990d      	ldr	r1, [sp, #52]	; 0x34
 8008ca2:	42b3      	cmp	r3, r6
 8008ca4:	bfa8      	it	ge
 8008ca6:	4633      	movge	r3, r6
 8008ca8:	1af6      	subs	r6, r6, r3
 8008caa:	1ac9      	subs	r1, r1, r3
 8008cac:	1ac0      	subs	r0, r0, r3
 8008cae:	910d      	str	r1, [sp, #52]	; 0x34
 8008cb0:	900b      	str	r0, [sp, #44]	; 0x2c
 8008cb2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8008cb4:	2a00      	cmp	r2, #0
 8008cb6:	dd1a      	ble.n	8008cee <_dtoa_r+0x66a>
 8008cb8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8008cba:	2b00      	cmp	r3, #0
 8008cbc:	f000 8394 	beq.w	80093e8 <_dtoa_r+0xd64>
 8008cc0:	2f00      	cmp	r7, #0
 8008cc2:	dd10      	ble.n	8008ce6 <_dtoa_r+0x662>
 8008cc4:	9908      	ldr	r1, [sp, #32]
 8008cc6:	463a      	mov	r2, r7
 8008cc8:	4620      	mov	r0, r4
 8008cca:	f001 fb1b 	bl	800a304 <__pow5mult>
 8008cce:	4652      	mov	r2, sl
 8008cd0:	9008      	str	r0, [sp, #32]
 8008cd2:	4620      	mov	r0, r4
 8008cd4:	9908      	ldr	r1, [sp, #32]
 8008cd6:	f001 fa81 	bl	800a1dc <__multiply>
 8008cda:	4651      	mov	r1, sl
 8008cdc:	4683      	mov	fp, r0
 8008cde:	4620      	mov	r0, r4
 8008ce0:	f001 f976 	bl	8009fd0 <_Bfree>
 8008ce4:	46da      	mov	sl, fp
 8008ce6:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8008ce8:	1bc2      	subs	r2, r0, r7
 8008cea:	f040 8384 	bne.w	80093f6 <_dtoa_r+0xd72>
 8008cee:	2101      	movs	r1, #1
 8008cf0:	4620      	mov	r0, r4
 8008cf2:	f001 fa69 	bl	800a1c8 <__i2b>
 8008cf6:	9911      	ldr	r1, [sp, #68]	; 0x44
 8008cf8:	2900      	cmp	r1, #0
 8008cfa:	4683      	mov	fp, r0
 8008cfc:	dd05      	ble.n	8008d0a <_dtoa_r+0x686>
 8008cfe:	4659      	mov	r1, fp
 8008d00:	4620      	mov	r0, r4
 8008d02:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8008d04:	f001 fafe 	bl	800a304 <__pow5mult>
 8008d08:	4683      	mov	fp, r0
 8008d0a:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8008d0c:	2a01      	cmp	r2, #1
 8008d0e:	f340 819e 	ble.w	800904e <_dtoa_r+0x9ca>
 8008d12:	2700      	movs	r7, #0
 8008d14:	9911      	ldr	r1, [sp, #68]	; 0x44
 8008d16:	2900      	cmp	r1, #0
 8008d18:	f040 82f2 	bne.w	8009300 <_dtoa_r+0xc7c>
 8008d1c:	2301      	movs	r3, #1
 8008d1e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8008d20:	189b      	adds	r3, r3, r2
 8008d22:	f013 031f 	ands.w	r3, r3, #31
 8008d26:	f000 8222 	beq.w	800916e <_dtoa_r+0xaea>
 8008d2a:	f1c3 0320 	rsb	r3, r3, #32
 8008d2e:	2b04      	cmp	r3, #4
 8008d30:	f340 83f6 	ble.w	8009520 <_dtoa_r+0xe9c>
 8008d34:	3b04      	subs	r3, #4
 8008d36:	980d      	ldr	r0, [sp, #52]	; 0x34
 8008d38:	18f6      	adds	r6, r6, r3
 8008d3a:	18d2      	adds	r2, r2, r3
 8008d3c:	18c0      	adds	r0, r0, r3
 8008d3e:	920b      	str	r2, [sp, #44]	; 0x2c
 8008d40:	900d      	str	r0, [sp, #52]	; 0x34
 8008d42:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008d44:	2b00      	cmp	r3, #0
 8008d46:	dd05      	ble.n	8008d54 <_dtoa_r+0x6d0>
 8008d48:	4651      	mov	r1, sl
 8008d4a:	4620      	mov	r0, r4
 8008d4c:	461a      	mov	r2, r3
 8008d4e:	f001 fb2b 	bl	800a3a8 <__lshift>
 8008d52:	4682      	mov	sl, r0
 8008d54:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8008d56:	2800      	cmp	r0, #0
 8008d58:	dd05      	ble.n	8008d66 <_dtoa_r+0x6e2>
 8008d5a:	4659      	mov	r1, fp
 8008d5c:	4620      	mov	r0, r4
 8008d5e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8008d60:	f001 fb22 	bl	800a3a8 <__lshift>
 8008d64:	4683      	mov	fp, r0
 8008d66:	9915      	ldr	r1, [sp, #84]	; 0x54
 8008d68:	2900      	cmp	r1, #0
 8008d6a:	f040 82d3 	bne.w	8009314 <_dtoa_r+0xc90>
 8008d6e:	9928      	ldr	r1, [sp, #160]	; 0xa0
 8008d70:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8008d72:	2902      	cmp	r1, #2
 8008d74:	bfd4      	ite	le
 8008d76:	2300      	movle	r3, #0
 8008d78:	2301      	movgt	r3, #1
 8008d7a:	2a00      	cmp	r2, #0
 8008d7c:	bfcc      	ite	gt
 8008d7e:	2300      	movgt	r3, #0
 8008d80:	f003 0301 	andle.w	r3, r3, #1
 8008d84:	2b00      	cmp	r3, #0
 8008d86:	f000 817c 	beq.w	8009082 <_dtoa_r+0x9fe>
 8008d8a:	2a00      	cmp	r2, #0
 8008d8c:	f47f ae77 	bne.w	8008a7e <_dtoa_r+0x3fa>
 8008d90:	4659      	mov	r1, fp
 8008d92:	2205      	movs	r2, #5
 8008d94:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008d96:	4620      	mov	r0, r4
 8008d98:	f001 f936 	bl	800a008 <__multadd>
 8008d9c:	4683      	mov	fp, r0
 8008d9e:	4650      	mov	r0, sl
 8008da0:	4659      	mov	r1, fp
 8008da2:	f001 fb57 	bl	800a454 <__mcmp>
 8008da6:	2800      	cmp	r0, #0
 8008da8:	f77f ae69 	ble.w	8008a7e <_dtoa_r+0x3fa>
 8008dac:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8008dae:	2331      	movs	r3, #49	; 0x31
 8008db0:	3501      	adds	r5, #1
 8008db2:	2700      	movs	r7, #0
 8008db4:	f806 3b01 	strb.w	r3, [r6], #1
 8008db8:	e665      	b.n	8008a86 <_dtoa_r+0x402>
 8008dba:	2010      	movs	r0, #16
 8008dbc:	f7fd fb88 	bl	80064d0 <malloc>
 8008dc0:	6260      	str	r0, [r4, #36]	; 0x24
 8008dc2:	6045      	str	r5, [r0, #4]
 8008dc4:	6085      	str	r5, [r0, #8]
 8008dc6:	6005      	str	r5, [r0, #0]
 8008dc8:	60c5      	str	r5, [r0, #12]
 8008dca:	e473      	b.n	80086b4 <_dtoa_r+0x30>
 8008dcc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008dce:	4268      	negs	r0, r5
 8008dd0:	2100      	movs	r1, #0
 8008dd2:	900f      	str	r0, [sp, #60]	; 0x3c
 8008dd4:	1b5b      	subs	r3, r3, r5
 8008dd6:	9111      	str	r1, [sp, #68]	; 0x44
 8008dd8:	930d      	str	r3, [sp, #52]	; 0x34
 8008dda:	e517      	b.n	800880c <_dtoa_r+0x188>
 8008ddc:	4276      	negs	r6, r6
 8008dde:	2300      	movs	r3, #0
 8008de0:	960d      	str	r6, [sp, #52]	; 0x34
 8008de2:	930b      	str	r3, [sp, #44]	; 0x2c
 8008de4:	e509      	b.n	80087fa <_dtoa_r+0x176>
 8008de6:	2200      	movs	r2, #0
 8008de8:	9215      	str	r2, [sp, #84]	; 0x54
 8008dea:	e4ff      	b.n	80087ec <_dtoa_r+0x168>
 8008dec:	f24d 03a0 	movw	r3, #53408	; 0xd0a0
 8008df0:	4640      	mov	r0, r8
 8008df2:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008df6:	4649      	mov	r1, r9
 8008df8:	f006 060f 	and.w	r6, r6, #15
 8008dfc:	f04f 0803 	mov.w	r8, #3
 8008e00:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8008e04:	f003 fa38 	bl	800c278 <__aeabi_ddiv>
 8008e08:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8008e0c:	e5a7      	b.n	800895e <_dtoa_r+0x2da>
 8008e0e:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8008e10:	2a01      	cmp	r2, #1
 8008e12:	f340 82f6 	ble.w	8009402 <_dtoa_r+0xd7e>
 8008e16:	990a      	ldr	r1, [sp, #40]	; 0x28
 8008e18:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8008e1a:	1e4b      	subs	r3, r1, #1
 8008e1c:	429a      	cmp	r2, r3
 8008e1e:	bfa8      	it	ge
 8008e20:	ebc3 0702 	rsbge	r7, r3, r2
 8008e24:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8008e26:	bfbf      	itttt	lt
 8008e28:	980f      	ldrlt	r0, [sp, #60]	; 0x3c
 8008e2a:	9911      	ldrlt	r1, [sp, #68]	; 0x44
 8008e2c:	ebc0 0303 	rsblt	r3, r0, r3
 8008e30:	18c9      	addlt	r1, r1, r3
 8008e32:	bfbe      	ittt	lt
 8008e34:	18c0      	addlt	r0, r0, r3
 8008e36:	9111      	strlt	r1, [sp, #68]	; 0x44
 8008e38:	900f      	strlt	r0, [sp, #60]	; 0x3c
 8008e3a:	2a00      	cmp	r2, #0
 8008e3c:	f2c0 82f9 	blt.w	8009432 <_dtoa_r+0xdae>
 8008e40:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 8008e42:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008e44:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8008e46:	4620      	mov	r0, r4
 8008e48:	2101      	movs	r1, #1
 8008e4a:	18d2      	adds	r2, r2, r3
 8008e4c:	920d      	str	r2, [sp, #52]	; 0x34
 8008e4e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8008e50:	18d2      	adds	r2, r2, r3
 8008e52:	920b      	str	r2, [sp, #44]	; 0x2c
 8008e54:	f001 f9b8 	bl	800a1c8 <__i2b>
 8008e58:	9008      	str	r0, [sp, #32]
 8008e5a:	e715      	b.n	8008c88 <_dtoa_r+0x604>
 8008e5c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008e5e:	2b00      	cmp	r3, #0
 8008e60:	f040 82d8 	bne.w	8009414 <_dtoa_r+0xd90>
 8008e64:	2300      	movs	r3, #0
 8008e66:	2200      	movs	r2, #0
 8008e68:	f2c4 0314 	movt	r3, #16404	; 0x4014
 8008e6c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8008e70:	f003 f8d8 	bl	800c024 <__aeabi_dmul>
 8008e74:	4642      	mov	r2, r8
 8008e76:	464b      	mov	r3, r9
 8008e78:	f003 fb5a 	bl	800c530 <__aeabi_dcmpge>
 8008e7c:	2800      	cmp	r0, #0
 8008e7e:	f47f adfa 	bne.w	8008a76 <_dtoa_r+0x3f2>
 8008e82:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 8008e86:	f8cd b020 	str.w	fp, [sp, #32]
 8008e8a:	e78f      	b.n	8008dac <_dtoa_r+0x728>
 8008e8c:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 8008e90:	9512      	str	r5, [sp, #72]	; 0x48
 8008e92:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8008e94:	2b00      	cmp	r3, #0
 8008e96:	f000 81af 	beq.w	80091f8 <_dtoa_r+0xb74>
 8008e9a:	f64c 73d8 	movw	r3, #53208	; 0xcfd8
 8008e9e:	2100      	movs	r1, #0
 8008ea0:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008ea4:	2000      	movs	r0, #0
 8008ea6:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 8008eaa:	f6c3 71e0 	movt	r1, #16352	; 0x3fe0
 8008eae:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8008eb0:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 8008eb4:	f003 f9e0 	bl	800c278 <__aeabi_ddiv>
 8008eb8:	4642      	mov	r2, r8
 8008eba:	464b      	mov	r3, r9
 8008ebc:	f7fc ffdc 	bl	8005e78 <__aeabi_dsub>
 8008ec0:	4680      	mov	r8, r0
 8008ec2:	4689      	mov	r9, r1
 8008ec4:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8008ec8:	f003 fb46 	bl	800c558 <__aeabi_d2iz>
 8008ecc:	4607      	mov	r7, r0
 8008ece:	f7fd f921 	bl	8006114 <__aeabi_i2d>
 8008ed2:	4602      	mov	r2, r0
 8008ed4:	460b      	mov	r3, r1
 8008ed6:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8008eda:	f7fc ffcd 	bl	8005e78 <__aeabi_dsub>
 8008ede:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8008ee2:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8008ee6:	4640      	mov	r0, r8
 8008ee8:	f806 3b01 	strb.w	r3, [r6], #1
 8008eec:	4649      	mov	r1, r9
 8008eee:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8008ef2:	f003 fb27 	bl	800c544 <__aeabi_dcmpgt>
 8008ef6:	2800      	cmp	r0, #0
 8008ef8:	f040 81fc 	bne.w	80092f4 <_dtoa_r+0xc70>
 8008efc:	2100      	movs	r1, #0
 8008efe:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8008f02:	2000      	movs	r0, #0
 8008f04:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
 8008f08:	f7fc ffb6 	bl	8005e78 <__aeabi_dsub>
 8008f0c:	4602      	mov	r2, r0
 8008f0e:	460b      	mov	r3, r1
 8008f10:	4640      	mov	r0, r8
 8008f12:	4649      	mov	r1, r9
 8008f14:	f003 fb16 	bl	800c544 <__aeabi_dcmpgt>
 8008f18:	2800      	cmp	r0, #0
 8008f1a:	f47f ae96 	bne.w	8008c4a <_dtoa_r+0x5c6>
 8008f1e:	f1bb 0f01 	cmp.w	fp, #1
 8008f22:	f77f add9 	ble.w	8008ad8 <_dtoa_r+0x454>
 8008f26:	980c      	ldr	r0, [sp, #48]	; 0x30
 8008f28:	4637      	mov	r7, r6
 8008f2a:	9518      	str	r5, [sp, #96]	; 0x60
 8008f2c:	4483      	add	fp, r0
 8008f2e:	f8cd a05c 	str.w	sl, [sp, #92]	; 0x5c
 8008f32:	465d      	mov	r5, fp
 8008f34:	e9dd ab08 	ldrd	sl, fp, [sp, #32]
 8008f38:	9408      	str	r4, [sp, #32]
 8008f3a:	e00f      	b.n	8008f5c <_dtoa_r+0x8d8>
 8008f3c:	2100      	movs	r1, #0
 8008f3e:	2000      	movs	r0, #0
 8008f40:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
 8008f44:	f7fc ff98 	bl	8005e78 <__aeabi_dsub>
 8008f48:	4642      	mov	r2, r8
 8008f4a:	464b      	mov	r3, r9
 8008f4c:	f003 fadc 	bl	800c508 <__aeabi_dcmplt>
 8008f50:	2800      	cmp	r0, #0
 8008f52:	f040 826a 	bne.w	800942a <_dtoa_r+0xda6>
 8008f56:	42af      	cmp	r7, r5
 8008f58:	f43f adba 	beq.w	8008ad0 <_dtoa_r+0x44c>
 8008f5c:	2300      	movs	r3, #0
 8008f5e:	2200      	movs	r2, #0
 8008f60:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8008f64:	4640      	mov	r0, r8
 8008f66:	4649      	mov	r1, r9
 8008f68:	f003 f85c 	bl	800c024 <__aeabi_dmul>
 8008f6c:	2300      	movs	r3, #0
 8008f6e:	2200      	movs	r2, #0
 8008f70:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8008f74:	4680      	mov	r8, r0
 8008f76:	4689      	mov	r9, r1
 8008f78:	4650      	mov	r0, sl
 8008f7a:	4659      	mov	r1, fp
 8008f7c:	f003 f852 	bl	800c024 <__aeabi_dmul>
 8008f80:	468b      	mov	fp, r1
 8008f82:	4682      	mov	sl, r0
 8008f84:	f003 fae8 	bl	800c558 <__aeabi_d2iz>
 8008f88:	4604      	mov	r4, r0
 8008f8a:	f7fd f8c3 	bl	8006114 <__aeabi_i2d>
 8008f8e:	3430      	adds	r4, #48	; 0x30
 8008f90:	4602      	mov	r2, r0
 8008f92:	460b      	mov	r3, r1
 8008f94:	4650      	mov	r0, sl
 8008f96:	4659      	mov	r1, fp
 8008f98:	f7fc ff6e 	bl	8005e78 <__aeabi_dsub>
 8008f9c:	4642      	mov	r2, r8
 8008f9e:	464b      	mov	r3, r9
 8008fa0:	f807 4b01 	strb.w	r4, [r7], #1
 8008fa4:	463e      	mov	r6, r7
 8008fa6:	4682      	mov	sl, r0
 8008fa8:	468b      	mov	fp, r1
 8008faa:	f003 faad 	bl	800c508 <__aeabi_dcmplt>
 8008fae:	4652      	mov	r2, sl
 8008fb0:	465b      	mov	r3, fp
 8008fb2:	2800      	cmp	r0, #0
 8008fb4:	d0c2      	beq.n	8008f3c <_dtoa_r+0x8b8>
 8008fb6:	f8dd a05c 	ldr.w	sl, [sp, #92]	; 0x5c
 8008fba:	9c08      	ldr	r4, [sp, #32]
 8008fbc:	9d12      	ldr	r5, [sp, #72]	; 0x48
 8008fbe:	e577      	b.n	8008ab0 <_dtoa_r+0x42c>
 8008fc0:	2600      	movs	r6, #0
 8008fc2:	e4fc      	b.n	80089be <_dtoa_r+0x33a>
 8008fc4:	2301      	movs	r3, #1
 8008fc6:	9310      	str	r3, [sp, #64]	; 0x40
 8008fc8:	9929      	ldr	r1, [sp, #164]	; 0xa4
 8008fca:	2900      	cmp	r1, #0
 8008fcc:	bfc2      	ittt	gt
 8008fce:	468b      	movgt	fp, r1
 8008fd0:	910e      	strgt	r1, [sp, #56]	; 0x38
 8008fd2:	910a      	strgt	r1, [sp, #40]	; 0x28
 8008fd4:	f340 81b4 	ble.w	8009340 <_dtoa_r+0xcbc>
 8008fd8:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8008fda:	2200      	movs	r2, #0
 8008fdc:	f1bb 0f17 	cmp.w	fp, #23
 8008fe0:	6072      	str	r2, [r6, #4]
 8008fe2:	f240 82a1 	bls.w	8009528 <_dtoa_r+0xea4>
 8008fe6:	2304      	movs	r3, #4
 8008fe8:	005b      	lsls	r3, r3, #1
 8008fea:	3201      	adds	r2, #1
 8008fec:	f103 0114 	add.w	r1, r3, #20
 8008ff0:	4559      	cmp	r1, fp
 8008ff2:	d9f9      	bls.n	8008fe8 <_dtoa_r+0x964>
 8008ff4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008ff6:	6072      	str	r2, [r6, #4]
 8008ff8:	2b0e      	cmp	r3, #14
 8008ffa:	bf8c      	ite	hi
 8008ffc:	2700      	movhi	r7, #0
 8008ffe:	f007 0701 	andls.w	r7, r7, #1
 8009002:	e484      	b.n	800890e <_dtoa_r+0x28a>
 8009004:	2300      	movs	r3, #0
 8009006:	9310      	str	r3, [sp, #64]	; 0x40
 8009008:	9829      	ldr	r0, [sp, #164]	; 0xa4
 800900a:	1828      	adds	r0, r5, r0
 800900c:	900e      	str	r0, [sp, #56]	; 0x38
 800900e:	f100 0b01 	add.w	fp, r0, #1
 8009012:	f1bb 0f00 	cmp.w	fp, #0
 8009016:	bfc8      	it	gt
 8009018:	f8cd b028 	strgt.w	fp, [sp, #40]	; 0x28
 800901c:	dcdc      	bgt.n	8008fd8 <_dtoa_r+0x954>
 800901e:	f1bb 0f0e 	cmp.w	fp, #14
 8009022:	bf8c      	ite	hi
 8009024:	2700      	movhi	r7, #0
 8009026:	f007 0701 	andls.w	r7, r7, #1
 800902a:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
 800902e:	e46b      	b.n	8008908 <_dtoa_r+0x284>
 8009030:	2000      	movs	r0, #0
 8009032:	9010      	str	r0, [sp, #64]	; 0x40
 8009034:	e7c8      	b.n	8008fc8 <_dtoa_r+0x944>
 8009036:	2201      	movs	r2, #1
 8009038:	9210      	str	r2, [sp, #64]	; 0x40
 800903a:	e7e5      	b.n	8009008 <_dtoa_r+0x984>
 800903c:	f04f 33ff 	mov.w	r3, #4294967295
 8009040:	2700      	movs	r7, #0
 8009042:	2001      	movs	r0, #1
 8009044:	930e      	str	r3, [sp, #56]	; 0x38
 8009046:	9010      	str	r0, [sp, #64]	; 0x40
 8009048:	930a      	str	r3, [sp, #40]	; 0x28
 800904a:	9729      	str	r7, [sp, #164]	; 0xa4
 800904c:	e45c      	b.n	8008908 <_dtoa_r+0x284>
 800904e:	f1b8 0f00 	cmp.w	r8, #0
 8009052:	f47f ae5e 	bne.w	8008d12 <_dtoa_r+0x68e>
 8009056:	f3c9 0313 	ubfx	r3, r9, #0, #20
 800905a:	4647      	mov	r7, r8
 800905c:	2b00      	cmp	r3, #0
 800905e:	f47f ae59 	bne.w	8008d14 <_dtoa_r+0x690>
 8009062:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 8009066:	ea09 0303 	and.w	r3, r9, r3
 800906a:	461f      	mov	r7, r3
 800906c:	2b00      	cmp	r3, #0
 800906e:	f43f ae51 	beq.w	8008d14 <_dtoa_r+0x690>
 8009072:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8009074:	2701      	movs	r7, #1
 8009076:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8009078:	3301      	adds	r3, #1
 800907a:	930d      	str	r3, [sp, #52]	; 0x34
 800907c:	3001      	adds	r0, #1
 800907e:	900b      	str	r0, [sp, #44]	; 0x2c
 8009080:	e648      	b.n	8008d14 <_dtoa_r+0x690>
 8009082:	9810      	ldr	r0, [sp, #64]	; 0x40
 8009084:	2800      	cmp	r0, #0
 8009086:	f000 8161 	beq.w	800934c <_dtoa_r+0xcc8>
 800908a:	2e00      	cmp	r6, #0
 800908c:	dd05      	ble.n	800909a <_dtoa_r+0xa16>
 800908e:	4620      	mov	r0, r4
 8009090:	9908      	ldr	r1, [sp, #32]
 8009092:	4632      	mov	r2, r6
 8009094:	f001 f988 	bl	800a3a8 <__lshift>
 8009098:	9008      	str	r0, [sp, #32]
 800909a:	2f00      	cmp	r7, #0
 800909c:	f040 81ed 	bne.w	800947a <_dtoa_r+0xdf6>
 80090a0:	9808      	ldr	r0, [sp, #32]
 80090a2:	9002      	str	r0, [sp, #8]
 80090a4:	990a      	ldr	r1, [sp, #40]	; 0x28
 80090a6:	f008 0201 	and.w	r2, r8, #1
 80090aa:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 80090ac:	9f08      	ldr	r7, [sp, #32]
 80090ae:	1871      	adds	r1, r6, r1
 80090b0:	920a      	str	r2, [sp, #40]	; 0x28
 80090b2:	910b      	str	r1, [sp, #44]	; 0x2c
 80090b4:	9508      	str	r5, [sp, #32]
 80090b6:	4659      	mov	r1, fp
 80090b8:	4650      	mov	r0, sl
 80090ba:	f7ff fa4d 	bl	8008558 <quorem>
 80090be:	4639      	mov	r1, r7
 80090c0:	f04f 0901 	mov.w	r9, #1
 80090c4:	3030      	adds	r0, #48	; 0x30
 80090c6:	9007      	str	r0, [sp, #28]
 80090c8:	4650      	mov	r0, sl
 80090ca:	f001 f9c3 	bl	800a454 <__mcmp>
 80090ce:	4659      	mov	r1, fp
 80090d0:	9a02      	ldr	r2, [sp, #8]
 80090d2:	4605      	mov	r5, r0
 80090d4:	4620      	mov	r0, r4
 80090d6:	f001 f9db 	bl	800a490 <__mdiff>
 80090da:	68c3      	ldr	r3, [r0, #12]
 80090dc:	4680      	mov	r8, r0
 80090de:	2b00      	cmp	r3, #0
 80090e0:	d03a      	beq.n	8009158 <_dtoa_r+0xad4>
 80090e2:	4620      	mov	r0, r4
 80090e4:	4641      	mov	r1, r8
 80090e6:	f000 ff73 	bl	8009fd0 <_Bfree>
 80090ea:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 80090ec:	ea59 0303 	orrs.w	r3, r9, r3
 80090f0:	d103      	bne.n	80090fa <_dtoa_r+0xa76>
 80090f2:	980a      	ldr	r0, [sp, #40]	; 0x28
 80090f4:	2800      	cmp	r0, #0
 80090f6:	f000 81f3 	beq.w	80094e0 <_dtoa_r+0xe5c>
 80090fa:	2d00      	cmp	r5, #0
 80090fc:	f2c0 819d 	blt.w	800943a <_dtoa_r+0xdb6>
 8009100:	9828      	ldr	r0, [sp, #160]	; 0xa0
 8009102:	4328      	orrs	r0, r5
 8009104:	d103      	bne.n	800910e <_dtoa_r+0xa8a>
 8009106:	990a      	ldr	r1, [sp, #40]	; 0x28
 8009108:	2900      	cmp	r1, #0
 800910a:	f000 8196 	beq.w	800943a <_dtoa_r+0xdb6>
 800910e:	f1b9 0f00 	cmp.w	r9, #0
 8009112:	f300 81d2 	bgt.w	80094ba <_dtoa_r+0xe36>
 8009116:	9a07      	ldr	r2, [sp, #28]
 8009118:	f806 2b01 	strb.w	r2, [r6], #1
 800911c:	46b0      	mov	r8, r6
 800911e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8009120:	429e      	cmp	r6, r3
 8009122:	f000 81c6 	beq.w	80094b2 <_dtoa_r+0xe2e>
 8009126:	4651      	mov	r1, sl
 8009128:	220a      	movs	r2, #10
 800912a:	2300      	movs	r3, #0
 800912c:	4620      	mov	r0, r4
 800912e:	f000 ff6b 	bl	800a008 <__multadd>
 8009132:	4682      	mov	sl, r0
 8009134:	9802      	ldr	r0, [sp, #8]
 8009136:	4287      	cmp	r7, r0
 8009138:	d022      	beq.n	8009180 <_dtoa_r+0xafc>
 800913a:	4639      	mov	r1, r7
 800913c:	220a      	movs	r2, #10
 800913e:	2300      	movs	r3, #0
 8009140:	4620      	mov	r0, r4
 8009142:	f000 ff61 	bl	800a008 <__multadd>
 8009146:	9902      	ldr	r1, [sp, #8]
 8009148:	220a      	movs	r2, #10
 800914a:	2300      	movs	r3, #0
 800914c:	4607      	mov	r7, r0
 800914e:	4620      	mov	r0, r4
 8009150:	f000 ff5a 	bl	800a008 <__multadd>
 8009154:	9002      	str	r0, [sp, #8]
 8009156:	e7ae      	b.n	80090b6 <_dtoa_r+0xa32>
 8009158:	4650      	mov	r0, sl
 800915a:	4641      	mov	r1, r8
 800915c:	f001 f97a 	bl	800a454 <__mcmp>
 8009160:	4681      	mov	r9, r0
 8009162:	e7be      	b.n	80090e2 <_dtoa_r+0xa5e>
 8009164:	4620      	mov	r0, r4
 8009166:	4639      	mov	r1, r7
 8009168:	f000 ff32 	bl	8009fd0 <_Bfree>
 800916c:	e49c      	b.n	8008aa8 <_dtoa_r+0x424>
 800916e:	231c      	movs	r3, #28
 8009170:	990d      	ldr	r1, [sp, #52]	; 0x34
 8009172:	18f6      	adds	r6, r6, r3
 8009174:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8009176:	18c9      	adds	r1, r1, r3
 8009178:	910d      	str	r1, [sp, #52]	; 0x34
 800917a:	18d2      	adds	r2, r2, r3
 800917c:	920b      	str	r2, [sp, #44]	; 0x2c
 800917e:	e5e0      	b.n	8008d42 <_dtoa_r+0x6be>
 8009180:	4639      	mov	r1, r7
 8009182:	4620      	mov	r0, r4
 8009184:	220a      	movs	r2, #10
 8009186:	2300      	movs	r3, #0
 8009188:	f000 ff3e 	bl	800a008 <__multadd>
 800918c:	4607      	mov	r7, r0
 800918e:	9002      	str	r0, [sp, #8]
 8009190:	e791      	b.n	80090b6 <_dtoa_r+0xa32>
 8009192:	426e      	negs	r6, r5
 8009194:	2e00      	cmp	r6, #0
 8009196:	f000 811d 	beq.w	80093d4 <_dtoa_r+0xd50>
 800919a:	f006 030f 	and.w	r3, r6, #15
 800919e:	f64c 72d8 	movw	r2, #53208	; 0xcfd8
 80091a2:	f6c0 0200 	movt	r2, #2048	; 0x800
 80091a6:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80091aa:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80091ae:	e9d3 2300 	ldrd	r2, r3, [r3]
 80091b2:	f002 ff37 	bl	800c024 <__aeabi_dmul>
 80091b6:	1136      	asrs	r6, r6, #4
 80091b8:	e9cd 0108 	strd	r0, r1, [sp, #32]
 80091bc:	f000 810a 	beq.w	80093d4 <_dtoa_r+0xd50>
 80091c0:	f24d 07a0 	movw	r7, #53408	; 0xd0a0
 80091c4:	f04f 0802 	mov.w	r8, #2
 80091c8:	f6c0 0700 	movt	r7, #2048	; 0x800
 80091cc:	4602      	mov	r2, r0
 80091ce:	460b      	mov	r3, r1
 80091d0:	f016 0f01 	tst.w	r6, #1
 80091d4:	4610      	mov	r0, r2
 80091d6:	4619      	mov	r1, r3
 80091d8:	d007      	beq.n	80091ea <_dtoa_r+0xb66>
 80091da:	e9d7 2300 	ldrd	r2, r3, [r7]
 80091de:	f108 0801 	add.w	r8, r8, #1
 80091e2:	f002 ff1f 	bl	800c024 <__aeabi_dmul>
 80091e6:	4602      	mov	r2, r0
 80091e8:	460b      	mov	r3, r1
 80091ea:	3708      	adds	r7, #8
 80091ec:	1076      	asrs	r6, r6, #1
 80091ee:	d1ef      	bne.n	80091d0 <_dtoa_r+0xb4c>
 80091f0:	e9cd 2308 	strd	r2, r3, [sp, #32]
 80091f4:	f7ff bbd4 	b.w	80089a0 <_dtoa_r+0x31c>
 80091f8:	f10b 32ff 	add.w	r2, fp, #4294967295
 80091fc:	9217      	str	r2, [sp, #92]	; 0x5c
 80091fe:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8009200:	f64c 71d8 	movw	r1, #53208	; 0xcfd8
 8009204:	f6c0 0100 	movt	r1, #2048	; 0x800
 8009208:	4642      	mov	r2, r8
 800920a:	464b      	mov	r3, r9
 800920c:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 800920e:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 8009212:	e9d1 0100 	ldrd	r0, r1, [r1]
 8009216:	f002 ff05 	bl	800c024 <__aeabi_dmul>
 800921a:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
 800921e:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8009222:	f003 f999 	bl	800c558 <__aeabi_d2iz>
 8009226:	4607      	mov	r7, r0
 8009228:	f7fc ff74 	bl	8006114 <__aeabi_i2d>
 800922c:	460b      	mov	r3, r1
 800922e:	4602      	mov	r2, r0
 8009230:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8009234:	f7fc fe20 	bl	8005e78 <__aeabi_dsub>
 8009238:	f1bb 0f01 	cmp.w	fp, #1
 800923c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8009240:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8009244:	f806 3b01 	strb.w	r3, [r6], #1
 8009248:	d02b      	beq.n	80092a2 <_dtoa_r+0xc1e>
 800924a:	990c      	ldr	r1, [sp, #48]	; 0x30
 800924c:	951b      	str	r5, [sp, #108]	; 0x6c
 800924e:	f101 39ff 	add.w	r9, r1, #4294967295
 8009252:	460f      	mov	r7, r1
 8009254:	44d9      	add	r9, fp
 8009256:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800925a:	46d3      	mov	fp, sl
 800925c:	464d      	mov	r5, r9
 800925e:	46b2      	mov	sl, r6
 8009260:	4626      	mov	r6, r4
 8009262:	2300      	movs	r3, #0
 8009264:	2200      	movs	r2, #0
 8009266:	f2c4 0324 	movt	r3, #16420	; 0x4024
 800926a:	f002 fedb 	bl	800c024 <__aeabi_dmul>
 800926e:	4689      	mov	r9, r1
 8009270:	4680      	mov	r8, r0
 8009272:	f003 f971 	bl	800c558 <__aeabi_d2iz>
 8009276:	4604      	mov	r4, r0
 8009278:	f7fc ff4c 	bl	8006114 <__aeabi_i2d>
 800927c:	3430      	adds	r4, #48	; 0x30
 800927e:	4602      	mov	r2, r0
 8009280:	460b      	mov	r3, r1
 8009282:	4640      	mov	r0, r8
 8009284:	4649      	mov	r1, r9
 8009286:	f7fc fdf7 	bl	8005e78 <__aeabi_dsub>
 800928a:	f807 4f01 	strb.w	r4, [r7, #1]!
 800928e:	42af      	cmp	r7, r5
 8009290:	d1e7      	bne.n	8009262 <_dtoa_r+0xbde>
 8009292:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8009294:	4634      	mov	r4, r6
 8009296:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
 8009298:	4656      	mov	r6, sl
 800929a:	18b6      	adds	r6, r6, r2
 800929c:	46da      	mov	sl, fp
 800929e:	e9cd 0108 	strd	r0, r1, [sp, #32]
 80092a2:	2300      	movs	r3, #0
 80092a4:	2200      	movs	r2, #0
 80092a6:	f6c3 73e0 	movt	r3, #16352	; 0x3fe0
 80092aa:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
 80092ae:	f7fc fde5 	bl	8005e7c <__adddf3>
 80092b2:	4602      	mov	r2, r0
 80092b4:	460b      	mov	r3, r1
 80092b6:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80092ba:	f003 f943 	bl	800c544 <__aeabi_dcmpgt>
 80092be:	2800      	cmp	r0, #0
 80092c0:	f47f acc3 	bne.w	8008c4a <_dtoa_r+0x5c6>
 80092c4:	2100      	movs	r1, #0
 80092c6:	e9dd 2318 	ldrd	r2, r3, [sp, #96]	; 0x60
 80092ca:	2000      	movs	r0, #0
 80092cc:	f6c3 71e0 	movt	r1, #16352	; 0x3fe0
 80092d0:	f7fc fdd2 	bl	8005e78 <__aeabi_dsub>
 80092d4:	4602      	mov	r2, r0
 80092d6:	460b      	mov	r3, r1
 80092d8:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80092dc:	f003 f914 	bl	800c508 <__aeabi_dcmplt>
 80092e0:	2800      	cmp	r0, #0
 80092e2:	f43f abf9 	beq.w	8008ad8 <_dtoa_r+0x454>
 80092e6:	4633      	mov	r3, r6
 80092e8:	461e      	mov	r6, r3
 80092ea:	3b01      	subs	r3, #1
 80092ec:	f816 2c01 	ldrb.w	r2, [r6, #-1]
 80092f0:	2a30      	cmp	r2, #48	; 0x30
 80092f2:	d0f9      	beq.n	80092e8 <_dtoa_r+0xc64>
 80092f4:	9d12      	ldr	r5, [sp, #72]	; 0x48
 80092f6:	f7ff bbdb 	b.w	8008ab0 <_dtoa_r+0x42c>
 80092fa:	980c      	ldr	r0, [sp, #48]	; 0x30
 80092fc:	f7ff ba04 	b.w	8008708 <_dtoa_r+0x84>
 8009300:	f8db 3010 	ldr.w	r3, [fp, #16]
 8009304:	eb0b 0383 	add.w	r3, fp, r3, lsl #2
 8009308:	6918      	ldr	r0, [r3, #16]
 800930a:	f000 ff0b 	bl	800a124 <__hi0bits>
 800930e:	f1c0 0320 	rsb	r3, r0, #32
 8009312:	e504      	b.n	8008d1e <_dtoa_r+0x69a>
 8009314:	4650      	mov	r0, sl
 8009316:	4659      	mov	r1, fp
 8009318:	f001 f89c 	bl	800a454 <__mcmp>
 800931c:	2800      	cmp	r0, #0
 800931e:	f6bf ad26 	bge.w	8008d6e <_dtoa_r+0x6ea>
 8009322:	4651      	mov	r1, sl
 8009324:	220a      	movs	r2, #10
 8009326:	4620      	mov	r0, r4
 8009328:	2300      	movs	r3, #0
 800932a:	f000 fe6d 	bl	800a008 <__multadd>
 800932e:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8009330:	3d01      	subs	r5, #1
 8009332:	4682      	mov	sl, r0
 8009334:	2a00      	cmp	r2, #0
 8009336:	f040 80e9 	bne.w	800950c <_dtoa_r+0xe88>
 800933a:	980e      	ldr	r0, [sp, #56]	; 0x38
 800933c:	900a      	str	r0, [sp, #40]	; 0x28
 800933e:	e516      	b.n	8008d6e <_dtoa_r+0x6ea>
 8009340:	2201      	movs	r2, #1
 8009342:	920e      	str	r2, [sp, #56]	; 0x38
 8009344:	920a      	str	r2, [sp, #40]	; 0x28
 8009346:	9229      	str	r2, [sp, #164]	; 0xa4
 8009348:	f7ff bade 	b.w	8008908 <_dtoa_r+0x284>
 800934c:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 800934e:	2701      	movs	r7, #1
 8009350:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
 8009354:	9502      	str	r5, [sp, #8]
 8009356:	e002      	b.n	800935e <_dtoa_r+0xcda>
 8009358:	f000 fe56 	bl	800a008 <__multadd>
 800935c:	4682      	mov	sl, r0
 800935e:	4659      	mov	r1, fp
 8009360:	4650      	mov	r0, sl
 8009362:	f7ff f8f9 	bl	8008558 <quorem>
 8009366:	220a      	movs	r2, #10
 8009368:	2300      	movs	r3, #0
 800936a:	454f      	cmp	r7, r9
 800936c:	4651      	mov	r1, sl
 800936e:	f107 0701 	add.w	r7, r7, #1
 8009372:	f100 0530 	add.w	r5, r0, #48	; 0x30
 8009376:	4620      	mov	r0, r4
 8009378:	f806 5b01 	strb.w	r5, [r6], #1
 800937c:	46b0      	mov	r8, r6
 800937e:	dbeb      	blt.n	8009358 <_dtoa_r+0xcd4>
 8009380:	9507      	str	r5, [sp, #28]
 8009382:	2700      	movs	r7, #0
 8009384:	9d02      	ldr	r5, [sp, #8]
 8009386:	4651      	mov	r1, sl
 8009388:	2201      	movs	r2, #1
 800938a:	4620      	mov	r0, r4
 800938c:	f001 f80c 	bl	800a3a8 <__lshift>
 8009390:	4659      	mov	r1, fp
 8009392:	4682      	mov	sl, r0
 8009394:	f001 f85e 	bl	800a454 <__mcmp>
 8009398:	2800      	cmp	r0, #0
 800939a:	dd0f      	ble.n	80093bc <_dtoa_r+0xd38>
 800939c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800939e:	4646      	mov	r6, r8
 80093a0:	f108 38ff 	add.w	r8, r8, #4294967295
 80093a4:	f816 3c01 	ldrb.w	r3, [r6, #-1]
 80093a8:	2b39      	cmp	r3, #57	; 0x39
 80093aa:	d161      	bne.n	8009470 <_dtoa_r+0xdec>
 80093ac:	4590      	cmp	r8, r2
 80093ae:	d1f6      	bne.n	800939e <_dtoa_r+0xd1a>
 80093b0:	980c      	ldr	r0, [sp, #48]	; 0x30
 80093b2:	2331      	movs	r3, #49	; 0x31
 80093b4:	3501      	adds	r5, #1
 80093b6:	7003      	strb	r3, [r0, #0]
 80093b8:	f7ff bb65 	b.w	8008a86 <_dtoa_r+0x402>
 80093bc:	d103      	bne.n	80093c6 <_dtoa_r+0xd42>
 80093be:	9a07      	ldr	r2, [sp, #28]
 80093c0:	f012 0f01 	tst.w	r2, #1
 80093c4:	d1ea      	bne.n	800939c <_dtoa_r+0xd18>
 80093c6:	4646      	mov	r6, r8
 80093c8:	f818 3d01 	ldrb.w	r3, [r8, #-1]!
 80093cc:	2b30      	cmp	r3, #48	; 0x30
 80093ce:	d0fa      	beq.n	80093c6 <_dtoa_r+0xd42>
 80093d0:	f7ff bb59 	b.w	8008a86 <_dtoa_r+0x402>
 80093d4:	f04f 0802 	mov.w	r8, #2
 80093d8:	f7ff bae2 	b.w	80089a0 <_dtoa_r+0x31c>
 80093dc:	9d07      	ldr	r5, [sp, #28]
 80093de:	4644      	mov	r4, r8
 80093e0:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 80093e4:	f7ff bb64 	b.w	8008ab0 <_dtoa_r+0x42c>
 80093e8:	4651      	mov	r1, sl
 80093ea:	4620      	mov	r0, r4
 80093ec:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80093ee:	f000 ff89 	bl	800a304 <__pow5mult>
 80093f2:	4682      	mov	sl, r0
 80093f4:	e47b      	b.n	8008cee <_dtoa_r+0x66a>
 80093f6:	4651      	mov	r1, sl
 80093f8:	4620      	mov	r0, r4
 80093fa:	f000 ff83 	bl	800a304 <__pow5mult>
 80093fe:	4682      	mov	sl, r0
 8009400:	e475      	b.n	8008cee <_dtoa_r+0x66a>
 8009402:	9816      	ldr	r0, [sp, #88]	; 0x58
 8009404:	2800      	cmp	r0, #0
 8009406:	d04e      	beq.n	80094a6 <_dtoa_r+0xe22>
 8009408:	f503 6386 	add.w	r3, r3, #1072	; 0x430
 800940c:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 800940e:	3303      	adds	r3, #3
 8009410:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 8009412:	e517      	b.n	8008e44 <_dtoa_r+0x7c0>
 8009414:	f04f 0b00 	mov.w	fp, #0
 8009418:	f8cd b020 	str.w	fp, [sp, #32]
 800941c:	f7ff bb2f 	b.w	8008a7e <_dtoa_r+0x3fa>
 8009420:	3101      	adds	r1, #1
 8009422:	9d12      	ldr	r5, [sp, #72]	; 0x48
 8009424:	7011      	strb	r1, [r2, #0]
 8009426:	f7ff bb43 	b.w	8008ab0 <_dtoa_r+0x42c>
 800942a:	f8dd a05c 	ldr.w	sl, [sp, #92]	; 0x5c
 800942e:	9c08      	ldr	r4, [sp, #32]
 8009430:	e40b      	b.n	8008c4a <_dtoa_r+0x5c6>
 8009432:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8009434:	1a9e      	subs	r6, r3, r2
 8009436:	2300      	movs	r3, #0
 8009438:	e504      	b.n	8008e44 <_dtoa_r+0x7c0>
 800943a:	f1b9 0f00 	cmp.w	r9, #0
 800943e:	9d08      	ldr	r5, [sp, #32]
 8009440:	dd0f      	ble.n	8009462 <_dtoa_r+0xdde>
 8009442:	4651      	mov	r1, sl
 8009444:	2201      	movs	r2, #1
 8009446:	4620      	mov	r0, r4
 8009448:	f000 ffae 	bl	800a3a8 <__lshift>
 800944c:	4659      	mov	r1, fp
 800944e:	4682      	mov	sl, r0
 8009450:	f001 f800 	bl	800a454 <__mcmp>
 8009454:	2800      	cmp	r0, #0
 8009456:	dd53      	ble.n	8009500 <_dtoa_r+0xe7c>
 8009458:	9b07      	ldr	r3, [sp, #28]
 800945a:	2b39      	cmp	r3, #57	; 0x39
 800945c:	d039      	beq.n	80094d2 <_dtoa_r+0xe4e>
 800945e:	3301      	adds	r3, #1
 8009460:	9307      	str	r3, [sp, #28]
 8009462:	9802      	ldr	r0, [sp, #8]
 8009464:	9907      	ldr	r1, [sp, #28]
 8009466:	9008      	str	r0, [sp, #32]
 8009468:	f806 1b01 	strb.w	r1, [r6], #1
 800946c:	f7ff bb0b 	b.w	8008a86 <_dtoa_r+0x402>
 8009470:	3301      	adds	r3, #1
 8009472:	f888 3000 	strb.w	r3, [r8]
 8009476:	f7ff bb06 	b.w	8008a86 <_dtoa_r+0x402>
 800947a:	9a08      	ldr	r2, [sp, #32]
 800947c:	4620      	mov	r0, r4
 800947e:	6851      	ldr	r1, [r2, #4]
 8009480:	f000 fd72 	bl	8009f68 <_Balloc>
 8009484:	9b08      	ldr	r3, [sp, #32]
 8009486:	f103 010c 	add.w	r1, r3, #12
 800948a:	691a      	ldr	r2, [r3, #16]
 800948c:	3202      	adds	r2, #2
 800948e:	0092      	lsls	r2, r2, #2
 8009490:	4606      	mov	r6, r0
 8009492:	300c      	adds	r0, #12
 8009494:	f000 fc66 	bl	8009d64 <memcpy>
 8009498:	4620      	mov	r0, r4
 800949a:	4631      	mov	r1, r6
 800949c:	2201      	movs	r2, #1
 800949e:	f000 ff83 	bl	800a3a8 <__lshift>
 80094a2:	9002      	str	r0, [sp, #8]
 80094a4:	e5fe      	b.n	80090a4 <_dtoa_r+0xa20>
 80094a6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80094a8:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 80094aa:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 80094ac:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 80094b0:	e4c8      	b.n	8008e44 <_dtoa_r+0x7c0>
 80094b2:	9902      	ldr	r1, [sp, #8]
 80094b4:	9d08      	ldr	r5, [sp, #32]
 80094b6:	9108      	str	r1, [sp, #32]
 80094b8:	e765      	b.n	8009386 <_dtoa_r+0xd02>
 80094ba:	9a07      	ldr	r2, [sp, #28]
 80094bc:	9d08      	ldr	r5, [sp, #32]
 80094be:	2a39      	cmp	r2, #57	; 0x39
 80094c0:	d007      	beq.n	80094d2 <_dtoa_r+0xe4e>
 80094c2:	9902      	ldr	r1, [sp, #8]
 80094c4:	9807      	ldr	r0, [sp, #28]
 80094c6:	9108      	str	r1, [sp, #32]
 80094c8:	1c43      	adds	r3, r0, #1
 80094ca:	f806 3b01 	strb.w	r3, [r6], #1
 80094ce:	f7ff bada 	b.w	8008a86 <_dtoa_r+0x402>
 80094d2:	9b02      	ldr	r3, [sp, #8]
 80094d4:	46b0      	mov	r8, r6
 80094d6:	9308      	str	r3, [sp, #32]
 80094d8:	2339      	movs	r3, #57	; 0x39
 80094da:	f808 3b01 	strb.w	r3, [r8], #1
 80094de:	e75d      	b.n	800939c <_dtoa_r+0xd18>
 80094e0:	9907      	ldr	r1, [sp, #28]
 80094e2:	462b      	mov	r3, r5
 80094e4:	9d08      	ldr	r5, [sp, #32]
 80094e6:	2939      	cmp	r1, #57	; 0x39
 80094e8:	d0f3      	beq.n	80094d2 <_dtoa_r+0xe4e>
 80094ea:	2b00      	cmp	r3, #0
 80094ec:	dd01      	ble.n	80094f2 <_dtoa_r+0xe6e>
 80094ee:	3101      	adds	r1, #1
 80094f0:	9107      	str	r1, [sp, #28]
 80094f2:	9a02      	ldr	r2, [sp, #8]
 80094f4:	9b07      	ldr	r3, [sp, #28]
 80094f6:	9208      	str	r2, [sp, #32]
 80094f8:	f806 3b01 	strb.w	r3, [r6], #1
 80094fc:	f7ff bac3 	b.w	8008a86 <_dtoa_r+0x402>
 8009500:	d1af      	bne.n	8009462 <_dtoa_r+0xdde>
 8009502:	9a07      	ldr	r2, [sp, #28]
 8009504:	f012 0f01 	tst.w	r2, #1
 8009508:	d0ab      	beq.n	8009462 <_dtoa_r+0xdde>
 800950a:	e7a5      	b.n	8009458 <_dtoa_r+0xdd4>
 800950c:	2300      	movs	r3, #0
 800950e:	4620      	mov	r0, r4
 8009510:	9908      	ldr	r1, [sp, #32]
 8009512:	220a      	movs	r2, #10
 8009514:	f000 fd78 	bl	800a008 <__multadd>
 8009518:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800951a:	930a      	str	r3, [sp, #40]	; 0x28
 800951c:	9008      	str	r0, [sp, #32]
 800951e:	e426      	b.n	8008d6e <_dtoa_r+0x6ea>
 8009520:	f43f ac0f 	beq.w	8008d42 <_dtoa_r+0x6be>
 8009524:	331c      	adds	r3, #28
 8009526:	e623      	b.n	8009170 <_dtoa_r+0xaec>
 8009528:	990a      	ldr	r1, [sp, #40]	; 0x28
 800952a:	290e      	cmp	r1, #14
 800952c:	bf8c      	ite	hi
 800952e:	2700      	movhi	r7, #0
 8009530:	f007 0701 	andls.w	r7, r7, #1
 8009534:	f7ff b9eb 	b.w	800890e <_dtoa_r+0x28a>
 8009538:	2701      	movs	r7, #1
 800953a:	f7ff b970 	b.w	800881e <_dtoa_r+0x19a>
 800953e:	bf00      	nop

08009540 <_fflush_r>:
 8009540:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009544:	460c      	mov	r4, r1
 8009546:	690e      	ldr	r6, [r1, #16]
 8009548:	4680      	mov	r8, r0
 800954a:	2e00      	cmp	r6, #0
 800954c:	d04a      	beq.n	80095e4 <_fflush_r+0xa4>
 800954e:	b118      	cbz	r0, 8009558 <_fflush_r+0x18>
 8009550:	6983      	ldr	r3, [r0, #24]
 8009552:	2b00      	cmp	r3, #0
 8009554:	f000 808e 	beq.w	8009674 <_fflush_r+0x134>
 8009558:	f64c 7368 	movw	r3, #53096	; 0xcf68
 800955c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8009560:	429c      	cmp	r4, r3
 8009562:	bf08      	it	eq
 8009564:	f8d8 4004 	ldreq.w	r4, [r8, #4]
 8009568:	d010      	beq.n	800958c <_fflush_r+0x4c>
 800956a:	f64c 7388 	movw	r3, #53128	; 0xcf88
 800956e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8009572:	429c      	cmp	r4, r3
 8009574:	bf08      	it	eq
 8009576:	f8d8 4008 	ldreq.w	r4, [r8, #8]
 800957a:	d007      	beq.n	800958c <_fflush_r+0x4c>
 800957c:	f64c 73a8 	movw	r3, #53160	; 0xcfa8
 8009580:	f6c0 0300 	movt	r3, #2048	; 0x800
 8009584:	429c      	cmp	r4, r3
 8009586:	bf08      	it	eq
 8009588:	f8d8 400c 	ldreq.w	r4, [r8, #12]
 800958c:	89a6      	ldrh	r6, [r4, #12]
 800958e:	2e00      	cmp	r6, #0
 8009590:	d028      	beq.n	80095e4 <_fflush_r+0xa4>
 8009592:	b233      	sxth	r3, r6
 8009594:	f013 0008 	ands.w	r0, r3, #8
 8009598:	d027      	beq.n	80095ea <_fflush_r+0xaa>
 800959a:	6926      	ldr	r6, [r4, #16]
 800959c:	b316      	cbz	r6, 80095e4 <_fflush_r+0xa4>
 800959e:	f013 0f03 	tst.w	r3, #3
 80095a2:	6825      	ldr	r5, [r4, #0]
 80095a4:	6026      	str	r6, [r4, #0]
 80095a6:	bf08      	it	eq
 80095a8:	6963      	ldreq	r3, [r4, #20]
 80095aa:	ebc6 0505 	rsb	r5, r6, r5
 80095ae:	bf18      	it	ne
 80095b0:	2300      	movne	r3, #0
 80095b2:	2d00      	cmp	r5, #0
 80095b4:	60a3      	str	r3, [r4, #8]
 80095b6:	dc02      	bgt.n	80095be <_fflush_r+0x7e>
 80095b8:	e09a      	b.n	80096f0 <_fflush_r+0x1b0>
 80095ba:	2d00      	cmp	r5, #0
 80095bc:	dd74      	ble.n	80096a8 <_fflush_r+0x168>
 80095be:	4632      	mov	r2, r6
 80095c0:	462b      	mov	r3, r5
 80095c2:	6aa7      	ldr	r7, [r4, #40]	; 0x28
 80095c4:	4640      	mov	r0, r8
 80095c6:	6a21      	ldr	r1, [r4, #32]
 80095c8:	47b8      	blx	r7
 80095ca:	2800      	cmp	r0, #0
 80095cc:	ebc0 0505 	rsb	r5, r0, r5
 80095d0:	4406      	add	r6, r0
 80095d2:	dcf2      	bgt.n	80095ba <_fflush_r+0x7a>
 80095d4:	89a3      	ldrh	r3, [r4, #12]
 80095d6:	f04f 30ff 	mov.w	r0, #4294967295
 80095da:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80095de:	81a3      	strh	r3, [r4, #12]
 80095e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80095e4:	4630      	mov	r0, r6
 80095e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80095ea:	6862      	ldr	r2, [r4, #4]
 80095ec:	f446 6300 	orr.w	r3, r6, #2048	; 0x800
 80095f0:	81a3      	strh	r3, [r4, #12]
 80095f2:	2a00      	cmp	r2, #0
 80095f4:	dd5b      	ble.n	80096ae <_fflush_r+0x16e>
 80095f6:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 80095f8:	2e00      	cmp	r6, #0
 80095fa:	d0f3      	beq.n	80095e4 <_fflush_r+0xa4>
 80095fc:	b29b      	uxth	r3, r3
 80095fe:	2200      	movs	r2, #0
 8009600:	f413 5780 	ands.w	r7, r3, #4096	; 0x1000
 8009604:	f8d8 5000 	ldr.w	r5, [r8]
 8009608:	f8c8 2000 	str.w	r2, [r8]
 800960c:	bf18      	it	ne
 800960e:	6d62      	ldrne	r2, [r4, #84]	; 0x54
 8009610:	d033      	beq.n	800967a <_fflush_r+0x13a>
 8009612:	f013 0f04 	tst.w	r3, #4
 8009616:	d005      	beq.n	8009624 <_fflush_r+0xe4>
 8009618:	6861      	ldr	r1, [r4, #4]
 800961a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800961c:	1a52      	subs	r2, r2, r1
 800961e:	b10b      	cbz	r3, 8009624 <_fflush_r+0xe4>
 8009620:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8009622:	1ad2      	subs	r2, r2, r3
 8009624:	2300      	movs	r3, #0
 8009626:	4640      	mov	r0, r8
 8009628:	6a21      	ldr	r1, [r4, #32]
 800962a:	47b0      	blx	r6
 800962c:	f1b0 3fff 	cmp.w	r0, #4294967295
 8009630:	d02f      	beq.n	8009692 <_fflush_r+0x152>
 8009632:	89a3      	ldrh	r3, [r4, #12]
 8009634:	2100      	movs	r1, #0
 8009636:	6922      	ldr	r2, [r4, #16]
 8009638:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800963c:	6061      	str	r1, [r4, #4]
 800963e:	041b      	lsls	r3, r3, #16
 8009640:	6022      	str	r2, [r4, #0]
 8009642:	0c1b      	lsrs	r3, r3, #16
 8009644:	81a3      	strh	r3, [r4, #12]
 8009646:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 800964a:	d003      	beq.n	8009654 <_fflush_r+0x114>
 800964c:	f1b0 3fff 	cmp.w	r0, #4294967295
 8009650:	d031      	beq.n	80096b6 <_fflush_r+0x176>
 8009652:	6560      	str	r0, [r4, #84]	; 0x54
 8009654:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8009656:	f8c8 5000 	str.w	r5, [r8]
 800965a:	2900      	cmp	r1, #0
 800965c:	d031      	beq.n	80096c2 <_fflush_r+0x182>
 800965e:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8009662:	4299      	cmp	r1, r3
 8009664:	d002      	beq.n	800966c <_fflush_r+0x12c>
 8009666:	4640      	mov	r0, r8
 8009668:	f000 f9c4 	bl	80099f4 <_free_r>
 800966c:	2000      	movs	r0, #0
 800966e:	6360      	str	r0, [r4, #52]	; 0x34
 8009670:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009674:	f000 f882 	bl	800977c <__sinit>
 8009678:	e76e      	b.n	8009558 <_fflush_r+0x18>
 800967a:	463a      	mov	r2, r7
 800967c:	2301      	movs	r3, #1
 800967e:	4640      	mov	r0, r8
 8009680:	6a21      	ldr	r1, [r4, #32]
 8009682:	47b0      	blx	r6
 8009684:	f1b0 3fff 	cmp.w	r0, #4294967295
 8009688:	4602      	mov	r2, r0
 800968a:	d01d      	beq.n	80096c8 <_fflush_r+0x188>
 800968c:	89a3      	ldrh	r3, [r4, #12]
 800968e:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8009690:	e7bf      	b.n	8009612 <_fflush_r+0xd2>
 8009692:	f8d8 3000 	ldr.w	r3, [r8]
 8009696:	2b1d      	cmp	r3, #29
 8009698:	d89c      	bhi.n	80095d4 <_fflush_r+0x94>
 800969a:	f44f 7201 	mov.w	r2, #516	; 0x204
 800969e:	f2c8 0200 	movt	r2, #32768	; 0x8000
 80096a2:	409a      	lsls	r2, r3
 80096a4:	d4c5      	bmi.n	8009632 <_fflush_r+0xf2>
 80096a6:	e795      	b.n	80095d4 <_fflush_r+0x94>
 80096a8:	2000      	movs	r0, #0
 80096aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80096ae:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80096b0:	2a00      	cmp	r2, #0
 80096b2:	dca0      	bgt.n	80095f6 <_fflush_r+0xb6>
 80096b4:	e7f9      	b.n	80096aa <_fflush_r+0x16a>
 80096b6:	f8d8 3000 	ldr.w	r3, [r8]
 80096ba:	2b00      	cmp	r3, #0
 80096bc:	d1ca      	bne.n	8009654 <_fflush_r+0x114>
 80096be:	6560      	str	r0, [r4, #84]	; 0x54
 80096c0:	e7c8      	b.n	8009654 <_fflush_r+0x114>
 80096c2:	4608      	mov	r0, r1
 80096c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80096c8:	f8d8 3000 	ldr.w	r3, [r8]
 80096cc:	2b00      	cmp	r3, #0
 80096ce:	d0dd      	beq.n	800968c <_fflush_r+0x14c>
 80096d0:	f1a3 021d 	sub.w	r2, r3, #29
 80096d4:	4251      	negs	r1, r2
 80096d6:	eb41 0102 	adc.w	r1, r1, r2
 80096da:	2b16      	cmp	r3, #22
 80096dc:	bf14      	ite	ne
 80096de:	460b      	movne	r3, r1
 80096e0:	f041 0301 	orreq.w	r3, r1, #1
 80096e4:	b13b      	cbz	r3, 80096f6 <_fflush_r+0x1b6>
 80096e6:	f8c8 5000 	str.w	r5, [r8]
 80096ea:	4638      	mov	r0, r7
 80096ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80096f0:	2000      	movs	r0, #0
 80096f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80096f6:	89a3      	ldrh	r3, [r4, #12]
 80096f8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80096fc:	81a3      	strh	r3, [r4, #12]
 80096fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009702:	bf00      	nop

08009704 <fflush>:
 8009704:	b130      	cbz	r0, 8009714 <fflush+0x10>
 8009706:	f240 2378 	movw	r3, #632	; 0x278
 800970a:	4601      	mov	r1, r0
 800970c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009710:	6818      	ldr	r0, [r3, #0]
 8009712:	e715      	b.n	8009540 <_fflush_r>
 8009714:	f64c 7344 	movw	r3, #53060	; 0xcf44
 8009718:	f249 5141 	movw	r1, #38209	; 0x9541
 800971c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8009720:	f6c0 0100 	movt	r1, #2048	; 0x800
 8009724:	6818      	ldr	r0, [r3, #0]
 8009726:	f000 ba5b 	b.w	8009be0 <_fwalk_reent>
 800972a:	bf00      	nop

0800972c <__fp_lock>:
 800972c:	2000      	movs	r0, #0
 800972e:	4770      	bx	lr

08009730 <__fp_unlock>:
 8009730:	2000      	movs	r0, #0
 8009732:	4770      	bx	lr

08009734 <_cleanup_r>:
 8009734:	f64b 0199 	movw	r1, #47257	; 0xb899
 8009738:	f6c0 0100 	movt	r1, #2048	; 0x800
 800973c:	f000 ba26 	b.w	8009b8c <_fwalk>

08009740 <__sfmoreglue>:
 8009740:	b570      	push	{r4, r5, r6, lr}
 8009742:	2568      	movs	r5, #104	; 0x68
 8009744:	460e      	mov	r6, r1
 8009746:	fb05 f501 	mul.w	r5, r5, r1
 800974a:	f105 010c 	add.w	r1, r5, #12
 800974e:	f7fc fecf 	bl	80064f0 <_malloc_r>
 8009752:	4604      	mov	r4, r0
 8009754:	b148      	cbz	r0, 800976a <__sfmoreglue+0x2a>
 8009756:	f100 030c 	add.w	r3, r0, #12
 800975a:	2100      	movs	r1, #0
 800975c:	6046      	str	r6, [r0, #4]
 800975e:	462a      	mov	r2, r5
 8009760:	4618      	mov	r0, r3
 8009762:	6021      	str	r1, [r4, #0]
 8009764:	60a3      	str	r3, [r4, #8]
 8009766:	f000 fba5 	bl	8009eb4 <memset>
 800976a:	4620      	mov	r0, r4
 800976c:	bd70      	pop	{r4, r5, r6, pc}
 800976e:	bf00      	nop

08009770 <_cleanup>:
 8009770:	f64c 7344 	movw	r3, #53060	; 0xcf44
 8009774:	f6c0 0300 	movt	r3, #2048	; 0x800
 8009778:	6818      	ldr	r0, [r3, #0]
 800977a:	e7db      	b.n	8009734 <_cleanup_r>

0800977c <__sinit>:
 800977c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009780:	4605      	mov	r5, r0
 8009782:	6984      	ldr	r4, [r0, #24]
 8009784:	b083      	sub	sp, #12
 8009786:	2c00      	cmp	r4, #0
 8009788:	d178      	bne.n	800987c <__sinit+0x100>
 800978a:	f249 7235 	movw	r2, #38709	; 0x9735
 800978e:	2301      	movs	r3, #1
 8009790:	f6c0 0200 	movt	r2, #2048	; 0x800
 8009794:	6183      	str	r3, [r0, #24]
 8009796:	6282      	str	r2, [r0, #40]	; 0x28
 8009798:	f64a 2985 	movw	r9, #43653	; 0xaa85
 800979c:	f8c0 40d8 	str.w	r4, [r0, #216]	; 0xd8
 80097a0:	f64a 28ad 	movw	r8, #43693	; 0xaaad
 80097a4:	f8c0 40dc 	str.w	r4, [r0, #220]	; 0xdc
 80097a8:	f64a 2ae9 	movw	sl, #43753	; 0xaae9
 80097ac:	f8c0 40e0 	str.w	r4, [r0, #224]	; 0xe0
 80097b0:	f64a 3b11 	movw	fp, #43793	; 0xab11
 80097b4:	9301      	str	r3, [sp, #4]
 80097b6:	f000 f865 	bl	8009884 <__sfp>
 80097ba:	f6c0 0900 	movt	r9, #2048	; 0x800
 80097be:	f6c0 0800 	movt	r8, #2048	; 0x800
 80097c2:	f6c0 0a00 	movt	sl, #2048	; 0x800
 80097c6:	f6c0 0b00 	movt	fp, #2048	; 0x800
 80097ca:	6068      	str	r0, [r5, #4]
 80097cc:	4628      	mov	r0, r5
 80097ce:	f000 f859 	bl	8009884 <__sfp>
 80097d2:	60a8      	str	r0, [r5, #8]
 80097d4:	4628      	mov	r0, r5
 80097d6:	f000 f855 	bl	8009884 <__sfp>
 80097da:	686f      	ldr	r7, [r5, #4]
 80097dc:	4621      	mov	r1, r4
 80097de:	2208      	movs	r2, #8
 80097e0:	60e8      	str	r0, [r5, #12]
 80097e2:	2004      	movs	r0, #4
 80097e4:	603c      	str	r4, [r7, #0]
 80097e6:	81b8      	strh	r0, [r7, #12]
 80097e8:	f107 005c 	add.w	r0, r7, #92	; 0x5c
 80097ec:	607c      	str	r4, [r7, #4]
 80097ee:	60bc      	str	r4, [r7, #8]
 80097f0:	667c      	str	r4, [r7, #100]	; 0x64
 80097f2:	81fc      	strh	r4, [r7, #14]
 80097f4:	613c      	str	r4, [r7, #16]
 80097f6:	617c      	str	r4, [r7, #20]
 80097f8:	61bc      	str	r4, [r7, #24]
 80097fa:	f000 fb5b 	bl	8009eb4 <memset>
 80097fe:	68ae      	ldr	r6, [r5, #8]
 8009800:	9b01      	ldr	r3, [sp, #4]
 8009802:	4621      	mov	r1, r4
 8009804:	2208      	movs	r2, #8
 8009806:	2009      	movs	r0, #9
 8009808:	623f      	str	r7, [r7, #32]
 800980a:	81b0      	strh	r0, [r6, #12]
 800980c:	f106 005c 	add.w	r0, r6, #92	; 0x5c
 8009810:	81f3      	strh	r3, [r6, #14]
 8009812:	f8c7 9024 	str.w	r9, [r7, #36]	; 0x24
 8009816:	f8c7 8028 	str.w	r8, [r7, #40]	; 0x28
 800981a:	f8c7 a02c 	str.w	sl, [r7, #44]	; 0x2c
 800981e:	f8c7 b030 	str.w	fp, [r7, #48]	; 0x30
 8009822:	6034      	str	r4, [r6, #0]
 8009824:	6074      	str	r4, [r6, #4]
 8009826:	60b4      	str	r4, [r6, #8]
 8009828:	6674      	str	r4, [r6, #100]	; 0x64
 800982a:	6134      	str	r4, [r6, #16]
 800982c:	6174      	str	r4, [r6, #20]
 800982e:	61b4      	str	r4, [r6, #24]
 8009830:	f000 fb40 	bl	8009eb4 <memset>
 8009834:	68ed      	ldr	r5, [r5, #12]
 8009836:	2312      	movs	r3, #18
 8009838:	2002      	movs	r0, #2
 800983a:	6236      	str	r6, [r6, #32]
 800983c:	4621      	mov	r1, r4
 800983e:	81e8      	strh	r0, [r5, #14]
 8009840:	2208      	movs	r2, #8
 8009842:	f8c6 9024 	str.w	r9, [r6, #36]	; 0x24
 8009846:	f105 005c 	add.w	r0, r5, #92	; 0x5c
 800984a:	81ab      	strh	r3, [r5, #12]
 800984c:	f8c6 8028 	str.w	r8, [r6, #40]	; 0x28
 8009850:	f8c6 a02c 	str.w	sl, [r6, #44]	; 0x2c
 8009854:	f8c6 b030 	str.w	fp, [r6, #48]	; 0x30
 8009858:	602c      	str	r4, [r5, #0]
 800985a:	606c      	str	r4, [r5, #4]
 800985c:	60ac      	str	r4, [r5, #8]
 800985e:	666c      	str	r4, [r5, #100]	; 0x64
 8009860:	612c      	str	r4, [r5, #16]
 8009862:	616c      	str	r4, [r5, #20]
 8009864:	61ac      	str	r4, [r5, #24]
 8009866:	f000 fb25 	bl	8009eb4 <memset>
 800986a:	622d      	str	r5, [r5, #32]
 800986c:	f8c5 9024 	str.w	r9, [r5, #36]	; 0x24
 8009870:	f8c5 8028 	str.w	r8, [r5, #40]	; 0x28
 8009874:	f8c5 a02c 	str.w	sl, [r5, #44]	; 0x2c
 8009878:	f8c5 b030 	str.w	fp, [r5, #48]	; 0x30
 800987c:	b003      	add	sp, #12
 800987e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009882:	bf00      	nop

08009884 <__sfp>:
 8009884:	f64c 7344 	movw	r3, #53060	; 0xcf44
 8009888:	f6c0 0300 	movt	r3, #2048	; 0x800
 800988c:	b570      	push	{r4, r5, r6, lr}
 800988e:	4606      	mov	r6, r0
 8009890:	681d      	ldr	r5, [r3, #0]
 8009892:	69ab      	ldr	r3, [r5, #24]
 8009894:	2b00      	cmp	r3, #0
 8009896:	d029      	beq.n	80098ec <__sfp+0x68>
 8009898:	35d8      	adds	r5, #216	; 0xd8
 800989a:	686b      	ldr	r3, [r5, #4]
 800989c:	68ac      	ldr	r4, [r5, #8]
 800989e:	3b01      	subs	r3, #1
 80098a0:	d503      	bpl.n	80098aa <__sfp+0x26>
 80098a2:	e01f      	b.n	80098e4 <__sfp+0x60>
 80098a4:	3468      	adds	r4, #104	; 0x68
 80098a6:	3b01      	subs	r3, #1
 80098a8:	d31c      	bcc.n	80098e4 <__sfp+0x60>
 80098aa:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 80098ae:	2a00      	cmp	r2, #0
 80098b0:	d1f8      	bne.n	80098a4 <__sfp+0x20>
 80098b2:	2500      	movs	r5, #0
 80098b4:	f04f 33ff 	mov.w	r3, #4294967295
 80098b8:	6665      	str	r5, [r4, #100]	; 0x64
 80098ba:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 80098be:	81e3      	strh	r3, [r4, #14]
 80098c0:	4629      	mov	r1, r5
 80098c2:	2301      	movs	r3, #1
 80098c4:	6025      	str	r5, [r4, #0]
 80098c6:	81a3      	strh	r3, [r4, #12]
 80098c8:	2208      	movs	r2, #8
 80098ca:	60a5      	str	r5, [r4, #8]
 80098cc:	6065      	str	r5, [r4, #4]
 80098ce:	6125      	str	r5, [r4, #16]
 80098d0:	6165      	str	r5, [r4, #20]
 80098d2:	61a5      	str	r5, [r4, #24]
 80098d4:	f000 faee 	bl	8009eb4 <memset>
 80098d8:	6365      	str	r5, [r4, #52]	; 0x34
 80098da:	63a5      	str	r5, [r4, #56]	; 0x38
 80098dc:	64a5      	str	r5, [r4, #72]	; 0x48
 80098de:	64e5      	str	r5, [r4, #76]	; 0x4c
 80098e0:	4620      	mov	r0, r4
 80098e2:	bd70      	pop	{r4, r5, r6, pc}
 80098e4:	6828      	ldr	r0, [r5, #0]
 80098e6:	b128      	cbz	r0, 80098f4 <__sfp+0x70>
 80098e8:	4605      	mov	r5, r0
 80098ea:	e7d6      	b.n	800989a <__sfp+0x16>
 80098ec:	4628      	mov	r0, r5
 80098ee:	f7ff ff45 	bl	800977c <__sinit>
 80098f2:	e7d1      	b.n	8009898 <__sfp+0x14>
 80098f4:	4630      	mov	r0, r6
 80098f6:	2104      	movs	r1, #4
 80098f8:	f7ff ff22 	bl	8009740 <__sfmoreglue>
 80098fc:	6028      	str	r0, [r5, #0]
 80098fe:	2800      	cmp	r0, #0
 8009900:	d1f2      	bne.n	80098e8 <__sfp+0x64>
 8009902:	230c      	movs	r3, #12
 8009904:	4604      	mov	r4, r0
 8009906:	6033      	str	r3, [r6, #0]
 8009908:	e7ea      	b.n	80098e0 <__sfp+0x5c>
 800990a:	bf00      	nop

0800990c <__sfp_lock_acquire>:
 800990c:	4770      	bx	lr
 800990e:	bf00      	nop

08009910 <__sfp_lock_release>:
 8009910:	4770      	bx	lr
 8009912:	bf00      	nop

08009914 <__sinit_lock_acquire>:
 8009914:	4770      	bx	lr
 8009916:	bf00      	nop

08009918 <__sinit_lock_release>:
 8009918:	4770      	bx	lr
 800991a:	bf00      	nop

0800991c <__fp_lock_all>:
 800991c:	f240 2378 	movw	r3, #632	; 0x278
 8009920:	f249 712d 	movw	r1, #38701	; 0x972d
 8009924:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009928:	f6c0 0100 	movt	r1, #2048	; 0x800
 800992c:	6818      	ldr	r0, [r3, #0]
 800992e:	f000 b92d 	b.w	8009b8c <_fwalk>
 8009932:	bf00      	nop

08009934 <__fp_unlock_all>:
 8009934:	f240 2378 	movw	r3, #632	; 0x278
 8009938:	f249 7131 	movw	r1, #38705	; 0x9731
 800993c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009940:	f6c0 0100 	movt	r1, #2048	; 0x800
 8009944:	6818      	ldr	r0, [r3, #0]
 8009946:	f000 b921 	b.w	8009b8c <_fwalk>
 800994a:	bf00      	nop

0800994c <_malloc_trim_r>:
 800994c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800994e:	f240 346c 	movw	r4, #876	; 0x36c
 8009952:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8009956:	460f      	mov	r7, r1
 8009958:	4605      	mov	r5, r0
 800995a:	f7fd f887 	bl	8006a6c <__malloc_lock>
 800995e:	68a3      	ldr	r3, [r4, #8]
 8009960:	685e      	ldr	r6, [r3, #4]
 8009962:	f026 0603 	bic.w	r6, r6, #3
 8009966:	f506 637e 	add.w	r3, r6, #4064	; 0xfe0
 800996a:	330f      	adds	r3, #15
 800996c:	1bdf      	subs	r7, r3, r7
 800996e:	0b3f      	lsrs	r7, r7, #12
 8009970:	3f01      	subs	r7, #1
 8009972:	033f      	lsls	r7, r7, #12
 8009974:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
 8009978:	db07      	blt.n	800998a <_malloc_trim_r+0x3e>
 800997a:	2100      	movs	r1, #0
 800997c:	4628      	mov	r0, r5
 800997e:	f7f7 f957 	bl	8000c30 <_sbrk_r>
 8009982:	68a3      	ldr	r3, [r4, #8]
 8009984:	199b      	adds	r3, r3, r6
 8009986:	4298      	cmp	r0, r3
 8009988:	d004      	beq.n	8009994 <_malloc_trim_r+0x48>
 800998a:	4628      	mov	r0, r5
 800998c:	f7fd f870 	bl	8006a70 <__malloc_unlock>
 8009990:	2000      	movs	r0, #0
 8009992:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009994:	4279      	negs	r1, r7
 8009996:	4628      	mov	r0, r5
 8009998:	f7f7 f94a 	bl	8000c30 <_sbrk_r>
 800999c:	f1b0 3fff 	cmp.w	r0, #4294967295
 80099a0:	d010      	beq.n	80099c4 <_malloc_trim_r+0x78>
 80099a2:	f641 1384 	movw	r3, #6532	; 0x1984
 80099a6:	68a1      	ldr	r1, [r4, #8]
 80099a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80099ac:	1bf6      	subs	r6, r6, r7
 80099ae:	4628      	mov	r0, r5
 80099b0:	f046 0601 	orr.w	r6, r6, #1
 80099b4:	681a      	ldr	r2, [r3, #0]
 80099b6:	604e      	str	r6, [r1, #4]
 80099b8:	1bd7      	subs	r7, r2, r7
 80099ba:	601f      	str	r7, [r3, #0]
 80099bc:	f7fd f858 	bl	8006a70 <__malloc_unlock>
 80099c0:	2001      	movs	r0, #1
 80099c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80099c4:	2100      	movs	r1, #0
 80099c6:	4628      	mov	r0, r5
 80099c8:	f7f7 f932 	bl	8000c30 <_sbrk_r>
 80099cc:	68a3      	ldr	r3, [r4, #8]
 80099ce:	1ac2      	subs	r2, r0, r3
 80099d0:	2a0f      	cmp	r2, #15
 80099d2:	ddda      	ble.n	800998a <_malloc_trim_r+0x3e>
 80099d4:	f240 7474 	movw	r4, #1908	; 0x774
 80099d8:	f641 1184 	movw	r1, #6532	; 0x1984
 80099dc:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80099e0:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80099e4:	f042 0201 	orr.w	r2, r2, #1
 80099e8:	605a      	str	r2, [r3, #4]
 80099ea:	6823      	ldr	r3, [r4, #0]
 80099ec:	1ac0      	subs	r0, r0, r3
 80099ee:	6008      	str	r0, [r1, #0]
 80099f0:	e7cb      	b.n	800998a <_malloc_trim_r+0x3e>
 80099f2:	bf00      	nop

080099f4 <_free_r>:
 80099f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80099f8:	460d      	mov	r5, r1
 80099fa:	4604      	mov	r4, r0
 80099fc:	2900      	cmp	r1, #0
 80099fe:	d058      	beq.n	8009ab2 <_free_r+0xbe>
 8009a00:	f7fd f834 	bl	8006a6c <__malloc_lock>
 8009a04:	f1a5 0208 	sub.w	r2, r5, #8
 8009a08:	f240 306c 	movw	r0, #876	; 0x36c
 8009a0c:	6856      	ldr	r6, [r2, #4]
 8009a0e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8009a12:	f026 0301 	bic.w	r3, r6, #1
 8009a16:	f8d0 c008 	ldr.w	ip, [r0, #8]
 8009a1a:	18d1      	adds	r1, r2, r3
 8009a1c:	458c      	cmp	ip, r1
 8009a1e:	684f      	ldr	r7, [r1, #4]
 8009a20:	f027 0703 	bic.w	r7, r7, #3
 8009a24:	d065      	beq.n	8009af2 <_free_r+0xfe>
 8009a26:	f016 0601 	ands.w	r6, r6, #1
 8009a2a:	604f      	str	r7, [r1, #4]
 8009a2c:	d031      	beq.n	8009a92 <_free_r+0x9e>
 8009a2e:	2600      	movs	r6, #0
 8009a30:	19cd      	adds	r5, r1, r7
 8009a32:	686d      	ldr	r5, [r5, #4]
 8009a34:	f015 0f01 	tst.w	r5, #1
 8009a38:	d106      	bne.n	8009a48 <_free_r+0x54>
 8009a3a:	19db      	adds	r3, r3, r7
 8009a3c:	2e00      	cmp	r6, #0
 8009a3e:	d04b      	beq.n	8009ad8 <_free_r+0xe4>
 8009a40:	688d      	ldr	r5, [r1, #8]
 8009a42:	68c9      	ldr	r1, [r1, #12]
 8009a44:	60e9      	str	r1, [r5, #12]
 8009a46:	608d      	str	r5, [r1, #8]
 8009a48:	f043 0101 	orr.w	r1, r3, #1
 8009a4c:	50d3      	str	r3, [r2, r3]
 8009a4e:	6051      	str	r1, [r2, #4]
 8009a50:	b9d6      	cbnz	r6, 8009a88 <_free_r+0x94>
 8009a52:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8009a56:	d32e      	bcc.n	8009ab6 <_free_r+0xc2>
 8009a58:	0a59      	lsrs	r1, r3, #9
 8009a5a:	2904      	cmp	r1, #4
 8009a5c:	d86b      	bhi.n	8009b36 <_free_r+0x142>
 8009a5e:	099e      	lsrs	r6, r3, #6
 8009a60:	3638      	adds	r6, #56	; 0x38
 8009a62:	00f5      	lsls	r5, r6, #3
 8009a64:	1945      	adds	r5, r0, r5
 8009a66:	68a9      	ldr	r1, [r5, #8]
 8009a68:	42a9      	cmp	r1, r5
 8009a6a:	d103      	bne.n	8009a74 <_free_r+0x80>
 8009a6c:	e069      	b.n	8009b42 <_free_r+0x14e>
 8009a6e:	6889      	ldr	r1, [r1, #8]
 8009a70:	428d      	cmp	r5, r1
 8009a72:	d004      	beq.n	8009a7e <_free_r+0x8a>
 8009a74:	6848      	ldr	r0, [r1, #4]
 8009a76:	f020 0003 	bic.w	r0, r0, #3
 8009a7a:	4283      	cmp	r3, r0
 8009a7c:	d3f7      	bcc.n	8009a6e <_free_r+0x7a>
 8009a7e:	68cb      	ldr	r3, [r1, #12]
 8009a80:	60d3      	str	r3, [r2, #12]
 8009a82:	6091      	str	r1, [r2, #8]
 8009a84:	60ca      	str	r2, [r1, #12]
 8009a86:	609a      	str	r2, [r3, #8]
 8009a88:	4620      	mov	r0, r4
 8009a8a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8009a8e:	f7fc bfef 	b.w	8006a70 <__malloc_unlock>
 8009a92:	f855 5c08 	ldr.w	r5, [r5, #-8]
 8009a96:	f100 0c08 	add.w	ip, r0, #8
 8009a9a:	1b52      	subs	r2, r2, r5
 8009a9c:	195b      	adds	r3, r3, r5
 8009a9e:	6895      	ldr	r5, [r2, #8]
 8009aa0:	4565      	cmp	r5, ip
 8009aa2:	d046      	beq.n	8009b32 <_free_r+0x13e>
 8009aa4:	f8d2 c00c 	ldr.w	ip, [r2, #12]
 8009aa8:	f8c5 c00c 	str.w	ip, [r5, #12]
 8009aac:	f8cc 5008 	str.w	r5, [ip, #8]
 8009ab0:	e7be      	b.n	8009a30 <_free_r+0x3c>
 8009ab2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009ab6:	08db      	lsrs	r3, r3, #3
 8009ab8:	2501      	movs	r5, #1
 8009aba:	6846      	ldr	r6, [r0, #4]
 8009abc:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
 8009ac0:	109b      	asrs	r3, r3, #2
 8009ac2:	fa15 f303 	lsls.w	r3, r5, r3
 8009ac6:	60d1      	str	r1, [r2, #12]
 8009ac8:	688d      	ldr	r5, [r1, #8]
 8009aca:	ea46 0303 	orr.w	r3, r6, r3
 8009ace:	6043      	str	r3, [r0, #4]
 8009ad0:	6095      	str	r5, [r2, #8]
 8009ad2:	60ea      	str	r2, [r5, #12]
 8009ad4:	608a      	str	r2, [r1, #8]
 8009ad6:	e7d7      	b.n	8009a88 <_free_r+0x94>
 8009ad8:	688d      	ldr	r5, [r1, #8]
 8009ada:	4f2b      	ldr	r7, [pc, #172]	; (8009b88 <_free_r+0x194>)
 8009adc:	42bd      	cmp	r5, r7
 8009ade:	d1b0      	bne.n	8009a42 <_free_r+0x4e>
 8009ae0:	60ea      	str	r2, [r5, #12]
 8009ae2:	f043 0101 	orr.w	r1, r3, #1
 8009ae6:	60aa      	str	r2, [r5, #8]
 8009ae8:	60d5      	str	r5, [r2, #12]
 8009aea:	6095      	str	r5, [r2, #8]
 8009aec:	6051      	str	r1, [r2, #4]
 8009aee:	50d3      	str	r3, [r2, r3]
 8009af0:	e7ca      	b.n	8009a88 <_free_r+0x94>
 8009af2:	f016 0f01 	tst.w	r6, #1
 8009af6:	443b      	add	r3, r7
 8009af8:	d107      	bne.n	8009b0a <_free_r+0x116>
 8009afa:	f855 1c08 	ldr.w	r1, [r5, #-8]
 8009afe:	1a52      	subs	r2, r2, r1
 8009b00:	185b      	adds	r3, r3, r1
 8009b02:	6895      	ldr	r5, [r2, #8]
 8009b04:	68d1      	ldr	r1, [r2, #12]
 8009b06:	60e9      	str	r1, [r5, #12]
 8009b08:	608d      	str	r5, [r1, #8]
 8009b0a:	f240 7178 	movw	r1, #1912	; 0x778
 8009b0e:	f043 0501 	orr.w	r5, r3, #1
 8009b12:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8009b16:	6055      	str	r5, [r2, #4]
 8009b18:	6082      	str	r2, [r0, #8]
 8009b1a:	680a      	ldr	r2, [r1, #0]
 8009b1c:	4293      	cmp	r3, r2
 8009b1e:	d3b3      	bcc.n	8009a88 <_free_r+0x94>
 8009b20:	f641 1380 	movw	r3, #6528	; 0x1980
 8009b24:	4620      	mov	r0, r4
 8009b26:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009b2a:	6819      	ldr	r1, [r3, #0]
 8009b2c:	f7ff ff0e 	bl	800994c <_malloc_trim_r>
 8009b30:	e7aa      	b.n	8009a88 <_free_r+0x94>
 8009b32:	2601      	movs	r6, #1
 8009b34:	e77c      	b.n	8009a30 <_free_r+0x3c>
 8009b36:	2914      	cmp	r1, #20
 8009b38:	d80c      	bhi.n	8009b54 <_free_r+0x160>
 8009b3a:	f101 065b 	add.w	r6, r1, #91	; 0x5b
 8009b3e:	00f5      	lsls	r5, r6, #3
 8009b40:	e790      	b.n	8009a64 <_free_r+0x70>
 8009b42:	2501      	movs	r5, #1
 8009b44:	6847      	ldr	r7, [r0, #4]
 8009b46:	10b6      	asrs	r6, r6, #2
 8009b48:	460b      	mov	r3, r1
 8009b4a:	40b5      	lsls	r5, r6
 8009b4c:	ea47 0505 	orr.w	r5, r7, r5
 8009b50:	6045      	str	r5, [r0, #4]
 8009b52:	e795      	b.n	8009a80 <_free_r+0x8c>
 8009b54:	2954      	cmp	r1, #84	; 0x54
 8009b56:	d803      	bhi.n	8009b60 <_free_r+0x16c>
 8009b58:	0b1e      	lsrs	r6, r3, #12
 8009b5a:	366e      	adds	r6, #110	; 0x6e
 8009b5c:	00f5      	lsls	r5, r6, #3
 8009b5e:	e781      	b.n	8009a64 <_free_r+0x70>
 8009b60:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
 8009b64:	d803      	bhi.n	8009b6e <_free_r+0x17a>
 8009b66:	0bde      	lsrs	r6, r3, #15
 8009b68:	3677      	adds	r6, #119	; 0x77
 8009b6a:	00f5      	lsls	r5, r6, #3
 8009b6c:	e77a      	b.n	8009a64 <_free_r+0x70>
 8009b6e:	f240 5554 	movw	r5, #1364	; 0x554
 8009b72:	42a9      	cmp	r1, r5
 8009b74:	d803      	bhi.n	8009b7e <_free_r+0x18a>
 8009b76:	0c9e      	lsrs	r6, r3, #18
 8009b78:	367c      	adds	r6, #124	; 0x7c
 8009b7a:	00f5      	lsls	r5, r6, #3
 8009b7c:	e772      	b.n	8009a64 <_free_r+0x70>
 8009b7e:	f44f 757c 	mov.w	r5, #1008	; 0x3f0
 8009b82:	267e      	movs	r6, #126	; 0x7e
 8009b84:	e76e      	b.n	8009a64 <_free_r+0x70>
 8009b86:	bf00      	nop
 8009b88:	20000374 	.word	0x20000374

08009b8c <_fwalk>:
 8009b8c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8009b90:	4607      	mov	r7, r0
 8009b92:	4689      	mov	r9, r1
 8009b94:	f7ff feba 	bl	800990c <__sfp_lock_acquire>
 8009b98:	37d8      	adds	r7, #216	; 0xd8
 8009b9a:	bf08      	it	eq
 8009b9c:	46b8      	moveq	r8, r7
 8009b9e:	d01a      	beq.n	8009bd6 <_fwalk+0x4a>
 8009ba0:	f04f 0800 	mov.w	r8, #0
 8009ba4:	687e      	ldr	r6, [r7, #4]
 8009ba6:	68bc      	ldr	r4, [r7, #8]
 8009ba8:	2e00      	cmp	r6, #0
 8009baa:	dd11      	ble.n	8009bd0 <_fwalk+0x44>
 8009bac:	2500      	movs	r5, #0
 8009bae:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8009bb2:	3501      	adds	r5, #1
 8009bb4:	b143      	cbz	r3, 8009bc8 <_fwalk+0x3c>
 8009bb6:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 8009bba:	4620      	mov	r0, r4
 8009bbc:	f1b3 3fff 	cmp.w	r3, #4294967295
 8009bc0:	d002      	beq.n	8009bc8 <_fwalk+0x3c>
 8009bc2:	47c8      	blx	r9
 8009bc4:	ea48 0800 	orr.w	r8, r8, r0
 8009bc8:	42b5      	cmp	r5, r6
 8009bca:	f104 0468 	add.w	r4, r4, #104	; 0x68
 8009bce:	d1ee      	bne.n	8009bae <_fwalk+0x22>
 8009bd0:	683f      	ldr	r7, [r7, #0]
 8009bd2:	2f00      	cmp	r7, #0
 8009bd4:	d1e6      	bne.n	8009ba4 <_fwalk+0x18>
 8009bd6:	f7ff fe9b 	bl	8009910 <__sfp_lock_release>
 8009bda:	4640      	mov	r0, r8
 8009bdc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08009be0 <_fwalk_reent>:
 8009be0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8009be4:	4680      	mov	r8, r0
 8009be6:	468a      	mov	sl, r1
 8009be8:	f7ff fe90 	bl	800990c <__sfp_lock_acquire>
 8009bec:	f118 07d8 	adds.w	r7, r8, #216	; 0xd8
 8009bf0:	bf08      	it	eq
 8009bf2:	46b9      	moveq	r9, r7
 8009bf4:	d01b      	beq.n	8009c2e <_fwalk_reent+0x4e>
 8009bf6:	f04f 0900 	mov.w	r9, #0
 8009bfa:	687e      	ldr	r6, [r7, #4]
 8009bfc:	68bc      	ldr	r4, [r7, #8]
 8009bfe:	2e00      	cmp	r6, #0
 8009c00:	dd12      	ble.n	8009c28 <_fwalk_reent+0x48>
 8009c02:	2500      	movs	r5, #0
 8009c04:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8009c08:	3501      	adds	r5, #1
 8009c0a:	b14b      	cbz	r3, 8009c20 <_fwalk_reent+0x40>
 8009c0c:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 8009c10:	4621      	mov	r1, r4
 8009c12:	4640      	mov	r0, r8
 8009c14:	f1b3 3fff 	cmp.w	r3, #4294967295
 8009c18:	d002      	beq.n	8009c20 <_fwalk_reent+0x40>
 8009c1a:	47d0      	blx	sl
 8009c1c:	ea49 0900 	orr.w	r9, r9, r0
 8009c20:	42b5      	cmp	r5, r6
 8009c22:	f104 0468 	add.w	r4, r4, #104	; 0x68
 8009c26:	d1ed      	bne.n	8009c04 <_fwalk_reent+0x24>
 8009c28:	683f      	ldr	r7, [r7, #0]
 8009c2a:	2f00      	cmp	r7, #0
 8009c2c:	d1e5      	bne.n	8009bfa <_fwalk_reent+0x1a>
 8009c2e:	f7ff fe6f 	bl	8009910 <__sfp_lock_release>
 8009c32:	4648      	mov	r0, r9
 8009c34:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08009c38 <_setlocale_r>:
 8009c38:	b510      	push	{r4, lr}
 8009c3a:	4614      	mov	r4, r2
 8009c3c:	b13a      	cbz	r2, 8009c4e <_setlocale_r+0x16>
 8009c3e:	f24d 2130 	movw	r1, #53808	; 0xd230
 8009c42:	4610      	mov	r0, r2
 8009c44:	f6c0 0100 	movt	r1, #2048	; 0x800
 8009c48:	f7fd f82e 	bl	8006ca8 <strcmp>
 8009c4c:	b920      	cbnz	r0, 8009c58 <_setlocale_r+0x20>
 8009c4e:	f24d 10d8 	movw	r0, #53720	; 0xd1d8
 8009c52:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009c56:	bd10      	pop	{r4, pc}
 8009c58:	f24d 11d8 	movw	r1, #53720	; 0xd1d8
 8009c5c:	4620      	mov	r0, r4
 8009c5e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8009c62:	f7fd f821 	bl	8006ca8 <strcmp>
 8009c66:	b920      	cbnz	r0, 8009c72 <_setlocale_r+0x3a>
 8009c68:	f24d 10d8 	movw	r0, #53720	; 0xd1d8
 8009c6c:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009c70:	bd10      	pop	{r4, pc}
 8009c72:	f24d 11fc 	movw	r1, #53756	; 0xd1fc
 8009c76:	4620      	mov	r0, r4
 8009c78:	f6c0 0100 	movt	r1, #2048	; 0x800
 8009c7c:	f7fd f814 	bl	8006ca8 <strcmp>
 8009c80:	f24d 13d8 	movw	r3, #53720	; 0xd1d8
 8009c84:	f6c0 0300 	movt	r3, #2048	; 0x800
 8009c88:	2800      	cmp	r0, #0
 8009c8a:	bf0c      	ite	eq
 8009c8c:	4618      	moveq	r0, r3
 8009c8e:	2000      	movne	r0, #0
 8009c90:	bd10      	pop	{r4, pc}
 8009c92:	bf00      	nop

08009c94 <__locale_charset>:
 8009c94:	f240 707c 	movw	r0, #1916	; 0x77c
 8009c98:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8009c9c:	4770      	bx	lr
 8009c9e:	bf00      	nop

08009ca0 <__locale_mb_cur_max>:
 8009ca0:	f240 737c 	movw	r3, #1916	; 0x77c
 8009ca4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009ca8:	6a18      	ldr	r0, [r3, #32]
 8009caa:	4770      	bx	lr

08009cac <__locale_msgcharset>:
 8009cac:	4800      	ldr	r0, [pc, #0]	; (8009cb0 <__locale_msgcharset+0x4>)
 8009cae:	4770      	bx	lr
 8009cb0:	200007a0 	.word	0x200007a0

08009cb4 <__locale_cjk_lang>:
 8009cb4:	2000      	movs	r0, #0
 8009cb6:	4770      	bx	lr

08009cb8 <_localeconv_r>:
 8009cb8:	4800      	ldr	r0, [pc, #0]	; (8009cbc <_localeconv_r+0x4>)
 8009cba:	4770      	bx	lr
 8009cbc:	200007c0 	.word	0x200007c0

08009cc0 <setlocale>:
 8009cc0:	f240 2378 	movw	r3, #632	; 0x278
 8009cc4:	460a      	mov	r2, r1
 8009cc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009cca:	4601      	mov	r1, r0
 8009ccc:	6818      	ldr	r0, [r3, #0]
 8009cce:	e7b3      	b.n	8009c38 <_setlocale_r>

08009cd0 <localeconv>:
 8009cd0:	4800      	ldr	r0, [pc, #0]	; (8009cd4 <localeconv+0x4>)
 8009cd2:	4770      	bx	lr
 8009cd4:	200007c0 	.word	0x200007c0

08009cd8 <memchr>:
 8009cd8:	f010 0f03 	tst.w	r0, #3
 8009cdc:	4603      	mov	r3, r0
 8009cde:	b470      	push	{r4, r5, r6}
 8009ce0:	b2c9      	uxtb	r1, r1
 8009ce2:	d011      	beq.n	8009d08 <memchr+0x30>
 8009ce4:	2a00      	cmp	r2, #0
 8009ce6:	d022      	beq.n	8009d2e <memchr+0x56>
 8009ce8:	7803      	ldrb	r3, [r0, #0]
 8009cea:	428b      	cmp	r3, r1
 8009cec:	d01d      	beq.n	8009d2a <memchr+0x52>
 8009cee:	3a01      	subs	r2, #1
 8009cf0:	3001      	adds	r0, #1
 8009cf2:	e005      	b.n	8009d00 <memchr+0x28>
 8009cf4:	b1da      	cbz	r2, 8009d2e <memchr+0x56>
 8009cf6:	f810 4b01 	ldrb.w	r4, [r0], #1
 8009cfa:	3a01      	subs	r2, #1
 8009cfc:	428c      	cmp	r4, r1
 8009cfe:	d018      	beq.n	8009d32 <memchr+0x5a>
 8009d00:	f010 0f03 	tst.w	r0, #3
 8009d04:	4603      	mov	r3, r0
 8009d06:	d1f5      	bne.n	8009cf4 <memchr+0x1c>
 8009d08:	2a03      	cmp	r2, #3
 8009d0a:	d814      	bhi.n	8009d36 <memchr+0x5e>
 8009d0c:	b17a      	cbz	r2, 8009d2e <memchr+0x56>
 8009d0e:	7818      	ldrb	r0, [r3, #0]
 8009d10:	4288      	cmp	r0, r1
 8009d12:	d00e      	beq.n	8009d32 <memchr+0x5a>
 8009d14:	1e54      	subs	r4, r2, #1
 8009d16:	1c5d      	adds	r5, r3, #1
 8009d18:	e003      	b.n	8009d22 <memchr+0x4a>
 8009d1a:	f815 6b01 	ldrb.w	r6, [r5], #1
 8009d1e:	428e      	cmp	r6, r1
 8009d20:	d003      	beq.n	8009d2a <memchr+0x52>
 8009d22:	3c01      	subs	r4, #1
 8009d24:	4628      	mov	r0, r5
 8009d26:	d2f8      	bcs.n	8009d1a <memchr+0x42>
 8009d28:	2000      	movs	r0, #0
 8009d2a:	bc70      	pop	{r4, r5, r6}
 8009d2c:	4770      	bx	lr
 8009d2e:	4610      	mov	r0, r2
 8009d30:	e7fb      	b.n	8009d2a <memchr+0x52>
 8009d32:	4618      	mov	r0, r3
 8009d34:	e7f9      	b.n	8009d2a <memchr+0x52>
 8009d36:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 8009d3a:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 8009d3e:	4618      	mov	r0, r3
 8009d40:	f853 4b04 	ldr.w	r4, [r3], #4
 8009d44:	ea86 0404 	eor.w	r4, r6, r4
 8009d48:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 8009d4c:	ea25 0404 	bic.w	r4, r5, r4
 8009d50:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 8009d54:	d103      	bne.n	8009d5e <memchr+0x86>
 8009d56:	3a04      	subs	r2, #4
 8009d58:	4618      	mov	r0, r3
 8009d5a:	2a03      	cmp	r2, #3
 8009d5c:	d8ef      	bhi.n	8009d3e <memchr+0x66>
 8009d5e:	4603      	mov	r3, r0
 8009d60:	e7d4      	b.n	8009d0c <memchr+0x34>
 8009d62:	bf00      	nop

08009d64 <memcpy>:
 8009d64:	2a03      	cmp	r2, #3
 8009d66:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 8009d6a:	d809      	bhi.n	8009d80 <memcpy+0x1c>
 8009d6c:	b12a      	cbz	r2, 8009d7a <memcpy+0x16>
 8009d6e:	2300      	movs	r3, #0
 8009d70:	5ccc      	ldrb	r4, [r1, r3]
 8009d72:	54c4      	strb	r4, [r0, r3]
 8009d74:	3301      	adds	r3, #1
 8009d76:	4293      	cmp	r3, r2
 8009d78:	d1fa      	bne.n	8009d70 <memcpy+0xc>
 8009d7a:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8009d7e:	4770      	bx	lr
 8009d80:	460b      	mov	r3, r1
 8009d82:	1882      	adds	r2, r0, r2
 8009d84:	4601      	mov	r1, r0
 8009d86:	e003      	b.n	8009d90 <memcpy+0x2c>
 8009d88:	7824      	ldrb	r4, [r4, #0]
 8009d8a:	3301      	adds	r3, #1
 8009d8c:	f801 4b01 	strb.w	r4, [r1], #1
 8009d90:	f011 0f03 	tst.w	r1, #3
 8009d94:	461c      	mov	r4, r3
 8009d96:	d1f7      	bne.n	8009d88 <memcpy+0x24>
 8009d98:	f013 0503 	ands.w	r5, r3, #3
 8009d9c:	d05d      	beq.n	8009e5a <memcpy+0xf6>
 8009d9e:	426e      	negs	r6, r5
 8009da0:	f1c5 0c04 	rsb	ip, r5, #4
 8009da4:	00ed      	lsls	r5, r5, #3
 8009da6:	599b      	ldr	r3, [r3, r6]
 8009da8:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8009dac:	e008      	b.n	8009dc0 <memcpy+0x5c>
 8009dae:	3404      	adds	r4, #4
 8009db0:	59a7      	ldr	r7, [r4, r6]
 8009db2:	463b      	mov	r3, r7
 8009db4:	fa07 f70c 	lsl.w	r7, r7, ip
 8009db8:	ea48 0707 	orr.w	r7, r8, r7
 8009dbc:	f841 7b04 	str.w	r7, [r1], #4
 8009dc0:	1a57      	subs	r7, r2, r1
 8009dc2:	fa23 f805 	lsr.w	r8, r3, r5
 8009dc6:	2f03      	cmp	r7, #3
 8009dc8:	dcf1      	bgt.n	8009dae <memcpy+0x4a>
 8009dca:	e003      	b.n	8009dd4 <memcpy+0x70>
 8009dcc:	f814 3b01 	ldrb.w	r3, [r4], #1
 8009dd0:	f801 3b01 	strb.w	r3, [r1], #1
 8009dd4:	428a      	cmp	r2, r1
 8009dd6:	d8f9      	bhi.n	8009dcc <memcpy+0x68>
 8009dd8:	e7cf      	b.n	8009d7a <memcpy+0x16>
 8009dda:	f853 4c40 	ldr.w	r4, [r3, #-64]
 8009dde:	f841 4c40 	str.w	r4, [r1, #-64]
 8009de2:	f853 4c3c 	ldr.w	r4, [r3, #-60]
 8009de6:	f841 4c3c 	str.w	r4, [r1, #-60]
 8009dea:	f853 4c38 	ldr.w	r4, [r3, #-56]
 8009dee:	f841 4c38 	str.w	r4, [r1, #-56]
 8009df2:	f853 4c34 	ldr.w	r4, [r3, #-52]
 8009df6:	f841 4c34 	str.w	r4, [r1, #-52]
 8009dfa:	f853 4c30 	ldr.w	r4, [r3, #-48]
 8009dfe:	f841 4c30 	str.w	r4, [r1, #-48]
 8009e02:	f853 4c2c 	ldr.w	r4, [r3, #-44]
 8009e06:	f841 4c2c 	str.w	r4, [r1, #-44]
 8009e0a:	f853 4c28 	ldr.w	r4, [r3, #-40]
 8009e0e:	f841 4c28 	str.w	r4, [r1, #-40]
 8009e12:	f853 4c24 	ldr.w	r4, [r3, #-36]
 8009e16:	f841 4c24 	str.w	r4, [r1, #-36]
 8009e1a:	f853 4c20 	ldr.w	r4, [r3, #-32]
 8009e1e:	f841 4c20 	str.w	r4, [r1, #-32]
 8009e22:	f853 4c1c 	ldr.w	r4, [r3, #-28]
 8009e26:	f841 4c1c 	str.w	r4, [r1, #-28]
 8009e2a:	f853 4c18 	ldr.w	r4, [r3, #-24]
 8009e2e:	f841 4c18 	str.w	r4, [r1, #-24]
 8009e32:	f853 4c14 	ldr.w	r4, [r3, #-20]
 8009e36:	f841 4c14 	str.w	r4, [r1, #-20]
 8009e3a:	f853 4c10 	ldr.w	r4, [r3, #-16]
 8009e3e:	f841 4c10 	str.w	r4, [r1, #-16]
 8009e42:	f853 4c0c 	ldr.w	r4, [r3, #-12]
 8009e46:	f841 4c0c 	str.w	r4, [r1, #-12]
 8009e4a:	f853 4c08 	ldr.w	r4, [r3, #-8]
 8009e4e:	f841 4c08 	str.w	r4, [r1, #-8]
 8009e52:	f853 4c04 	ldr.w	r4, [r3, #-4]
 8009e56:	f841 4c04 	str.w	r4, [r1, #-4]
 8009e5a:	1a56      	subs	r6, r2, r1
 8009e5c:	461d      	mov	r5, r3
 8009e5e:	460c      	mov	r4, r1
 8009e60:	3340      	adds	r3, #64	; 0x40
 8009e62:	3140      	adds	r1, #64	; 0x40
 8009e64:	2e3f      	cmp	r6, #63	; 0x3f
 8009e66:	dcb8      	bgt.n	8009dda <memcpy+0x76>
 8009e68:	462b      	mov	r3, r5
 8009e6a:	e00f      	b.n	8009e8c <memcpy+0x128>
 8009e6c:	f853 1c10 	ldr.w	r1, [r3, #-16]
 8009e70:	f844 1c10 	str.w	r1, [r4, #-16]
 8009e74:	f853 1c0c 	ldr.w	r1, [r3, #-12]
 8009e78:	f844 1c0c 	str.w	r1, [r4, #-12]
 8009e7c:	f853 1c08 	ldr.w	r1, [r3, #-8]
 8009e80:	f844 1c08 	str.w	r1, [r4, #-8]
 8009e84:	f853 1c04 	ldr.w	r1, [r3, #-4]
 8009e88:	f844 1c04 	str.w	r1, [r4, #-4]
 8009e8c:	1b16      	subs	r6, r2, r4
 8009e8e:	4621      	mov	r1, r4
 8009e90:	461d      	mov	r5, r3
 8009e92:	3410      	adds	r4, #16
 8009e94:	3310      	adds	r3, #16
 8009e96:	2e0f      	cmp	r6, #15
 8009e98:	dce8      	bgt.n	8009e6c <memcpy+0x108>
 8009e9a:	462b      	mov	r3, r5
 8009e9c:	e002      	b.n	8009ea4 <memcpy+0x140>
 8009e9e:	6824      	ldr	r4, [r4, #0]
 8009ea0:	f841 4b04 	str.w	r4, [r1], #4
 8009ea4:	1a55      	subs	r5, r2, r1
 8009ea6:	461c      	mov	r4, r3
 8009ea8:	2d03      	cmp	r5, #3
 8009eaa:	f103 0304 	add.w	r3, r3, #4
 8009eae:	dcf6      	bgt.n	8009e9e <memcpy+0x13a>
 8009eb0:	e790      	b.n	8009dd4 <memcpy+0x70>
 8009eb2:	bf00      	nop

08009eb4 <memset>:
 8009eb4:	2a03      	cmp	r2, #3
 8009eb6:	b2c9      	uxtb	r1, r1
 8009eb8:	b470      	push	{r4, r5, r6}
 8009eba:	d808      	bhi.n	8009ece <memset+0x1a>
 8009ebc:	b12a      	cbz	r2, 8009eca <memset+0x16>
 8009ebe:	4603      	mov	r3, r0
 8009ec0:	1812      	adds	r2, r2, r0
 8009ec2:	f803 1b01 	strb.w	r1, [r3], #1
 8009ec6:	4293      	cmp	r3, r2
 8009ec8:	d1fb      	bne.n	8009ec2 <memset+0xe>
 8009eca:	bc70      	pop	{r4, r5, r6}
 8009ecc:	4770      	bx	lr
 8009ece:	1882      	adds	r2, r0, r2
 8009ed0:	4604      	mov	r4, r0
 8009ed2:	e001      	b.n	8009ed8 <memset+0x24>
 8009ed4:	f804 1b01 	strb.w	r1, [r4], #1
 8009ed8:	f014 0f03 	tst.w	r4, #3
 8009edc:	d1fa      	bne.n	8009ed4 <memset+0x20>
 8009ede:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
 8009ee2:	fb03 f301 	mul.w	r3, r3, r1
 8009ee6:	e01f      	b.n	8009f28 <memset+0x74>
 8009ee8:	f844 3c40 	str.w	r3, [r4, #-64]
 8009eec:	f844 3c3c 	str.w	r3, [r4, #-60]
 8009ef0:	f844 3c38 	str.w	r3, [r4, #-56]
 8009ef4:	f844 3c34 	str.w	r3, [r4, #-52]
 8009ef8:	f844 3c30 	str.w	r3, [r4, #-48]
 8009efc:	f844 3c2c 	str.w	r3, [r4, #-44]
 8009f00:	f844 3c28 	str.w	r3, [r4, #-40]
 8009f04:	f844 3c24 	str.w	r3, [r4, #-36]
 8009f08:	f844 3c20 	str.w	r3, [r4, #-32]
 8009f0c:	f844 3c1c 	str.w	r3, [r4, #-28]
 8009f10:	f844 3c18 	str.w	r3, [r4, #-24]
 8009f14:	f844 3c14 	str.w	r3, [r4, #-20]
 8009f18:	f844 3c10 	str.w	r3, [r4, #-16]
 8009f1c:	f844 3c0c 	str.w	r3, [r4, #-12]
 8009f20:	f844 3c08 	str.w	r3, [r4, #-8]
 8009f24:	f844 3c04 	str.w	r3, [r4, #-4]
 8009f28:	1b16      	subs	r6, r2, r4
 8009f2a:	4625      	mov	r5, r4
 8009f2c:	3440      	adds	r4, #64	; 0x40
 8009f2e:	2e3f      	cmp	r6, #63	; 0x3f
 8009f30:	dcda      	bgt.n	8009ee8 <memset+0x34>
 8009f32:	462c      	mov	r4, r5
 8009f34:	e007      	b.n	8009f46 <memset+0x92>
 8009f36:	f844 3c10 	str.w	r3, [r4, #-16]
 8009f3a:	f844 3c0c 	str.w	r3, [r4, #-12]
 8009f3e:	f844 3c08 	str.w	r3, [r4, #-8]
 8009f42:	f844 3c04 	str.w	r3, [r4, #-4]
 8009f46:	1b16      	subs	r6, r2, r4
 8009f48:	4625      	mov	r5, r4
 8009f4a:	3410      	adds	r4, #16
 8009f4c:	2e0f      	cmp	r6, #15
 8009f4e:	dcf2      	bgt.n	8009f36 <memset+0x82>
 8009f50:	e001      	b.n	8009f56 <memset+0xa2>
 8009f52:	f845 3b04 	str.w	r3, [r5], #4
 8009f56:	1b54      	subs	r4, r2, r5
 8009f58:	2c03      	cmp	r4, #3
 8009f5a:	dcfa      	bgt.n	8009f52 <memset+0x9e>
 8009f5c:	e001      	b.n	8009f62 <memset+0xae>
 8009f5e:	f805 1b01 	strb.w	r1, [r5], #1
 8009f62:	4295      	cmp	r5, r2
 8009f64:	d3fb      	bcc.n	8009f5e <memset+0xaa>
 8009f66:	e7b0      	b.n	8009eca <memset+0x16>

08009f68 <_Balloc>:
 8009f68:	b570      	push	{r4, r5, r6, lr}
 8009f6a:	4606      	mov	r6, r0
 8009f6c:	6a44      	ldr	r4, [r0, #36]	; 0x24
 8009f6e:	460d      	mov	r5, r1
 8009f70:	b15c      	cbz	r4, 8009f8a <_Balloc+0x22>
 8009f72:	68e3      	ldr	r3, [r4, #12]
 8009f74:	b19b      	cbz	r3, 8009f9e <_Balloc+0x36>
 8009f76:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 8009f7a:	b1e0      	cbz	r0, 8009fb6 <_Balloc+0x4e>
 8009f7c:	6802      	ldr	r2, [r0, #0]
 8009f7e:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
 8009f82:	2300      	movs	r3, #0
 8009f84:	6103      	str	r3, [r0, #16]
 8009f86:	60c3      	str	r3, [r0, #12]
 8009f88:	bd70      	pop	{r4, r5, r6, pc}
 8009f8a:	2010      	movs	r0, #16
 8009f8c:	f7fc faa0 	bl	80064d0 <malloc>
 8009f90:	2300      	movs	r3, #0
 8009f92:	4604      	mov	r4, r0
 8009f94:	6270      	str	r0, [r6, #36]	; 0x24
 8009f96:	6043      	str	r3, [r0, #4]
 8009f98:	6083      	str	r3, [r0, #8]
 8009f9a:	6003      	str	r3, [r0, #0]
 8009f9c:	60c3      	str	r3, [r0, #12]
 8009f9e:	4630      	mov	r0, r6
 8009fa0:	2104      	movs	r1, #4
 8009fa2:	2221      	movs	r2, #33	; 0x21
 8009fa4:	f001 fbdc 	bl	800b760 <_calloc_r>
 8009fa8:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8009faa:	60e0      	str	r0, [r4, #12]
 8009fac:	68db      	ldr	r3, [r3, #12]
 8009fae:	2b00      	cmp	r3, #0
 8009fb0:	d1e1      	bne.n	8009f76 <_Balloc+0xe>
 8009fb2:	4618      	mov	r0, r3
 8009fb4:	bd70      	pop	{r4, r5, r6, pc}
 8009fb6:	2401      	movs	r4, #1
 8009fb8:	4630      	mov	r0, r6
 8009fba:	4621      	mov	r1, r4
 8009fbc:	40ac      	lsls	r4, r5
 8009fbe:	1d62      	adds	r2, r4, #5
 8009fc0:	0092      	lsls	r2, r2, #2
 8009fc2:	f001 fbcd 	bl	800b760 <_calloc_r>
 8009fc6:	2800      	cmp	r0, #0
 8009fc8:	d0f4      	beq.n	8009fb4 <_Balloc+0x4c>
 8009fca:	6045      	str	r5, [r0, #4]
 8009fcc:	6084      	str	r4, [r0, #8]
 8009fce:	e7d8      	b.n	8009f82 <_Balloc+0x1a>

08009fd0 <_Bfree>:
 8009fd0:	b530      	push	{r4, r5, lr}
 8009fd2:	4604      	mov	r4, r0
 8009fd4:	6a45      	ldr	r5, [r0, #36]	; 0x24
 8009fd6:	b083      	sub	sp, #12
 8009fd8:	b155      	cbz	r5, 8009ff0 <_Bfree+0x20>
 8009fda:	b139      	cbz	r1, 8009fec <_Bfree+0x1c>
 8009fdc:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8009fde:	684a      	ldr	r2, [r1, #4]
 8009fe0:	68db      	ldr	r3, [r3, #12]
 8009fe2:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 8009fe6:	6008      	str	r0, [r1, #0]
 8009fe8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8009fec:	b003      	add	sp, #12
 8009fee:	bd30      	pop	{r4, r5, pc}
 8009ff0:	2010      	movs	r0, #16
 8009ff2:	9101      	str	r1, [sp, #4]
 8009ff4:	f7fc fa6c 	bl	80064d0 <malloc>
 8009ff8:	9901      	ldr	r1, [sp, #4]
 8009ffa:	6260      	str	r0, [r4, #36]	; 0x24
 8009ffc:	6045      	str	r5, [r0, #4]
 8009ffe:	6085      	str	r5, [r0, #8]
 800a000:	6005      	str	r5, [r0, #0]
 800a002:	60c5      	str	r5, [r0, #12]
 800a004:	e7e9      	b.n	8009fda <_Bfree+0xa>
 800a006:	bf00      	nop

0800a008 <__multadd>:
 800a008:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a00c:	460c      	mov	r4, r1
 800a00e:	4605      	mov	r5, r0
 800a010:	690e      	ldr	r6, [r1, #16]
 800a012:	f101 0014 	add.w	r0, r1, #20
 800a016:	b082      	sub	sp, #8
 800a018:	2100      	movs	r1, #0
 800a01a:	6807      	ldr	r7, [r0, #0]
 800a01c:	3101      	adds	r1, #1
 800a01e:	fa1f fc87 	uxth.w	ip, r7
 800a022:	0c3f      	lsrs	r7, r7, #16
 800a024:	fb0c 3302 	mla	r3, ip, r2, r3
 800a028:	fb07 f702 	mul.w	r7, r7, r2
 800a02c:	eb07 4713 	add.w	r7, r7, r3, lsr #16
 800a030:	fa1f fc83 	uxth.w	ip, r3
 800a034:	0c3b      	lsrs	r3, r7, #16
 800a036:	428e      	cmp	r6, r1
 800a038:	ea4f 4807 	mov.w	r8, r7, lsl #16
 800a03c:	eb08 070c 	add.w	r7, r8, ip
 800a040:	f840 7b04 	str.w	r7, [r0], #4
 800a044:	dce9      	bgt.n	800a01a <__multadd+0x12>
 800a046:	b13b      	cbz	r3, 800a058 <__multadd+0x50>
 800a048:	68a2      	ldr	r2, [r4, #8]
 800a04a:	4296      	cmp	r6, r2
 800a04c:	da08      	bge.n	800a060 <__multadd+0x58>
 800a04e:	eb04 0286 	add.w	r2, r4, r6, lsl #2
 800a052:	3601      	adds	r6, #1
 800a054:	6126      	str	r6, [r4, #16]
 800a056:	6153      	str	r3, [r2, #20]
 800a058:	4620      	mov	r0, r4
 800a05a:	b002      	add	sp, #8
 800a05c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a060:	6861      	ldr	r1, [r4, #4]
 800a062:	4628      	mov	r0, r5
 800a064:	9301      	str	r3, [sp, #4]
 800a066:	3101      	adds	r1, #1
 800a068:	f7ff ff7e 	bl	8009f68 <_Balloc>
 800a06c:	6922      	ldr	r2, [r4, #16]
 800a06e:	f104 010c 	add.w	r1, r4, #12
 800a072:	3202      	adds	r2, #2
 800a074:	0092      	lsls	r2, r2, #2
 800a076:	4607      	mov	r7, r0
 800a078:	300c      	adds	r0, #12
 800a07a:	f7ff fe73 	bl	8009d64 <memcpy>
 800a07e:	4621      	mov	r1, r4
 800a080:	4628      	mov	r0, r5
 800a082:	463c      	mov	r4, r7
 800a084:	f7ff ffa4 	bl	8009fd0 <_Bfree>
 800a088:	9b01      	ldr	r3, [sp, #4]
 800a08a:	e7e0      	b.n	800a04e <__multadd+0x46>

0800a08c <__s2b>:
 800a08c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800a090:	f648 6539 	movw	r5, #36409	; 0x8e39
 800a094:	461f      	mov	r7, r3
 800a096:	f6c3 05e3 	movt	r5, #14563	; 0x38e3
 800a09a:	3308      	adds	r3, #8
 800a09c:	460e      	mov	r6, r1
 800a09e:	4604      	mov	r4, r0
 800a0a0:	4690      	mov	r8, r2
 800a0a2:	fb85 1503 	smull	r1, r5, r5, r3
 800a0a6:	17db      	asrs	r3, r3, #31
 800a0a8:	ebc3 0365 	rsb	r3, r3, r5, asr #1
 800a0ac:	2b01      	cmp	r3, #1
 800a0ae:	dd37      	ble.n	800a120 <__s2b+0x94>
 800a0b0:	2201      	movs	r2, #1
 800a0b2:	2100      	movs	r1, #0
 800a0b4:	0052      	lsls	r2, r2, #1
 800a0b6:	3101      	adds	r1, #1
 800a0b8:	4293      	cmp	r3, r2
 800a0ba:	dcfb      	bgt.n	800a0b4 <__s2b+0x28>
 800a0bc:	4620      	mov	r0, r4
 800a0be:	f7ff ff53 	bl	8009f68 <_Balloc>
 800a0c2:	9b08      	ldr	r3, [sp, #32]
 800a0c4:	6143      	str	r3, [r0, #20]
 800a0c6:	2301      	movs	r3, #1
 800a0c8:	f1b8 0f09 	cmp.w	r8, #9
 800a0cc:	4601      	mov	r1, r0
 800a0ce:	6103      	str	r3, [r0, #16]
 800a0d0:	dd22      	ble.n	800a118 <__s2b+0x8c>
 800a0d2:	f106 0909 	add.w	r9, r6, #9
 800a0d6:	4446      	add	r6, r8
 800a0d8:	464d      	mov	r5, r9
 800a0da:	f815 3b01 	ldrb.w	r3, [r5], #1
 800a0de:	220a      	movs	r2, #10
 800a0e0:	4620      	mov	r0, r4
 800a0e2:	3b30      	subs	r3, #48	; 0x30
 800a0e4:	f7ff ff90 	bl	800a008 <__multadd>
 800a0e8:	42b5      	cmp	r5, r6
 800a0ea:	4601      	mov	r1, r0
 800a0ec:	d1f5      	bne.n	800a0da <__s2b+0x4e>
 800a0ee:	eb09 0608 	add.w	r6, r9, r8
 800a0f2:	3e08      	subs	r6, #8
 800a0f4:	4547      	cmp	r7, r8
 800a0f6:	dd0c      	ble.n	800a112 <__s2b+0x86>
 800a0f8:	19f7      	adds	r7, r6, r7
 800a0fa:	ebc8 0707 	rsb	r7, r8, r7
 800a0fe:	f816 3b01 	ldrb.w	r3, [r6], #1
 800a102:	220a      	movs	r2, #10
 800a104:	4620      	mov	r0, r4
 800a106:	3b30      	subs	r3, #48	; 0x30
 800a108:	f7ff ff7e 	bl	800a008 <__multadd>
 800a10c:	42be      	cmp	r6, r7
 800a10e:	4601      	mov	r1, r0
 800a110:	d1f5      	bne.n	800a0fe <__s2b+0x72>
 800a112:	4608      	mov	r0, r1
 800a114:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800a118:	360a      	adds	r6, #10
 800a11a:	f04f 0809 	mov.w	r8, #9
 800a11e:	e7e9      	b.n	800a0f4 <__s2b+0x68>
 800a120:	2100      	movs	r1, #0
 800a122:	e7cb      	b.n	800a0bc <__s2b+0x30>

0800a124 <__hi0bits>:
 800a124:	0c02      	lsrs	r2, r0, #16
 800a126:	4603      	mov	r3, r0
 800a128:	d119      	bne.n	800a15e <__hi0bits+0x3a>
 800a12a:	0403      	lsls	r3, r0, #16
 800a12c:	2010      	movs	r0, #16
 800a12e:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
 800a132:	d101      	bne.n	800a138 <__hi0bits+0x14>
 800a134:	3008      	adds	r0, #8
 800a136:	021b      	lsls	r3, r3, #8
 800a138:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
 800a13c:	d101      	bne.n	800a142 <__hi0bits+0x1e>
 800a13e:	3004      	adds	r0, #4
 800a140:	011b      	lsls	r3, r3, #4
 800a142:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
 800a146:	d101      	bne.n	800a14c <__hi0bits+0x28>
 800a148:	3002      	adds	r0, #2
 800a14a:	009b      	lsls	r3, r3, #2
 800a14c:	2b00      	cmp	r3, #0
 800a14e:	db05      	blt.n	800a15c <__hi0bits+0x38>
 800a150:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
 800a154:	d001      	beq.n	800a15a <__hi0bits+0x36>
 800a156:	3001      	adds	r0, #1
 800a158:	4770      	bx	lr
 800a15a:	2020      	movs	r0, #32
 800a15c:	4770      	bx	lr
 800a15e:	2000      	movs	r0, #0
 800a160:	e7e5      	b.n	800a12e <__hi0bits+0xa>
 800a162:	bf00      	nop

0800a164 <__lo0bits>:
 800a164:	6803      	ldr	r3, [r0, #0]
 800a166:	4602      	mov	r2, r0
 800a168:	f013 0007 	ands.w	r0, r3, #7
 800a16c:	d009      	beq.n	800a182 <__lo0bits+0x1e>
 800a16e:	f013 0f01 	tst.w	r3, #1
 800a172:	d121      	bne.n	800a1b8 <__lo0bits+0x54>
 800a174:	f013 0f02 	tst.w	r3, #2
 800a178:	d122      	bne.n	800a1c0 <__lo0bits+0x5c>
 800a17a:	089b      	lsrs	r3, r3, #2
 800a17c:	2002      	movs	r0, #2
 800a17e:	6013      	str	r3, [r2, #0]
 800a180:	4770      	bx	lr
 800a182:	b299      	uxth	r1, r3
 800a184:	b909      	cbnz	r1, 800a18a <__lo0bits+0x26>
 800a186:	0c1b      	lsrs	r3, r3, #16
 800a188:	2010      	movs	r0, #16
 800a18a:	f013 0fff 	tst.w	r3, #255	; 0xff
 800a18e:	d101      	bne.n	800a194 <__lo0bits+0x30>
 800a190:	3008      	adds	r0, #8
 800a192:	0a1b      	lsrs	r3, r3, #8
 800a194:	f013 0f0f 	tst.w	r3, #15
 800a198:	d101      	bne.n	800a19e <__lo0bits+0x3a>
 800a19a:	3004      	adds	r0, #4
 800a19c:	091b      	lsrs	r3, r3, #4
 800a19e:	f013 0f03 	tst.w	r3, #3
 800a1a2:	d101      	bne.n	800a1a8 <__lo0bits+0x44>
 800a1a4:	3002      	adds	r0, #2
 800a1a6:	089b      	lsrs	r3, r3, #2
 800a1a8:	f013 0f01 	tst.w	r3, #1
 800a1ac:	d102      	bne.n	800a1b4 <__lo0bits+0x50>
 800a1ae:	085b      	lsrs	r3, r3, #1
 800a1b0:	d004      	beq.n	800a1bc <__lo0bits+0x58>
 800a1b2:	3001      	adds	r0, #1
 800a1b4:	6013      	str	r3, [r2, #0]
 800a1b6:	4770      	bx	lr
 800a1b8:	2000      	movs	r0, #0
 800a1ba:	4770      	bx	lr
 800a1bc:	2020      	movs	r0, #32
 800a1be:	4770      	bx	lr
 800a1c0:	085b      	lsrs	r3, r3, #1
 800a1c2:	2001      	movs	r0, #1
 800a1c4:	6013      	str	r3, [r2, #0]
 800a1c6:	4770      	bx	lr

0800a1c8 <__i2b>:
 800a1c8:	b510      	push	{r4, lr}
 800a1ca:	460c      	mov	r4, r1
 800a1cc:	2101      	movs	r1, #1
 800a1ce:	f7ff fecb 	bl	8009f68 <_Balloc>
 800a1d2:	2201      	movs	r2, #1
 800a1d4:	6144      	str	r4, [r0, #20]
 800a1d6:	6102      	str	r2, [r0, #16]
 800a1d8:	bd10      	pop	{r4, pc}
 800a1da:	bf00      	nop

0800a1dc <__multiply>:
 800a1dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a1e0:	4690      	mov	r8, r2
 800a1e2:	690f      	ldr	r7, [r1, #16]
 800a1e4:	460d      	mov	r5, r1
 800a1e6:	6916      	ldr	r6, [r2, #16]
 800a1e8:	b085      	sub	sp, #20
 800a1ea:	42b7      	cmp	r7, r6
 800a1ec:	bfbf      	itttt	lt
 800a1ee:	4645      	movlt	r5, r8
 800a1f0:	463a      	movlt	r2, r7
 800a1f2:	4637      	movlt	r7, r6
 800a1f4:	4616      	movlt	r6, r2
 800a1f6:	68ab      	ldr	r3, [r5, #8]
 800a1f8:	bfb8      	it	lt
 800a1fa:	4688      	movlt	r8, r1
 800a1fc:	19f4      	adds	r4, r6, r7
 800a1fe:	6869      	ldr	r1, [r5, #4]
 800a200:	429c      	cmp	r4, r3
 800a202:	bfc8      	it	gt
 800a204:	3101      	addgt	r1, #1
 800a206:	f7ff feaf 	bl	8009f68 <_Balloc>
 800a20a:	eb00 0384 	add.w	r3, r0, r4, lsl #2
 800a20e:	f100 0c14 	add.w	ip, r0, #20
 800a212:	3314      	adds	r3, #20
 800a214:	9001      	str	r0, [sp, #4]
 800a216:	459c      	cmp	ip, r3
 800a218:	9302      	str	r3, [sp, #8]
 800a21a:	d206      	bcs.n	800a22a <__multiply+0x4e>
 800a21c:	9902      	ldr	r1, [sp, #8]
 800a21e:	4663      	mov	r3, ip
 800a220:	2200      	movs	r2, #0
 800a222:	f843 2b04 	str.w	r2, [r3], #4
 800a226:	4299      	cmp	r1, r3
 800a228:	d8fb      	bhi.n	800a222 <__multiply+0x46>
 800a22a:	eb08 0686 	add.w	r6, r8, r6, lsl #2
 800a22e:	eb05 0787 	add.w	r7, r5, r7, lsl #2
 800a232:	f108 0814 	add.w	r8, r8, #20
 800a236:	3614      	adds	r6, #20
 800a238:	3514      	adds	r5, #20
 800a23a:	3714      	adds	r7, #20
 800a23c:	45b0      	cmp	r8, r6
 800a23e:	9500      	str	r5, [sp, #0]
 800a240:	d24d      	bcs.n	800a2de <__multiply+0x102>
 800a242:	9403      	str	r4, [sp, #12]
 800a244:	f858 4b04 	ldr.w	r4, [r8], #4
 800a248:	b2a0      	uxth	r0, r4
 800a24a:	b1f0      	cbz	r0, 800a28a <__multiply+0xae>
 800a24c:	9a00      	ldr	r2, [sp, #0]
 800a24e:	4663      	mov	r3, ip
 800a250:	2400      	movs	r4, #0
 800a252:	f852 5b04 	ldr.w	r5, [r2], #4
 800a256:	6819      	ldr	r1, [r3, #0]
 800a258:	fa1f fa85 	uxth.w	sl, r5
 800a25c:	0c2d      	lsrs	r5, r5, #16
 800a25e:	fa1f f981 	uxth.w	r9, r1
 800a262:	0c09      	lsrs	r1, r1, #16
 800a264:	fb00 990a 	mla	r9, r0, sl, r9
 800a268:	fb00 1105 	mla	r1, r0, r5, r1
 800a26c:	44a1      	add	r9, r4
 800a26e:	eb01 4119 	add.w	r1, r1, r9, lsr #16
 800a272:	fa1f f989 	uxth.w	r9, r9
 800a276:	0c0c      	lsrs	r4, r1, #16
 800a278:	4297      	cmp	r7, r2
 800a27a:	ea49 4501 	orr.w	r5, r9, r1, lsl #16
 800a27e:	f843 5b04 	str.w	r5, [r3], #4
 800a282:	d8e6      	bhi.n	800a252 <__multiply+0x76>
 800a284:	601c      	str	r4, [r3, #0]
 800a286:	f858 4c04 	ldr.w	r4, [r8, #-4]
 800a28a:	0c24      	lsrs	r4, r4, #16
 800a28c:	d021      	beq.n	800a2d2 <__multiply+0xf6>
 800a28e:	f8dc 2000 	ldr.w	r2, [ip]
 800a292:	4660      	mov	r0, ip
 800a294:	9b00      	ldr	r3, [sp, #0]
 800a296:	46e1      	mov	r9, ip
 800a298:	4611      	mov	r1, r2
 800a29a:	2500      	movs	r5, #0
 800a29c:	f8b3 a000 	ldrh.w	sl, [r3]
 800a2a0:	fa1f fb82 	uxth.w	fp, r2
 800a2a4:	fb0a 5504 	mla	r5, sl, r4, r5
 800a2a8:	eb05 4511 	add.w	r5, r5, r1, lsr #16
 800a2ac:	ea4b 4205 	orr.w	r2, fp, r5, lsl #16
 800a2b0:	f840 2b04 	str.w	r2, [r0], #4
 800a2b4:	f853 2b04 	ldr.w	r2, [r3], #4
 800a2b8:	f859 1f04 	ldr.w	r1, [r9, #4]!
 800a2bc:	0c12      	lsrs	r2, r2, #16
 800a2be:	fa1f fa81 	uxth.w	sl, r1
 800a2c2:	fb02 a204 	mla	r2, r2, r4, sl
 800a2c6:	eb02 4215 	add.w	r2, r2, r5, lsr #16
 800a2ca:	0c15      	lsrs	r5, r2, #16
 800a2cc:	429f      	cmp	r7, r3
 800a2ce:	d8e5      	bhi.n	800a29c <__multiply+0xc0>
 800a2d0:	6002      	str	r2, [r0, #0]
 800a2d2:	4546      	cmp	r6, r8
 800a2d4:	d902      	bls.n	800a2dc <__multiply+0x100>
 800a2d6:	f10c 0c04 	add.w	ip, ip, #4
 800a2da:	e7b3      	b.n	800a244 <__multiply+0x68>
 800a2dc:	9c03      	ldr	r4, [sp, #12]
 800a2de:	2c00      	cmp	r4, #0
 800a2e0:	dd0a      	ble.n	800a2f8 <__multiply+0x11c>
 800a2e2:	9902      	ldr	r1, [sp, #8]
 800a2e4:	1f0b      	subs	r3, r1, #4
 800a2e6:	f851 2c04 	ldr.w	r2, [r1, #-4]
 800a2ea:	b11a      	cbz	r2, 800a2f4 <__multiply+0x118>
 800a2ec:	e004      	b.n	800a2f8 <__multiply+0x11c>
 800a2ee:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 800a2f2:	b90a      	cbnz	r2, 800a2f8 <__multiply+0x11c>
 800a2f4:	3c01      	subs	r4, #1
 800a2f6:	d1fa      	bne.n	800a2ee <__multiply+0x112>
 800a2f8:	9a01      	ldr	r2, [sp, #4]
 800a2fa:	4610      	mov	r0, r2
 800a2fc:	6114      	str	r4, [r2, #16]
 800a2fe:	b005      	add	sp, #20
 800a300:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800a304 <__pow5mult>:
 800a304:	f012 0303 	ands.w	r3, r2, #3
 800a308:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a30c:	4615      	mov	r5, r2
 800a30e:	4604      	mov	r4, r0
 800a310:	4688      	mov	r8, r1
 800a312:	d128      	bne.n	800a366 <__pow5mult+0x62>
 800a314:	10ad      	asrs	r5, r5, #2
 800a316:	d01a      	beq.n	800a34e <__pow5mult+0x4a>
 800a318:	6a66      	ldr	r6, [r4, #36]	; 0x24
 800a31a:	2e00      	cmp	r6, #0
 800a31c:	d02f      	beq.n	800a37e <__pow5mult+0x7a>
 800a31e:	68b7      	ldr	r7, [r6, #8]
 800a320:	b92f      	cbnz	r7, 800a32e <__pow5mult+0x2a>
 800a322:	e036      	b.n	800a392 <__pow5mult+0x8e>
 800a324:	106d      	asrs	r5, r5, #1
 800a326:	d012      	beq.n	800a34e <__pow5mult+0x4a>
 800a328:	683e      	ldr	r6, [r7, #0]
 800a32a:	b19e      	cbz	r6, 800a354 <__pow5mult+0x50>
 800a32c:	4637      	mov	r7, r6
 800a32e:	f015 0f01 	tst.w	r5, #1
 800a332:	d0f7      	beq.n	800a324 <__pow5mult+0x20>
 800a334:	4641      	mov	r1, r8
 800a336:	463a      	mov	r2, r7
 800a338:	4620      	mov	r0, r4
 800a33a:	f7ff ff4f 	bl	800a1dc <__multiply>
 800a33e:	4641      	mov	r1, r8
 800a340:	4606      	mov	r6, r0
 800a342:	4620      	mov	r0, r4
 800a344:	f7ff fe44 	bl	8009fd0 <_Bfree>
 800a348:	106d      	asrs	r5, r5, #1
 800a34a:	46b0      	mov	r8, r6
 800a34c:	d1ec      	bne.n	800a328 <__pow5mult+0x24>
 800a34e:	4640      	mov	r0, r8
 800a350:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a354:	4639      	mov	r1, r7
 800a356:	463a      	mov	r2, r7
 800a358:	4620      	mov	r0, r4
 800a35a:	f7ff ff3f 	bl	800a1dc <__multiply>
 800a35e:	6038      	str	r0, [r7, #0]
 800a360:	4607      	mov	r7, r0
 800a362:	6006      	str	r6, [r0, #0]
 800a364:	e7e3      	b.n	800a32e <__pow5mult+0x2a>
 800a366:	f64c 72c8 	movw	r2, #53192	; 0xcfc8
 800a36a:	1e5e      	subs	r6, r3, #1
 800a36c:	f6c0 0200 	movt	r2, #2048	; 0x800
 800a370:	2300      	movs	r3, #0
 800a372:	f852 2026 	ldr.w	r2, [r2, r6, lsl #2]
 800a376:	f7ff fe47 	bl	800a008 <__multadd>
 800a37a:	4680      	mov	r8, r0
 800a37c:	e7ca      	b.n	800a314 <__pow5mult+0x10>
 800a37e:	2010      	movs	r0, #16
 800a380:	f7fc f8a6 	bl	80064d0 <malloc>
 800a384:	2300      	movs	r3, #0
 800a386:	4606      	mov	r6, r0
 800a388:	6260      	str	r0, [r4, #36]	; 0x24
 800a38a:	6043      	str	r3, [r0, #4]
 800a38c:	6083      	str	r3, [r0, #8]
 800a38e:	6003      	str	r3, [r0, #0]
 800a390:	60c3      	str	r3, [r0, #12]
 800a392:	4620      	mov	r0, r4
 800a394:	f240 2171 	movw	r1, #625	; 0x271
 800a398:	f7ff ff16 	bl	800a1c8 <__i2b>
 800a39c:	2300      	movs	r3, #0
 800a39e:	60b0      	str	r0, [r6, #8]
 800a3a0:	4607      	mov	r7, r0
 800a3a2:	6003      	str	r3, [r0, #0]
 800a3a4:	e7c3      	b.n	800a32e <__pow5mult+0x2a>
 800a3a6:	bf00      	nop

0800a3a8 <__lshift>:
 800a3a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800a3ac:	1156      	asrs	r6, r2, #5
 800a3ae:	690d      	ldr	r5, [r1, #16]
 800a3b0:	460c      	mov	r4, r1
 800a3b2:	688b      	ldr	r3, [r1, #8]
 800a3b4:	4690      	mov	r8, r2
 800a3b6:	3501      	adds	r5, #1
 800a3b8:	4681      	mov	r9, r0
 800a3ba:	19ad      	adds	r5, r5, r6
 800a3bc:	6849      	ldr	r1, [r1, #4]
 800a3be:	429d      	cmp	r5, r3
 800a3c0:	dd03      	ble.n	800a3ca <__lshift+0x22>
 800a3c2:	005b      	lsls	r3, r3, #1
 800a3c4:	3101      	adds	r1, #1
 800a3c6:	429d      	cmp	r5, r3
 800a3c8:	dcfb      	bgt.n	800a3c2 <__lshift+0x1a>
 800a3ca:	4648      	mov	r0, r9
 800a3cc:	f7ff fdcc 	bl	8009f68 <_Balloc>
 800a3d0:	2e00      	cmp	r6, #0
 800a3d2:	4607      	mov	r7, r0
 800a3d4:	f100 0214 	add.w	r2, r0, #20
 800a3d8:	dd0a      	ble.n	800a3f0 <__lshift+0x48>
 800a3da:	2300      	movs	r3, #0
 800a3dc:	4619      	mov	r1, r3
 800a3de:	3301      	adds	r3, #1
 800a3e0:	f842 1b04 	str.w	r1, [r2], #4
 800a3e4:	42b3      	cmp	r3, r6
 800a3e6:	d1fa      	bne.n	800a3de <__lshift+0x36>
 800a3e8:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 800a3ec:	f103 0214 	add.w	r2, r3, #20
 800a3f0:	6926      	ldr	r6, [r4, #16]
 800a3f2:	f104 0114 	add.w	r1, r4, #20
 800a3f6:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 800a3fa:	3614      	adds	r6, #20
 800a3fc:	f018 081f 	ands.w	r8, r8, #31
 800a400:	d01a      	beq.n	800a438 <__lshift+0x90>
 800a402:	f1c8 0e20 	rsb	lr, r8, #32
 800a406:	2000      	movs	r0, #0
 800a408:	680b      	ldr	r3, [r1, #0]
 800a40a:	fa03 f308 	lsl.w	r3, r3, r8
 800a40e:	4318      	orrs	r0, r3
 800a410:	f842 0b04 	str.w	r0, [r2], #4
 800a414:	f851 0b04 	ldr.w	r0, [r1], #4
 800a418:	428e      	cmp	r6, r1
 800a41a:	fa20 f00e 	lsr.w	r0, r0, lr
 800a41e:	d8f3      	bhi.n	800a408 <__lshift+0x60>
 800a420:	6010      	str	r0, [r2, #0]
 800a422:	b100      	cbz	r0, 800a426 <__lshift+0x7e>
 800a424:	3501      	adds	r5, #1
 800a426:	4648      	mov	r0, r9
 800a428:	3d01      	subs	r5, #1
 800a42a:	4621      	mov	r1, r4
 800a42c:	613d      	str	r5, [r7, #16]
 800a42e:	f7ff fdcf 	bl	8009fd0 <_Bfree>
 800a432:	4638      	mov	r0, r7
 800a434:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800a438:	f851 3b04 	ldr.w	r3, [r1], #4
 800a43c:	428e      	cmp	r6, r1
 800a43e:	f842 3b04 	str.w	r3, [r2], #4
 800a442:	d9f0      	bls.n	800a426 <__lshift+0x7e>
 800a444:	f851 3b04 	ldr.w	r3, [r1], #4
 800a448:	428e      	cmp	r6, r1
 800a44a:	f842 3b04 	str.w	r3, [r2], #4
 800a44e:	d8f3      	bhi.n	800a438 <__lshift+0x90>
 800a450:	e7e9      	b.n	800a426 <__lshift+0x7e>
 800a452:	bf00      	nop

0800a454 <__mcmp>:
 800a454:	4603      	mov	r3, r0
 800a456:	690a      	ldr	r2, [r1, #16]
 800a458:	6900      	ldr	r0, [r0, #16]
 800a45a:	b430      	push	{r4, r5}
 800a45c:	1a80      	subs	r0, r0, r2
 800a45e:	d10f      	bne.n	800a480 <__mcmp+0x2c>
 800a460:	3204      	adds	r2, #4
 800a462:	f103 0514 	add.w	r5, r3, #20
 800a466:	0092      	lsls	r2, r2, #2
 800a468:	189b      	adds	r3, r3, r2
 800a46a:	1889      	adds	r1, r1, r2
 800a46c:	3304      	adds	r3, #4
 800a46e:	3104      	adds	r1, #4
 800a470:	f853 4d04 	ldr.w	r4, [r3, #-4]!
 800a474:	f851 2d04 	ldr.w	r2, [r1, #-4]!
 800a478:	4294      	cmp	r4, r2
 800a47a:	d103      	bne.n	800a484 <__mcmp+0x30>
 800a47c:	429d      	cmp	r5, r3
 800a47e:	d3f7      	bcc.n	800a470 <__mcmp+0x1c>
 800a480:	bc30      	pop	{r4, r5}
 800a482:	4770      	bx	lr
 800a484:	bf38      	it	cc
 800a486:	f04f 30ff 	movcc.w	r0, #4294967295
 800a48a:	d3f9      	bcc.n	800a480 <__mcmp+0x2c>
 800a48c:	2001      	movs	r0, #1
 800a48e:	e7f7      	b.n	800a480 <__mcmp+0x2c>

0800a490 <__mdiff>:
 800a490:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a494:	4689      	mov	r9, r1
 800a496:	4604      	mov	r4, r0
 800a498:	4611      	mov	r1, r2
 800a49a:	4648      	mov	r0, r9
 800a49c:	4690      	mov	r8, r2
 800a49e:	f7ff ffd9 	bl	800a454 <__mcmp>
 800a4a2:	1e05      	subs	r5, r0, #0
 800a4a4:	d064      	beq.n	800a570 <__mdiff+0xe0>
 800a4a6:	bfbc      	itt	lt
 800a4a8:	464b      	movlt	r3, r9
 800a4aa:	46c1      	movlt	r9, r8
 800a4ac:	4620      	mov	r0, r4
 800a4ae:	bfb8      	it	lt
 800a4b0:	4698      	movlt	r8, r3
 800a4b2:	f8d9 1004 	ldr.w	r1, [r9, #4]
 800a4b6:	bfac      	ite	ge
 800a4b8:	f04f 0a00 	movge.w	sl, #0
 800a4bc:	f04f 0a01 	movlt.w	sl, #1
 800a4c0:	f7ff fd52 	bl	8009f68 <_Balloc>
 800a4c4:	f8d9 6010 	ldr.w	r6, [r9, #16]
 800a4c8:	f109 0514 	add.w	r5, r9, #20
 800a4cc:	f8d8 3010 	ldr.w	r3, [r8, #16]
 800a4d0:	f108 0714 	add.w	r7, r8, #20
 800a4d4:	2400      	movs	r4, #0
 800a4d6:	eb09 0986 	add.w	r9, r9, r6, lsl #2
 800a4da:	f109 0914 	add.w	r9, r9, #20
 800a4de:	4683      	mov	fp, r0
 800a4e0:	3014      	adds	r0, #20
 800a4e2:	f8cb a00c 	str.w	sl, [fp, #12]
 800a4e6:	eb08 0a83 	add.w	sl, r8, r3, lsl #2
 800a4ea:	f10a 0a14 	add.w	sl, sl, #20
 800a4ee:	f855 1b04 	ldr.w	r1, [r5], #4
 800a4f2:	4603      	mov	r3, r0
 800a4f4:	f857 0b04 	ldr.w	r0, [r7], #4
 800a4f8:	462a      	mov	r2, r5
 800a4fa:	fa1f f881 	uxth.w	r8, r1
 800a4fe:	fa1f fc80 	uxth.w	ip, r0
 800a502:	0c00      	lsrs	r0, r0, #16
 800a504:	ebcc 0c08 	rsb	ip, ip, r8
 800a508:	ebc0 4011 	rsb	r0, r0, r1, lsr #16
 800a50c:	4464      	add	r4, ip
 800a50e:	eb00 4024 	add.w	r0, r0, r4, asr #16
 800a512:	b2a4      	uxth	r4, r4
 800a514:	ea44 4100 	orr.w	r1, r4, r0, lsl #16
 800a518:	1404      	asrs	r4, r0, #16
 800a51a:	45ba      	cmp	sl, r7
 800a51c:	f843 1b04 	str.w	r1, [r3], #4
 800a520:	4618      	mov	r0, r3
 800a522:	d8e4      	bhi.n	800a4ee <__mdiff+0x5e>
 800a524:	45a9      	cmp	r9, r5
 800a526:	461f      	mov	r7, r3
 800a528:	d914      	bls.n	800a554 <__mdiff+0xc4>
 800a52a:	f852 1b04 	ldr.w	r1, [r2], #4
 800a52e:	b288      	uxth	r0, r1
 800a530:	0c09      	lsrs	r1, r1, #16
 800a532:	1824      	adds	r4, r4, r0
 800a534:	eb01 4124 	add.w	r1, r1, r4, asr #16
 800a538:	b2a4      	uxth	r4, r4
 800a53a:	ea44 4001 	orr.w	r0, r4, r1, lsl #16
 800a53e:	140c      	asrs	r4, r1, #16
 800a540:	4591      	cmp	r9, r2
 800a542:	f843 0b04 	str.w	r0, [r3], #4
 800a546:	d8f0      	bhi.n	800a52a <__mdiff+0x9a>
 800a548:	43eb      	mvns	r3, r5
 800a54a:	444b      	add	r3, r9
 800a54c:	f023 0303 	bic.w	r3, r3, #3
 800a550:	3304      	adds	r3, #4
 800a552:	18fb      	adds	r3, r7, r3
 800a554:	f853 2c04 	ldr.w	r2, [r3, #-4]
 800a558:	3b04      	subs	r3, #4
 800a55a:	b922      	cbnz	r2, 800a566 <__mdiff+0xd6>
 800a55c:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 800a560:	3e01      	subs	r6, #1
 800a562:	2a00      	cmp	r2, #0
 800a564:	d0fa      	beq.n	800a55c <__mdiff+0xcc>
 800a566:	f8cb 6010 	str.w	r6, [fp, #16]
 800a56a:	4658      	mov	r0, fp
 800a56c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a570:	4620      	mov	r0, r4
 800a572:	4629      	mov	r1, r5
 800a574:	f7ff fcf8 	bl	8009f68 <_Balloc>
 800a578:	2301      	movs	r3, #1
 800a57a:	4683      	mov	fp, r0
 800a57c:	6145      	str	r5, [r0, #20]
 800a57e:	6103      	str	r3, [r0, #16]
 800a580:	4658      	mov	r0, fp
 800a582:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a586:	bf00      	nop

0800a588 <__ulp>:
 800a588:	2300      	movs	r3, #0
 800a58a:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 800a58e:	ea01 0303 	and.w	r3, r1, r3
 800a592:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
 800a596:	2b00      	cmp	r3, #0
 800a598:	dd02      	ble.n	800a5a0 <__ulp+0x18>
 800a59a:	4619      	mov	r1, r3
 800a59c:	2000      	movs	r0, #0
 800a59e:	4770      	bx	lr
 800a5a0:	425b      	negs	r3, r3
 800a5a2:	151b      	asrs	r3, r3, #20
 800a5a4:	2b13      	cmp	r3, #19
 800a5a6:	dd0d      	ble.n	800a5c4 <__ulp+0x3c>
 800a5a8:	3b14      	subs	r3, #20
 800a5aa:	2100      	movs	r1, #0
 800a5ac:	2b1e      	cmp	r3, #30
 800a5ae:	dd02      	ble.n	800a5b6 <__ulp+0x2e>
 800a5b0:	2301      	movs	r3, #1
 800a5b2:	4618      	mov	r0, r3
 800a5b4:	4770      	bx	lr
 800a5b6:	2201      	movs	r2, #1
 800a5b8:	f1c3 031f 	rsb	r3, r3, #31
 800a5bc:	fa12 f303 	lsls.w	r3, r2, r3
 800a5c0:	4618      	mov	r0, r3
 800a5c2:	4770      	bx	lr
 800a5c4:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 800a5c8:	2000      	movs	r0, #0
 800a5ca:	fa52 f103 	asrs.w	r1, r2, r3
 800a5ce:	4770      	bx	lr

0800a5d0 <__b2d>:
 800a5d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a5d4:	f100 0614 	add.w	r6, r0, #20
 800a5d8:	6904      	ldr	r4, [r0, #16]
 800a5da:	460f      	mov	r7, r1
 800a5dc:	3404      	adds	r4, #4
 800a5de:	f850 5024 	ldr.w	r5, [r0, r4, lsl #2]
 800a5e2:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 800a5e6:	46a0      	mov	r8, r4
 800a5e8:	4628      	mov	r0, r5
 800a5ea:	f7ff fd9b 	bl	800a124 <__hi0bits>
 800a5ee:	280a      	cmp	r0, #10
 800a5f0:	f1c0 0320 	rsb	r3, r0, #32
 800a5f4:	603b      	str	r3, [r7, #0]
 800a5f6:	dc15      	bgt.n	800a624 <__b2d+0x54>
 800a5f8:	f1c0 010b 	rsb	r1, r0, #11
 800a5fc:	fa35 f701 	lsrs.w	r7, r5, r1
 800a600:	42a6      	cmp	r6, r4
 800a602:	f047 577e 	orr.w	r7, r7, #1065353216	; 0x3f800000
 800a606:	f447 03e0 	orr.w	r3, r7, #7340032	; 0x700000
 800a60a:	d233      	bcs.n	800a674 <__b2d+0xa4>
 800a60c:	f854 4c04 	ldr.w	r4, [r4, #-4]
 800a610:	fa34 f101 	lsrs.w	r1, r4, r1
 800a614:	3015      	adds	r0, #21
 800a616:	4085      	lsls	r5, r0
 800a618:	ea41 0205 	orr.w	r2, r1, r5
 800a61c:	4610      	mov	r0, r2
 800a61e:	4619      	mov	r1, r3
 800a620:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a624:	42a6      	cmp	r6, r4
 800a626:	d321      	bcc.n	800a66c <__b2d+0x9c>
 800a628:	2100      	movs	r1, #0
 800a62a:	380b      	subs	r0, #11
 800a62c:	bf02      	ittt	eq
 800a62e:	f045 557e 	orreq.w	r5, r5, #1065353216	; 0x3f800000
 800a632:	460a      	moveq	r2, r1
 800a634:	f445 03e0 	orreq.w	r3, r5, #7340032	; 0x700000
 800a638:	d0f0      	beq.n	800a61c <__b2d+0x4c>
 800a63a:	4085      	lsls	r5, r0
 800a63c:	f1c0 0720 	rsb	r7, r0, #32
 800a640:	f045 557e 	orr.w	r5, r5, #1065353216	; 0x3f800000
 800a644:	42b4      	cmp	r4, r6
 800a646:	fa21 fc07 	lsr.w	ip, r1, r7
 800a64a:	f445 05e0 	orr.w	r5, r5, #7340032	; 0x700000
 800a64e:	ea45 030c 	orr.w	r3, r5, ip
 800a652:	d911      	bls.n	800a678 <__b2d+0xa8>
 800a654:	f854 4c04 	ldr.w	r4, [r4, #-4]
 800a658:	fa34 f707 	lsrs.w	r7, r4, r7
 800a65c:	fa11 f000 	lsls.w	r0, r1, r0
 800a660:	4619      	mov	r1, r3
 800a662:	ea47 0200 	orr.w	r2, r7, r0
 800a666:	4610      	mov	r0, r2
 800a668:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a66c:	3c04      	subs	r4, #4
 800a66e:	f858 1c04 	ldr.w	r1, [r8, #-4]
 800a672:	e7da      	b.n	800a62a <__b2d+0x5a>
 800a674:	2100      	movs	r1, #0
 800a676:	e7cd      	b.n	800a614 <__b2d+0x44>
 800a678:	2700      	movs	r7, #0
 800a67a:	e7ef      	b.n	800a65c <__b2d+0x8c>

0800a67c <__d2b>:
 800a67c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800a680:	b083      	sub	sp, #12
 800a682:	2101      	movs	r1, #1
 800a684:	461d      	mov	r5, r3
 800a686:	4614      	mov	r4, r2
 800a688:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 800a68a:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800a68c:	f7ff fc6c 	bl	8009f68 <_Balloc>
 800a690:	f3c5 590a 	ubfx	r9, r5, #20, #11
 800a694:	f025 437f 	bic.w	r3, r5, #4278190080	; 0xff000000
 800a698:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800a69c:	9300      	str	r3, [sp, #0]
 800a69e:	4680      	mov	r8, r0
 800a6a0:	f1b9 0f00 	cmp.w	r9, #0
 800a6a4:	d002      	beq.n	800a6ac <__d2b+0x30>
 800a6a6:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800a6aa:	9300      	str	r3, [sp, #0]
 800a6ac:	2c00      	cmp	r4, #0
 800a6ae:	d025      	beq.n	800a6fc <__d2b+0x80>
 800a6b0:	a802      	add	r0, sp, #8
 800a6b2:	f840 4d04 	str.w	r4, [r0, #-4]!
 800a6b6:	f7ff fd55 	bl	800a164 <__lo0bits>
 800a6ba:	2800      	cmp	r0, #0
 800a6bc:	d136      	bne.n	800a72c <__d2b+0xb0>
 800a6be:	9a01      	ldr	r2, [sp, #4]
 800a6c0:	9b00      	ldr	r3, [sp, #0]
 800a6c2:	f8c8 2014 	str.w	r2, [r8, #20]
 800a6c6:	2b00      	cmp	r3, #0
 800a6c8:	bf0c      	ite	eq
 800a6ca:	2401      	moveq	r4, #1
 800a6cc:	2402      	movne	r4, #2
 800a6ce:	f8c8 3018 	str.w	r3, [r8, #24]
 800a6d2:	f8c8 4010 	str.w	r4, [r8, #16]
 800a6d6:	f1b9 0f00 	cmp.w	r9, #0
 800a6da:	d11d      	bne.n	800a718 <__d2b+0x9c>
 800a6dc:	eb08 0384 	add.w	r3, r8, r4, lsl #2
 800a6e0:	f5a0 6086 	sub.w	r0, r0, #1072	; 0x430
 800a6e4:	3802      	subs	r0, #2
 800a6e6:	6038      	str	r0, [r7, #0]
 800a6e8:	6918      	ldr	r0, [r3, #16]
 800a6ea:	0164      	lsls	r4, r4, #5
 800a6ec:	f7ff fd1a 	bl	800a124 <__hi0bits>
 800a6f0:	1a24      	subs	r4, r4, r0
 800a6f2:	6034      	str	r4, [r6, #0]
 800a6f4:	4640      	mov	r0, r8
 800a6f6:	b003      	add	sp, #12
 800a6f8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800a6fc:	4668      	mov	r0, sp
 800a6fe:	f7ff fd31 	bl	800a164 <__lo0bits>
 800a702:	2301      	movs	r3, #1
 800a704:	461c      	mov	r4, r3
 800a706:	f8c8 3010 	str.w	r3, [r8, #16]
 800a70a:	9b00      	ldr	r3, [sp, #0]
 800a70c:	f8c8 3014 	str.w	r3, [r8, #20]
 800a710:	3020      	adds	r0, #32
 800a712:	f1b9 0f00 	cmp.w	r9, #0
 800a716:	d0e1      	beq.n	800a6dc <__d2b+0x60>
 800a718:	f5a9 6986 	sub.w	r9, r9, #1072	; 0x430
 800a71c:	f1c0 0335 	rsb	r3, r0, #53	; 0x35
 800a720:	f1a9 0903 	sub.w	r9, r9, #3
 800a724:	4448      	add	r0, r9
 800a726:	6038      	str	r0, [r7, #0]
 800a728:	6033      	str	r3, [r6, #0]
 800a72a:	e7e3      	b.n	800a6f4 <__d2b+0x78>
 800a72c:	9b00      	ldr	r3, [sp, #0]
 800a72e:	f1c0 0220 	rsb	r2, r0, #32
 800a732:	9901      	ldr	r1, [sp, #4]
 800a734:	fa13 f202 	lsls.w	r2, r3, r2
 800a738:	40c3      	lsrs	r3, r0
 800a73a:	430a      	orrs	r2, r1
 800a73c:	9300      	str	r3, [sp, #0]
 800a73e:	f8c8 2014 	str.w	r2, [r8, #20]
 800a742:	e7c0      	b.n	800a6c6 <__d2b+0x4a>

0800a744 <__ratio>:
 800a744:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a748:	b082      	sub	sp, #8
 800a74a:	4688      	mov	r8, r1
 800a74c:	a901      	add	r1, sp, #4
 800a74e:	4606      	mov	r6, r0
 800a750:	f7ff ff3e 	bl	800a5d0 <__b2d>
 800a754:	460d      	mov	r5, r1
 800a756:	4604      	mov	r4, r0
 800a758:	4669      	mov	r1, sp
 800a75a:	4640      	mov	r0, r8
 800a75c:	f7ff ff38 	bl	800a5d0 <__b2d>
 800a760:	f8d8 e010 	ldr.w	lr, [r8, #16]
 800a764:	f8d6 c010 	ldr.w	ip, [r6, #16]
 800a768:	f8dd 8004 	ldr.w	r8, [sp, #4]
 800a76c:	ebce 0c0c 	rsb	ip, lr, ip
 800a770:	f8dd e000 	ldr.w	lr, [sp]
 800a774:	ea4f 1c4c 	mov.w	ip, ip, lsl #5
 800a778:	ebce 0e08 	rsb	lr, lr, r8
 800a77c:	44e6      	add	lr, ip
 800a77e:	f1be 0f00 	cmp.w	lr, #0
 800a782:	ea4f 5e0e 	mov.w	lr, lr, lsl #20
 800a786:	bfc4      	itt	gt
 800a788:	eb0e 0705 	addgt.w	r7, lr, r5
 800a78c:	463d      	movgt	r5, r7
 800a78e:	460b      	mov	r3, r1
 800a790:	bfd8      	it	le
 800a792:	ebce 0101 	rsble	r1, lr, r1
 800a796:	4602      	mov	r2, r0
 800a798:	bfdc      	itt	le
 800a79a:	460b      	movle	r3, r1
 800a79c:	4602      	movle	r2, r0
 800a79e:	4629      	mov	r1, r5
 800a7a0:	4620      	mov	r0, r4
 800a7a2:	f001 fd69 	bl	800c278 <__aeabi_ddiv>
 800a7a6:	b002      	add	sp, #8
 800a7a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800a7ac <_mprec_log10>:
 800a7ac:	2817      	cmp	r0, #23
 800a7ae:	b510      	push	{r4, lr}
 800a7b0:	4604      	mov	r4, r0
 800a7b2:	dd0c      	ble.n	800a7ce <_mprec_log10+0x22>
 800a7b4:	2100      	movs	r1, #0
 800a7b6:	2000      	movs	r0, #0
 800a7b8:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
 800a7bc:	2300      	movs	r3, #0
 800a7be:	2200      	movs	r2, #0
 800a7c0:	f2c4 0324 	movt	r3, #16420	; 0x4024
 800a7c4:	f001 fc2e 	bl	800c024 <__aeabi_dmul>
 800a7c8:	3c01      	subs	r4, #1
 800a7ca:	d1f7      	bne.n	800a7bc <_mprec_log10+0x10>
 800a7cc:	bd10      	pop	{r4, pc}
 800a7ce:	f64c 73c8 	movw	r3, #53192	; 0xcfc8
 800a7d2:	f6c0 0300 	movt	r3, #2048	; 0x800
 800a7d6:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 800a7da:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800a7de:	bd10      	pop	{r4, pc}

0800a7e0 <__copybits>:
 800a7e0:	b470      	push	{r4, r5, r6}
 800a7e2:	3901      	subs	r1, #1
 800a7e4:	6916      	ldr	r6, [r2, #16]
 800a7e6:	f102 0314 	add.w	r3, r2, #20
 800a7ea:	1149      	asrs	r1, r1, #5
 800a7ec:	3101      	adds	r1, #1
 800a7ee:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 800a7f2:	3614      	adds	r6, #20
 800a7f4:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 800a7f8:	42b3      	cmp	r3, r6
 800a7fa:	d20c      	bcs.n	800a816 <__copybits+0x36>
 800a7fc:	4604      	mov	r4, r0
 800a7fe:	f853 5b04 	ldr.w	r5, [r3], #4
 800a802:	429e      	cmp	r6, r3
 800a804:	f844 5b04 	str.w	r5, [r4], #4
 800a808:	d8f9      	bhi.n	800a7fe <__copybits+0x1e>
 800a80a:	1ab3      	subs	r3, r6, r2
 800a80c:	3b15      	subs	r3, #21
 800a80e:	f023 0303 	bic.w	r3, r3, #3
 800a812:	3304      	adds	r3, #4
 800a814:	18c0      	adds	r0, r0, r3
 800a816:	4281      	cmp	r1, r0
 800a818:	d904      	bls.n	800a824 <__copybits+0x44>
 800a81a:	2300      	movs	r3, #0
 800a81c:	f840 3b04 	str.w	r3, [r0], #4
 800a820:	4281      	cmp	r1, r0
 800a822:	d8fb      	bhi.n	800a81c <__copybits+0x3c>
 800a824:	bc70      	pop	{r4, r5, r6}
 800a826:	4770      	bx	lr

0800a828 <__any_on>:
 800a828:	6902      	ldr	r2, [r0, #16]
 800a82a:	114b      	asrs	r3, r1, #5
 800a82c:	b410      	push	{r4}
 800a82e:	429a      	cmp	r2, r3
 800a830:	db11      	blt.n	800a856 <__any_on+0x2e>
 800a832:	dd0f      	ble.n	800a854 <__any_on+0x2c>
 800a834:	f011 011f 	ands.w	r1, r1, #31
 800a838:	d00c      	beq.n	800a854 <__any_on+0x2c>
 800a83a:	461a      	mov	r2, r3
 800a83c:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800a840:	695b      	ldr	r3, [r3, #20]
 800a842:	fa33 f401 	lsrs.w	r4, r3, r1
 800a846:	fa14 f101 	lsls.w	r1, r4, r1
 800a84a:	4299      	cmp	r1, r3
 800a84c:	d003      	beq.n	800a856 <__any_on+0x2e>
 800a84e:	2001      	movs	r0, #1
 800a850:	bc10      	pop	{r4}
 800a852:	4770      	bx	lr
 800a854:	461a      	mov	r2, r3
 800a856:	3204      	adds	r2, #4
 800a858:	f100 0114 	add.w	r1, r0, #20
 800a85c:	eb00 0382 	add.w	r3, r0, r2, lsl #2
 800a860:	1d1c      	adds	r4, r3, #4
 800a862:	42a1      	cmp	r1, r4
 800a864:	d20b      	bcs.n	800a87e <__any_on+0x56>
 800a866:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 800a86a:	2a00      	cmp	r2, #0
 800a86c:	d1ef      	bne.n	800a84e <__any_on+0x26>
 800a86e:	4299      	cmp	r1, r3
 800a870:	d205      	bcs.n	800a87e <__any_on+0x56>
 800a872:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 800a876:	2a00      	cmp	r2, #0
 800a878:	d1e9      	bne.n	800a84e <__any_on+0x26>
 800a87a:	4299      	cmp	r1, r3
 800a87c:	d3f9      	bcc.n	800a872 <__any_on+0x4a>
 800a87e:	2000      	movs	r0, #0
 800a880:	e7e6      	b.n	800a850 <__any_on+0x28>
 800a882:	bf00      	nop

0800a884 <_open_r>:
 800a884:	b538      	push	{r3, r4, r5, lr}
 800a886:	f642 248c 	movw	r4, #10892	; 0x2a8c
 800a88a:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800a88e:	4605      	mov	r5, r0
 800a890:	4608      	mov	r0, r1
 800a892:	4611      	mov	r1, r2
 800a894:	461a      	mov	r2, r3
 800a896:	2300      	movs	r3, #0
 800a898:	6023      	str	r3, [r4, #0]
 800a89a:	f7f6 f99d 	bl	8000bd8 <_open>
 800a89e:	f1b0 3fff 	cmp.w	r0, #4294967295
 800a8a2:	d000      	beq.n	800a8a6 <_open_r+0x22>
 800a8a4:	bd38      	pop	{r3, r4, r5, pc}
 800a8a6:	6823      	ldr	r3, [r4, #0]
 800a8a8:	2b00      	cmp	r3, #0
 800a8aa:	d0fb      	beq.n	800a8a4 <_open_r+0x20>
 800a8ac:	602b      	str	r3, [r5, #0]
 800a8ae:	bd38      	pop	{r3, r4, r5, pc}

0800a8b0 <_read_r>:
 800a8b0:	b538      	push	{r3, r4, r5, lr}
 800a8b2:	f642 248c 	movw	r4, #10892	; 0x2a8c
 800a8b6:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800a8ba:	4605      	mov	r5, r0
 800a8bc:	4608      	mov	r0, r1
 800a8be:	4611      	mov	r1, r2
 800a8c0:	461a      	mov	r2, r3
 800a8c2:	2300      	movs	r3, #0
 800a8c4:	6023      	str	r3, [r4, #0]
 800a8c6:	f7f6 f9a3 	bl	8000c10 <_read>
 800a8ca:	f1b0 3fff 	cmp.w	r0, #4294967295
 800a8ce:	d000      	beq.n	800a8d2 <_read_r+0x22>
 800a8d0:	bd38      	pop	{r3, r4, r5, pc}
 800a8d2:	6823      	ldr	r3, [r4, #0]
 800a8d4:	2b00      	cmp	r3, #0
 800a8d6:	d0fb      	beq.n	800a8d0 <_read_r+0x20>
 800a8d8:	602b      	str	r3, [r5, #0]
 800a8da:	bd38      	pop	{r3, r4, r5, pc}

0800a8dc <cleanup_glue>:
 800a8dc:	b570      	push	{r4, r5, r6, lr}
 800a8de:	460c      	mov	r4, r1
 800a8e0:	6809      	ldr	r1, [r1, #0]
 800a8e2:	4605      	mov	r5, r0
 800a8e4:	b109      	cbz	r1, 800a8ea <cleanup_glue+0xe>
 800a8e6:	f7ff fff9 	bl	800a8dc <cleanup_glue>
 800a8ea:	4628      	mov	r0, r5
 800a8ec:	4621      	mov	r1, r4
 800a8ee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800a8f2:	f7ff b87f 	b.w	80099f4 <_free_r>
 800a8f6:	bf00      	nop

0800a8f8 <_reclaim_reent>:
 800a8f8:	f240 2378 	movw	r3, #632	; 0x278
 800a8fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800a900:	b570      	push	{r4, r5, r6, lr}
 800a902:	4605      	mov	r5, r0
 800a904:	681b      	ldr	r3, [r3, #0]
 800a906:	4298      	cmp	r0, r3
 800a908:	d04a      	beq.n	800a9a0 <_reclaim_reent+0xa8>
 800a90a:	6a42      	ldr	r2, [r0, #36]	; 0x24
 800a90c:	b302      	cbz	r2, 800a950 <_reclaim_reent+0x58>
 800a90e:	68d3      	ldr	r3, [r2, #12]
 800a910:	b1cb      	cbz	r3, 800a946 <_reclaim_reent+0x4e>
 800a912:	2100      	movs	r1, #0
 800a914:	460e      	mov	r6, r1
 800a916:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 800a91a:	b909      	cbnz	r1, 800a920 <_reclaim_reent+0x28>
 800a91c:	e008      	b.n	800a930 <_reclaim_reent+0x38>
 800a91e:	4621      	mov	r1, r4
 800a920:	680c      	ldr	r4, [r1, #0]
 800a922:	4628      	mov	r0, r5
 800a924:	f7ff f866 	bl	80099f4 <_free_r>
 800a928:	2c00      	cmp	r4, #0
 800a92a:	d1f8      	bne.n	800a91e <_reclaim_reent+0x26>
 800a92c:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800a92e:	68d3      	ldr	r3, [r2, #12]
 800a930:	3601      	adds	r6, #1
 800a932:	2e20      	cmp	r6, #32
 800a934:	4631      	mov	r1, r6
 800a936:	d001      	beq.n	800a93c <_reclaim_reent+0x44>
 800a938:	68d3      	ldr	r3, [r2, #12]
 800a93a:	e7ec      	b.n	800a916 <_reclaim_reent+0x1e>
 800a93c:	4628      	mov	r0, r5
 800a93e:	4619      	mov	r1, r3
 800a940:	f7ff f858 	bl	80099f4 <_free_r>
 800a944:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800a946:	6811      	ldr	r1, [r2, #0]
 800a948:	b111      	cbz	r1, 800a950 <_reclaim_reent+0x58>
 800a94a:	4628      	mov	r0, r5
 800a94c:	f7ff f852 	bl	80099f4 <_free_r>
 800a950:	6969      	ldr	r1, [r5, #20]
 800a952:	b111      	cbz	r1, 800a95a <_reclaim_reent+0x62>
 800a954:	4628      	mov	r0, r5
 800a956:	f7ff f84d 	bl	80099f4 <_free_r>
 800a95a:	6a69      	ldr	r1, [r5, #36]	; 0x24
 800a95c:	b111      	cbz	r1, 800a964 <_reclaim_reent+0x6c>
 800a95e:	4628      	mov	r0, r5
 800a960:	f7ff f848 	bl	80099f4 <_free_r>
 800a964:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 800a966:	b111      	cbz	r1, 800a96e <_reclaim_reent+0x76>
 800a968:	4628      	mov	r0, r5
 800a96a:	f7ff f843 	bl	80099f4 <_free_r>
 800a96e:	6be9      	ldr	r1, [r5, #60]	; 0x3c
 800a970:	b111      	cbz	r1, 800a978 <_reclaim_reent+0x80>
 800a972:	4628      	mov	r0, r5
 800a974:	f7ff f83e 	bl	80099f4 <_free_r>
 800a978:	6c29      	ldr	r1, [r5, #64]	; 0x40
 800a97a:	b111      	cbz	r1, 800a982 <_reclaim_reent+0x8a>
 800a97c:	4628      	mov	r0, r5
 800a97e:	f7ff f839 	bl	80099f4 <_free_r>
 800a982:	6cab      	ldr	r3, [r5, #72]	; 0x48
 800a984:	b12b      	cbz	r3, 800a992 <_reclaim_reent+0x9a>
 800a986:	f8d3 1088 	ldr.w	r1, [r3, #136]	; 0x88
 800a98a:	b111      	cbz	r1, 800a992 <_reclaim_reent+0x9a>
 800a98c:	4628      	mov	r0, r5
 800a98e:	f7ff f831 	bl	80099f4 <_free_r>
 800a992:	6b69      	ldr	r1, [r5, #52]	; 0x34
 800a994:	b111      	cbz	r1, 800a99c <_reclaim_reent+0xa4>
 800a996:	4628      	mov	r0, r5
 800a998:	f7ff f82c 	bl	80099f4 <_free_r>
 800a99c:	69ab      	ldr	r3, [r5, #24]
 800a99e:	b903      	cbnz	r3, 800a9a2 <_reclaim_reent+0xaa>
 800a9a0:	bd70      	pop	{r4, r5, r6, pc}
 800a9a2:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800a9a4:	4628      	mov	r0, r5
 800a9a6:	4798      	blx	r3
 800a9a8:	f8d5 10d8 	ldr.w	r1, [r5, #216]	; 0xd8
 800a9ac:	2900      	cmp	r1, #0
 800a9ae:	d0f7      	beq.n	800a9a0 <_reclaim_reent+0xa8>
 800a9b0:	4628      	mov	r0, r5
 800a9b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800a9b6:	e791      	b.n	800a8dc <cleanup_glue>

0800a9b8 <_wrapup_reent>:
 800a9b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a9ba:	4607      	mov	r7, r0
 800a9bc:	b198      	cbz	r0, 800a9e6 <_wrapup_reent+0x2e>
 800a9be:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800a9c0:	b163      	cbz	r3, 800a9dc <_wrapup_reent+0x24>
 800a9c2:	685e      	ldr	r6, [r3, #4]
 800a9c4:	2e00      	cmp	r6, #0
 800a9c6:	dd09      	ble.n	800a9dc <_wrapup_reent+0x24>
 800a9c8:	1cb5      	adds	r5, r6, #2
 800a9ca:	2400      	movs	r4, #0
 800a9cc:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 800a9d0:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 800a9d4:	3401      	adds	r4, #1
 800a9d6:	4798      	blx	r3
 800a9d8:	42b4      	cmp	r4, r6
 800a9da:	d1f9      	bne.n	800a9d0 <_wrapup_reent+0x18>
 800a9dc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a9de:	b10b      	cbz	r3, 800a9e4 <_wrapup_reent+0x2c>
 800a9e0:	4638      	mov	r0, r7
 800a9e2:	4798      	blx	r3
 800a9e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a9e6:	f240 2378 	movw	r3, #632	; 0x278
 800a9ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800a9ee:	681f      	ldr	r7, [r3, #0]
 800a9f0:	e7e5      	b.n	800a9be <_wrapup_reent+0x6>
 800a9f2:	bf00      	nop

0800a9f4 <__fpclassifyd>:
 800a9f4:	ea50 0301 	orrs.w	r3, r0, r1
 800a9f8:	b410      	push	{r4}
 800a9fa:	d03c      	beq.n	800aa76 <__fpclassifyd+0x82>
 800a9fc:	f1d0 0201 	rsbs	r2, r0, #1
 800aa00:	bf38      	it	cc
 800aa02:	2200      	movcc	r2, #0
 800aa04:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 800aa08:	bf14      	ite	ne
 800aa0a:	2300      	movne	r3, #0
 800aa0c:	f002 0301 	andeq.w	r3, r2, #1
 800aa10:	2b00      	cmp	r3, #0
 800aa12:	d130      	bne.n	800aa76 <__fpclassifyd+0x82>
 800aa14:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800aa18:	f5a1 1080 	sub.w	r0, r1, #1048576	; 0x100000
 800aa1c:	f6c7 73df 	movt	r3, #32735	; 0x7fdf
 800aa20:	f101 44fe 	add.w	r4, r1, #2130706432	; 0x7f000000
 800aa24:	4298      	cmp	r0, r3
 800aa26:	f504 0470 	add.w	r4, r4, #15728640	; 0xf00000
 800aa2a:	bf8c      	ite	hi
 800aa2c:	2000      	movhi	r0, #0
 800aa2e:	2001      	movls	r0, #1
 800aa30:	429c      	cmp	r4, r3
 800aa32:	bf8c      	ite	hi
 800aa34:	4603      	movhi	r3, r0
 800aa36:	f040 0301 	orrls.w	r3, r0, #1
 800aa3a:	2b00      	cmp	r3, #0
 800aa3c:	d120      	bne.n	800aa80 <__fpclassifyd+0x8c>
 800aa3e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 800aa42:	f101 4000 	add.w	r0, r1, #2147483648	; 0x80000000
 800aa46:	bf2c      	ite	cs
 800aa48:	2300      	movcs	r3, #0
 800aa4a:	2301      	movcc	r3, #1
 800aa4c:	f5b0 1f80 	cmp.w	r0, #1048576	; 0x100000
 800aa50:	bf38      	it	cc
 800aa52:	f043 0301 	orrcc.w	r3, r3, #1
 800aa56:	b98b      	cbnz	r3, 800aa7c <__fpclassifyd+0x88>
 800aa58:	f511 1f80 	cmn.w	r1, #1048576	; 0x100000
 800aa5c:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 800aa60:	bf14      	ite	ne
 800aa62:	2000      	movne	r0, #0
 800aa64:	2001      	moveq	r0, #1
 800aa66:	4299      	cmp	r1, r3
 800aa68:	bf14      	ite	ne
 800aa6a:	4601      	movne	r1, r0
 800aa6c:	f040 0101 	orreq.w	r1, r0, #1
 800aa70:	ea02 0001 	and.w	r0, r2, r1
 800aa74:	e000      	b.n	800aa78 <__fpclassifyd+0x84>
 800aa76:	2002      	movs	r0, #2
 800aa78:	bc10      	pop	{r4}
 800aa7a:	4770      	bx	lr
 800aa7c:	2003      	movs	r0, #3
 800aa7e:	e7fb      	b.n	800aa78 <__fpclassifyd+0x84>
 800aa80:	2004      	movs	r0, #4
 800aa82:	e7f9      	b.n	800aa78 <__fpclassifyd+0x84>

0800aa84 <__sread>:
 800aa84:	b510      	push	{r4, lr}
 800aa86:	460c      	mov	r4, r1
 800aa88:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800aa8c:	f7ff ff10 	bl	800a8b0 <_read_r>
 800aa90:	2800      	cmp	r0, #0
 800aa92:	bfab      	itete	ge
 800aa94:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 800aa96:	89a3      	ldrhlt	r3, [r4, #12]
 800aa98:	181b      	addge	r3, r3, r0
 800aa9a:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 800aa9e:	bfac      	ite	ge
 800aaa0:	6563      	strge	r3, [r4, #84]	; 0x54
 800aaa2:	81a3      	strhlt	r3, [r4, #12]
 800aaa4:	bd10      	pop	{r4, pc}
 800aaa6:	bf00      	nop

0800aaa8 <__seofread>:
 800aaa8:	2000      	movs	r0, #0
 800aaaa:	4770      	bx	lr

0800aaac <__swrite>:
 800aaac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800aab0:	461d      	mov	r5, r3
 800aab2:	898b      	ldrh	r3, [r1, #12]
 800aab4:	460c      	mov	r4, r1
 800aab6:	4607      	mov	r7, r0
 800aab8:	4616      	mov	r6, r2
 800aaba:	f413 7f80 	tst.w	r3, #256	; 0x100
 800aabe:	d006      	beq.n	800aace <__swrite+0x22>
 800aac0:	2302      	movs	r3, #2
 800aac2:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800aac6:	2200      	movs	r2, #0
 800aac8:	f000 feee 	bl	800b8a8 <_lseek_r>
 800aacc:	89a3      	ldrh	r3, [r4, #12]
 800aace:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800aad2:	4638      	mov	r0, r7
 800aad4:	81a3      	strh	r3, [r4, #12]
 800aad6:	4632      	mov	r2, r6
 800aad8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800aadc:	462b      	mov	r3, r5
 800aade:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800aae2:	f7fd bd21 	b.w	8008528 <_write_r>
 800aae6:	bf00      	nop

0800aae8 <__sseek>:
 800aae8:	b510      	push	{r4, lr}
 800aaea:	460c      	mov	r4, r1
 800aaec:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800aaf0:	f000 feda 	bl	800b8a8 <_lseek_r>
 800aaf4:	89a3      	ldrh	r3, [r4, #12]
 800aaf6:	f1b0 3fff 	cmp.w	r0, #4294967295
 800aafa:	bf15      	itete	ne
 800aafc:	6560      	strne	r0, [r4, #84]	; 0x54
 800aafe:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 800ab02:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 800ab06:	81a3      	strheq	r3, [r4, #12]
 800ab08:	bf18      	it	ne
 800ab0a:	81a3      	strhne	r3, [r4, #12]
 800ab0c:	bd10      	pop	{r4, pc}
 800ab0e:	bf00      	nop

0800ab10 <__sclose>:
 800ab10:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800ab14:	f000 be52 	b.w	800b7bc <_close_r>

0800ab18 <strlen>:
 800ab18:	f020 0103 	bic.w	r1, r0, #3
 800ab1c:	f010 0003 	ands.w	r0, r0, #3
 800ab20:	f1c0 0000 	rsb	r0, r0, #0
 800ab24:	f851 3b04 	ldr.w	r3, [r1], #4
 800ab28:	f100 0c04 	add.w	ip, r0, #4
 800ab2c:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 800ab30:	f06f 0200 	mvn.w	r2, #0
 800ab34:	bf1c      	itt	ne
 800ab36:	fa22 f20c 	lsrne.w	r2, r2, ip
 800ab3a:	4313      	orrne	r3, r2
 800ab3c:	f04f 0c01 	mov.w	ip, #1
 800ab40:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 800ab44:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 800ab48:	eba3 020c 	sub.w	r2, r3, ip
 800ab4c:	ea22 0203 	bic.w	r2, r2, r3
 800ab50:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 800ab54:	bf04      	itt	eq
 800ab56:	f851 3b04 	ldreq.w	r3, [r1], #4
 800ab5a:	3004      	addeq	r0, #4
 800ab5c:	d0f4      	beq.n	800ab48 <strlen+0x30>
 800ab5e:	f013 0fff 	tst.w	r3, #255	; 0xff
 800ab62:	bf1f      	itttt	ne
 800ab64:	3001      	addne	r0, #1
 800ab66:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
 800ab6a:	3001      	addne	r0, #1
 800ab6c:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
 800ab70:	bf18      	it	ne
 800ab72:	3001      	addne	r0, #1
 800ab74:	4770      	bx	lr
 800ab76:	bf00      	nop

0800ab78 <__ssprint_r>:
 800ab78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ab7c:	b083      	sub	sp, #12
 800ab7e:	4691      	mov	r9, r2
 800ab80:	460d      	mov	r5, r1
 800ab82:	9001      	str	r0, [sp, #4]
 800ab84:	6890      	ldr	r0, [r2, #8]
 800ab86:	6817      	ldr	r7, [r2, #0]
 800ab88:	2800      	cmp	r0, #0
 800ab8a:	d077      	beq.n	800ac7c <__ssprint_r+0x104>
 800ab8c:	f04f 0a00 	mov.w	sl, #0
 800ab90:	6808      	ldr	r0, [r1, #0]
 800ab92:	688b      	ldr	r3, [r1, #8]
 800ab94:	4654      	mov	r4, sl
 800ab96:	2c00      	cmp	r4, #0
 800ab98:	d04c      	beq.n	800ac34 <__ssprint_r+0xbc>
 800ab9a:	429c      	cmp	r4, r3
 800ab9c:	461e      	mov	r6, r3
 800ab9e:	4698      	mov	r8, r3
 800aba0:	bf3c      	itt	cc
 800aba2:	4626      	movcc	r6, r4
 800aba4:	46a0      	movcc	r8, r4
 800aba6:	d335      	bcc.n	800ac14 <__ssprint_r+0x9c>
 800aba8:	89ab      	ldrh	r3, [r5, #12]
 800abaa:	f413 6f90 	tst.w	r3, #1152	; 0x480
 800abae:	d031      	beq.n	800ac14 <__ssprint_r+0x9c>
 800abb0:	696a      	ldr	r2, [r5, #20]
 800abb2:	f104 0e01 	add.w	lr, r4, #1
 800abb6:	6929      	ldr	r1, [r5, #16]
 800abb8:	eb02 0b42 	add.w	fp, r2, r2, lsl #1
 800abbc:	1a46      	subs	r6, r0, r1
 800abbe:	eb0e 0006 	add.w	r0, lr, r6
 800abc2:	eb0b 7bdb 	add.w	fp, fp, fp, lsr #31
 800abc6:	ea4f 0b6b 	mov.w	fp, fp, asr #1
 800abca:	4583      	cmp	fp, r0
 800abcc:	465a      	mov	r2, fp
 800abce:	bf3c      	itt	cc
 800abd0:	4683      	movcc	fp, r0
 800abd2:	4602      	movcc	r2, r0
 800abd4:	f413 6f80 	tst.w	r3, #1024	; 0x400
 800abd8:	d031      	beq.n	800ac3e <__ssprint_r+0xc6>
 800abda:	9801      	ldr	r0, [sp, #4]
 800abdc:	4611      	mov	r1, r2
 800abde:	f7fb fc87 	bl	80064f0 <_malloc_r>
 800abe2:	4680      	mov	r8, r0
 800abe4:	2800      	cmp	r0, #0
 800abe6:	d034      	beq.n	800ac52 <__ssprint_r+0xda>
 800abe8:	6929      	ldr	r1, [r5, #16]
 800abea:	4632      	mov	r2, r6
 800abec:	f7ff f8ba 	bl	8009d64 <memcpy>
 800abf0:	89ab      	ldrh	r3, [r5, #12]
 800abf2:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 800abf6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800abfa:	81ab      	strh	r3, [r5, #12]
 800abfc:	eb08 0006 	add.w	r0, r8, r6
 800ac00:	ebc6 030b 	rsb	r3, r6, fp
 800ac04:	f8c5 8010 	str.w	r8, [r5, #16]
 800ac08:	4626      	mov	r6, r4
 800ac0a:	46a0      	mov	r8, r4
 800ac0c:	6028      	str	r0, [r5, #0]
 800ac0e:	f8c5 b014 	str.w	fp, [r5, #20]
 800ac12:	60ab      	str	r3, [r5, #8]
 800ac14:	4642      	mov	r2, r8
 800ac16:	4651      	mov	r1, sl
 800ac18:	f000 fe5c 	bl	800b8d4 <memmove>
 800ac1c:	f8d9 2008 	ldr.w	r2, [r9, #8]
 800ac20:	68ab      	ldr	r3, [r5, #8]
 800ac22:	6828      	ldr	r0, [r5, #0]
 800ac24:	1b14      	subs	r4, r2, r4
 800ac26:	1b9b      	subs	r3, r3, r6
 800ac28:	60ab      	str	r3, [r5, #8]
 800ac2a:	4440      	add	r0, r8
 800ac2c:	6028      	str	r0, [r5, #0]
 800ac2e:	f8c9 4008 	str.w	r4, [r9, #8]
 800ac32:	b1ec      	cbz	r4, 800ac70 <__ssprint_r+0xf8>
 800ac34:	f8d7 a000 	ldr.w	sl, [r7]
 800ac38:	687c      	ldr	r4, [r7, #4]
 800ac3a:	3708      	adds	r7, #8
 800ac3c:	e7ab      	b.n	800ab96 <__ssprint_r+0x1e>
 800ac3e:	9801      	ldr	r0, [sp, #4]
 800ac40:	f000 fea2 	bl	800b988 <_realloc_r>
 800ac44:	4680      	mov	r8, r0
 800ac46:	2800      	cmp	r0, #0
 800ac48:	d1d8      	bne.n	800abfc <__ssprint_r+0x84>
 800ac4a:	9801      	ldr	r0, [sp, #4]
 800ac4c:	6929      	ldr	r1, [r5, #16]
 800ac4e:	f7fe fed1 	bl	80099f4 <_free_r>
 800ac52:	9a01      	ldr	r2, [sp, #4]
 800ac54:	230c      	movs	r3, #12
 800ac56:	f04f 30ff 	mov.w	r0, #4294967295
 800ac5a:	6013      	str	r3, [r2, #0]
 800ac5c:	2300      	movs	r3, #0
 800ac5e:	89aa      	ldrh	r2, [r5, #12]
 800ac60:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800ac64:	81aa      	strh	r2, [r5, #12]
 800ac66:	f8c9 3008 	str.w	r3, [r9, #8]
 800ac6a:	f8c9 3004 	str.w	r3, [r9, #4]
 800ac6e:	e002      	b.n	800ac76 <__ssprint_r+0xfe>
 800ac70:	4620      	mov	r0, r4
 800ac72:	f8c9 4004 	str.w	r4, [r9, #4]
 800ac76:	b003      	add	sp, #12
 800ac78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ac7c:	6050      	str	r0, [r2, #4]
 800ac7e:	e7fa      	b.n	800ac76 <__ssprint_r+0xfe>

0800ac80 <_svfiprintf_r>:
 800ac80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ac84:	b0ab      	sub	sp, #172	; 0xac
 800ac86:	4689      	mov	r9, r1
 800ac88:	4683      	mov	fp, r0
 800ac8a:	9306      	str	r3, [sp, #24]
 800ac8c:	898b      	ldrh	r3, [r1, #12]
 800ac8e:	f013 0f80 	tst.w	r3, #128	; 0x80
 800ac92:	d003      	beq.n	800ac9c <_svfiprintf_r+0x1c>
 800ac94:	690b      	ldr	r3, [r1, #16]
 800ac96:	2b00      	cmp	r3, #0
 800ac98:	f000 8515 	beq.w	800b6c6 <_svfiprintf_r+0xa46>
 800ac9c:	4617      	mov	r7, r2
 800ac9e:	2300      	movs	r3, #0
 800aca0:	ae0c      	add	r6, sp, #48	; 0x30
 800aca2:	9308      	str	r3, [sp, #32]
 800aca4:	9305      	str	r3, [sp, #20]
 800aca6:	9626      	str	r6, [sp, #152]	; 0x98
 800aca8:	9328      	str	r3, [sp, #160]	; 0xa0
 800acaa:	9327      	str	r3, [sp, #156]	; 0x9c
 800acac:	783b      	ldrb	r3, [r7, #0]
 800acae:	f1b3 0225 	subs.w	r2, r3, #37	; 0x25
 800acb2:	bf18      	it	ne
 800acb4:	2201      	movne	r2, #1
 800acb6:	2b00      	cmp	r3, #0
 800acb8:	bf0c      	ite	eq
 800acba:	2300      	moveq	r3, #0
 800acbc:	f002 0301 	andne.w	r3, r2, #1
 800acc0:	2b00      	cmp	r3, #0
 800acc2:	f000 8360 	beq.w	800b386 <_svfiprintf_r+0x706>
 800acc6:	1c7a      	adds	r2, r7, #1
 800acc8:	4614      	mov	r4, r2
 800acca:	3201      	adds	r2, #1
 800accc:	7823      	ldrb	r3, [r4, #0]
 800acce:	1e19      	subs	r1, r3, #0
 800acd0:	bf18      	it	ne
 800acd2:	2101      	movne	r1, #1
 800acd4:	2b25      	cmp	r3, #37	; 0x25
 800acd6:	bf0c      	ite	eq
 800acd8:	2300      	moveq	r3, #0
 800acda:	f001 0301 	andne.w	r3, r1, #1
 800acde:	2b00      	cmp	r3, #0
 800ace0:	d1f2      	bne.n	800acc8 <_svfiprintf_r+0x48>
 800ace2:	1be5      	subs	r5, r4, r7
 800ace4:	d00e      	beq.n	800ad04 <_svfiprintf_r+0x84>
 800ace6:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800ace8:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800acea:	3301      	adds	r3, #1
 800acec:	6037      	str	r7, [r6, #0]
 800acee:	2b07      	cmp	r3, #7
 800acf0:	6075      	str	r5, [r6, #4]
 800acf2:	442a      	add	r2, r5
 800acf4:	9327      	str	r3, [sp, #156]	; 0x9c
 800acf6:	9228      	str	r2, [sp, #160]	; 0xa0
 800acf8:	f300 83bc 	bgt.w	800b474 <_svfiprintf_r+0x7f4>
 800acfc:	3608      	adds	r6, #8
 800acfe:	9905      	ldr	r1, [sp, #20]
 800ad00:	1949      	adds	r1, r1, r5
 800ad02:	9105      	str	r1, [sp, #20]
 800ad04:	7823      	ldrb	r3, [r4, #0]
 800ad06:	2b00      	cmp	r3, #0
 800ad08:	f000 833f 	beq.w	800b38a <_svfiprintf_r+0x70a>
 800ad0c:	2200      	movs	r2, #0
 800ad0e:	2300      	movs	r3, #0
 800ad10:	9204      	str	r2, [sp, #16]
 800ad12:	1c67      	adds	r7, r4, #1
 800ad14:	f88d 30a7 	strb.w	r3, [sp, #167]	; 0xa7
 800ad18:	f04f 38ff 	mov.w	r8, #4294967295
 800ad1c:	7863      	ldrb	r3, [r4, #1]
 800ad1e:	4692      	mov	sl, r2
 800ad20:	f04f 0c20 	mov.w	ip, #32
 800ad24:	242b      	movs	r4, #43	; 0x2b
 800ad26:	3701      	adds	r7, #1
 800ad28:	f1a3 0220 	sub.w	r2, r3, #32
 800ad2c:	2a58      	cmp	r2, #88	; 0x58
 800ad2e:	f200 824e 	bhi.w	800b1ce <_svfiprintf_r+0x54e>
 800ad32:	e8df f012 	tbh	[pc, r2, lsl #1]
 800ad36:	025a      	.short	0x025a
 800ad38:	024c024c 	.word	0x024c024c
 800ad3c:	024c01fb 	.word	0x024c01fb
 800ad40:	024c024c 	.word	0x024c024c
 800ad44:	024c024c 	.word	0x024c024c
 800ad48:	00fe024c 	.word	0x00fe024c
 800ad4c:	024c0214 	.word	0x024c0214
 800ad50:	0218010a 	.word	0x0218010a
 800ad54:	0210024c 	.word	0x0210024c
 800ad58:	01ff01ff 	.word	0x01ff01ff
 800ad5c:	01ff01ff 	.word	0x01ff01ff
 800ad60:	01ff01ff 	.word	0x01ff01ff
 800ad64:	01ff01ff 	.word	0x01ff01ff
 800ad68:	024c01ff 	.word	0x024c01ff
 800ad6c:	024c024c 	.word	0x024c024c
 800ad70:	024c024c 	.word	0x024c024c
 800ad74:	024c024c 	.word	0x024c024c
 800ad78:	024c024c 	.word	0x024c024c
 800ad7c:	00c7024c 	.word	0x00c7024c
 800ad80:	024c024c 	.word	0x024c024c
 800ad84:	024c024c 	.word	0x024c024c
 800ad88:	024c024c 	.word	0x024c024c
 800ad8c:	024c024c 	.word	0x024c024c
 800ad90:	024c024c 	.word	0x024c024c
 800ad94:	024c00bd 	.word	0x024c00bd
 800ad98:	024c024c 	.word	0x024c024c
 800ad9c:	024c024c 	.word	0x024c024c
 800ada0:	024c0059 	.word	0x024c0059
 800ada4:	016d024c 	.word	0x016d024c
 800ada8:	024c024c 	.word	0x024c024c
 800adac:	024c024c 	.word	0x024c024c
 800adb0:	024c024c 	.word	0x024c024c
 800adb4:	024c024c 	.word	0x024c024c
 800adb8:	024c024c 	.word	0x024c024c
 800adbc:	00c90192 	.word	0x00c90192
 800adc0:	024c024c 	.word	0x024c024c
 800adc4:	0169024c 	.word	0x0169024c
 800adc8:	024c00c9 	.word	0x024c00c9
 800adcc:	015f024c 	.word	0x015f024c
 800add0:	014c024c 	.word	0x014c024c
 800add4:	013400bf 	.word	0x013400bf
 800add8:	024c0130 	.word	0x024c0130
 800addc:	024c010e 	.word	0x024c010e
 800ade0:	024c005b 	.word	0x024c005b
 800ade4:	0235024c 	.word	0x0235024c
 800ade8:	f04a 0a10 	orr.w	sl, sl, #16
 800adec:	f01a 0f20 	tst.w	sl, #32
 800adf0:	f000 83bf 	beq.w	800b572 <_svfiprintf_r+0x8f2>
 800adf4:	9b06      	ldr	r3, [sp, #24]
 800adf6:	1dda      	adds	r2, r3, #7
 800adf8:	2301      	movs	r3, #1
 800adfa:	f022 0207 	bic.w	r2, r2, #7
 800adfe:	f102 0508 	add.w	r5, r2, #8
 800ae02:	9506      	str	r5, [sp, #24]
 800ae04:	e9d2 4500 	ldrd	r4, r5, [r2]
 800ae08:	ea54 0005 	orrs.w	r0, r4, r5
 800ae0c:	bf0c      	ite	eq
 800ae0e:	2200      	moveq	r2, #0
 800ae10:	2201      	movne	r2, #1
 800ae12:	2100      	movs	r1, #0
 800ae14:	f88d 10a7 	strb.w	r1, [sp, #167]	; 0xa7
 800ae18:	f1b8 0f00 	cmp.w	r8, #0
 800ae1c:	bfa8      	it	ge
 800ae1e:	f02a 0a80 	bicge.w	sl, sl, #128	; 0x80
 800ae22:	f1b8 0f00 	cmp.w	r8, #0
 800ae26:	bf18      	it	ne
 800ae28:	f042 0201 	orrne.w	r2, r2, #1
 800ae2c:	2a00      	cmp	r2, #0
 800ae2e:	d070      	beq.n	800af12 <_svfiprintf_r+0x292>
 800ae30:	2b01      	cmp	r3, #1
 800ae32:	f000 8348 	beq.w	800b4c6 <_svfiprintf_r+0x846>
 800ae36:	2b02      	cmp	r3, #2
 800ae38:	f000 836f 	beq.w	800b51a <_svfiprintf_r+0x89a>
 800ae3c:	aa1c      	add	r2, sp, #112	; 0x70
 800ae3e:	46b4      	mov	ip, r6
 800ae40:	f102 0327 	add.w	r3, r2, #39	; 0x27
 800ae44:	9202      	str	r2, [sp, #8]
 800ae46:	9703      	str	r7, [sp, #12]
 800ae48:	08ea      	lsrs	r2, r5, #3
 800ae4a:	08e7      	lsrs	r7, r4, #3
 800ae4c:	ea47 7745 	orr.w	r7, r7, r5, lsl #29
 800ae50:	f004 0407 	and.w	r4, r4, #7
 800ae54:	4611      	mov	r1, r2
 800ae56:	f104 0230 	add.w	r2, r4, #48	; 0x30
 800ae5a:	460d      	mov	r5, r1
 800ae5c:	463c      	mov	r4, r7
 800ae5e:	461e      	mov	r6, r3
 800ae60:	701a      	strb	r2, [r3, #0]
 800ae62:	3b01      	subs	r3, #1
 800ae64:	ea54 0005 	orrs.w	r0, r4, r5
 800ae68:	d1ee      	bne.n	800ae48 <_svfiprintf_r+0x1c8>
 800ae6a:	f01a 0f01 	tst.w	sl, #1
 800ae6e:	9609      	str	r6, [sp, #36]	; 0x24
 800ae70:	9f03      	ldr	r7, [sp, #12]
 800ae72:	4666      	mov	r6, ip
 800ae74:	f000 83ab 	beq.w	800b5ce <_svfiprintf_r+0x94e>
 800ae78:	2a30      	cmp	r2, #48	; 0x30
 800ae7a:	f000 8365 	beq.w	800b548 <_svfiprintf_r+0x8c8>
 800ae7e:	9309      	str	r3, [sp, #36]	; 0x24
 800ae80:	9902      	ldr	r1, [sp, #8]
 800ae82:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800ae84:	f101 0328 	add.w	r3, r1, #40	; 0x28
 800ae88:	1a9b      	subs	r3, r3, r2
 800ae8a:	9303      	str	r3, [sp, #12]
 800ae8c:	2330      	movs	r3, #48	; 0x30
 800ae8e:	7013      	strb	r3, [r2, #0]
 800ae90:	f8cd 801c 	str.w	r8, [sp, #28]
 800ae94:	9803      	ldr	r0, [sp, #12]
 800ae96:	9907      	ldr	r1, [sp, #28]
 800ae98:	f89d 30a7 	ldrb.w	r3, [sp, #167]	; 0xa7
 800ae9c:	4288      	cmp	r0, r1
 800ae9e:	bfb8      	it	lt
 800aea0:	4608      	movlt	r0, r1
 800aea2:	9002      	str	r0, [sp, #8]
 800aea4:	2b00      	cmp	r3, #0
 800aea6:	f000 80e8 	beq.w	800b07a <_svfiprintf_r+0x3fa>
 800aeaa:	3001      	adds	r0, #1
 800aeac:	9002      	str	r0, [sp, #8]
 800aeae:	e0e4      	b.n	800b07a <_svfiprintf_r+0x3fa>
 800aeb0:	f04a 0a10 	orr.w	sl, sl, #16
 800aeb4:	f01a 0320 	ands.w	r3, sl, #32
 800aeb8:	f000 8366 	beq.w	800b588 <_svfiprintf_r+0x908>
 800aebc:	9b06      	ldr	r3, [sp, #24]
 800aebe:	1dda      	adds	r2, r3, #7
 800aec0:	2300      	movs	r3, #0
 800aec2:	e79a      	b.n	800adfa <_svfiprintf_r+0x17a>
 800aec4:	f04a 0a10 	orr.w	sl, sl, #16
 800aec8:	f01a 0f20 	tst.w	sl, #32
 800aecc:	f000 8343 	beq.w	800b556 <_svfiprintf_r+0x8d6>
 800aed0:	9806      	ldr	r0, [sp, #24]
 800aed2:	1dc3      	adds	r3, r0, #7
 800aed4:	f023 0307 	bic.w	r3, r3, #7
 800aed8:	f103 0108 	add.w	r1, r3, #8
 800aedc:	9106      	str	r1, [sp, #24]
 800aede:	e9d3 4500 	ldrd	r4, r5, [r3]
 800aee2:	2c00      	cmp	r4, #0
 800aee4:	f175 0000 	sbcs.w	r0, r5, #0
 800aee8:	f2c0 83ab 	blt.w	800b642 <_svfiprintf_r+0x9c2>
 800aeec:	ea54 0105 	orrs.w	r1, r4, r5
 800aef0:	f04f 0301 	mov.w	r3, #1
 800aef4:	bf0c      	ite	eq
 800aef6:	2200      	moveq	r2, #0
 800aef8:	2201      	movne	r2, #1
 800aefa:	f1b8 0f00 	cmp.w	r8, #0
 800aefe:	bfa8      	it	ge
 800af00:	f02a 0a80 	bicge.w	sl, sl, #128	; 0x80
 800af04:	f1b8 0f00 	cmp.w	r8, #0
 800af08:	bf18      	it	ne
 800af0a:	f042 0201 	orrne.w	r2, r2, #1
 800af0e:	2a00      	cmp	r2, #0
 800af10:	d18e      	bne.n	800ae30 <_svfiprintf_r+0x1b0>
 800af12:	2b00      	cmp	r3, #0
 800af14:	f040 82aa 	bne.w	800b46c <_svfiprintf_r+0x7ec>
 800af18:	f01a 0f01 	tst.w	sl, #1
 800af1c:	f000 82f9 	beq.w	800b512 <_svfiprintf_r+0x892>
 800af20:	2101      	movs	r1, #1
 800af22:	2330      	movs	r3, #48	; 0x30
 800af24:	f10d 0297 	add.w	r2, sp, #151	; 0x97
 800af28:	9103      	str	r1, [sp, #12]
 800af2a:	f88d 3097 	strb.w	r3, [sp, #151]	; 0x97
 800af2e:	9209      	str	r2, [sp, #36]	; 0x24
 800af30:	e7ae      	b.n	800ae90 <_svfiprintf_r+0x210>
 800af32:	9806      	ldr	r0, [sp, #24]
 800af34:	9906      	ldr	r1, [sp, #24]
 800af36:	6800      	ldr	r0, [r0, #0]
 800af38:	1d0a      	adds	r2, r1, #4
 800af3a:	2800      	cmp	r0, #0
 800af3c:	9004      	str	r0, [sp, #16]
 800af3e:	f280 8338 	bge.w	800b5b2 <_svfiprintf_r+0x932>
 800af42:	9b04      	ldr	r3, [sp, #16]
 800af44:	9206      	str	r2, [sp, #24]
 800af46:	425b      	negs	r3, r3
 800af48:	9304      	str	r3, [sp, #16]
 800af4a:	f04a 0a04 	orr.w	sl, sl, #4
 800af4e:	783b      	ldrb	r3, [r7, #0]
 800af50:	e6e9      	b.n	800ad26 <_svfiprintf_r+0xa6>
 800af52:	9b06      	ldr	r3, [sp, #24]
 800af54:	2500      	movs	r5, #0
 800af56:	f88d 50a7 	strb.w	r5, [sp, #167]	; 0xa7
 800af5a:	1d18      	adds	r0, r3, #4
 800af5c:	9006      	str	r0, [sp, #24]
 800af5e:	681b      	ldr	r3, [r3, #0]
 800af60:	9309      	str	r3, [sp, #36]	; 0x24
 800af62:	2b00      	cmp	r3, #0
 800af64:	f000 83ce 	beq.w	800b704 <_svfiprintf_r+0xa84>
 800af68:	f1b8 0f00 	cmp.w	r8, #0
 800af6c:	f2c0 837b 	blt.w	800b666 <_svfiprintf_r+0x9e6>
 800af70:	9809      	ldr	r0, [sp, #36]	; 0x24
 800af72:	2100      	movs	r1, #0
 800af74:	4642      	mov	r2, r8
 800af76:	f7fe feaf 	bl	8009cd8 <memchr>
 800af7a:	2800      	cmp	r0, #0
 800af7c:	f000 83d4 	beq.w	800b728 <_svfiprintf_r+0xaa8>
 800af80:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800af82:	1b40      	subs	r0, r0, r5
 800af84:	9003      	str	r0, [sp, #12]
 800af86:	4540      	cmp	r0, r8
 800af88:	f340 837f 	ble.w	800b68a <_svfiprintf_r+0xa0a>
 800af8c:	2500      	movs	r5, #0
 800af8e:	f8cd 800c 	str.w	r8, [sp, #12]
 800af92:	9507      	str	r5, [sp, #28]
 800af94:	e77e      	b.n	800ae94 <_svfiprintf_r+0x214>
 800af96:	f04a 0a20 	orr.w	sl, sl, #32
 800af9a:	783b      	ldrb	r3, [r7, #0]
 800af9c:	e6c3      	b.n	800ad26 <_svfiprintf_r+0xa6>
 800af9e:	9b06      	ldr	r3, [sp, #24]
 800afa0:	f24d 2100 	movw	r1, #53760	; 0xd200
 800afa4:	2500      	movs	r5, #0
 800afa6:	f6c0 0100 	movt	r1, #2048	; 0x800
 800afaa:	f04a 0a02 	orr.w	sl, sl, #2
 800afae:	681a      	ldr	r2, [r3, #0]
 800afb0:	3304      	adds	r3, #4
 800afb2:	9306      	str	r3, [sp, #24]
 800afb4:	2330      	movs	r3, #48	; 0x30
 800afb6:	4614      	mov	r4, r2
 800afb8:	f88d 30a4 	strb.w	r3, [sp, #164]	; 0xa4
 800afbc:	2378      	movs	r3, #120	; 0x78
 800afbe:	3a00      	subs	r2, #0
 800afc0:	f88d 30a5 	strb.w	r3, [sp, #165]	; 0xa5
 800afc4:	bf18      	it	ne
 800afc6:	2201      	movne	r2, #1
 800afc8:	9108      	str	r1, [sp, #32]
 800afca:	2302      	movs	r3, #2
 800afcc:	e721      	b.n	800ae12 <_svfiprintf_r+0x192>
 800afce:	f01a 0f20 	tst.w	sl, #32
 800afd2:	f040 830c 	bne.w	800b5ee <_svfiprintf_r+0x96e>
 800afd6:	f01a 0f10 	tst.w	sl, #16
 800afda:	f040 834b 	bne.w	800b674 <_svfiprintf_r+0x9f4>
 800afde:	f01a 0f40 	tst.w	sl, #64	; 0x40
 800afe2:	f000 8347 	beq.w	800b674 <_svfiprintf_r+0x9f4>
 800afe6:	9d06      	ldr	r5, [sp, #24]
 800afe8:	9805      	ldr	r0, [sp, #20]
 800afea:	682b      	ldr	r3, [r5, #0]
 800afec:	3504      	adds	r5, #4
 800afee:	9506      	str	r5, [sp, #24]
 800aff0:	8018      	strh	r0, [r3, #0]
 800aff2:	e65b      	b.n	800acac <_svfiprintf_r+0x2c>
 800aff4:	783b      	ldrb	r3, [r7, #0]
 800aff6:	2b6c      	cmp	r3, #108	; 0x6c
 800aff8:	bf0a      	itet	eq
 800affa:	f04a 0a20 	orreq.w	sl, sl, #32
 800affe:	f04a 0a10 	orrne.w	sl, sl, #16
 800b002:	f817 3f01 	ldrbeq.w	r3, [r7, #1]!
 800b006:	e68e      	b.n	800ad26 <_svfiprintf_r+0xa6>
 800b008:	f04a 0a40 	orr.w	sl, sl, #64	; 0x40
 800b00c:	783b      	ldrb	r3, [r7, #0]
 800b00e:	e68a      	b.n	800ad26 <_svfiprintf_r+0xa6>
 800b010:	f01a 0f20 	tst.w	sl, #32
 800b014:	f24d 12ec 	movw	r2, #53740	; 0xd1ec
 800b018:	f6c0 0200 	movt	r2, #2048	; 0x800
 800b01c:	9208      	str	r2, [sp, #32]
 800b01e:	f000 80c8 	beq.w	800b1b2 <_svfiprintf_r+0x532>
 800b022:	9d06      	ldr	r5, [sp, #24]
 800b024:	1dea      	adds	r2, r5, #7
 800b026:	f022 0207 	bic.w	r2, r2, #7
 800b02a:	f102 0008 	add.w	r0, r2, #8
 800b02e:	9006      	str	r0, [sp, #24]
 800b030:	e9d2 4500 	ldrd	r4, r5, [r2]
 800b034:	ea54 0005 	orrs.w	r0, r4, r5
 800b038:	bf0c      	ite	eq
 800b03a:	2200      	moveq	r2, #0
 800b03c:	2201      	movne	r2, #1
 800b03e:	ea1a 0f02 	tst.w	sl, r2
 800b042:	f000 82b4 	beq.w	800b5ae <_svfiprintf_r+0x92e>
 800b046:	f88d 30a5 	strb.w	r3, [sp, #165]	; 0xa5
 800b04a:	f04a 0a02 	orr.w	sl, sl, #2
 800b04e:	2330      	movs	r3, #48	; 0x30
 800b050:	2201      	movs	r2, #1
 800b052:	f88d 30a4 	strb.w	r3, [sp, #164]	; 0xa4
 800b056:	2302      	movs	r3, #2
 800b058:	e6db      	b.n	800ae12 <_svfiprintf_r+0x192>
 800b05a:	9b06      	ldr	r3, [sp, #24]
 800b05c:	2001      	movs	r0, #1
 800b05e:	aa1c      	add	r2, sp, #112	; 0x70
 800b060:	2500      	movs	r5, #0
 800b062:	1d19      	adds	r1, r3, #4
 800b064:	9002      	str	r0, [sp, #8]
 800b066:	681b      	ldr	r3, [r3, #0]
 800b068:	9106      	str	r1, [sp, #24]
 800b06a:	9003      	str	r0, [sp, #12]
 800b06c:	9209      	str	r2, [sp, #36]	; 0x24
 800b06e:	f88d 50a7 	strb.w	r5, [sp, #167]	; 0xa7
 800b072:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
 800b076:	2100      	movs	r1, #0
 800b078:	9107      	str	r1, [sp, #28]
 800b07a:	f01a 0202 	ands.w	r2, sl, #2
 800b07e:	920a      	str	r2, [sp, #40]	; 0x28
 800b080:	d002      	beq.n	800b088 <_svfiprintf_r+0x408>
 800b082:	9b02      	ldr	r3, [sp, #8]
 800b084:	3302      	adds	r3, #2
 800b086:	9302      	str	r3, [sp, #8]
 800b088:	f01a 0584 	ands.w	r5, sl, #132	; 0x84
 800b08c:	950b      	str	r5, [sp, #44]	; 0x2c
 800b08e:	f040 80b5 	bne.w	800b1fc <_svfiprintf_r+0x57c>
 800b092:	9804      	ldr	r0, [sp, #16]
 800b094:	9902      	ldr	r1, [sp, #8]
 800b096:	1a44      	subs	r4, r0, r1
 800b098:	2c00      	cmp	r4, #0
 800b09a:	f340 80af 	ble.w	800b1fc <_svfiprintf_r+0x57c>
 800b09e:	2c10      	cmp	r4, #16
 800b0a0:	f340 8321 	ble.w	800b6e6 <_svfiprintf_r+0xa66>
 800b0a4:	f24d 05f0 	movw	r5, #53488	; 0xd0f0
 800b0a8:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800b0aa:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b0ac:	f6c0 0500 	movt	r5, #2048	; 0x800
 800b0b0:	f04f 0810 	mov.w	r8, #16
 800b0b4:	e002      	b.n	800b0bc <_svfiprintf_r+0x43c>
 800b0b6:	3c10      	subs	r4, #16
 800b0b8:	2c10      	cmp	r4, #16
 800b0ba:	dd1c      	ble.n	800b0f6 <_svfiprintf_r+0x476>
 800b0bc:	3301      	adds	r3, #1
 800b0be:	6035      	str	r5, [r6, #0]
 800b0c0:	f8c6 8004 	str.w	r8, [r6, #4]
 800b0c4:	3210      	adds	r2, #16
 800b0c6:	3608      	adds	r6, #8
 800b0c8:	2b07      	cmp	r3, #7
 800b0ca:	9327      	str	r3, [sp, #156]	; 0x9c
 800b0cc:	f106 0c08 	add.w	ip, r6, #8
 800b0d0:	9228      	str	r2, [sp, #160]	; 0xa0
 800b0d2:	ddf0      	ble.n	800b0b6 <_svfiprintf_r+0x436>
 800b0d4:	aa26      	add	r2, sp, #152	; 0x98
 800b0d6:	4658      	mov	r0, fp
 800b0d8:	4649      	mov	r1, r9
 800b0da:	ae0c      	add	r6, sp, #48	; 0x30
 800b0dc:	f7ff fd4c 	bl	800ab78 <__ssprint_r>
 800b0e0:	aa0c      	add	r2, sp, #48	; 0x30
 800b0e2:	f102 0c08 	add.w	ip, r2, #8
 800b0e6:	2800      	cmp	r0, #0
 800b0e8:	f040 8156 	bne.w	800b398 <_svfiprintf_r+0x718>
 800b0ec:	3c10      	subs	r4, #16
 800b0ee:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800b0f0:	2c10      	cmp	r4, #16
 800b0f2:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b0f4:	dce2      	bgt.n	800b0bc <_svfiprintf_r+0x43c>
 800b0f6:	3301      	adds	r3, #1
 800b0f8:	6035      	str	r5, [r6, #0]
 800b0fa:	2b07      	cmp	r3, #7
 800b0fc:	6074      	str	r4, [r6, #4]
 800b0fe:	4422      	add	r2, r4
 800b100:	9327      	str	r3, [sp, #156]	; 0x9c
 800b102:	9228      	str	r2, [sp, #160]	; 0xa0
 800b104:	bfdc      	itt	le
 800b106:	f10c 0108 	addle.w	r1, ip, #8
 800b10a:	4666      	movle	r6, ip
 800b10c:	dd7a      	ble.n	800b204 <_svfiprintf_r+0x584>
 800b10e:	4658      	mov	r0, fp
 800b110:	4649      	mov	r1, r9
 800b112:	aa26      	add	r2, sp, #152	; 0x98
 800b114:	f7ff fd30 	bl	800ab78 <__ssprint_r>
 800b118:	2800      	cmp	r0, #0
 800b11a:	f040 813d 	bne.w	800b398 <_svfiprintf_r+0x718>
 800b11e:	ab0c      	add	r3, sp, #48	; 0x30
 800b120:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800b122:	f103 0108 	add.w	r1, r3, #8
 800b126:	ae0c      	add	r6, sp, #48	; 0x30
 800b128:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b12a:	e06b      	b.n	800b204 <_svfiprintf_r+0x584>
 800b12c:	f04a 0a01 	orr.w	sl, sl, #1
 800b130:	783b      	ldrb	r3, [r7, #0]
 800b132:	e5f8      	b.n	800ad26 <_svfiprintf_r+0xa6>
 800b134:	4639      	mov	r1, r7
 800b136:	2200      	movs	r2, #0
 800b138:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
 800b13c:	f811 3b01 	ldrb.w	r3, [r1], #1
 800b140:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800b144:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 800b148:	460f      	mov	r7, r1
 800b14a:	2809      	cmp	r0, #9
 800b14c:	eb05 0242 	add.w	r2, r5, r2, lsl #1
 800b150:	d9f2      	bls.n	800b138 <_svfiprintf_r+0x4b8>
 800b152:	9204      	str	r2, [sp, #16]
 800b154:	e5e8      	b.n	800ad28 <_svfiprintf_r+0xa8>
 800b156:	f04a 0a80 	orr.w	sl, sl, #128	; 0x80
 800b15a:	783b      	ldrb	r3, [r7, #0]
 800b15c:	e5e3      	b.n	800ad26 <_svfiprintf_r+0xa6>
 800b15e:	f88d 40a7 	strb.w	r4, [sp, #167]	; 0xa7
 800b162:	783b      	ldrb	r3, [r7, #0]
 800b164:	e5df      	b.n	800ad26 <_svfiprintf_r+0xa6>
 800b166:	f817 3b01 	ldrb.w	r3, [r7], #1
 800b16a:	2b2a      	cmp	r3, #42	; 0x2a
 800b16c:	f000 82e1 	beq.w	800b732 <_svfiprintf_r+0xab2>
 800b170:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800b174:	2a09      	cmp	r2, #9
 800b176:	bf88      	it	hi
 800b178:	f04f 0800 	movhi.w	r8, #0
 800b17c:	d80d      	bhi.n	800b19a <_svfiprintf_r+0x51a>
 800b17e:	4639      	mov	r1, r7
 800b180:	f04f 0800 	mov.w	r8, #0
 800b184:	f811 3b01 	ldrb.w	r3, [r1], #1
 800b188:	eb08 0888 	add.w	r8, r8, r8, lsl #2
 800b18c:	eb02 0848 	add.w	r8, r2, r8, lsl #1
 800b190:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800b194:	2a09      	cmp	r2, #9
 800b196:	460f      	mov	r7, r1
 800b198:	d9f4      	bls.n	800b184 <_svfiprintf_r+0x504>
 800b19a:	ea48 78e8 	orr.w	r8, r8, r8, asr #31
 800b19e:	e5c3      	b.n	800ad28 <_svfiprintf_r+0xa8>
 800b1a0:	f01a 0f20 	tst.w	sl, #32
 800b1a4:	f24d 2100 	movw	r1, #53760	; 0xd200
 800b1a8:	f6c0 0100 	movt	r1, #2048	; 0x800
 800b1ac:	9108      	str	r1, [sp, #32]
 800b1ae:	f47f af38 	bne.w	800b022 <_svfiprintf_r+0x3a2>
 800b1b2:	f01a 0f10 	tst.w	sl, #16
 800b1b6:	f040 8226 	bne.w	800b606 <_svfiprintf_r+0x986>
 800b1ba:	f01a 0f40 	tst.w	sl, #64	; 0x40
 800b1be:	f000 8278 	beq.w	800b6b2 <_svfiprintf_r+0xa32>
 800b1c2:	9a06      	ldr	r2, [sp, #24]
 800b1c4:	2500      	movs	r5, #0
 800b1c6:	8814      	ldrh	r4, [r2, #0]
 800b1c8:	3204      	adds	r2, #4
 800b1ca:	9206      	str	r2, [sp, #24]
 800b1cc:	e732      	b.n	800b034 <_svfiprintf_r+0x3b4>
 800b1ce:	2b00      	cmp	r3, #0
 800b1d0:	f000 80db 	beq.w	800b38a <_svfiprintf_r+0x70a>
 800b1d4:	2001      	movs	r0, #1
 800b1d6:	2100      	movs	r1, #0
 800b1d8:	aa1c      	add	r2, sp, #112	; 0x70
 800b1da:	9002      	str	r0, [sp, #8]
 800b1dc:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
 800b1e0:	f88d 10a7 	strb.w	r1, [sp, #167]	; 0xa7
 800b1e4:	9003      	str	r0, [sp, #12]
 800b1e6:	9209      	str	r2, [sp, #36]	; 0x24
 800b1e8:	e745      	b.n	800b076 <_svfiprintf_r+0x3f6>
 800b1ea:	f89d 30a7 	ldrb.w	r3, [sp, #167]	; 0xa7
 800b1ee:	2b00      	cmp	r3, #0
 800b1f0:	f040 821a 	bne.w	800b628 <_svfiprintf_r+0x9a8>
 800b1f4:	f88d c0a7 	strb.w	ip, [sp, #167]	; 0xa7
 800b1f8:	783b      	ldrb	r3, [r7, #0]
 800b1fa:	e594      	b.n	800ad26 <_svfiprintf_r+0xa6>
 800b1fc:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800b1fe:	f106 0108 	add.w	r1, r6, #8
 800b202:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b204:	f89d 00a7 	ldrb.w	r0, [sp, #167]	; 0xa7
 800b208:	b168      	cbz	r0, 800b226 <_svfiprintf_r+0x5a6>
 800b20a:	3301      	adds	r3, #1
 800b20c:	f10d 00a7 	add.w	r0, sp, #167	; 0xa7
 800b210:	6030      	str	r0, [r6, #0]
 800b212:	2001      	movs	r0, #1
 800b214:	2b07      	cmp	r3, #7
 800b216:	6070      	str	r0, [r6, #4]
 800b218:	4402      	add	r2, r0
 800b21a:	9327      	str	r3, [sp, #156]	; 0x9c
 800b21c:	9228      	str	r2, [sp, #160]	; 0xa0
 800b21e:	f300 8132 	bgt.w	800b486 <_svfiprintf_r+0x806>
 800b222:	460e      	mov	r6, r1
 800b224:	3108      	adds	r1, #8
 800b226:	980a      	ldr	r0, [sp, #40]	; 0x28
 800b228:	b160      	cbz	r0, 800b244 <_svfiprintf_r+0x5c4>
 800b22a:	3301      	adds	r3, #1
 800b22c:	a829      	add	r0, sp, #164	; 0xa4
 800b22e:	6030      	str	r0, [r6, #0]
 800b230:	2002      	movs	r0, #2
 800b232:	2b07      	cmp	r3, #7
 800b234:	6070      	str	r0, [r6, #4]
 800b236:	4402      	add	r2, r0
 800b238:	9327      	str	r3, [sp, #156]	; 0x9c
 800b23a:	9228      	str	r2, [sp, #160]	; 0xa0
 800b23c:	f300 8134 	bgt.w	800b4a8 <_svfiprintf_r+0x828>
 800b240:	460e      	mov	r6, r1
 800b242:	3108      	adds	r1, #8
 800b244:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 800b246:	2d80      	cmp	r5, #128	; 0x80
 800b248:	f000 80b3 	beq.w	800b3b2 <_svfiprintf_r+0x732>
 800b24c:	9807      	ldr	r0, [sp, #28]
 800b24e:	9d03      	ldr	r5, [sp, #12]
 800b250:	1b44      	subs	r4, r0, r5
 800b252:	2c00      	cmp	r4, #0
 800b254:	dd3e      	ble.n	800b2d4 <_svfiprintf_r+0x654>
 800b256:	2c10      	cmp	r4, #16
 800b258:	f340 8214 	ble.w	800b684 <_svfiprintf_r+0xa04>
 800b25c:	4d91      	ldr	r5, [pc, #580]	; (800b4a4 <_svfiprintf_r+0x824>)
 800b25e:	f04f 0810 	mov.w	r8, #16
 800b262:	e002      	b.n	800b26a <_svfiprintf_r+0x5ea>
 800b264:	3c10      	subs	r4, #16
 800b266:	2c10      	cmp	r4, #16
 800b268:	dd1b      	ble.n	800b2a2 <_svfiprintf_r+0x622>
 800b26a:	3301      	adds	r3, #1
 800b26c:	6035      	str	r5, [r6, #0]
 800b26e:	f8c6 8004 	str.w	r8, [r6, #4]
 800b272:	3210      	adds	r2, #16
 800b274:	3608      	adds	r6, #8
 800b276:	2b07      	cmp	r3, #7
 800b278:	9327      	str	r3, [sp, #156]	; 0x9c
 800b27a:	f106 0c08 	add.w	ip, r6, #8
 800b27e:	9228      	str	r2, [sp, #160]	; 0xa0
 800b280:	ddf0      	ble.n	800b264 <_svfiprintf_r+0x5e4>
 800b282:	4649      	mov	r1, r9
 800b284:	4658      	mov	r0, fp
 800b286:	aa26      	add	r2, sp, #152	; 0x98
 800b288:	ae0c      	add	r6, sp, #48	; 0x30
 800b28a:	f7ff fc75 	bl	800ab78 <__ssprint_r>
 800b28e:	a90c      	add	r1, sp, #48	; 0x30
 800b290:	f101 0c08 	add.w	ip, r1, #8
 800b294:	2800      	cmp	r0, #0
 800b296:	d17f      	bne.n	800b398 <_svfiprintf_r+0x718>
 800b298:	3c10      	subs	r4, #16
 800b29a:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800b29c:	2c10      	cmp	r4, #16
 800b29e:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b2a0:	dce3      	bgt.n	800b26a <_svfiprintf_r+0x5ea>
 800b2a2:	3301      	adds	r3, #1
 800b2a4:	6035      	str	r5, [r6, #0]
 800b2a6:	2b07      	cmp	r3, #7
 800b2a8:	6074      	str	r4, [r6, #4]
 800b2aa:	4422      	add	r2, r4
 800b2ac:	9327      	str	r3, [sp, #156]	; 0x9c
 800b2ae:	9228      	str	r2, [sp, #160]	; 0xa0
 800b2b0:	bfdc      	itt	le
 800b2b2:	f10c 0108 	addle.w	r1, ip, #8
 800b2b6:	4666      	movle	r6, ip
 800b2b8:	dd0c      	ble.n	800b2d4 <_svfiprintf_r+0x654>
 800b2ba:	4658      	mov	r0, fp
 800b2bc:	4649      	mov	r1, r9
 800b2be:	aa26      	add	r2, sp, #152	; 0x98
 800b2c0:	f7ff fc5a 	bl	800ab78 <__ssprint_r>
 800b2c4:	2800      	cmp	r0, #0
 800b2c6:	d167      	bne.n	800b398 <_svfiprintf_r+0x718>
 800b2c8:	ab0c      	add	r3, sp, #48	; 0x30
 800b2ca:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800b2cc:	f103 0108 	add.w	r1, r3, #8
 800b2d0:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b2d2:	ae0c      	add	r6, sp, #48	; 0x30
 800b2d4:	3301      	adds	r3, #1
 800b2d6:	9803      	ldr	r0, [sp, #12]
 800b2d8:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800b2da:	2b07      	cmp	r3, #7
 800b2dc:	4402      	add	r2, r0
 800b2de:	6070      	str	r0, [r6, #4]
 800b2e0:	6035      	str	r5, [r6, #0]
 800b2e2:	9327      	str	r3, [sp, #156]	; 0x9c
 800b2e4:	9228      	str	r2, [sp, #160]	; 0xa0
 800b2e6:	f300 80ae 	bgt.w	800b446 <_svfiprintf_r+0x7c6>
 800b2ea:	f01a 0f04 	tst.w	sl, #4
 800b2ee:	d030      	beq.n	800b352 <_svfiprintf_r+0x6d2>
 800b2f0:	9b04      	ldr	r3, [sp, #16]
 800b2f2:	9d02      	ldr	r5, [sp, #8]
 800b2f4:	1b5c      	subs	r4, r3, r5
 800b2f6:	2c00      	cmp	r4, #0
 800b2f8:	dd2b      	ble.n	800b352 <_svfiprintf_r+0x6d2>
 800b2fa:	2c10      	cmp	r4, #16
 800b2fc:	f340 81fc 	ble.w	800b6f8 <_svfiprintf_r+0xa78>
 800b300:	f24d 05f0 	movw	r5, #53488	; 0xd0f0
 800b304:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b306:	f6c0 0500 	movt	r5, #2048	; 0x800
 800b30a:	2610      	movs	r6, #16
 800b30c:	e002      	b.n	800b314 <_svfiprintf_r+0x694>
 800b30e:	3c10      	subs	r4, #16
 800b310:	2c10      	cmp	r4, #16
 800b312:	dd15      	ble.n	800b340 <_svfiprintf_r+0x6c0>
 800b314:	3301      	adds	r3, #1
 800b316:	600d      	str	r5, [r1, #0]
 800b318:	604e      	str	r6, [r1, #4]
 800b31a:	3210      	adds	r2, #16
 800b31c:	3108      	adds	r1, #8
 800b31e:	2b07      	cmp	r3, #7
 800b320:	9327      	str	r3, [sp, #156]	; 0x9c
 800b322:	9228      	str	r2, [sp, #160]	; 0xa0
 800b324:	ddf3      	ble.n	800b30e <_svfiprintf_r+0x68e>
 800b326:	4649      	mov	r1, r9
 800b328:	4658      	mov	r0, fp
 800b32a:	aa26      	add	r2, sp, #152	; 0x98
 800b32c:	f7ff fc24 	bl	800ab78 <__ssprint_r>
 800b330:	a90c      	add	r1, sp, #48	; 0x30
 800b332:	2800      	cmp	r0, #0
 800b334:	d130      	bne.n	800b398 <_svfiprintf_r+0x718>
 800b336:	3c10      	subs	r4, #16
 800b338:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800b33a:	2c10      	cmp	r4, #16
 800b33c:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b33e:	dce9      	bgt.n	800b314 <_svfiprintf_r+0x694>
 800b340:	3301      	adds	r3, #1
 800b342:	600d      	str	r5, [r1, #0]
 800b344:	2b07      	cmp	r3, #7
 800b346:	604c      	str	r4, [r1, #4]
 800b348:	4422      	add	r2, r4
 800b34a:	9327      	str	r3, [sp, #156]	; 0x9c
 800b34c:	9228      	str	r2, [sp, #160]	; 0xa0
 800b34e:	f300 8134 	bgt.w	800b5ba <_svfiprintf_r+0x93a>
 800b352:	9805      	ldr	r0, [sp, #20]
 800b354:	9b02      	ldr	r3, [sp, #8]
 800b356:	9904      	ldr	r1, [sp, #16]
 800b358:	428b      	cmp	r3, r1
 800b35a:	bfac      	ite	ge
 800b35c:	18c0      	addge	r0, r0, r3
 800b35e:	1840      	addlt	r0, r0, r1
 800b360:	9005      	str	r0, [sp, #20]
 800b362:	2a00      	cmp	r2, #0
 800b364:	d179      	bne.n	800b45a <_svfiprintf_r+0x7da>
 800b366:	2500      	movs	r5, #0
 800b368:	9527      	str	r5, [sp, #156]	; 0x9c
 800b36a:	783b      	ldrb	r3, [r7, #0]
 800b36c:	ae0c      	add	r6, sp, #48	; 0x30
 800b36e:	f1b3 0225 	subs.w	r2, r3, #37	; 0x25
 800b372:	bf18      	it	ne
 800b374:	2201      	movne	r2, #1
 800b376:	2b00      	cmp	r3, #0
 800b378:	bf0c      	ite	eq
 800b37a:	2300      	moveq	r3, #0
 800b37c:	f002 0301 	andne.w	r3, r2, #1
 800b380:	2b00      	cmp	r3, #0
 800b382:	f47f aca0 	bne.w	800acc6 <_svfiprintf_r+0x46>
 800b386:	463c      	mov	r4, r7
 800b388:	e4bc      	b.n	800ad04 <_svfiprintf_r+0x84>
 800b38a:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 800b38c:	b123      	cbz	r3, 800b398 <_svfiprintf_r+0x718>
 800b38e:	4658      	mov	r0, fp
 800b390:	4649      	mov	r1, r9
 800b392:	aa26      	add	r2, sp, #152	; 0x98
 800b394:	f7ff fbf0 	bl	800ab78 <__ssprint_r>
 800b398:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 800b39c:	9805      	ldr	r0, [sp, #20]
 800b39e:	f013 0f40 	tst.w	r3, #64	; 0x40
 800b3a2:	bf18      	it	ne
 800b3a4:	f04f 30ff 	movne.w	r0, #4294967295
 800b3a8:	9005      	str	r0, [sp, #20]
 800b3aa:	9805      	ldr	r0, [sp, #20]
 800b3ac:	b02b      	add	sp, #172	; 0xac
 800b3ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b3b2:	9804      	ldr	r0, [sp, #16]
 800b3b4:	9d02      	ldr	r5, [sp, #8]
 800b3b6:	1b44      	subs	r4, r0, r5
 800b3b8:	2c00      	cmp	r4, #0
 800b3ba:	bfd8      	it	le
 800b3bc:	f106 0108 	addle.w	r1, r6, #8
 800b3c0:	f77f af44 	ble.w	800b24c <_svfiprintf_r+0x5cc>
 800b3c4:	2c10      	cmp	r4, #16
 800b3c6:	f340 81ac 	ble.w	800b722 <_svfiprintf_r+0xaa2>
 800b3ca:	4d36      	ldr	r5, [pc, #216]	; (800b4a4 <_svfiprintf_r+0x824>)
 800b3cc:	f04f 0810 	mov.w	r8, #16
 800b3d0:	e002      	b.n	800b3d8 <_svfiprintf_r+0x758>
 800b3d2:	3c10      	subs	r4, #16
 800b3d4:	2c10      	cmp	r4, #16
 800b3d6:	dd1b      	ble.n	800b410 <_svfiprintf_r+0x790>
 800b3d8:	3301      	adds	r3, #1
 800b3da:	6035      	str	r5, [r6, #0]
 800b3dc:	f8c6 8004 	str.w	r8, [r6, #4]
 800b3e0:	3210      	adds	r2, #16
 800b3e2:	3608      	adds	r6, #8
 800b3e4:	2b07      	cmp	r3, #7
 800b3e6:	9327      	str	r3, [sp, #156]	; 0x9c
 800b3e8:	f106 0c08 	add.w	ip, r6, #8
 800b3ec:	9228      	str	r2, [sp, #160]	; 0xa0
 800b3ee:	ddf0      	ble.n	800b3d2 <_svfiprintf_r+0x752>
 800b3f0:	4649      	mov	r1, r9
 800b3f2:	4658      	mov	r0, fp
 800b3f4:	aa26      	add	r2, sp, #152	; 0x98
 800b3f6:	ae0c      	add	r6, sp, #48	; 0x30
 800b3f8:	f7ff fbbe 	bl	800ab78 <__ssprint_r>
 800b3fc:	a90c      	add	r1, sp, #48	; 0x30
 800b3fe:	f101 0c08 	add.w	ip, r1, #8
 800b402:	2800      	cmp	r0, #0
 800b404:	d1c8      	bne.n	800b398 <_svfiprintf_r+0x718>
 800b406:	3c10      	subs	r4, #16
 800b408:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800b40a:	2c10      	cmp	r4, #16
 800b40c:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b40e:	dce3      	bgt.n	800b3d8 <_svfiprintf_r+0x758>
 800b410:	3301      	adds	r3, #1
 800b412:	6035      	str	r5, [r6, #0]
 800b414:	2b07      	cmp	r3, #7
 800b416:	6074      	str	r4, [r6, #4]
 800b418:	4422      	add	r2, r4
 800b41a:	9327      	str	r3, [sp, #156]	; 0x9c
 800b41c:	9228      	str	r2, [sp, #160]	; 0xa0
 800b41e:	bfdc      	itt	le
 800b420:	f10c 0108 	addle.w	r1, ip, #8
 800b424:	4666      	movle	r6, ip
 800b426:	f77f af11 	ble.w	800b24c <_svfiprintf_r+0x5cc>
 800b42a:	4658      	mov	r0, fp
 800b42c:	4649      	mov	r1, r9
 800b42e:	aa26      	add	r2, sp, #152	; 0x98
 800b430:	f7ff fba2 	bl	800ab78 <__ssprint_r>
 800b434:	2800      	cmp	r0, #0
 800b436:	d1af      	bne.n	800b398 <_svfiprintf_r+0x718>
 800b438:	ab0c      	add	r3, sp, #48	; 0x30
 800b43a:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800b43c:	f103 0108 	add.w	r1, r3, #8
 800b440:	ae0c      	add	r6, sp, #48	; 0x30
 800b442:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b444:	e702      	b.n	800b24c <_svfiprintf_r+0x5cc>
 800b446:	4658      	mov	r0, fp
 800b448:	4649      	mov	r1, r9
 800b44a:	aa26      	add	r2, sp, #152	; 0x98
 800b44c:	f7ff fb94 	bl	800ab78 <__ssprint_r>
 800b450:	2800      	cmp	r0, #0
 800b452:	d1a1      	bne.n	800b398 <_svfiprintf_r+0x718>
 800b454:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800b456:	a90c      	add	r1, sp, #48	; 0x30
 800b458:	e747      	b.n	800b2ea <_svfiprintf_r+0x66a>
 800b45a:	4658      	mov	r0, fp
 800b45c:	4649      	mov	r1, r9
 800b45e:	aa26      	add	r2, sp, #152	; 0x98
 800b460:	f7ff fb8a 	bl	800ab78 <__ssprint_r>
 800b464:	2800      	cmp	r0, #0
 800b466:	f43f af7e 	beq.w	800b366 <_svfiprintf_r+0x6e6>
 800b46a:	e795      	b.n	800b398 <_svfiprintf_r+0x718>
 800b46c:	ab26      	add	r3, sp, #152	; 0x98
 800b46e:	9203      	str	r2, [sp, #12]
 800b470:	9309      	str	r3, [sp, #36]	; 0x24
 800b472:	e50d      	b.n	800ae90 <_svfiprintf_r+0x210>
 800b474:	4658      	mov	r0, fp
 800b476:	4649      	mov	r1, r9
 800b478:	aa26      	add	r2, sp, #152	; 0x98
 800b47a:	f7ff fb7d 	bl	800ab78 <__ssprint_r>
 800b47e:	2800      	cmp	r0, #0
 800b480:	d18a      	bne.n	800b398 <_svfiprintf_r+0x718>
 800b482:	ae0c      	add	r6, sp, #48	; 0x30
 800b484:	e43b      	b.n	800acfe <_svfiprintf_r+0x7e>
 800b486:	4658      	mov	r0, fp
 800b488:	4649      	mov	r1, r9
 800b48a:	aa26      	add	r2, sp, #152	; 0x98
 800b48c:	f7ff fb74 	bl	800ab78 <__ssprint_r>
 800b490:	2800      	cmp	r0, #0
 800b492:	d181      	bne.n	800b398 <_svfiprintf_r+0x718>
 800b494:	ad0c      	add	r5, sp, #48	; 0x30
 800b496:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800b498:	f105 0108 	add.w	r1, r5, #8
 800b49c:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b49e:	462e      	mov	r6, r5
 800b4a0:	e6c1      	b.n	800b226 <_svfiprintf_r+0x5a6>
 800b4a2:	bf00      	nop
 800b4a4:	0800d100 	.word	0x0800d100
 800b4a8:	4658      	mov	r0, fp
 800b4aa:	4649      	mov	r1, r9
 800b4ac:	aa26      	add	r2, sp, #152	; 0x98
 800b4ae:	f7ff fb63 	bl	800ab78 <__ssprint_r>
 800b4b2:	2800      	cmp	r0, #0
 800b4b4:	f47f af70 	bne.w	800b398 <_svfiprintf_r+0x718>
 800b4b8:	ab0c      	add	r3, sp, #48	; 0x30
 800b4ba:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800b4bc:	f103 0108 	add.w	r1, r3, #8
 800b4c0:	ae0c      	add	r6, sp, #48	; 0x30
 800b4c2:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b4c4:	e6be      	b.n	800b244 <_svfiprintf_r+0x5c4>
 800b4c6:	2c0a      	cmp	r4, #10
 800b4c8:	f175 0300 	sbcs.w	r3, r5, #0
 800b4cc:	f0c0 8086 	bcc.w	800b5dc <_svfiprintf_r+0x95c>
 800b4d0:	a91c      	add	r1, sp, #112	; 0x70
 800b4d2:	9703      	str	r7, [sp, #12]
 800b4d4:	f101 0327 	add.w	r3, r1, #39	; 0x27
 800b4d8:	9102      	str	r1, [sp, #8]
 800b4da:	461f      	mov	r7, r3
 800b4dc:	9607      	str	r6, [sp, #28]
 800b4de:	4620      	mov	r0, r4
 800b4e0:	4629      	mov	r1, r5
 800b4e2:	220a      	movs	r2, #10
 800b4e4:	2300      	movs	r3, #0
 800b4e6:	f001 f85f 	bl	800c5a8 <__aeabi_uldivmod>
 800b4ea:	463e      	mov	r6, r7
 800b4ec:	4620      	mov	r0, r4
 800b4ee:	4629      	mov	r1, r5
 800b4f0:	2300      	movs	r3, #0
 800b4f2:	3f01      	subs	r7, #1
 800b4f4:	f102 0430 	add.w	r4, r2, #48	; 0x30
 800b4f8:	220a      	movs	r2, #10
 800b4fa:	7034      	strb	r4, [r6, #0]
 800b4fc:	f001 f854 	bl	800c5a8 <__aeabi_uldivmod>
 800b500:	4604      	mov	r4, r0
 800b502:	460d      	mov	r5, r1
 800b504:	ea54 0205 	orrs.w	r2, r4, r5
 800b508:	d1e9      	bne.n	800b4de <_svfiprintf_r+0x85e>
 800b50a:	9609      	str	r6, [sp, #36]	; 0x24
 800b50c:	9f03      	ldr	r7, [sp, #12]
 800b50e:	9e07      	ldr	r6, [sp, #28]
 800b510:	e01a      	b.n	800b548 <_svfiprintf_r+0x8c8>
 800b512:	ad26      	add	r5, sp, #152	; 0x98
 800b514:	9303      	str	r3, [sp, #12]
 800b516:	9509      	str	r5, [sp, #36]	; 0x24
 800b518:	e4ba      	b.n	800ae90 <_svfiprintf_r+0x210>
 800b51a:	a91c      	add	r1, sp, #112	; 0x70
 800b51c:	f8dd c020 	ldr.w	ip, [sp, #32]
 800b520:	f101 0027 	add.w	r0, r1, #39	; 0x27
 800b524:	9102      	str	r1, [sp, #8]
 800b526:	f004 020f 	and.w	r2, r4, #15
 800b52a:	0923      	lsrs	r3, r4, #4
 800b52c:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 800b530:	0929      	lsrs	r1, r5, #4
 800b532:	f81c 2002 	ldrb.w	r2, [ip, r2]
 800b536:	461c      	mov	r4, r3
 800b538:	4603      	mov	r3, r0
 800b53a:	460d      	mov	r5, r1
 800b53c:	3801      	subs	r0, #1
 800b53e:	701a      	strb	r2, [r3, #0]
 800b540:	ea54 0205 	orrs.w	r2, r4, r5
 800b544:	d1ef      	bne.n	800b526 <_svfiprintf_r+0x8a6>
 800b546:	9309      	str	r3, [sp, #36]	; 0x24
 800b548:	9d02      	ldr	r5, [sp, #8]
 800b54a:	9809      	ldr	r0, [sp, #36]	; 0x24
 800b54c:	f105 0328 	add.w	r3, r5, #40	; 0x28
 800b550:	1a1b      	subs	r3, r3, r0
 800b552:	9303      	str	r3, [sp, #12]
 800b554:	e49c      	b.n	800ae90 <_svfiprintf_r+0x210>
 800b556:	f01a 0f10 	tst.w	sl, #16
 800b55a:	d168      	bne.n	800b62e <_svfiprintf_r+0x9ae>
 800b55c:	f01a 0f40 	tst.w	sl, #64	; 0x40
 800b560:	f000 8096 	beq.w	800b690 <_svfiprintf_r+0xa10>
 800b564:	9b06      	ldr	r3, [sp, #24]
 800b566:	f9b3 4000 	ldrsh.w	r4, [r3]
 800b56a:	3304      	adds	r3, #4
 800b56c:	9306      	str	r3, [sp, #24]
 800b56e:	17e5      	asrs	r5, r4, #31
 800b570:	e4b7      	b.n	800aee2 <_svfiprintf_r+0x262>
 800b572:	f01a 0f10 	tst.w	sl, #16
 800b576:	d172      	bne.n	800b65e <_svfiprintf_r+0x9de>
 800b578:	f01a 0f40 	tst.w	sl, #64	; 0x40
 800b57c:	f000 809f 	beq.w	800b6be <_svfiprintf_r+0xa3e>
 800b580:	9b06      	ldr	r3, [sp, #24]
 800b582:	881a      	ldrh	r2, [r3, #0]
 800b584:	2301      	movs	r3, #1
 800b586:	e009      	b.n	800b59c <_svfiprintf_r+0x91c>
 800b588:	f01a 0110 	ands.w	r1, sl, #16
 800b58c:	d141      	bne.n	800b612 <_svfiprintf_r+0x992>
 800b58e:	f01a 0340 	ands.w	r3, sl, #64	; 0x40
 800b592:	f000 8083 	beq.w	800b69c <_svfiprintf_r+0xa1c>
 800b596:	9b06      	ldr	r3, [sp, #24]
 800b598:	881a      	ldrh	r2, [r3, #0]
 800b59a:	460b      	mov	r3, r1
 800b59c:	9d06      	ldr	r5, [sp, #24]
 800b59e:	4614      	mov	r4, r2
 800b5a0:	3504      	adds	r5, #4
 800b5a2:	9506      	str	r5, [sp, #24]
 800b5a4:	2500      	movs	r5, #0
 800b5a6:	3a00      	subs	r2, #0
 800b5a8:	bf18      	it	ne
 800b5aa:	2201      	movne	r2, #1
 800b5ac:	e431      	b.n	800ae12 <_svfiprintf_r+0x192>
 800b5ae:	2302      	movs	r3, #2
 800b5b0:	e42f      	b.n	800ae12 <_svfiprintf_r+0x192>
 800b5b2:	783b      	ldrb	r3, [r7, #0]
 800b5b4:	9206      	str	r2, [sp, #24]
 800b5b6:	f7ff bbb6 	b.w	800ad26 <_svfiprintf_r+0xa6>
 800b5ba:	4658      	mov	r0, fp
 800b5bc:	4649      	mov	r1, r9
 800b5be:	aa26      	add	r2, sp, #152	; 0x98
 800b5c0:	f7ff fada 	bl	800ab78 <__ssprint_r>
 800b5c4:	2800      	cmp	r0, #0
 800b5c6:	f47f aee7 	bne.w	800b398 <_svfiprintf_r+0x718>
 800b5ca:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800b5cc:	e6c1      	b.n	800b352 <_svfiprintf_r+0x6d2>
 800b5ce:	9902      	ldr	r1, [sp, #8]
 800b5d0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800b5d2:	f101 0328 	add.w	r3, r1, #40	; 0x28
 800b5d6:	1a9b      	subs	r3, r3, r2
 800b5d8:	9303      	str	r3, [sp, #12]
 800b5da:	e459      	b.n	800ae90 <_svfiprintf_r+0x210>
 800b5dc:	3430      	adds	r4, #48	; 0x30
 800b5de:	2501      	movs	r5, #1
 800b5e0:	f10d 0097 	add.w	r0, sp, #151	; 0x97
 800b5e4:	9503      	str	r5, [sp, #12]
 800b5e6:	f88d 4097 	strb.w	r4, [sp, #151]	; 0x97
 800b5ea:	9009      	str	r0, [sp, #36]	; 0x24
 800b5ec:	e450      	b.n	800ae90 <_svfiprintf_r+0x210>
 800b5ee:	9b06      	ldr	r3, [sp, #24]
 800b5f0:	9d05      	ldr	r5, [sp, #20]
 800b5f2:	9806      	ldr	r0, [sp, #24]
 800b5f4:	6819      	ldr	r1, [r3, #0]
 800b5f6:	462a      	mov	r2, r5
 800b5f8:	17eb      	asrs	r3, r5, #31
 800b5fa:	3004      	adds	r0, #4
 800b5fc:	9006      	str	r0, [sp, #24]
 800b5fe:	e9c1 2300 	strd	r2, r3, [r1]
 800b602:	f7ff bb53 	b.w	800acac <_svfiprintf_r+0x2c>
 800b606:	9906      	ldr	r1, [sp, #24]
 800b608:	2500      	movs	r5, #0
 800b60a:	680c      	ldr	r4, [r1, #0]
 800b60c:	3104      	adds	r1, #4
 800b60e:	9106      	str	r1, [sp, #24]
 800b610:	e510      	b.n	800b034 <_svfiprintf_r+0x3b4>
 800b612:	9906      	ldr	r1, [sp, #24]
 800b614:	680a      	ldr	r2, [r1, #0]
 800b616:	3104      	adds	r1, #4
 800b618:	4614      	mov	r4, r2
 800b61a:	2500      	movs	r5, #0
 800b61c:	3a00      	subs	r2, #0
 800b61e:	9106      	str	r1, [sp, #24]
 800b620:	bf18      	it	ne
 800b622:	2201      	movne	r2, #1
 800b624:	f7ff bbf5 	b.w	800ae12 <_svfiprintf_r+0x192>
 800b628:	783b      	ldrb	r3, [r7, #0]
 800b62a:	f7ff bb7c 	b.w	800ad26 <_svfiprintf_r+0xa6>
 800b62e:	9a06      	ldr	r2, [sp, #24]
 800b630:	6814      	ldr	r4, [r2, #0]
 800b632:	3204      	adds	r2, #4
 800b634:	9206      	str	r2, [sp, #24]
 800b636:	17e5      	asrs	r5, r4, #31
 800b638:	2c00      	cmp	r4, #0
 800b63a:	f175 0000 	sbcs.w	r0, r5, #0
 800b63e:	f6bf ac55 	bge.w	800aeec <_svfiprintf_r+0x26c>
 800b642:	4264      	negs	r4, r4
 800b644:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 800b648:	232d      	movs	r3, #45	; 0x2d
 800b64a:	ea54 0205 	orrs.w	r2, r4, r5
 800b64e:	f88d 30a7 	strb.w	r3, [sp, #167]	; 0xa7
 800b652:	bf0c      	ite	eq
 800b654:	2200      	moveq	r2, #0
 800b656:	2201      	movne	r2, #1
 800b658:	2301      	movs	r3, #1
 800b65a:	f7ff bbdd 	b.w	800ae18 <_svfiprintf_r+0x198>
 800b65e:	9906      	ldr	r1, [sp, #24]
 800b660:	2301      	movs	r3, #1
 800b662:	680a      	ldr	r2, [r1, #0]
 800b664:	e7d7      	b.n	800b616 <_svfiprintf_r+0x996>
 800b666:	9809      	ldr	r0, [sp, #36]	; 0x24
 800b668:	2100      	movs	r1, #0
 800b66a:	9107      	str	r1, [sp, #28]
 800b66c:	f7ff fa54 	bl	800ab18 <strlen>
 800b670:	9003      	str	r0, [sp, #12]
 800b672:	e40f      	b.n	800ae94 <_svfiprintf_r+0x214>
 800b674:	9906      	ldr	r1, [sp, #24]
 800b676:	9a05      	ldr	r2, [sp, #20]
 800b678:	680b      	ldr	r3, [r1, #0]
 800b67a:	3104      	adds	r1, #4
 800b67c:	9106      	str	r1, [sp, #24]
 800b67e:	601a      	str	r2, [r3, #0]
 800b680:	f7ff bb14 	b.w	800acac <_svfiprintf_r+0x2c>
 800b684:	4d35      	ldr	r5, [pc, #212]	; (800b75c <_svfiprintf_r+0xadc>)
 800b686:	468c      	mov	ip, r1
 800b688:	e60b      	b.n	800b2a2 <_svfiprintf_r+0x622>
 800b68a:	2300      	movs	r3, #0
 800b68c:	9307      	str	r3, [sp, #28]
 800b68e:	e401      	b.n	800ae94 <_svfiprintf_r+0x214>
 800b690:	9d06      	ldr	r5, [sp, #24]
 800b692:	682c      	ldr	r4, [r5, #0]
 800b694:	3504      	adds	r5, #4
 800b696:	9506      	str	r5, [sp, #24]
 800b698:	17e5      	asrs	r5, r4, #31
 800b69a:	e422      	b.n	800aee2 <_svfiprintf_r+0x262>
 800b69c:	9806      	ldr	r0, [sp, #24]
 800b69e:	6802      	ldr	r2, [r0, #0]
 800b6a0:	3004      	adds	r0, #4
 800b6a2:	4614      	mov	r4, r2
 800b6a4:	2500      	movs	r5, #0
 800b6a6:	3a00      	subs	r2, #0
 800b6a8:	9006      	str	r0, [sp, #24]
 800b6aa:	bf18      	it	ne
 800b6ac:	2201      	movne	r2, #1
 800b6ae:	f7ff bbb0 	b.w	800ae12 <_svfiprintf_r+0x192>
 800b6b2:	9d06      	ldr	r5, [sp, #24]
 800b6b4:	682c      	ldr	r4, [r5, #0]
 800b6b6:	3504      	adds	r5, #4
 800b6b8:	9506      	str	r5, [sp, #24]
 800b6ba:	2500      	movs	r5, #0
 800b6bc:	e4ba      	b.n	800b034 <_svfiprintf_r+0x3b4>
 800b6be:	9806      	ldr	r0, [sp, #24]
 800b6c0:	2301      	movs	r3, #1
 800b6c2:	6802      	ldr	r2, [r0, #0]
 800b6c4:	e7ec      	b.n	800b6a0 <_svfiprintf_r+0xa20>
 800b6c6:	2140      	movs	r1, #64	; 0x40
 800b6c8:	9201      	str	r2, [sp, #4]
 800b6ca:	f7fa ff11 	bl	80064f0 <_malloc_r>
 800b6ce:	9a01      	ldr	r2, [sp, #4]
 800b6d0:	f8c9 0000 	str.w	r0, [r9]
 800b6d4:	f8c9 0010 	str.w	r0, [r9, #16]
 800b6d8:	2800      	cmp	r0, #0
 800b6da:	d038      	beq.n	800b74e <_svfiprintf_r+0xace>
 800b6dc:	2340      	movs	r3, #64	; 0x40
 800b6de:	f8c9 3014 	str.w	r3, [r9, #20]
 800b6e2:	f7ff badb 	b.w	800ac9c <_svfiprintf_r+0x1c>
 800b6e6:	f24d 05f0 	movw	r5, #53488	; 0xd0f0
 800b6ea:	f106 0c08 	add.w	ip, r6, #8
 800b6ee:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800b6f0:	f6c0 0500 	movt	r5, #2048	; 0x800
 800b6f4:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b6f6:	e4fe      	b.n	800b0f6 <_svfiprintf_r+0x476>
 800b6f8:	f24d 05f0 	movw	r5, #53488	; 0xd0f0
 800b6fc:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b6fe:	f6c0 0500 	movt	r5, #2048	; 0x800
 800b702:	e61d      	b.n	800b340 <_svfiprintf_r+0x6c0>
 800b704:	f1b8 0f06 	cmp.w	r8, #6
 800b708:	bf34      	ite	cc
 800b70a:	4641      	movcc	r1, r8
 800b70c:	2106      	movcs	r1, #6
 800b70e:	f24d 2214 	movw	r2, #53780	; 0xd214
 800b712:	ea21 73e1 	bic.w	r3, r1, r1, asr #31
 800b716:	f6c0 0200 	movt	r2, #2048	; 0x800
 800b71a:	9103      	str	r1, [sp, #12]
 800b71c:	9302      	str	r3, [sp, #8]
 800b71e:	9209      	str	r2, [sp, #36]	; 0x24
 800b720:	e4a9      	b.n	800b076 <_svfiprintf_r+0x3f6>
 800b722:	4d0e      	ldr	r5, [pc, #56]	; (800b75c <_svfiprintf_r+0xadc>)
 800b724:	468c      	mov	ip, r1
 800b726:	e673      	b.n	800b410 <_svfiprintf_r+0x790>
 800b728:	f8cd 800c 	str.w	r8, [sp, #12]
 800b72c:	9007      	str	r0, [sp, #28]
 800b72e:	f7ff bbb1 	b.w	800ae94 <_svfiprintf_r+0x214>
 800b732:	9d06      	ldr	r5, [sp, #24]
 800b734:	1d2a      	adds	r2, r5, #4
 800b736:	f8d5 8000 	ldr.w	r8, [r5]
 800b73a:	f1b8 0f00 	cmp.w	r8, #0
 800b73e:	f6bf af38 	bge.w	800b5b2 <_svfiprintf_r+0x932>
 800b742:	783b      	ldrb	r3, [r7, #0]
 800b744:	f04f 38ff 	mov.w	r8, #4294967295
 800b748:	9206      	str	r2, [sp, #24]
 800b74a:	f7ff baec 	b.w	800ad26 <_svfiprintf_r+0xa6>
 800b74e:	3801      	subs	r0, #1
 800b750:	230c      	movs	r3, #12
 800b752:	9005      	str	r0, [sp, #20]
 800b754:	f8cb 3000 	str.w	r3, [fp]
 800b758:	e627      	b.n	800b3aa <_svfiprintf_r+0x72a>
 800b75a:	bf00      	nop
 800b75c:	0800d100 	.word	0x0800d100

0800b760 <_calloc_r>:
 800b760:	b538      	push	{r3, r4, r5, lr}
 800b762:	fb01 f102 	mul.w	r1, r1, r2
 800b766:	f7fa fec3 	bl	80064f0 <_malloc_r>
 800b76a:	4604      	mov	r4, r0
 800b76c:	b1f8      	cbz	r0, 800b7ae <_calloc_r+0x4e>
 800b76e:	f850 2c04 	ldr.w	r2, [r0, #-4]
 800b772:	f022 0203 	bic.w	r2, r2, #3
 800b776:	3a04      	subs	r2, #4
 800b778:	2a24      	cmp	r2, #36	; 0x24
 800b77a:	d81a      	bhi.n	800b7b2 <_calloc_r+0x52>
 800b77c:	2a13      	cmp	r2, #19
 800b77e:	4603      	mov	r3, r0
 800b780:	d90f      	bls.n	800b7a2 <_calloc_r+0x42>
 800b782:	2100      	movs	r1, #0
 800b784:	f840 1b04 	str.w	r1, [r0], #4
 800b788:	1d03      	adds	r3, r0, #4
 800b78a:	2a1b      	cmp	r2, #27
 800b78c:	6061      	str	r1, [r4, #4]
 800b78e:	d908      	bls.n	800b7a2 <_calloc_r+0x42>
 800b790:	1d1d      	adds	r5, r3, #4
 800b792:	6041      	str	r1, [r0, #4]
 800b794:	6059      	str	r1, [r3, #4]
 800b796:	3308      	adds	r3, #8
 800b798:	2a24      	cmp	r2, #36	; 0x24
 800b79a:	bf02      	ittt	eq
 800b79c:	6069      	streq	r1, [r5, #4]
 800b79e:	6059      	streq	r1, [r3, #4]
 800b7a0:	3308      	addeq	r3, #8
 800b7a2:	461a      	mov	r2, r3
 800b7a4:	2100      	movs	r1, #0
 800b7a6:	f842 1b04 	str.w	r1, [r2], #4
 800b7aa:	6059      	str	r1, [r3, #4]
 800b7ac:	6051      	str	r1, [r2, #4]
 800b7ae:	4620      	mov	r0, r4
 800b7b0:	bd38      	pop	{r3, r4, r5, pc}
 800b7b2:	2100      	movs	r1, #0
 800b7b4:	f7fe fb7e 	bl	8009eb4 <memset>
 800b7b8:	4620      	mov	r0, r4
 800b7ba:	bd38      	pop	{r3, r4, r5, pc}

0800b7bc <_close_r>:
 800b7bc:	b538      	push	{r3, r4, r5, lr}
 800b7be:	f642 248c 	movw	r4, #10892	; 0x2a8c
 800b7c2:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800b7c6:	4605      	mov	r5, r0
 800b7c8:	4608      	mov	r0, r1
 800b7ca:	2300      	movs	r3, #0
 800b7cc:	6023      	str	r3, [r4, #0]
 800b7ce:	f7f5 f9fb 	bl	8000bc8 <_close>
 800b7d2:	f1b0 3fff 	cmp.w	r0, #4294967295
 800b7d6:	d000      	beq.n	800b7da <_close_r+0x1e>
 800b7d8:	bd38      	pop	{r3, r4, r5, pc}
 800b7da:	6823      	ldr	r3, [r4, #0]
 800b7dc:	2b00      	cmp	r3, #0
 800b7de:	d0fb      	beq.n	800b7d8 <_close_r+0x1c>
 800b7e0:	602b      	str	r3, [r5, #0]
 800b7e2:	bd38      	pop	{r3, r4, r5, pc}

0800b7e4 <_fclose_r>:
 800b7e4:	b570      	push	{r4, r5, r6, lr}
 800b7e6:	460c      	mov	r4, r1
 800b7e8:	4605      	mov	r5, r0
 800b7ea:	460e      	mov	r6, r1
 800b7ec:	2900      	cmp	r1, #0
 800b7ee:	d048      	beq.n	800b882 <_fclose_r+0x9e>
 800b7f0:	f7fe f88c 	bl	800990c <__sfp_lock_acquire>
 800b7f4:	b115      	cbz	r5, 800b7fc <_fclose_r+0x18>
 800b7f6:	69ab      	ldr	r3, [r5, #24]
 800b7f8:	2b00      	cmp	r3, #0
 800b7fa:	d044      	beq.n	800b886 <_fclose_r+0xa2>
 800b7fc:	f64c 7368 	movw	r3, #53096	; 0xcf68
 800b800:	f6c0 0300 	movt	r3, #2048	; 0x800
 800b804:	429c      	cmp	r4, r3
 800b806:	bf08      	it	eq
 800b808:	686c      	ldreq	r4, [r5, #4]
 800b80a:	d00e      	beq.n	800b82a <_fclose_r+0x46>
 800b80c:	f64c 7388 	movw	r3, #53128	; 0xcf88
 800b810:	f6c0 0300 	movt	r3, #2048	; 0x800
 800b814:	429c      	cmp	r4, r3
 800b816:	bf08      	it	eq
 800b818:	68ac      	ldreq	r4, [r5, #8]
 800b81a:	d006      	beq.n	800b82a <_fclose_r+0x46>
 800b81c:	f64c 73a8 	movw	r3, #53160	; 0xcfa8
 800b820:	f6c0 0300 	movt	r3, #2048	; 0x800
 800b824:	429c      	cmp	r4, r3
 800b826:	bf08      	it	eq
 800b828:	68ec      	ldreq	r4, [r5, #12]
 800b82a:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
 800b82e:	b336      	cbz	r6, 800b87e <_fclose_r+0x9a>
 800b830:	4628      	mov	r0, r5
 800b832:	4621      	mov	r1, r4
 800b834:	f7fd fe84 	bl	8009540 <_fflush_r>
 800b838:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800b83a:	4606      	mov	r6, r0
 800b83c:	b13b      	cbz	r3, 800b84e <_fclose_r+0x6a>
 800b83e:	4628      	mov	r0, r5
 800b840:	6a21      	ldr	r1, [r4, #32]
 800b842:	4798      	blx	r3
 800b844:	ea36 0620 	bics.w	r6, r6, r0, asr #32
 800b848:	bf28      	it	cs
 800b84a:	f04f 36ff 	movcs.w	r6, #4294967295
 800b84e:	89a3      	ldrh	r3, [r4, #12]
 800b850:	f013 0f80 	tst.w	r3, #128	; 0x80
 800b854:	d11b      	bne.n	800b88e <_fclose_r+0xaa>
 800b856:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800b858:	b141      	cbz	r1, 800b86c <_fclose_r+0x88>
 800b85a:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800b85e:	4299      	cmp	r1, r3
 800b860:	d002      	beq.n	800b868 <_fclose_r+0x84>
 800b862:	4628      	mov	r0, r5
 800b864:	f7fe f8c6 	bl	80099f4 <_free_r>
 800b868:	2300      	movs	r3, #0
 800b86a:	6363      	str	r3, [r4, #52]	; 0x34
 800b86c:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800b86e:	b121      	cbz	r1, 800b87a <_fclose_r+0x96>
 800b870:	4628      	mov	r0, r5
 800b872:	f7fe f8bf 	bl	80099f4 <_free_r>
 800b876:	2300      	movs	r3, #0
 800b878:	64a3      	str	r3, [r4, #72]	; 0x48
 800b87a:	2300      	movs	r3, #0
 800b87c:	81a3      	strh	r3, [r4, #12]
 800b87e:	f7fe f847 	bl	8009910 <__sfp_lock_release>
 800b882:	4630      	mov	r0, r6
 800b884:	bd70      	pop	{r4, r5, r6, pc}
 800b886:	4628      	mov	r0, r5
 800b888:	f7fd ff78 	bl	800977c <__sinit>
 800b88c:	e7b6      	b.n	800b7fc <_fclose_r+0x18>
 800b88e:	4628      	mov	r0, r5
 800b890:	6921      	ldr	r1, [r4, #16]
 800b892:	f7fe f8af 	bl	80099f4 <_free_r>
 800b896:	e7de      	b.n	800b856 <_fclose_r+0x72>

0800b898 <fclose>:
 800b898:	f240 2378 	movw	r3, #632	; 0x278
 800b89c:	4601      	mov	r1, r0
 800b89e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b8a2:	6818      	ldr	r0, [r3, #0]
 800b8a4:	e79e      	b.n	800b7e4 <_fclose_r>
 800b8a6:	bf00      	nop

0800b8a8 <_lseek_r>:
 800b8a8:	b538      	push	{r3, r4, r5, lr}
 800b8aa:	f642 248c 	movw	r4, #10892	; 0x2a8c
 800b8ae:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800b8b2:	4605      	mov	r5, r0
 800b8b4:	4608      	mov	r0, r1
 800b8b6:	4611      	mov	r1, r2
 800b8b8:	461a      	mov	r2, r3
 800b8ba:	2300      	movs	r3, #0
 800b8bc:	6023      	str	r3, [r4, #0]
 800b8be:	f7f5 f989 	bl	8000bd4 <_lseek>
 800b8c2:	f1b0 3fff 	cmp.w	r0, #4294967295
 800b8c6:	d000      	beq.n	800b8ca <_lseek_r+0x22>
 800b8c8:	bd38      	pop	{r3, r4, r5, pc}
 800b8ca:	6823      	ldr	r3, [r4, #0]
 800b8cc:	2b00      	cmp	r3, #0
 800b8ce:	d0fb      	beq.n	800b8c8 <_lseek_r+0x20>
 800b8d0:	602b      	str	r3, [r5, #0]
 800b8d2:	bd38      	pop	{r3, r4, r5, pc}

0800b8d4 <memmove>:
 800b8d4:	4288      	cmp	r0, r1
 800b8d6:	4603      	mov	r3, r0
 800b8d8:	b4f0      	push	{r4, r5, r6, r7}
 800b8da:	460c      	mov	r4, r1
 800b8dc:	d90e      	bls.n	800b8fc <memmove+0x28>
 800b8de:	188d      	adds	r5, r1, r2
 800b8e0:	42a8      	cmp	r0, r5
 800b8e2:	d20b      	bcs.n	800b8fc <memmove+0x28>
 800b8e4:	b142      	cbz	r2, 800b8f8 <memmove+0x24>
 800b8e6:	1883      	adds	r3, r0, r2
 800b8e8:	4629      	mov	r1, r5
 800b8ea:	1a9a      	subs	r2, r3, r2
 800b8ec:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
 800b8f0:	f803 4d01 	strb.w	r4, [r3, #-1]!
 800b8f4:	4293      	cmp	r3, r2
 800b8f6:	d1f9      	bne.n	800b8ec <memmove+0x18>
 800b8f8:	bcf0      	pop	{r4, r5, r6, r7}
 800b8fa:	4770      	bx	lr
 800b8fc:	2a0f      	cmp	r2, #15
 800b8fe:	d938      	bls.n	800b972 <memmove+0x9e>
 800b900:	ea41 0500 	orr.w	r5, r1, r0
 800b904:	f015 0f03 	tst.w	r5, #3
 800b908:	d135      	bne.n	800b976 <memmove+0xa2>
 800b90a:	f1a2 0610 	sub.w	r6, r2, #16
 800b90e:	f101 0510 	add.w	r5, r1, #16
 800b912:	460b      	mov	r3, r1
 800b914:	4602      	mov	r2, r0
 800b916:	0937      	lsrs	r7, r6, #4
 800b918:	eb05 1507 	add.w	r5, r5, r7, lsl #4
 800b91c:	681c      	ldr	r4, [r3, #0]
 800b91e:	6014      	str	r4, [r2, #0]
 800b920:	685c      	ldr	r4, [r3, #4]
 800b922:	6054      	str	r4, [r2, #4]
 800b924:	689c      	ldr	r4, [r3, #8]
 800b926:	6094      	str	r4, [r2, #8]
 800b928:	68dc      	ldr	r4, [r3, #12]
 800b92a:	3310      	adds	r3, #16
 800b92c:	60d4      	str	r4, [r2, #12]
 800b92e:	3210      	adds	r2, #16
 800b930:	429d      	cmp	r5, r3
 800b932:	d1f3      	bne.n	800b91c <memmove+0x48>
 800b934:	1c7c      	adds	r4, r7, #1
 800b936:	f006 020f 	and.w	r2, r6, #15
 800b93a:	0124      	lsls	r4, r4, #4
 800b93c:	2a03      	cmp	r2, #3
 800b93e:	eb00 0304 	add.w	r3, r0, r4
 800b942:	4421      	add	r1, r4
 800b944:	d914      	bls.n	800b970 <memmove+0x9c>
 800b946:	3a04      	subs	r2, #4
 800b948:	460c      	mov	r4, r1
 800b94a:	461d      	mov	r5, r3
 800b94c:	ea4f 0c92 	mov.w	ip, r2, lsr #2
 800b950:	eb01 078c 	add.w	r7, r1, ip, lsl #2
 800b954:	3704      	adds	r7, #4
 800b956:	f854 6b04 	ldr.w	r6, [r4], #4
 800b95a:	42bc      	cmp	r4, r7
 800b95c:	f845 6b04 	str.w	r6, [r5], #4
 800b960:	d1f9      	bne.n	800b956 <memmove+0x82>
 800b962:	f10c 0401 	add.w	r4, ip, #1
 800b966:	f002 0203 	and.w	r2, r2, #3
 800b96a:	00a4      	lsls	r4, r4, #2
 800b96c:	191b      	adds	r3, r3, r4
 800b96e:	1909      	adds	r1, r1, r4
 800b970:	460c      	mov	r4, r1
 800b972:	2a00      	cmp	r2, #0
 800b974:	d0c0      	beq.n	800b8f8 <memmove+0x24>
 800b976:	4621      	mov	r1, r4
 800b978:	18a2      	adds	r2, r4, r2
 800b97a:	f811 4b01 	ldrb.w	r4, [r1], #1
 800b97e:	4291      	cmp	r1, r2
 800b980:	f803 4b01 	strb.w	r4, [r3], #1
 800b984:	d1f9      	bne.n	800b97a <memmove+0xa6>
 800b986:	e7b7      	b.n	800b8f8 <memmove+0x24>

0800b988 <_realloc_r>:
 800b988:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b98c:	460d      	mov	r5, r1
 800b98e:	b083      	sub	sp, #12
 800b990:	4607      	mov	r7, r0
 800b992:	4690      	mov	r8, r2
 800b994:	2900      	cmp	r1, #0
 800b996:	f000 8155 	beq.w	800bc44 <_realloc_r+0x2bc>
 800b99a:	f108 040b 	add.w	r4, r8, #11
 800b99e:	f1a1 0a08 	sub.w	sl, r1, #8
 800b9a2:	f7fb f863 	bl	8006a6c <__malloc_lock>
 800b9a6:	2c16      	cmp	r4, #22
 800b9a8:	f8da 3004 	ldr.w	r3, [sl, #4]
 800b9ac:	f200 8097 	bhi.w	800bade <_realloc_r+0x156>
 800b9b0:	2210      	movs	r2, #16
 800b9b2:	2000      	movs	r0, #0
 800b9b4:	4614      	mov	r4, r2
 800b9b6:	4544      	cmp	r4, r8
 800b9b8:	bf38      	it	cc
 800b9ba:	f040 0001 	orrcc.w	r0, r0, #1
 800b9be:	2800      	cmp	r0, #0
 800b9c0:	f040 8146 	bne.w	800bc50 <_realloc_r+0x2c8>
 800b9c4:	f023 0b03 	bic.w	fp, r3, #3
 800b9c8:	4593      	cmp	fp, r2
 800b9ca:	bfa4      	itt	ge
 800b9cc:	f10a 0808 	addge.w	r8, sl, #8
 800b9d0:	465e      	movge	r6, fp
 800b9d2:	da6e      	bge.n	800bab2 <_realloc_r+0x12a>
 800b9d4:	f240 396c 	movw	r9, #876	; 0x36c
 800b9d8:	eb0a 010b 	add.w	r1, sl, fp
 800b9dc:	f2c2 0900 	movt	r9, #8192	; 0x2000
 800b9e0:	f8d9 e008 	ldr.w	lr, [r9, #8]
 800b9e4:	458e      	cmp	lr, r1
 800b9e6:	f000 8138 	beq.w	800bc5a <_realloc_r+0x2d2>
 800b9ea:	684e      	ldr	r6, [r1, #4]
 800b9ec:	f026 0c01 	bic.w	ip, r6, #1
 800b9f0:	448c      	add	ip, r1
 800b9f2:	f8dc c004 	ldr.w	ip, [ip, #4]
 800b9f6:	f01c 0f01 	tst.w	ip, #1
 800b9fa:	bf18      	it	ne
 800b9fc:	4601      	movne	r1, r0
 800b9fe:	d073      	beq.n	800bae8 <_realloc_r+0x160>
 800ba00:	f013 0f01 	tst.w	r3, #1
 800ba04:	f040 8092 	bne.w	800bb2c <_realloc_r+0x1a4>
 800ba08:	f855 3c08 	ldr.w	r3, [r5, #-8]
 800ba0c:	ebc3 0c0a 	rsb	ip, r3, sl
 800ba10:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800ba14:	f023 0303 	bic.w	r3, r3, #3
 800ba18:	2900      	cmp	r1, #0
 800ba1a:	f000 80d1 	beq.w	800bbc0 <_realloc_r+0x238>
 800ba1e:	4571      	cmp	r1, lr
 800ba20:	f000 814f 	beq.w	800bcc2 <_realloc_r+0x33a>
 800ba24:	445b      	add	r3, fp
 800ba26:	18c6      	adds	r6, r0, r3
 800ba28:	42b2      	cmp	r2, r6
 800ba2a:	f300 80ca 	bgt.w	800bbc2 <_realloc_r+0x23a>
 800ba2e:	68cb      	ldr	r3, [r1, #12]
 800ba30:	46e0      	mov	r8, ip
 800ba32:	6889      	ldr	r1, [r1, #8]
 800ba34:	f1ab 0204 	sub.w	r2, fp, #4
 800ba38:	2a24      	cmp	r2, #36	; 0x24
 800ba3a:	60cb      	str	r3, [r1, #12]
 800ba3c:	6099      	str	r1, [r3, #8]
 800ba3e:	f8dc 300c 	ldr.w	r3, [ip, #12]
 800ba42:	f858 1f08 	ldr.w	r1, [r8, #8]!
 800ba46:	60cb      	str	r3, [r1, #12]
 800ba48:	6099      	str	r1, [r3, #8]
 800ba4a:	f200 8196 	bhi.w	800bd7a <_realloc_r+0x3f2>
 800ba4e:	2a13      	cmp	r2, #19
 800ba50:	4641      	mov	r1, r8
 800ba52:	d921      	bls.n	800ba98 <_realloc_r+0x110>
 800ba54:	462b      	mov	r3, r5
 800ba56:	f10c 0110 	add.w	r1, ip, #16
 800ba5a:	f853 0b04 	ldr.w	r0, [r3], #4
 800ba5e:	f8cc 0008 	str.w	r0, [ip, #8]
 800ba62:	6868      	ldr	r0, [r5, #4]
 800ba64:	1d1d      	adds	r5, r3, #4
 800ba66:	2a1b      	cmp	r2, #27
 800ba68:	f8cc 000c 	str.w	r0, [ip, #12]
 800ba6c:	d914      	bls.n	800ba98 <_realloc_r+0x110>
 800ba6e:	6858      	ldr	r0, [r3, #4]
 800ba70:	1d2b      	adds	r3, r5, #4
 800ba72:	f10c 0118 	add.w	r1, ip, #24
 800ba76:	f8cc 0010 	str.w	r0, [ip, #16]
 800ba7a:	6868      	ldr	r0, [r5, #4]
 800ba7c:	3508      	adds	r5, #8
 800ba7e:	2a24      	cmp	r2, #36	; 0x24
 800ba80:	f8cc 0014 	str.w	r0, [ip, #20]
 800ba84:	d108      	bne.n	800ba98 <_realloc_r+0x110>
 800ba86:	685b      	ldr	r3, [r3, #4]
 800ba88:	f10c 0120 	add.w	r1, ip, #32
 800ba8c:	f8cc 3018 	str.w	r3, [ip, #24]
 800ba90:	686b      	ldr	r3, [r5, #4]
 800ba92:	3508      	adds	r5, #8
 800ba94:	f8cc 301c 	str.w	r3, [ip, #28]
 800ba98:	462a      	mov	r2, r5
 800ba9a:	460b      	mov	r3, r1
 800ba9c:	46e2      	mov	sl, ip
 800ba9e:	f852 0b04 	ldr.w	r0, [r2], #4
 800baa2:	f843 0b04 	str.w	r0, [r3], #4
 800baa6:	6868      	ldr	r0, [r5, #4]
 800baa8:	6048      	str	r0, [r1, #4]
 800baaa:	6852      	ldr	r2, [r2, #4]
 800baac:	605a      	str	r2, [r3, #4]
 800baae:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800bab2:	1b30      	subs	r0, r6, r4
 800bab4:	280f      	cmp	r0, #15
 800bab6:	d824      	bhi.n	800bb02 <_realloc_r+0x17a>
 800bab8:	eb0a 0206 	add.w	r2, sl, r6
 800babc:	f003 0301 	and.w	r3, r3, #1
 800bac0:	ea43 0606 	orr.w	r6, r3, r6
 800bac4:	f8ca 6004 	str.w	r6, [sl, #4]
 800bac8:	6853      	ldr	r3, [r2, #4]
 800baca:	f043 0301 	orr.w	r3, r3, #1
 800bace:	6053      	str	r3, [r2, #4]
 800bad0:	4638      	mov	r0, r7
 800bad2:	f7fa ffcd 	bl	8006a70 <__malloc_unlock>
 800bad6:	4640      	mov	r0, r8
 800bad8:	b003      	add	sp, #12
 800bada:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800bade:	f024 0407 	bic.w	r4, r4, #7
 800bae2:	4622      	mov	r2, r4
 800bae4:	0fe0      	lsrs	r0, r4, #31
 800bae6:	e766      	b.n	800b9b6 <_realloc_r+0x2e>
 800bae8:	f026 0003 	bic.w	r0, r6, #3
 800baec:	eb00 060b 	add.w	r6, r0, fp
 800baf0:	42b2      	cmp	r2, r6
 800baf2:	dc85      	bgt.n	800ba00 <_realloc_r+0x78>
 800baf4:	68ca      	ldr	r2, [r1, #12]
 800baf6:	f10a 0808 	add.w	r8, sl, #8
 800bafa:	6889      	ldr	r1, [r1, #8]
 800bafc:	60ca      	str	r2, [r1, #12]
 800bafe:	6091      	str	r1, [r2, #8]
 800bb00:	e7d7      	b.n	800bab2 <_realloc_r+0x12a>
 800bb02:	eb0a 0104 	add.w	r1, sl, r4
 800bb06:	f003 0301 	and.w	r3, r3, #1
 800bb0a:	180a      	adds	r2, r1, r0
 800bb0c:	ea43 0404 	orr.w	r4, r3, r4
 800bb10:	f040 0001 	orr.w	r0, r0, #1
 800bb14:	f8ca 4004 	str.w	r4, [sl, #4]
 800bb18:	6048      	str	r0, [r1, #4]
 800bb1a:	4638      	mov	r0, r7
 800bb1c:	6853      	ldr	r3, [r2, #4]
 800bb1e:	3108      	adds	r1, #8
 800bb20:	f043 0301 	orr.w	r3, r3, #1
 800bb24:	6053      	str	r3, [r2, #4]
 800bb26:	f7fd ff65 	bl	80099f4 <_free_r>
 800bb2a:	e7d1      	b.n	800bad0 <_realloc_r+0x148>
 800bb2c:	4641      	mov	r1, r8
 800bb2e:	4638      	mov	r0, r7
 800bb30:	f7fa fcde 	bl	80064f0 <_malloc_r>
 800bb34:	4680      	mov	r8, r0
 800bb36:	2800      	cmp	r0, #0
 800bb38:	d0ca      	beq.n	800bad0 <_realloc_r+0x148>
 800bb3a:	f8da 3004 	ldr.w	r3, [sl, #4]
 800bb3e:	f1a0 0208 	sub.w	r2, r0, #8
 800bb42:	f023 0101 	bic.w	r1, r3, #1
 800bb46:	4451      	add	r1, sl
 800bb48:	428a      	cmp	r2, r1
 800bb4a:	f000 810e 	beq.w	800bd6a <_realloc_r+0x3e2>
 800bb4e:	f1ab 0204 	sub.w	r2, fp, #4
 800bb52:	2a24      	cmp	r2, #36	; 0x24
 800bb54:	f200 80b1 	bhi.w	800bcba <_realloc_r+0x332>
 800bb58:	2a13      	cmp	r2, #19
 800bb5a:	4629      	mov	r1, r5
 800bb5c:	4603      	mov	r3, r0
 800bb5e:	d91d      	bls.n	800bb9c <_realloc_r+0x214>
 800bb60:	462c      	mov	r4, r5
 800bb62:	f854 3b04 	ldr.w	r3, [r4], #4
 800bb66:	1d21      	adds	r1, r4, #4
 800bb68:	f840 3b04 	str.w	r3, [r0], #4
 800bb6c:	1d03      	adds	r3, r0, #4
 800bb6e:	686e      	ldr	r6, [r5, #4]
 800bb70:	2a1b      	cmp	r2, #27
 800bb72:	f8c8 6004 	str.w	r6, [r8, #4]
 800bb76:	d911      	bls.n	800bb9c <_realloc_r+0x214>
 800bb78:	f8d4 e004 	ldr.w	lr, [r4, #4]
 800bb7c:	1d0e      	adds	r6, r1, #4
 800bb7e:	1d1c      	adds	r4, r3, #4
 800bb80:	f8c0 e004 	str.w	lr, [r0, #4]
 800bb84:	6848      	ldr	r0, [r1, #4]
 800bb86:	3108      	adds	r1, #8
 800bb88:	6058      	str	r0, [r3, #4]
 800bb8a:	3308      	adds	r3, #8
 800bb8c:	2a24      	cmp	r2, #36	; 0x24
 800bb8e:	d105      	bne.n	800bb9c <_realloc_r+0x214>
 800bb90:	6872      	ldr	r2, [r6, #4]
 800bb92:	6062      	str	r2, [r4, #4]
 800bb94:	684a      	ldr	r2, [r1, #4]
 800bb96:	3108      	adds	r1, #8
 800bb98:	605a      	str	r2, [r3, #4]
 800bb9a:	3308      	adds	r3, #8
 800bb9c:	4608      	mov	r0, r1
 800bb9e:	461a      	mov	r2, r3
 800bba0:	f850 4b04 	ldr.w	r4, [r0], #4
 800bba4:	f842 4b04 	str.w	r4, [r2], #4
 800bba8:	6849      	ldr	r1, [r1, #4]
 800bbaa:	6059      	str	r1, [r3, #4]
 800bbac:	6843      	ldr	r3, [r0, #4]
 800bbae:	6053      	str	r3, [r2, #4]
 800bbb0:	4638      	mov	r0, r7
 800bbb2:	4629      	mov	r1, r5
 800bbb4:	f7fd ff1e 	bl	80099f4 <_free_r>
 800bbb8:	4638      	mov	r0, r7
 800bbba:	f7fa ff59 	bl	8006a70 <__malloc_unlock>
 800bbbe:	e78a      	b.n	800bad6 <_realloc_r+0x14e>
 800bbc0:	445b      	add	r3, fp
 800bbc2:	429a      	cmp	r2, r3
 800bbc4:	dcb2      	bgt.n	800bb2c <_realloc_r+0x1a4>
 800bbc6:	46e0      	mov	r8, ip
 800bbc8:	f8dc 100c 	ldr.w	r1, [ip, #12]
 800bbcc:	f1ab 0204 	sub.w	r2, fp, #4
 800bbd0:	f858 0f08 	ldr.w	r0, [r8, #8]!
 800bbd4:	2a24      	cmp	r2, #36	; 0x24
 800bbd6:	60c1      	str	r1, [r0, #12]
 800bbd8:	6088      	str	r0, [r1, #8]
 800bbda:	d85f      	bhi.n	800bc9c <_realloc_r+0x314>
 800bbdc:	2a13      	cmp	r2, #19
 800bbde:	4640      	mov	r0, r8
 800bbe0:	d921      	bls.n	800bc26 <_realloc_r+0x29e>
 800bbe2:	4629      	mov	r1, r5
 800bbe4:	f10c 0010 	add.w	r0, ip, #16
 800bbe8:	f851 6b04 	ldr.w	r6, [r1], #4
 800bbec:	f8cc 6008 	str.w	r6, [ip, #8]
 800bbf0:	686e      	ldr	r6, [r5, #4]
 800bbf2:	1d0d      	adds	r5, r1, #4
 800bbf4:	2a1b      	cmp	r2, #27
 800bbf6:	f8cc 600c 	str.w	r6, [ip, #12]
 800bbfa:	d914      	bls.n	800bc26 <_realloc_r+0x29e>
 800bbfc:	684e      	ldr	r6, [r1, #4]
 800bbfe:	1d29      	adds	r1, r5, #4
 800bc00:	f10c 0018 	add.w	r0, ip, #24
 800bc04:	f8cc 6010 	str.w	r6, [ip, #16]
 800bc08:	686e      	ldr	r6, [r5, #4]
 800bc0a:	3508      	adds	r5, #8
 800bc0c:	2a24      	cmp	r2, #36	; 0x24
 800bc0e:	f8cc 6014 	str.w	r6, [ip, #20]
 800bc12:	d108      	bne.n	800bc26 <_realloc_r+0x29e>
 800bc14:	684a      	ldr	r2, [r1, #4]
 800bc16:	f10c 0020 	add.w	r0, ip, #32
 800bc1a:	f8cc 2018 	str.w	r2, [ip, #24]
 800bc1e:	686a      	ldr	r2, [r5, #4]
 800bc20:	3508      	adds	r5, #8
 800bc22:	f8cc 201c 	str.w	r2, [ip, #28]
 800bc26:	4629      	mov	r1, r5
 800bc28:	461e      	mov	r6, r3
 800bc2a:	4602      	mov	r2, r0
 800bc2c:	46e2      	mov	sl, ip
 800bc2e:	f851 3b04 	ldr.w	r3, [r1], #4
 800bc32:	f842 3b04 	str.w	r3, [r2], #4
 800bc36:	686b      	ldr	r3, [r5, #4]
 800bc38:	6043      	str	r3, [r0, #4]
 800bc3a:	684b      	ldr	r3, [r1, #4]
 800bc3c:	6053      	str	r3, [r2, #4]
 800bc3e:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800bc42:	e736      	b.n	800bab2 <_realloc_r+0x12a>
 800bc44:	4611      	mov	r1, r2
 800bc46:	b003      	add	sp, #12
 800bc48:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800bc4c:	f7fa bc50 	b.w	80064f0 <_malloc_r>
 800bc50:	230c      	movs	r3, #12
 800bc52:	f04f 0800 	mov.w	r8, #0
 800bc56:	603b      	str	r3, [r7, #0]
 800bc58:	e73d      	b.n	800bad6 <_realloc_r+0x14e>
 800bc5a:	f8de 0004 	ldr.w	r0, [lr, #4]
 800bc5e:	f104 0c10 	add.w	ip, r4, #16
 800bc62:	f020 0003 	bic.w	r0, r0, #3
 800bc66:	eb00 010b 	add.w	r1, r0, fp
 800bc6a:	4561      	cmp	r1, ip
 800bc6c:	bfb8      	it	lt
 800bc6e:	4671      	movlt	r1, lr
 800bc70:	f6ff aec6 	blt.w	800ba00 <_realloc_r+0x78>
 800bc74:	eb0a 0304 	add.w	r3, sl, r4
 800bc78:	1b0a      	subs	r2, r1, r4
 800bc7a:	f042 0201 	orr.w	r2, r2, #1
 800bc7e:	f8c9 3008 	str.w	r3, [r9, #8]
 800bc82:	605a      	str	r2, [r3, #4]
 800bc84:	4638      	mov	r0, r7
 800bc86:	f8da 2004 	ldr.w	r2, [sl, #4]
 800bc8a:	46a8      	mov	r8, r5
 800bc8c:	f002 0301 	and.w	r3, r2, #1
 800bc90:	431c      	orrs	r4, r3
 800bc92:	f8ca 4004 	str.w	r4, [sl, #4]
 800bc96:	f7fa feeb 	bl	8006a70 <__malloc_unlock>
 800bc9a:	e71c      	b.n	800bad6 <_realloc_r+0x14e>
 800bc9c:	4640      	mov	r0, r8
 800bc9e:	4629      	mov	r1, r5
 800bca0:	9301      	str	r3, [sp, #4]
 800bca2:	f8cd c000 	str.w	ip, [sp]
 800bca6:	f7ff fe15 	bl	800b8d4 <memmove>
 800bcaa:	f8dd c000 	ldr.w	ip, [sp]
 800bcae:	9b01      	ldr	r3, [sp, #4]
 800bcb0:	46e2      	mov	sl, ip
 800bcb2:	461e      	mov	r6, r3
 800bcb4:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800bcb8:	e6fb      	b.n	800bab2 <_realloc_r+0x12a>
 800bcba:	4629      	mov	r1, r5
 800bcbc:	f7ff fe0a 	bl	800b8d4 <memmove>
 800bcc0:	e776      	b.n	800bbb0 <_realloc_r+0x228>
 800bcc2:	445b      	add	r3, fp
 800bcc4:	f104 0110 	add.w	r1, r4, #16
 800bcc8:	18c6      	adds	r6, r0, r3
 800bcca:	428e      	cmp	r6, r1
 800bccc:	f6ff af79 	blt.w	800bbc2 <_realloc_r+0x23a>
 800bcd0:	46e0      	mov	r8, ip
 800bcd2:	f8dc 300c 	ldr.w	r3, [ip, #12]
 800bcd6:	f1ab 0204 	sub.w	r2, fp, #4
 800bcda:	f858 1f08 	ldr.w	r1, [r8, #8]!
 800bcde:	2a24      	cmp	r2, #36	; 0x24
 800bce0:	60cb      	str	r3, [r1, #12]
 800bce2:	6099      	str	r1, [r3, #8]
 800bce4:	d855      	bhi.n	800bd92 <_realloc_r+0x40a>
 800bce6:	2a13      	cmp	r2, #19
 800bce8:	4641      	mov	r1, r8
 800bcea:	d921      	bls.n	800bd30 <_realloc_r+0x3a8>
 800bcec:	462b      	mov	r3, r5
 800bcee:	f10c 0110 	add.w	r1, ip, #16
 800bcf2:	f853 0b04 	ldr.w	r0, [r3], #4
 800bcf6:	f8cc 0008 	str.w	r0, [ip, #8]
 800bcfa:	6868      	ldr	r0, [r5, #4]
 800bcfc:	1d1d      	adds	r5, r3, #4
 800bcfe:	2a1b      	cmp	r2, #27
 800bd00:	f8cc 000c 	str.w	r0, [ip, #12]
 800bd04:	d914      	bls.n	800bd30 <_realloc_r+0x3a8>
 800bd06:	6858      	ldr	r0, [r3, #4]
 800bd08:	1d2b      	adds	r3, r5, #4
 800bd0a:	f10c 0118 	add.w	r1, ip, #24
 800bd0e:	f8cc 0010 	str.w	r0, [ip, #16]
 800bd12:	6868      	ldr	r0, [r5, #4]
 800bd14:	3508      	adds	r5, #8
 800bd16:	2a24      	cmp	r2, #36	; 0x24
 800bd18:	f8cc 0014 	str.w	r0, [ip, #20]
 800bd1c:	d108      	bne.n	800bd30 <_realloc_r+0x3a8>
 800bd1e:	685b      	ldr	r3, [r3, #4]
 800bd20:	f10c 0120 	add.w	r1, ip, #32
 800bd24:	f8cc 3018 	str.w	r3, [ip, #24]
 800bd28:	686b      	ldr	r3, [r5, #4]
 800bd2a:	3508      	adds	r5, #8
 800bd2c:	f8cc 301c 	str.w	r3, [ip, #28]
 800bd30:	462a      	mov	r2, r5
 800bd32:	460b      	mov	r3, r1
 800bd34:	f852 0b04 	ldr.w	r0, [r2], #4
 800bd38:	f843 0b04 	str.w	r0, [r3], #4
 800bd3c:	6868      	ldr	r0, [r5, #4]
 800bd3e:	6048      	str	r0, [r1, #4]
 800bd40:	6852      	ldr	r2, [r2, #4]
 800bd42:	605a      	str	r2, [r3, #4]
 800bd44:	eb0c 0304 	add.w	r3, ip, r4
 800bd48:	1b32      	subs	r2, r6, r4
 800bd4a:	f042 0201 	orr.w	r2, r2, #1
 800bd4e:	f8c9 3008 	str.w	r3, [r9, #8]
 800bd52:	605a      	str	r2, [r3, #4]
 800bd54:	4638      	mov	r0, r7
 800bd56:	f8dc 2004 	ldr.w	r2, [ip, #4]
 800bd5a:	f002 0301 	and.w	r3, r2, #1
 800bd5e:	431c      	orrs	r4, r3
 800bd60:	f8cc 4004 	str.w	r4, [ip, #4]
 800bd64:	f7fa fe84 	bl	8006a70 <__malloc_unlock>
 800bd68:	e6b5      	b.n	800bad6 <_realloc_r+0x14e>
 800bd6a:	f850 6c04 	ldr.w	r6, [r0, #-4]
 800bd6e:	f10a 0808 	add.w	r8, sl, #8
 800bd72:	f026 0603 	bic.w	r6, r6, #3
 800bd76:	445e      	add	r6, fp
 800bd78:	e69b      	b.n	800bab2 <_realloc_r+0x12a>
 800bd7a:	4640      	mov	r0, r8
 800bd7c:	4629      	mov	r1, r5
 800bd7e:	f8cd c000 	str.w	ip, [sp]
 800bd82:	f7ff fda7 	bl	800b8d4 <memmove>
 800bd86:	f8dd c000 	ldr.w	ip, [sp]
 800bd8a:	46e2      	mov	sl, ip
 800bd8c:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800bd90:	e68f      	b.n	800bab2 <_realloc_r+0x12a>
 800bd92:	4640      	mov	r0, r8
 800bd94:	4629      	mov	r1, r5
 800bd96:	f8cd c000 	str.w	ip, [sp]
 800bd9a:	f7ff fd9b 	bl	800b8d4 <memmove>
 800bd9e:	f8dd c000 	ldr.w	ip, [sp]
 800bda2:	e7cf      	b.n	800bd44 <_realloc_r+0x3bc>
 800bda4:	0000      	movs	r0, r0
	...

0800bda8 <__aeabi_uidiv>:
 800bda8:	1e4a      	subs	r2, r1, #1
 800bdaa:	bf08      	it	eq
 800bdac:	4770      	bxeq	lr
 800bdae:	f0c0 8124 	bcc.w	800bffa <__aeabi_uidiv+0x252>
 800bdb2:	4288      	cmp	r0, r1
 800bdb4:	f240 8116 	bls.w	800bfe4 <__aeabi_uidiv+0x23c>
 800bdb8:	4211      	tst	r1, r2
 800bdba:	f000 8117 	beq.w	800bfec <__aeabi_uidiv+0x244>
 800bdbe:	fab0 f380 	clz	r3, r0
 800bdc2:	fab1 f281 	clz	r2, r1
 800bdc6:	eba2 0303 	sub.w	r3, r2, r3
 800bdca:	f1c3 031f 	rsb	r3, r3, #31
 800bdce:	a204      	add	r2, pc, #16	; (adr r2, 800bde0 <__aeabi_uidiv+0x38>)
 800bdd0:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800bdd4:	f04f 0200 	mov.w	r2, #0
 800bdd8:	469f      	mov	pc, r3
 800bdda:	bf00      	nop
 800bddc:	f3af 8000 	nop.w
 800bde0:	ebb0 7fc1 	cmp.w	r0, r1, lsl #31
 800bde4:	bf00      	nop
 800bde6:	eb42 0202 	adc.w	r2, r2, r2
 800bdea:	bf28      	it	cs
 800bdec:	eba0 70c1 	subcs.w	r0, r0, r1, lsl #31
 800bdf0:	ebb0 7f81 	cmp.w	r0, r1, lsl #30
 800bdf4:	bf00      	nop
 800bdf6:	eb42 0202 	adc.w	r2, r2, r2
 800bdfa:	bf28      	it	cs
 800bdfc:	eba0 7081 	subcs.w	r0, r0, r1, lsl #30
 800be00:	ebb0 7f41 	cmp.w	r0, r1, lsl #29
 800be04:	bf00      	nop
 800be06:	eb42 0202 	adc.w	r2, r2, r2
 800be0a:	bf28      	it	cs
 800be0c:	eba0 7041 	subcs.w	r0, r0, r1, lsl #29
 800be10:	ebb0 7f01 	cmp.w	r0, r1, lsl #28
 800be14:	bf00      	nop
 800be16:	eb42 0202 	adc.w	r2, r2, r2
 800be1a:	bf28      	it	cs
 800be1c:	eba0 7001 	subcs.w	r0, r0, r1, lsl #28
 800be20:	ebb0 6fc1 	cmp.w	r0, r1, lsl #27
 800be24:	bf00      	nop
 800be26:	eb42 0202 	adc.w	r2, r2, r2
 800be2a:	bf28      	it	cs
 800be2c:	eba0 60c1 	subcs.w	r0, r0, r1, lsl #27
 800be30:	ebb0 6f81 	cmp.w	r0, r1, lsl #26
 800be34:	bf00      	nop
 800be36:	eb42 0202 	adc.w	r2, r2, r2
 800be3a:	bf28      	it	cs
 800be3c:	eba0 6081 	subcs.w	r0, r0, r1, lsl #26
 800be40:	ebb0 6f41 	cmp.w	r0, r1, lsl #25
 800be44:	bf00      	nop
 800be46:	eb42 0202 	adc.w	r2, r2, r2
 800be4a:	bf28      	it	cs
 800be4c:	eba0 6041 	subcs.w	r0, r0, r1, lsl #25
 800be50:	ebb0 6f01 	cmp.w	r0, r1, lsl #24
 800be54:	bf00      	nop
 800be56:	eb42 0202 	adc.w	r2, r2, r2
 800be5a:	bf28      	it	cs
 800be5c:	eba0 6001 	subcs.w	r0, r0, r1, lsl #24
 800be60:	ebb0 5fc1 	cmp.w	r0, r1, lsl #23
 800be64:	bf00      	nop
 800be66:	eb42 0202 	adc.w	r2, r2, r2
 800be6a:	bf28      	it	cs
 800be6c:	eba0 50c1 	subcs.w	r0, r0, r1, lsl #23
 800be70:	ebb0 5f81 	cmp.w	r0, r1, lsl #22
 800be74:	bf00      	nop
 800be76:	eb42 0202 	adc.w	r2, r2, r2
 800be7a:	bf28      	it	cs
 800be7c:	eba0 5081 	subcs.w	r0, r0, r1, lsl #22
 800be80:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
 800be84:	bf00      	nop
 800be86:	eb42 0202 	adc.w	r2, r2, r2
 800be8a:	bf28      	it	cs
 800be8c:	eba0 5041 	subcs.w	r0, r0, r1, lsl #21
 800be90:	ebb0 5f01 	cmp.w	r0, r1, lsl #20
 800be94:	bf00      	nop
 800be96:	eb42 0202 	adc.w	r2, r2, r2
 800be9a:	bf28      	it	cs
 800be9c:	eba0 5001 	subcs.w	r0, r0, r1, lsl #20
 800bea0:	ebb0 4fc1 	cmp.w	r0, r1, lsl #19
 800bea4:	bf00      	nop
 800bea6:	eb42 0202 	adc.w	r2, r2, r2
 800beaa:	bf28      	it	cs
 800beac:	eba0 40c1 	subcs.w	r0, r0, r1, lsl #19
 800beb0:	ebb0 4f81 	cmp.w	r0, r1, lsl #18
 800beb4:	bf00      	nop
 800beb6:	eb42 0202 	adc.w	r2, r2, r2
 800beba:	bf28      	it	cs
 800bebc:	eba0 4081 	subcs.w	r0, r0, r1, lsl #18
 800bec0:	ebb0 4f41 	cmp.w	r0, r1, lsl #17
 800bec4:	bf00      	nop
 800bec6:	eb42 0202 	adc.w	r2, r2, r2
 800beca:	bf28      	it	cs
 800becc:	eba0 4041 	subcs.w	r0, r0, r1, lsl #17
 800bed0:	ebb0 4f01 	cmp.w	r0, r1, lsl #16
 800bed4:	bf00      	nop
 800bed6:	eb42 0202 	adc.w	r2, r2, r2
 800beda:	bf28      	it	cs
 800bedc:	eba0 4001 	subcs.w	r0, r0, r1, lsl #16
 800bee0:	ebb0 3fc1 	cmp.w	r0, r1, lsl #15
 800bee4:	bf00      	nop
 800bee6:	eb42 0202 	adc.w	r2, r2, r2
 800beea:	bf28      	it	cs
 800beec:	eba0 30c1 	subcs.w	r0, r0, r1, lsl #15
 800bef0:	ebb0 3f81 	cmp.w	r0, r1, lsl #14
 800bef4:	bf00      	nop
 800bef6:	eb42 0202 	adc.w	r2, r2, r2
 800befa:	bf28      	it	cs
 800befc:	eba0 3081 	subcs.w	r0, r0, r1, lsl #14
 800bf00:	ebb0 3f41 	cmp.w	r0, r1, lsl #13
 800bf04:	bf00      	nop
 800bf06:	eb42 0202 	adc.w	r2, r2, r2
 800bf0a:	bf28      	it	cs
 800bf0c:	eba0 3041 	subcs.w	r0, r0, r1, lsl #13
 800bf10:	ebb0 3f01 	cmp.w	r0, r1, lsl #12
 800bf14:	bf00      	nop
 800bf16:	eb42 0202 	adc.w	r2, r2, r2
 800bf1a:	bf28      	it	cs
 800bf1c:	eba0 3001 	subcs.w	r0, r0, r1, lsl #12
 800bf20:	ebb0 2fc1 	cmp.w	r0, r1, lsl #11
 800bf24:	bf00      	nop
 800bf26:	eb42 0202 	adc.w	r2, r2, r2
 800bf2a:	bf28      	it	cs
 800bf2c:	eba0 20c1 	subcs.w	r0, r0, r1, lsl #11
 800bf30:	ebb0 2f81 	cmp.w	r0, r1, lsl #10
 800bf34:	bf00      	nop
 800bf36:	eb42 0202 	adc.w	r2, r2, r2
 800bf3a:	bf28      	it	cs
 800bf3c:	eba0 2081 	subcs.w	r0, r0, r1, lsl #10
 800bf40:	ebb0 2f41 	cmp.w	r0, r1, lsl #9
 800bf44:	bf00      	nop
 800bf46:	eb42 0202 	adc.w	r2, r2, r2
 800bf4a:	bf28      	it	cs
 800bf4c:	eba0 2041 	subcs.w	r0, r0, r1, lsl #9
 800bf50:	ebb0 2f01 	cmp.w	r0, r1, lsl #8
 800bf54:	bf00      	nop
 800bf56:	eb42 0202 	adc.w	r2, r2, r2
 800bf5a:	bf28      	it	cs
 800bf5c:	eba0 2001 	subcs.w	r0, r0, r1, lsl #8
 800bf60:	ebb0 1fc1 	cmp.w	r0, r1, lsl #7
 800bf64:	bf00      	nop
 800bf66:	eb42 0202 	adc.w	r2, r2, r2
 800bf6a:	bf28      	it	cs
 800bf6c:	eba0 10c1 	subcs.w	r0, r0, r1, lsl #7
 800bf70:	ebb0 1f81 	cmp.w	r0, r1, lsl #6
 800bf74:	bf00      	nop
 800bf76:	eb42 0202 	adc.w	r2, r2, r2
 800bf7a:	bf28      	it	cs
 800bf7c:	eba0 1081 	subcs.w	r0, r0, r1, lsl #6
 800bf80:	ebb0 1f41 	cmp.w	r0, r1, lsl #5
 800bf84:	bf00      	nop
 800bf86:	eb42 0202 	adc.w	r2, r2, r2
 800bf8a:	bf28      	it	cs
 800bf8c:	eba0 1041 	subcs.w	r0, r0, r1, lsl #5
 800bf90:	ebb0 1f01 	cmp.w	r0, r1, lsl #4
 800bf94:	bf00      	nop
 800bf96:	eb42 0202 	adc.w	r2, r2, r2
 800bf9a:	bf28      	it	cs
 800bf9c:	eba0 1001 	subcs.w	r0, r0, r1, lsl #4
 800bfa0:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
 800bfa4:	bf00      	nop
 800bfa6:	eb42 0202 	adc.w	r2, r2, r2
 800bfaa:	bf28      	it	cs
 800bfac:	eba0 00c1 	subcs.w	r0, r0, r1, lsl #3
 800bfb0:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
 800bfb4:	bf00      	nop
 800bfb6:	eb42 0202 	adc.w	r2, r2, r2
 800bfba:	bf28      	it	cs
 800bfbc:	eba0 0081 	subcs.w	r0, r0, r1, lsl #2
 800bfc0:	ebb0 0f41 	cmp.w	r0, r1, lsl #1
 800bfc4:	bf00      	nop
 800bfc6:	eb42 0202 	adc.w	r2, r2, r2
 800bfca:	bf28      	it	cs
 800bfcc:	eba0 0041 	subcs.w	r0, r0, r1, lsl #1
 800bfd0:	ebb0 0f01 	cmp.w	r0, r1
 800bfd4:	bf00      	nop
 800bfd6:	eb42 0202 	adc.w	r2, r2, r2
 800bfda:	bf28      	it	cs
 800bfdc:	eba0 0001 	subcs.w	r0, r0, r1
 800bfe0:	4610      	mov	r0, r2
 800bfe2:	4770      	bx	lr
 800bfe4:	bf0c      	ite	eq
 800bfe6:	2001      	moveq	r0, #1
 800bfe8:	2000      	movne	r0, #0
 800bfea:	4770      	bx	lr
 800bfec:	fab1 f281 	clz	r2, r1
 800bff0:	f1c2 021f 	rsb	r2, r2, #31
 800bff4:	fa20 f002 	lsr.w	r0, r0, r2
 800bff8:	4770      	bx	lr
 800bffa:	b108      	cbz	r0, 800c000 <__aeabi_uidiv+0x258>
 800bffc:	f04f 30ff 	mov.w	r0, #4294967295
 800c000:	f000 b80e 	b.w	800c020 <__aeabi_idiv0>

0800c004 <__aeabi_uidivmod>:
 800c004:	2900      	cmp	r1, #0
 800c006:	d0f8      	beq.n	800bffa <__aeabi_uidiv+0x252>
 800c008:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
 800c00c:	f7ff fecc 	bl	800bda8 <__aeabi_uidiv>
 800c010:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
 800c014:	fb02 f300 	mul.w	r3, r2, r0
 800c018:	eba1 0103 	sub.w	r1, r1, r3
 800c01c:	4770      	bx	lr
 800c01e:	bf00      	nop

0800c020 <__aeabi_idiv0>:
 800c020:	4770      	bx	lr
 800c022:	bf00      	nop

0800c024 <__aeabi_dmul>:
 800c024:	b570      	push	{r4, r5, r6, lr}
 800c026:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800c02a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800c02e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800c032:	bf1d      	ittte	ne
 800c034:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800c038:	ea94 0f0c 	teqne	r4, ip
 800c03c:	ea95 0f0c 	teqne	r5, ip
 800c040:	f000 f8de 	bleq	800c200 <__aeabi_dmul+0x1dc>
 800c044:	442c      	add	r4, r5
 800c046:	ea81 0603 	eor.w	r6, r1, r3
 800c04a:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800c04e:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800c052:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800c056:	bf18      	it	ne
 800c058:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 800c05c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800c060:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800c064:	d038      	beq.n	800c0d8 <__aeabi_dmul+0xb4>
 800c066:	fba0 ce02 	umull	ip, lr, r0, r2
 800c06a:	f04f 0500 	mov.w	r5, #0
 800c06e:	fbe1 e502 	umlal	lr, r5, r1, r2
 800c072:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800c076:	fbe0 e503 	umlal	lr, r5, r0, r3
 800c07a:	f04f 0600 	mov.w	r6, #0
 800c07e:	fbe1 5603 	umlal	r5, r6, r1, r3
 800c082:	f09c 0f00 	teq	ip, #0
 800c086:	bf18      	it	ne
 800c088:	f04e 0e01 	orrne.w	lr, lr, #1
 800c08c:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800c090:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 800c094:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 800c098:	d204      	bcs.n	800c0a4 <__aeabi_dmul+0x80>
 800c09a:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800c09e:	416d      	adcs	r5, r5
 800c0a0:	eb46 0606 	adc.w	r6, r6, r6
 800c0a4:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800c0a8:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 800c0ac:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800c0b0:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 800c0b4:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800c0b8:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800c0bc:	bf88      	it	hi
 800c0be:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800c0c2:	d81e      	bhi.n	800c102 <__aeabi_dmul+0xde>
 800c0c4:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 800c0c8:	bf08      	it	eq
 800c0ca:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800c0ce:	f150 0000 	adcs.w	r0, r0, #0
 800c0d2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800c0d6:	bd70      	pop	{r4, r5, r6, pc}
 800c0d8:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 800c0dc:	ea46 0101 	orr.w	r1, r6, r1
 800c0e0:	ea40 0002 	orr.w	r0, r0, r2
 800c0e4:	ea81 0103 	eor.w	r1, r1, r3
 800c0e8:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 800c0ec:	bfc2      	ittt	gt
 800c0ee:	ebd4 050c 	rsbsgt	r5, r4, ip
 800c0f2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800c0f6:	bd70      	popgt	{r4, r5, r6, pc}
 800c0f8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800c0fc:	f04f 0e00 	mov.w	lr, #0
 800c100:	3c01      	subs	r4, #1
 800c102:	f300 80ab 	bgt.w	800c25c <__aeabi_dmul+0x238>
 800c106:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800c10a:	bfde      	ittt	le
 800c10c:	2000      	movle	r0, #0
 800c10e:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800c112:	bd70      	pople	{r4, r5, r6, pc}
 800c114:	f1c4 0400 	rsb	r4, r4, #0
 800c118:	3c20      	subs	r4, #32
 800c11a:	da35      	bge.n	800c188 <__aeabi_dmul+0x164>
 800c11c:	340c      	adds	r4, #12
 800c11e:	dc1b      	bgt.n	800c158 <__aeabi_dmul+0x134>
 800c120:	f104 0414 	add.w	r4, r4, #20
 800c124:	f1c4 0520 	rsb	r5, r4, #32
 800c128:	fa00 f305 	lsl.w	r3, r0, r5
 800c12c:	fa20 f004 	lsr.w	r0, r0, r4
 800c130:	fa01 f205 	lsl.w	r2, r1, r5
 800c134:	ea40 0002 	orr.w	r0, r0, r2
 800c138:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 800c13c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800c140:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800c144:	fa21 f604 	lsr.w	r6, r1, r4
 800c148:	eb42 0106 	adc.w	r1, r2, r6
 800c14c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800c150:	bf08      	it	eq
 800c152:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800c156:	bd70      	pop	{r4, r5, r6, pc}
 800c158:	f1c4 040c 	rsb	r4, r4, #12
 800c15c:	f1c4 0520 	rsb	r5, r4, #32
 800c160:	fa00 f304 	lsl.w	r3, r0, r4
 800c164:	fa20 f005 	lsr.w	r0, r0, r5
 800c168:	fa01 f204 	lsl.w	r2, r1, r4
 800c16c:	ea40 0002 	orr.w	r0, r0, r2
 800c170:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c174:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800c178:	f141 0100 	adc.w	r1, r1, #0
 800c17c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800c180:	bf08      	it	eq
 800c182:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800c186:	bd70      	pop	{r4, r5, r6, pc}
 800c188:	f1c4 0520 	rsb	r5, r4, #32
 800c18c:	fa00 f205 	lsl.w	r2, r0, r5
 800c190:	ea4e 0e02 	orr.w	lr, lr, r2
 800c194:	fa20 f304 	lsr.w	r3, r0, r4
 800c198:	fa01 f205 	lsl.w	r2, r1, r5
 800c19c:	ea43 0302 	orr.w	r3, r3, r2
 800c1a0:	fa21 f004 	lsr.w	r0, r1, r4
 800c1a4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c1a8:	fa21 f204 	lsr.w	r2, r1, r4
 800c1ac:	ea20 0002 	bic.w	r0, r0, r2
 800c1b0:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 800c1b4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800c1b8:	bf08      	it	eq
 800c1ba:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800c1be:	bd70      	pop	{r4, r5, r6, pc}
 800c1c0:	f094 0f00 	teq	r4, #0
 800c1c4:	d10f      	bne.n	800c1e6 <__aeabi_dmul+0x1c2>
 800c1c6:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800c1ca:	0040      	lsls	r0, r0, #1
 800c1cc:	eb41 0101 	adc.w	r1, r1, r1
 800c1d0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800c1d4:	bf08      	it	eq
 800c1d6:	3c01      	subeq	r4, #1
 800c1d8:	d0f7      	beq.n	800c1ca <__aeabi_dmul+0x1a6>
 800c1da:	ea41 0106 	orr.w	r1, r1, r6
 800c1de:	f095 0f00 	teq	r5, #0
 800c1e2:	bf18      	it	ne
 800c1e4:	4770      	bxne	lr
 800c1e6:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800c1ea:	0052      	lsls	r2, r2, #1
 800c1ec:	eb43 0303 	adc.w	r3, r3, r3
 800c1f0:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800c1f4:	bf08      	it	eq
 800c1f6:	3d01      	subeq	r5, #1
 800c1f8:	d0f7      	beq.n	800c1ea <__aeabi_dmul+0x1c6>
 800c1fa:	ea43 0306 	orr.w	r3, r3, r6
 800c1fe:	4770      	bx	lr
 800c200:	ea94 0f0c 	teq	r4, ip
 800c204:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800c208:	bf18      	it	ne
 800c20a:	ea95 0f0c 	teqne	r5, ip
 800c20e:	d00c      	beq.n	800c22a <__aeabi_dmul+0x206>
 800c210:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800c214:	bf18      	it	ne
 800c216:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800c21a:	d1d1      	bne.n	800c1c0 <__aeabi_dmul+0x19c>
 800c21c:	ea81 0103 	eor.w	r1, r1, r3
 800c220:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c224:	f04f 0000 	mov.w	r0, #0
 800c228:	bd70      	pop	{r4, r5, r6, pc}
 800c22a:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800c22e:	bf06      	itte	eq
 800c230:	4610      	moveq	r0, r2
 800c232:	4619      	moveq	r1, r3
 800c234:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800c238:	d019      	beq.n	800c26e <__aeabi_dmul+0x24a>
 800c23a:	ea94 0f0c 	teq	r4, ip
 800c23e:	d102      	bne.n	800c246 <__aeabi_dmul+0x222>
 800c240:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 800c244:	d113      	bne.n	800c26e <__aeabi_dmul+0x24a>
 800c246:	ea95 0f0c 	teq	r5, ip
 800c24a:	d105      	bne.n	800c258 <__aeabi_dmul+0x234>
 800c24c:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800c250:	bf1c      	itt	ne
 800c252:	4610      	movne	r0, r2
 800c254:	4619      	movne	r1, r3
 800c256:	d10a      	bne.n	800c26e <__aeabi_dmul+0x24a>
 800c258:	ea81 0103 	eor.w	r1, r1, r3
 800c25c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c260:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800c264:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800c268:	f04f 0000 	mov.w	r0, #0
 800c26c:	bd70      	pop	{r4, r5, r6, pc}
 800c26e:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800c272:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800c276:	bd70      	pop	{r4, r5, r6, pc}

0800c278 <__aeabi_ddiv>:
 800c278:	b570      	push	{r4, r5, r6, lr}
 800c27a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800c27e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800c282:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800c286:	bf1d      	ittte	ne
 800c288:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800c28c:	ea94 0f0c 	teqne	r4, ip
 800c290:	ea95 0f0c 	teqne	r5, ip
 800c294:	f000 f8a7 	bleq	800c3e6 <__aeabi_ddiv+0x16e>
 800c298:	eba4 0405 	sub.w	r4, r4, r5
 800c29c:	ea81 0e03 	eor.w	lr, r1, r3
 800c2a0:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800c2a4:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800c2a8:	f000 8088 	beq.w	800c3bc <__aeabi_ddiv+0x144>
 800c2ac:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800c2b0:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800c2b4:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800c2b8:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800c2bc:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800c2c0:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 800c2c4:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800c2c8:	ea4f 2600 	mov.w	r6, r0, lsl #8
 800c2cc:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800c2d0:	429d      	cmp	r5, r3
 800c2d2:	bf08      	it	eq
 800c2d4:	4296      	cmpeq	r6, r2
 800c2d6:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 800c2da:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800c2de:	d202      	bcs.n	800c2e6 <__aeabi_ddiv+0x6e>
 800c2e0:	085b      	lsrs	r3, r3, #1
 800c2e2:	ea4f 0232 	mov.w	r2, r2, rrx
 800c2e6:	1ab6      	subs	r6, r6, r2
 800c2e8:	eb65 0503 	sbc.w	r5, r5, r3
 800c2ec:	085b      	lsrs	r3, r3, #1
 800c2ee:	ea4f 0232 	mov.w	r2, r2, rrx
 800c2f2:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800c2f6:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800c2fa:	ebb6 0e02 	subs.w	lr, r6, r2
 800c2fe:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c302:	bf22      	ittt	cs
 800c304:	1ab6      	subcs	r6, r6, r2
 800c306:	4675      	movcs	r5, lr
 800c308:	ea40 000c 	orrcs.w	r0, r0, ip
 800c30c:	085b      	lsrs	r3, r3, #1
 800c30e:	ea4f 0232 	mov.w	r2, r2, rrx
 800c312:	ebb6 0e02 	subs.w	lr, r6, r2
 800c316:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c31a:	bf22      	ittt	cs
 800c31c:	1ab6      	subcs	r6, r6, r2
 800c31e:	4675      	movcs	r5, lr
 800c320:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 800c324:	085b      	lsrs	r3, r3, #1
 800c326:	ea4f 0232 	mov.w	r2, r2, rrx
 800c32a:	ebb6 0e02 	subs.w	lr, r6, r2
 800c32e:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c332:	bf22      	ittt	cs
 800c334:	1ab6      	subcs	r6, r6, r2
 800c336:	4675      	movcs	r5, lr
 800c338:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 800c33c:	085b      	lsrs	r3, r3, #1
 800c33e:	ea4f 0232 	mov.w	r2, r2, rrx
 800c342:	ebb6 0e02 	subs.w	lr, r6, r2
 800c346:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c34a:	bf22      	ittt	cs
 800c34c:	1ab6      	subcs	r6, r6, r2
 800c34e:	4675      	movcs	r5, lr
 800c350:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 800c354:	ea55 0e06 	orrs.w	lr, r5, r6
 800c358:	d018      	beq.n	800c38c <__aeabi_ddiv+0x114>
 800c35a:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800c35e:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800c362:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800c366:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800c36a:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800c36e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800c372:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800c376:	d1c0      	bne.n	800c2fa <__aeabi_ddiv+0x82>
 800c378:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800c37c:	d10b      	bne.n	800c396 <__aeabi_ddiv+0x11e>
 800c37e:	ea41 0100 	orr.w	r1, r1, r0
 800c382:	f04f 0000 	mov.w	r0, #0
 800c386:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800c38a:	e7b6      	b.n	800c2fa <__aeabi_ddiv+0x82>
 800c38c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800c390:	bf04      	itt	eq
 800c392:	4301      	orreq	r1, r0
 800c394:	2000      	moveq	r0, #0
 800c396:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800c39a:	bf88      	it	hi
 800c39c:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800c3a0:	f63f aeaf 	bhi.w	800c102 <__aeabi_dmul+0xde>
 800c3a4:	ebb5 0c03 	subs.w	ip, r5, r3
 800c3a8:	bf04      	itt	eq
 800c3aa:	ebb6 0c02 	subseq.w	ip, r6, r2
 800c3ae:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800c3b2:	f150 0000 	adcs.w	r0, r0, #0
 800c3b6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800c3ba:	bd70      	pop	{r4, r5, r6, pc}
 800c3bc:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800c3c0:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 800c3c4:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 800c3c8:	bfc2      	ittt	gt
 800c3ca:	ebd4 050c 	rsbsgt	r5, r4, ip
 800c3ce:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800c3d2:	bd70      	popgt	{r4, r5, r6, pc}
 800c3d4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800c3d8:	f04f 0e00 	mov.w	lr, #0
 800c3dc:	3c01      	subs	r4, #1
 800c3de:	e690      	b.n	800c102 <__aeabi_dmul+0xde>
 800c3e0:	ea45 0e06 	orr.w	lr, r5, r6
 800c3e4:	e68d      	b.n	800c102 <__aeabi_dmul+0xde>
 800c3e6:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800c3ea:	ea94 0f0c 	teq	r4, ip
 800c3ee:	bf08      	it	eq
 800c3f0:	ea95 0f0c 	teqeq	r5, ip
 800c3f4:	f43f af3b 	beq.w	800c26e <__aeabi_dmul+0x24a>
 800c3f8:	ea94 0f0c 	teq	r4, ip
 800c3fc:	d10a      	bne.n	800c414 <__aeabi_ddiv+0x19c>
 800c3fe:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800c402:	f47f af34 	bne.w	800c26e <__aeabi_dmul+0x24a>
 800c406:	ea95 0f0c 	teq	r5, ip
 800c40a:	f47f af25 	bne.w	800c258 <__aeabi_dmul+0x234>
 800c40e:	4610      	mov	r0, r2
 800c410:	4619      	mov	r1, r3
 800c412:	e72c      	b.n	800c26e <__aeabi_dmul+0x24a>
 800c414:	ea95 0f0c 	teq	r5, ip
 800c418:	d106      	bne.n	800c428 <__aeabi_ddiv+0x1b0>
 800c41a:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800c41e:	f43f aefd 	beq.w	800c21c <__aeabi_dmul+0x1f8>
 800c422:	4610      	mov	r0, r2
 800c424:	4619      	mov	r1, r3
 800c426:	e722      	b.n	800c26e <__aeabi_dmul+0x24a>
 800c428:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800c42c:	bf18      	it	ne
 800c42e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800c432:	f47f aec5 	bne.w	800c1c0 <__aeabi_dmul+0x19c>
 800c436:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 800c43a:	f47f af0d 	bne.w	800c258 <__aeabi_dmul+0x234>
 800c43e:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800c442:	f47f aeeb 	bne.w	800c21c <__aeabi_dmul+0x1f8>
 800c446:	e712      	b.n	800c26e <__aeabi_dmul+0x24a>

0800c448 <__gedf2>:
 800c448:	f04f 3cff 	mov.w	ip, #4294967295
 800c44c:	e006      	b.n	800c45c <__cmpdf2+0x4>
 800c44e:	bf00      	nop

0800c450 <__ledf2>:
 800c450:	f04f 0c01 	mov.w	ip, #1
 800c454:	e002      	b.n	800c45c <__cmpdf2+0x4>
 800c456:	bf00      	nop

0800c458 <__cmpdf2>:
 800c458:	f04f 0c01 	mov.w	ip, #1
 800c45c:	f84d cd04 	str.w	ip, [sp, #-4]!
 800c460:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800c464:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800c468:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800c46c:	bf18      	it	ne
 800c46e:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 800c472:	d01b      	beq.n	800c4ac <__cmpdf2+0x54>
 800c474:	b001      	add	sp, #4
 800c476:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 800c47a:	bf0c      	ite	eq
 800c47c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 800c480:	ea91 0f03 	teqne	r1, r3
 800c484:	bf02      	ittt	eq
 800c486:	ea90 0f02 	teqeq	r0, r2
 800c48a:	2000      	moveq	r0, #0
 800c48c:	4770      	bxeq	lr
 800c48e:	f110 0f00 	cmn.w	r0, #0
 800c492:	ea91 0f03 	teq	r1, r3
 800c496:	bf58      	it	pl
 800c498:	4299      	cmppl	r1, r3
 800c49a:	bf08      	it	eq
 800c49c:	4290      	cmpeq	r0, r2
 800c49e:	bf2c      	ite	cs
 800c4a0:	17d8      	asrcs	r0, r3, #31
 800c4a2:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 800c4a6:	f040 0001 	orr.w	r0, r0, #1
 800c4aa:	4770      	bx	lr
 800c4ac:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800c4b0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800c4b4:	d102      	bne.n	800c4bc <__cmpdf2+0x64>
 800c4b6:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800c4ba:	d107      	bne.n	800c4cc <__cmpdf2+0x74>
 800c4bc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800c4c0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800c4c4:	d1d6      	bne.n	800c474 <__cmpdf2+0x1c>
 800c4c6:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800c4ca:	d0d3      	beq.n	800c474 <__cmpdf2+0x1c>
 800c4cc:	f85d 0b04 	ldr.w	r0, [sp], #4
 800c4d0:	4770      	bx	lr
 800c4d2:	bf00      	nop

0800c4d4 <__aeabi_cdrcmple>:
 800c4d4:	4684      	mov	ip, r0
 800c4d6:	4610      	mov	r0, r2
 800c4d8:	4662      	mov	r2, ip
 800c4da:	468c      	mov	ip, r1
 800c4dc:	4619      	mov	r1, r3
 800c4de:	4663      	mov	r3, ip
 800c4e0:	e000      	b.n	800c4e4 <__aeabi_cdcmpeq>
 800c4e2:	bf00      	nop

0800c4e4 <__aeabi_cdcmpeq>:
 800c4e4:	b501      	push	{r0, lr}
 800c4e6:	f7ff ffb7 	bl	800c458 <__cmpdf2>
 800c4ea:	2800      	cmp	r0, #0
 800c4ec:	bf48      	it	mi
 800c4ee:	f110 0f00 	cmnmi.w	r0, #0
 800c4f2:	bd01      	pop	{r0, pc}

0800c4f4 <__aeabi_dcmpeq>:
 800c4f4:	f84d ed08 	str.w	lr, [sp, #-8]!
 800c4f8:	f7ff fff4 	bl	800c4e4 <__aeabi_cdcmpeq>
 800c4fc:	bf0c      	ite	eq
 800c4fe:	2001      	moveq	r0, #1
 800c500:	2000      	movne	r0, #0
 800c502:	f85d fb08 	ldr.w	pc, [sp], #8
 800c506:	bf00      	nop

0800c508 <__aeabi_dcmplt>:
 800c508:	f84d ed08 	str.w	lr, [sp, #-8]!
 800c50c:	f7ff ffea 	bl	800c4e4 <__aeabi_cdcmpeq>
 800c510:	bf34      	ite	cc
 800c512:	2001      	movcc	r0, #1
 800c514:	2000      	movcs	r0, #0
 800c516:	f85d fb08 	ldr.w	pc, [sp], #8
 800c51a:	bf00      	nop

0800c51c <__aeabi_dcmple>:
 800c51c:	f84d ed08 	str.w	lr, [sp, #-8]!
 800c520:	f7ff ffe0 	bl	800c4e4 <__aeabi_cdcmpeq>
 800c524:	bf94      	ite	ls
 800c526:	2001      	movls	r0, #1
 800c528:	2000      	movhi	r0, #0
 800c52a:	f85d fb08 	ldr.w	pc, [sp], #8
 800c52e:	bf00      	nop

0800c530 <__aeabi_dcmpge>:
 800c530:	f84d ed08 	str.w	lr, [sp, #-8]!
 800c534:	f7ff ffce 	bl	800c4d4 <__aeabi_cdrcmple>
 800c538:	bf94      	ite	ls
 800c53a:	2001      	movls	r0, #1
 800c53c:	2000      	movhi	r0, #0
 800c53e:	f85d fb08 	ldr.w	pc, [sp], #8
 800c542:	bf00      	nop

0800c544 <__aeabi_dcmpgt>:
 800c544:	f84d ed08 	str.w	lr, [sp, #-8]!
 800c548:	f7ff ffc4 	bl	800c4d4 <__aeabi_cdrcmple>
 800c54c:	bf34      	ite	cc
 800c54e:	2001      	movcc	r0, #1
 800c550:	2000      	movcs	r0, #0
 800c552:	f85d fb08 	ldr.w	pc, [sp], #8
 800c556:	bf00      	nop

0800c558 <__aeabi_d2iz>:
 800c558:	ea4f 0241 	mov.w	r2, r1, lsl #1
 800c55c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 800c560:	d215      	bcs.n	800c58e <__aeabi_d2iz+0x36>
 800c562:	d511      	bpl.n	800c588 <__aeabi_d2iz+0x30>
 800c564:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 800c568:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 800c56c:	d912      	bls.n	800c594 <__aeabi_d2iz+0x3c>
 800c56e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800c572:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800c576:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 800c57a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800c57e:	fa23 f002 	lsr.w	r0, r3, r2
 800c582:	bf18      	it	ne
 800c584:	4240      	negne	r0, r0
 800c586:	4770      	bx	lr
 800c588:	f04f 0000 	mov.w	r0, #0
 800c58c:	4770      	bx	lr
 800c58e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 800c592:	d105      	bne.n	800c5a0 <__aeabi_d2iz+0x48>
 800c594:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 800c598:	bf08      	it	eq
 800c59a:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 800c59e:	4770      	bx	lr
 800c5a0:	f04f 0000 	mov.w	r0, #0
 800c5a4:	4770      	bx	lr
 800c5a6:	bf00      	nop

0800c5a8 <__aeabi_uldivmod>:
 800c5a8:	b94b      	cbnz	r3, 800c5be <__aeabi_uldivmod+0x16>
 800c5aa:	b942      	cbnz	r2, 800c5be <__aeabi_uldivmod+0x16>
 800c5ac:	2900      	cmp	r1, #0
 800c5ae:	bf08      	it	eq
 800c5b0:	2800      	cmpeq	r0, #0
 800c5b2:	d002      	beq.n	800c5ba <__aeabi_uldivmod+0x12>
 800c5b4:	f04f 31ff 	mov.w	r1, #4294967295
 800c5b8:	4608      	mov	r0, r1
 800c5ba:	f7ff bd31 	b.w	800c020 <__aeabi_idiv0>
 800c5be:	b082      	sub	sp, #8
 800c5c0:	46ec      	mov	ip, sp
 800c5c2:	e92d 5000 	stmdb	sp!, {ip, lr}
 800c5c6:	f000 f81d 	bl	800c604 <__gnu_uldivmod_helper>
 800c5ca:	f8dd e004 	ldr.w	lr, [sp, #4]
 800c5ce:	b002      	add	sp, #8
 800c5d0:	bc0c      	pop	{r2, r3}
 800c5d2:	4770      	bx	lr

0800c5d4 <__gnu_ldivmod_helper>:
 800c5d4:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 800c5d8:	4616      	mov	r6, r2
 800c5da:	4680      	mov	r8, r0
 800c5dc:	4689      	mov	r9, r1
 800c5de:	461d      	mov	r5, r3
 800c5e0:	f000 f828 	bl	800c634 <__divdi3>
 800c5e4:	fb00 f305 	mul.w	r3, r0, r5
 800c5e8:	fba0 4506 	umull	r4, r5, r0, r6
 800c5ec:	fb06 3601 	mla	r6, r6, r1, r3
 800c5f0:	9b06      	ldr	r3, [sp, #24]
 800c5f2:	1975      	adds	r5, r6, r5
 800c5f4:	ebb8 0404 	subs.w	r4, r8, r4
 800c5f8:	eb69 0505 	sbc.w	r5, r9, r5
 800c5fc:	e9c3 4500 	strd	r4, r5, [r3]
 800c600:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

0800c604 <__gnu_uldivmod_helper>:
 800c604:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 800c608:	4616      	mov	r6, r2
 800c60a:	4680      	mov	r8, r0
 800c60c:	4689      	mov	r9, r1
 800c60e:	461d      	mov	r5, r3
 800c610:	f000 f9c0 	bl	800c994 <__udivdi3>
 800c614:	fb00 f305 	mul.w	r3, r0, r5
 800c618:	fba0 4506 	umull	r4, r5, r0, r6
 800c61c:	fb06 3601 	mla	r6, r6, r1, r3
 800c620:	9b06      	ldr	r3, [sp, #24]
 800c622:	1975      	adds	r5, r6, r5
 800c624:	ebb8 0404 	subs.w	r4, r8, r4
 800c628:	eb69 0505 	sbc.w	r5, r9, r5
 800c62c:	e9c3 4500 	strd	r4, r5, [r3]
 800c630:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

0800c634 <__divdi3>:
 800c634:	2900      	cmp	r1, #0
 800c636:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c63a:	461c      	mov	r4, r3
 800c63c:	b085      	sub	sp, #20
 800c63e:	f2c0 80cb 	blt.w	800c7d8 <__divdi3+0x1a4>
 800c642:	2600      	movs	r6, #0
 800c644:	2c00      	cmp	r4, #0
 800c646:	f2c0 80c2 	blt.w	800c7ce <__divdi3+0x19a>
 800c64a:	468c      	mov	ip, r1
 800c64c:	4617      	mov	r7, r2
 800c64e:	4614      	mov	r4, r2
 800c650:	4605      	mov	r5, r0
 800c652:	4688      	mov	r8, r1
 800c654:	469a      	mov	sl, r3
 800c656:	2b00      	cmp	r3, #0
 800c658:	d14a      	bne.n	800c6f0 <__divdi3+0xbc>
 800c65a:	428a      	cmp	r2, r1
 800c65c:	d96e      	bls.n	800c73c <__divdi3+0x108>
 800c65e:	fab2 f382 	clz	r3, r2
 800c662:	b15b      	cbz	r3, 800c67c <__divdi3+0x48>
 800c664:	f1c3 0420 	rsb	r4, r3, #32
 800c668:	fa01 f803 	lsl.w	r8, r1, r3
 800c66c:	fa30 f204 	lsrs.w	r2, r0, r4
 800c670:	fa10 f503 	lsls.w	r5, r0, r3
 800c674:	fa17 f403 	lsls.w	r4, r7, r3
 800c678:	ea42 0808 	orr.w	r8, r2, r8
 800c67c:	ea4f 4a14 	mov.w	sl, r4, lsr #16
 800c680:	4640      	mov	r0, r8
 800c682:	4651      	mov	r1, sl
 800c684:	fa1f fb84 	uxth.w	fp, r4
 800c688:	f7ff fb8e 	bl	800bda8 <__aeabi_uidiv>
 800c68c:	4651      	mov	r1, sl
 800c68e:	4681      	mov	r9, r0
 800c690:	4640      	mov	r0, r8
 800c692:	f7ff fcb7 	bl	800c004 <__aeabi_uidivmod>
 800c696:	0c28      	lsrs	r0, r5, #16
 800c698:	fb0b f309 	mul.w	r3, fp, r9
 800c69c:	ea40 4801 	orr.w	r8, r0, r1, lsl #16
 800c6a0:	4543      	cmp	r3, r8
 800c6a2:	d909      	bls.n	800c6b8 <__divdi3+0x84>
 800c6a4:	eb18 0804 	adds.w	r8, r8, r4
 800c6a8:	f109 39ff 	add.w	r9, r9, #4294967295
 800c6ac:	d204      	bcs.n	800c6b8 <__divdi3+0x84>
 800c6ae:	4543      	cmp	r3, r8
 800c6b0:	bf84      	itt	hi
 800c6b2:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800c6b6:	44a0      	addhi	r8, r4
 800c6b8:	ebc3 0808 	rsb	r8, r3, r8
 800c6bc:	4651      	mov	r1, sl
 800c6be:	4640      	mov	r0, r8
 800c6c0:	b2ad      	uxth	r5, r5
 800c6c2:	f7ff fb71 	bl	800bda8 <__aeabi_uidiv>
 800c6c6:	4651      	mov	r1, sl
 800c6c8:	4607      	mov	r7, r0
 800c6ca:	4640      	mov	r0, r8
 800c6cc:	f7ff fc9a 	bl	800c004 <__aeabi_uidivmod>
 800c6d0:	fb0b fb07 	mul.w	fp, fp, r7
 800c6d4:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
 800c6d8:	45ab      	cmp	fp, r5
 800c6da:	d905      	bls.n	800c6e8 <__divdi3+0xb4>
 800c6dc:	3f01      	subs	r7, #1
 800c6de:	192d      	adds	r5, r5, r4
 800c6e0:	d202      	bcs.n	800c6e8 <__divdi3+0xb4>
 800c6e2:	45ab      	cmp	fp, r5
 800c6e4:	bf88      	it	hi
 800c6e6:	3f01      	subhi	r7, #1
 800c6e8:	ea47 4909 	orr.w	r9, r7, r9, lsl #16
 800c6ec:	2400      	movs	r4, #0
 800c6ee:	e003      	b.n	800c6f8 <__divdi3+0xc4>
 800c6f0:	428b      	cmp	r3, r1
 800c6f2:	d90c      	bls.n	800c70e <__divdi3+0xda>
 800c6f4:	2400      	movs	r4, #0
 800c6f6:	46a1      	mov	r9, r4
 800c6f8:	464a      	mov	r2, r9
 800c6fa:	4623      	mov	r3, r4
 800c6fc:	b116      	cbz	r6, 800c704 <__divdi3+0xd0>
 800c6fe:	4252      	negs	r2, r2
 800c700:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800c704:	4610      	mov	r0, r2
 800c706:	4619      	mov	r1, r3
 800c708:	b005      	add	sp, #20
 800c70a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c70e:	fab3 f483 	clz	r4, r3
 800c712:	2c00      	cmp	r4, #0
 800c714:	f040 80b3 	bne.w	800c87e <__divdi3+0x24a>
 800c718:	428b      	cmp	r3, r1
 800c71a:	f04f 0901 	mov.w	r9, #1
 800c71e:	bf2c      	ite	cs
 800c720:	f04f 0c00 	movcs.w	ip, #0
 800c724:	f04f 0c01 	movcc.w	ip, #1
 800c728:	4282      	cmp	r2, r0
 800c72a:	bf8c      	ite	hi
 800c72c:	4667      	movhi	r7, ip
 800c72e:	f04c 0701 	orrls.w	r7, ip, #1
 800c732:	2f00      	cmp	r7, #0
 800c734:	d1e0      	bne.n	800c6f8 <__divdi3+0xc4>
 800c736:	463c      	mov	r4, r7
 800c738:	46b9      	mov	r9, r7
 800c73a:	e7dd      	b.n	800c6f8 <__divdi3+0xc4>
 800c73c:	b922      	cbnz	r2, 800c748 <__divdi3+0x114>
 800c73e:	2001      	movs	r0, #1
 800c740:	4611      	mov	r1, r2
 800c742:	f7ff fb31 	bl	800bda8 <__aeabi_uidiv>
 800c746:	4604      	mov	r4, r0
 800c748:	fab4 f384 	clz	r3, r4
 800c74c:	2b00      	cmp	r3, #0
 800c74e:	d149      	bne.n	800c7e4 <__divdi3+0x1b0>
 800c750:	ebc4 0808 	rsb	r8, r4, r8
 800c754:	0c27      	lsrs	r7, r4, #16
 800c756:	fa1f fa84 	uxth.w	sl, r4
 800c75a:	2101      	movs	r1, #1
 800c75c:	9102      	str	r1, [sp, #8]
 800c75e:	4639      	mov	r1, r7
 800c760:	4640      	mov	r0, r8
 800c762:	f7ff fb21 	bl	800bda8 <__aeabi_uidiv>
 800c766:	4639      	mov	r1, r7
 800c768:	4681      	mov	r9, r0
 800c76a:	4640      	mov	r0, r8
 800c76c:	f7ff fc4a 	bl	800c004 <__aeabi_uidivmod>
 800c770:	0c2a      	lsrs	r2, r5, #16
 800c772:	fb0a f309 	mul.w	r3, sl, r9
 800c776:	ea42 4b01 	orr.w	fp, r2, r1, lsl #16
 800c77a:	455b      	cmp	r3, fp
 800c77c:	d909      	bls.n	800c792 <__divdi3+0x15e>
 800c77e:	eb1b 0b04 	adds.w	fp, fp, r4
 800c782:	f109 39ff 	add.w	r9, r9, #4294967295
 800c786:	d204      	bcs.n	800c792 <__divdi3+0x15e>
 800c788:	455b      	cmp	r3, fp
 800c78a:	bf84      	itt	hi
 800c78c:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800c790:	44a3      	addhi	fp, r4
 800c792:	ebc3 0b0b 	rsb	fp, r3, fp
 800c796:	4639      	mov	r1, r7
 800c798:	4658      	mov	r0, fp
 800c79a:	b2ad      	uxth	r5, r5
 800c79c:	f7ff fb04 	bl	800bda8 <__aeabi_uidiv>
 800c7a0:	4639      	mov	r1, r7
 800c7a2:	4680      	mov	r8, r0
 800c7a4:	4658      	mov	r0, fp
 800c7a6:	f7ff fc2d 	bl	800c004 <__aeabi_uidivmod>
 800c7aa:	fb0a fa08 	mul.w	sl, sl, r8
 800c7ae:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
 800c7b2:	45aa      	cmp	sl, r5
 800c7b4:	d907      	bls.n	800c7c6 <__divdi3+0x192>
 800c7b6:	192d      	adds	r5, r5, r4
 800c7b8:	f108 38ff 	add.w	r8, r8, #4294967295
 800c7bc:	d203      	bcs.n	800c7c6 <__divdi3+0x192>
 800c7be:	45aa      	cmp	sl, r5
 800c7c0:	bf88      	it	hi
 800c7c2:	f108 38ff 	addhi.w	r8, r8, #4294967295
 800c7c6:	ea48 4909 	orr.w	r9, r8, r9, lsl #16
 800c7ca:	9c02      	ldr	r4, [sp, #8]
 800c7cc:	e794      	b.n	800c6f8 <__divdi3+0xc4>
 800c7ce:	43f6      	mvns	r6, r6
 800c7d0:	4252      	negs	r2, r2
 800c7d2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800c7d6:	e738      	b.n	800c64a <__divdi3+0x16>
 800c7d8:	4240      	negs	r0, r0
 800c7da:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800c7de:	f04f 36ff 	mov.w	r6, #4294967295
 800c7e2:	e72f      	b.n	800c644 <__divdi3+0x10>
 800c7e4:	409c      	lsls	r4, r3
 800c7e6:	f1c3 0720 	rsb	r7, r3, #32
 800c7ea:	fa28 fa07 	lsr.w	sl, r8, r7
 800c7ee:	fa35 f207 	lsrs.w	r2, r5, r7
 800c7f2:	0c27      	lsrs	r7, r4, #16
 800c7f4:	fa08 fb03 	lsl.w	fp, r8, r3
 800c7f8:	4639      	mov	r1, r7
 800c7fa:	4650      	mov	r0, sl
 800c7fc:	ea42 020b 	orr.w	r2, r2, fp
 800c800:	409d      	lsls	r5, r3
 800c802:	9202      	str	r2, [sp, #8]
 800c804:	f7ff fad0 	bl	800bda8 <__aeabi_uidiv>
 800c808:	4639      	mov	r1, r7
 800c80a:	4683      	mov	fp, r0
 800c80c:	4650      	mov	r0, sl
 800c80e:	f7ff fbf9 	bl	800c004 <__aeabi_uidivmod>
 800c812:	9b02      	ldr	r3, [sp, #8]
 800c814:	fa1f fa84 	uxth.w	sl, r4
 800c818:	ea4f 4913 	mov.w	r9, r3, lsr #16
 800c81c:	fb0a f30b 	mul.w	r3, sl, fp
 800c820:	ea49 4801 	orr.w	r8, r9, r1, lsl #16
 800c824:	4543      	cmp	r3, r8
 800c826:	d905      	bls.n	800c834 <__divdi3+0x200>
 800c828:	eb18 0804 	adds.w	r8, r8, r4
 800c82c:	f10b 3bff 	add.w	fp, fp, #4294967295
 800c830:	f0c0 80aa 	bcc.w	800c988 <__divdi3+0x354>
 800c834:	ebc3 0808 	rsb	r8, r3, r8
 800c838:	4639      	mov	r1, r7
 800c83a:	4640      	mov	r0, r8
 800c83c:	f7ff fab4 	bl	800bda8 <__aeabi_uidiv>
 800c840:	4639      	mov	r1, r7
 800c842:	4681      	mov	r9, r0
 800c844:	4640      	mov	r0, r8
 800c846:	f7ff fbdd 	bl	800c004 <__aeabi_uidivmod>
 800c84a:	9802      	ldr	r0, [sp, #8]
 800c84c:	fb0a f309 	mul.w	r3, sl, r9
 800c850:	fa1f fc80 	uxth.w	ip, r0
 800c854:	ea4c 4801 	orr.w	r8, ip, r1, lsl #16
 800c858:	4543      	cmp	r3, r8
 800c85a:	d909      	bls.n	800c870 <__divdi3+0x23c>
 800c85c:	eb18 0804 	adds.w	r8, r8, r4
 800c860:	f109 39ff 	add.w	r9, r9, #4294967295
 800c864:	d204      	bcs.n	800c870 <__divdi3+0x23c>
 800c866:	4543      	cmp	r3, r8
 800c868:	bf84      	itt	hi
 800c86a:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800c86e:	44a0      	addhi	r8, r4
 800c870:	ea49 4e0b 	orr.w	lr, r9, fp, lsl #16
 800c874:	ebc3 0808 	rsb	r8, r3, r8
 800c878:	f8cd e008 	str.w	lr, [sp, #8]
 800c87c:	e76f      	b.n	800c75e <__divdi3+0x12a>
 800c87e:	f1c4 0320 	rsb	r3, r4, #32
 800c882:	fa0a fa04 	lsl.w	sl, sl, r4
 800c886:	40da      	lsrs	r2, r3
 800c888:	fa21 f803 	lsr.w	r8, r1, r3
 800c88c:	ea42 0a0a 	orr.w	sl, r2, sl
 800c890:	fa01 f904 	lsl.w	r9, r1, r4
 800c894:	fa30 f203 	lsrs.w	r2, r0, r3
 800c898:	4640      	mov	r0, r8
 800c89a:	ea4f 4b1a 	mov.w	fp, sl, lsr #16
 800c89e:	ea42 0109 	orr.w	r1, r2, r9
 800c8a2:	9103      	str	r1, [sp, #12]
 800c8a4:	4659      	mov	r1, fp
 800c8a6:	fa17 f304 	lsls.w	r3, r7, r4
 800c8aa:	9302      	str	r3, [sp, #8]
 800c8ac:	f7ff fa7c 	bl	800bda8 <__aeabi_uidiv>
 800c8b0:	4659      	mov	r1, fp
 800c8b2:	4681      	mov	r9, r0
 800c8b4:	4640      	mov	r0, r8
 800c8b6:	f7ff fba5 	bl	800c004 <__aeabi_uidivmod>
 800c8ba:	fa1f f38a 	uxth.w	r3, sl
 800c8be:	9803      	ldr	r0, [sp, #12]
 800c8c0:	fb03 f209 	mul.w	r2, r3, r9
 800c8c4:	0c07      	lsrs	r7, r0, #16
 800c8c6:	ea47 4801 	orr.w	r8, r7, r1, lsl #16
 800c8ca:	4542      	cmp	r2, r8
 800c8cc:	d904      	bls.n	800c8d8 <__divdi3+0x2a4>
 800c8ce:	eb18 080a 	adds.w	r8, r8, sl
 800c8d2:	f109 39ff 	add.w	r9, r9, #4294967295
 800c8d6:	d351      	bcc.n	800c97c <__divdi3+0x348>
 800c8d8:	ebc2 0808 	rsb	r8, r2, r8
 800c8dc:	4659      	mov	r1, fp
 800c8de:	4640      	mov	r0, r8
 800c8e0:	9301      	str	r3, [sp, #4]
 800c8e2:	f7ff fa61 	bl	800bda8 <__aeabi_uidiv>
 800c8e6:	4659      	mov	r1, fp
 800c8e8:	4607      	mov	r7, r0
 800c8ea:	4640      	mov	r0, r8
 800c8ec:	f7ff fb8a 	bl	800c004 <__aeabi_uidivmod>
 800c8f0:	9b01      	ldr	r3, [sp, #4]
 800c8f2:	9803      	ldr	r0, [sp, #12]
 800c8f4:	fb03 f307 	mul.w	r3, r3, r7
 800c8f8:	fa1f fc80 	uxth.w	ip, r0
 800c8fc:	ea4c 4c01 	orr.w	ip, ip, r1, lsl #16
 800c900:	4563      	cmp	r3, ip
 800c902:	d907      	bls.n	800c914 <__divdi3+0x2e0>
 800c904:	3f01      	subs	r7, #1
 800c906:	eb1c 0c0a 	adds.w	ip, ip, sl
 800c90a:	d203      	bcs.n	800c914 <__divdi3+0x2e0>
 800c90c:	4563      	cmp	r3, ip
 800c90e:	d901      	bls.n	800c914 <__divdi3+0x2e0>
 800c910:	3f01      	subs	r7, #1
 800c912:	44d4      	add	ip, sl
 800c914:	ea47 4909 	orr.w	r9, r7, r9, lsl #16
 800c918:	9f02      	ldr	r7, [sp, #8]
 800c91a:	ebc3 0c0c 	rsb	ip, r3, ip
 800c91e:	fa1f fe89 	uxth.w	lr, r9
 800c922:	ea4f 4319 	mov.w	r3, r9, lsr #16
 800c926:	b2b8      	uxth	r0, r7
 800c928:	0c3f      	lsrs	r7, r7, #16
 800c92a:	fb00 f80e 	mul.w	r8, r0, lr
 800c92e:	fb00 f103 	mul.w	r1, r0, r3
 800c932:	fb07 120e 	mla	r2, r7, lr, r1
 800c936:	fb07 f003 	mul.w	r0, r7, r3
 800c93a:	eb02 4218 	add.w	r2, r2, r8, lsr #16
 800c93e:	4291      	cmp	r1, r2
 800c940:	bf88      	it	hi
 800c942:	f500 3080 	addhi.w	r0, r0, #65536	; 0x10000
 800c946:	eb00 4e12 	add.w	lr, r0, r2, lsr #16
 800c94a:	45f4      	cmp	ip, lr
 800c94c:	d312      	bcc.n	800c974 <__divdi3+0x340>
 800c94e:	ea4f 4202 	mov.w	r2, r2, lsl #16
 800c952:	fa1f f888 	uxth.w	r8, r8
 800c956:	bf14      	ite	ne
 800c958:	2100      	movne	r1, #0
 800c95a:	2101      	moveq	r1, #1
 800c95c:	eb02 0c08 	add.w	ip, r2, r8
 800c960:	fa15 f404 	lsls.w	r4, r5, r4
 800c964:	4564      	cmp	r4, ip
 800c966:	bf2c      	ite	cs
 800c968:	2400      	movcs	r4, #0
 800c96a:	f001 0401 	andcc.w	r4, r1, #1
 800c96e:	2c00      	cmp	r4, #0
 800c970:	f43f aec2 	beq.w	800c6f8 <__divdi3+0xc4>
 800c974:	f109 39ff 	add.w	r9, r9, #4294967295
 800c978:	2400      	movs	r4, #0
 800c97a:	e6bd      	b.n	800c6f8 <__divdi3+0xc4>
 800c97c:	4542      	cmp	r2, r8
 800c97e:	bf84      	itt	hi
 800c980:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800c984:	44d0      	addhi	r8, sl
 800c986:	e7a7      	b.n	800c8d8 <__divdi3+0x2a4>
 800c988:	4543      	cmp	r3, r8
 800c98a:	bf84      	itt	hi
 800c98c:	f10b 3bff 	addhi.w	fp, fp, #4294967295
 800c990:	44a0      	addhi	r8, r4
 800c992:	e74f      	b.n	800c834 <__divdi3+0x200>

0800c994 <__udivdi3>:
 800c994:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c998:	4605      	mov	r5, r0
 800c99a:	b083      	sub	sp, #12
 800c99c:	460c      	mov	r4, r1
 800c99e:	4617      	mov	r7, r2
 800c9a0:	4680      	mov	r8, r0
 800c9a2:	460e      	mov	r6, r1
 800c9a4:	2b00      	cmp	r3, #0
 800c9a6:	d14d      	bne.n	800ca44 <__udivdi3+0xb0>
 800c9a8:	428a      	cmp	r2, r1
 800c9aa:	d961      	bls.n	800ca70 <__udivdi3+0xdc>
 800c9ac:	fab2 f382 	clz	r3, r2
 800c9b0:	b153      	cbz	r3, 800c9c8 <__udivdi3+0x34>
 800c9b2:	f1c3 0420 	rsb	r4, r3, #32
 800c9b6:	fa11 f603 	lsls.w	r6, r1, r3
 800c9ba:	fa30 f204 	lsrs.w	r2, r0, r4
 800c9be:	409f      	lsls	r7, r3
 800c9c0:	ea42 0606 	orr.w	r6, r2, r6
 800c9c4:	fa00 f803 	lsl.w	r8, r0, r3
 800c9c8:	0c3c      	lsrs	r4, r7, #16
 800c9ca:	4630      	mov	r0, r6
 800c9cc:	4621      	mov	r1, r4
 800c9ce:	fa1f fa87 	uxth.w	sl, r7
 800c9d2:	f7ff f9e9 	bl	800bda8 <__aeabi_uidiv>
 800c9d6:	4621      	mov	r1, r4
 800c9d8:	4681      	mov	r9, r0
 800c9da:	4630      	mov	r0, r6
 800c9dc:	f7ff fb12 	bl	800c004 <__aeabi_uidivmod>
 800c9e0:	ea4f 4018 	mov.w	r0, r8, lsr #16
 800c9e4:	fb0a f309 	mul.w	r3, sl, r9
 800c9e8:	ea40 4601 	orr.w	r6, r0, r1, lsl #16
 800c9ec:	42b3      	cmp	r3, r6
 800c9ee:	d908      	bls.n	800ca02 <__udivdi3+0x6e>
 800c9f0:	19f6      	adds	r6, r6, r7
 800c9f2:	f109 39ff 	add.w	r9, r9, #4294967295
 800c9f6:	d204      	bcs.n	800ca02 <__udivdi3+0x6e>
 800c9f8:	42b3      	cmp	r3, r6
 800c9fa:	bf84      	itt	hi
 800c9fc:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800ca00:	19f6      	addhi	r6, r6, r7
 800ca02:	1af6      	subs	r6, r6, r3
 800ca04:	4621      	mov	r1, r4
 800ca06:	4630      	mov	r0, r6
 800ca08:	fa1f f888 	uxth.w	r8, r8
 800ca0c:	f7ff f9cc 	bl	800bda8 <__aeabi_uidiv>
 800ca10:	4621      	mov	r1, r4
 800ca12:	4605      	mov	r5, r0
 800ca14:	4630      	mov	r0, r6
 800ca16:	f7ff faf5 	bl	800c004 <__aeabi_uidivmod>
 800ca1a:	fb0a fa05 	mul.w	sl, sl, r5
 800ca1e:	ea48 4801 	orr.w	r8, r8, r1, lsl #16
 800ca22:	45c2      	cmp	sl, r8
 800ca24:	d906      	bls.n	800ca34 <__udivdi3+0xa0>
 800ca26:	3d01      	subs	r5, #1
 800ca28:	eb18 0807 	adds.w	r8, r8, r7
 800ca2c:	d202      	bcs.n	800ca34 <__udivdi3+0xa0>
 800ca2e:	45c2      	cmp	sl, r8
 800ca30:	bf88      	it	hi
 800ca32:	3d01      	subhi	r5, #1
 800ca34:	ea45 4a09 	orr.w	sl, r5, r9, lsl #16
 800ca38:	2600      	movs	r6, #0
 800ca3a:	4631      	mov	r1, r6
 800ca3c:	4650      	mov	r0, sl
 800ca3e:	b003      	add	sp, #12
 800ca40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ca44:	428b      	cmp	r3, r1
 800ca46:	d85b      	bhi.n	800cb00 <__udivdi3+0x16c>
 800ca48:	fab3 f683 	clz	r6, r3
 800ca4c:	2e00      	cmp	r6, #0
 800ca4e:	d15a      	bne.n	800cb06 <__udivdi3+0x172>
 800ca50:	428b      	cmp	r3, r1
 800ca52:	f04f 0a01 	mov.w	sl, #1
 800ca56:	bf2c      	ite	cs
 800ca58:	2400      	movcs	r4, #0
 800ca5a:	2401      	movcc	r4, #1
 800ca5c:	4282      	cmp	r2, r0
 800ca5e:	bf8c      	ite	hi
 800ca60:	4625      	movhi	r5, r4
 800ca62:	f044 0501 	orrls.w	r5, r4, #1
 800ca66:	2d00      	cmp	r5, #0
 800ca68:	d1e7      	bne.n	800ca3a <__udivdi3+0xa6>
 800ca6a:	462e      	mov	r6, r5
 800ca6c:	46aa      	mov	sl, r5
 800ca6e:	e7e4      	b.n	800ca3a <__udivdi3+0xa6>
 800ca70:	b922      	cbnz	r2, 800ca7c <__udivdi3+0xe8>
 800ca72:	2001      	movs	r0, #1
 800ca74:	4611      	mov	r1, r2
 800ca76:	f7ff f997 	bl	800bda8 <__aeabi_uidiv>
 800ca7a:	4607      	mov	r7, r0
 800ca7c:	fab7 f387 	clz	r3, r7
 800ca80:	2b00      	cmp	r3, #0
 800ca82:	f040 80b6 	bne.w	800cbf2 <__udivdi3+0x25e>
 800ca86:	1be4      	subs	r4, r4, r7
 800ca88:	ea4f 4b17 	mov.w	fp, r7, lsr #16
 800ca8c:	b2bd      	uxth	r5, r7
 800ca8e:	2601      	movs	r6, #1
 800ca90:	4659      	mov	r1, fp
 800ca92:	4620      	mov	r0, r4
 800ca94:	f7ff f988 	bl	800bda8 <__aeabi_uidiv>
 800ca98:	4659      	mov	r1, fp
 800ca9a:	ea4f 4918 	mov.w	r9, r8, lsr #16
 800ca9e:	4682      	mov	sl, r0
 800caa0:	4620      	mov	r0, r4
 800caa2:	f7ff faaf 	bl	800c004 <__aeabi_uidivmod>
 800caa6:	fb05 f30a 	mul.w	r3, r5, sl
 800caaa:	ea49 4401 	orr.w	r4, r9, r1, lsl #16
 800caae:	42a3      	cmp	r3, r4
 800cab0:	d908      	bls.n	800cac4 <__udivdi3+0x130>
 800cab2:	19e4      	adds	r4, r4, r7
 800cab4:	f10a 3aff 	add.w	sl, sl, #4294967295
 800cab8:	d204      	bcs.n	800cac4 <__udivdi3+0x130>
 800caba:	42a3      	cmp	r3, r4
 800cabc:	bf84      	itt	hi
 800cabe:	f10a 3aff 	addhi.w	sl, sl, #4294967295
 800cac2:	19e4      	addhi	r4, r4, r7
 800cac4:	1ae4      	subs	r4, r4, r3
 800cac6:	4659      	mov	r1, fp
 800cac8:	4620      	mov	r0, r4
 800caca:	f7ff f96d 	bl	800bda8 <__aeabi_uidiv>
 800cace:	4659      	mov	r1, fp
 800cad0:	4681      	mov	r9, r0
 800cad2:	4620      	mov	r0, r4
 800cad4:	f7ff fa96 	bl	800c004 <__aeabi_uidivmod>
 800cad8:	fa1f f388 	uxth.w	r3, r8
 800cadc:	fb05 f509 	mul.w	r5, r5, r9
 800cae0:	ea43 4801 	orr.w	r8, r3, r1, lsl #16
 800cae4:	4545      	cmp	r5, r8
 800cae6:	d908      	bls.n	800cafa <__udivdi3+0x166>
 800cae8:	eb18 0807 	adds.w	r8, r8, r7
 800caec:	f109 39ff 	add.w	r9, r9, #4294967295
 800caf0:	d203      	bcs.n	800cafa <__udivdi3+0x166>
 800caf2:	4545      	cmp	r5, r8
 800caf4:	bf88      	it	hi
 800caf6:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800cafa:	ea49 4a0a 	orr.w	sl, r9, sl, lsl #16
 800cafe:	e79c      	b.n	800ca3a <__udivdi3+0xa6>
 800cb00:	2600      	movs	r6, #0
 800cb02:	46b2      	mov	sl, r6
 800cb04:	e799      	b.n	800ca3a <__udivdi3+0xa6>
 800cb06:	f1c6 0120 	rsb	r1, r6, #32
 800cb0a:	40b3      	lsls	r3, r6
 800cb0c:	fa32 f701 	lsrs.w	r7, r2, r1
 800cb10:	fa24 f901 	lsr.w	r9, r4, r1
 800cb14:	431f      	orrs	r7, r3
 800cb16:	40b4      	lsls	r4, r6
 800cb18:	fa30 f301 	lsrs.w	r3, r0, r1
 800cb1c:	4648      	mov	r0, r9
 800cb1e:	ea4f 4817 	mov.w	r8, r7, lsr #16
 800cb22:	ea43 0104 	orr.w	r1, r3, r4
 800cb26:	9101      	str	r1, [sp, #4]
 800cb28:	4641      	mov	r1, r8
 800cb2a:	40b2      	lsls	r2, r6
 800cb2c:	9200      	str	r2, [sp, #0]
 800cb2e:	f7ff f93b 	bl	800bda8 <__aeabi_uidiv>
 800cb32:	4641      	mov	r1, r8
 800cb34:	b2bc      	uxth	r4, r7
 800cb36:	4682      	mov	sl, r0
 800cb38:	4648      	mov	r0, r9
 800cb3a:	f7ff fa63 	bl	800c004 <__aeabi_uidivmod>
 800cb3e:	9801      	ldr	r0, [sp, #4]
 800cb40:	fb04 f30a 	mul.w	r3, r4, sl
 800cb44:	ea4f 4b10 	mov.w	fp, r0, lsr #16
 800cb48:	ea4b 4b01 	orr.w	fp, fp, r1, lsl #16
 800cb4c:	455b      	cmp	r3, fp
 800cb4e:	d905      	bls.n	800cb5c <__udivdi3+0x1c8>
 800cb50:	eb1b 0b07 	adds.w	fp, fp, r7
 800cb54:	f10a 3aff 	add.w	sl, sl, #4294967295
 800cb58:	f0c0 8093 	bcc.w	800cc82 <__udivdi3+0x2ee>
 800cb5c:	ebc3 0b0b 	rsb	fp, r3, fp
 800cb60:	4641      	mov	r1, r8
 800cb62:	4658      	mov	r0, fp
 800cb64:	f7ff f920 	bl	800bda8 <__aeabi_uidiv>
 800cb68:	4641      	mov	r1, r8
 800cb6a:	4681      	mov	r9, r0
 800cb6c:	4658      	mov	r0, fp
 800cb6e:	f7ff fa49 	bl	800c004 <__aeabi_uidivmod>
 800cb72:	9801      	ldr	r0, [sp, #4]
 800cb74:	fb04 f409 	mul.w	r4, r4, r9
 800cb78:	fa1f fc80 	uxth.w	ip, r0
 800cb7c:	ea4c 4301 	orr.w	r3, ip, r1, lsl #16
 800cb80:	429c      	cmp	r4, r3
 800cb82:	d903      	bls.n	800cb8c <__udivdi3+0x1f8>
 800cb84:	19db      	adds	r3, r3, r7
 800cb86:	f109 39ff 	add.w	r9, r9, #4294967295
 800cb8a:	d374      	bcc.n	800cc76 <__udivdi3+0x2e2>
 800cb8c:	9f00      	ldr	r7, [sp, #0]
 800cb8e:	ea49 4a0a 	orr.w	sl, r9, sl, lsl #16
 800cb92:	1b1c      	subs	r4, r3, r4
 800cb94:	fa1f fe8a 	uxth.w	lr, sl
 800cb98:	b2b8      	uxth	r0, r7
 800cb9a:	0c3a      	lsrs	r2, r7, #16
 800cb9c:	ea4f 471a 	mov.w	r7, sl, lsr #16
 800cba0:	fb00 fc0e 	mul.w	ip, r0, lr
 800cba4:	fb00 f307 	mul.w	r3, r0, r7
 800cba8:	fb02 310e 	mla	r1, r2, lr, r3
 800cbac:	fb02 f207 	mul.w	r2, r2, r7
 800cbb0:	eb01 411c 	add.w	r1, r1, ip, lsr #16
 800cbb4:	428b      	cmp	r3, r1
 800cbb6:	bf88      	it	hi
 800cbb8:	f502 3280 	addhi.w	r2, r2, #65536	; 0x10000
 800cbbc:	eb02 4e11 	add.w	lr, r2, r1, lsr #16
 800cbc0:	4574      	cmp	r4, lr
 800cbc2:	d312      	bcc.n	800cbea <__udivdi3+0x256>
 800cbc4:	ea4f 4101 	mov.w	r1, r1, lsl #16
 800cbc8:	fa1f f28c 	uxth.w	r2, ip
 800cbcc:	bf14      	ite	ne
 800cbce:	2300      	movne	r3, #0
 800cbd0:	2301      	moveq	r3, #1
 800cbd2:	eb01 0c02 	add.w	ip, r1, r2
 800cbd6:	fa15 f606 	lsls.w	r6, r5, r6
 800cbda:	4566      	cmp	r6, ip
 800cbdc:	bf2c      	ite	cs
 800cbde:	2600      	movcs	r6, #0
 800cbe0:	f003 0601 	andcc.w	r6, r3, #1
 800cbe4:	2e00      	cmp	r6, #0
 800cbe6:	f43f af28 	beq.w	800ca3a <__udivdi3+0xa6>
 800cbea:	f10a 3aff 	add.w	sl, sl, #4294967295
 800cbee:	2600      	movs	r6, #0
 800cbf0:	e723      	b.n	800ca3a <__udivdi3+0xa6>
 800cbf2:	409f      	lsls	r7, r3
 800cbf4:	f1c3 0120 	rsb	r1, r3, #32
 800cbf8:	fa34 f601 	lsrs.w	r6, r4, r1
 800cbfc:	fa14 f203 	lsls.w	r2, r4, r3
 800cc00:	ea4f 4b17 	mov.w	fp, r7, lsr #16
 800cc04:	fa25 fa01 	lsr.w	sl, r5, r1
 800cc08:	4630      	mov	r0, r6
 800cc0a:	4659      	mov	r1, fp
 800cc0c:	fa05 f803 	lsl.w	r8, r5, r3
 800cc10:	ea4a 0a02 	orr.w	sl, sl, r2
 800cc14:	f7ff f8c8 	bl	800bda8 <__aeabi_uidiv>
 800cc18:	4659      	mov	r1, fp
 800cc1a:	b2bd      	uxth	r5, r7
 800cc1c:	4681      	mov	r9, r0
 800cc1e:	4630      	mov	r0, r6
 800cc20:	f7ff f9f0 	bl	800c004 <__aeabi_uidivmod>
 800cc24:	ea4f 4c1a 	mov.w	ip, sl, lsr #16
 800cc28:	fb05 f309 	mul.w	r3, r5, r9
 800cc2c:	ea4c 4401 	orr.w	r4, ip, r1, lsl #16
 800cc30:	42a3      	cmp	r3, r4
 800cc32:	d903      	bls.n	800cc3c <__udivdi3+0x2a8>
 800cc34:	19e4      	adds	r4, r4, r7
 800cc36:	f109 39ff 	add.w	r9, r9, #4294967295
 800cc3a:	d328      	bcc.n	800cc8e <__udivdi3+0x2fa>
 800cc3c:	1ae4      	subs	r4, r4, r3
 800cc3e:	4659      	mov	r1, fp
 800cc40:	4620      	mov	r0, r4
 800cc42:	f7ff f8b1 	bl	800bda8 <__aeabi_uidiv>
 800cc46:	4659      	mov	r1, fp
 800cc48:	4606      	mov	r6, r0
 800cc4a:	4620      	mov	r0, r4
 800cc4c:	f7ff f9da 	bl	800c004 <__aeabi_uidivmod>
 800cc50:	fa1f f48a 	uxth.w	r4, sl
 800cc54:	fb05 f306 	mul.w	r3, r5, r6
 800cc58:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 800cc5c:	42a3      	cmp	r3, r4
 800cc5e:	d906      	bls.n	800cc6e <__udivdi3+0x2da>
 800cc60:	3e01      	subs	r6, #1
 800cc62:	19e4      	adds	r4, r4, r7
 800cc64:	d203      	bcs.n	800cc6e <__udivdi3+0x2da>
 800cc66:	42a3      	cmp	r3, r4
 800cc68:	d901      	bls.n	800cc6e <__udivdi3+0x2da>
 800cc6a:	3e01      	subs	r6, #1
 800cc6c:	19e4      	adds	r4, r4, r7
 800cc6e:	1ae4      	subs	r4, r4, r3
 800cc70:	ea46 4609 	orr.w	r6, r6, r9, lsl #16
 800cc74:	e70c      	b.n	800ca90 <__udivdi3+0xfc>
 800cc76:	429c      	cmp	r4, r3
 800cc78:	bf84      	itt	hi
 800cc7a:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800cc7e:	19db      	addhi	r3, r3, r7
 800cc80:	e784      	b.n	800cb8c <__udivdi3+0x1f8>
 800cc82:	455b      	cmp	r3, fp
 800cc84:	bf84      	itt	hi
 800cc86:	f10a 3aff 	addhi.w	sl, sl, #4294967295
 800cc8a:	44bb      	addhi	fp, r7
 800cc8c:	e766      	b.n	800cb5c <__udivdi3+0x1c8>
 800cc8e:	42a3      	cmp	r3, r4
 800cc90:	bf84      	itt	hi
 800cc92:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800cc96:	19e4      	addhi	r4, r4, r7
 800cc98:	e7d0      	b.n	800cc3c <__udivdi3+0x2a8>
 800cc9a:	bf00      	nop

0800cc9c <Reset_Handler>:
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
 800cc9c:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800cc9e:	e003      	b.n	800cca8 <LoopCopyDataInit>

0800cca0 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800cca0:	4b0b      	ldr	r3, [pc, #44]	; (800ccd0 <LoopFillZerobss+0x14>)
  ldr  r3, [r3, r1]
 800cca2:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800cca4:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800cca6:	3104      	adds	r1, #4

0800cca8 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr  r0, =_sdata
 800cca8:	480a      	ldr	r0, [pc, #40]	; (800ccd4 <LoopFillZerobss+0x18>)
  ldr  r3, =_edata
 800ccaa:	4b0b      	ldr	r3, [pc, #44]	; (800ccd8 <LoopFillZerobss+0x1c>)
  adds  r2, r0, r1
 800ccac:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800ccae:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800ccb0:	d3f6      	bcc.n	800cca0 <CopyDataInit>
  ldr  r2, =_sbss
 800ccb2:	4a0a      	ldr	r2, [pc, #40]	; (800ccdc <LoopFillZerobss+0x20>)
  b  LoopFillZerobss
 800ccb4:	e002      	b.n	800ccbc <LoopFillZerobss>

0800ccb6 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs  r3, #0
 800ccb6:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800ccb8:	f842 3b04 	str.w	r3, [r2], #4

0800ccbc <LoopFillZerobss>:

LoopFillZerobss:
  ldr  r3, = _ebss
 800ccbc:	4b08      	ldr	r3, [pc, #32]	; (800cce0 <LoopFillZerobss+0x24>)
  cmp  r2, r3
 800ccbe:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800ccc0:	d3f9      	bcc.n	800ccb6 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 800ccc2:	f7f4 f889 	bl	8000dd8 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 800ccc6:	f7f9 fbdb 	bl	8006480 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800ccca:	f7f3 ff59 	bl	8000b80 <main>
  bx  lr
 800ccce:	4770      	bx	lr
 800ccd0:	0800d244 	.word	0x0800d244
 800ccd4:	20000000 	.word	0x20000000
 800ccd8:	200007f8 	.word	0x200007f8
 800ccdc:	200007f8 	.word	0x200007f8
 800cce0:	20002a90 	.word	0x20002a90

0800cce4 <Default_Handler2>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler2:
Infinite_Loop:
  b  Infinite_Loop
 800cce4:	e7fe      	b.n	800cce4 <Default_Handler2>
	...

0800cce8 <clocks>:
 800cce8:	0101 0405 0000 0000 1200 007a 0007 0000     ..........z.....
 800ccf8:	0054 0002                                   T...

0800ccfc <can_params>:
 800ccfc:	0000 03a0 a120 0007 0003 0400 0b04 0001     .... ...........
 800cd0c:	0001 0000 756f 7074 7475 6f54 7172 6575     ....outputTorque
 800cd1c:	203a 3225 6630 0000 6954 656d 203a 3225     : %20f..Time: %2
 800cd2c:	6430 0000                                   0d..

0800cd30 <canPC>:
 800cd30:	0000 3320 0008 0000 3210 7654 ba98 fedc     .. 3.....2Tv....
 800cd40:	0000 3340 0004 0000 ccdd aabb 0000 0000     ..@3............
 800cd50:	0000 3360 0000 0000 0000 0000 0000 0000     ..`3............
 800cd60:	333c 3333 0008 0000 2200 6644 aa88 eecc     <333....."Df....
 800cd70:	0002 3380 0000 0000 0000 0000 0000 0000     ...3............

0800cd80 <canCAN>:
 800cd80:	0000 5520 0008 0000 3210 7654 ba98 fedc     .. U.....2Tv....
 800cd90:	0000 5540 0004 0000 ccdd aabb 0000 0000     ..@U............
 800cda0:	0000 5560 0000 0000 0000 0000 0000 0000     ..`U............
 800cdb0:	555c 5555 0008 0000 2200 6644 aa88 eecc     \UUU....."Df....

0800cdc0 <CSWTCH.6>:
 800cdc0:	0102 0002                                   ....

0800cdc4 <h>:
 800cdc4:	3130 3332 3534 3736 3938 4241 4443 4645     0123456789ABCDEF

0800cdd4 <hxbn>:
	...
 800ce04:	0100 0302 0504 0706 0908 0000 0000 0000     ................
 800ce14:	0a00 0c0b 0e0d 000f 0000 0000 0000 0000     ................
	...
 800ce34:	0a00 0c0b 0e0d 000f 0000 0000 0000 0000     ................
	...

0800ced4 <outputaf>:
 800ced4:	0002 0003 0209                                   .....

0800ced9 <inputpup>:
 800ced9:	0002 0100 0109                                   .....

0800cede <outputpp>:
 800cede:	0001 0003 0100                                   .....

0800cee3 <outputcs>:
 800cee3:	0001 0003 0200                                   .....

0800cee8 <outputaf>:
 800cee8:	0002 0003 0205                                   .....

0800ceed <inputaf>:
 800ceed:	0002 0100 0105                                   .....

0800cef2 <ahbtbl>:
 800cef2:	0001 0001 0001 0001 0001 0001 0001 0001     ................
 800cf02:	0002 0004 0008 0010 0040 0080 0100 0200     ........@.......
	...

0800cf14 <tcif_tbl>:
 800cf14:	0600 1610                                   ....

0800cf18 <open_name>:
 800cf18:	d1b4 0800 d110 0800 d1b9 0800 d1be 0800     ................
 800cf28:	d1c3 0800 d1c8 0800 d1cd 0800 d1d2 0800     ................

0800cf38 <C.0.4985>:
 800cf38:	0002 0003 0200                                   .....

0800cf3d <C.1.4986>:
 800cf3d:	0002 0100 0000 7c00                              .......

0800cf44 <_global_impure_ptr>:
 800cf44:	027c 2000                                   |.. 

0800cf48 <blanks.6598>:
 800cf48:	2020 2020 2020 2020 2020 2020 2020 2020                     

0800cf58 <zeroes.6599>:
 800cf58:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000

0800cf68 <__sf_fake_stdin>:
	...

0800cf88 <__sf_fake_stdout>:
	...

0800cfa8 <__sf_fake_stderr>:
	...

0800cfc8 <p05.5124>:
 800cfc8:	0005 0000 0019 0000 007d 0000 0000 0000     ........}.......

0800cfd8 <__mprec_tens>:
 800cfd8:	0000 0000 0000 3ff0 0000 0000 0000 4024     .......?......$@
 800cfe8:	0000 0000 0000 4059 0000 0000 4000 408f     ......Y@.....@.@
 800cff8:	0000 0000 8800 40c3 0000 0000 6a00 40f8     .......@.....j.@
 800d008:	0000 0000 8480 412e 0000 0000 12d0 4163     .......A......cA
 800d018:	0000 0000 d784 4197 0000 0000 cd65 41cd     .......A....e..A
 800d028:	0000 2000 a05f 4202 0000 e800 4876 4237     ... _..B....vH7B
 800d038:	0000 a200 1a94 426d 0000 e540 309c 42a2     ......mB..@..0.B
 800d048:	0000 1e90 bcc4 42d6 0000 2634 6bf5 430c     .......B..4&.k.C
 800d058:	8000 37e0 c379 4341 a000 85d8 3457 4376     ...7y.AC....W4vC
 800d068:	c800 674e c16d 43ab 3d00 6091 58e4 43e1     ..Ngm..C.=.`.X.C
 800d078:	8c40 78b5 af1d 4415 ef50 d6e2 1ae4 444b     @..x...DP.....KD
 800d088:	d592 064d f0cf 4480 4af6 c7e1 2d02 44b5     ..M....D.J...-.D
 800d098:	9db4 79d9 7843 44ea                         ...yCx.D

0800d0a0 <__mprec_bigtens>:
 800d0a0:	8000 37e0 c379 4341 6e17 b505 b8b5 4693     ...7y.AC.n.....F
 800d0b0:	f9f5 e93f 4f03 4d38 1d32 f930 7748 5a82     ..?..O8M2.0.Hw.Z
 800d0c0:	bf3c 7f73 4fdd 7515                         <.s..O.u

0800d0c8 <__mprec_tinytens>:
 800d0c8:	89bc 97d8 d2b2 3c9c a733 d5a8 f623 3949     .......<3...#.I9
 800d0d8:	a73d 44f4 0ffd 32a5 979d cf8c ba08 255b     =..D...2......[%
 800d0e8:	6f43 64ac 0628 0ac8                         Co.d(...

0800d0f0 <blanks.6542>:
 800d0f0:	2020 2020 2020 2020 2020 2020 2020 2020                     

0800d100 <zeroes.6543>:
 800d100:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000
 800d110:	7474 3279 2500 3631 2573 6434 4300 7275     tty2.%16s%4d.Cur
 800d120:	6572 746e 5320 6174 6574 003a 4356 2050     rent State:.VCP 
 800d130:	6e49 6574 6672 6361 0065 4356 2050 6f43     Interface.VCP Co
 800d140:	666e 6769 3000 3030 3030 3030 3030 3035     nfig.00000000050
 800d150:	0042 3030 3030 3030 3030 3530 4330 5300     B.00000000050C.S
 800d160:	4d54 6369 6f72 6c65 6365 7274 6e6f 6369     TMicroelectronic
 800d170:	0073 5453 334d 2032 6956 7472 6175 206c     s.STM32 Virtual 
 800d180:	6f43 506d 726f 2074 6e69 4820 2053 6f6d     ComPort in HS mo
 800d190:	6564 5300 4d54 3233 5620 7269 7574 6c61     de.STM32 Virtual
 800d1a0:	4320 6d6f 6f50 7472 6920 206e 5346 4d20      ComPort in FS M
 800d1b0:	646f 0065 7474 3179 7400 7974 0033 7474     ode.tty1.tty3.tt
 800d1c0:	3479 7400 7974 0035 7474 3679 7400 7974     y4.tty5.tty6.tty
 800d1d0:	0037 7474 3879 0000 0043 0000 4e49 0046     7.tty8..C...INF.
 800d1e0:	6e69 0066 414e 004e 616e 006e 3130 3332     inf.NAN.nan.0123
 800d1f0:	3534 3736 3938 4241 4443 4645 0000 0000     456789ABCDEF....
 800d200:	3130 3332 3534 3736 3938 6261 6463 6665     0123456789abcdef
 800d210:	0000 0000 6e28 6c75 296c 0000 0030 0000     ....(null)..0...
 800d220:	6e49 6966 696e 7974 0000 0000 614e 004e     Infinity....NaN.
 800d230:	4f50 4953 0058 0000 002e 0000               POSIX.......
