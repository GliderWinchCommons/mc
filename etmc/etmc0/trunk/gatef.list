
gatef.elf:     file format elf32-littlearm


Disassembly of section .text:

08000188 <incIdx>:
#define CANBUSBUFSIZE	64	// Number of incoming CAN msgs to buffer
static struct CANRCVBUF canbuf[CANBUSBUFSIZE];
static u32 canmsgct[CANBUSBUFSIZE]; // Msg seq number for CAN-to-PC.
static int canbufidxi = 0;	// Incoming index into canbuf
static int canbufidxm = 0;	// Outgoing index into canbuf
static int incIdx(int x){x += 1; if (x >= CANBUSBUFSIZE) x = 0; return x;} 
 8000188:	3001      	adds	r0, #1
 800018a:	283f      	cmp	r0, #63	; 0x3f
 800018c:	bfc8      	it	gt
 800018e:	2000      	movgt	r0, #0
 8000190:	4770      	bx	lr

08000192 <canbuf_add>:
 * static void canbuf_add(struct CANRCVBUF* p);
 * @brief	: Add msg to buffer
 * @param	: p = Pointer to CAN msg
 * ************************************************************************************** */
static void canbuf_add(struct CANRCVBUF* p)
{
 8000192:	b570      	push	{r4, r5, r6, lr}
	int temp;
	canbuf[canbufidxi] = *p;		// Copy struct
 8000194:	4c0f      	ldr	r4, [pc, #60]	; (80001d4 <canbuf_add+0x42>)
 8000196:	c80f      	ldmia	r0, {r0, r1, r2, r3}
 8000198:	6826      	ldr	r6, [r4, #0]
 800019a:	eb04 1506 	add.w	r5, r4, r6, lsl #4
 800019e:	3508      	adds	r5, #8
 80001a0:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
	canmsgct[canbufidxi] = canmsgctr;	// Save sequence count that goes with this msg
 80001a4:	f894 3408 	ldrb.w	r3, [r4, #1032]	; 0x408
 80001a8:	eb04 0286 	add.w	r2, r4, r6, lsl #2
	canmsgctr += 1;				// Count incoming CAN msgs
	temp = incIdx(canbufidxi);		// Increment the index for incoming msgs.
 80001ac:	4630      	mov	r0, r6
 * ************************************************************************************** */
static void canbuf_add(struct CANRCVBUF* p)
{
	int temp;
	canbuf[canbufidxi] = *p;		// Copy struct
	canmsgct[canbufidxi] = canmsgctr;	// Save sequence count that goes with this msg
 80001ae:	f8c2 340c 	str.w	r3, [r2, #1036]	; 0x40c
	canmsgctr += 1;				// Count incoming CAN msgs
 80001b2:	3301      	adds	r3, #1
 80001b4:	f884 3408 	strb.w	r3, [r4, #1032]	; 0x408
	temp = incIdx(canbufidxi);		// Increment the index for incoming msgs.
 80001b8:	f7ff ffe6 	bl	8000188 <incIdx>
	if (canbufidxm == temp)  		// Did this last fill the last one?
 80001bc:	f8d4 350c 	ldr.w	r3, [r4, #1292]	; 0x50c
 80001c0:	4283      	cmp	r3, r0
 80001c2:	d105      	bne.n	80001d0 <canbuf_add+0x3e>
	{ // Yes, we have filled the buffer.  This CAN msg might be dropped (by not advancing the index)
		Errors_misc(-1);		// Add to buffer overrun counter
 80001c4:	f04f 30ff 	mov.w	r0, #4294967295
	else
	{ // Here, there is room in the buffer and we are good to go.
		canbufidxi = temp;		// Update the index to next buffer position.
	}	
	return;
}
 80001c8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	canmsgct[canbufidxi] = canmsgctr;	// Save sequence count that goes with this msg
	canmsgctr += 1;				// Count incoming CAN msgs
	temp = incIdx(canbufidxi);		// Increment the index for incoming msgs.
	if (canbufidxm == temp)  		// Did this last fill the last one?
	{ // Yes, we have filled the buffer.  This CAN msg might be dropped (by not advancing the index)
		Errors_misc(-1);		// Add to buffer overrun counter
 80001cc:	f000 bddc 	b.w	8000d88 <Errors_misc>
	}
	else
	{ // Here, there is room in the buffer and we are good to go.
		canbufidxi = temp;		// Update the index to next buffer position.
 80001d0:	6020      	str	r0, [r4, #0]
	}	
	return;
}
 80001d2:	bd70      	pop	{r4, r5, r6, pc}
 80001d4:	20000800 	.word	0x20000800

080001d8 <Default_Handler08>:
float outputTorque = 0.0;

/* --------------- For debugging...(usb) ------------------------------ */
int Default_HandlerCode = 999;
u32 DH08;
void Default_Handler08(void) {DH08 += 1; return;}
 80001d8:	4b02      	ldr	r3, [pc, #8]	; (80001e4 <Default_Handler08+0xc>)
 80001da:	681a      	ldr	r2, [r3, #0]
 80001dc:	3201      	adds	r2, #1
 80001de:	601a      	str	r2, [r3, #0]
 80001e0:	4770      	bx	lr
 80001e2:	bf00      	nop
 80001e4:	200019e8 	.word	0x200019e8

080001e8 <Default_Handler76>:

void OTG_FS_IRQHandler(void);
void Default_Handler76(void) {	OTG_FS_IRQHandler(); return; }
 80001e8:	f000 be04 	b.w	8000df4 <OTG_FS_IRQHandler>

080001ec <Default_Handler00>:

void Default_Handler00(void) { Default_HandlerCode =  0; panic_leds(5); }
 80001ec:	4b02      	ldr	r3, [pc, #8]	; (80001f8 <Default_Handler00+0xc>)
 80001ee:	2200      	movs	r2, #0
 80001f0:	2005      	movs	r0, #5
 80001f2:	601a      	str	r2, [r3, #0]
 80001f4:	f004 bde3 	b.w	8004dbe <panic_leds>
 80001f8:	20000000 	.word	0x20000000

080001fc <Default_Handler01>:
void Default_Handler01(void) { Default_HandlerCode =  1; panic_leds(5); }
 80001fc:	4b02      	ldr	r3, [pc, #8]	; (8000208 <Default_Handler01+0xc>)
 80001fe:	2201      	movs	r2, #1
 8000200:	2005      	movs	r0, #5
 8000202:	601a      	str	r2, [r3, #0]
 8000204:	f004 bddb 	b.w	8004dbe <panic_leds>
 8000208:	20000000 	.word	0x20000000

0800020c <Default_Handler02>:
void Default_Handler02(void) { Default_HandlerCode =  2; panic_leds(5); }
 800020c:	4b02      	ldr	r3, [pc, #8]	; (8000218 <Default_Handler02+0xc>)
 800020e:	2202      	movs	r2, #2
 8000210:	2005      	movs	r0, #5
 8000212:	601a      	str	r2, [r3, #0]
 8000214:	f004 bdd3 	b.w	8004dbe <panic_leds>
 8000218:	20000000 	.word	0x20000000

0800021c <Default_Handler03>:
void Default_Handler03(void) { Default_HandlerCode =  3; panic_leds(5); }
 800021c:	4b02      	ldr	r3, [pc, #8]	; (8000228 <Default_Handler03+0xc>)
 800021e:	2203      	movs	r2, #3
 8000220:	2005      	movs	r0, #5
 8000222:	601a      	str	r2, [r3, #0]
 8000224:	f004 bdcb 	b.w	8004dbe <panic_leds>
 8000228:	20000000 	.word	0x20000000

0800022c <Default_Handler04>:
void Default_Handler04(void) { Default_HandlerCode =  4; panic_leds(5); }
 800022c:	4b02      	ldr	r3, [pc, #8]	; (8000238 <Default_Handler04+0xc>)
 800022e:	2204      	movs	r2, #4
 8000230:	2005      	movs	r0, #5
 8000232:	601a      	str	r2, [r3, #0]
 8000234:	f004 bdc3 	b.w	8004dbe <panic_leds>
 8000238:	20000000 	.word	0x20000000

0800023c <Default_Handler05>:
void Default_Handler05(void) { Default_HandlerCode =  5; panic_leds(5); }
 800023c:	4b02      	ldr	r3, [pc, #8]	; (8000248 <Default_Handler05+0xc>)
 800023e:	2005      	movs	r0, #5
 8000240:	6018      	str	r0, [r3, #0]
 8000242:	f004 bdbc 	b.w	8004dbe <panic_leds>
 8000246:	bf00      	nop
 8000248:	20000000 	.word	0x20000000

0800024c <Default_Handler06>:
void Default_Handler06(void) { Default_HandlerCode =  6; panic_leds(5); }
 800024c:	4b02      	ldr	r3, [pc, #8]	; (8000258 <Default_Handler06+0xc>)
 800024e:	2206      	movs	r2, #6
 8000250:	2005      	movs	r0, #5
 8000252:	601a      	str	r2, [r3, #0]
 8000254:	f004 bdb3 	b.w	8004dbe <panic_leds>
 8000258:	20000000 	.word	0x20000000

0800025c <Default_Handler07>:
void Default_Handler07(void) { Default_HandlerCode =  7; panic_leds(5); }
 800025c:	4b02      	ldr	r3, [pc, #8]	; (8000268 <Default_Handler07+0xc>)
 800025e:	2207      	movs	r2, #7
 8000260:	2005      	movs	r0, #5
 8000262:	601a      	str	r2, [r3, #0]
 8000264:	f004 bdab 	b.w	8004dbe <panic_leds>
 8000268:	20000000 	.word	0x20000000

0800026c <Default_Handler09>:
//void Default_Handler08(void) { Default_HandlerCode =  8; panic_leds(5); }
void Default_Handler09(void) { Default_HandlerCode =  9; panic_leds(5); }
 800026c:	4b02      	ldr	r3, [pc, #8]	; (8000278 <Default_Handler09+0xc>)
 800026e:	2209      	movs	r2, #9
 8000270:	2005      	movs	r0, #5
 8000272:	601a      	str	r2, [r3, #0]
 8000274:	f004 bda3 	b.w	8004dbe <panic_leds>
 8000278:	20000000 	.word	0x20000000

0800027c <Default_Handler10>:
void Default_Handler10(void) { Default_HandlerCode = 10; panic_leds(5); }
 800027c:	4b02      	ldr	r3, [pc, #8]	; (8000288 <Default_Handler10+0xc>)
 800027e:	220a      	movs	r2, #10
 8000280:	2005      	movs	r0, #5
 8000282:	601a      	str	r2, [r3, #0]
 8000284:	f004 bd9b 	b.w	8004dbe <panic_leds>
 8000288:	20000000 	.word	0x20000000

0800028c <Default_Handler11>:
void Default_Handler11(void) { Default_HandlerCode = 11; panic_leds(5); }
 800028c:	4b02      	ldr	r3, [pc, #8]	; (8000298 <Default_Handler11+0xc>)
 800028e:	220b      	movs	r2, #11
 8000290:	2005      	movs	r0, #5
 8000292:	601a      	str	r2, [r3, #0]
 8000294:	f004 bd93 	b.w	8004dbe <panic_leds>
 8000298:	20000000 	.word	0x20000000

0800029c <Default_Handler12>:
void Default_Handler12(void) { Default_HandlerCode = 12; panic_leds(5); }
 800029c:	4b02      	ldr	r3, [pc, #8]	; (80002a8 <Default_Handler12+0xc>)
 800029e:	220c      	movs	r2, #12
 80002a0:	2005      	movs	r0, #5
 80002a2:	601a      	str	r2, [r3, #0]
 80002a4:	f004 bd8b 	b.w	8004dbe <panic_leds>
 80002a8:	20000000 	.word	0x20000000

080002ac <Default_Handler13>:
void Default_Handler13(void) { Default_HandlerCode = 13; panic_leds(5); }
 80002ac:	4b02      	ldr	r3, [pc, #8]	; (80002b8 <Default_Handler13+0xc>)
 80002ae:	220d      	movs	r2, #13
 80002b0:	2005      	movs	r0, #5
 80002b2:	601a      	str	r2, [r3, #0]
 80002b4:	f004 bd83 	b.w	8004dbe <panic_leds>
 80002b8:	20000000 	.word	0x20000000

080002bc <Default_Handler14>:
void Default_Handler14(void) { Default_HandlerCode = 14; panic_leds(5); }
 80002bc:	4b02      	ldr	r3, [pc, #8]	; (80002c8 <Default_Handler14+0xc>)
 80002be:	220e      	movs	r2, #14
 80002c0:	2005      	movs	r0, #5
 80002c2:	601a      	str	r2, [r3, #0]
 80002c4:	f004 bd7b 	b.w	8004dbe <panic_leds>
 80002c8:	20000000 	.word	0x20000000

080002cc <Default_Handler15>:
void Default_Handler15(void) { Default_HandlerCode = 15; panic_leds(5); }
 80002cc:	4b02      	ldr	r3, [pc, #8]	; (80002d8 <Default_Handler15+0xc>)
 80002ce:	220f      	movs	r2, #15
 80002d0:	2005      	movs	r0, #5
 80002d2:	601a      	str	r2, [r3, #0]
 80002d4:	f004 bd73 	b.w	8004dbe <panic_leds>
 80002d8:	20000000 	.word	0x20000000

080002dc <Default_Handler16>:
void Default_Handler16(void) { Default_HandlerCode = 16; panic_leds(5); }
 80002dc:	4b02      	ldr	r3, [pc, #8]	; (80002e8 <Default_Handler16+0xc>)
 80002de:	2210      	movs	r2, #16
 80002e0:	2005      	movs	r0, #5
 80002e2:	601a      	str	r2, [r3, #0]
 80002e4:	f004 bd6b 	b.w	8004dbe <panic_leds>
 80002e8:	20000000 	.word	0x20000000

080002ec <Default_Handler17>:
void Default_Handler17(void) { Default_HandlerCode = 17; panic_leds(5); }
 80002ec:	4b02      	ldr	r3, [pc, #8]	; (80002f8 <Default_Handler17+0xc>)
 80002ee:	2211      	movs	r2, #17
 80002f0:	2005      	movs	r0, #5
 80002f2:	601a      	str	r2, [r3, #0]
 80002f4:	f004 bd63 	b.w	8004dbe <panic_leds>
 80002f8:	20000000 	.word	0x20000000

080002fc <Default_Handler18>:
void Default_Handler18(void) { Default_HandlerCode = 18; panic_leds(5); }
 80002fc:	4b02      	ldr	r3, [pc, #8]	; (8000308 <Default_Handler18+0xc>)
 80002fe:	2212      	movs	r2, #18
 8000300:	2005      	movs	r0, #5
 8000302:	601a      	str	r2, [r3, #0]
 8000304:	f004 bd5b 	b.w	8004dbe <panic_leds>
 8000308:	20000000 	.word	0x20000000

0800030c <Default_Handler19>:
void Default_Handler19(void) { Default_HandlerCode = 19; panic_leds(5); }
 800030c:	4b02      	ldr	r3, [pc, #8]	; (8000318 <Default_Handler19+0xc>)
 800030e:	2213      	movs	r2, #19
 8000310:	2005      	movs	r0, #5
 8000312:	601a      	str	r2, [r3, #0]
 8000314:	f004 bd53 	b.w	8004dbe <panic_leds>
 8000318:	20000000 	.word	0x20000000

0800031c <Default_Handler20>:
void Default_Handler20(void) { Default_HandlerCode = 20; panic_leds(5); }
 800031c:	4b02      	ldr	r3, [pc, #8]	; (8000328 <Default_Handler20+0xc>)
 800031e:	2214      	movs	r2, #20
 8000320:	2005      	movs	r0, #5
 8000322:	601a      	str	r2, [r3, #0]
 8000324:	f004 bd4b 	b.w	8004dbe <panic_leds>
 8000328:	20000000 	.word	0x20000000

0800032c <Default_Handler21>:
void Default_Handler21(void) { Default_HandlerCode = 21; panic_leds(5); }
 800032c:	4b02      	ldr	r3, [pc, #8]	; (8000338 <Default_Handler21+0xc>)
 800032e:	2215      	movs	r2, #21
 8000330:	2005      	movs	r0, #5
 8000332:	601a      	str	r2, [r3, #0]
 8000334:	f004 bd43 	b.w	8004dbe <panic_leds>
 8000338:	20000000 	.word	0x20000000

0800033c <Default_Handler22>:
void Default_Handler22(void) { Default_HandlerCode = 22; panic_leds(5); }
 800033c:	4b02      	ldr	r3, [pc, #8]	; (8000348 <Default_Handler22+0xc>)
 800033e:	2216      	movs	r2, #22
 8000340:	2005      	movs	r0, #5
 8000342:	601a      	str	r2, [r3, #0]
 8000344:	f004 bd3b 	b.w	8004dbe <panic_leds>
 8000348:	20000000 	.word	0x20000000

0800034c <Default_Handler23>:
void Default_Handler23(void) { Default_HandlerCode = 23; panic_leds(5); }
 800034c:	4b02      	ldr	r3, [pc, #8]	; (8000358 <Default_Handler23+0xc>)
 800034e:	2217      	movs	r2, #23
 8000350:	2005      	movs	r0, #5
 8000352:	601a      	str	r2, [r3, #0]
 8000354:	f004 bd33 	b.w	8004dbe <panic_leds>
 8000358:	20000000 	.word	0x20000000

0800035c <Default_Handler24>:
void Default_Handler24(void) { Default_HandlerCode = 24; panic_leds(5); }
 800035c:	4b02      	ldr	r3, [pc, #8]	; (8000368 <Default_Handler24+0xc>)
 800035e:	2218      	movs	r2, #24
 8000360:	2005      	movs	r0, #5
 8000362:	601a      	str	r2, [r3, #0]
 8000364:	f004 bd2b 	b.w	8004dbe <panic_leds>
 8000368:	20000000 	.word	0x20000000

0800036c <Default_Handler25>:
void Default_Handler25(void) { Default_HandlerCode = 25; panic_leds(5); }
 800036c:	4b02      	ldr	r3, [pc, #8]	; (8000378 <Default_Handler25+0xc>)
 800036e:	2219      	movs	r2, #25
 8000370:	2005      	movs	r0, #5
 8000372:	601a      	str	r2, [r3, #0]
 8000374:	f004 bd23 	b.w	8004dbe <panic_leds>
 8000378:	20000000 	.word	0x20000000

0800037c <Default_Handler26>:
void Default_Handler26(void) { Default_HandlerCode = 26; panic_leds(5); }
 800037c:	4b02      	ldr	r3, [pc, #8]	; (8000388 <Default_Handler26+0xc>)
 800037e:	221a      	movs	r2, #26
 8000380:	2005      	movs	r0, #5
 8000382:	601a      	str	r2, [r3, #0]
 8000384:	f004 bd1b 	b.w	8004dbe <panic_leds>
 8000388:	20000000 	.word	0x20000000

0800038c <Default_Handler27>:
void Default_Handler27(void) { Default_HandlerCode = 27; panic_leds(5); }
 800038c:	4b02      	ldr	r3, [pc, #8]	; (8000398 <Default_Handler27+0xc>)
 800038e:	221b      	movs	r2, #27
 8000390:	2005      	movs	r0, #5
 8000392:	601a      	str	r2, [r3, #0]
 8000394:	f004 bd13 	b.w	8004dbe <panic_leds>
 8000398:	20000000 	.word	0x20000000

0800039c <Default_Handler28>:
void Default_Handler28(void) { Default_HandlerCode = 28; panic_leds(5); }
 800039c:	4b02      	ldr	r3, [pc, #8]	; (80003a8 <Default_Handler28+0xc>)
 800039e:	221c      	movs	r2, #28
 80003a0:	2005      	movs	r0, #5
 80003a2:	601a      	str	r2, [r3, #0]
 80003a4:	f004 bd0b 	b.w	8004dbe <panic_leds>
 80003a8:	20000000 	.word	0x20000000

080003ac <Default_Handler29>:
void Default_Handler29(void) { Default_HandlerCode = 29; panic_leds(5); }
 80003ac:	4b02      	ldr	r3, [pc, #8]	; (80003b8 <Default_Handler29+0xc>)
 80003ae:	221d      	movs	r2, #29
 80003b0:	2005      	movs	r0, #5
 80003b2:	601a      	str	r2, [r3, #0]
 80003b4:	f004 bd03 	b.w	8004dbe <panic_leds>
 80003b8:	20000000 	.word	0x20000000

080003bc <Default_Handler30>:
void Default_Handler30(void) { Default_HandlerCode = 30; panic_leds(5); }
 80003bc:	4b02      	ldr	r3, [pc, #8]	; (80003c8 <Default_Handler30+0xc>)
 80003be:	221e      	movs	r2, #30
 80003c0:	2005      	movs	r0, #5
 80003c2:	601a      	str	r2, [r3, #0]
 80003c4:	f004 bcfb 	b.w	8004dbe <panic_leds>
 80003c8:	20000000 	.word	0x20000000

080003cc <Default_Handler31>:
void Default_Handler31(void) { Default_HandlerCode = 31; panic_leds(5); }
 80003cc:	4b02      	ldr	r3, [pc, #8]	; (80003d8 <Default_Handler31+0xc>)
 80003ce:	221f      	movs	r2, #31
 80003d0:	2005      	movs	r0, #5
 80003d2:	601a      	str	r2, [r3, #0]
 80003d4:	f004 bcf3 	b.w	8004dbe <panic_leds>
 80003d8:	20000000 	.word	0x20000000

080003dc <Default_Handler32>:
void Default_Handler32(void) { Default_HandlerCode = 32; panic_leds(5); }
 80003dc:	4b02      	ldr	r3, [pc, #8]	; (80003e8 <Default_Handler32+0xc>)
 80003de:	2220      	movs	r2, #32
 80003e0:	2005      	movs	r0, #5
 80003e2:	601a      	str	r2, [r3, #0]
 80003e4:	f004 bceb 	b.w	8004dbe <panic_leds>
 80003e8:	20000000 	.word	0x20000000

080003ec <Default_Handler33>:
void Default_Handler33(void) { Default_HandlerCode = 33; panic_leds(5); }
 80003ec:	4b02      	ldr	r3, [pc, #8]	; (80003f8 <Default_Handler33+0xc>)
 80003ee:	2221      	movs	r2, #33	; 0x21
 80003f0:	2005      	movs	r0, #5
 80003f2:	601a      	str	r2, [r3, #0]
 80003f4:	f004 bce3 	b.w	8004dbe <panic_leds>
 80003f8:	20000000 	.word	0x20000000

080003fc <Default_Handler34>:
void Default_Handler34(void) { Default_HandlerCode = 34; panic_leds(5); }
 80003fc:	4b02      	ldr	r3, [pc, #8]	; (8000408 <Default_Handler34+0xc>)
 80003fe:	2222      	movs	r2, #34	; 0x22
 8000400:	2005      	movs	r0, #5
 8000402:	601a      	str	r2, [r3, #0]
 8000404:	f004 bcdb 	b.w	8004dbe <panic_leds>
 8000408:	20000000 	.word	0x20000000

0800040c <Default_Handler35>:
void Default_Handler35(void) { Default_HandlerCode = 35; panic_leds(5); }
 800040c:	4b02      	ldr	r3, [pc, #8]	; (8000418 <Default_Handler35+0xc>)
 800040e:	2223      	movs	r2, #35	; 0x23
 8000410:	2005      	movs	r0, #5
 8000412:	601a      	str	r2, [r3, #0]
 8000414:	f004 bcd3 	b.w	8004dbe <panic_leds>
 8000418:	20000000 	.word	0x20000000

0800041c <Default_Handler36>:
void Default_Handler36(void) { Default_HandlerCode = 36; panic_leds(5); }
 800041c:	4b02      	ldr	r3, [pc, #8]	; (8000428 <Default_Handler36+0xc>)
 800041e:	2224      	movs	r2, #36	; 0x24
 8000420:	2005      	movs	r0, #5
 8000422:	601a      	str	r2, [r3, #0]
 8000424:	f004 bccb 	b.w	8004dbe <panic_leds>
 8000428:	20000000 	.word	0x20000000

0800042c <Default_Handler37>:
void Default_Handler37(void) { Default_HandlerCode = 37; panic_leds(5); }
 800042c:	4b02      	ldr	r3, [pc, #8]	; (8000438 <Default_Handler37+0xc>)
 800042e:	2225      	movs	r2, #37	; 0x25
 8000430:	2005      	movs	r0, #5
 8000432:	601a      	str	r2, [r3, #0]
 8000434:	f004 bcc3 	b.w	8004dbe <panic_leds>
 8000438:	20000000 	.word	0x20000000

0800043c <Default_Handler38>:
void Default_Handler38(void) { Default_HandlerCode = 38; panic_leds(5); }
 800043c:	4b02      	ldr	r3, [pc, #8]	; (8000448 <Default_Handler38+0xc>)
 800043e:	2226      	movs	r2, #38	; 0x26
 8000440:	2005      	movs	r0, #5
 8000442:	601a      	str	r2, [r3, #0]
 8000444:	f004 bcbb 	b.w	8004dbe <panic_leds>
 8000448:	20000000 	.word	0x20000000

0800044c <Default_Handler39>:
void Default_Handler39(void) { Default_HandlerCode = 39; panic_leds(5); }
 800044c:	4b02      	ldr	r3, [pc, #8]	; (8000458 <Default_Handler39+0xc>)
 800044e:	2227      	movs	r2, #39	; 0x27
 8000450:	2005      	movs	r0, #5
 8000452:	601a      	str	r2, [r3, #0]
 8000454:	f004 bcb3 	b.w	8004dbe <panic_leds>
 8000458:	20000000 	.word	0x20000000

0800045c <Default_Handler40>:
void Default_Handler40(void) { Default_HandlerCode = 40; panic_leds(5); }
 800045c:	4b02      	ldr	r3, [pc, #8]	; (8000468 <Default_Handler40+0xc>)
 800045e:	2228      	movs	r2, #40	; 0x28
 8000460:	2005      	movs	r0, #5
 8000462:	601a      	str	r2, [r3, #0]
 8000464:	f004 bcab 	b.w	8004dbe <panic_leds>
 8000468:	20000000 	.word	0x20000000

0800046c <Default_Handler41>:
void Default_Handler41(void) { Default_HandlerCode = 41; panic_leds(5); }
 800046c:	4b02      	ldr	r3, [pc, #8]	; (8000478 <Default_Handler41+0xc>)
 800046e:	2229      	movs	r2, #41	; 0x29
 8000470:	2005      	movs	r0, #5
 8000472:	601a      	str	r2, [r3, #0]
 8000474:	f004 bca3 	b.w	8004dbe <panic_leds>
 8000478:	20000000 	.word	0x20000000

0800047c <Default_Handler42>:
void Default_Handler42(void) { Default_HandlerCode = 42; panic_leds(5); }
 800047c:	4b02      	ldr	r3, [pc, #8]	; (8000488 <Default_Handler42+0xc>)
 800047e:	222a      	movs	r2, #42	; 0x2a
 8000480:	2005      	movs	r0, #5
 8000482:	601a      	str	r2, [r3, #0]
 8000484:	f004 bc9b 	b.w	8004dbe <panic_leds>
 8000488:	20000000 	.word	0x20000000

0800048c <Default_Handler43>:
void Default_Handler43(void) { Default_HandlerCode = 43; panic_leds(5); }
 800048c:	4b02      	ldr	r3, [pc, #8]	; (8000498 <Default_Handler43+0xc>)
 800048e:	222b      	movs	r2, #43	; 0x2b
 8000490:	2005      	movs	r0, #5
 8000492:	601a      	str	r2, [r3, #0]
 8000494:	f004 bc93 	b.w	8004dbe <panic_leds>
 8000498:	20000000 	.word	0x20000000

0800049c <Default_Handler44>:
void Default_Handler44(void) { Default_HandlerCode = 44; panic_leds(5); }
 800049c:	4b02      	ldr	r3, [pc, #8]	; (80004a8 <Default_Handler44+0xc>)
 800049e:	222c      	movs	r2, #44	; 0x2c
 80004a0:	2005      	movs	r0, #5
 80004a2:	601a      	str	r2, [r3, #0]
 80004a4:	f004 bc8b 	b.w	8004dbe <panic_leds>
 80004a8:	20000000 	.word	0x20000000

080004ac <Default_Handler45>:
void Default_Handler45(void) { Default_HandlerCode = 45; panic_leds(5); }
 80004ac:	4b02      	ldr	r3, [pc, #8]	; (80004b8 <Default_Handler45+0xc>)
 80004ae:	222d      	movs	r2, #45	; 0x2d
 80004b0:	2005      	movs	r0, #5
 80004b2:	601a      	str	r2, [r3, #0]
 80004b4:	f004 bc83 	b.w	8004dbe <panic_leds>
 80004b8:	20000000 	.word	0x20000000

080004bc <Default_Handler46>:
void Default_Handler46(void) { Default_HandlerCode = 46; panic_leds(5); }
 80004bc:	4b02      	ldr	r3, [pc, #8]	; (80004c8 <Default_Handler46+0xc>)
 80004be:	222e      	movs	r2, #46	; 0x2e
 80004c0:	2005      	movs	r0, #5
 80004c2:	601a      	str	r2, [r3, #0]
 80004c4:	f004 bc7b 	b.w	8004dbe <panic_leds>
 80004c8:	20000000 	.word	0x20000000

080004cc <Default_Handler47>:
void Default_Handler47(void) { Default_HandlerCode = 47; panic_leds(5); }
 80004cc:	4b02      	ldr	r3, [pc, #8]	; (80004d8 <Default_Handler47+0xc>)
 80004ce:	222f      	movs	r2, #47	; 0x2f
 80004d0:	2005      	movs	r0, #5
 80004d2:	601a      	str	r2, [r3, #0]
 80004d4:	f004 bc73 	b.w	8004dbe <panic_leds>
 80004d8:	20000000 	.word	0x20000000

080004dc <Default_Handler48>:
void Default_Handler48(void) { Default_HandlerCode = 48; panic_leds(5); }
 80004dc:	4b02      	ldr	r3, [pc, #8]	; (80004e8 <Default_Handler48+0xc>)
 80004de:	2230      	movs	r2, #48	; 0x30
 80004e0:	2005      	movs	r0, #5
 80004e2:	601a      	str	r2, [r3, #0]
 80004e4:	f004 bc6b 	b.w	8004dbe <panic_leds>
 80004e8:	20000000 	.word	0x20000000

080004ec <Default_Handler49>:
void Default_Handler49(void) { Default_HandlerCode = 49; panic_leds(5); }
 80004ec:	4b02      	ldr	r3, [pc, #8]	; (80004f8 <Default_Handler49+0xc>)
 80004ee:	2231      	movs	r2, #49	; 0x31
 80004f0:	2005      	movs	r0, #5
 80004f2:	601a      	str	r2, [r3, #0]
 80004f4:	f004 bc63 	b.w	8004dbe <panic_leds>
 80004f8:	20000000 	.word	0x20000000

080004fc <Default_Handler50>:
void Default_Handler50(void) { Default_HandlerCode = 50; panic_leds(5); }
 80004fc:	4b02      	ldr	r3, [pc, #8]	; (8000508 <Default_Handler50+0xc>)
 80004fe:	2232      	movs	r2, #50	; 0x32
 8000500:	2005      	movs	r0, #5
 8000502:	601a      	str	r2, [r3, #0]
 8000504:	f004 bc5b 	b.w	8004dbe <panic_leds>
 8000508:	20000000 	.word	0x20000000

0800050c <Default_Handler51>:
void Default_Handler51(void) { Default_HandlerCode = 51; panic_leds(5); }
 800050c:	4b02      	ldr	r3, [pc, #8]	; (8000518 <Default_Handler51+0xc>)
 800050e:	2233      	movs	r2, #51	; 0x33
 8000510:	2005      	movs	r0, #5
 8000512:	601a      	str	r2, [r3, #0]
 8000514:	f004 bc53 	b.w	8004dbe <panic_leds>
 8000518:	20000000 	.word	0x20000000

0800051c <Default_Handler52>:
void Default_Handler52(void) { Default_HandlerCode = 52; panic_leds(5); }
 800051c:	4b02      	ldr	r3, [pc, #8]	; (8000528 <Default_Handler52+0xc>)
 800051e:	2234      	movs	r2, #52	; 0x34
 8000520:	2005      	movs	r0, #5
 8000522:	601a      	str	r2, [r3, #0]
 8000524:	f004 bc4b 	b.w	8004dbe <panic_leds>
 8000528:	20000000 	.word	0x20000000

0800052c <Default_Handler53>:
void Default_Handler53(void) { Default_HandlerCode = 53; panic_leds(5); }
 800052c:	4b02      	ldr	r3, [pc, #8]	; (8000538 <Default_Handler53+0xc>)
 800052e:	2235      	movs	r2, #53	; 0x35
 8000530:	2005      	movs	r0, #5
 8000532:	601a      	str	r2, [r3, #0]
 8000534:	f004 bc43 	b.w	8004dbe <panic_leds>
 8000538:	20000000 	.word	0x20000000

0800053c <Default_Handler54>:
void Default_Handler54(void) { Default_HandlerCode = 54; panic_leds(5); }
 800053c:	4b02      	ldr	r3, [pc, #8]	; (8000548 <Default_Handler54+0xc>)
 800053e:	2236      	movs	r2, #54	; 0x36
 8000540:	2005      	movs	r0, #5
 8000542:	601a      	str	r2, [r3, #0]
 8000544:	f004 bc3b 	b.w	8004dbe <panic_leds>
 8000548:	20000000 	.word	0x20000000

0800054c <Default_Handler55>:
void Default_Handler55(void) { Default_HandlerCode = 55; panic_leds(5); }
 800054c:	4b02      	ldr	r3, [pc, #8]	; (8000558 <Default_Handler55+0xc>)
 800054e:	2237      	movs	r2, #55	; 0x37
 8000550:	2005      	movs	r0, #5
 8000552:	601a      	str	r2, [r3, #0]
 8000554:	f004 bc33 	b.w	8004dbe <panic_leds>
 8000558:	20000000 	.word	0x20000000

0800055c <Default_Handler56>:
void Default_Handler56(void) { Default_HandlerCode = 56; panic_leds(5); }
 800055c:	4b02      	ldr	r3, [pc, #8]	; (8000568 <Default_Handler56+0xc>)
 800055e:	2238      	movs	r2, #56	; 0x38
 8000560:	2005      	movs	r0, #5
 8000562:	601a      	str	r2, [r3, #0]
 8000564:	f004 bc2b 	b.w	8004dbe <panic_leds>
 8000568:	20000000 	.word	0x20000000

0800056c <Default_Handler57>:
void Default_Handler57(void) { Default_HandlerCode = 57; panic_leds(5); }
 800056c:	4b02      	ldr	r3, [pc, #8]	; (8000578 <Default_Handler57+0xc>)
 800056e:	2239      	movs	r2, #57	; 0x39
 8000570:	2005      	movs	r0, #5
 8000572:	601a      	str	r2, [r3, #0]
 8000574:	f004 bc23 	b.w	8004dbe <panic_leds>
 8000578:	20000000 	.word	0x20000000

0800057c <Default_Handler58>:
void Default_Handler58(void) { Default_HandlerCode = 58; panic_leds(5); }
 800057c:	4b02      	ldr	r3, [pc, #8]	; (8000588 <Default_Handler58+0xc>)
 800057e:	223a      	movs	r2, #58	; 0x3a
 8000580:	2005      	movs	r0, #5
 8000582:	601a      	str	r2, [r3, #0]
 8000584:	f004 bc1b 	b.w	8004dbe <panic_leds>
 8000588:	20000000 	.word	0x20000000

0800058c <Default_Handler59>:
void Default_Handler59(void) { Default_HandlerCode = 59; panic_leds(5); }
 800058c:	4b02      	ldr	r3, [pc, #8]	; (8000598 <Default_Handler59+0xc>)
 800058e:	223b      	movs	r2, #59	; 0x3b
 8000590:	2005      	movs	r0, #5
 8000592:	601a      	str	r2, [r3, #0]
 8000594:	f004 bc13 	b.w	8004dbe <panic_leds>
 8000598:	20000000 	.word	0x20000000

0800059c <Default_Handler60>:
void Default_Handler60(void) { Default_HandlerCode = 60; panic_leds(5); }
 800059c:	4b02      	ldr	r3, [pc, #8]	; (80005a8 <Default_Handler60+0xc>)
 800059e:	223c      	movs	r2, #60	; 0x3c
 80005a0:	2005      	movs	r0, #5
 80005a2:	601a      	str	r2, [r3, #0]
 80005a4:	f004 bc0b 	b.w	8004dbe <panic_leds>
 80005a8:	20000000 	.word	0x20000000

080005ac <Default_Handler61>:
void Default_Handler61(void) { Default_HandlerCode = 61; panic_leds(5); }
 80005ac:	4b02      	ldr	r3, [pc, #8]	; (80005b8 <Default_Handler61+0xc>)
 80005ae:	223d      	movs	r2, #61	; 0x3d
 80005b0:	2005      	movs	r0, #5
 80005b2:	601a      	str	r2, [r3, #0]
 80005b4:	f004 bc03 	b.w	8004dbe <panic_leds>
 80005b8:	20000000 	.word	0x20000000

080005bc <Default_Handler62>:
void Default_Handler62(void) { Default_HandlerCode = 62; panic_leds(5); }
 80005bc:	4b02      	ldr	r3, [pc, #8]	; (80005c8 <Default_Handler62+0xc>)
 80005be:	223e      	movs	r2, #62	; 0x3e
 80005c0:	2005      	movs	r0, #5
 80005c2:	601a      	str	r2, [r3, #0]
 80005c4:	f004 bbfb 	b.w	8004dbe <panic_leds>
 80005c8:	20000000 	.word	0x20000000

080005cc <Default_Handler63>:
void Default_Handler63(void) { Default_HandlerCode = 63; panic_leds(5); }
 80005cc:	4b02      	ldr	r3, [pc, #8]	; (80005d8 <Default_Handler63+0xc>)
 80005ce:	223f      	movs	r2, #63	; 0x3f
 80005d0:	2005      	movs	r0, #5
 80005d2:	601a      	str	r2, [r3, #0]
 80005d4:	f004 bbf3 	b.w	8004dbe <panic_leds>
 80005d8:	20000000 	.word	0x20000000

080005dc <Default_Handler64>:
void Default_Handler64(void) { Default_HandlerCode = 64; panic_leds(5); }
 80005dc:	4b02      	ldr	r3, [pc, #8]	; (80005e8 <Default_Handler64+0xc>)
 80005de:	2240      	movs	r2, #64	; 0x40
 80005e0:	2005      	movs	r0, #5
 80005e2:	601a      	str	r2, [r3, #0]
 80005e4:	f004 bbeb 	b.w	8004dbe <panic_leds>
 80005e8:	20000000 	.word	0x20000000

080005ec <Default_Handler65>:
void Default_Handler65(void) { Default_HandlerCode = 65; panic_leds(5); }
 80005ec:	4b02      	ldr	r3, [pc, #8]	; (80005f8 <Default_Handler65+0xc>)
 80005ee:	2241      	movs	r2, #65	; 0x41
 80005f0:	2005      	movs	r0, #5
 80005f2:	601a      	str	r2, [r3, #0]
 80005f4:	f004 bbe3 	b.w	8004dbe <panic_leds>
 80005f8:	20000000 	.word	0x20000000

080005fc <Default_Handler66>:
void Default_Handler66(void) { Default_HandlerCode = 66; panic_leds(5); }
 80005fc:	4b02      	ldr	r3, [pc, #8]	; (8000608 <Default_Handler66+0xc>)
 80005fe:	2242      	movs	r2, #66	; 0x42
 8000600:	2005      	movs	r0, #5
 8000602:	601a      	str	r2, [r3, #0]
 8000604:	f004 bbdb 	b.w	8004dbe <panic_leds>
 8000608:	20000000 	.word	0x20000000

0800060c <Default_Handler67>:
void Default_Handler67(void) { Default_HandlerCode = 67; panic_leds(5); }
 800060c:	4b02      	ldr	r3, [pc, #8]	; (8000618 <Default_Handler67+0xc>)
 800060e:	2243      	movs	r2, #67	; 0x43
 8000610:	2005      	movs	r0, #5
 8000612:	601a      	str	r2, [r3, #0]
 8000614:	f004 bbd3 	b.w	8004dbe <panic_leds>
 8000618:	20000000 	.word	0x20000000

0800061c <Default_Handler68>:
void Default_Handler68(void) { Default_HandlerCode = 68; panic_leds(5); }
 800061c:	4b02      	ldr	r3, [pc, #8]	; (8000628 <Default_Handler68+0xc>)
 800061e:	2244      	movs	r2, #68	; 0x44
 8000620:	2005      	movs	r0, #5
 8000622:	601a      	str	r2, [r3, #0]
 8000624:	f004 bbcb 	b.w	8004dbe <panic_leds>
 8000628:	20000000 	.word	0x20000000

0800062c <Default_Handler69>:
void Default_Handler69(void) { Default_HandlerCode = 69; panic_leds(5); }
 800062c:	4b02      	ldr	r3, [pc, #8]	; (8000638 <Default_Handler69+0xc>)
 800062e:	2245      	movs	r2, #69	; 0x45
 8000630:	2005      	movs	r0, #5
 8000632:	601a      	str	r2, [r3, #0]
 8000634:	f004 bbc3 	b.w	8004dbe <panic_leds>
 8000638:	20000000 	.word	0x20000000

0800063c <Default_Handler70>:
void Default_Handler70(void) { Default_HandlerCode = 70; panic_leds(5); }
 800063c:	4b02      	ldr	r3, [pc, #8]	; (8000648 <Default_Handler70+0xc>)
 800063e:	2246      	movs	r2, #70	; 0x46
 8000640:	2005      	movs	r0, #5
 8000642:	601a      	str	r2, [r3, #0]
 8000644:	f004 bbbb 	b.w	8004dbe <panic_leds>
 8000648:	20000000 	.word	0x20000000

0800064c <Default_Handler71>:
void Default_Handler71(void) { Default_HandlerCode = 71; panic_leds(5); }
 800064c:	4b02      	ldr	r3, [pc, #8]	; (8000658 <Default_Handler71+0xc>)
 800064e:	2247      	movs	r2, #71	; 0x47
 8000650:	2005      	movs	r0, #5
 8000652:	601a      	str	r2, [r3, #0]
 8000654:	f004 bbb3 	b.w	8004dbe <panic_leds>
 8000658:	20000000 	.word	0x20000000

0800065c <Default_Handler72>:
void Default_Handler72(void) { Default_HandlerCode = 72; panic_leds(5); }
 800065c:	4b02      	ldr	r3, [pc, #8]	; (8000668 <Default_Handler72+0xc>)
 800065e:	2248      	movs	r2, #72	; 0x48
 8000660:	2005      	movs	r0, #5
 8000662:	601a      	str	r2, [r3, #0]
 8000664:	f004 bbab 	b.w	8004dbe <panic_leds>
 8000668:	20000000 	.word	0x20000000

0800066c <Default_Handler73>:
void Default_Handler73(void) { Default_HandlerCode = 73; panic_leds(5); }
 800066c:	4b02      	ldr	r3, [pc, #8]	; (8000678 <Default_Handler73+0xc>)
 800066e:	2249      	movs	r2, #73	; 0x49
 8000670:	2005      	movs	r0, #5
 8000672:	601a      	str	r2, [r3, #0]
 8000674:	f004 bba3 	b.w	8004dbe <panic_leds>
 8000678:	20000000 	.word	0x20000000

0800067c <Default_Handler74>:
void Default_Handler74(void) { Default_HandlerCode = 74; panic_leds(5); }
 800067c:	4b02      	ldr	r3, [pc, #8]	; (8000688 <Default_Handler74+0xc>)
 800067e:	224a      	movs	r2, #74	; 0x4a
 8000680:	2005      	movs	r0, #5
 8000682:	601a      	str	r2, [r3, #0]
 8000684:	f004 bb9b 	b.w	8004dbe <panic_leds>
 8000688:	20000000 	.word	0x20000000

0800068c <Default_Handler75>:
void Default_Handler75(void) { Default_HandlerCode = 75; panic_leds(5); }
 800068c:	4b02      	ldr	r3, [pc, #8]	; (8000698 <Default_Handler75+0xc>)
 800068e:	224b      	movs	r2, #75	; 0x4b
 8000690:	2005      	movs	r0, #5
 8000692:	601a      	str	r2, [r3, #0]
 8000694:	f004 bb93 	b.w	8004dbe <panic_leds>
 8000698:	20000000 	.word	0x20000000

0800069c <Default_Handler77>:
//void Default_Handler76(void) { Default_HandlerCode = 76; panic_leds(5); }
void Default_Handler77(void) { Default_HandlerCode = 77; panic_leds(5); }
 800069c:	4b02      	ldr	r3, [pc, #8]	; (80006a8 <Default_Handler77+0xc>)
 800069e:	224d      	movs	r2, #77	; 0x4d
 80006a0:	2005      	movs	r0, #5
 80006a2:	601a      	str	r2, [r3, #0]
 80006a4:	f004 bb8b 	b.w	8004dbe <panic_leds>
 80006a8:	20000000 	.word	0x20000000

080006ac <Default_Handler78>:
void Default_Handler78(void) { Default_HandlerCode = 78; panic_leds(5); }
 80006ac:	4b02      	ldr	r3, [pc, #8]	; (80006b8 <Default_Handler78+0xc>)
 80006ae:	224e      	movs	r2, #78	; 0x4e
 80006b0:	2005      	movs	r0, #5
 80006b2:	601a      	str	r2, [r3, #0]
 80006b4:	f004 bb83 	b.w	8004dbe <panic_leds>
 80006b8:	20000000 	.word	0x20000000

080006bc <Default_Handler79>:
void Default_Handler79(void) { Default_HandlerCode = 79; panic_leds(5); }
 80006bc:	4b02      	ldr	r3, [pc, #8]	; (80006c8 <Default_Handler79+0xc>)
 80006be:	224f      	movs	r2, #79	; 0x4f
 80006c0:	2005      	movs	r0, #5
 80006c2:	601a      	str	r2, [r3, #0]
 80006c4:	f004 bb7b 	b.w	8004dbe <panic_leds>
 80006c8:	20000000 	.word	0x20000000

080006cc <Default_Handler80>:
void Default_Handler80(void) { Default_HandlerCode = 80; panic_leds(5); }
 80006cc:	4b02      	ldr	r3, [pc, #8]	; (80006d8 <Default_Handler80+0xc>)
 80006ce:	2250      	movs	r2, #80	; 0x50
 80006d0:	2005      	movs	r0, #5
 80006d2:	601a      	str	r2, [r3, #0]
 80006d4:	f004 bb73 	b.w	8004dbe <panic_leds>
 80006d8:	20000000 	.word	0x20000000

080006dc <Default_Handler81>:
void Default_Handler81(void) { Default_HandlerCode = 81; panic_leds(5); }
 80006dc:	4b02      	ldr	r3, [pc, #8]	; (80006e8 <Default_Handler81+0xc>)
 80006de:	2251      	movs	r2, #81	; 0x51
 80006e0:	2005      	movs	r0, #5
 80006e2:	601a      	str	r2, [r3, #0]
 80006e4:	f004 bb6b 	b.w	8004dbe <panic_leds>
 80006e8:	20000000 	.word	0x20000000

080006ec <Default_Handler82>:
void Default_Handler82(void) { Default_HandlerCode = 82; panic_leds(5); }
 80006ec:	4b02      	ldr	r3, [pc, #8]	; (80006f8 <Default_Handler82+0xc>)
 80006ee:	2252      	movs	r2, #82	; 0x52
 80006f0:	2005      	movs	r0, #5
 80006f2:	601a      	str	r2, [r3, #0]
 80006f4:	f004 bb63 	b.w	8004dbe <panic_leds>
 80006f8:	20000000 	.word	0x20000000

080006fc <Default_Handler83>:
void Default_Handler83(void) { Default_HandlerCode = 83; panic_leds(5); }
 80006fc:	4b02      	ldr	r3, [pc, #8]	; (8000708 <Default_Handler83+0xc>)
 80006fe:	2253      	movs	r2, #83	; 0x53
 8000700:	2005      	movs	r0, #5
 8000702:	601a      	str	r2, [r3, #0]
 8000704:	f004 bb5b 	b.w	8004dbe <panic_leds>
 8000708:	20000000 	.word	0x20000000

0800070c <Default_Handler84>:
void Default_Handler84(void) { Default_HandlerCode = 84; panic_leds(5); }
 800070c:	4b02      	ldr	r3, [pc, #8]	; (8000718 <Default_Handler84+0xc>)
 800070e:	2254      	movs	r2, #84	; 0x54
 8000710:	2005      	movs	r0, #5
 8000712:	601a      	str	r2, [r3, #0]
 8000714:	f004 bb53 	b.w	8004dbe <panic_leds>
 8000718:	20000000 	.word	0x20000000

0800071c <Default_Handler85>:
void Default_Handler85(void) { Default_HandlerCode = 85; panic_leds(5); }
 800071c:	4b02      	ldr	r3, [pc, #8]	; (8000728 <Default_Handler85+0xc>)
 800071e:	2255      	movs	r2, #85	; 0x55
 8000720:	2005      	movs	r0, #5
 8000722:	601a      	str	r2, [r3, #0]
 8000724:	f004 bb4b 	b.w	8004dbe <panic_leds>
 8000728:	20000000 	.word	0x20000000

0800072c <Default_Handler86>:
void Default_Handler86(void) { Default_HandlerCode = 86; panic_leds(5); }
 800072c:	4b02      	ldr	r3, [pc, #8]	; (8000738 <Default_Handler86+0xc>)
 800072e:	2256      	movs	r2, #86	; 0x56
 8000730:	2005      	movs	r0, #5
 8000732:	601a      	str	r2, [r3, #0]
 8000734:	f004 bb43 	b.w	8004dbe <panic_leds>
 8000738:	20000000 	.word	0x20000000

0800073c <Default_Handler87>:
void Default_Handler87(void) { Default_HandlerCode = 87; panic_leds(5); }
 800073c:	4b02      	ldr	r3, [pc, #8]	; (8000748 <Default_Handler87+0xc>)
 800073e:	2257      	movs	r2, #87	; 0x57
 8000740:	2005      	movs	r0, #5
 8000742:	601a      	str	r2, [r3, #0]
 8000744:	f004 bb3b 	b.w	8004dbe <panic_leds>
 8000748:	20000000 	.word	0x20000000

0800074c <Default_Handler88>:
void Default_Handler88(void) { Default_HandlerCode = 88; panic_leds(5); }
 800074c:	4b02      	ldr	r3, [pc, #8]	; (8000758 <Default_Handler88+0xc>)
 800074e:	2258      	movs	r2, #88	; 0x58
 8000750:	2005      	movs	r0, #5
 8000752:	601a      	str	r2, [r3, #0]
 8000754:	f004 bb33 	b.w	8004dbe <panic_leds>
 8000758:	20000000 	.word	0x20000000

0800075c <Default_Handler89>:
void Default_Handler89(void) { Default_HandlerCode = 89; panic_leds(5); }
 800075c:	4b02      	ldr	r3, [pc, #8]	; (8000768 <Default_Handler89+0xc>)
 800075e:	2259      	movs	r2, #89	; 0x59
 8000760:	2005      	movs	r0, #5
 8000762:	601a      	str	r2, [r3, #0]
 8000764:	f004 bb2b 	b.w	8004dbe <panic_leds>
 8000768:	20000000 	.word	0x20000000

0800076c <Default_Handler90>:
void Default_Handler90(void) { Default_HandlerCode = 90; panic_leds(5); }
 800076c:	4b02      	ldr	r3, [pc, #8]	; (8000778 <Default_Handler90+0xc>)
 800076e:	225a      	movs	r2, #90	; 0x5a
 8000770:	2005      	movs	r0, #5
 8000772:	601a      	str	r2, [r3, #0]
 8000774:	f004 bb23 	b.w	8004dbe <panic_leds>
 8000778:	20000000 	.word	0x20000000

0800077c <toggle_4leds>:
Turn the LEDs on in sequence, then turn them back off 
***************************************************************/
static int lednum = 12;	// Lowest port bit numbered LED
void toggle_4leds (void)
{
	if ((GPIO_ODR(GPIOD) & (1<<lednum)) == 0)
 800077c:	4a0c      	ldr	r2, [pc, #48]	; (80007b0 <toggle_4leds+0x34>)
 800077e:	4b0d      	ldr	r3, [pc, #52]	; (80007b4 <toggle_4leds+0x38>)
/* ************************************************************
Turn the LEDs on in sequence, then turn them back off 
***************************************************************/
static int lednum = 12;	// Lowest port bit numbered LED
void toggle_4leds (void)
{
 8000780:	b510      	push	{r4, lr}
	if ((GPIO_ODR(GPIOD) & (1<<lednum)) == 0)
 8000782:	681c      	ldr	r4, [r3, #0]
 8000784:	6853      	ldr	r3, [r2, #4]
 8000786:	2101      	movs	r1, #1
 8000788:	fa11 f003 	lsls.w	r0, r1, r3
 800078c:	4220      	tst	r0, r4
 800078e:	4614      	mov	r4, r2
 8000790:	4a09      	ldr	r2, [pc, #36]	; (80007b8 <toggle_4leds+0x3c>)
 8000792:	d101      	bne.n	8000798 <toggle_4leds+0x1c>
	{ // Here, LED bit was off
		GPIO_BSRR(GPIOD) = (1<<lednum);	// Set bit
 8000794:	6010      	str	r0, [r2, #0]
 8000796:	e003      	b.n	80007a0 <toggle_4leds+0x24>
	}
	else
	{ // HEre, LED bit was on
		GPIO_BSRR(GPIOD) = (1<<(lednum+16));	// Reset bit
 8000798:	f103 0010 	add.w	r0, r3, #16
 800079c:	4081      	lsls	r1, r0
 800079e:	6011      	str	r1, [r2, #0]
	}
	lednum += 1;		// Step through all four LEDs
 80007a0:	3301      	adds	r3, #1
	if (lednum > 15) lednum = 12;
 80007a2:	2b0f      	cmp	r3, #15
	}
	else
	{ // HEre, LED bit was on
		GPIO_BSRR(GPIOD) = (1<<(lednum+16));	// Reset bit
	}
	lednum += 1;		// Step through all four LEDs
 80007a4:	6063      	str	r3, [r4, #4]
	if (lednum > 15) lednum = 12;
 80007a6:	dd02      	ble.n	80007ae <toggle_4leds+0x32>
 80007a8:	4b01      	ldr	r3, [pc, #4]	; (80007b0 <toggle_4leds+0x34>)
 80007aa:	220c      	movs	r2, #12
 80007ac:	605a      	str	r2, [r3, #4]
 80007ae:	bd10      	pop	{r4, pc}
 80007b0:	20000000 	.word	0x20000000
 80007b4:	40020c14 	.word	0x40020c14
 80007b8:	40020c18 	.word	0x40020c18

080007bc <toggle_led>:
/* ************************************************************
Turn the LEDs on in sequence, then turn them back off 
***************************************************************/
void toggle_led (int lednum)
{
	if ((GPIO_ODR(GPIOD) & (1<<lednum)) == 0)
 80007bc:	4b06      	ldr	r3, [pc, #24]	; (80007d8 <toggle_led+0x1c>)
 80007be:	2201      	movs	r2, #1
 80007c0:	681b      	ldr	r3, [r3, #0]
 80007c2:	fa12 f100 	lsls.w	r1, r2, r0
 80007c6:	4219      	tst	r1, r3
 80007c8:	4b04      	ldr	r3, [pc, #16]	; (80007dc <toggle_led+0x20>)
 80007ca:	d101      	bne.n	80007d0 <toggle_led+0x14>
	{ // Here, LED bit was off
		GPIO_BSRR(GPIOD) = (1<<lednum);	// Set bit
 80007cc:	6019      	str	r1, [r3, #0]
 80007ce:	4770      	bx	lr
	}
	else
	{ // HEre, LED bit was on
		GPIO_BSRR(GPIOD) = (1<<(lednum+16));	// Reset bit
 80007d0:	3010      	adds	r0, #16
 80007d2:	4082      	lsls	r2, r0
 80007d4:	601a      	str	r2, [r3, #0]
 80007d6:	4770      	bx	lr
 80007d8:	40020c14 	.word	0x40020c14
 80007dc:	40020c18 	.word	0x40020c18

080007e0 <initMasterController>:
// 		// str[strlen(str)] = padChar;
// 	}
// }

/* Setup & initialization functions */ 
void initMasterController () {
 80007e0:	b537      	push	{r0, r1, r2, r4, r5, lr}
	int init_ret = -4;
	/* --------------------- Begin setting things up -------------------------------------------------- */ 
		clockspecifysetup((struct CLOCKS*)&clocks);		// Get the system clock and bus clocks running
 80007e2:	482c      	ldr	r0, [pc, #176]	; (8000894 <initMasterController+0xb4>)
 80007e4:	f004 fbf4 	bl	8004fd0 <clockspecifysetup>
	/* ---------------------- Set up pins ------------------------------------------------------------- */
		/* Configure pins */
		DISCgpiopins_Config();	// Configure pins
 80007e8:	f003 feca 	bl	8004580 <DISCgpiopins_Config>
	/* ---------------------- Set usb ----------------------------------------------------------------- */
		// usb1_init();	// Initialization for USB (STM32F4_USB_CDC demo package)
		setbuf(stdout, NULL);
 80007ec:	4b2a      	ldr	r3, [pc, #168]	; (8000898 <initMasterController+0xb8>)
 80007ee:	681b      	ldr	r3, [r3, #0]
 80007f0:	2100      	movs	r1, #0
 80007f2:	6898      	ldr	r0, [r3, #8]
 80007f4:	f006 f9a8 	bl	8006b48 <setbuf>
	/* --------------------- Initialize UARTs ---------------------------------------------------- */
		bsp_uart_int_init_number(UARTGATE, 115200, 256, 256, 0x40);	// UART used for the Gateway
 80007f8:	f44f 7280 	mov.w	r2, #256	; 0x100
 80007fc:	4613      	mov	r3, r2
 80007fe:	2440      	movs	r4, #64	; 0x40
 8000800:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
 8000804:	2002      	movs	r0, #2
 8000806:	9400      	str	r4, [sp, #0]
 8000808:	f005 fa1a 	bl	8005c40 <bsp_uart_int_init_number>
		bsp_uart_int_init_number(UARTGPS, 115200, 256, 256, 0x40);	// UART used for the GPS		
 800080c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000810:	4613      	mov	r3, r2
 8000812:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
 8000816:	2003      	movs	r0, #3
 8000818:	9400      	str	r4, [sp, #0]
 800081a:	f005 fa11 	bl	8005c40 <bsp_uart_int_init_number>
		lcd_init(UARTLCD); 											// UART used for the LCD screen
 800081e:	2006      	movs	r0, #6
 8000820:	f003 fe93 	bl	800454a <lcd_init>

		lcd_clear(UARTLCD);				//	clear the LCD										
 8000824:	2006      	movs	r0, #6
 8000826:	f003 fe35 	bl	8004494 <lcd_clear>
		
		/* ---------------------- DTW sys counter -------------------------------------------------------- */
		// Use DTW_CYCCNT counter (driven by sysclk) for polling type timing 
		// CYCCNT counter is in the Cortex-M-series core.  See the following for details 
		// http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html 
		*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
 800082a:	4b1c      	ldr	r3, [pc, #112]	; (800089c <initMasterController+0xbc>)
		*(volatile unsigned int*)0xE0001000 |= 0x1;	// Enable DTW_CYCCNT (Data Watch cycle counter)

	/* Setup STDOUT, STDIN (a shameful sequence until we sort out 'newlib' and 'fopen'.)  The following 'open' sets up 
	   the USART/UART that will be used as STDOUT_FILENO, and STDIN_FILENO.  Don't call 'open' again!  */
fd = open("tty2", 0,0); // This sets up the uart control block pointer versus file descriptor ('fd')
 800082c:	481c      	ldr	r0, [pc, #112]	; (80008a0 <initMasterController+0xc0>)
		
		/* ---------------------- DTW sys counter -------------------------------------------------------- */
		// Use DTW_CYCCNT counter (driven by sysclk) for polling type timing 
		// CYCCNT counter is in the Cortex-M-series core.  See the following for details 
		// http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html 
		*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
 800082e:	681a      	ldr	r2, [r3, #0]
 8000830:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000834:	601a      	str	r2, [r3, #0]
		*(volatile unsigned int*)0xE0001000 |= 0x1;	// Enable DTW_CYCCNT (Data Watch cycle counter)
 8000836:	4b1b      	ldr	r3, [pc, #108]	; (80008a4 <initMasterController+0xc4>)
 8000838:	681a      	ldr	r2, [r3, #0]

	/* Setup STDOUT, STDIN (a shameful sequence until we sort out 'newlib' and 'fopen'.)  The following 'open' sets up 
	   the USART/UART that will be used as STDOUT_FILENO, and STDIN_FILENO.  Don't call 'open' again!  */
fd = open("tty2", 0,0); // This sets up the uart control block pointer versus file descriptor ('fd')
 800083a:	2100      	movs	r1, #0
		/* ---------------------- DTW sys counter -------------------------------------------------------- */
		// Use DTW_CYCCNT counter (driven by sysclk) for polling type timing 
		// CYCCNT counter is in the Cortex-M-series core.  See the following for details 
		// http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html 
		*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
		*(volatile unsigned int*)0xE0001000 |= 0x1;	// Enable DTW_CYCCNT (Data Watch cycle counter)
 800083c:	f042 0201 	orr.w	r2, r2, #1
 8000840:	601a      	str	r2, [r3, #0]

	/* Setup STDOUT, STDIN (a shameful sequence until we sort out 'newlib' and 'fopen'.)  The following 'open' sets up 
	   the USART/UART that will be used as STDOUT_FILENO, and STDIN_FILENO.  Don't call 'open' again!  */
fd = open("tty2", 0,0); // This sets up the uart control block pointer versus file descriptor ('fd')
 8000842:	460a      	mov	r2, r1
 8000844:	f007 ff2e 	bl	80086a4 <open>
 8000848:	4b17      	ldr	r3, [pc, #92]	; (80008a8 <initMasterController+0xc8>)
//#define FLASHCOUNT 25000000;	// LED flash

int count = 0;
 800084a:	2200      	movs	r2, #0
		*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
		*(volatile unsigned int*)0xE0001000 |= 0x1;	// Enable DTW_CYCCNT (Data Watch cycle counter)

	/* Setup STDOUT, STDIN (a shameful sequence until we sort out 'newlib' and 'fopen'.)  The following 'open' sets up 
	   the USART/UART that will be used as STDOUT_FILENO, and STDIN_FILENO.  Don't call 'open' again!  */
fd = open("tty2", 0,0); // This sets up the uart control block pointer versus file descriptor ('fd')
 800084c:	6018      	str	r0, [r3, #0]
//#define FLASHCOUNT 25000000;	// LED flash

int count = 0;
while (1 == 1) 
{if (((int)(*(volatile unsigned int *)0xE0001004 - t_led)) > 0) // Has the time expired?
 800084e:	4c17      	ldr	r4, [pc, #92]	; (80008ac <initMasterController+0xcc>)
 8000850:	6823      	ldr	r3, [r4, #0]
 8000852:	4917      	ldr	r1, [pc, #92]	; (80008b0 <initMasterController+0xd0>)
 8000854:	6809      	ldr	r1, [r1, #0]
 8000856:	1ac9      	subs	r1, r1, r3
 8000858:	2900      	cmp	r1, #0
 800085a:	ddfa      	ble.n	8000852 <initMasterController+0x72>
		{ // Here, yes.
			sprintf(vv, "Test Count: %5d", count++);
 800085c:	4915      	ldr	r1, [pc, #84]	; (80008b4 <initMasterController+0xd4>)
 800085e:	4816      	ldr	r0, [pc, #88]	; (80008b8 <initMasterController+0xd8>)
 8000860:	1c55      	adds	r5, r2, #1
 8000862:	f006 faad 	bl	8006dc0 <sprintf>
			lcd_printToLine(UARTLCD, 0, vv);
 8000866:	2006      	movs	r0, #6
 8000868:	2100      	movs	r1, #0
 800086a:	4a13      	ldr	r2, [pc, #76]	; (80008b8 <initMasterController+0xd8>)
 800086c:	f003 fe62 	bl	8004534 <lcd_printToLine>
			xprintf(UARTGPS, "3 %s\n\r", vv);
 8000870:	4a11      	ldr	r2, [pc, #68]	; (80008b8 <initMasterController+0xd8>)
 8000872:	4912      	ldr	r1, [pc, #72]	; (80008bc <initMasterController+0xdc>)
 8000874:	2003      	movs	r0, #3
 8000876:	f005 fa3d 	bl	8005cf4 <xprintf>
			printf("2 %s\n\r", vv);
 800087a:	490f      	ldr	r1, [pc, #60]	; (80008b8 <initMasterController+0xd8>)
 800087c:	4810      	ldr	r0, [pc, #64]	; (80008c0 <initMasterController+0xe0>)
 800087e:	f006 f947 	bl	8006b10 <printf>
			toggle_4leds(); 	// Advance some LED pattern
 8000882:	f7ff ff7b 	bl	800077c <toggle_4leds>
			t_led += 25000000; //FLASHCOUNT; 	// Set next toggle time
 8000886:	6822      	ldr	r2, [r4, #0]
 8000888:	4b0e      	ldr	r3, [pc, #56]	; (80008c4 <initMasterController+0xe4>)
 800088a:	18d3      	adds	r3, r2, r3
 800088c:	6023      	str	r3, [r4, #0]

int count = 0;
while (1 == 1) 
{if (((int)(*(volatile unsigned int *)0xE0001004 - t_led)) > 0) // Has the time expired?
		{ // Here, yes.
			sprintf(vv, "Test Count: %5d", count++);
 800088e:	462a      	mov	r2, r5
 8000890:	e7dd      	b.n	800084e <initMasterController+0x6e>
 8000892:	bf00      	nop
 8000894:	0800ff20 	.word	0x0800ff20
 8000898:	2000027c 	.word	0x2000027c
 800089c:	e000edfc 	.word	0xe000edfc
 80008a0:	08010388 	.word	0x08010388
 80008a4:	e0001000 	.word	0xe0001000
 80008a8:	20001a04 	.word	0x20001a04
 80008ac:	200019e4 	.word	0x200019e4
 80008b0:	e0001004 	.word	0xe0001004
 80008b4:	0801038d 	.word	0x0801038d
 80008b8:	20001a08 	.word	0x20001a08
 80008bc:	0801039d 	.word	0x0801039d
 80008c0:	080103a4 	.word	0x080103a4
 80008c4:	017d7840 	.word	0x017d7840

080008c8 <ledHeartbeat>:
}

// main loop functions
	/* Flash the red LED to amuse the hapless Op or signal the wizard programmer that the loop is running. */
	void ledHeartbeat () {
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_led)) > 0) // Has the time expired?
 80008c8:	4b06      	ldr	r3, [pc, #24]	; (80008e4 <ledHeartbeat+0x1c>)
 80008ca:	4a07      	ldr	r2, [pc, #28]	; (80008e8 <ledHeartbeat+0x20>)
 80008cc:	681b      	ldr	r3, [r3, #0]
 80008ce:	6811      	ldr	r1, [r2, #0]
 80008d0:	1a5b      	subs	r3, r3, r1
 80008d2:	2b00      	cmp	r3, #0
 80008d4:	dd04      	ble.n	80008e0 <ledHeartbeat+0x18>
		{ // Here, yes.
			t_led += FLASHCOUNT; 	// Set next toggle time
 80008d6:	4b05      	ldr	r3, [pc, #20]	; (80008ec <ledHeartbeat+0x24>)

			toggle_led(14); 	// Advance some LED pattern
 80008d8:	200e      	movs	r0, #14
// main loop functions
	/* Flash the red LED to amuse the hapless Op or signal the wizard programmer that the loop is running. */
	void ledHeartbeat () {
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_led)) > 0) // Has the time expired?
		{ // Here, yes.
			t_led += FLASHCOUNT; 	// Set next toggle time
 80008da:	18cb      	adds	r3, r1, r3
 80008dc:	6013      	str	r3, [r2, #0]

			toggle_led(14); 	// Advance some LED pattern
 80008de:	e76d      	b.n	80007bc <toggle_led>
 80008e0:	4770      	bx	lr
 80008e2:	bf00      	nop
 80008e4:	e0001004 	.word	0xe0001004
 80008e8:	200019e4 	.word	0x200019e4
 80008ec:	0501bd00 	.word	0x0501bd00

080008f0 <timeKeeper>:
		}
	}

	/* function to find the 64th second beats */
	void timeKeeper () {
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_timeKeeper)) > 0) // Has the time expired?
 80008f0:	4b11      	ldr	r3, [pc, #68]	; (8000938 <timeKeeper+0x48>)
 80008f2:	4a12      	ldr	r2, [pc, #72]	; (800093c <timeKeeper+0x4c>)
 80008f4:	681b      	ldr	r3, [r3, #0]
 80008f6:	6811      	ldr	r1, [r2, #0]
 80008f8:	1a5b      	subs	r3, r3, r1
 80008fa:	2b00      	cmp	r3, #0
 80008fc:	dd1a      	ble.n	8000934 <timeKeeper+0x44>
		{ // Here, yes.
			t_timeKeeper += SIXTYFOURTH; 	// Set next toggle time
 80008fe:	4b10      	ldr	r3, [pc, #64]	; (8000940 <timeKeeper+0x50>)
 8000900:	18cb      	adds	r3, r1, r3
 8000902:	6013      	str	r3, [r2, #0]

			count64++;
 8000904:	4b0f      	ldr	r3, [pc, #60]	; (8000944 <timeKeeper+0x54>)
 8000906:	f893 2510 	ldrb.w	r2, [r3, #1296]	; 0x510
 800090a:	3201      	adds	r2, #1
 800090c:	b2d2      	uxtb	r2, r2

			if(count64 == 64) {
 800090e:	2a40      	cmp	r2, #64	; 0x40
	void timeKeeper () {
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_timeKeeper)) > 0) // Has the time expired?
		{ // Here, yes.
			t_timeKeeper += SIXTYFOURTH; 	// Set next toggle time

			count64++;
 8000910:	f883 2510 	strb.w	r2, [r3, #1296]	; 0x510

			if(count64 == 64) {
 8000914:	d10b      	bne.n	800092e <timeKeeper+0x3e>
				currentTime++;
 8000916:	f8d3 2514 	ldr.w	r2, [r3, #1300]	; 0x514
 800091a:	3201      	adds	r2, #1
 800091c:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
				count64 = 0;
 8000920:	2200      	movs	r2, #0
 8000922:	f883 2510 	strb.w	r2, [r3, #1296]	; 0x510
				timerMsgFlag = 2; // send 1 sec message
 8000926:	3202      	adds	r2, #2
 8000928:	f883 2518 	strb.w	r2, [r3, #1304]	; 0x518
 800092c:	4770      	bx	lr
			} else {
				timerMsgFlag = 1; // send 1/64th sec message
 800092e:	2201      	movs	r2, #1
 8000930:	f883 2518 	strb.w	r2, [r3, #1304]	; 0x518
 8000934:	4770      	bx	lr
 8000936:	bf00      	nop
 8000938:	e0001004 	.word	0xe0001004
 800093c:	20001a8c 	.word	0x20001a8c
 8000940:	00280de8 	.word	0x00280de8
 8000944:	20000800 	.word	0x20000800

08000948 <spiInOut>:
		}
	}

	/* spi i/o */
	void spiInOut () {
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_spi)) > 0) {
 8000948:	4b0b      	ldr	r3, [pc, #44]	; (8000978 <spiInOut+0x30>)
 800094a:	6819      	ldr	r1, [r3, #0]
 800094c:	4b0b      	ldr	r3, [pc, #44]	; (800097c <spiInOut+0x34>)
 800094e:	681a      	ldr	r2, [r3, #0]
 8000950:	1a89      	subs	r1, r1, r2
 8000952:	2900      	cmp	r1, #0
			}
		}
	}

	/* spi i/o */
	void spiInOut () {
 8000954:	b510      	push	{r4, lr}
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_spi)) > 0) {
 8000956:	dd0e      	ble.n	8000976 <spiInOut+0x2e>
			t_spi += SPIPACE;
 8000958:	f502 224c 	add.w	r2, r2, #835584	; 0xcc000
 800095c:	f502 528a 	add.w	r2, r2, #4416	; 0x1140
 8000960:	601a      	str	r2, [r3, #0]

			if (spi2_busy() != 0) // Is SPI2 busy?
 8000962:	f004 facd 	bl	8004f00 <spi2_busy>
 8000966:	b130      	cbz	r0, 8000976 <spiInOut+0x2e>
			{ // Here, no.
				spi2_rw(spi_ledout, spi_swin, SPI2SIZE); // Send/rcv three bytes
 8000968:	4805      	ldr	r0, [pc, #20]	; (8000980 <spiInOut+0x38>)
 800096a:	4906      	ldr	r1, [pc, #24]	; (8000984 <spiInOut+0x3c>)
 800096c:	2203      	movs	r2, #3
			}
		}
	}
 800096e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_spi)) > 0) {
			t_spi += SPIPACE;

			if (spi2_busy() != 0) // Is SPI2 busy?
			{ // Here, no.
				spi2_rw(spi_ledout, spi_swin, SPI2SIZE); // Send/rcv three bytes
 8000972:	f004 bacd 	b.w	8004f10 <spi2_rw>
 8000976:	bd10      	pop	{r4, pc}
 8000978:	e0001004 	.word	0xe0001004
 800097c:	200019c8 	.word	0x200019c8
 8000980:	20000008 	.word	0x20000008
 8000984:	200019cc 	.word	0x200019cc

08000988 <lcdOut>:
		}
	}

	/* LCD output routine */
	void lcdOut () {
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_lcd)) > 0) {
 8000988:	4b1b      	ldr	r3, [pc, #108]	; (80009f8 <lcdOut+0x70>)
			}
		}
	}

	/* LCD output routine */
	void lcdOut () {
 800098a:	b513      	push	{r0, r1, r4, lr}
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_lcd)) > 0) {
 800098c:	6819      	ldr	r1, [r3, #0]
 800098e:	4b1b      	ldr	r3, [pc, #108]	; (80009fc <lcdOut+0x74>)
 8000990:	681a      	ldr	r2, [r3, #0]
 8000992:	1a89      	subs	r1, r1, r2
 8000994:	2900      	cmp	r1, #0
 8000996:	dd2d      	ble.n	80009f4 <lcdOut+0x6c>
			t_lcd += LCDPACE;

			snprintf(lcdLine0, 20, "%16s%4d", "Current State:", currentState);
 8000998:	4c19      	ldr	r4, [pc, #100]	; (8000a00 <lcdOut+0x78>)
 800099a:	481a      	ldr	r0, [pc, #104]	; (8000a04 <lcdOut+0x7c>)
	}

	/* LCD output routine */
	void lcdOut () {
		if (((int)(*(volatile unsigned int *)0xE0001004 - t_lcd)) > 0) {
			t_lcd += LCDPACE;
 800099c:	f102 7280 	add.w	r2, r2, #16777216	; 0x1000000
 80009a0:	f502 42b2 	add.w	r2, r2, #22784	; 0x5900
 80009a4:	601a      	str	r2, [r3, #0]

			snprintf(lcdLine0, 20, "%16s%4d", "Current State:", currentState);
 80009a6:	f8d4 351c 	ldr.w	r3, [r4, #1308]	; 0x51c
 80009aa:	4a17      	ldr	r2, [pc, #92]	; (8000a08 <lcdOut+0x80>)
 80009ac:	9300      	str	r3, [sp, #0]
 80009ae:	2114      	movs	r1, #20
 80009b0:	4b16      	ldr	r3, [pc, #88]	; (8000a0c <lcdOut+0x84>)
 80009b2:	f006 f9ad 	bl	8006d10 <snprintf>
			snprintf(lcdLine1, 20, "outputTorque: %20f\0", outputTorque);
 80009b6:	f8d4 0520 	ldr.w	r0, [r4, #1312]	; 0x520
 80009ba:	f005 fbf5 	bl	80061a8 <__aeabi_f2d>
 80009be:	4a14      	ldr	r2, [pc, #80]	; (8000a10 <lcdOut+0x88>)
 80009c0:	e9cd 0100 	strd	r0, r1, [sp]
 80009c4:	2114      	movs	r1, #20
 80009c6:	4813      	ldr	r0, [pc, #76]	; (8000a14 <lcdOut+0x8c>)
 80009c8:	f006 f9a2 	bl	8006d10 <snprintf>
			snprintf(lcdLine2, 20, "Time: %20d\0", currentTime);
 80009cc:	2114      	movs	r1, #20
 80009ce:	f8d4 3514 	ldr.w	r3, [r4, #1300]	; 0x514
 80009d2:	4a11      	ldr	r2, [pc, #68]	; (8000a18 <lcdOut+0x90>)
 80009d4:	4811      	ldr	r0, [pc, #68]	; (8000a1c <lcdOut+0x94>)
 80009d6:	f006 f99b 	bl	8006d10 <snprintf>
			// padString(' ', lcdLine1, 20);
			// padString(' ', lcdLine2, 20);
			// padString(' ', lcdLine3, 20);

			// display a char on the lcd
			lcd_printToLine(UARTLCD, 0, lcdLine0);
 80009da:	2006      	movs	r0, #6
 80009dc:	2100      	movs	r1, #0
 80009de:	4a09      	ldr	r2, [pc, #36]	; (8000a04 <lcdOut+0x7c>)
 80009e0:	f003 fda8 	bl	8004534 <lcd_printToLine>
			// lcd_printToLine(UARTLCD, 1, lcdLine1);
			lcd_printToLine(UARTLCD, 2, lcdLine2);
 80009e4:	4a0d      	ldr	r2, [pc, #52]	; (8000a1c <lcdOut+0x94>)
 80009e6:	2006      	movs	r0, #6
 80009e8:	2102      	movs	r1, #2
			// lcd_printToLine(UARTLCD, 3, lcdLine3);
		}
	}
 80009ea:	b002      	add	sp, #8
 80009ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			// padString(' ', lcdLine3, 20);

			// display a char on the lcd
			lcd_printToLine(UARTLCD, 0, lcdLine0);
			// lcd_printToLine(UARTLCD, 1, lcdLine1);
			lcd_printToLine(UARTLCD, 2, lcdLine2);
 80009f0:	f003 bda0 	b.w	8004534 <lcd_printToLine>
			// lcd_printToLine(UARTLCD, 3, lcdLine3);
		}
	}
 80009f4:	b002      	add	sp, #8
 80009f6:	bd10      	pop	{r4, pc}
 80009f8:	e0001004 	.word	0xe0001004
 80009fc:	20001a88 	.word	0x20001a88
 8000a00:	20000800 	.word	0x20000800
 8000a04:	200019ec 	.word	0x200019ec
 8000a08:	080103ab 	.word	0x080103ab
 8000a0c:	080103b3 	.word	0x080103b3
 8000a10:	0800ff34 	.word	0x0800ff34
 8000a14:	20001a90 	.word	0x20001a90
 8000a18:	0800ff48 	.word	0x0800ff48
 8000a1c:	200019cf 	.word	0x200019cf

08000a20 <stateZero>:

	void stateZero () {
		// TODO: check for conditions that progress the state
		if (currentTime > 60) {
 8000a20:	4b04      	ldr	r3, [pc, #16]	; (8000a34 <stateZero+0x14>)
 8000a22:	f8d3 2514 	ldr.w	r2, [r3, #1300]	; 0x514
 8000a26:	2a3c      	cmp	r2, #60	; 0x3c
 8000a28:	d902      	bls.n	8000a30 <stateZero+0x10>
			nextState = 1;
 8000a2a:	2201      	movs	r2, #1
 8000a2c:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
 8000a30:	4770      	bx	lr
 8000a32:	bf00      	nop
 8000a34:	20000800 	.word	0x20000800

08000a38 <stateOne>:
		}
	}

	void stateOne () {

	}
 8000a38:	4770      	bx	lr

08000a3a <stateMachine>:

	/* State Machine */
	void stateMachine () {
		currentState = nextState;
 8000a3a:	4a04      	ldr	r2, [pc, #16]	; (8000a4c <stateMachine+0x12>)
 8000a3c:	f8d2 3524 	ldr.w	r3, [r2, #1316]	; 0x524
 8000a40:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c

		switch(currentState) {
 8000a44:	b903      	cbnz	r3, 8000a48 <stateMachine+0xe>
			case 0:
				stateZero();
 8000a46:	e7eb      	b.n	8000a20 <stateZero>
 8000a48:	4770      	bx	lr
 8000a4a:	bf00      	nop
 8000a4c:	20000800 	.word	0x20000800

08000a50 <desiredTensionSpeed>:
				break;
		}
	}

	void desiredTensionSpeed () {
		desiredSpeed = 1;
 8000a50:	4b04      	ldr	r3, [pc, #16]	; (8000a64 <desiredTensionSpeed+0x14>)
 8000a52:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8000a56:	f8c3 2528 	str.w	r2, [r3, #1320]	; 0x528
		desiredTension = 2;
 8000a5a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8000a5e:	f8c3 252c 	str.w	r2, [r3, #1324]	; 0x52c
	}
 8000a62:	4770      	bx	lr
 8000a64:	20000800 	.word	0x20000800

08000a68 <controlLaw>:

	void controlLaw () {
 8000a68:	b510      	push	{r4, lr}
		if (currentState == 0) {
 8000a6a:	4c08      	ldr	r4, [pc, #32]	; (8000a8c <controlLaw+0x24>)
 8000a6c:	f8d4 351c 	ldr.w	r3, [r4, #1308]	; 0x51c
 8000a70:	b913      	cbnz	r3, 8000a78 <controlLaw+0x10>
			outputTorque = 0.5 * desiredSpeed;
 8000a72:	f8d4 0528 	ldr.w	r0, [r4, #1320]	; 0x528
 8000a76:	e001      	b.n	8000a7c <controlLaw+0x14>
		} else {
			outputTorque = 0.5 * desiredTension;
 8000a78:	f8d4 052c 	ldr.w	r0, [r4, #1324]	; 0x52c
 8000a7c:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8000a80:	f005 fbe6 	bl	8006250 <__aeabi_fmul>
 8000a84:	f8c4 0520 	str.w	r0, [r4, #1312]	; 0x520
 8000a88:	bd10      	pop	{r4, pc}
 8000a8a:	bf00      	nop
 8000a8c:	20000800 	.word	0x20000800

08000a90 <usbInput>:
	// messages here are from the pc. We need to parse and forward to the CANbus
	void usbInput () {
		int tmp;
		int temp;

		temp=USB_PC_get_msg_mode(STDIN_FILENO, &gatewayToPC, &canrcvbuf);	// Check if msg is ready
 8000a90:	490c      	ldr	r1, [pc, #48]	; (8000ac4 <usbInput+0x34>)
		}
	}

	/* ================ PC --> CAN ================================================================= */
	// messages here are from the pc. We need to parse and forward to the CANbus
	void usbInput () {
 8000a92:	b510      	push	{r4, lr}
		int tmp;
		int temp;

		temp=USB_PC_get_msg_mode(STDIN_FILENO, &gatewayToPC, &canrcvbuf);	// Check if msg is ready
 8000a94:	2000      	movs	r0, #0
 8000a96:	f101 0260 	add.w	r2, r1, #96	; 0x60
 8000a9a:	f003 fc27 	bl	80042ec <USB_PC_get_msg_mode>
		if (temp != 0)	// Do we have completion of a msg?
 8000a9e:	b178      	cbz	r0, 8000ac0 <usbInput+0x30>
		{ // Here, yes.  We have a msg, but it might not be valid.
			if ( temp == 1 ) // Was valid?
 8000aa0:	2801      	cmp	r0, #1
 8000aa2:	d109      	bne.n	8000ab8 <usbInput+0x28>
				{ // Here, msg is OK msg from the PC

					// TODO: filter message id's that require the MC to do something

					// Take the message and send it over CAN
					tmp = CAN_gateway_send(&canrcvbuf);	// Add to xmit buffer (if OK)
 8000aa4:	4808      	ldr	r0, [pc, #32]	; (8000ac8 <usbInput+0x38>)
 8000aa6:	f004 f9d3 	bl	8004e50 <CAN_gateway_send>
					Errors_CAN_gateway_send(tmp);		// Count any error returns					
 8000aaa:	f000 f963 	bl	8000d74 <Errors_CAN_gateway_send>
					PC_msg_initg(&gatewayToPC);	// Initialize struct for next msg from PC to gateway
 8000aae:	4805      	ldr	r0, [pc, #20]	; (8000ac4 <usbInput+0x34>)
			else
			{ // Something wrong with the msg.  Count the various types of error returns from 'USB_PC_msg_getASCII'
				Errors_USB_PC_get_msg_mode(temp);
			} // Note: 'pctogateway' gets re-intialized in 'PC_msg_initg' when there are errors.
		}
	}
 8000ab0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
					// TODO: filter message id's that require the MC to do something

					// Take the message and send it over CAN
					tmp = CAN_gateway_send(&canrcvbuf);	// Add to xmit buffer (if OK)
					Errors_CAN_gateway_send(tmp);		// Count any error returns					
					PC_msg_initg(&gatewayToPC);	// Initialize struct for next msg from PC to gateway
 8000ab4:	f003 b9a1 	b.w	8003dfa <PC_msg_initg>
			else
			{ // Something wrong with the msg.  Count the various types of error returns from 'USB_PC_msg_getASCII'
				Errors_USB_PC_get_msg_mode(temp);
			} // Note: 'pctogateway' gets re-intialized in 'PC_msg_initg' when there are errors.
		}
	}
 8000ab8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
					PC_msg_initg(&gatewayToPC);	// Initialize struct for next msg from PC to gateway
				}
			}
			else
			{ // Something wrong with the msg.  Count the various types of error returns from 'USB_PC_msg_getASCII'
				Errors_USB_PC_get_msg_mode(temp);
 8000abc:	f000 b94a 	b.w	8000d54 <Errors_USB_PC_get_msg_mode>
 8000ac0:	bd10      	pop	{r4, pc}
 8000ac2:	bf00      	nop
 8000ac4:	20000d30 	.word	0x20000d30
 8000ac8:	20000d90 	.word	0x20000d90

08000acc <canInput>:
		}
	}

	/* ================= CAN --> PC ================================================================= */
	// messages here are from the CANbus. We need to parse and forward to the PC
	void canInput () {
 8000acc:	b510      	push	{r4, lr}
		while ( (pfifo1 = canrcvtim_get_ldr()) != 0)	// Did we receive a HIGH PRIORITY CAN BUS msg?
 8000ace:	e002      	b.n	8000ad6 <canInput+0xa>
		{ // Here yes.  Retrieve it from the CAN buffer and save it in our vast mainline storage buffer ;)
			canbuf_add(&pfifo1->R);	// Add msg to buffer
 8000ad0:	3008      	adds	r0, #8
 8000ad2:	f7ff fb5e 	bl	8000192 <canbuf_add>
	}

	/* ================= CAN --> PC ================================================================= */
	// messages here are from the CANbus. We need to parse and forward to the PC
	void canInput () {
		while ( (pfifo1 = canrcvtim_get_ldr()) != 0)	// Did we receive a HIGH PRIORITY CAN BUS msg?
 8000ad6:	f003 ffbf 	bl	8004a58 <canrcvtim_get_ldr>
 8000ada:	4c07      	ldr	r4, [pc, #28]	; (8000af8 <canInput+0x2c>)
 8000adc:	f8c4 05a0 	str.w	r0, [r4, #1440]	; 0x5a0
 8000ae0:	2800      	cmp	r0, #0
 8000ae2:	d1f5      	bne.n	8000ad0 <canInput+0x4>
 8000ae4:	e001      	b.n	8000aea <canInput+0x1e>
			// TODO: filter message id's that require the MC to do something
		}

		while ( (pfifo0 = canrcv_get_ldr()) != 0)		// Did we receive a LESS-THAN-HIGH-PRIORITY CAN BUS msg?
		{ // Here yes.  Retrieve it from the CAN buffer and save it in our vast mainline storage buffer.
			canbuf_add(pfifo0);	// Add msg to buffer
 8000ae6:	f7ff fb54 	bl	8000192 <canbuf_add>
			canbuf_add(&pfifo1->R);	// Add msg to buffer

			// TODO: filter message id's that require the MC to do something
		}

		while ( (pfifo0 = canrcv_get_ldr()) != 0)		// Did we receive a LESS-THAN-HIGH-PRIORITY CAN BUS msg?
 8000aea:	f003 ff9f 	bl	8004a2c <canrcv_get_ldr>
 8000aee:	f8c4 05a4 	str.w	r0, [r4, #1444]	; 0x5a4
 8000af2:	2800      	cmp	r0, #0
 8000af4:	d1f7      	bne.n	8000ae6 <canInput+0x1a>
		{ // Here yes.  Retrieve it from the CAN buffer and save it in our vast mainline storage buffer.
			canbuf_add(pfifo0);	// Add msg to buffer

			// TODO: filter message id's that require the MC to do something
		}
	}
 8000af6:	bd10      	pop	{r4, pc}
 8000af8:	20000800 	.word	0x20000800

08000afc <usbOutput>:

	void usbOutput () {
 8000afc:	b510      	push	{r4, lr}
		/* Send buffered msgs to PC */
		while (canbufidxi != canbufidxm)	// Set up all the buffered msgs until we are caught up.				
 8000afe:	e014      	b.n	8000b2a <usbOutput+0x2e>
		{ // Here, yes.  Set up a buffered msg from the CAN bus to go to the PC.
			pctogateway.cmprs.seq = canmsgct[canbufidxm];		// Add sequence number (for PC checking for missing msgs)
 8000b00:	eb04 0283 	add.w	r2, r4, r3, lsl #2
			USB_toPC_msg_mode(STDOUT_FILENO, &pctogateway, &canbuf[canbufidxm]); 	// Send to PC via STDOUT
 8000b04:	f504 61b5 	add.w	r1, r4, #1448	; 0x5a8

	void usbOutput () {
		/* Send buffered msgs to PC */
		while (canbufidxi != canbufidxm)	// Set up all the buffered msgs until we are caught up.				
		{ // Here, yes.  Set up a buffered msg from the CAN bus to go to the PC.
			pctogateway.cmprs.seq = canmsgct[canbufidxm];		// Add sequence number (for PC checking for missing msgs)
 8000b08:	f8d2 240c 	ldr.w	r2, [r2, #1036]	; 0x40c
 8000b0c:	f884 2606 	strb.w	r2, [r4, #1542]	; 0x606
			USB_toPC_msg_mode(STDOUT_FILENO, &pctogateway, &canbuf[canbufidxm]); 	// Send to PC via STDOUT
 8000b10:	f104 0208 	add.w	r2, r4, #8
 8000b14:	eb02 1203 	add.w	r2, r2, r3, lsl #4
 8000b18:	2001      	movs	r0, #1
 8000b1a:	f003 fc81 	bl	8004420 <USB_toPC_msg_mode>
			canbufidxm = incIdx(canbufidxm);			// Advance outgoing buffer index.
 8000b1e:	f8d4 050c 	ldr.w	r0, [r4, #1292]	; 0x50c
 8000b22:	f7ff fb31 	bl	8000188 <incIdx>
 8000b26:	f8c4 050c 	str.w	r0, [r4, #1292]	; 0x50c
		}
	}

	void usbOutput () {
		/* Send buffered msgs to PC */
		while (canbufidxi != canbufidxm)	// Set up all the buffered msgs until we are caught up.				
 8000b2a:	4c03      	ldr	r4, [pc, #12]	; (8000b38 <usbOutput+0x3c>)
 8000b2c:	f8d4 350c 	ldr.w	r3, [r4, #1292]	; 0x50c
 8000b30:	6822      	ldr	r2, [r4, #0]
 8000b32:	429a      	cmp	r2, r3
 8000b34:	d1e4      	bne.n	8000b00 <usbOutput+0x4>
		{ // Here, yes.  Set up a buffered msg from the CAN bus to go to the PC.
			pctogateway.cmprs.seq = canmsgct[canbufidxm];		// Add sequence number (for PC checking for missing msgs)
			USB_toPC_msg_mode(STDOUT_FILENO, &pctogateway, &canbuf[canbufidxm]); 	// Send to PC via STDOUT
			canbufidxm = incIdx(canbufidxm);			// Advance outgoing buffer index.
		}
	}
 8000b36:	bd10      	pop	{r4, pc}
 8000b38:	20000800 	.word	0x20000800

08000b3c <canOutput>:

	// check flags and send out appropriate messages
	void canOutput () {
 8000b3c:	b530      	push	{r4, r5, lr}
		struct CANRCVBUF can;
		int tmp;

		if (timerMsgFlag == 1) { // every 1/64 second
 8000b3e:	4c19      	ldr	r4, [pc, #100]	; (8000ba4 <canOutput+0x68>)
 8000b40:	f894 5518 	ldrb.w	r5, [r4, #1304]	; 0x518
 8000b44:	2d01      	cmp	r5, #1
			canbufidxm = incIdx(canbufidxm);			// Advance outgoing buffer index.
		}
	}

	// check flags and send out appropriate messages
	void canOutput () {
 8000b46:	b085      	sub	sp, #20
		struct CANRCVBUF can;
		int tmp;

		if (timerMsgFlag == 1) { // every 1/64 second
 8000b48:	d115      	bne.n	8000b76 <canOutput+0x3a>
			can.id       = 0x20000000; // time id
 8000b4a:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 8000b4e:	9300      	str	r3, [sp, #0]
			can.dlc      = 0x00000001;
			can.cd.us[0] = count64;
 8000b50:	f894 3510 	ldrb.w	r3, [r4, #1296]	; 0x510
		struct CANRCVBUF can;
		int tmp;

		if (timerMsgFlag == 1) { // every 1/64 second
			can.id       = 0x20000000; // time id
			can.dlc      = 0x00000001;
 8000b54:	9501      	str	r5, [sp, #4]
			can.cd.us[0] = count64;

			tmp = CAN_gateway_send(&can);
 8000b56:	4668      	mov	r0, sp
		int tmp;

		if (timerMsgFlag == 1) { // every 1/64 second
			can.id       = 0x20000000; // time id
			can.dlc      = 0x00000001;
			can.cd.us[0] = count64;
 8000b58:	f8ad 3008 	strh.w	r3, [sp, #8]

			tmp = CAN_gateway_send(&can);
 8000b5c:	f004 f978 	bl	8004e50 <CAN_gateway_send>
			canbuf_add(&can);
 8000b60:	4668      	mov	r0, sp
 8000b62:	f7ff fb16 	bl	8000192 <canbuf_add>

			can.id       = 0x21400000; // torque
 8000b66:	f04f 5305 	mov.w	r3, #557842432	; 0x21400000
 8000b6a:	9300      	str	r3, [sp, #0]
			can.dlc      = 0x00000002;
 8000b6c:	2302      	movs	r3, #2
 8000b6e:	9301      	str	r3, [sp, #4]
			can.cd.us[0] = 0x0001;
 8000b70:	f8ad 5008 	strh.w	r5, [sp, #8]
 8000b74:	e00a      	b.n	8000b8c <canOutput+0x50>

			tmp = CAN_gateway_send(&can);
			canbuf_add(&can);

			timerMsgFlag = 0;
		} else if (timerMsgFlag == 2) { // every second
 8000b76:	2d02      	cmp	r5, #2
 8000b78:	d111      	bne.n	8000b9e <canOutput+0x62>
			can.id       = 0x20000000;
 8000b7a:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 8000b7e:	9300      	str	r3, [sp, #0]
			can.dlc      = 0x00000004;
 8000b80:	2304      	movs	r3, #4
 8000b82:	9301      	str	r3, [sp, #4]
			can.cd.us[0] = currentTime;
 8000b84:	f8b4 3514 	ldrh.w	r3, [r4, #1300]	; 0x514
 8000b88:	f8ad 3008 	strh.w	r3, [sp, #8]

			tmp = CAN_gateway_send(&can);
 8000b8c:	4668      	mov	r0, sp
 8000b8e:	f004 f95f 	bl	8004e50 <CAN_gateway_send>
			canbuf_add(&can);
 8000b92:	4668      	mov	r0, sp
 8000b94:	f7ff fafd 	bl	8000192 <canbuf_add>

			timerMsgFlag = 0;
 8000b98:	2300      	movs	r3, #0
 8000b9a:	f884 3518 	strb.w	r3, [r4, #1304]	; 0x518
		}
	}
 8000b9e:	b005      	add	sp, #20
 8000ba0:	bd30      	pop	{r4, r5, pc}
 8000ba2:	bf00      	nop
 8000ba4:	20000800 	.word	0x20000800

08000ba8 <main>:

/*#################################################################################################
And now for the main routine 
  #################################################################################################*/
int main(void)
{
 8000ba8:	b508      	push	{r3, lr}
	// initialize
	initMasterController();
 8000baa:	f7ff fe19 	bl	80007e0 <initMasterController>

/* --------------------- Endless Polling Loop ----------------------------------------------- */
	while (1==1)
	{
		ledHeartbeat();
 8000bae:	f7ff fe8b 	bl	80008c8 <ledHeartbeat>
		timeKeeper();
 8000bb2:	f7ff fe9d 	bl	80008f0 <timeKeeper>
		
		// Gateway functionality (also catches messages for the MC)
		usbInput();
 8000bb6:	f7ff ff6b 	bl	8000a90 <usbInput>
		canInput();
 8000bba:	f7ff ff87 	bl	8000acc <canInput>

		stateMachine();
 8000bbe:	f7ff ff3c 	bl	8000a3a <stateMachine>
		desiredTensionSpeed();
 8000bc2:	f7ff ff45 	bl	8000a50 <desiredTensionSpeed>
		controlLaw();
 8000bc6:	f7ff ff4f 	bl	8000a68 <controlLaw>

		// Send any messages the MC needs over CAN
		canOutput();
 8000bca:	f7ff ffb7 	bl	8000b3c <canOutput>
		usbOutput();
 8000bce:	f7ff ff95 	bl	8000afc <usbOutput>

		// SPI - led output & switch input
		spiInOut();
 8000bd2:	f7ff feb9 	bl	8000948 <spiInOut>
		lcdOut();
 8000bd6:	f7ff fed7 	bl	8000988 <lcdOut>
 8000bda:	e7e8      	b.n	8000bae <main+0x6>
 8000bdc:	080104dc 	.word	0x080104dc
 8000be0:	20000000 	.word	0x20000000
 8000be4:	20000800 	.word	0x20000800
 8000be8:	20000800 	.word	0x20000800
 8000bec:	20002aa0 	.word	0x20002aa0

08000bf0 <_close>:

int __errno;

int _close(int file) {
	return 0;
}
 8000bf0:	2000      	movs	r0, #0
 8000bf2:	4770      	bx	lr

08000bf4 <_fstat>:

int _fstat(int file, struct stat *st) {
	return 0;
}
 8000bf4:	2000      	movs	r0, #0
 8000bf6:	4770      	bx	lr

08000bf8 <_isatty>:

int _isatty(int file) {
	return 1;
}
 8000bf8:	2001      	movs	r0, #1
 8000bfa:	4770      	bx	lr

08000bfc <_lseek>:

int _lseek(int file, int ptr, int dir) {
	return 0;
}
 8000bfc:	2000      	movs	r0, #0
 8000bfe:	4770      	bx	lr

08000c00 <_open>:



int _open(const char *name, int flags, int mode) {
 8000c00:	b538      	push	{r3, r4, r5, lr}
	void* pret;
	int i;

	if (i_cur >= FD_OPNMAX) return -1;// No free slots check
 8000c02:	4d0b      	ldr	r5, [pc, #44]	; (8000c30 <_open+0x30>)
 8000c04:	682c      	ldr	r4, [r5, #0]
 8000c06:	2c0b      	cmp	r4, #11
 8000c08:	dc0d      	bgt.n	8000c26 <_open+0x26>

	i = i_cur;

	/* Check if there is someone out there with this name */
	pret = (struct CB_UART*)bsp_uart_open(name); // Check USART/UARTs
 8000c0a:	f004 fd3b 	bl	8005684 <bsp_uart_open>
	if (pret != 0) 
 8000c0e:	b150      	cbz	r0, 8000c26 <_open+0x26>
	{ // Here, bsp_uart found the name and returned a control blk ptr
		fd_opn[i].pv = pret;
 8000c10:	4b08      	ldr	r3, [pc, #32]	; (8000c34 <_open+0x34>)
 8000c12:	f843 0034 	str.w	r0, [r3, r4, lsl #3]
		fd_opn[i].dev = 0;	// USART/UART group
 8000c16:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 8000c1a:	2200      	movs	r2, #0
 8000c1c:	605a      	str	r2, [r3, #4]
		i_cur += 1;
 8000c1e:	682b      	ldr	r3, [r5, #0]
 8000c20:	3301      	adds	r3, #1
 8000c22:	602b      	str	r3, [r5, #0]
		return (i);
 8000c24:	e001      	b.n	8000c2a <_open+0x2a>
	}
	// Place calls for others here, e.g. usb (device code 0)
	return -1;		// Nobody recognizes this name
 8000c26:	f04f 34ff 	mov.w	r4, #4294967295
}
 8000c2a:	4620      	mov	r0, r4
 8000c2c:	bd38      	pop	{r3, r4, r5, pc}
 8000c2e:	bf00      	nop
 8000c30:	20000e08 	.word	0x20000e08
 8000c34:	20001abc 	.word	0x20001abc

08000c38 <_read>:

int _read(int fd, char *ptr, int len) {
 8000c38:	b510      	push	{r4, lr}
	char* p = ptr;
//	if (fd > FD_OPNMAX) return -1;
	if (fd != 0) return -1;
 8000c3a:	b938      	cbnz	r0, 8000c4c <_read+0x14>

	if (fd_opn[fd].dev == 0) // Is it a USART/UART?
 8000c3c:	4b05      	ldr	r3, [pc, #20]	; (8000c54 <_read+0x1c>)
 8000c3e:	685c      	ldr	r4, [r3, #4]
 8000c40:	b934      	cbnz	r4, 8000c50 <_read+0x18>
		return bsp_uart_getn_ptr((struct CB_UART*)fd_opn[fd].pv, ptr, len);
 8000c42:	6818      	ldr	r0, [r3, #0]
//		while(VCP_get_char_test()  &&  len > 0) 
//		{VCP_get_char((u8*)p++); len -= 1;}
//	}
	
	return p - ptr;
}
 8000c44:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	char* p = ptr;
//	if (fd > FD_OPNMAX) return -1;
	if (fd != 0) return -1;

	if (fd_opn[fd].dev == 0) // Is it a USART/UART?
		return bsp_uart_getn_ptr((struct CB_UART*)fd_opn[fd].pv, ptr, len);
 8000c48:	f004 beec 	b.w	8005a24 <bsp_uart_getn_ptr>
}

int _read(int fd, char *ptr, int len) {
	char* p = ptr;
//	if (fd > FD_OPNMAX) return -1;
	if (fd != 0) return -1;
 8000c4c:	f04f 30ff 	mov.w	r0, #4294967295
//		while(VCP_get_char_test()  &&  len > 0) 
//		{VCP_get_char((u8*)p++); len -= 1;}
//	}
	
	return p - ptr;
}
 8000c50:	bd10      	pop	{r4, pc}
 8000c52:	bf00      	nop
 8000c54:	20001abc 	.word	0x20001abc

08000c58 <_sbrk_r>:
caddr_t _sbrk_r (struct _reent *r, int incr) {
	extern char   end asm ("end"); /* Defined by the linker.  */
	static char * heap_end;
	char *        prev_heap_end;

	if (heap_end == NULL)
 8000c58:	4b07      	ldr	r3, [pc, #28]	; (8000c78 <_sbrk_r+0x20>)
 8000c5a:	685a      	ldr	r2, [r3, #4]
 8000c5c:	b90a      	cbnz	r2, 8000c62 <_sbrk_r+0xa>
		heap_end = & end;
 8000c5e:	4a07      	ldr	r2, [pc, #28]	; (8000c7c <_sbrk_r+0x24>)
 8000c60:	605a      	str	r2, [r3, #4]

	prev_heap_end = heap_end;
 8000c62:	6858      	ldr	r0, [r3, #4]

	if (heap_end + incr > stack_ptr) {
 8000c64:	466b      	mov	r3, sp
 8000c66:	1841      	adds	r1, r0, r1
 8000c68:	4299      	cmp	r1, r3
		//errno = ENOMEM;
		return (caddr_t) -1;
	}

	heap_end += incr;
 8000c6a:	bf96      	itet	ls
 8000c6c:	4b02      	ldrls	r3, [pc, #8]	; (8000c78 <_sbrk_r+0x20>)

	prev_heap_end = heap_end;

	if (heap_end + incr > stack_ptr) {
		//errno = ENOMEM;
		return (caddr_t) -1;
 8000c6e:	f04f 30ff 	movhi.w	r0, #4294967295
	}

	heap_end += incr;
 8000c72:	6059      	strls	r1, [r3, #4]

	return (caddr_t) prev_heap_end;
}
 8000c74:	4770      	bx	lr
 8000c76:	bf00      	nop
 8000c78:	20000e08 	.word	0x20000e08
 8000c7c:	20002aa0 	.word	0x20002aa0

08000c80 <_write>:

int _write(int fd, char *ptr, int len) 
{
	if ((fd == 1) || (fd == 2))
 8000c80:	3801      	subs	r0, #1
 8000c82:	2801      	cmp	r0, #1

	return (caddr_t) prev_heap_end;
}

int _write(int fd, char *ptr, int len) 
{
 8000c84:	b510      	push	{r4, lr}
 8000c86:	4613      	mov	r3, r2
	if ((fd == 1) || (fd == 2))
 8000c88:	d807      	bhi.n	8000c9a <_write+0x1a>
	{
/* Map either 1 or 2 into 0, since that holds the control block pointer. */
		if (fd_opn[0].dev == 0) // Is it a USART/UART?
 8000c8a:	4805      	ldr	r0, [pc, #20]	; (8000ca0 <_write+0x20>)
 8000c8c:	6844      	ldr	r4, [r0, #4]
 8000c8e:	b924      	cbnz	r4, 8000c9a <_write+0x1a>
		{return bsp_uart_putn_ptr((struct CB_UART*)fd_opn[0].pv, ptr, len);}
 8000c90:	6800      	ldr	r0, [r0, #0]
	}	
//		// USB equivalent goes here-----
//	VCP_send_buffer((u8*)ptr, len); 
	return len;
}
 8000c92:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
	if ((fd == 1) || (fd == 2))
	{
/* Map either 1 or 2 into 0, since that holds the control block pointer. */
		if (fd_opn[0].dev == 0) // Is it a USART/UART?
		{return bsp_uart_putn_ptr((struct CB_UART*)fd_opn[0].pv, ptr, len);}
 8000c96:	f004 bf53 	b.w	8005b40 <bsp_uart_putn_ptr>
	}	
//		// USB equivalent goes here-----
//	VCP_send_buffer((u8*)ptr, len); 
	return len;
}
 8000c9a:	4618      	mov	r0, r3
 8000c9c:	bd10      	pop	{r4, pc}
 8000c9e:	bf00      	nop
 8000ca0:	20001abc 	.word	0x20001abc

08000ca4 <CAN_test_msg_init>:
 * void CAN_test_msg_init(void);
 * @brief	: Initialize time for generating time msgs
 * ************************************************************************************** */
void CAN_test_msg_init(void)
{
	t_dly_pc  = *(volatile unsigned int *)0xE0001004 + CANTESTINC_PC;
 8000ca4:	4904      	ldr	r1, [pc, #16]	; (8000cb8 <CAN_test_msg_init+0x14>)
 8000ca6:	4a05      	ldr	r2, [pc, #20]	; (8000cbc <CAN_test_msg_init+0x18>)
 8000ca8:	6808      	ldr	r0, [r1, #0]
 8000caa:	4b05      	ldr	r3, [pc, #20]	; (8000cc0 <CAN_test_msg_init+0x1c>)
 8000cac:	1880      	adds	r0, r0, r2
 8000cae:	6018      	str	r0, [r3, #0]
	t_dly_can = *(volatile unsigned int *)0xE0001004 + CANTESTINC_CAN;
 8000cb0:	6809      	ldr	r1, [r1, #0]
 8000cb2:	188a      	adds	r2, r1, r2
 8000cb4:	605a      	str	r2, [r3, #4]
	return;
}
 8000cb6:	4770      	bx	lr
 8000cb8:	e0001004 	.word	0xe0001004
 8000cbc:	058b1140 	.word	0x058b1140
 8000cc0:	20000e10 	.word	0x20000e10

08000cc4 <CAN_test_msg_PC>:

struct CANRCVBUF* CAN_test_msg_PC(void)
{
//return 0; // NO MSGS
	/* Is it time to send a new round of msgs? */
	if (((int)(*(volatile unsigned int *)0xE0001004 - t_dly_pc)) > 0)
 8000cc4:	4b0c      	ldr	r3, [pc, #48]	; (8000cf8 <CAN_test_msg_PC+0x34>)
 8000cc6:	490d      	ldr	r1, [pc, #52]	; (8000cfc <CAN_test_msg_PC+0x38>)
 8000cc8:	681b      	ldr	r3, [r3, #0]
 8000cca:	6808      	ldr	r0, [r1, #0]
 8000ccc:	4a0c      	ldr	r2, [pc, #48]	; (8000d00 <CAN_test_msg_PC+0x3c>)
 8000cce:	1a1b      	subs	r3, r3, r0
 8000cd0:	2b00      	cmp	r3, #0
 8000cd2:	dd04      	ble.n	8000cde <CAN_test_msg_PC+0x1a>
	{ // Here, yes.
		t_dly_pc += CANTESTINC_PC;	// Compute next time
 8000cd4:	4b0b      	ldr	r3, [pc, #44]	; (8000d04 <CAN_test_msg_PC+0x40>)
 8000cd6:	18c3      	adds	r3, r0, r3
 8000cd8:	600b      	str	r3, [r1, #0]
		idx = 0;
 8000cda:	2300      	movs	r3, #0
 8000cdc:	6013      	str	r3, [r2, #0]
	}
	if (idx >= CANTESTNUMBER_PC) return 0;
 8000cde:	6813      	ldr	r3, [r2, #0]
 8000ce0:	2b04      	cmp	r3, #4
 8000ce2:	dc06      	bgt.n	8000cf2 <CAN_test_msg_PC+0x2e>
	return (struct CANRCVBUF*)&canPC[idx++];	
 8000ce4:	4808      	ldr	r0, [pc, #32]	; (8000d08 <CAN_test_msg_PC+0x44>)
 8000ce6:	4a06      	ldr	r2, [pc, #24]	; (8000d00 <CAN_test_msg_PC+0x3c>)
 8000ce8:	eb00 1003 	add.w	r0, r0, r3, lsl #4
 8000cec:	3301      	adds	r3, #1
 8000cee:	6013      	str	r3, [r2, #0]
 8000cf0:	4770      	bx	lr
	if (((int)(*(volatile unsigned int *)0xE0001004 - t_dly_pc)) > 0)
	{ // Here, yes.
		t_dly_pc += CANTESTINC_PC;	// Compute next time
		idx = 0;
	}
	if (idx >= CANTESTNUMBER_PC) return 0;
 8000cf2:	2000      	movs	r0, #0
	return (struct CANRCVBUF*)&canPC[idx++];	
}
 8000cf4:	4770      	bx	lr
 8000cf6:	bf00      	nop
 8000cf8:	e0001004 	.word	0xe0001004
 8000cfc:	20000e10 	.word	0x20000e10
 8000d00:	2000000c 	.word	0x2000000c
 8000d04:	058b1140 	.word	0x058b1140
 8000d08:	0800ff68 	.word	0x0800ff68

08000d0c <CAN_test_msg_CAN>:
struct CANRCVBUF* CAN_test_msg_CAN(void)
{
//return 0; // NO MSGS

	/* Is it time to send a msg? */
	if (((int)(*(volatile unsigned int *)0xE0001004 - t_dly_can)) > 0)
 8000d0c:	4b0c      	ldr	r3, [pc, #48]	; (8000d40 <CAN_test_msg_CAN+0x34>)
 8000d0e:	4a0d      	ldr	r2, [pc, #52]	; (8000d44 <CAN_test_msg_CAN+0x38>)
 8000d10:	681b      	ldr	r3, [r3, #0]
 8000d12:	6851      	ldr	r1, [r2, #4]
 8000d14:	1a5b      	subs	r3, r3, r1
 8000d16:	2b00      	cmp	r3, #0
 8000d18:	dd0f      	ble.n	8000d3a <CAN_test_msg_CAN+0x2e>
	{ // Here, yes.
		t_dly_can += CANTESTINC_CAN;	// Compute next time
 8000d1a:	4b0b      	ldr	r3, [pc, #44]	; (8000d48 <CAN_test_msg_CAN+0x3c>)
 8000d1c:	18cb      	adds	r3, r1, r3
 8000d1e:	6053      	str	r3, [r2, #4]
		idx1 += 1; if (idx1 >= CANTESTNUMBER_CAN) idx1 = 0;
 8000d20:	4b0a      	ldr	r3, [pc, #40]	; (8000d4c <CAN_test_msg_CAN+0x40>)
 8000d22:	685a      	ldr	r2, [r3, #4]
 8000d24:	3201      	adds	r2, #1
 8000d26:	2a03      	cmp	r2, #3
 8000d28:	605a      	str	r2, [r3, #4]
 8000d2a:	dd01      	ble.n	8000d30 <CAN_test_msg_CAN+0x24>
 8000d2c:	2200      	movs	r2, #0
 8000d2e:	605a      	str	r2, [r3, #4]
		return (struct CANRCVBUF*)&canCAN[idx1];
 8000d30:	6858      	ldr	r0, [r3, #4]
 8000d32:	4b07      	ldr	r3, [pc, #28]	; (8000d50 <CAN_test_msg_CAN+0x44>)
 8000d34:	eb03 1000 	add.w	r0, r3, r0, lsl #4
 8000d38:	4770      	bx	lr
	}
	return 0;	
 8000d3a:	2000      	movs	r0, #0
}
 8000d3c:	4770      	bx	lr
 8000d3e:	bf00      	nop
 8000d40:	e0001004 	.word	0xe0001004
 8000d44:	20000e10 	.word	0x20000e10
 8000d48:	058b1140 	.word	0x058b1140
 8000d4c:	2000000c 	.word	0x2000000c
 8000d50:	0800ffb8 	.word	0x0800ffb8

08000d54 <Errors_USB_PC_get_msg_mode>:
 * @brief	: Count errors
 * @param	: Subroutine return from: USB_PC_get_msg_mode
 * ************************************************************************************** */
void Errors_USB_PC_get_msg_mode(int x)
{
	if ( x > 0 ) return; // Expect negative numbers
 8000d54:	2800      	cmp	r0, #0
 8000d56:	dc09      	bgt.n	8000d6c <Errors_USB_PC_get_msg_mode+0x18>
	x = 1 - x; // Make -1 to -n run 0 to + (n-1), i.e an index
 8000d58:	f1c0 0001 	rsb	r0, r0, #1
	if (x >= FIRSTGROUPSIZE) return; // Assure it is in range.
 8000d5c:	2809      	cmp	r0, #9
 8000d5e:	dc05      	bgt.n	8000d6c <Errors_USB_PC_get_msg_mode+0x18>
	err_ctrs[x] += 1;	// Add to error count
 8000d60:	4b03      	ldr	r3, [pc, #12]	; (8000d70 <Errors_USB_PC_get_msg_mode+0x1c>)
 8000d62:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 8000d66:	3201      	adds	r2, #1
 8000d68:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
 8000d6c:	4770      	bx	lr
 8000d6e:	bf00      	nop
 8000d70:	20001b20 	.word	0x20001b20

08000d74 <Errors_CAN_gateway_send>:
 * @brief	: Count errors
 * @param	: Subroutine return from: USB_PC_get_msg_mode
 * ************************************************************************************** */
void Errors_CAN_gateway_send(int x)
{
	if ( x > 0 ) return; // Expect negative numbers
 8000d74:	2800      	cmp	r0, #0
 8000d76:	dc04      	bgt.n	8000d82 <Errors_CAN_gateway_send+0xe>
	x = 1 - x;
	if ( x >= SECONDGROUPSIZE)  return;
 8000d78:	d103      	bne.n	8000d82 <Errors_CAN_gateway_send+0xe>
	err_ctrs[x + FIRSTGROUPSIZE] += 1;
 8000d7a:	4b02      	ldr	r3, [pc, #8]	; (8000d84 <Errors_CAN_gateway_send+0x10>)
 8000d7c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000d7e:	3201      	adds	r2, #1
 8000d80:	62da      	str	r2, [r3, #44]	; 0x2c
 8000d82:	4770      	bx	lr
 8000d84:	20001b20 	.word	0x20001b20

08000d88 <Errors_misc>:
	if ( x > 0 ) return; // Expect negative numbers
	x = 1 - x;
	if ( x >= THIRDGROUPSIZE)  return;
	err_ctrs[x + (FIRSTGROUPSIZE + SECONDGROUPSIZE) ] += 1;
	return;
}
 8000d88:	4770      	bx	lr

08000d8a <Errors_get_count>:
static int CAN_error_idx = 0;	// Index for 'get' of counters

struct CANERR2 Errors_get_count(void)
{
	struct CANERR2 err;
	err.idx = CAN_error_idx;
 8000d8a:	4a07      	ldr	r2, [pc, #28]	; (8000da8 <Errors_get_count+0x1e>)
	err.ct  = err_ctrs[CAN_error_idx];
 8000d8c:	4907      	ldr	r1, [pc, #28]	; (8000dac <Errors_get_count+0x22>)
static int CAN_error_idx = 0;	// Index for 'get' of counters

struct CANERR2 Errors_get_count(void)
{
	struct CANERR2 err;
	err.idx = CAN_error_idx;
 8000d8e:	6813      	ldr	r3, [r2, #0]
 * @return	: array index; error count
 * ************************************************************************************** */
static int CAN_error_idx = 0;	// Index for 'get' of counters

struct CANERR2 Errors_get_count(void)
{
 8000d90:	b510      	push	{r4, lr}
	struct CANERR2 err;
	err.idx = CAN_error_idx;
	err.ct  = err_ctrs[CAN_error_idx];
 8000d92:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
	CAN_error_idx += 1; if (CAN_error_idx >= TOTALERRCTSIZE) CAN_error_idx = 0;
 8000d96:	1c59      	adds	r1, r3, #1
 8000d98:	290c      	cmp	r1, #12
 8000d9a:	6011      	str	r1, [r2, #0]
 8000d9c:	dd01      	ble.n	8000da2 <Errors_get_count+0x18>
 8000d9e:	2100      	movs	r1, #0
 8000da0:	6011      	str	r1, [r2, #0]
 8000da2:	6003      	str	r3, [r0, #0]
 8000da4:	6044      	str	r4, [r0, #4]
	return err; // Return count, and step 
}
 8000da6:	bd10      	pop	{r4, pc}
 8000da8:	20000e18 	.word	0x20000e18
 8000dac:	20001b20 	.word	0x20001b20

08000db0 <NMI_Handler>:
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}
 8000db0:	4770      	bx	lr

08000db2 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8000db2:	e7fe      	b.n	8000db2 <HardFault_Handler>

08000db4 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8000db4:	e7fe      	b.n	8000db4 <MemManage_Handler>

08000db6 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 8000db6:	e7fe      	b.n	8000db6 <BusFault_Handler>

08000db8 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8000db8:	e7fe      	b.n	8000db8 <UsageFault_Handler>

08000dba <SVC_Handler>:
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
}
 8000dba:	4770      	bx	lr

08000dbc <DebugMon_Handler>:
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
}
 8000dbc:	4770      	bx	lr

08000dbe <PendSV_Handler>:
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
}
 8000dbe:	4770      	bx	lr

08000dc0 <SysTick_Handler>:
  * @retval None
  */
void SysTick_Handler(void)
{

	timing_handler();
 8000dc0:	f000 b91e 	b.w	8001000 <timing_handler>

08000dc4 <OTG_FS_WKUP_IRQHandler>:
/*  file (startup_stm32f4xx.s).                                               */
/******************************************************************************/

#ifdef USE_USB_OTG_FS
void OTG_FS_WKUP_IRQHandler(void)
{
 8000dc4:	b510      	push	{r4, lr}
  if(USB_OTG_dev.cfg.low_power)
 8000dc6:	4c09      	ldr	r4, [pc, #36]	; (8000dec <OTG_FS_WKUP_IRQHandler+0x28>)
 8000dc8:	7aa3      	ldrb	r3, [r4, #10]
 8000dca:	b14b      	cbz	r3, 8000de0 <OTG_FS_WKUP_IRQHandler+0x1c>
  {
    *(uint32_t *)(0xE000ED10) &= 0xFFFFFFF9 ;
 8000dcc:	4b08      	ldr	r3, [pc, #32]	; (8000df0 <OTG_FS_WKUP_IRQHandler+0x2c>)
 8000dce:	681a      	ldr	r2, [r3, #0]
 8000dd0:	f022 0206 	bic.w	r2, r2, #6
 8000dd4:	601a      	str	r2, [r3, #0]
    SystemInit();
 8000dd6:	f000 f813 	bl	8000e00 <SystemInit>
    USB_OTG_UngateClock(&USB_OTG_dev);
 8000dda:	4620      	mov	r0, r4
 8000ddc:	f001 fcee 	bl	80027bc <USB_OTG_UngateClock>
  }
  EXTI_ClearITPendingBit(EXTI_Line18);
 8000de0:	f44f 2080 	mov.w	r0, #262144	; 0x40000
}
 8000de4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  {
    *(uint32_t *)(0xE000ED10) &= 0xFFFFFFF9 ;
    SystemInit();
    USB_OTG_UngateClock(&USB_OTG_dev);
  }
  EXTI_ClearITPendingBit(EXTI_Line18);
 8000de8:	f000 bc48 	b.w	800167c <EXTI_ClearITPendingBit>
 8000dec:	20001b54 	.word	0x20001b54
 8000df0:	e000ed10 	.word	0xe000ed10

08000df4 <OTG_FS_IRQHandler>:
void OTG_HS_IRQHandler(void)
#else
void OTG_FS_IRQHandler(void)
#endif
{
  USBD_OTG_ISR_Handler (&USB_OTG_dev);
 8000df4:	4801      	ldr	r0, [pc, #4]	; (8000dfc <OTG_FS_IRQHandler+0x8>)
 8000df6:	f001 bf55 	b.w	8002ca4 <USBD_OTG_ISR_Handler>
 8000dfa:	bf00      	nop
 8000dfc:	20001b54 	.word	0x20001b54

08000e00 <SystemInit>:
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
	SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
#endif
	/* Reset the RCC clock configuration to the default reset state ------------*/
	/* Set HSION bit */
	RCC->CR |= (uint32_t)0x00000001;
 8000e00:	4b34      	ldr	r3, [pc, #208]	; (8000ed4 <SystemInit+0xd4>)
 8000e02:	681a      	ldr	r2, [r3, #0]
 8000e04:	f042 0201 	orr.w	r2, r2, #1
 8000e08:	601a      	str	r2, [r3, #0]

	/* Reset CFGR register */
	RCC->CFGR = 0x00000000;
 8000e0a:	2200      	movs	r2, #0
 8000e0c:	609a      	str	r2, [r3, #8]

	/* Reset HSEON, CSSON and PLLON bits */
	RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000e0e:	6819      	ldr	r1, [r3, #0]
 8000e10:	f021 7184 	bic.w	r1, r1, #17301504	; 0x1080000
 8000e14:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 8000e18:	6019      	str	r1, [r3, #0]

	/* Reset PLLCFGR register */
	RCC->PLLCFGR = 0x24003010;
 8000e1a:	492f      	ldr	r1, [pc, #188]	; (8000ed8 <SystemInit+0xd8>)
 8000e1c:	6059      	str	r1, [r3, #4]

	/* Reset HSEBYP bit */
	RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000e1e:	6819      	ldr	r1, [r3, #0]
 *         SystemFrequency variable.
 * @param  None
 * @retval None
 */
void SystemInit(void)
{
 8000e20:	b082      	sub	sp, #8

	/* Reset PLLCFGR register */
	RCC->PLLCFGR = 0x24003010;

	/* Reset HSEBYP bit */
	RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000e22:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 8000e26:	6019      	str	r1, [r3, #0]

	/* Disable all interrupts */
	RCC->CIR = 0x00000000;
 8000e28:	60da      	str	r2, [r3, #12]
static void SetSysClock(void)
{
	/******************************************************************************/
	/*            PLL (clocked by HSE) used as System clock source                */
	/******************************************************************************/
	__IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 8000e2a:	9201      	str	r2, [sp, #4]
 8000e2c:	9200      	str	r2, [sp, #0]

	/* Enable HSE */
	RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8000e2e:	681a      	ldr	r2, [r3, #0]
 8000e30:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8000e34:	601a      	str	r2, [r3, #0]

	/* Wait till HSE is ready and if Time out is reached exit */
	do
	{
		HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8000e36:	4b27      	ldr	r3, [pc, #156]	; (8000ed4 <SystemInit+0xd4>)
 8000e38:	681a      	ldr	r2, [r3, #0]
 8000e3a:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 8000e3e:	9200      	str	r2, [sp, #0]
		StartUpCounter++;
 8000e40:	9a01      	ldr	r2, [sp, #4]
 8000e42:	3201      	adds	r2, #1
 8000e44:	9201      	str	r2, [sp, #4]
	} while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8000e46:	9a00      	ldr	r2, [sp, #0]
 8000e48:	b91a      	cbnz	r2, 8000e52 <SystemInit+0x52>
 8000e4a:	9a01      	ldr	r2, [sp, #4]
 8000e4c:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 8000e50:	d1f1      	bne.n	8000e36 <SystemInit+0x36>

	if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8000e52:	681b      	ldr	r3, [r3, #0]
 8000e54:	f413 3300 	ands.w	r3, r3, #131072	; 0x20000
	{
		HSEStatus = (uint32_t)0x01;
 8000e58:	bf18      	it	ne
 8000e5a:	2301      	movne	r3, #1
	}
	else
	{
		HSEStatus = (uint32_t)0x00;
 8000e5c:	9300      	str	r3, [sp, #0]
	}

	if (HSEStatus == (uint32_t)0x01)
 8000e5e:	9b00      	ldr	r3, [sp, #0]
 8000e60:	2b01      	cmp	r3, #1
 8000e62:	d130      	bne.n	8000ec6 <SystemInit+0xc6>
	{
		/* Select regulator voltage output Scale 1 mode, System frequency up to 168 MHz */
		RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 8000e64:	4b1b      	ldr	r3, [pc, #108]	; (8000ed4 <SystemInit+0xd4>)
 8000e66:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000e68:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000e6c:	641a      	str	r2, [r3, #64]	; 0x40
		PWR->CR |= PWR_CR_VOS;
 8000e6e:	4a1b      	ldr	r2, [pc, #108]	; (8000edc <SystemInit+0xdc>)
 8000e70:	6811      	ldr	r1, [r2, #0]
 8000e72:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 8000e76:	6011      	str	r1, [r2, #0]

		/* HCLK = SYSCLK / 1*/
		RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 8000e78:	689a      	ldr	r2, [r3, #8]
 8000e7a:	609a      	str	r2, [r3, #8]

		/* PCLK2 = HCLK / 2*/
		RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 8000e7c:	689a      	ldr	r2, [r3, #8]
 8000e7e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8000e82:	609a      	str	r2, [r3, #8]

		/* PCLK1 = HCLK / 4*/
		RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 8000e84:	689a      	ldr	r2, [r3, #8]
 8000e86:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 8000e8a:	609a      	str	r2, [r3, #8]

		/* Configure the main PLL */
		RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8000e8c:	4a14      	ldr	r2, [pc, #80]	; (8000ee0 <SystemInit+0xe0>)
 8000e8e:	605a      	str	r2, [r3, #4]
				(RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

		/* Enable the main PLL */
		RCC->CR |= RCC_CR_PLLON;
 8000e90:	681a      	ldr	r2, [r3, #0]
 8000e92:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000e96:	601a      	str	r2, [r3, #0]

		/* Wait till the main PLL is ready */
		while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8000e98:	4b0e      	ldr	r3, [pc, #56]	; (8000ed4 <SystemInit+0xd4>)
 8000e9a:	681a      	ldr	r2, [r3, #0]
 8000e9c:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8000ea0:	d0fa      	beq.n	8000e98 <SystemInit+0x98>
		{
		}

		/* Configure Flash prefetch, Instruction cache, Data cache and wait state */
		FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 8000ea2:	4a10      	ldr	r2, [pc, #64]	; (8000ee4 <SystemInit+0xe4>)
 8000ea4:	f240 6105 	movw	r1, #1541	; 0x605
 8000ea8:	6011      	str	r1, [r2, #0]

		/* Select the main PLL as system clock source */
		RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8000eaa:	689a      	ldr	r2, [r3, #8]
 8000eac:	f022 0203 	bic.w	r2, r2, #3
 8000eb0:	609a      	str	r2, [r3, #8]
		RCC->CFGR |= RCC_CFGR_SW_PLL;
 8000eb2:	689a      	ldr	r2, [r3, #8]
 8000eb4:	f042 0202 	orr.w	r2, r2, #2
 8000eb8:	609a      	str	r2, [r3, #8]

		/* Wait till the main PLL is used as system clock source */
		while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 8000eba:	4b06      	ldr	r3, [pc, #24]	; (8000ed4 <SystemInit+0xd4>)
 8000ebc:	689b      	ldr	r3, [r3, #8]
 8000ebe:	f003 030c 	and.w	r3, r3, #12
 8000ec2:	2b08      	cmp	r3, #8
 8000ec4:	d1f9      	bne.n	8000eba <SystemInit+0xba>

	/* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
	SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
	SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8000ec6:	4b08      	ldr	r3, [pc, #32]	; (8000ee8 <SystemInit+0xe8>)
 8000ec8:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8000ecc:	609a      	str	r2, [r3, #8]
#endif
}
 8000ece:	b002      	add	sp, #8
 8000ed0:	4770      	bx	lr
 8000ed2:	bf00      	nop
 8000ed4:	40023800 	.word	0x40023800
 8000ed8:	24003010 	.word	0x24003010
 8000edc:	40007000 	.word	0x40007000
 8000ee0:	07405408 	.word	0x07405408
 8000ee4:	40023c00 	.word	0x40023c00
 8000ee8:	e000ed00 	.word	0xe000ed00

08000eec <SystemCoreClockUpdate>:
void SystemCoreClockUpdate(void)
{
	uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

	/* Get SYSCLK source -------------------------------------------------------*/
	tmp = RCC->CFGR & RCC_CFGR_SWS;
 8000eec:	4a1e      	ldr	r2, [pc, #120]	; (8000f68 <SystemCoreClockUpdate+0x7c>)
 8000eee:	4b1f      	ldr	r3, [pc, #124]	; (8000f6c <SystemCoreClockUpdate+0x80>)
 8000ef0:	6891      	ldr	r1, [r2, #8]
 8000ef2:	f001 010c 	and.w	r1, r1, #12

	switch (tmp)
 8000ef6:	2904      	cmp	r1, #4
 8000ef8:	d003      	beq.n	8000f02 <SystemCoreClockUpdate+0x16>
 8000efa:	2908      	cmp	r1, #8
 8000efc:	d003      	beq.n	8000f06 <SystemCoreClockUpdate+0x1a>
 8000efe:	4a1c      	ldr	r2, [pc, #112]	; (8000f70 <SystemCoreClockUpdate+0x84>)
 8000f00:	e025      	b.n	8000f4e <SystemCoreClockUpdate+0x62>
	{
	case 0x00:  /* HSI used as system clock source */
		SystemCoreClock = HSI_VALUE;
		break;
	case 0x04:  /* HSE used as system clock source */
		SystemCoreClock = HSE_VALUE;
 8000f02:	4a1c      	ldr	r2, [pc, #112]	; (8000f74 <SystemCoreClockUpdate+0x88>)
 8000f04:	e023      	b.n	8000f4e <SystemCoreClockUpdate+0x62>
	case 0x08:  /* PLL used as system clock source */

		/* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
		 */
		pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8000f06:	6851      	ldr	r1, [r2, #4]
		pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8000f08:	6850      	ldr	r0, [r2, #4]

		if (pllsource != 0)
 8000f0a:	f411 0f80 	tst.w	r1, #4194304	; 0x400000

		/* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
		 */
		pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
		pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8000f0e:	f000 003f 	and.w	r0, r0, #63	; 0x3f

		if (pllsource != 0)
 8000f12:	d00a      	beq.n	8000f2a <SystemCoreClockUpdate+0x3e>
		{
			/* HSE used as PLL clock source */
			pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8000f14:	6852      	ldr	r2, [r2, #4]
 8000f16:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 8000f1a:	ea02 0101 	and.w	r1, r2, r1
 8000f1e:	4a15      	ldr	r2, [pc, #84]	; (8000f74 <SystemCoreClockUpdate+0x88>)
 8000f20:	0989      	lsrs	r1, r1, #6
 8000f22:	fbb2 f2f0 	udiv	r2, r2, r0
 8000f26:	434a      	muls	r2, r1
 8000f28:	e009      	b.n	8000f3e <SystemCoreClockUpdate+0x52>
		}
		else
		{
			/* HSI used as PLL clock source */
			pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8000f2a:	6851      	ldr	r1, [r2, #4]
 8000f2c:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 8000f30:	ea01 0202 	and.w	r2, r1, r2
 8000f34:	490e      	ldr	r1, [pc, #56]	; (8000f70 <SystemCoreClockUpdate+0x84>)
 8000f36:	0992      	lsrs	r2, r2, #6
 8000f38:	fbb1 f0f0 	udiv	r0, r1, r0
 8000f3c:	4342      	muls	r2, r0
		}

		pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8000f3e:	490a      	ldr	r1, [pc, #40]	; (8000f68 <SystemCoreClockUpdate+0x7c>)
 8000f40:	6849      	ldr	r1, [r1, #4]
 8000f42:	f401 3140 	and.w	r1, r1, #196608	; 0x30000
 8000f46:	0bc9      	lsrs	r1, r1, #15
 8000f48:	3102      	adds	r1, #2
		SystemCoreClock = pllvco/pllp;
 8000f4a:	fbb2 f2f1 	udiv	r2, r2, r1
 8000f4e:	601a      	str	r2, [r3, #0]
		SystemCoreClock = HSI_VALUE;
		break;
	}
	/* Compute HCLK frequency --------------------------------------------------*/
	/* Get HCLK prescaler */
	tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8000f50:	4a05      	ldr	r2, [pc, #20]	; (8000f68 <SystemCoreClockUpdate+0x7c>)
	/* HCLK frequency */
	SystemCoreClock >>= tmp;
 8000f52:	6819      	ldr	r1, [r3, #0]
		SystemCoreClock = HSI_VALUE;
		break;
	}
	/* Compute HCLK frequency --------------------------------------------------*/
	/* Get HCLK prescaler */
	tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8000f54:	6892      	ldr	r2, [r2, #8]
 8000f56:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8000f5a:	eb03 1212 	add.w	r2, r3, r2, lsr #4
 8000f5e:	7912      	ldrb	r2, [r2, #4]
	/* HCLK frequency */
	SystemCoreClock >>= tmp;
 8000f60:	fa31 f202 	lsrs.w	r2, r1, r2
 8000f64:	601a      	str	r2, [r3, #0]
}
 8000f66:	4770      	bx	lr
 8000f68:	40023800 	.word	0x40023800
 8000f6c:	20000014 	.word	0x20000014
 8000f70:	00f42400 	.word	0x00f42400
 8000f74:	017d7840 	.word	0x017d7840

08000f78 <usb1_init>:
void usb1_init(void)
{
	GPIO_InitTypeDef  GPIO_InitStructure;

	// ---------- SysTick timer -------- //
	if (SysTick_Config(SystemCoreClock / 1000)) {
 8000f78:	4b19      	ldr	r3, [pc, #100]	; (8000fe0 <usb1_init+0x68>)
 8000f7a:	681a      	ldr	r2, [r3, #0]
 8000f7c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000f80:	fbb2 f2f3 	udiv	r2, r2, r3
__ALIGN_BEGIN USB_OTG_CORE_HANDLE  USB_OTG_dev __ALIGN_END;

// Private function prototypes

void usb1_init(void)
{
 8000f84:	b530      	push	{r4, r5, lr}
 */
static __INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
 8000f86:	4b17      	ldr	r3, [pc, #92]	; (8000fe4 <usb1_init+0x6c>)
 8000f88:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8000f8c:	3a01      	subs	r2, #1
 8000f8e:	605a      	str	r2, [r3, #4]
    \param [in]  priority  Priority to set
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8000f90:	4a15      	ldr	r2, [pc, #84]	; (8000fe8 <usb1_init+0x70>)
 8000f92:	21f0      	movs	r1, #240	; 0xf0
 8000f94:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 8000f98:	2400      	movs	r4, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000f9a:	2207      	movs	r2, #7
 8000f9c:	b085      	sub	sp, #20
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 8000f9e:	609c      	str	r4, [r3, #8]
		while (1){};
	}

	// ---------- GPIO -------- //
	// GPIOD Periph clock enable
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 8000fa0:	2008      	movs	r0, #8
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000fa2:	601a      	str	r2, [r3, #0]
 8000fa4:	39ef      	subs	r1, #239	; 0xef
 8000fa6:	f000 f9bb 	bl	8001320 <RCC_AHB1PeriphClockCmd>

	// Configure PD12, PD13, PD14 and PD15 in output pushpull mode
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15;
 8000faa:	f44f 4370 	mov.w	r3, #61440	; 0xf000
 8000fae:	9302      	str	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8000fb0:	2501      	movs	r5, #1
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8000fb2:	2303      	movs	r3, #3
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 8000fb4:	a902      	add	r1, sp, #8
 8000fb6:	480d      	ldr	r0, [pc, #52]	; (8000fec <usb1_init+0x74>)

	// Configure PD12, PD13, PD14 and PD15 in output pushpull mode
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8000fb8:	f88d 300d 	strb.w	r3, [sp, #13]
	// GPIOD Periph clock enable
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);

	// Configure PD12, PD13, PD14 and PD15 in output pushpull mode
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8000fbc:	f88d 500c 	strb.w	r5, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000fc0:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8000fc4:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 8000fc8:	f000 fbea 	bl	80017a0 <GPIO_Init>

	// ------------- USB -------------- //
	USBD_Init(&USB_OTG_dev,
 8000fcc:	4b08      	ldr	r3, [pc, #32]	; (8000ff0 <usb1_init+0x78>)
 8000fce:	4809      	ldr	r0, [pc, #36]	; (8000ff4 <usb1_init+0x7c>)
 8000fd0:	9300      	str	r3, [sp, #0]
 8000fd2:	4629      	mov	r1, r5
 8000fd4:	4a08      	ldr	r2, [pc, #32]	; (8000ff8 <usb1_init+0x80>)
 8000fd6:	4b09      	ldr	r3, [pc, #36]	; (8000ffc <usb1_init+0x84>)
 8000fd8:	f002 fa06 	bl	80033e8 <USBD_Init>
	            &USR_desc,
	            &USBD_CDC_cb,
	            &USR_cb);

	return;
}
 8000fdc:	b005      	add	sp, #20
 8000fde:	bd30      	pop	{r4, r5, pc}
 8000fe0:	20000014 	.word	0x20000014
 8000fe4:	e000e010 	.word	0xe000e010
 8000fe8:	e000ed00 	.word	0xe000ed00
 8000fec:	40020c00 	.word	0x40020c00
 8000ff0:	20000028 	.word	0x20000028
 8000ff4:	20001b54 	.word	0x20001b54
 8000ff8:	2000005c 	.word	0x2000005c
 8000ffc:	200000dc 	.word	0x200000dc

08001000 <timing_handler>:
/*
 * Called from systick handler.  Call his ticker.
 */
void timing_handler()
{
}
 8001000:	4770      	bx	lr

08001002 <_init>:

/*
 * Dummy function to avoid compiler error
 */
void _init() {}
 8001002:	4770      	bx	lr

08001004 <USBD_USR_Init>:
* @retval None
*/
void USBD_USR_Init(void)
{   

}
 8001004:	4770      	bx	lr

08001006 <USBD_USR_DeviceReset>:
     break;
 default:
     break;
     
 }
}
 8001006:	4770      	bx	lr

08001008 <USBD_USR_DeviceConfigured>:
* @param  None
* @retval Staus
*/
void USBD_USR_DeviceConfigured (void)
{
}
 8001008:	4770      	bx	lr

0800100a <USBD_USR_DeviceConnected>:
* @param  None
* @retval Staus
*/
void USBD_USR_DeviceConnected (void)
{
}
 800100a:	4770      	bx	lr

0800100c <USBD_USR_DeviceDisconnected>:
* @param  None
* @retval Staus
*/
void USBD_USR_DeviceDisconnected (void)
{
}
 800100c:	4770      	bx	lr

0800100e <USBD_USR_DeviceSuspended>:
* @retval None
*/
void USBD_USR_DeviceSuspended(void)
{
  /* Users can do their application actions here for the USB-Reset */
}
 800100e:	4770      	bx	lr

08001010 <USBD_USR_DeviceResumed>:
* @retval None
*/
void USBD_USR_DeviceResumed(void)
{
  /* Users can do their application actions here for the USB-Reset */
}
 8001010:	4770      	bx	lr
	...

08001014 <USBD_USR_DeviceDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_DeviceDescriptor( uint8_t speed , uint16_t *length)
{
  *length = sizeof(USBD_DeviceDesc);
 8001014:	2312      	movs	r3, #18
 8001016:	800b      	strh	r3, [r1, #0]
  return USBD_DeviceDesc;
}
 8001018:	4800      	ldr	r0, [pc, #0]	; (800101c <USBD_USR_DeviceDescriptor+0x8>)
 800101a:	4770      	bx	lr
 800101c:	20000044 	.word	0x20000044

08001020 <USBD_USR_LangIDStrDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_LangIDStrDescriptor( uint8_t speed , uint16_t *length)
{
  *length =  sizeof(USBD_LangIDDesc);  
 8001020:	2304      	movs	r3, #4
 8001022:	800b      	strh	r3, [r1, #0]
  return USBD_LangIDDesc;
}
 8001024:	4800      	ldr	r0, [pc, #0]	; (8001028 <USBD_USR_LangIDStrDescriptor+0x8>)
 8001026:	4770      	bx	lr
 8001028:	20000056 	.word	0x20000056

0800102c <USBD_USR_InterfaceStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_InterfaceStrDescriptor( uint8_t speed , uint16_t *length)
{
 800102c:	460a      	mov	r2, r1
 800102e:	b508      	push	{r3, lr}
  {
    USBD_GetString ((uint8_t*)USBD_INTERFACE_HS_STRING, USBD_StrDesc, length);
  }
  else
  {
    USBD_GetString ((uint8_t*)USBD_INTERFACE_FS_STRING, USBD_StrDesc, length);
 8001030:	4802      	ldr	r0, [pc, #8]	; (800103c <USBD_USR_InterfaceStrDescriptor+0x10>)
 8001032:	4903      	ldr	r1, [pc, #12]	; (8001040 <USBD_USR_InterfaceStrDescriptor+0x14>)
 8001034:	f002 fcb2 	bl	800399c <USBD_GetString>
  }
  return USBD_StrDesc;  
}
 8001038:	4801      	ldr	r0, [pc, #4]	; (8001040 <USBD_USR_InterfaceStrDescriptor+0x14>)
 800103a:	bd08      	pop	{r3, pc}
 800103c:	080103c2 	.word	0x080103c2
 8001040:	200029d0 	.word	0x200029d0

08001044 <USBD_USR_ConfigStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_ConfigStrDescriptor( uint8_t speed , uint16_t *length)
{
 8001044:	460a      	mov	r2, r1
 8001046:	b508      	push	{r3, lr}
  {  
    USBD_GetString ((uint8_t*)USBD_CONFIGURATION_HS_STRING, USBD_StrDesc, length);
  }
  else
  {
    USBD_GetString ((uint8_t*)USBD_CONFIGURATION_FS_STRING, USBD_StrDesc, length);
 8001048:	4802      	ldr	r0, [pc, #8]	; (8001054 <USBD_USR_ConfigStrDescriptor+0x10>)
 800104a:	4903      	ldr	r1, [pc, #12]	; (8001058 <USBD_USR_ConfigStrDescriptor+0x14>)
 800104c:	f002 fca6 	bl	800399c <USBD_GetString>
  }
  return USBD_StrDesc;  
}
 8001050:	4801      	ldr	r0, [pc, #4]	; (8001058 <USBD_USR_ConfigStrDescriptor+0x14>)
 8001052:	bd08      	pop	{r3, pc}
 8001054:	080103d0 	.word	0x080103d0
 8001058:	200029d0 	.word	0x200029d0

0800105c <USBD_USR_SerialStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_SerialStrDescriptor( uint8_t speed , uint16_t *length)
{
 800105c:	b508      	push	{r3, lr}
 800105e:	460a      	mov	r2, r1
  if(speed  == USB_OTG_SPEED_HIGH)
 8001060:	b908      	cbnz	r0, 8001066 <USBD_USR_SerialStrDescriptor+0xa>
  {    
    USBD_GetString ((uint8_t*)USBD_SERIALNUMBER_HS_STRING, USBD_StrDesc, length);
 8001062:	4804      	ldr	r0, [pc, #16]	; (8001074 <USBD_USR_SerialStrDescriptor+0x18>)
 8001064:	e000      	b.n	8001068 <USBD_USR_SerialStrDescriptor+0xc>
  }
  else
  {
    USBD_GetString ((uint8_t*)USBD_SERIALNUMBER_FS_STRING, USBD_StrDesc, length);
 8001066:	4804      	ldr	r0, [pc, #16]	; (8001078 <USBD_USR_SerialStrDescriptor+0x1c>)
 8001068:	4904      	ldr	r1, [pc, #16]	; (800107c <USBD_USR_SerialStrDescriptor+0x20>)
 800106a:	f002 fc97 	bl	800399c <USBD_GetString>
  }
  return USBD_StrDesc;
}
 800106e:	4803      	ldr	r0, [pc, #12]	; (800107c <USBD_USR_SerialStrDescriptor+0x20>)
 8001070:	bd08      	pop	{r3, pc}
 8001072:	bf00      	nop
 8001074:	080103db 	.word	0x080103db
 8001078:	080103e8 	.word	0x080103e8
 800107c:	200029d0 	.word	0x200029d0

08001080 <USBD_USR_ManufacturerStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_ManufacturerStrDescriptor( uint8_t speed , uint16_t *length)
{
 8001080:	460a      	mov	r2, r1
 8001082:	b508      	push	{r3, lr}
  USBD_GetString ((uint8_t*)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8001084:	4802      	ldr	r0, [pc, #8]	; (8001090 <USBD_USR_ManufacturerStrDescriptor+0x10>)
 8001086:	4903      	ldr	r1, [pc, #12]	; (8001094 <USBD_USR_ManufacturerStrDescriptor+0x14>)
 8001088:	f002 fc88 	bl	800399c <USBD_GetString>
  return USBD_StrDesc;
}
 800108c:	4801      	ldr	r0, [pc, #4]	; (8001094 <USBD_USR_ManufacturerStrDescriptor+0x14>)
 800108e:	bd08      	pop	{r3, pc}
 8001090:	080103f5 	.word	0x080103f5
 8001094:	200029d0 	.word	0x200029d0

08001098 <USBD_USR_ProductStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_ProductStrDescriptor( uint8_t speed , uint16_t *length)
{
 8001098:	b508      	push	{r3, lr}
 800109a:	460a      	mov	r2, r1
 
  
  if(speed == 0)
 800109c:	b908      	cbnz	r0, 80010a2 <USBD_USR_ProductStrDescriptor+0xa>
  {   
    USBD_GetString ((uint8_t*)USBD_PRODUCT_HS_STRING, USBD_StrDesc, length);
 800109e:	4804      	ldr	r0, [pc, #16]	; (80010b0 <USBD_USR_ProductStrDescriptor+0x18>)
 80010a0:	e000      	b.n	80010a4 <USBD_USR_ProductStrDescriptor+0xc>
  }
  else
  {
    USBD_GetString ((uint8_t*)USBD_PRODUCT_FS_STRING, USBD_StrDesc, length);
 80010a2:	4804      	ldr	r0, [pc, #16]	; (80010b4 <USBD_USR_ProductStrDescriptor+0x1c>)
 80010a4:	4904      	ldr	r1, [pc, #16]	; (80010b8 <USBD_USR_ProductStrDescriptor+0x20>)
 80010a6:	f002 fc79 	bl	800399c <USBD_GetString>
  }
  return USBD_StrDesc;
}
 80010aa:	4803      	ldr	r0, [pc, #12]	; (80010b8 <USBD_USR_ProductStrDescriptor+0x20>)
 80010ac:	bd08      	pop	{r3, pc}
 80010ae:	bf00      	nop
 80010b0:	08010408 	.word	0x08010408
 80010b4:	08010429 	.word	0x08010429
 80010b8:	200029d0 	.word	0x200029d0

080010bc <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80010bc:	4b0a      	ldr	r3, [pc, #40]	; (80010e8 <RCC_DeInit+0x2c>)
 80010be:	6819      	ldr	r1, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80010c0:	2200      	movs	r2, #0
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80010c2:	f041 0001 	orr.w	r0, r1, #1
 80010c6:	6018      	str	r0, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80010c8:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80010ca:	6819      	ldr	r1, [r3, #0]
 80010cc:	f021 7c84 	bic.w	ip, r1, #17301504	; 0x1080000

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80010d0:	4906      	ldr	r1, [pc, #24]	; (80010ec <RCC_DeInit+0x30>)

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80010d2:	f42c 3080 	bic.w	r0, ip, #65536	; 0x10000
 80010d6:	6018      	str	r0, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80010d8:	6059      	str	r1, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80010da:	6818      	ldr	r0, [r3, #0]
 80010dc:	f420 2180 	bic.w	r1, r0, #262144	; 0x40000
 80010e0:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80010e2:	60da      	str	r2, [r3, #12]
}
 80010e4:	4770      	bx	lr
 80010e6:	bf00      	nop
 80010e8:	40023800 	.word	0x40023800
 80010ec:	24003010 	.word	0x24003010

080010f0 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
 80010f0:	4b02      	ldr	r3, [pc, #8]	; (80010fc <RCC_HSEConfig+0xc>)
 80010f2:	2200      	movs	r2, #0
 80010f4:	701a      	strb	r2, [r3, #0]

  /* Set the new HSE configuration -------------------------------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
 80010f6:	7018      	strb	r0, [r3, #0]
}
 80010f8:	4770      	bx	lr
 80010fa:	bf00      	nop
 80010fc:	40023802 	.word	0x40023802

08001100 <RCC_AdjustHSICalibrationValue>:
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));

  tmpreg = RCC->CR;
 8001100:	4b03      	ldr	r3, [pc, #12]	; (8001110 <RCC_AdjustHSICalibrationValue+0x10>)
 8001102:	681a      	ldr	r2, [r3, #0]

  /* Clear HSITRIM[4:0] bits */
  tmpreg &= ~RCC_CR_HSITRIM;
 8001104:	f022 01f8 	bic.w	r1, r2, #248	; 0xf8

  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 8001108:	ea41 02c0 	orr.w	r2, r1, r0, lsl #3

  /* Store the new value */
  RCC->CR = tmpreg;
 800110c:	601a      	str	r2, [r3, #0]
}
 800110e:	4770      	bx	lr
 8001110:	40023800 	.word	0x40023800

08001114 <RCC_HSICmd>:
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 8001114:	4b01      	ldr	r3, [pc, #4]	; (800111c <RCC_HSICmd+0x8>)
 8001116:	6018      	str	r0, [r3, #0]
}
 8001118:	4770      	bx	lr
 800111a:	bf00      	nop
 800111c:	42470000 	.word	0x42470000

08001120 <RCC_LSEConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8001120:	4b06      	ldr	r3, [pc, #24]	; (800113c <RCC_LSEConfig+0x1c>)
 8001122:	2200      	movs	r2, #0

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
 8001124:	2801      	cmp	r0, #1
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8001126:	701a      	strb	r2, [r3, #0]

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8001128:	701a      	strb	r2, [r3, #0]

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
 800112a:	d004      	beq.n	8001136 <RCC_LSEConfig+0x16>
 800112c:	2804      	cmp	r0, #4
 800112e:	d101      	bne.n	8001134 <RCC_LSEConfig+0x14>
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
      break;
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 8001130:	2005      	movs	r0, #5
 8001132:	7018      	strb	r0, [r3, #0]
 8001134:	4770      	bx	lr
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 8001136:	7018      	strb	r0, [r3, #0]
      break;
 8001138:	4770      	bx	lr
 800113a:	bf00      	nop
 800113c:	40023870 	.word	0x40023870

08001140 <RCC_LSICmd>:
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 8001140:	4b01      	ldr	r3, [pc, #4]	; (8001148 <RCC_LSICmd+0x8>)
 8001142:	6018      	str	r0, [r3, #0]
}
 8001144:	4770      	bx	lr
 8001146:	bf00      	nop
 8001148:	42470e80 	.word	0x42470e80

0800114c <RCC_PLLConfig>:
  assert_param(IS_RCC_PLLM_VALUE(PLLM));
  assert_param(IS_RCC_PLLN_VALUE(PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLP));
  assert_param(IS_RCC_PLLQ_VALUE(PLLQ));

  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
 800114c:	ea41 0000 	orr.w	r0, r1, r0
 8001150:	ea40 1c82 	orr.w	ip, r0, r2, lsl #6
 8001154:	9a00      	ldr	r2, [sp, #0]
 8001156:	085b      	lsrs	r3, r3, #1
 8001158:	1e59      	subs	r1, r3, #1
 800115a:	ea4c 6002 	orr.w	r0, ip, r2, lsl #24
 800115e:	4b02      	ldr	r3, [pc, #8]	; (8001168 <RCC_PLLConfig+0x1c>)
 8001160:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
 8001164:	605a      	str	r2, [r3, #4]
                 (PLLQ << 24);
}
 8001166:	4770      	bx	lr
 8001168:	40023800 	.word	0x40023800

0800116c <RCC_PLLCmd>:
  */
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 800116c:	4b01      	ldr	r3, [pc, #4]	; (8001174 <RCC_PLLCmd+0x8>)
 800116e:	6018      	str	r0, [r3, #0]
}
 8001170:	4770      	bx	lr
 8001172:	bf00      	nop
 8001174:	42470060 	.word	0x42470060

08001178 <RCC_PLLI2SConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
  assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));

  RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
 8001178:	0180      	lsls	r0, r0, #6
 800117a:	4b03      	ldr	r3, [pc, #12]	; (8001188 <RCC_PLLI2SConfig+0x10>)
 800117c:	ea40 7101 	orr.w	r1, r0, r1, lsl #28
 8001180:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
}
 8001184:	4770      	bx	lr
 8001186:	bf00      	nop
 8001188:	40023800 	.word	0x40023800

0800118c <RCC_PLLI2SCmd>:
  */
void RCC_PLLI2SCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
 800118c:	4b01      	ldr	r3, [pc, #4]	; (8001194 <RCC_PLLI2SCmd+0x8>)
 800118e:	6018      	str	r0, [r3, #0]
}
 8001190:	4770      	bx	lr
 8001192:	bf00      	nop
 8001194:	42470068 	.word	0x42470068

08001198 <RCC_ClockSecuritySystemCmd>:
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 8001198:	4b01      	ldr	r3, [pc, #4]	; (80011a0 <RCC_ClockSecuritySystemCmd+0x8>)
 800119a:	6018      	str	r0, [r3, #0]
}
 800119c:	4770      	bx	lr
 800119e:	bf00      	nop
 80011a0:	4247004c 	.word	0x4247004c

080011a4 <RCC_MCO1Config>:
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
  assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  

  tmpreg = RCC->CFGR;
 80011a4:	4b04      	ldr	r3, [pc, #16]	; (80011b8 <RCC_MCO1Config+0x14>)
 80011a6:	689a      	ldr	r2, [r3, #8]

  /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
  tmpreg &= CFGR_MCO1_RESET_MASK;
 80011a8:	f022 6cec 	bic.w	ip, r2, #123731968	; 0x7600000

  /* Select MCO1 clock source and prescaler */
  tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
 80011ac:	ea40 000c 	orr.w	r0, r0, ip
 80011b0:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 80011b4:	609a      	str	r2, [r3, #8]
}
 80011b6:	4770      	bx	lr
 80011b8:	40023800 	.word	0x40023800

080011bc <RCC_MCO2Config>:
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
  assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
  
  tmpreg = RCC->CFGR;
 80011bc:	4b04      	ldr	r3, [pc, #16]	; (80011d0 <RCC_MCO2Config+0x14>)
 80011be:	689a      	ldr	r2, [r3, #8]
  
  /* Clear MCO2 and MCO2PRE[2:0] bits */
  tmpreg &= CFGR_MCO2_RESET_MASK;
 80011c0:	f022 4c78 	bic.w	ip, r2, #4160749568	; 0xf8000000

  /* Select MCO2 clock source and prescaler */
  tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
 80011c4:	ea40 000c 	orr.w	r0, r0, ip
 80011c8:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 80011cc:	609a      	str	r2, [r3, #8]
}
 80011ce:	4770      	bx	lr
 80011d0:	40023800 	.word	0x40023800

080011d4 <RCC_SYSCLKConfig>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));

  tmpreg = RCC->CFGR;
 80011d4:	4b03      	ldr	r3, [pc, #12]	; (80011e4 <RCC_SYSCLKConfig+0x10>)
 80011d6:	689a      	ldr	r2, [r3, #8]

  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
 80011d8:	f022 0103 	bic.w	r1, r2, #3

  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 80011dc:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80011e0:	609a      	str	r2, [r3, #8]
}
 80011e2:	4770      	bx	lr
 80011e4:	40023800 	.word	0x40023800

080011e8 <RCC_GetSYSCLKSource>:
  *              - 0x04: HSE used as system clock
  *              - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 80011e8:	4b02      	ldr	r3, [pc, #8]	; (80011f4 <RCC_GetSYSCLKSource+0xc>)
 80011ea:	6898      	ldr	r0, [r3, #8]
}
 80011ec:	f000 000c 	and.w	r0, r0, #12
 80011f0:	4770      	bx	lr
 80011f2:	bf00      	nop
 80011f4:	40023800 	.word	0x40023800

080011f8 <RCC_HCLKConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));

  tmpreg = RCC->CFGR;
 80011f8:	4b03      	ldr	r3, [pc, #12]	; (8001208 <RCC_HCLKConfig+0x10>)
 80011fa:	689a      	ldr	r2, [r3, #8]

  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 80011fc:	f022 01f0 	bic.w	r1, r2, #240	; 0xf0

  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8001200:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8001204:	609a      	str	r2, [r3, #8]
}
 8001206:	4770      	bx	lr
 8001208:	40023800 	.word	0x40023800

0800120c <RCC_PCLK1Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 800120c:	4b03      	ldr	r3, [pc, #12]	; (800121c <RCC_PCLK1Config+0x10>)
 800120e:	689a      	ldr	r2, [r3, #8]

  /* Clear PPRE1[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE1;
 8001210:	f422 51e0 	bic.w	r1, r2, #7168	; 0x1c00

  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 8001214:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8001218:	609a      	str	r2, [r3, #8]
}
 800121a:	4770      	bx	lr
 800121c:	40023800 	.word	0x40023800

08001220 <RCC_PCLK2Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 8001220:	4b03      	ldr	r3, [pc, #12]	; (8001230 <RCC_PCLK2Config+0x10>)
 8001222:	689a      	ldr	r2, [r3, #8]

  /* Clear PPRE2[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE2;
 8001224:	f422 4160 	bic.w	r1, r2, #57344	; 0xe000

  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 8001228:	ea41 02c0 	orr.w	r2, r1, r0, lsl #3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800122c:	609a      	str	r2, [r3, #8]
}
 800122e:	4770      	bx	lr
 8001230:	40023800 	.word	0x40023800

08001234 <RCC_GetClocksFreq>:
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8001234:	4a20      	ldr	r2, [pc, #128]	; (80012b8 <RCC_GetClocksFreq+0x84>)
 8001236:	6893      	ldr	r3, [r2, #8]
 8001238:	f003 030c 	and.w	r3, r3, #12

  switch (tmp)
 800123c:	2b04      	cmp	r3, #4
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 800123e:	b410      	push	{r4}
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;

  switch (tmp)
 8001240:	d01d      	beq.n	800127e <RCC_GetClocksFreq+0x4a>
 8001242:	2b08      	cmp	r3, #8
 8001244:	d01e      	beq.n	8001284 <RCC_GetClocksFreq+0x50>

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
      break;
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8001246:	4b1d      	ldr	r3, [pc, #116]	; (80012bc <RCC_GetClocksFreq+0x88>)
 8001248:	6003      	str	r3, [r0, #0]
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 800124a:	491b      	ldr	r1, [pc, #108]	; (80012b8 <RCC_GetClocksFreq+0x84>)
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 800124c:	4a1c      	ldr	r2, [pc, #112]	; (80012c0 <RCC_GetClocksFreq+0x8c>)
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 800124e:	688c      	ldr	r4, [r1, #8]
  tmp = tmp >> 4;
 8001250:	f3c4 1c03 	ubfx	ip, r4, #4, #4
  presc = APBAHBPrescTable[tmp];
 8001254:	f812 400c 	ldrb.w	r4, [r2, ip]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8001258:	40e3      	lsrs	r3, r4
 800125a:	6043      	str	r3, [r0, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 800125c:	688c      	ldr	r4, [r1, #8]
  tmp = tmp >> 10;
 800125e:	f3c4 2c82 	ubfx	ip, r4, #10, #3
  presc = APBAHBPrescTable[tmp];
 8001262:	f812 400c 	ldrb.w	r4, [r2, ip]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8001266:	fa33 f404 	lsrs.w	r4, r3, r4
 800126a:	6084      	str	r4, [r0, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 800126c:	6889      	ldr	r1, [r1, #8]
  tmp = tmp >> 13;
 800126e:	f3c1 3c42 	ubfx	ip, r1, #13, #3
  presc = APBAHBPrescTable[tmp];
 8001272:	f812 200c 	ldrb.w	r2, [r2, ip]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8001276:	40d3      	lsrs	r3, r2
 8001278:	60c3      	str	r3, [r0, #12]
}
 800127a:	bc10      	pop	{r4}
 800127c:	4770      	bx	lr
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 800127e:	4b11      	ldr	r3, [pc, #68]	; (80012c4 <RCC_GetClocksFreq+0x90>)
 8001280:	6003      	str	r3, [r0, #0]
      break;
 8001282:	e7e2      	b.n	800124a <RCC_GetClocksFreq+0x16>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8001284:	6854      	ldr	r4, [r2, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001286:	6851      	ldr	r1, [r2, #4]
      
      if (pllsource != 0)
 8001288:	f414 0f80 	tst.w	r4, #4194304	; 0x400000
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 800128c:	6854      	ldr	r4, [r2, #4]
 800128e:	bf14      	ite	ne
 8001290:	4b0c      	ldrne	r3, [pc, #48]	; (80012c4 <RCC_GetClocksFreq+0x90>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8001292:	4b0a      	ldreq	r3, [pc, #40]	; (80012bc <RCC_GetClocksFreq+0x88>)
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
      
      if (pllsource != 0)
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8001294:	f3c4 1288 	ubfx	r2, r4, #6, #9

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001298:	f001 013f 	and.w	r1, r1, #63	; 0x3f
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 800129c:	4c06      	ldr	r4, [pc, #24]	; (80012b8 <RCC_GetClocksFreq+0x84>)
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 800129e:	fbb3 fcf1 	udiv	ip, r3, r1
 80012a2:	fb0c f102 	mul.w	r1, ip, r2
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 80012a6:	6862      	ldr	r2, [r4, #4]
 80012a8:	f3c2 4301 	ubfx	r3, r2, #16, #2
 80012ac:	1c5c      	adds	r4, r3, #1
 80012ae:	0062      	lsls	r2, r4, #1
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 80012b0:	fbb1 f3f2 	udiv	r3, r1, r2
 80012b4:	6003      	str	r3, [r0, #0]
      break;
 80012b6:	e7c8      	b.n	800124a <RCC_GetClocksFreq+0x16>
 80012b8:	40023800 	.word	0x40023800
 80012bc:	00f42400 	.word	0x00f42400
 80012c0:	20000084 	.word	0x20000084
 80012c4:	017d7840 	.word	0x017d7840

080012c8 <RCC_RTCCLKConfig>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
 80012c8:	f400 7340 	and.w	r3, r0, #768	; 0x300
 80012cc:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80012d0:	d10a      	bne.n	80012e8 <RCC_RTCCLKConfig+0x20>
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;
 80012d2:	4b09      	ldr	r3, [pc, #36]	; (80012f8 <RCC_RTCCLKConfig+0x30>)
 80012d4:	6899      	ldr	r1, [r3, #8]

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 80012d6:	f020 4270 	bic.w	r2, r0, #4026531840	; 0xf0000000
  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;
 80012da:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 80012de:	f422 7c40 	bic.w	ip, r2, #768	; 0x300
 80012e2:	ea4c 0201 	orr.w	r2, ip, r1

    /* Store the new value */
    RCC->CFGR = tmpreg;
 80012e6:	609a      	str	r2, [r3, #8]
  }
    
  /* Select the RTC clock source */
  RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
 80012e8:	4b03      	ldr	r3, [pc, #12]	; (80012f8 <RCC_RTCCLKConfig+0x30>)
 80012ea:	0500      	lsls	r0, r0, #20
 80012ec:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80012ee:	0d01      	lsrs	r1, r0, #20
 80012f0:	ea41 0002 	orr.w	r0, r1, r2
 80012f4:	6718      	str	r0, [r3, #112]	; 0x70
}
 80012f6:	4770      	bx	lr
 80012f8:	40023800 	.word	0x40023800

080012fc <RCC_RTCCLKCmd>:
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 80012fc:	4b01      	ldr	r3, [pc, #4]	; (8001304 <RCC_RTCCLKCmd+0x8>)
 80012fe:	6018      	str	r0, [r3, #0]
}
 8001300:	4770      	bx	lr
 8001302:	bf00      	nop
 8001304:	42470e3c 	.word	0x42470e3c

08001308 <RCC_BackupResetCmd>:
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 8001308:	4b01      	ldr	r3, [pc, #4]	; (8001310 <RCC_BackupResetCmd+0x8>)
 800130a:	6018      	str	r0, [r3, #0]
}
 800130c:	4770      	bx	lr
 800130e:	bf00      	nop
 8001310:	42470e40 	.word	0x42470e40

08001314 <RCC_I2SCLKConfig>:
void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));

  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
 8001314:	4b01      	ldr	r3, [pc, #4]	; (800131c <RCC_I2SCLKConfig+0x8>)
 8001316:	6018      	str	r0, [r3, #0]
}
 8001318:	4770      	bx	lr
 800131a:	bf00      	nop
 800131c:	4247015c 	.word	0x4247015c

08001320 <RCC_AHB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001320:	b929      	cbnz	r1, 800132e <RCC_AHB1PeriphClockCmd+0xe>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 8001322:	4b05      	ldr	r3, [pc, #20]	; (8001338 <RCC_AHB1PeriphClockCmd+0x18>)
 8001324:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001326:	ea22 0100 	bic.w	r1, r2, r0
 800132a:	6319      	str	r1, [r3, #48]	; 0x30
 800132c:	4770      	bx	lr
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 800132e:	4b02      	ldr	r3, [pc, #8]	; (8001338 <RCC_AHB1PeriphClockCmd+0x18>)
 8001330:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001332:	4310      	orrs	r0, r2
 8001334:	6318      	str	r0, [r3, #48]	; 0x30
 8001336:	4770      	bx	lr
 8001338:	40023800 	.word	0x40023800

0800133c <RCC_AHB2PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800133c:	b929      	cbnz	r1, 800134a <RCC_AHB2PeriphClockCmd+0xe>
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2ENR &= ~RCC_AHB2Periph;
 800133e:	4b05      	ldr	r3, [pc, #20]	; (8001354 <RCC_AHB2PeriphClockCmd+0x18>)
 8001340:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001342:	ea22 0100 	bic.w	r1, r2, r0
 8001346:	6359      	str	r1, [r3, #52]	; 0x34
 8001348:	4770      	bx	lr
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
 800134a:	4b02      	ldr	r3, [pc, #8]	; (8001354 <RCC_AHB2PeriphClockCmd+0x18>)
 800134c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800134e:	4310      	orrs	r0, r2
 8001350:	6358      	str	r0, [r3, #52]	; 0x34
 8001352:	4770      	bx	lr
 8001354:	40023800 	.word	0x40023800

08001358 <RCC_AHB3PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001358:	b929      	cbnz	r1, 8001366 <RCC_AHB3PeriphClockCmd+0xe>
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3ENR &= ~RCC_AHB3Periph;
 800135a:	4b05      	ldr	r3, [pc, #20]	; (8001370 <RCC_AHB3PeriphClockCmd+0x18>)
 800135c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800135e:	ea22 0100 	bic.w	r1, r2, r0
 8001362:	6399      	str	r1, [r3, #56]	; 0x38
 8001364:	4770      	bx	lr
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
 8001366:	4b02      	ldr	r3, [pc, #8]	; (8001370 <RCC_AHB3PeriphClockCmd+0x18>)
 8001368:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800136a:	4310      	orrs	r0, r2
 800136c:	6398      	str	r0, [r3, #56]	; 0x38
 800136e:	4770      	bx	lr
 8001370:	40023800 	.word	0x40023800

08001374 <RCC_APB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001374:	b929      	cbnz	r1, 8001382 <RCC_APB1PeriphClockCmd+0xe>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8001376:	4b05      	ldr	r3, [pc, #20]	; (800138c <RCC_APB1PeriphClockCmd+0x18>)
 8001378:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800137a:	ea22 0100 	bic.w	r1, r2, r0
 800137e:	6419      	str	r1, [r3, #64]	; 0x40
 8001380:	4770      	bx	lr
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8001382:	4b02      	ldr	r3, [pc, #8]	; (800138c <RCC_APB1PeriphClockCmd+0x18>)
 8001384:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001386:	4310      	orrs	r0, r2
 8001388:	6418      	str	r0, [r3, #64]	; 0x40
 800138a:	4770      	bx	lr
 800138c:	40023800 	.word	0x40023800

08001390 <RCC_APB2PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001390:	b929      	cbnz	r1, 800139e <RCC_APB2PeriphClockCmd+0xe>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8001392:	4b05      	ldr	r3, [pc, #20]	; (80013a8 <RCC_APB2PeriphClockCmd+0x18>)
 8001394:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001396:	ea22 0100 	bic.w	r1, r2, r0
 800139a:	6459      	str	r1, [r3, #68]	; 0x44
 800139c:	4770      	bx	lr
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 800139e:	4b02      	ldr	r3, [pc, #8]	; (80013a8 <RCC_APB2PeriphClockCmd+0x18>)
 80013a0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80013a2:	4310      	orrs	r0, r2
 80013a4:	6458      	str	r0, [r3, #68]	; 0x44
 80013a6:	4770      	bx	lr
 80013a8:	40023800 	.word	0x40023800

080013ac <RCC_AHB1PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80013ac:	b929      	cbnz	r1, 80013ba <RCC_AHB1PeriphResetCmd+0xe>
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
 80013ae:	4b05      	ldr	r3, [pc, #20]	; (80013c4 <RCC_AHB1PeriphResetCmd+0x18>)
 80013b0:	691a      	ldr	r2, [r3, #16]
 80013b2:	ea22 0100 	bic.w	r1, r2, r0
 80013b6:	6119      	str	r1, [r3, #16]
 80013b8:	4770      	bx	lr
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 80013ba:	4b02      	ldr	r3, [pc, #8]	; (80013c4 <RCC_AHB1PeriphResetCmd+0x18>)
 80013bc:	691a      	ldr	r2, [r3, #16]
 80013be:	4310      	orrs	r0, r2
 80013c0:	6118      	str	r0, [r3, #16]
 80013c2:	4770      	bx	lr
 80013c4:	40023800 	.word	0x40023800

080013c8 <RCC_AHB2PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80013c8:	b929      	cbnz	r1, 80013d6 <RCC_AHB2PeriphResetCmd+0xe>
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2RSTR &= ~RCC_AHB2Periph;
 80013ca:	4b05      	ldr	r3, [pc, #20]	; (80013e0 <RCC_AHB2PeriphResetCmd+0x18>)
 80013cc:	695a      	ldr	r2, [r3, #20]
 80013ce:	ea22 0100 	bic.w	r1, r2, r0
 80013d2:	6159      	str	r1, [r3, #20]
 80013d4:	4770      	bx	lr
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
 80013d6:	4b02      	ldr	r3, [pc, #8]	; (80013e0 <RCC_AHB2PeriphResetCmd+0x18>)
 80013d8:	695a      	ldr	r2, [r3, #20]
 80013da:	4310      	orrs	r0, r2
 80013dc:	6158      	str	r0, [r3, #20]
 80013de:	4770      	bx	lr
 80013e0:	40023800 	.word	0x40023800

080013e4 <RCC_AHB3PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80013e4:	b929      	cbnz	r1, 80013f2 <RCC_AHB3PeriphResetCmd+0xe>
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3RSTR &= ~RCC_AHB3Periph;
 80013e6:	4b05      	ldr	r3, [pc, #20]	; (80013fc <RCC_AHB3PeriphResetCmd+0x18>)
 80013e8:	699a      	ldr	r2, [r3, #24]
 80013ea:	ea22 0100 	bic.w	r1, r2, r0
 80013ee:	6199      	str	r1, [r3, #24]
 80013f0:	4770      	bx	lr
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
 80013f2:	4b02      	ldr	r3, [pc, #8]	; (80013fc <RCC_AHB3PeriphResetCmd+0x18>)
 80013f4:	699a      	ldr	r2, [r3, #24]
 80013f6:	4310      	orrs	r0, r2
 80013f8:	6198      	str	r0, [r3, #24]
 80013fa:	4770      	bx	lr
 80013fc:	40023800 	.word	0x40023800

08001400 <RCC_APB1PeriphResetCmd>:
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001400:	b929      	cbnz	r1, 800140e <RCC_APB1PeriphResetCmd+0xe>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 8001402:	4b05      	ldr	r3, [pc, #20]	; (8001418 <RCC_APB1PeriphResetCmd+0x18>)
 8001404:	6a1a      	ldr	r2, [r3, #32]
 8001406:	ea22 0100 	bic.w	r1, r2, r0
 800140a:	6219      	str	r1, [r3, #32]
 800140c:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 800140e:	4b02      	ldr	r3, [pc, #8]	; (8001418 <RCC_APB1PeriphResetCmd+0x18>)
 8001410:	6a1a      	ldr	r2, [r3, #32]
 8001412:	4310      	orrs	r0, r2
 8001414:	6218      	str	r0, [r3, #32]
 8001416:	4770      	bx	lr
 8001418:	40023800 	.word	0x40023800

0800141c <RCC_APB2PeriphResetCmd>:
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800141c:	b929      	cbnz	r1, 800142a <RCC_APB2PeriphResetCmd+0xe>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 800141e:	4b05      	ldr	r3, [pc, #20]	; (8001434 <RCC_APB2PeriphResetCmd+0x18>)
 8001420:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001422:	ea22 0100 	bic.w	r1, r2, r0
 8001426:	6259      	str	r1, [r3, #36]	; 0x24
 8001428:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 800142a:	4b02      	ldr	r3, [pc, #8]	; (8001434 <RCC_APB2PeriphResetCmd+0x18>)
 800142c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800142e:	4310      	orrs	r0, r2
 8001430:	6258      	str	r0, [r3, #36]	; 0x24
 8001432:	4770      	bx	lr
 8001434:	40023800 	.word	0x40023800

08001438 <RCC_AHB1PeriphClockLPModeCmd>:
void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001438:	b929      	cbnz	r1, 8001446 <RCC_AHB1PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1LPENR &= ~RCC_AHB1Periph;
 800143a:	4b05      	ldr	r3, [pc, #20]	; (8001450 <RCC_AHB1PeriphClockLPModeCmd+0x18>)
 800143c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800143e:	ea22 0100 	bic.w	r1, r2, r0
 8001442:	6519      	str	r1, [r3, #80]	; 0x50
 8001444:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
 8001446:	4b02      	ldr	r3, [pc, #8]	; (8001450 <RCC_AHB1PeriphClockLPModeCmd+0x18>)
 8001448:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800144a:	4310      	orrs	r0, r2
 800144c:	6518      	str	r0, [r3, #80]	; 0x50
 800144e:	4770      	bx	lr
 8001450:	40023800 	.word	0x40023800

08001454 <RCC_AHB2PeriphClockLPModeCmd>:
void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001454:	b929      	cbnz	r1, 8001462 <RCC_AHB2PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2LPENR &= ~RCC_AHB2Periph;
 8001456:	4b05      	ldr	r3, [pc, #20]	; (800146c <RCC_AHB2PeriphClockLPModeCmd+0x18>)
 8001458:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800145a:	ea22 0100 	bic.w	r1, r2, r0
 800145e:	6559      	str	r1, [r3, #84]	; 0x54
 8001460:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
 8001462:	4b02      	ldr	r3, [pc, #8]	; (800146c <RCC_AHB2PeriphClockLPModeCmd+0x18>)
 8001464:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8001466:	4310      	orrs	r0, r2
 8001468:	6558      	str	r0, [r3, #84]	; 0x54
 800146a:	4770      	bx	lr
 800146c:	40023800 	.word	0x40023800

08001470 <RCC_AHB3PeriphClockLPModeCmd>:
void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001470:	b929      	cbnz	r1, 800147e <RCC_AHB3PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3LPENR &= ~RCC_AHB3Periph;
 8001472:	4b05      	ldr	r3, [pc, #20]	; (8001488 <RCC_AHB3PeriphClockLPModeCmd+0x18>)
 8001474:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001476:	ea22 0100 	bic.w	r1, r2, r0
 800147a:	6599      	str	r1, [r3, #88]	; 0x58
 800147c:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
 800147e:	4b02      	ldr	r3, [pc, #8]	; (8001488 <RCC_AHB3PeriphClockLPModeCmd+0x18>)
 8001480:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001482:	4310      	orrs	r0, r2
 8001484:	6598      	str	r0, [r3, #88]	; 0x58
 8001486:	4770      	bx	lr
 8001488:	40023800 	.word	0x40023800

0800148c <RCC_APB1PeriphClockLPModeCmd>:
void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800148c:	b929      	cbnz	r1, 800149a <RCC_APB1PeriphClockLPModeCmd+0xe>
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1LPENR &= ~RCC_APB1Periph;
 800148e:	4b05      	ldr	r3, [pc, #20]	; (80014a4 <RCC_APB1PeriphClockLPModeCmd+0x18>)
 8001490:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001492:	ea22 0100 	bic.w	r1, r2, r0
 8001496:	6619      	str	r1, [r3, #96]	; 0x60
 8001498:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
 800149a:	4b02      	ldr	r3, [pc, #8]	; (80014a4 <RCC_APB1PeriphClockLPModeCmd+0x18>)
 800149c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800149e:	4310      	orrs	r0, r2
 80014a0:	6618      	str	r0, [r3, #96]	; 0x60
 80014a2:	4770      	bx	lr
 80014a4:	40023800 	.word	0x40023800

080014a8 <RCC_APB2PeriphClockLPModeCmd>:
void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80014a8:	b929      	cbnz	r1, 80014b6 <RCC_APB2PeriphClockLPModeCmd+0xe>
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2LPENR &= ~RCC_APB2Periph;
 80014aa:	4b05      	ldr	r3, [pc, #20]	; (80014c0 <RCC_APB2PeriphClockLPModeCmd+0x18>)
 80014ac:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 80014ae:	ea22 0100 	bic.w	r1, r2, r0
 80014b2:	6659      	str	r1, [r3, #100]	; 0x64
 80014b4:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
 80014b6:	4b02      	ldr	r3, [pc, #8]	; (80014c0 <RCC_APB2PeriphClockLPModeCmd+0x18>)
 80014b8:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 80014ba:	4310      	orrs	r0, r2
 80014bc:	6658      	str	r0, [r3, #100]	; 0x64
 80014be:	4770      	bx	lr
 80014c0:	40023800 	.word	0x40023800

080014c4 <RCC_ITConfig>:
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80014c4:	b931      	cbnz	r1, 80014d4 <RCC_ITConfig+0x10>
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
  }
  else
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 80014c6:	4b06      	ldr	r3, [pc, #24]	; (80014e0 <RCC_ITConfig+0x1c>)
 80014c8:	f893 c000 	ldrb.w	ip, [r3]
 80014cc:	ea2c 0100 	bic.w	r1, ip, r0
 80014d0:	7019      	strb	r1, [r3, #0]
 80014d2:	4770      	bx	lr
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 80014d4:	4b02      	ldr	r3, [pc, #8]	; (80014e0 <RCC_ITConfig+0x1c>)
 80014d6:	781a      	ldrb	r2, [r3, #0]
 80014d8:	4310      	orrs	r0, r2
 80014da:	7018      	strb	r0, [r3, #0]
 80014dc:	4770      	bx	lr
 80014de:	bf00      	nop
 80014e0:	4002380d 	.word	0x4002380d

080014e4 <RCC_GetFlagStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 80014e4:	0943      	lsrs	r3, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 80014e6:	2b01      	cmp	r3, #1
 80014e8:	d00b      	beq.n	8001502 <RCC_GetFlagStatus+0x1e>
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 80014ea:	2b02      	cmp	r3, #2
  {
    statusreg = RCC->BDCR;
 80014ec:	4b09      	ldr	r3, [pc, #36]	; (8001514 <RCC_GetFlagStatus+0x30>)
 80014ee:	bf0c      	ite	eq
 80014f0:	6f1b      	ldreq	r3, [r3, #112]	; 0x70
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 80014f2:	6f5b      	ldrne	r3, [r3, #116]	; 0x74
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
 80014f4:	f000 011f 	and.w	r1, r0, #31
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 80014f8:	fa33 f001 	lsrs.w	r0, r3, r1
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 80014fc:	f000 0001 	and.w	r0, r0, #1
 8001500:	4770      	bx	lr

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 8001502:	4b04      	ldr	r3, [pc, #16]	; (8001514 <RCC_GetFlagStatus+0x30>)
 8001504:	681b      	ldr	r3, [r3, #0]
  {
    statusreg = RCC->CSR;
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
 8001506:	f000 011f 	and.w	r1, r0, #31
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 800150a:	fa33 f001 	lsrs.w	r0, r3, r1
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 800150e:	f000 0001 	and.w	r0, r0, #1
 8001512:	4770      	bx	lr
 8001514:	40023800 	.word	0x40023800

08001518 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 8001518:	b500      	push	{lr}
 800151a:	b083      	sub	sp, #12
  __IO uint32_t startupcounter = 0;
 800151c:	2300      	movs	r3, #0
 800151e:	9301      	str	r3, [sp, #4]
 8001520:	e000      	b.n	8001524 <RCC_WaitForHSEStartUp+0xc>
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    startupcounter++;
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 8001522:	b948      	cbnz	r0, 8001538 <RCC_WaitForHSEStartUp+0x20>
  ErrorStatus status = ERROR;
  FlagStatus hsestatus = RESET;
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 8001524:	2031      	movs	r0, #49	; 0x31
 8001526:	f7ff ffdd 	bl	80014e4 <RCC_GetFlagStatus>
    startupcounter++;
 800152a:	9b01      	ldr	r3, [sp, #4]
 800152c:	1c5a      	adds	r2, r3, #1
 800152e:	9201      	str	r2, [sp, #4]
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 8001530:	9901      	ldr	r1, [sp, #4]
 8001532:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
 8001536:	d1f4      	bne.n	8001522 <RCC_WaitForHSEStartUp+0xa>

  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 8001538:	2031      	movs	r0, #49	; 0x31
 800153a:	f7ff ffd3 	bl	80014e4 <RCC_GetFlagStatus>
  else
  {
    status = ERROR;
  }
  return (status);
}
 800153e:	3800      	subs	r0, #0
 8001540:	bf18      	it	ne
 8001542:	2001      	movne	r0, #1
 8001544:	b003      	add	sp, #12
 8001546:	bd00      	pop	{pc}

08001548 <RCC_ClearFlag>:
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= RCC_CSR_RMVF;
 8001548:	4b02      	ldr	r3, [pc, #8]	; (8001554 <RCC_ClearFlag+0xc>)
 800154a:	6f58      	ldr	r0, [r3, #116]	; 0x74
 800154c:	f040 7280 	orr.w	r2, r0, #16777216	; 0x1000000
 8001550:	675a      	str	r2, [r3, #116]	; 0x74
}
 8001552:	4770      	bx	lr
 8001554:	40023800 	.word	0x40023800

08001558 <RCC_GetITStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 8001558:	4903      	ldr	r1, [pc, #12]	; (8001568 <RCC_GetITStatus+0x10>)
 800155a:	68cb      	ldr	r3, [r1, #12]
  {
    bitstatus = SET;
 800155c:	4218      	tst	r0, r3
  {
    bitstatus = RESET;
  }
  /* Return the RCC_IT status */
  return  bitstatus;
}
 800155e:	bf0c      	ite	eq
 8001560:	2000      	moveq	r0, #0
 8001562:	2001      	movne	r0, #1
 8001564:	4770      	bx	lr
 8001566:	bf00      	nop
 8001568:	40023800 	.word	0x40023800

0800156c <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 800156c:	4b01      	ldr	r3, [pc, #4]	; (8001574 <RCC_ClearITPendingBit+0x8>)
 800156e:	7018      	strb	r0, [r3, #0]
}
 8001570:	4770      	bx	lr
 8001572:	bf00      	nop
 8001574:	4002380e 	.word	0x4002380e

08001578 <EXTI_DeInit>:
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR = 0x00000000;
 8001578:	4b04      	ldr	r3, [pc, #16]	; (800158c <EXTI_DeInit+0x14>)
  EXTI->EMR = 0x00000000;
  EXTI->RTSR = 0x00000000;
  EXTI->FTSR = 0x00000000;
  EXTI->PR = 0x007FFFFF;
 800157a:	4a05      	ldr	r2, [pc, #20]	; (8001590 <EXTI_DeInit+0x18>)
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR = 0x00000000;
 800157c:	2000      	movs	r0, #0
 800157e:	6018      	str	r0, [r3, #0]
  EXTI->EMR = 0x00000000;
 8001580:	6058      	str	r0, [r3, #4]
  EXTI->RTSR = 0x00000000;
 8001582:	6098      	str	r0, [r3, #8]
  EXTI->FTSR = 0x00000000;
 8001584:	60d8      	str	r0, [r3, #12]
  EXTI->PR = 0x007FFFFF;
 8001586:	615a      	str	r2, [r3, #20]
}
 8001588:	4770      	bx	lr
 800158a:	bf00      	nop
 800158c:	40013c00 	.word	0x40013c00
 8001590:	007fffff 	.word	0x007fffff

08001594 <EXTI_Init>:
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8001594:	7983      	ldrb	r3, [r0, #6]
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
  *         that contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 8001596:	b470      	push	{r4, r5, r6}
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8001598:	b343      	cbz	r3, 80015ec <EXTI_Init+0x58>
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 800159a:	4b20      	ldr	r3, [pc, #128]	; (800161c <EXTI_Init+0x88>)
 800159c:	6801      	ldr	r1, [r0, #0]
 800159e:	681e      	ldr	r6, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 80015a0:	7902      	ldrb	r2, [r0, #4]
    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 80015a2:	7945      	ldrb	r5, [r0, #5]
  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 80015a4:	43cc      	mvns	r4, r1
 80015a6:	ea04 0606 	and.w	r6, r4, r6
 80015aa:	601e      	str	r6, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 80015ac:	685e      	ldr	r6, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 80015ae:	f102 4c80 	add.w	ip, r2, #1073741824	; 0x40000000
 80015b2:	f50c 329e 	add.w	r2, ip, #80896	; 0x13c00
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 80015b6:	4034      	ands	r4, r6
 80015b8:	605c      	str	r4, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80015ba:	6814      	ldr	r4, [r2, #0]
 80015bc:	ea44 0101 	orr.w	r1, r4, r1
 80015c0:	6011      	str	r1, [r2, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 80015c2:	6802      	ldr	r2, [r0, #0]
 80015c4:	6898      	ldr	r0, [r3, #8]
 80015c6:	43d1      	mvns	r1, r2
 80015c8:	ea01 0000 	and.w	r0, r1, r0
 80015cc:	6098      	str	r0, [r3, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 80015ce:	68d8      	ldr	r0, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 80015d0:	2d10      	cmp	r5, #16

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 80015d2:	ea01 0100 	and.w	r1, r1, r0
 80015d6:	60d9      	str	r1, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 80015d8:	d016      	beq.n	8001608 <EXTI_Init+0x74>
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
    }
    else
    {
      tmp = (uint32_t)EXTI_BASE;
      tmp += EXTI_InitStruct->EXTI_Trigger;
 80015da:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 80015de:	f505 359e 	add.w	r5, r5, #80896	; 0x13c00

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80015e2:	6828      	ldr	r0, [r5, #0]
 80015e4:	ea40 0302 	orr.w	r3, r0, r2
 80015e8:	602b      	str	r3, [r5, #0]
 80015ea:	e00b      	b.n	8001604 <EXTI_Init+0x70>
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 80015ec:	7902      	ldrb	r2, [r0, #4]

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 80015ee:	6801      	ldr	r1, [r0, #0]
      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 80015f0:	f102 4080 	add.w	r0, r2, #1073741824	; 0x40000000
 80015f4:	f500 3c9e 	add.w	ip, r0, #80896	; 0x13c00

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 80015f8:	f8dc 3000 	ldr.w	r3, [ip]
 80015fc:	ea23 0201 	bic.w	r2, r3, r1
 8001600:	f8cc 2000 	str.w	r2, [ip]
  }
}
 8001604:	bc70      	pop	{r4, r5, r6}
 8001606:	4770      	bx	lr
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 8001608:	6899      	ldr	r1, [r3, #8]
 800160a:	ea41 0002 	orr.w	r0, r1, r2
 800160e:	6098      	str	r0, [r3, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 8001610:	68d9      	ldr	r1, [r3, #12]
 8001612:	ea41 0002 	orr.w	r0, r1, r2
 8001616:	60d8      	str	r0, [r3, #12]
 8001618:	e7f4      	b.n	8001604 <EXTI_Init+0x70>
 800161a:	bf00      	nop
 800161c:	40013c00 	.word	0x40013c00

08001620 <EXTI_StructInit>:
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 8001620:	2300      	movs	r3, #0
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 8001622:	220c      	movs	r2, #12
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 8001624:	6003      	str	r3, [r0, #0]
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
 8001626:	7103      	strb	r3, [r0, #4]
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 8001628:	7142      	strb	r2, [r0, #5]
  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
 800162a:	7183      	strb	r3, [r0, #6]
}
 800162c:	4770      	bx	lr
 800162e:	bf00      	nop

08001630 <EXTI_GenerateSWInterrupt>:
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->SWIER |= EXTI_Line;
 8001630:	4b02      	ldr	r3, [pc, #8]	; (800163c <EXTI_GenerateSWInterrupt+0xc>)
 8001632:	6919      	ldr	r1, [r3, #16]
 8001634:	ea40 0201 	orr.w	r2, r0, r1
 8001638:	611a      	str	r2, [r3, #16]
}
 800163a:	4770      	bx	lr
 800163c:	40013c00 	.word	0x40013c00

08001640 <EXTI_GetFlagStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
 8001640:	4903      	ldr	r1, [pc, #12]	; (8001650 <EXTI_GetFlagStatus+0x10>)
 8001642:	694b      	ldr	r3, [r1, #20]
  {
    bitstatus = SET;
 8001644:	4218      	tst	r0, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8001646:	bf0c      	ite	eq
 8001648:	2000      	moveq	r0, #0
 800164a:	2001      	movne	r0, #1
 800164c:	4770      	bx	lr
 800164e:	bf00      	nop
 8001650:	40013c00 	.word	0x40013c00

08001654 <EXTI_ClearFlag>:
void EXTI_ClearFlag(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 8001654:	4b01      	ldr	r3, [pc, #4]	; (800165c <EXTI_ClearFlag+0x8>)
 8001656:	6158      	str	r0, [r3, #20]
}
 8001658:	4770      	bx	lr
 800165a:	bf00      	nop
 800165c:	40013c00 	.word	0x40013c00

08001660 <EXTI_GetITStatus>:
  ITStatus bitstatus = RESET;
  uint32_t enablestatus = 0;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  EXTI->IMR & EXTI_Line;
 8001660:	4905      	ldr	r1, [pc, #20]	; (8001678 <EXTI_GetITStatus+0x18>)
 8001662:	680a      	ldr	r2, [r1, #0]
  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 8001664:	694b      	ldr	r3, [r1, #20]
 8001666:	4003      	ands	r3, r0
 8001668:	d004      	beq.n	8001674 <EXTI_GetITStatus+0x14>
  {
    bitstatus = SET;
 800166a:	4210      	tst	r0, r2
 800166c:	bf0c      	ite	eq
 800166e:	2000      	moveq	r0, #0
 8001670:	2001      	movne	r0, #1
 8001672:	4770      	bx	lr
  }
  else
  {
    bitstatus = RESET;
 8001674:	4618      	mov	r0, r3
  }
  return bitstatus;
}
 8001676:	4770      	bx	lr
 8001678:	40013c00 	.word	0x40013c00

0800167c <EXTI_ClearITPendingBit>:
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 800167c:	4b01      	ldr	r3, [pc, #4]	; (8001684 <EXTI_ClearITPendingBit+0x8>)
 800167e:	6158      	str	r0, [r3, #20]
}
 8001680:	4770      	bx	lr
 8001682:	bf00      	nop
 8001684:	40013c00 	.word	0x40013c00

08001688 <GPIO_DeInit>:
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
 8001688:	4b3c      	ldr	r3, [pc, #240]	; (800177c <GPIO_DeInit+0xf4>)
 800168a:	4298      	cmp	r0, r3
  * @note   By default, The GPIO pins are configured in input floating mode (except JTAG pins).
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 800168c:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
 800168e:	d024      	beq.n	80016da <GPIO_DeInit+0x52>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
 8001690:	493b      	ldr	r1, [pc, #236]	; (8001780 <GPIO_DeInit+0xf8>)
 8001692:	4288      	cmp	r0, r1
 8001694:	d02b      	beq.n	80016ee <GPIO_DeInit+0x66>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
 8001696:	4a3b      	ldr	r2, [pc, #236]	; (8001784 <GPIO_DeInit+0xfc>)
 8001698:	4290      	cmp	r0, r2
 800169a:	d032      	beq.n	8001702 <GPIO_DeInit+0x7a>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
 800169c:	4b3a      	ldr	r3, [pc, #232]	; (8001788 <GPIO_DeInit+0x100>)
 800169e:	4298      	cmp	r0, r3
 80016a0:	d039      	beq.n	8001716 <GPIO_DeInit+0x8e>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
  }
  else if (GPIOx == GPIOE)
 80016a2:	493a      	ldr	r1, [pc, #232]	; (800178c <GPIO_DeInit+0x104>)
 80016a4:	4288      	cmp	r0, r1
 80016a6:	d040      	beq.n	800172a <GPIO_DeInit+0xa2>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
  }
  else if (GPIOx == GPIOF)
 80016a8:	4a39      	ldr	r2, [pc, #228]	; (8001790 <GPIO_DeInit+0x108>)
 80016aa:	4290      	cmp	r0, r2
 80016ac:	d047      	beq.n	800173e <GPIO_DeInit+0xb6>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
  }
  else if (GPIOx == GPIOG)
 80016ae:	4b39      	ldr	r3, [pc, #228]	; (8001794 <GPIO_DeInit+0x10c>)
 80016b0:	4298      	cmp	r0, r3
 80016b2:	d04e      	beq.n	8001752 <GPIO_DeInit+0xca>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
  }
  else if (GPIOx == GPIOH)
 80016b4:	4938      	ldr	r1, [pc, #224]	; (8001798 <GPIO_DeInit+0x110>)
 80016b6:	4288      	cmp	r0, r1
 80016b8:	d055      	beq.n	8001766 <GPIO_DeInit+0xde>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
  }
  else
  {
    if (GPIOx == GPIOI)
 80016ba:	4a38      	ldr	r2, [pc, #224]	; (800179c <GPIO_DeInit+0x114>)
 80016bc:	4290      	cmp	r0, r2
 80016be:	d000      	beq.n	80016c2 <GPIO_DeInit+0x3a>
 80016c0:	bd10      	pop	{r4, pc}
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
 80016c2:	2101      	movs	r1, #1
 80016c4:	f44f 7080 	mov.w	r0, #256	; 0x100
 80016c8:	f7ff fe70 	bl	80013ac <RCC_AHB1PeriphResetCmd>
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 80016cc:	f44f 7080 	mov.w	r0, #256	; 0x100
 80016d0:	2100      	movs	r1, #0
    }
  }
}
 80016d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  else
  {
    if (GPIOx == GPIOI)
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 80016d6:	f7ff be69 	b.w	80013ac <RCC_AHB1PeriphResetCmd>
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 80016da:	2001      	movs	r0, #1
 80016dc:	4601      	mov	r1, r0
 80016de:	f7ff fe65 	bl	80013ac <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
 80016e2:	2001      	movs	r0, #1
 80016e4:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80016e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
 80016ea:	f7ff be5f 	b.w	80013ac <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOB)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 80016ee:	2002      	movs	r0, #2
 80016f0:	2101      	movs	r1, #1
 80016f2:	f7ff fe5b 	bl	80013ac <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
 80016f6:	2002      	movs	r0, #2
 80016f8:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80016fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
 80016fe:	f7ff be55 	b.w	80013ac <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOC)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 8001702:	2004      	movs	r0, #4
 8001704:	2101      	movs	r1, #1
 8001706:	f7ff fe51 	bl	80013ac <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
 800170a:	2004      	movs	r0, #4
 800170c:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 800170e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
 8001712:	f7ff be4b 	b.w	80013ac <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOD)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 8001716:	2008      	movs	r0, #8
 8001718:	2101      	movs	r1, #1
 800171a:	f7ff fe47 	bl	80013ac <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
 800171e:	2008      	movs	r0, #8
 8001720:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 8001722:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
 8001726:	f7ff be41 	b.w	80013ac <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOE)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
 800172a:	2010      	movs	r0, #16
 800172c:	2101      	movs	r1, #1
 800172e:	f7ff fe3d 	bl	80013ac <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
 8001732:	2010      	movs	r0, #16
 8001734:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 8001736:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
  }
  else if (GPIOx == GPIOE)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
 800173a:	f7ff be37 	b.w	80013ac <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOF)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
 800173e:	2020      	movs	r0, #32
 8001740:	2101      	movs	r1, #1
 8001742:	f7ff fe33 	bl	80013ac <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
 8001746:	2020      	movs	r0, #32
 8001748:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 800174a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
  }
  else if (GPIOx == GPIOF)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
 800174e:	f7ff be2d 	b.w	80013ac <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOG)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
 8001752:	2040      	movs	r0, #64	; 0x40
 8001754:	2101      	movs	r1, #1
 8001756:	f7ff fe29 	bl	80013ac <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
 800175a:	2040      	movs	r0, #64	; 0x40
 800175c:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 800175e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
  }
  else if (GPIOx == GPIOG)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
 8001762:	f7ff be23 	b.w	80013ac <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOH)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
 8001766:	2080      	movs	r0, #128	; 0x80
 8001768:	2101      	movs	r1, #1
 800176a:	f7ff fe1f 	bl	80013ac <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
 800176e:	2080      	movs	r0, #128	; 0x80
 8001770:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 8001772:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
  }
  else if (GPIOx == GPIOH)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
 8001776:	f7ff be19 	b.w	80013ac <RCC_AHB1PeriphResetCmd>
 800177a:	bf00      	nop
 800177c:	40020000 	.word	0x40020000
 8001780:	40020400 	.word	0x40020400
 8001784:	40020800 	.word	0x40020800
 8001788:	40020c00 	.word	0x40020c00
 800178c:	40021000 	.word	0x40021000
 8001790:	40021400 	.word	0x40021400
 8001794:	40021800 	.word	0x40021800
 8001798:	40021c00 	.word	0x40021c00
 800179c:	40022000 	.word	0x40022000

080017a0 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 80017a0:	2300      	movs	r3, #0
 80017a2:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80017a6:	680a      	ldr	r2, [r1, #0]
 80017a8:	461c      	mov	r4, r3
  {
    pos = ((uint32_t)0x01) << pinpos;
 80017aa:	2601      	movs	r6, #1
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80017ac:	f04f 0c03 	mov.w	ip, #3
 80017b0:	e00b      	b.n	80017ca <GPIO_Init+0x2a>
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80017b2:	3401      	adds	r4, #1
  {
    pos = ((uint32_t)0x01) << pinpos;
 80017b4:	fa16 f504 	lsls.w	r5, r6, r4
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80017b8:	ea05 0702 	and.w	r7, r5, r2
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80017bc:	3302      	adds	r3, #2
  {
    pos = ((uint32_t)0x01) << pinpos;
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
 80017be:	42af      	cmp	r7, r5
 80017c0:	d035      	beq.n	800182e <GPIO_Init+0x8e>
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80017c2:	3401      	adds	r4, #1
 80017c4:	3302      	adds	r3, #2
 80017c6:	2c10      	cmp	r4, #16
 80017c8:	d05a      	beq.n	8001880 <GPIO_Init+0xe0>
  {
    pos = ((uint32_t)0x01) << pinpos;
 80017ca:	fa16 f504 	lsls.w	r5, r6, r4
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80017ce:	ea05 0702 	and.w	r7, r5, r2

    if (currentpin == pos)
 80017d2:	42af      	cmp	r7, r5
 80017d4:	d1ed      	bne.n	80017b2 <GPIO_Init+0x12>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80017d6:	f8d0 9000 	ldr.w	r9, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80017da:	f891 8004 	ldrb.w	r8, [r1, #4]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80017de:	fa0c f503 	lsl.w	r5, ip, r3
 80017e2:	43ed      	mvns	r5, r5
 80017e4:	ea05 0a09 	and.w	sl, r5, r9
 80017e8:	f8c0 a000 	str.w	sl, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80017ec:	f8d0 9000 	ldr.w	r9, [r0]
 80017f0:	fa08 fa03 	lsl.w	sl, r8, r3

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80017f4:	f108 38ff 	add.w	r8, r8, #4294967295
 80017f8:	fa5f f888 	uxtb.w	r8, r8
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80017fc:	ea4a 0909 	orr.w	r9, sl, r9

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8001800:	f1b8 0f01 	cmp.w	r8, #1
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8001804:	f8c0 9000 	str.w	r9, [r0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8001808:	d93d      	bls.n	8001886 <GPIO_Init+0xe6>
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 800180a:	68c7      	ldr	r7, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 800180c:	f891 8007 	ldrb.w	r8, [r1, #7]
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8001810:	403d      	ands	r5, r7
 8001812:	60c5      	str	r5, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8001814:	68c7      	ldr	r7, [r0, #12]
 8001816:	fa08 f503 	lsl.w	r5, r8, r3
 800181a:	433d      	orrs	r5, r7
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800181c:	3401      	adds	r4, #1
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 800181e:	60c5      	str	r5, [r0, #12]

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
  {
    pos = ((uint32_t)0x01) << pinpos;
 8001820:	fa16 f504 	lsls.w	r5, r6, r4
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8001824:	ea05 0702 	and.w	r7, r5, r2
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8001828:	3302      	adds	r3, #2
  {
    pos = ((uint32_t)0x01) << pinpos;
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
 800182a:	42af      	cmp	r7, r5
 800182c:	d1c9      	bne.n	80017c2 <GPIO_Init+0x22>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 800182e:	f8d0 9000 	ldr.w	r9, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8001832:	f891 8004 	ldrb.w	r8, [r1, #4]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8001836:	fa0c f503 	lsl.w	r5, ip, r3
 800183a:	43ed      	mvns	r5, r5
 800183c:	ea05 0a09 	and.w	sl, r5, r9
 8001840:	f8c0 a000 	str.w	sl, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8001844:	f8d0 9000 	ldr.w	r9, [r0]
 8001848:	fa08 fa03 	lsl.w	sl, r8, r3

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 800184c:	f108 38ff 	add.w	r8, r8, #4294967295
 8001850:	fa5f f888 	uxtb.w	r8, r8
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8001854:	ea4a 0909 	orr.w	r9, sl, r9

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8001858:	f1b8 0f01 	cmp.w	r8, #1
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 800185c:	f8c0 9000 	str.w	r9, [r0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8001860:	d931      	bls.n	80018c6 <GPIO_Init+0x126>
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8001862:	68c7      	ldr	r7, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8001864:	f891 8007 	ldrb.w	r8, [r1, #7]
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8001868:	ea05 0707 	and.w	r7, r5, r7
 800186c:	60c7      	str	r7, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 800186e:	68c7      	ldr	r7, [r0, #12]
 8001870:	fa08 f503 	lsl.w	r5, r8, r3
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8001874:	3401      	adds	r4, #1
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8001876:	433d      	orrs	r5, r7
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8001878:	3302      	adds	r3, #2
 800187a:	2c10      	cmp	r4, #16
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 800187c:	60c5      	str	r5, [r0, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800187e:	d1a4      	bne.n	80017ca <GPIO_Init+0x2a>
      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 8001880:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8001884:	4770      	bx	lr
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8001886:	f8d0 a008 	ldr.w	sl, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 800188a:	f891 9005 	ldrb.w	r9, [r1, #5]
        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 800188e:	f891 8006 	ldrb.w	r8, [r1, #6]
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8001892:	ea05 0a0a 	and.w	sl, r5, sl
 8001896:	f8c0 a008 	str.w	sl, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 800189a:	f8d0 a008 	ldr.w	sl, [r0, #8]
 800189e:	fa09 f903 	lsl.w	r9, r9, r3
 80018a2:	ea49 090a 	orr.w	r9, r9, sl
 80018a6:	f8c0 9008 	str.w	r9, [r0, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 80018aa:	f8d0 9004 	ldr.w	r9, [r0, #4]
 80018ae:	ea29 0707 	bic.w	r7, r9, r7
 80018b2:	6047      	str	r7, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 80018b4:	6847      	ldr	r7, [r0, #4]
 80018b6:	fa08 f804 	lsl.w	r8, r8, r4
 80018ba:	fa1f f888 	uxth.w	r8, r8
 80018be:	ea48 0707 	orr.w	r7, r8, r7
 80018c2:	6047      	str	r7, [r0, #4]
 80018c4:	e7a1      	b.n	800180a <GPIO_Init+0x6a>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 80018c6:	f8d0 a008 	ldr.w	sl, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 80018ca:	f891 9005 	ldrb.w	r9, [r1, #5]
        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 80018ce:	f891 8006 	ldrb.w	r8, [r1, #6]
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 80018d2:	ea05 0a0a 	and.w	sl, r5, sl
 80018d6:	f8c0 a008 	str.w	sl, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 80018da:	f8d0 a008 	ldr.w	sl, [r0, #8]
 80018de:	fa09 f903 	lsl.w	r9, r9, r3
 80018e2:	ea49 090a 	orr.w	r9, r9, sl
 80018e6:	f8c0 9008 	str.w	r9, [r0, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 80018ea:	f8d0 9004 	ldr.w	r9, [r0, #4]
 80018ee:	ea29 0707 	bic.w	r7, r9, r7
 80018f2:	6047      	str	r7, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 80018f4:	6847      	ldr	r7, [r0, #4]
 80018f6:	fa08 f804 	lsl.w	r8, r8, r4
 80018fa:	fa1f f888 	uxth.w	r8, r8
 80018fe:	ea48 0707 	orr.w	r7, r8, r7
 8001902:	6047      	str	r7, [r0, #4]
 8001904:	e7ad      	b.n	8001862 <GPIO_Init+0xc2>
 8001906:	bf00      	nop

08001908 <GPIO_StructInit>:
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 8001908:	2300      	movs	r3, #0
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 800190a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800190e:	6002      	str	r2, [r0, #0]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 8001910:	7103      	strb	r3, [r0, #4]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8001912:	7143      	strb	r3, [r0, #5]
  GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
 8001914:	7183      	strb	r3, [r0, #6]
  GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
 8001916:	71c3      	strb	r3, [r0, #7]
}
 8001918:	4770      	bx	lr
 800191a:	bf00      	nop

0800191c <GPIO_PinLockConfig>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800191c:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0x00010000;
 800191e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8001922:	9201      	str	r2, [sp, #4]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  tmp |= GPIO_Pin;
 8001924:	9b01      	ldr	r3, [sp, #4]
 8001926:	ea41 0203 	orr.w	r2, r1, r3
 800192a:	9201      	str	r2, [sp, #4]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 800192c:	9b01      	ldr	r3, [sp, #4]
 800192e:	61c3      	str	r3, [r0, #28]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 8001930:	61c1      	str	r1, [r0, #28]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8001932:	9a01      	ldr	r2, [sp, #4]
 8001934:	61c2      	str	r2, [r0, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8001936:	69c1      	ldr	r1, [r0, #28]
 8001938:	9101      	str	r1, [sp, #4]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 800193a:	69c3      	ldr	r3, [r0, #28]
 800193c:	9301      	str	r3, [sp, #4]
}
 800193e:	b002      	add	sp, #8
 8001940:	4770      	bx	lr
 8001942:	bf00      	nop

08001944 <GPIO_ReadInputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8001944:	6903      	ldr	r3, [r0, #16]
  {
    bitstatus = (uint8_t)Bit_SET;
 8001946:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 8001948:	bf0c      	ite	eq
 800194a:	2000      	moveq	r0, #0
 800194c:	2001      	movne	r0, #1
 800194e:	4770      	bx	lr

08001950 <GPIO_ReadInputData>:
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->IDR);
 8001950:	6900      	ldr	r0, [r0, #16]
}
 8001952:	b280      	uxth	r0, r0
 8001954:	4770      	bx	lr
 8001956:	bf00      	nop

08001958 <GPIO_ReadOutputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8001958:	6943      	ldr	r3, [r0, #20]
  {
    bitstatus = (uint8_t)Bit_SET;
 800195a:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 800195c:	bf0c      	ite	eq
 800195e:	2000      	moveq	r0, #0
 8001960:	2001      	movne	r0, #1
 8001962:	4770      	bx	lr

08001964 <GPIO_ReadOutputData>:
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->ODR);
 8001964:	6940      	ldr	r0, [r0, #20]
}
 8001966:	b280      	uxth	r0, r0
 8001968:	4770      	bx	lr
 800196a:	bf00      	nop

0800196c <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRL = GPIO_Pin;
 800196c:	8301      	strh	r1, [r0, #24]
}
 800196e:	4770      	bx	lr

08001970 <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRH = GPIO_Pin;
 8001970:	8341      	strh	r1, [r0, #26]
}
 8001972:	4770      	bx	lr

08001974 <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
 8001974:	b90a      	cbnz	r2, 800197a <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRRL = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRRH = GPIO_Pin ;
 8001976:	8341      	strh	r1, [r0, #26]
 8001978:	4770      	bx	lr
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
  {
    GPIOx->BSRRL = GPIO_Pin;
 800197a:	8301      	strh	r1, [r0, #24]
 800197c:	4770      	bx	lr
 800197e:	bf00      	nop

08001980 <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR = PortVal;
 8001980:	6141      	str	r1, [r0, #20]
}
 8001982:	4770      	bx	lr

08001984 <GPIO_ToggleBits>:
void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR ^= GPIO_Pin;
 8001984:	6942      	ldr	r2, [r0, #20]
 8001986:	ea81 0302 	eor.w	r3, r1, r2
 800198a:	6143      	str	r3, [r0, #20]
}
 800198c:	4770      	bx	lr
 800198e:	bf00      	nop

08001990 <GPIO_PinAFConfig>:
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8001990:	08cb      	lsrs	r3, r1, #3
 8001992:	3308      	adds	r3, #8
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8001994:	f001 0107 	and.w	r1, r1, #7
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8001998:	b430      	push	{r4, r5}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 800199a:	0089      	lsls	r1, r1, #2
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 800199c:	f850 5023 	ldr.w	r5, [r0, r3, lsl #2]
 80019a0:	240f      	movs	r4, #15
 80019a2:	408c      	lsls	r4, r1
 80019a4:	ea25 0404 	bic.w	r4, r5, r4
 80019a8:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 80019ac:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 80019b0:	fa12 f101 	lsls.w	r1, r2, r1
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 80019b4:	ea41 0404 	orr.w	r4, r1, r4
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 80019b8:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
}
 80019bc:	bc30      	pop	{r4, r5}
 80019be:	4770      	bx	lr

080019c0 <usbd_cdc_EP0_RxReady>:
  *         Data received on control endpoint
  * @param  pdev: device device instance
  * @retval status
  */
static uint8_t  usbd_cdc_EP0_RxReady (void  *pdev)
{ 
 80019c0:	b510      	push	{r4, lr}
  if (cdcCmd != NO_CMD)
 80019c2:	4c07      	ldr	r4, [pc, #28]	; (80019e0 <usbd_cdc_EP0_RxReady+0x20>)
 80019c4:	6820      	ldr	r0, [r4, #0]
 80019c6:	28ff      	cmp	r0, #255	; 0xff
 80019c8:	d007      	beq.n	80019da <usbd_cdc_EP0_RxReady+0x1a>
  {
    /* Process the data */
    APP_FOPS.pIf_Ctrl(cdcCmd, CmdBuff, cdcLen);
 80019ca:	4906      	ldr	r1, [pc, #24]	; (80019e4 <usbd_cdc_EP0_RxReady+0x24>)
 80019cc:	4a06      	ldr	r2, [pc, #24]	; (80019e8 <usbd_cdc_EP0_RxReady+0x28>)
 80019ce:	688b      	ldr	r3, [r1, #8]
 80019d0:	6812      	ldr	r2, [r2, #0]
 80019d2:	4906      	ldr	r1, [pc, #24]	; (80019ec <usbd_cdc_EP0_RxReady+0x2c>)
 80019d4:	4798      	blx	r3
    
    /* Reset the command variable to default value */
    cdcCmd = NO_CMD;
 80019d6:	23ff      	movs	r3, #255	; 0xff
 80019d8:	6023      	str	r3, [r4, #0]
  }
  
  return USBD_OK;
}
 80019da:	2000      	movs	r0, #0
 80019dc:	bd10      	pop	{r4, pc}
 80019de:	bf00      	nop
 80019e0:	20000094 	.word	0x20000094
 80019e4:	20000140 	.word	0x20000140
 80019e8:	20000e1c 	.word	0x20000e1c
 80019ec:	200021c8 	.word	0x200021c8

080019f0 <USBD_cdc_GetCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_cdc_GetCfgDesc (uint8_t speed, uint16_t *length)
{
  *length = sizeof (usbd_cdc_CfgDesc);
 80019f0:	2343      	movs	r3, #67	; 0x43
 80019f2:	800b      	strh	r3, [r1, #0]
  return usbd_cdc_CfgDesc;
}
 80019f4:	4800      	ldr	r0, [pc, #0]	; (80019f8 <USBD_cdc_GetCfgDesc+0x8>)
 80019f6:	4770      	bx	lr
 80019f8:	20000098 	.word	0x20000098

080019fc <usbd_cdc_SOF>:
  * @param  pdev: instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  usbd_cdc_SOF (void *pdev)
{      
 80019fc:	b538      	push	{r3, r4, r5, lr}
  static uint32_t FrameCount = 0;
  
  if (FrameCount++ == CDC_IN_FRAME_INTERVAL)
 80019fe:	4c1f      	ldr	r4, [pc, #124]	; (8001a7c <usbd_cdc_SOF+0x80>)
 8001a00:	6863      	ldr	r3, [r4, #4]
 8001a02:	1c5a      	adds	r2, r3, #1
 8001a04:	2b05      	cmp	r3, #5
 8001a06:	6062      	str	r2, [r4, #4]
 8001a08:	d001      	beq.n	8001a0e <usbd_cdc_SOF+0x12>
    /* Check the data to be sent through IN pipe */
    Handle_USBAsynchXfer(pdev);
  }
  
  return USBD_OK;
}
 8001a0a:	2000      	movs	r0, #0
 8001a0c:	bd38      	pop	{r3, r4, r5, pc}
static void Handle_USBAsynchXfer (void *pdev)
{
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;
  
  if(USB_Tx_State != 1)
 8001a0e:	f894 c008 	ldrb.w	ip, [r4, #8]
  static uint32_t FrameCount = 0;
  
  if (FrameCount++ == CDC_IN_FRAME_INTERVAL)
  {
    /* Reset the frame counter */
    FrameCount = 0;
 8001a12:	2300      	movs	r3, #0
static void Handle_USBAsynchXfer (void *pdev)
{
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;
  
  if(USB_Tx_State != 1)
 8001a14:	f1bc 0f01 	cmp.w	ip, #1
  static uint32_t FrameCount = 0;
  
  if (FrameCount++ == CDC_IN_FRAME_INTERVAL)
  {
    /* Reset the frame counter */
    FrameCount = 0;
 8001a18:	6063      	str	r3, [r4, #4]
static void Handle_USBAsynchXfer (void *pdev)
{
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;
  
  if(USB_Tx_State != 1)
 8001a1a:	d0f6      	beq.n	8001a0a <usbd_cdc_SOF+0xe>
  {
    if (APP_Rx_ptr_out == APP_RX_DATA_SIZE)
 8001a1c:	68e5      	ldr	r5, [r4, #12]
    {
      APP_Rx_ptr_out = 0;
    }
    
    if(APP_Rx_ptr_out == APP_Rx_ptr_in) 
 8001a1e:	4a17      	ldr	r2, [pc, #92]	; (8001a7c <usbd_cdc_SOF+0x80>)
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;
  
  if(USB_Tx_State != 1)
  {
    if (APP_Rx_ptr_out == APP_RX_DATA_SIZE)
 8001a20:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
    {
      APP_Rx_ptr_out = 0;
 8001a24:	bf04      	itt	eq
 8001a26:	60e3      	streq	r3, [r4, #12]
 8001a28:	461d      	moveq	r5, r3
    }
    
    if(APP_Rx_ptr_out == APP_Rx_ptr_in) 
 8001a2a:	6923      	ldr	r3, [r4, #16]
 8001a2c:	42ab      	cmp	r3, r5
 8001a2e:	d021      	beq.n	8001a74 <usbd_cdc_SOF+0x78>
      APP_Rx_length = APP_RX_DATA_SIZE - APP_Rx_ptr_out;
    
    }
    else 
    {
      APP_Rx_length = APP_Rx_ptr_in - APP_Rx_ptr_out;
 8001a30:	bf28      	it	cs
 8001a32:	ebc5 0103 	rsbcs	r1, r5, r3
    }
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     APP_Rx_length &= ~0x03;
#endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    
    if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE)
 8001a36:	f8d0 35ec 	ldr.w	r3, [r0, #1516]	; 0x5ec
 8001a3a:	f8b3 3039 	ldrh.w	r3, [r3, #57]	; 0x39
      return;
    }
    
    if(APP_Rx_ptr_out > APP_Rx_ptr_in) /* rollback */
    { 
      APP_Rx_length = APP_RX_DATA_SIZE - APP_Rx_ptr_out;
 8001a3e:	bf38      	it	cc
 8001a40:	f5c5 6100 	rsbcc	r1, r5, #2048	; 0x800
    }
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     APP_Rx_length &= ~0x03;
#endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    
    if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE)
 8001a44:	428b      	cmp	r3, r1
      APP_Rx_length = APP_RX_DATA_SIZE - APP_Rx_ptr_out;
    
    }
    else 
    {
      APP_Rx_length = APP_Rx_ptr_in - APP_Rx_ptr_out;
 8001a46:	6151      	str	r1, [r2, #20]
    }
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     APP_Rx_length &= ~0x03;
#endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    
    if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE)
 8001a48:	d20d      	bcs.n	8001a66 <usbd_cdc_SOF+0x6a>
    {
      USB_Tx_ptr = APP_Rx_ptr_out;
      USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
      
      APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;	
 8001a4a:	18ea      	adds	r2, r5, r3
      APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;
 8001a4c:	1ac9      	subs	r1, r1, r3
     APP_Rx_length &= ~0x03;
#endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    
    if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE)
    {
      USB_Tx_ptr = APP_Rx_ptr_out;
 8001a4e:	b2ad      	uxth	r5, r5
      USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
      
      APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;	
 8001a50:	60e2      	str	r2, [r4, #12]
      APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;
 8001a52:	6161      	str	r1, [r4, #20]
      APP_Rx_ptr_out += APP_Rx_length;
      APP_Rx_length = 0;
    }
    USB_Tx_State = 1; 

    DCD_EP_Tx (pdev,
 8001a54:	4a0a      	ldr	r2, [pc, #40]	; (8001a80 <usbd_cdc_SOF+0x84>)
 8001a56:	2181      	movs	r1, #129	; 0x81
 8001a58:	1952      	adds	r2, r2, r5
      USB_Tx_length = APP_Rx_length;
      
      APP_Rx_ptr_out += APP_Rx_length;
      APP_Rx_length = 0;
    }
    USB_Tx_State = 1; 
 8001a5a:	2501      	movs	r5, #1
 8001a5c:	7225      	strb	r5, [r4, #8]

    DCD_EP_Tx (pdev,
 8001a5e:	f001 f871 	bl	8002b44 <DCD_EP_Tx>
    /* Check the data to be sent through IN pipe */
    Handle_USBAsynchXfer(pdev);
  }
  
  return USBD_OK;
}
 8001a62:	2000      	movs	r0, #0
 8001a64:	bd38      	pop	{r3, r4, r5, pc}
    else
    {
      USB_Tx_ptr = APP_Rx_ptr_out;
      USB_Tx_length = APP_Rx_length;
      
      APP_Rx_ptr_out += APP_Rx_length;
 8001a66:	194a      	adds	r2, r1, r5
      APP_Rx_length = 0;
 8001a68:	2300      	movs	r3, #0
 8001a6a:	6163      	str	r3, [r4, #20]
      APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;	
      APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;
    }
    else
    {
      USB_Tx_ptr = APP_Rx_ptr_out;
 8001a6c:	b2ad      	uxth	r5, r5
      USB_Tx_length = APP_Rx_length;
      
      APP_Rx_ptr_out += APP_Rx_length;
 8001a6e:	60e2      	str	r2, [r4, #12]
      APP_Rx_length = 0;
 8001a70:	b28b      	uxth	r3, r1
 8001a72:	e7ef      	b.n	8001a54 <usbd_cdc_SOF+0x58>
      APP_Rx_ptr_out = 0;
    }
    
    if(APP_Rx_ptr_out == APP_Rx_ptr_in) 
    {
      USB_Tx_State = 0; 
 8001a74:	2000      	movs	r0, #0
 8001a76:	7210      	strb	r0, [r2, #8]
 8001a78:	e7c7      	b.n	8001a0a <usbd_cdc_SOF+0xe>
 8001a7a:	bf00      	nop
 8001a7c:	20000e1c 	.word	0x20000e1c
 8001a80:	200021d0 	.word	0x200021d0

08001a84 <usbd_cdc_DataIn>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  usbd_cdc_DataIn (void *pdev, uint8_t epnum)
{
 8001a84:	b538      	push	{r3, r4, r5, lr}
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;

  if (USB_Tx_State == 1)
 8001a86:	4913      	ldr	r1, [pc, #76]	; (8001ad4 <usbd_cdc_DataIn+0x50>)
 8001a88:	7a0b      	ldrb	r3, [r1, #8]
 8001a8a:	2b01      	cmp	r3, #1
 8001a8c:	d001      	beq.n	8001a92 <usbd_cdc_DataIn+0xe>
                 USB_Tx_length);
    }
  }  
  
  return USBD_OK;
}
 8001a8e:	2000      	movs	r0, #0
 8001a90:	bd38      	pop	{r3, r4, r5, pc}
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;

  if (USB_Tx_State == 1)
  {
    if (APP_Rx_length == 0) 
 8001a92:	694c      	ldr	r4, [r1, #20]
 8001a94:	b1d4      	cbz	r4, 8001acc <usbd_cdc_DataIn+0x48>
    {
      USB_Tx_State = 0;
    }
    else 
    {
      if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE){
 8001a96:	f8d0 25ec 	ldr.w	r2, [r0, #1516]	; 0x5ec
 8001a9a:	f8b2 3039 	ldrh.w	r3, [r2, #57]	; 0x39
 8001a9e:	429c      	cmp	r4, r3
 8001aa0:	d80d      	bhi.n	8001abe <usbd_cdc_DataIn+0x3a>
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
        APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;    
      }
      else 
      {
        USB_Tx_ptr = APP_Rx_ptr_out;
 8001aa2:	68ca      	ldr	r2, [r1, #12]
        USB_Tx_length = APP_Rx_length;
        
        APP_Rx_ptr_out += APP_Rx_length;
 8001aa4:	1913      	adds	r3, r2, r4
 8001aa6:	60cb      	str	r3, [r1, #12]
        APP_Rx_length = 0;
 8001aa8:	2300      	movs	r3, #0
 8001aaa:	614b      	str	r3, [r1, #20]
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
        APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;    
      }
      else 
      {
        USB_Tx_ptr = APP_Rx_ptr_out;
 8001aac:	b292      	uxth	r2, r2
        USB_Tx_length = APP_Rx_length;
        
        APP_Rx_ptr_out += APP_Rx_length;
        APP_Rx_length = 0;
 8001aae:	b2a3      	uxth	r3, r4
      }
      
      /* Prepare the available data buffer to be sent on IN endpoint */
      DCD_EP_Tx (pdev,
 8001ab0:	4c09      	ldr	r4, [pc, #36]	; (8001ad8 <usbd_cdc_DataIn+0x54>)
 8001ab2:	2181      	movs	r1, #129	; 0x81
 8001ab4:	18a2      	adds	r2, r4, r2
 8001ab6:	f001 f845 	bl	8002b44 <DCD_EP_Tx>
                 USB_Tx_length);
    }
  }  
  
  return USBD_OK;
}
 8001aba:	2000      	movs	r0, #0
 8001abc:	bd38      	pop	{r3, r4, r5, pc}
      USB_Tx_State = 0;
    }
    else 
    {
      if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE){
        USB_Tx_ptr = APP_Rx_ptr_out;
 8001abe:	68ca      	ldr	r2, [r1, #12]
        USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
        
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
        APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;    
 8001ac0:	1ae4      	subs	r4, r4, r3
    {
      if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE){
        USB_Tx_ptr = APP_Rx_ptr_out;
        USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
        
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
 8001ac2:	189d      	adds	r5, r3, r2
 8001ac4:	60cd      	str	r5, [r1, #12]
      USB_Tx_State = 0;
    }
    else 
    {
      if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE){
        USB_Tx_ptr = APP_Rx_ptr_out;
 8001ac6:	b292      	uxth	r2, r2
        USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
        
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
        APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;    
 8001ac8:	614c      	str	r4, [r1, #20]
 8001aca:	e7f1      	b.n	8001ab0 <usbd_cdc_DataIn+0x2c>

  if (USB_Tx_State == 1)
  {
    if (APP_Rx_length == 0) 
    {
      USB_Tx_State = 0;
 8001acc:	720c      	strb	r4, [r1, #8]
                 USB_Tx_length);
    }
  }  
  
  return USBD_OK;
}
 8001ace:	2000      	movs	r0, #0
 8001ad0:	bd38      	pop	{r3, r4, r5, pc}
 8001ad2:	bf00      	nop
 8001ad4:	20000e1c 	.word	0x20000e1c
 8001ad8:	200021d0 	.word	0x200021d0

08001adc <usbd_cdc_DataOut>:
static uint8_t  usbd_cdc_DataOut (void *pdev, uint8_t epnum)
{      
  uint16_t USB_Rx_Cnt;
  
  /* Get the received data buffer and update the counter */
  USB_Rx_Cnt = ((USB_OTG_CORE_HANDLE*)pdev)->dev.out_ep[epnum].xfer_count;
 8001adc:	eb01 0c81 	add.w	ip, r1, r1, lsl #2
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  usbd_cdc_DataOut (void *pdev, uint8_t epnum)
{      
 8001ae0:	b538      	push	{r3, r4, r5, lr}
  uint16_t USB_Rx_Cnt;
  
  /* Get the received data buffer and update the counter */
  USB_Rx_Cnt = ((USB_OTG_CORE_HANDLE*)pdev)->dev.out_ep[epnum].xfer_count;
 8001ae2:	eb00 01cc 	add.w	r1, r0, ip, lsl #3
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  usbd_cdc_DataOut (void *pdev, uint8_t epnum)
{      
 8001ae6:	4604      	mov	r4, r0
  /* Get the received data buffer and update the counter */
  USB_Rx_Cnt = ((USB_OTG_CORE_HANDLE*)pdev)->dev.out_ep[epnum].xfer_count;
  
  /* USB data will be immediately processed, this allow next USB traffic being 
     NAKed till the end of the application Xfer */
  APP_FOPS.pIf_DataRx(USB_Rx_Buffer, USB_Rx_Cnt);
 8001ae8:	4d08      	ldr	r5, [pc, #32]	; (8001b0c <usbd_cdc_DataOut+0x30>)
 8001aea:	4809      	ldr	r0, [pc, #36]	; (8001b10 <usbd_cdc_DataOut+0x34>)
 8001aec:	f8b1 1388 	ldrh.w	r1, [r1, #904]	; 0x388
 8001af0:	6902      	ldr	r2, [r0, #16]
 8001af2:	4628      	mov	r0, r5
 8001af4:	4790      	blx	r2
  
  /* Prepare Out endpoint to receive next packet */
  DCD_EP_PrepareRx(pdev,
 8001af6:	f8d4 35ec 	ldr.w	r3, [r4, #1516]	; 0x5ec
 8001afa:	4620      	mov	r0, r4
 8001afc:	2101      	movs	r1, #1
 8001afe:	462a      	mov	r2, r5
 8001b00:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8001b04:	f000 fff4 	bl	8002af0 <DCD_EP_PrepareRx>
                   CDC_OUT_EP,
                   (uint8_t*)(USB_Rx_Buffer),
                   CDC_DATA_OUT_PACKET_SIZE);

  return USBD_OK;
}
 8001b08:	2000      	movs	r0, #0
 8001b0a:	bd38      	pop	{r3, r4, r5, pc}
 8001b0c:	20002188 	.word	0x20002188
 8001b10:	20000140 	.word	0x20000140

08001b14 <usbd_cdc_Setup>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t  usbd_cdc_Setup (void  *pdev, 
                                USB_SETUP_REQ *req)
{
 8001b14:	b570      	push	{r4, r5, r6, lr}
  uint16_t len;
  uint8_t  *pbuf;
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8001b16:	780b      	ldrb	r3, [r1, #0]
 8001b18:	f013 0560 	ands.w	r5, r3, #96	; 0x60
  * @param  req: usb requests
  * @retval status
  */
static uint8_t  usbd_cdc_Setup (void  *pdev, 
                                USB_SETUP_REQ *req)
{
 8001b1c:	460c      	mov	r4, r1
 8001b1e:	4606      	mov	r6, r0
  uint16_t len;
  uint8_t  *pbuf;
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8001b20:	d108      	bne.n	8001b34 <usbd_cdc_Setup+0x20>
    
      
      
    /* Standard Requests -------------------------------*/
  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
 8001b22:	784b      	ldrb	r3, [r1, #1]
 8001b24:	2b0a      	cmp	r3, #10
 8001b26:	d01c      	beq.n	8001b62 <usbd_cdc_Setup+0x4e>
 8001b28:	2b0b      	cmp	r3, #11
 8001b2a:	d02d      	beq.n	8001b88 <usbd_cdc_Setup+0x74>
 8001b2c:	2b06      	cmp	r3, #6
 8001b2e:	d031      	beq.n	8001b94 <usbd_cdc_Setup+0x80>
        USBD_CtlError (pdev, req);
      }
      break;
    }
  }
  return USBD_OK;
 8001b30:	4628      	mov	r0, r5
}
 8001b32:	bd70      	pop	{r4, r5, r6, pc}
                                USB_SETUP_REQ *req)
{
  uint16_t len;
  uint8_t  *pbuf;
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8001b34:	2d20      	cmp	r5, #32
 8001b36:	d003      	beq.n	8001b40 <usbd_cdc_Setup+0x2c>
      }
      
      return USBD_OK;
      
    default:
      USBD_CtlError (pdev, req);
 8001b38:	f001 fd0e 	bl	8003558 <USBD_CtlError>
      return USBD_FAIL;
 8001b3c:	2002      	movs	r0, #2
 8001b3e:	bd70      	pop	{r4, r5, r6, pc}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
  {
    /* CDC Class Requests -------------------------------*/
  case USB_REQ_TYPE_CLASS :
      /* Check if the request is a data setup packet */
      if (req->wLength)
 8001b40:	88cd      	ldrh	r5, [r1, #6]
 8001b42:	2d00      	cmp	r5, #0
 8001b44:	d034      	beq.n	8001bb0 <usbd_cdc_Setup+0x9c>
      {
        /* Check if the request is Device-to-Host */
        if (req->bmRequest & 0x80)
 8001b46:	f013 0f80 	tst.w	r3, #128	; 0x80
 8001b4a:	d110      	bne.n	8001b6e <usbd_cdc_Setup+0x5a>
                            req->wLength);          
        }
        else /* Host-to-Device requeset */
        {
          /* Set the value of the current command to be processed */
          cdcCmd = req->bRequest;
 8001b4c:	784a      	ldrb	r2, [r1, #1]
 8001b4e:	4b1e      	ldr	r3, [pc, #120]	; (8001bc8 <usbd_cdc_Setup+0xb4>)
          cdcLen = req->wLength;
          
          /* Prepare the reception of the buffer over EP0
          Next step: the received data will be managed in usbd_cdc_EP0_TxSent() 
          function. */
          USBD_CtlPrepareRx (pdev,
 8001b50:	491e      	ldr	r1, [pc, #120]	; (8001bcc <usbd_cdc_Setup+0xb8>)
                            req->wLength);          
        }
        else /* Host-to-Device requeset */
        {
          /* Set the value of the current command to be processed */
          cdcCmd = req->bRequest;
 8001b52:	601a      	str	r2, [r3, #0]
          cdcLen = req->wLength;
 8001b54:	4b1e      	ldr	r3, [pc, #120]	; (8001bd0 <usbd_cdc_Setup+0xbc>)
          
          /* Prepare the reception of the buffer over EP0
          Next step: the received data will be managed in usbd_cdc_EP0_TxSent() 
          function. */
          USBD_CtlPrepareRx (pdev,
 8001b56:	462a      	mov	r2, r5
        }
        else /* Host-to-Device requeset */
        {
          /* Set the value of the current command to be processed */
          cdcCmd = req->bRequest;
          cdcLen = req->wLength;
 8001b58:	601d      	str	r5, [r3, #0]
          
          /* Prepare the reception of the buffer over EP0
          Next step: the received data will be managed in usbd_cdc_EP0_TxSent() 
          function. */
          USBD_CtlPrepareRx (pdev,
 8001b5a:	f001 fc91 	bl	8003480 <USBD_CtlPrepareRx>
      {
        /* Transfer the command to the interface layer */
        APP_FOPS.pIf_Ctrl(req->bRequest, NULL, 0);
      }
      
      return USBD_OK;
 8001b5e:	2000      	movs	r0, #0
 8001b60:	bd70      	pop	{r4, r5, r6, pc}
                        pbuf,
                        len);
      break;
      
    case USB_REQ_GET_INTERFACE :
      USBD_CtlSendData (pdev,
 8001b62:	491c      	ldr	r1, [pc, #112]	; (8001bd4 <usbd_cdc_Setup+0xc0>)
 8001b64:	2201      	movs	r2, #1
 8001b66:	f001 fc71 	bl	800344c <USBD_CtlSendData>
        USBD_CtlError (pdev, req);
      }
      break;
    }
  }
  return USBD_OK;
 8001b6a:	4628      	mov	r0, r5
      
    case USB_REQ_GET_INTERFACE :
      USBD_CtlSendData (pdev,
                        (uint8_t *)&usbd_cdc_AltSet,
                        1);
      break;
 8001b6c:	bd70      	pop	{r4, r5, r6, pc}
      {
        /* Check if the request is Device-to-Host */
        if (req->bmRequest & 0x80)
        {
          /* Get the data to be sent to Host from interface layer */
          APP_FOPS.pIf_Ctrl(req->bRequest, CmdBuff, req->wLength);
 8001b6e:	481a      	ldr	r0, [pc, #104]	; (8001bd8 <usbd_cdc_Setup+0xc4>)
 8001b70:	4916      	ldr	r1, [pc, #88]	; (8001bcc <usbd_cdc_Setup+0xb8>)
 8001b72:	6883      	ldr	r3, [r0, #8]
 8001b74:	7860      	ldrb	r0, [r4, #1]
 8001b76:	462a      	mov	r2, r5
 8001b78:	4798      	blx	r3
          
          /* Send the data to the host */
          USBD_CtlSendData (pdev, 
 8001b7a:	4630      	mov	r0, r6
 8001b7c:	4913      	ldr	r1, [pc, #76]	; (8001bcc <usbd_cdc_Setup+0xb8>)
 8001b7e:	88e2      	ldrh	r2, [r4, #6]
 8001b80:	f001 fc64 	bl	800344c <USBD_CtlSendData>
      {
        /* Transfer the command to the interface layer */
        APP_FOPS.pIf_Ctrl(req->bRequest, NULL, 0);
      }
      
      return USBD_OK;
 8001b84:	2000      	movs	r0, #0
 8001b86:	bd70      	pop	{r4, r5, r6, pc}
                        (uint8_t *)&usbd_cdc_AltSet,
                        1);
      break;
      
    case USB_REQ_SET_INTERFACE :
      if ((uint8_t)(req->wValue) < USBD_ITF_MAX_NUM)
 8001b88:	788b      	ldrb	r3, [r1, #2]
 8001b8a:	b9cb      	cbnz	r3, 8001bc0 <usbd_cdc_Setup+0xac>
      {
        usbd_cdc_AltSet = (uint8_t)(req->wValue);
 8001b8c:	4a10      	ldr	r2, [pc, #64]	; (8001bd0 <usbd_cdc_Setup+0xbc>)
        USBD_CtlError (pdev, req);
      }
      break;
    }
  }
  return USBD_OK;
 8001b8e:	4618      	mov	r0, r3
      break;
      
    case USB_REQ_SET_INTERFACE :
      if ((uint8_t)(req->wValue) < USBD_ITF_MAX_NUM)
      {
        usbd_cdc_AltSet = (uint8_t)(req->wValue);
 8001b90:	6193      	str	r3, [r2, #24]
 8001b92:	bd70      	pop	{r4, r5, r6, pc}
    /* Standard Requests -------------------------------*/
  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
    {
    case USB_REQ_GET_DESCRIPTOR: 
      if( (req->wValue >> 8) == CDC_DESCRIPTOR_TYPE)
 8001b94:	884b      	ldrh	r3, [r1, #2]
 8001b96:	0a18      	lsrs	r0, r3, #8
 8001b98:	2821      	cmp	r0, #33	; 0x21
 8001b9a:	d103      	bne.n	8001ba4 <usbd_cdc_Setup+0x90>
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
        pbuf = usbd_cdc_Desc;   
#else
        pbuf = usbd_cdc_CfgDesc + 9 + (9 * USBD_ITF_MAX_NUM);
#endif 
        len = MIN(USB_CDC_DESC_SIZ , req->wLength);
 8001b9c:	88ca      	ldrh	r2, [r1, #6]
 8001b9e:	2a3a      	cmp	r2, #58	; 0x3a
 8001ba0:	bf28      	it	cs
 8001ba2:	223a      	movcs	r2, #58	; 0x3a
      }
      
      USBD_CtlSendData (pdev, 
 8001ba4:	4630      	mov	r0, r6
 8001ba6:	490d      	ldr	r1, [pc, #52]	; (8001bdc <usbd_cdc_Setup+0xc8>)
 8001ba8:	f001 fc50 	bl	800344c <USBD_CtlSendData>
        USBD_CtlError (pdev, req);
      }
      break;
    }
  }
  return USBD_OK;
 8001bac:	2000      	movs	r0, #0
      }
      
      USBD_CtlSendData (pdev, 
                        pbuf,
                        len);
      break;
 8001bae:	bd70      	pop	{r4, r5, r6, pc}
        }
      }
      else /* No Data request */
      {
        /* Transfer the command to the interface layer */
        APP_FOPS.pIf_Ctrl(req->bRequest, NULL, 0);
 8001bb0:	7848      	ldrb	r0, [r1, #1]
 8001bb2:	4909      	ldr	r1, [pc, #36]	; (8001bd8 <usbd_cdc_Setup+0xc4>)
 8001bb4:	462a      	mov	r2, r5
 8001bb6:	688b      	ldr	r3, [r1, #8]
 8001bb8:	4629      	mov	r1, r5
 8001bba:	4798      	blx	r3
      }
      
      return USBD_OK;
 8001bbc:	4628      	mov	r0, r5
 8001bbe:	bd70      	pop	{r4, r5, r6, pc}
        usbd_cdc_AltSet = (uint8_t)(req->wValue);
      }
      else
      {
        /* Call the error management function (command will be nacked */
        USBD_CtlError (pdev, req);
 8001bc0:	f001 fcca 	bl	8003558 <USBD_CtlError>
      }
      break;
    }
  }
  return USBD_OK;
 8001bc4:	4628      	mov	r0, r5
 8001bc6:	bd70      	pop	{r4, r5, r6, pc}
 8001bc8:	20000094 	.word	0x20000094
 8001bcc:	200021c8 	.word	0x200021c8
 8001bd0:	20000e1c 	.word	0x20000e1c
 8001bd4:	20000e34 	.word	0x20000e34
 8001bd8:	20000140 	.word	0x20000140
 8001bdc:	200000aa 	.word	0x200000aa

08001be0 <usbd_cdc_DeInit>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  usbd_cdc_DeInit (void  *pdev, 
                                 uint8_t cfgidx)
{
 8001be0:	b510      	push	{r4, lr}
  /* Open EP IN */
  DCD_EP_Close(pdev,
 8001be2:	2181      	movs	r1, #129	; 0x81
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  usbd_cdc_DeInit (void  *pdev, 
                                 uint8_t cfgidx)
{
 8001be4:	4604      	mov	r4, r0
  /* Open EP IN */
  DCD_EP_Close(pdev,
 8001be6:	f000 ff6d 	bl	8002ac4 <DCD_EP_Close>
              CDC_IN_EP);
  
  /* Open EP OUT */
  DCD_EP_Close(pdev,
 8001bea:	2101      	movs	r1, #1
 8001bec:	4620      	mov	r0, r4
 8001bee:	f000 ff69 	bl	8002ac4 <DCD_EP_Close>
              CDC_OUT_EP);
  
  /* Open Command IN EP */
  DCD_EP_Close(pdev,
 8001bf2:	2182      	movs	r1, #130	; 0x82
 8001bf4:	4620      	mov	r0, r4
 8001bf6:	f000 ff65 	bl	8002ac4 <DCD_EP_Close>
              CDC_CMD_EP);

  /* Restore default state of the Interface physical components */
  APP_FOPS.pIf_DeInit();
 8001bfa:	4802      	ldr	r0, [pc, #8]	; (8001c04 <usbd_cdc_DeInit+0x24>)
 8001bfc:	6843      	ldr	r3, [r0, #4]
 8001bfe:	4798      	blx	r3
  
  return USBD_OK;
}
 8001c00:	2000      	movs	r0, #0
 8001c02:	bd10      	pop	{r4, pc}
 8001c04:	20000140 	.word	0x20000140

08001c08 <usbd_cdc_Init>:
                               uint8_t cfgidx)
{
  uint8_t *pbuf;

  /* Open EP IN */
  DCD_EP_Open(pdev,
 8001c08:	f8d0 25ec 	ldr.w	r2, [r0, #1516]	; 0x5ec
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  usbd_cdc_Init (void  *pdev, 
                               uint8_t cfgidx)
{
 8001c0c:	b538      	push	{r3, r4, r5, lr}
 8001c0e:	4604      	mov	r4, r0
  uint8_t *pbuf;

  /* Open EP IN */
  DCD_EP_Open(pdev,
 8001c10:	2181      	movs	r1, #129	; 0x81
 8001c12:	2302      	movs	r3, #2
 8001c14:	f8b2 2039 	ldrh.w	r2, [r2, #57]	; 0x39
 8001c18:	f000 ff34 	bl	8002a84 <DCD_EP_Open>
              CDC_IN_EP,
              CDC_DATA_IN_PACKET_SIZE,
              USB_OTG_EP_BULK);
  
  /* Open EP OUT */
  DCD_EP_Open(pdev,
 8001c1c:	f8d4 55ec 	ldr.w	r5, [r4, #1516]	; 0x5ec
 8001c20:	2101      	movs	r1, #1
 8001c22:	f8b5 2040 	ldrh.w	r2, [r5, #64]	; 0x40
 8001c26:	2302      	movs	r3, #2
 8001c28:	4620      	mov	r0, r4
 8001c2a:	f000 ff2b 	bl	8002a84 <DCD_EP_Open>
              CDC_OUT_EP,
              CDC_DATA_OUT_PACKET_SIZE,
              USB_OTG_EP_BULK);
  
  /* Open Command IN EP */
  DCD_EP_Open(pdev,
 8001c2e:	2182      	movs	r1, #130	; 0x82
 8001c30:	2208      	movs	r2, #8
 8001c32:	2303      	movs	r3, #3
 8001c34:	4620      	mov	r0, r4
 8001c36:	f000 ff25 	bl	8002a84 <DCD_EP_Open>
              CDC_CMD_EP,
              CDC_CMD_PACKET_SZE,
              USB_OTG_EP_INT);
  
  pbuf = (uint8_t *)USBD_DeviceDesc;
  pbuf[4] = DEVICE_CLASS_CDC;
 8001c3a:	4b09      	ldr	r3, [pc, #36]	; (8001c60 <usbd_cdc_Init+0x58>)
  pbuf[5] = DEVICE_SUBCLASS_CDC;
  
  /* Initialize the Interface physical components */
  APP_FOPS.pIf_Init();
 8001c3c:	4909      	ldr	r1, [pc, #36]	; (8001c64 <usbd_cdc_Init+0x5c>)
              CDC_CMD_EP,
              CDC_CMD_PACKET_SZE,
              USB_OTG_EP_INT);
  
  pbuf = (uint8_t *)USBD_DeviceDesc;
  pbuf[4] = DEVICE_CLASS_CDC;
 8001c3e:	2202      	movs	r2, #2
  pbuf[5] = DEVICE_SUBCLASS_CDC;
 8001c40:	2500      	movs	r5, #0
              CDC_CMD_EP,
              CDC_CMD_PACKET_SZE,
              USB_OTG_EP_INT);
  
  pbuf = (uint8_t *)USBD_DeviceDesc;
  pbuf[4] = DEVICE_CLASS_CDC;
 8001c42:	711a      	strb	r2, [r3, #4]
  pbuf[5] = DEVICE_SUBCLASS_CDC;
 8001c44:	715d      	strb	r5, [r3, #5]
  
  /* Initialize the Interface physical components */
  APP_FOPS.pIf_Init();
 8001c46:	6808      	ldr	r0, [r1, #0]
 8001c48:	4780      	blx	r0

  /* Prepare Out endpoint to receive next packet */
  DCD_EP_PrepareRx(pdev,
 8001c4a:	f8d4 35ec 	ldr.w	r3, [r4, #1516]	; 0x5ec
 8001c4e:	4a06      	ldr	r2, [pc, #24]	; (8001c68 <usbd_cdc_Init+0x60>)
 8001c50:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8001c54:	4620      	mov	r0, r4
 8001c56:	2101      	movs	r1, #1
 8001c58:	f000 ff4a 	bl	8002af0 <DCD_EP_PrepareRx>
                   CDC_OUT_EP,
                   (uint8_t*)(USB_Rx_Buffer),
                   CDC_DATA_OUT_PACKET_SIZE);
  
  return USBD_OK;
}
 8001c5c:	4628      	mov	r0, r5
 8001c5e:	bd38      	pop	{r3, r4, r5, pc}
 8001c60:	20000044 	.word	0x20000044
 8001c64:	20000140 	.word	0x20000140
 8001c68:	20002188 	.word	0x20002188

08001c6c <USB_OTG_CoreReset.clone.1>:
/**
* @brief  USB_OTG_CoreReset : Soft reset of the core
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
 8001c6c:	b530      	push	{r4, r5, lr}
 8001c6e:	4605      	mov	r5, r0
 8001c70:	b083      	sub	sp, #12
{
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 8001c72:	2300      	movs	r3, #0
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 8001c74:	2003      	movs	r0, #3
{
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 8001c76:	9301      	str	r3, [sp, #4]
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 8001c78:	f001 ff21 	bl	8003abe <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001c7c:	682b      	ldr	r3, [r5, #0]
 8001c7e:	4c1b      	ldr	r4, [pc, #108]	; (8001cec <USB_OTG_CoreReset.clone.1+0x80>)
 8001c80:	691a      	ldr	r2, [r3, #16]
 8001c82:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
    {
      return USB_OTG_OK;
    }
  }
  while (greset.b.ahbidle == 0);
 8001c84:	9a01      	ldr	r2, [sp, #4]
 8001c86:	2a00      	cmp	r2, #0
 8001c88:	db14      	blt.n	8001cb4 <USB_OTG_CoreReset.clone.1+0x48>
  
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 8001c8a:	2003      	movs	r0, #3
 8001c8c:	f001 ff17 	bl	8003abe <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001c90:	682b      	ldr	r3, [r5, #0]
 8001c92:	6919      	ldr	r1, [r3, #16]
 8001c94:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
    {
      return USB_OTG_OK;
    }
  }
  while (greset.b.ahbidle == 0);
 8001c96:	9801      	ldr	r0, [sp, #4]
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001c98:	3c01      	subs	r4, #1
    if (++count > 200000)
    {
      return USB_OTG_OK;
    }
  }
  while (greset.b.ahbidle == 0);
 8001c9a:	2800      	cmp	r0, #0
 8001c9c:	db0a      	blt.n	8001cb4 <USB_OTG_CoreReset.clone.1+0x48>
  
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 8001c9e:	2003      	movs	r0, #3
 8001ca0:	f001 ff0d 	bl	8003abe <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001ca4:	682b      	ldr	r3, [r5, #0]
 8001ca6:	691a      	ldr	r2, [r3, #16]
    if (++count > 200000)
 8001ca8:	3c01      	subs	r4, #1
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001caa:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 8001cac:	d1ea      	bne.n	8001c84 <USB_OTG_CoreReset.clone.1+0x18>
  }
  while (greset.b.csftrst == 1);
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
  return status;
}
 8001cae:	2000      	movs	r0, #0
 8001cb0:	b003      	add	sp, #12
 8001cb2:	bd30      	pop	{r4, r5, pc}
    }
  }
  while (greset.b.ahbidle == 0);
  /* Core Soft Reset */
  count = 0;
  greset.b.csftrst = 1;
 8001cb4:	9901      	ldr	r1, [sp, #4]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001cb6:	4a0d      	ldr	r2, [pc, #52]	; (8001cec <USB_OTG_CoreReset.clone.1+0x80>)
    }
  }
  while (greset.b.ahbidle == 0);
  /* Core Soft Reset */
  count = 0;
  greset.b.csftrst = 1;
 8001cb8:	f041 0001 	orr.w	r0, r1, #1
 8001cbc:	9001      	str	r0, [sp, #4]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8001cbe:	9901      	ldr	r1, [sp, #4]
 8001cc0:	6119      	str	r1, [r3, #16]
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001cc2:	6918      	ldr	r0, [r3, #16]
 8001cc4:	9001      	str	r0, [sp, #4]
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.csftrst == 1);
 8001cc6:	9801      	ldr	r0, [sp, #4]
 8001cc8:	f010 0f01 	tst.w	r0, #1
 8001ccc:	d00a      	beq.n	8001ce4 <USB_OTG_CoreReset.clone.1+0x78>
  count = 0;
  greset.b.csftrst = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001cce:	6919      	ldr	r1, [r3, #16]
 8001cd0:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.csftrst == 1);
 8001cd2:	9801      	ldr	r0, [sp, #4]
  count = 0;
  greset.b.csftrst = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001cd4:	3a01      	subs	r2, #1
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.csftrst == 1);
 8001cd6:	f010 0f01 	tst.w	r0, #1
 8001cda:	d003      	beq.n	8001ce4 <USB_OTG_CoreReset.clone.1+0x78>
  count = 0;
  greset.b.csftrst = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001cdc:	6919      	ldr	r1, [r3, #16]
    if (++count > 200000)
 8001cde:	3a01      	subs	r2, #1
  count = 0;
  greset.b.csftrst = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001ce0:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
 8001ce2:	d1f0      	bne.n	8001cc6 <USB_OTG_CoreReset.clone.1+0x5a>
      break;
    }
  }
  while (greset.b.csftrst == 1);
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 8001ce4:	2003      	movs	r0, #3
 8001ce6:	f001 feea 	bl	8003abe <USB_OTG_BSP_uDelay>
 8001cea:	e7e0      	b.n	8001cae <USB_OTG_CoreReset.clone.1+0x42>
 8001cec:	00030d40 	.word	0x00030d40

08001cf0 <USB_OTG_WritePacket>:
*/
USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t             *src, 
                                uint8_t             ch_ep_num, 
                                uint16_t            len)
{
 8001cf0:	b430      	push	{r4, r5}
  USB_OTG_STS status = USB_OTG_OK;
  if (pdev->cfg.dma_enable == 0)
 8001cf2:	78c4      	ldrb	r4, [r0, #3]
 8001cf4:	bb04      	cbnz	r4, 8001d38 <USB_OTG_WritePacket+0x48>
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
 8001cf6:	eb00 0082 	add.w	r0, r0, r2, lsl #2
  if (pdev->cfg.dma_enable == 0)
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
 8001cfa:	3303      	adds	r3, #3
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001cfc:	109b      	asrs	r3, r3, #2
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
 8001cfe:	f8d0 40d0 	ldr.w	r4, [r0, #208]	; 0xd0
    for (i = 0; i < count32b; i++, src+=4)
 8001d02:	d019      	beq.n	8001d38 <USB_OTG_WritePacket+0x48>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001d04:	f851 2b04 	ldr.w	r2, [r1], #4
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001d08:	2001      	movs	r0, #1
 8001d0a:	1e5d      	subs	r5, r3, #1
 8001d0c:	4283      	cmp	r3, r0
 8001d0e:	f005 0501 	and.w	r5, r5, #1
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001d12:	6022      	str	r2, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001d14:	d010      	beq.n	8001d38 <USB_OTG_WritePacket+0x48>
 8001d16:	b12d      	cbz	r5, 8001d24 <USB_OTG_WritePacket+0x34>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001d18:	f851 2b04 	ldr.w	r2, [r1], #4
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001d1c:	2002      	movs	r0, #2
 8001d1e:	4283      	cmp	r3, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001d20:	6022      	str	r2, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001d22:	d009      	beq.n	8001d38 <USB_OTG_WritePacket+0x48>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001d24:	460a      	mov	r2, r1
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001d26:	3002      	adds	r0, #2
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001d28:	f852 5b04 	ldr.w	r5, [r2], #4
 8001d2c:	6025      	str	r5, [r4, #0]
 8001d2e:	684d      	ldr	r5, [r1, #4]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001d30:	1d11      	adds	r1, r2, #4
 8001d32:	4283      	cmp	r3, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001d34:	6025      	str	r5, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001d36:	d1f5      	bne.n	8001d24 <USB_OTG_WritePacket+0x34>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
    }
  }
  return status;
}
 8001d38:	2000      	movs	r0, #0
 8001d3a:	bc30      	pop	{r4, r5}
 8001d3c:	4770      	bx	lr
 8001d3e:	bf00      	nop

08001d40 <USB_OTG_ReadPacket>:
void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
                         uint8_t *dest, 
                         uint16_t len)
{
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
 8001d40:	3203      	adds	r2, #3
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001d42:	1092      	asrs	r2, r2, #2
* @retval None
*/
void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
                         uint8_t *dest, 
                         uint16_t len)
{
 8001d44:	b470      	push	{r4, r5, r6}
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
 8001d46:	f8d0 50d0 	ldr.w	r5, [r0, #208]	; 0xd0
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001d4a:	d01c      	beq.n	8001d86 <USB_OTG_ReadPacket+0x46>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001d4c:	682c      	ldr	r4, [r5, #0]
 8001d4e:	460b      	mov	r3, r1
 8001d50:	1e50      	subs	r0, r2, #1
 8001d52:	f843 4b04 	str.w	r4, [r3], #4
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001d56:	2401      	movs	r4, #1
 8001d58:	42a2      	cmp	r2, r4
 8001d5a:	f000 0001 	and.w	r0, r0, #1
 8001d5e:	d010      	beq.n	8001d82 <USB_OTG_ReadPacket+0x42>
 8001d60:	b128      	cbz	r0, 8001d6e <USB_OTG_ReadPacket+0x2e>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001d62:	6828      	ldr	r0, [r5, #0]
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001d64:	2402      	movs	r4, #2
 8001d66:	42a2      	cmp	r2, r4
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001d68:	f843 0b04 	str.w	r0, [r3], #4
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001d6c:	d009      	beq.n	8001d82 <USB_OTG_ReadPacket+0x42>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001d6e:	682e      	ldr	r6, [r5, #0]
 8001d70:	4618      	mov	r0, r3
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001d72:	3402      	adds	r4, #2
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001d74:	f840 6b04 	str.w	r6, [r0], #4
 8001d78:	682e      	ldr	r6, [r5, #0]
 8001d7a:	605e      	str	r6, [r3, #4]
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001d7c:	1d03      	adds	r3, r0, #4
 8001d7e:	42a2      	cmp	r2, r4
 8001d80:	d1f5      	bne.n	8001d6e <USB_OTG_ReadPacket+0x2e>
 8001d82:	eb01 0182 	add.w	r1, r1, r2, lsl #2
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
    
  }
  return ((void *)dest);
}
 8001d86:	4608      	mov	r0, r1
 8001d88:	bc70      	pop	{r4, r5, r6}
 8001d8a:	4770      	bx	lr

08001d8c <USB_OTG_SelectCore>:
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
                               USB_OTG_CORE_ID_TypeDef coreID)
{
 8001d8c:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  uint32_t i , baseAddress = 0;
  USB_OTG_STS status = USB_OTG_OK;
  
  pdev->cfg.dma_enable       = 0;
 8001d90:	2300      	movs	r3, #0
  
  /* at startup the core is in FS mode */
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8001d92:	2701      	movs	r7, #1
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
 8001d94:	2240      	movs	r2, #64	; 0x40
    
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
 8001d96:	2901      	cmp	r1, #1
                               USB_OTG_CORE_ID_TypeDef coreID)
{
  uint32_t i , baseAddress = 0;
  USB_OTG_STS status = USB_OTG_OK;
  
  pdev->cfg.dma_enable       = 0;
 8001d98:	70c3      	strb	r3, [r0, #3]
  
  /* at startup the core is in FS mode */
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8001d9a:	7087      	strb	r7, [r0, #2]
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
 8001d9c:	8082      	strh	r2, [r0, #4]
    
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
 8001d9e:	f000 80a6 	beq.w	8001eee <USB_OTG_SelectCore+0x162>
    
#ifdef USB_OTG_FS_LOW_PWR_MGMT_SUPPORT    
    pdev->cfg.low_power        = 1;    
#endif     
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
 8001da2:	2900      	cmp	r1, #0
 8001da4:	f000 808c 	beq.w	8001ec0 <USB_OTG_SelectCore+0x134>
 8001da8:	7847      	ldrb	r7, [r0, #1]
 8001daa:	f890 8000 	ldrb.w	r8, [r0]
    pdev->cfg.low_power        = 1;    
#endif 
    
  }
  
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
 8001dae:	60c3      	str	r3, [r0, #12]
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
 8001db0:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8001db4:	6102      	str	r2, [r0, #16]
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001db6:	2f00      	cmp	r7, #0
 8001db8:	f000 80b0 	beq.w	8001f1c <USB_OTG_SelectCore+0x190>
 8001dbc:	f44f 6a60 	mov.w	sl, #3584	; 0xe00
 8001dc0:	f44f 6988 	mov.w	r9, #1088	; 0x440
 8001dc4:	f44f 6b80 	mov.w	fp, #1024	; 0x400
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
                               USB_OTG_CORE_ID_TypeDef coreID)
{
  uint32_t i , baseAddress = 0;
 8001dc8:	469c      	mov	ip, r3
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001dca:	4602      	mov	r2, r0
 8001dcc:	f50c 6410 	add.w	r4, ip, #2304	; 0x900
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8001dd0:	f842 4f18 	str.w	r4, [r2, #24]!
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001dd4:	2401      	movs	r4, #1
 8001dd6:	1e7b      	subs	r3, r7, #1
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001dd8:	f50c 6130 	add.w	r1, ip, #2816	; 0xb00
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001ddc:	42bc      	cmp	r4, r7
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8001dde:	63d1      	str	r1, [r2, #60]	; 0x3c
 8001de0:	ea03 0104 	and.w	r1, r3, r4
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001de4:	f50c 6312 	add.w	r3, ip, #2336	; 0x920
 8001de8:	d21c      	bcs.n	8001e24 <USB_OTG_SelectCore+0x98>
 8001dea:	b151      	cbz	r1, 8001e02 <USB_OTG_SelectCore+0x76>
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001dec:	4602      	mov	r2, r0
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001dee:	2402      	movs	r4, #2
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8001df0:	f842 3f1c 	str.w	r3, [r2, #28]!
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001df4:	f50c 6132 	add.w	r1, ip, #2848	; 0xb20
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001df8:	42bc      	cmp	r4, r7
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8001dfa:	63d1      	str	r1, [r2, #60]	; 0x3c
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001dfc:	f50c 6314 	add.w	r3, ip, #2368	; 0x940
 8001e00:	d210      	bcs.n	8001e24 <USB_OTG_SelectCore+0x98>
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001e02:	1d11      	adds	r1, r2, #4
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8001e04:	6053      	str	r3, [r2, #4]
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001e06:	3402      	adds	r4, #2
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001e08:	3208      	adds	r2, #8
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001e0a:	f103 0520 	add.w	r5, r3, #32
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001e0e:	f503 7600 	add.w	r6, r3, #512	; 0x200
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001e12:	42bc      	cmp	r4, r7
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001e14:	f503 7308 	add.w	r3, r3, #544	; 0x220
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8001e18:	63ce      	str	r6, [r1, #60]	; 0x3c
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8001e1a:	604d      	str	r5, [r1, #4]
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8001e1c:	63d3      	str	r3, [r2, #60]	; 0x3c
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001e1e:	f105 0320 	add.w	r3, r5, #32
 8001e22:	d3ee      	bcc.n	8001e02 <USB_OTG_SelectCore+0x76>
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
 8001e24:	f8c0 b014 	str.w	fp, [r0, #20]
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
 8001e28:	f8c0 90cc 	str.w	r9, [r0, #204]	; 0xcc
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001e2c:	f1b8 0f00 	cmp.w	r8, #0
 8001e30:	d040      	beq.n	8001eb4 <USB_OTG_SelectCore+0x128>
 8001e32:	f50c 61a0 	add.w	r1, ip, #1280	; 0x500
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001e36:	ea4f 1548 	mov.w	r5, r8, lsl #5
 8001e3a:	f1a5 0420 	sub.w	r4, r5, #32
 8001e3e:	4602      	mov	r2, r0
 8001e40:	186d      	adds	r5, r5, r1
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8001e42:	f50c 63a4 	add.w	r3, ip, #1312	; 0x520
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001e46:	42ab      	cmp	r3, r5
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8001e48:	f842 1f90 	str.w	r1, [r2, #144]!
 8001e4c:	f3c4 1440 	ubfx	r4, r4, #5, #1
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001e50:	d00f      	beq.n	8001e72 <USB_OTG_SelectCore+0xe6>
 8001e52:	b134      	cbz	r4, 8001e62 <USB_OTG_SelectCore+0xd6>
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001e54:	4602      	mov	r2, r0
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8001e56:	f842 3f94 	str.w	r3, [r2, #148]!
 8001e5a:	f50c 63a8 	add.w	r3, ip, #1344	; 0x540
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001e5e:	42ab      	cmp	r3, r5
 8001e60:	d007      	beq.n	8001e72 <USB_OTG_SelectCore+0xe6>
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8001e62:	f103 0420 	add.w	r4, r3, #32
 8001e66:	6053      	str	r3, [r2, #4]
 8001e68:	3340      	adds	r3, #64	; 0x40
 8001e6a:	6094      	str	r4, [r2, #8]
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001e6c:	3208      	adds	r2, #8
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001e6e:	42ab      	cmp	r3, r5
 8001e70:	d1f7      	bne.n	8001e62 <USB_OTG_SelectCore+0xd6>
 8001e72:	f50c 5180 	add.w	r1, ip, #4096	; 0x1000
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001e76:	ea4f 3808 	mov.w	r8, r8, lsl #12
 8001e7a:	f5a8 5480 	sub.w	r4, r8, #4096	; 0x1000
 8001e7e:	4602      	mov	r2, r0
 8001e80:	4488      	add	r8, r1
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8001e82:	f50c 5300 	add.w	r3, ip, #8192	; 0x2000
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001e86:	4543      	cmp	r3, r8
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8001e88:	f842 1fd0 	str.w	r1, [r2, #208]!
 8001e8c:	f3c4 3400 	ubfx	r4, r4, #12, #1
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001e90:	d010      	beq.n	8001eb4 <USB_OTG_SelectCore+0x128>
 8001e92:	b134      	cbz	r4, 8001ea2 <USB_OTG_SelectCore+0x116>
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001e94:	4602      	mov	r2, r0
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8001e96:	f842 3fd4 	str.w	r3, [r2, #212]!
 8001e9a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001e9e:	4543      	cmp	r3, r8
 8001ea0:	d008      	beq.n	8001eb4 <USB_OTG_SelectCore+0x128>
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8001ea2:	f503 5480 	add.w	r4, r3, #4096	; 0x1000
 8001ea6:	6053      	str	r3, [r2, #4]
 8001ea8:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8001eac:	6094      	str	r4, [r2, #8]
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001eae:	3208      	adds	r2, #8
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001eb0:	4543      	cmp	r3, r8
 8001eb2:	d1f6      	bne.n	8001ea2 <USB_OTG_SelectCore+0x116>
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
      (i * USB_OTG_DATA_FIFO_SIZE));
  }
  pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
 8001eb4:	f8c0 a10c 	str.w	sl, [r0, #268]	; 0x10c
  
  return status;
}
 8001eb8:	2000      	movs	r0, #0
 8001eba:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001ebe:	4770      	bx	lr
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001ec0:	f44f 69a0 	mov.w	r9, #1280	; 0x500
 8001ec4:	4b19      	ldr	r3, [pc, #100]	; (8001f2c <USB_OTG_SelectCore+0x1a0>)
 8001ec6:	f8a0 9006 	strh.w	r9, [r0, #6]
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
 8001eca:	f04f 080c 	mov.w	r8, #12
    pdev->cfg.dev_endpoints    = 6 ;
 8001ece:	2706      	movs	r7, #6
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001ed0:	f8df a064 	ldr.w	sl, [pc, #100]	; 8001f38 <USB_OTG_SelectCore+0x1ac>
 8001ed4:	f8df 9064 	ldr.w	r9, [pc, #100]	; 8001f3c <USB_OTG_SelectCore+0x1b0>
 8001ed8:	f8df b064 	ldr.w	fp, [pc, #100]	; 8001f40 <USB_OTG_SelectCore+0x1b4>
 8001edc:	4a14      	ldr	r2, [pc, #80]	; (8001f30 <USB_OTG_SelectCore+0x1a4>)
#endif     
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
 8001ede:	72c1      	strb	r1, [r0, #11]
    pdev->cfg.host_channels    = 12 ;
 8001ee0:	f880 8000 	strb.w	r8, [r0]
    pdev->cfg.dev_endpoints    = 6 ;
 8001ee4:	7047      	strb	r7, [r0, #1]
    pdev->cfg.low_power        = 1;    
#endif     
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
 8001ee6:	469c      	mov	ip, r3
    pdev->cfg.low_power        = 1;    
#endif 
    
  }
  
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
 8001ee8:	60c3      	str	r3, [r0, #12]
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
 8001eea:	6102      	str	r2, [r0, #16]
 8001eec:	e76d      	b.n	8001dca <USB_OTG_SelectCore+0x3e>
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
    pdev->cfg.host_channels    = 8 ;
 8001eee:	f04f 0808 	mov.w	r8, #8
    pdev->cfg.dev_endpoints    = 4 ;
 8001ef2:	2704      	movs	r7, #4
    pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
 8001ef4:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
 8001ef8:	72c1      	strb	r1, [r0, #11]
    pdev->cfg.host_channels    = 8 ;
    pdev->cfg.dev_endpoints    = 4 ;
    pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
 8001efa:	f44f 74a0 	mov.w	r4, #320	; 0x140
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
 8001efe:	2102      	movs	r1, #2
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
    pdev->cfg.host_channels    = 8 ;
 8001f00:	f880 8000 	strb.w	r8, [r0]
    pdev->cfg.dev_endpoints    = 4 ;
 8001f04:	7047      	strb	r7, [r0, #1]
    pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
 8001f06:	80c4      	strh	r4, [r0, #6]
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
 8001f08:	7201      	strb	r1, [r0, #8]
 8001f0a:	f8df a038 	ldr.w	sl, [pc, #56]	; 8001f44 <USB_OTG_SelectCore+0x1b8>
 8001f0e:	f8df 9038 	ldr.w	r9, [pc, #56]	; 8001f48 <USB_OTG_SelectCore+0x1bc>
 8001f12:	f8df b038 	ldr.w	fp, [pc, #56]	; 8001f4c <USB_OTG_SelectCore+0x1c0>
 8001f16:	4a07      	ldr	r2, [pc, #28]	; (8001f34 <USB_OTG_SelectCore+0x1a8>)
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
    
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
 8001f18:	469c      	mov	ip, r3
 8001f1a:	e7e5      	b.n	8001ee8 <USB_OTG_SelectCore+0x15c>
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001f1c:	f44f 6a60 	mov.w	sl, #3584	; 0xe00
 8001f20:	f44f 6988 	mov.w	r9, #1088	; 0x440
 8001f24:	f44f 6b80 	mov.w	fp, #1024	; 0x400
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
                               USB_OTG_CORE_ID_TypeDef coreID)
{
  uint32_t i , baseAddress = 0;
 8001f28:	46bc      	mov	ip, r7
 8001f2a:	e77b      	b.n	8001e24 <USB_OTG_SelectCore+0x98>
 8001f2c:	40040000 	.word	0x40040000
 8001f30:	40040800 	.word	0x40040800
 8001f34:	50000800 	.word	0x50000800
 8001f38:	40040e00 	.word	0x40040e00
 8001f3c:	40040440 	.word	0x40040440
 8001f40:	40040400 	.word	0x40040400
 8001f44:	50000e00 	.word	0x50000e00
 8001f48:	50000440 	.word	0x50000440
 8001f4c:	50000400 	.word	0x50000400

08001f50 <USB_OTG_CoreInit>:
*         device mode or host mode operation.
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
{
 8001f50:	b538      	push	{r3, r4, r5, lr}
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8001f52:	7a03      	ldrb	r3, [r0, #8]
  USB_OTG_GI2CCTL_TypeDef  i2cctl;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  
  usbcfg.d32 = 0;
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
 8001f54:	2500      	movs	r5, #0
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8001f56:	2b01      	cmp	r3, #1
*         device mode or host mode operation.
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
{
 8001f58:	4604      	mov	r4, r0
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8001f5a:	d037      	beq.n	8001fcc <USB_OTG_CoreInit+0x7c>
    }    
  }
  else /* FS interface (embedded Phy or I2C Phy) */
  {
    
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
 8001f5c:	f850 3f0c 	ldr.w	r3, [r0, #12]!
 8001f60:	68d9      	ldr	r1, [r3, #12]
    usbcfg.b.physel  = 1; /* FS Interface */
 8001f62:	f041 0240 	orr.w	r2, r1, #64	; 0x40
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8001f66:	60da      	str	r2, [r3, #12]
    /* Reset after a PHY select and set Host mode */
    USB_OTG_CoreReset(pdev);
 8001f68:	f7ff fe80 	bl	8001c6c <USB_OTG_CoreReset.clone.1>
    /* Enable the I2C interface and deactivate the power down*/
    gccfg.d32 = 0;
    gccfg.b.pwdn = 1;
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 8001f6c:	f894 c008 	ldrb.w	ip, [r4, #8]
    gccfg.b.vbussensingB = 1 ;     
#ifndef VBUS_SENSING_ENABLED
    gccfg.b.disablevbussensing = 1; 
#endif    
    
    if(pdev->cfg.Sof_output)
 8001f70:	7a61      	ldrb	r1, [r4, #9]
    gccfg.d32 = 0;
    gccfg.b.pwdn = 1;
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
    {
      gccfg.b.i2cifen = 1;
 8001f72:	f1bc 0f03 	cmp.w	ip, #3
 8001f76:	bf14      	ite	ne
 8001f78:	f44f 3280 	movne.w	r2, #65536	; 0x10000
 8001f7c:	f44f 3240 	moveq.w	r2, #196608	; 0x30000
    }   
    gccfg.b.vbussensingA = 1 ;
    gccfg.b.vbussensingB = 1 ;     
#ifndef VBUS_SENSING_ENABLED
    gccfg.b.disablevbussensing = 1; 
 8001f80:	f442 1330 	orr.w	r3, r2, #2883584	; 0x2c0000
#endif    
    
    if(pdev->cfg.Sof_output)
 8001f84:	b109      	cbz	r1, 8001f8a <USB_OTG_CoreInit+0x3a>
    {
      gccfg.b.sofouten = 1;  
 8001f86:	f442 1370 	orr.w	r3, r2, #3932160	; 0x3c0000
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 8001f8a:	68e1      	ldr	r1, [r4, #12]
    USB_OTG_BSP_mDelay(20);
 8001f8c:	2014      	movs	r0, #20
    if(pdev->cfg.Sof_output)
    {
      gccfg.b.sofouten = 1;  
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 8001f8e:	638b      	str	r3, [r1, #56]	; 0x38
    USB_OTG_BSP_mDelay(20);
 8001f90:	f001 fd9f 	bl	8003ad2 <USB_OTG_BSP_mDelay>
    /* Program GUSBCFG.OtgUtmifsSel to I2C*/
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8001f94:	68e3      	ldr	r3, [r4, #12]
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 8001f96:	f894 c008 	ldrb.w	ip, [r4, #8]
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
    USB_OTG_BSP_mDelay(20);
    /* Program GUSBCFG.OtgUtmifsSel to I2C*/
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8001f9a:	68da      	ldr	r2, [r3, #12]
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 8001f9c:	f1bc 0f03 	cmp.w	ip, #3
    {
      usbcfg.b.otgutmifssel = 1;
 8001fa0:	bf08      	it	eq
 8001fa2:	f442 3280 	orreq.w	r2, r2, #65536	; 0x10000
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8001fa6:	60da      	str	r2, [r3, #12]
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 8001fa8:	7a20      	ldrb	r0, [r4, #8]
 8001faa:	2803      	cmp	r0, #3
 8001fac:	d03b      	beq.n	8002026 <USB_OTG_CoreInit+0xd6>
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
      USB_OTG_BSP_mDelay(200);
    }
  }
  /* case the HS core is working in FS mode */
  if(pdev->cfg.dma_enable == 1)
 8001fae:	f894 e003 	ldrb.w	lr, [r4, #3]
 8001fb2:	f1be 0f01 	cmp.w	lr, #1
 8001fb6:	d107      	bne.n	8001fc8 <USB_OTG_CoreInit+0x78>
  {
    
    ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
 8001fb8:	68e3      	ldr	r3, [r4, #12]
 8001fba:	689a      	ldr	r2, [r3, #8]
    ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 8001fbc:	2105      	movs	r1, #5
 8001fbe:	f361 0244 	bfi	r2, r1, #1, #4
    ahbcfg.b.dmaenable = 1;
 8001fc2:	f042 0020 	orr.w	r0, r2, #32
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8001fc6:	6098      	str	r0, [r3, #8]
  usbcfg.b.srpcap = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
  USB_OTG_EnableCommonInt(pdev);
#endif
  return status;
}
 8001fc8:	2000      	movs	r0, #0
 8001fca:	bd38      	pop	{r3, r4, r5, pc}
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
 8001fcc:	68c2      	ldr	r2, [r0, #12]
    gccfg.b.pwdn = 0;
    
    if (pdev->cfg.Sof_output)
 8001fce:	7a41      	ldrb	r1, [r0, #9]
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
 8001fd0:	6b93      	ldr	r3, [r2, #56]	; 0x38
    gccfg.b.pwdn = 0;
 8001fd2:	f365 4310 	bfi	r3, r5, #16, #1
    
    if (pdev->cfg.Sof_output)
 8001fd6:	b109      	cbz	r1, 8001fdc <USB_OTG_CoreInit+0x8c>
    {
      gccfg.b.sofouten = 1;   
 8001fd8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    }
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 8001fdc:	6393      	str	r3, [r2, #56]	; 0x38
    
    /* Init The ULPI Interface */
    usbcfg.d32 = 0;
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8001fde:	68d1      	ldr	r1, [r2, #12]
    
    usbcfg.b.physel            = 0; /* HS Interface */
 8001fe0:	f36f 1186 	bfc	r1, #6, #1
#else
 #ifdef USB_OTG_EXTERNAL_VBUS_ENABLED    
    usbcfg.b.ulpi_ext_vbus_drv = 1; /* Use external VBUS */
 #endif
#endif 
    usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
 8001fe4:	f36f 5196 	bfc	r1, #22, #1
    usbcfg.b.ulpi_utmi_sel     = 1; /* ULPI seleInterfacect */
 8001fe8:	f041 0310 	orr.w	r3, r1, #16
    
    usbcfg.b.phyif             = 0; /* 8 bits */
 8001fec:	f36f 03c3 	bfc	r3, #3, #1
    usbcfg.b.ddrsel            = 0; /* single data rate */
 8001ff0:	f36f 13c7 	bfc	r3, #7, #1
    
    usbcfg.b.ulpi_fsls = 0;
 8001ff4:	f36f 4351 	bfc	r3, #17, #1
    usbcfg.b.ulpi_clk_sus_m = 0;
 8001ff8:	f36f 43d3 	bfc	r3, #19, #1
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8001ffc:	60d3      	str	r3, [r2, #12]
    
    /* Reset after a PHY select  */
    USB_OTG_CoreReset(pdev);
 8001ffe:	f104 000c 	add.w	r0, r4, #12
 8002002:	f7ff fe33 	bl	8001c6c <USB_OTG_CoreReset.clone.1>
    
    if(pdev->cfg.dma_enable == 1)
 8002006:	78e0      	ldrb	r0, [r4, #3]
 8002008:	2801      	cmp	r0, #1
 800200a:	d1dd      	bne.n	8001fc8 <USB_OTG_CoreInit+0x78>
    {
      
      ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 800200c:	2005      	movs	r0, #5
 800200e:	f360 0544 	bfi	r5, r0, #1, #4
      ahbcfg.b.dmaenable = 1;
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8002012:	68e2      	ldr	r2, [r4, #12]
    
    if(pdev->cfg.dma_enable == 1)
    {
      
      ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
      ahbcfg.b.dmaenable = 1;
 8002014:	f045 0520 	orr.w	r5, r5, #32
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8002018:	6095      	str	r5, [r2, #8]
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
      USB_OTG_BSP_mDelay(200);
    }
  }
  /* case the HS core is working in FS mode */
  if(pdev->cfg.dma_enable == 1)
 800201a:	f894 e003 	ldrb.w	lr, [r4, #3]
 800201e:	f1be 0f01 	cmp.w	lr, #1
 8002022:	d0c9      	beq.n	8001fb8 <USB_OTG_CoreInit+0x68>
 8002024:	e7d0      	b.n	8001fc8 <USB_OTG_CoreInit+0x78>
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
    {
      /*Program GI2CCTL.I2CEn*/
      i2cctl.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GI2CCTL);
 8002026:	6b19      	ldr	r1, [r3, #48]	; 0x30
      i2cctl.b.i2cdevaddr = 1;
 8002028:	2201      	movs	r2, #1
 800202a:	f362 619b 	bfi	r1, r2, #26, #2
      i2cctl.b.i2cen = 0;
 800202e:	f36f 51d7 	bfc	r1, #23, #1
      i2cctl.b.dat_se0 = 1;
 8002032:	f041 5580 	orr.w	r5, r1, #268435456	; 0x10000000
      i2cctl.b.addr = 0x2D;
 8002036:	202d      	movs	r0, #45	; 0x2d
 8002038:	f360 4516 	bfi	r5, r0, #16, #7
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
 800203c:	631d      	str	r5, [r3, #48]	; 0x30
      
      USB_OTG_BSP_mDelay(200);
 800203e:	20c8      	movs	r0, #200	; 0xc8
 8002040:	f001 fd47 	bl	8003ad2 <USB_OTG_BSP_mDelay>
      
      i2cctl.b.i2cen = 1;
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
 8002044:	68e3      	ldr	r3, [r4, #12]
      i2cctl.b.addr = 0x2D;
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
      
      USB_OTG_BSP_mDelay(200);
      
      i2cctl.b.i2cen = 1;
 8002046:	f445 0500 	orr.w	r5, r5, #8388608	; 0x800000
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
 800204a:	631d      	str	r5, [r3, #48]	; 0x30
      USB_OTG_BSP_mDelay(200);
 800204c:	20c8      	movs	r0, #200	; 0xc8
 800204e:	f001 fd40 	bl	8003ad2 <USB_OTG_BSP_mDelay>
 8002052:	e7ac      	b.n	8001fae <USB_OTG_CoreInit+0x5e>

08002054 <USB_OTG_EnableGlobalInt>:
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  
  ahbcfg.d32 = 0;
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
 8002054:	68c3      	ldr	r3, [r0, #12]
 8002056:	6898      	ldr	r0, [r3, #8]
 8002058:	f040 0201 	orr.w	r2, r0, #1
 800205c:	609a      	str	r2, [r3, #8]
  return status;
}
 800205e:	2000      	movs	r0, #0
 8002060:	4770      	bx	lr
 8002062:	bf00      	nop

08002064 <USB_OTG_DisableGlobalInt>:
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  ahbcfg.d32 = 0;
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
 8002064:	68c3      	ldr	r3, [r0, #12]
 8002066:	6898      	ldr	r0, [r3, #8]
 8002068:	f020 0201 	bic.w	r2, r0, #1
 800206c:	609a      	str	r2, [r3, #8]
  return status;
}
 800206e:	2000      	movs	r0, #0
 8002070:	4770      	bx	lr
 8002072:	bf00      	nop

08002074 <USB_OTG_FlushTxFifo>:
* @param  pdev : Selected device
* @param  num : FO num
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
{
 8002074:	b500      	push	{lr}
 8002076:	b083      	sub	sp, #12
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  
  uint32_t count = 0;
  greset.d32 = 0;
 8002078:	2300      	movs	r3, #0
 800207a:	9301      	str	r3, [sp, #4]
  greset.b.txfflsh = 1;
 800207c:	9a01      	ldr	r2, [sp, #4]
  greset.b.txfnum  = num;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 800207e:	4b11      	ldr	r3, [pc, #68]	; (80020c4 <USB_OTG_FlushTxFifo+0x50>)
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  
  uint32_t count = 0;
  greset.d32 = 0;
  greset.b.txfflsh = 1;
 8002080:	f042 0220 	orr.w	r2, r2, #32
 8002084:	9201      	str	r2, [sp, #4]
  greset.b.txfnum  = num;
 8002086:	9a01      	ldr	r2, [sp, #4]
 8002088:	f361 128a 	bfi	r2, r1, #6, #5
 800208c:	9201      	str	r2, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 800208e:	9a01      	ldr	r2, [sp, #4]
 8002090:	68c1      	ldr	r1, [r0, #12]
 8002092:	610a      	str	r2, [r1, #16]
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8002094:	690a      	ldr	r2, [r1, #16]
 8002096:	9201      	str	r2, [sp, #4]
 8002098:	e00a      	b.n	80020b0 <USB_OTG_FlushTxFifo+0x3c>
 800209a:	690a      	ldr	r2, [r1, #16]
 800209c:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.txfflsh == 1);
 800209e:	9801      	ldr	r0, [sp, #4]
  greset.b.txfflsh = 1;
  greset.b.txfnum  = num;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80020a0:	3b01      	subs	r3, #1
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.txfflsh == 1);
 80020a2:	f010 0f20 	tst.w	r0, #32
 80020a6:	d007      	beq.n	80020b8 <USB_OTG_FlushTxFifo+0x44>
  greset.b.txfflsh = 1;
  greset.b.txfnum  = num;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80020a8:	690a      	ldr	r2, [r1, #16]
    if (++count > 200000)
 80020aa:	3b01      	subs	r3, #1
  greset.b.txfflsh = 1;
  greset.b.txfnum  = num;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80020ac:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 80020ae:	d003      	beq.n	80020b8 <USB_OTG_FlushTxFifo+0x44>
    {
      break;
    }
  }
  while (greset.b.txfflsh == 1);
 80020b0:	9801      	ldr	r0, [sp, #4]
 80020b2:	f010 0f20 	tst.w	r0, #32
 80020b6:	d1f0      	bne.n	800209a <USB_OTG_FlushTxFifo+0x26>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 80020b8:	2003      	movs	r0, #3
 80020ba:	f001 fd00 	bl	8003abe <USB_OTG_BSP_uDelay>
  return status;
}
 80020be:	2000      	movs	r0, #0
 80020c0:	b003      	add	sp, #12
 80020c2:	bd00      	pop	{pc}
 80020c4:	00030d40 	.word	0x00030d40

080020c8 <USB_OTG_FlushRxFifo>:
* @brief  USB_OTG_FlushRxFifo : Flush a Rx FIFO
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
{
 80020c8:	b500      	push	{lr}
 80020ca:	b083      	sub	sp, #12
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 80020cc:	2300      	movs	r3, #0
 80020ce:	9301      	str	r3, [sp, #4]
  greset.b.rxfflsh = 1;
 80020d0:	9a01      	ldr	r2, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80020d2:	4b0f      	ldr	r3, [pc, #60]	; (8002110 <USB_OTG_FlushRxFifo+0x48>)
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
  greset.b.rxfflsh = 1;
 80020d4:	f042 0110 	orr.w	r1, r2, #16
 80020d8:	9101      	str	r1, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 80020da:	9a01      	ldr	r2, [sp, #4]
 80020dc:	68c1      	ldr	r1, [r0, #12]
 80020de:	610a      	str	r2, [r1, #16]
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80020e0:	690a      	ldr	r2, [r1, #16]
 80020e2:	9201      	str	r2, [sp, #4]
 80020e4:	e00a      	b.n	80020fc <USB_OTG_FlushRxFifo+0x34>
 80020e6:	690a      	ldr	r2, [r1, #16]
 80020e8:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.rxfflsh == 1);
 80020ea:	9801      	ldr	r0, [sp, #4]
  greset.d32 = 0;
  greset.b.rxfflsh = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80020ec:	3b01      	subs	r3, #1
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.rxfflsh == 1);
 80020ee:	f010 0f10 	tst.w	r0, #16
 80020f2:	d007      	beq.n	8002104 <USB_OTG_FlushRxFifo+0x3c>
  greset.d32 = 0;
  greset.b.rxfflsh = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80020f4:	690a      	ldr	r2, [r1, #16]
    if (++count > 200000)
 80020f6:	3b01      	subs	r3, #1
  greset.d32 = 0;
  greset.b.rxfflsh = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80020f8:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 80020fa:	d003      	beq.n	8002104 <USB_OTG_FlushRxFifo+0x3c>
    {
      break;
    }
  }
  while (greset.b.rxfflsh == 1);
 80020fc:	9801      	ldr	r0, [sp, #4]
 80020fe:	f010 0f10 	tst.w	r0, #16
 8002102:	d1f0      	bne.n	80020e6 <USB_OTG_FlushRxFifo+0x1e>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 8002104:	2003      	movs	r0, #3
 8002106:	f001 fcda 	bl	8003abe <USB_OTG_BSP_uDelay>
  return status;
}
 800210a:	2000      	movs	r0, #0
 800210c:	b003      	add	sp, #12
 800210e:	bd00      	pop	{pc}
 8002110:	00030d40 	.word	0x00030d40

08002114 <USB_OTG_SetCurrentMode>:
USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8002114:	68c2      	ldr	r2, [r0, #12]
* @param  pdev : Selected device
* @param  mode :  (Host/device)
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
{
 8002116:	b508      	push	{r3, lr}
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8002118:	68d3      	ldr	r3, [r2, #12]
  
  usbcfg.b.force_host = 0;
  usbcfg.b.force_dev = 0;
  
  if ( mode == HOST_MODE)
 800211a:	2901      	cmp	r1, #1
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
  
  usbcfg.b.force_host = 0;
 800211c:	f36f 735d 	bfc	r3, #29, #1
  usbcfg.b.force_dev = 0;
 8002120:	f36f 739e 	bfc	r3, #30, #1
  
  if ( mode == HOST_MODE)
 8002124:	d008      	beq.n	8002138 <USB_OTG_SetCurrentMode+0x24>
  {
    usbcfg.b.force_host = 1;
  }
  else if ( mode == DEVICE_MODE)
 8002126:	b909      	cbnz	r1, 800212c <USB_OTG_SetCurrentMode+0x18>
  {
    usbcfg.b.force_dev = 1;
 8002128:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
  USB_OTG_BSP_mDelay(50);
 800212c:	2032      	movs	r0, #50	; 0x32
  else if ( mode == DEVICE_MODE)
  {
    usbcfg.b.force_dev = 1;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 800212e:	60d3      	str	r3, [r2, #12]
  USB_OTG_BSP_mDelay(50);
 8002130:	f001 fccf 	bl	8003ad2 <USB_OTG_BSP_mDelay>
  return status;
}
 8002134:	2000      	movs	r0, #0
 8002136:	bd08      	pop	{r3, pc}
  usbcfg.b.force_host = 0;
  usbcfg.b.force_dev = 0;
  
  if ( mode == HOST_MODE)
  {
    usbcfg.b.force_host = 1;
 8002138:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  {
    usbcfg.b.force_dev = 1;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
  USB_OTG_BSP_mDelay(50);
 800213c:	2032      	movs	r0, #50	; 0x32
  else if ( mode == DEVICE_MODE)
  {
    usbcfg.b.force_dev = 1;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 800213e:	60d3      	str	r3, [r2, #12]
  USB_OTG_BSP_mDelay(50);
 8002140:	f001 fcc7 	bl	8003ad2 <USB_OTG_BSP_mDelay>
  return status;
}
 8002144:	2000      	movs	r0, #0
 8002146:	bd08      	pop	{r3, pc}

08002148 <USB_OTG_GetMode>:
* @param  pdev : Selected device
* @retval current mode
*/
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 8002148:	68c3      	ldr	r3, [r0, #12]
 800214a:	6958      	ldr	r0, [r3, #20]
}
 800214c:	f000 0001 	and.w	r0, r0, #1
 8002150:	4770      	bx	lr
 8002152:	bf00      	nop

08002154 <USB_OTG_IsDeviceMode>:
* @param  pdev : Selected device
* @retval current mode
*/
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 8002154:	68c0      	ldr	r0, [r0, #12]
 8002156:	6943      	ldr	r3, [r0, #20]
* @param  pdev : Selected device
* @retval num_in_ep
*/
uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_GetMode(pdev) != HOST_MODE);
 8002158:	f013 0f01 	tst.w	r3, #1
}
 800215c:	bf14      	ite	ne
 800215e:	2000      	movne	r0, #0
 8002160:	2001      	moveq	r0, #1
 8002162:	4770      	bx	lr

08002164 <USB_OTG_IsHostMode>:
* @param  pdev : Selected device
* @retval current mode
*/
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 8002164:	68c3      	ldr	r3, [r0, #12]
 8002166:	6958      	ldr	r0, [r3, #20]
* @retval num_in_ep
*/
uint8_t USB_OTG_IsHostMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_GetMode(pdev) == HOST_MODE);
}
 8002168:	f000 0001 	and.w	r0, r0, #1
 800216c:	4770      	bx	lr
 800216e:	bf00      	nop

08002170 <USB_OTG_ReadCoreItr>:
* @retval Status
*/
uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v = 0;
  v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
 8002170:	68c3      	ldr	r3, [r0, #12]
 8002172:	695a      	ldr	r2, [r3, #20]
  v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
 8002174:	6998      	ldr	r0, [r3, #24]
  return v;
}
 8002176:	4010      	ands	r0, r2
 8002178:	4770      	bx	lr
 800217a:	bf00      	nop

0800217c <USB_OTG_ReadOtgItr>:
* @param  pdev : Selected device
* @retval Status
*/
uint32_t USB_OTG_ReadOtgItr (USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32 (&pdev->regs.GREGS->GOTGINT));
 800217c:	68c3      	ldr	r3, [r0, #12]
 800217e:	6858      	ldr	r0, [r3, #4]
}
 8002180:	4770      	bx	lr
 8002182:	bf00      	nop

08002184 <USB_OTG_InitDevSpeed>:
*/
void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
{
  USB_OTG_DCFG_TypeDef   dcfg;
  
  dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
 8002184:	6903      	ldr	r3, [r0, #16]
 8002186:	681a      	ldr	r2, [r3, #0]
  dcfg.b.devspd = speed;
 8002188:	f361 0201 	bfi	r2, r1, #0, #2
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCFG, dcfg.d32);
 800218c:	601a      	str	r2, [r3, #0]
}
 800218e:	4770      	bx	lr

08002190 <USB_OTG_EnableDevInt>:
  USB_OTG_GINTMSK_TypeDef  intmsk;
  
  intmsk.d32 = 0;
  
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
 8002190:	68c3      	ldr	r3, [r0, #12]
USB_OTG_STS USB_OTG_EnableDevInt(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GINTMSK_TypeDef  intmsk;
  
  intmsk.d32 = 0;
 8002192:	2200      	movs	r2, #0
  
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 8002194:	f04f 31ff 	mov.w	r1, #4294967295
  USB_OTG_GINTMSK_TypeDef  intmsk;
  
  intmsk.d32 = 0;
  
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
 8002198:	619a      	str	r2, [r3, #24]
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 800219a:	6159      	str	r1, [r3, #20]
  USB_OTG_GINTMSK_TypeDef  int_mask;
  
  int_mask.d32 = 0;
  /* Clear any pending USB_OTG Interrupts */
#ifndef USE_OTG_MODE
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GOTGINT, 0xFFFFFFFF);
 800219c:	6059      	str	r1, [r3, #4]
#endif
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 800219e:	6159      	str	r1, [r3, #20]
#ifdef USE_OTG_MODE
  int_mask.b.otgintr = 1;
  int_mask.b.sessreqintr = 1;
  int_mask.b.conidstschng = 1;
#endif
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
 80021a0:	490a      	ldr	r1, [pc, #40]	; (80021cc <USB_OTG_EnableDevInt+0x3c>)
 80021a2:	6199      	str	r1, [r3, #24]
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
  /* Enable the common interrupts */
  USB_OTG_EnableCommonInt(pdev);
  
  if (pdev->cfg.dma_enable == 0)
 80021a4:	f890 c003 	ldrb.w	ip, [r0, #3]
  intmsk.b.incomplisoout    = 1;   
#ifdef VBUS_SENSING_ENABLED
  intmsk.b.sessreqintr    = 1; 
  intmsk.b.otgintr    = 1;    
#endif  
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 80021a8:	6998      	ldr	r0, [r3, #24]
  /* Enable the common interrupts */
  USB_OTG_EnableCommonInt(pdev);
  
  if (pdev->cfg.dma_enable == 0)
  {
    intmsk.b.rxstsqlvl = 1;
 80021aa:	4594      	cmp	ip, r2
 80021ac:	bf14      	ite	ne
 80021ae:	4611      	movne	r1, r2
 80021b0:	2110      	moveq	r1, #16
  
  /* Enable interrupts matching to the Device mode ONLY */
  intmsk.b.usbsuspend = 1;
  intmsk.b.usbreset   = 1;
  intmsk.b.enumdone   = 1;
  intmsk.b.inepintr   = 1;
 80021b2:	f441 2c87 	orr.w	ip, r1, #276480	; 0x43800
  intmsk.b.outepintr  = 1;
  intmsk.b.sofintr    = 1; 
 80021b6:	f04c 1108 	orr.w	r1, ip, #524296	; 0x80008

  intmsk.b.incomplisoin    = 1; 
  intmsk.b.incomplisoout    = 1;   
 80021ba:	f441 1c40 	orr.w	ip, r1, #3145728	; 0x300000
#ifdef VBUS_SENSING_ENABLED
  intmsk.b.sessreqintr    = 1; 
  intmsk.b.otgintr    = 1;    
#endif  
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 80021be:	ea20 000c 	bic.w	r0, r0, ip
 80021c2:	ea40 010c 	orr.w	r1, r0, ip
 80021c6:	6199      	str	r1, [r3, #24]
  return status;
}
 80021c8:	4610      	mov	r0, r2
 80021ca:	4770      	bx	lr
 80021cc:	80000800 	.word	0x80000800

080021d0 <USB_OTG_CoreInitDev>:
*         for device mode
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
{
 80021d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  nptxfifosize.d32 = 0;
  txfifosize.d32 = 0;
  msk.d32 = 0;
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
 80021d2:	f8d0 510c 	ldr.w	r5, [r0, #268]	; 0x10c
  /* Device configuration register */
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
 80021d6:	6902      	ldr	r2, [r0, #16]
  USB_OTG_DIEPMSK_TypeDef msk;
  USB_OTG_DTHRCTL_TypeDef dthrctl;  
  
  depctl.d32 = 0;
  dcfg.d32 = 0;
  nptxfifosize.d32 = 0;
 80021d8:	2100      	movs	r1, #0
  txfifosize.d32 = 0;
  msk.d32 = 0;
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
 80021da:	6029      	str	r1, [r5, #0]
*         for device mode
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
{
 80021dc:	4604      	mov	r4, r0
  msk.d32 = 0;
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
  /* Device configuration register */
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
 80021de:	6810      	ldr	r0, [r2, #0]
  dcfg.b.perfrint = DCFG_FRAME_INTERVAL_80;
 80021e0:	f361 20cc 	bfi	r0, r1, #11, #2
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32 );
 80021e4:	6010      	str	r0, [r2, #0]
  USB_OTG_DTHRCTL_TypeDef dthrctl;  
  
  depctl.d32 = 0;
  dcfg.d32 = 0;
  nptxfifosize.d32 = 0;
  txfifosize.d32 = 0;
 80021e6:	460b      	mov	r3, r1
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
  dcfg.b.perfrint = DCFG_FRAME_INTERVAL_80;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32 );
  
#ifdef USB_OTG_FS_CORE
  if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID  )
 80021e8:	7ae1      	ldrb	r1, [r4, #11]
 80021ea:	2901      	cmp	r1, #1
 80021ec:	d058      	beq.n	80022a0 <USB_OTG_CoreInitDev+0xd0>
    txfifosize.b.depth = TX5_FIFO_HS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[4], txfifosize.d32 );
  }
#endif  
  /* Flush the FIFOs */
  USB_OTG_FlushTxFifo(pdev , 0x10); /* all Tx FIFOs */
 80021ee:	2110      	movs	r1, #16
 80021f0:	4620      	mov	r0, r4
 80021f2:	f7ff ff3f 	bl	8002074 <USB_OTG_FlushTxFifo>
  USB_OTG_FlushRxFifo(pdev);
 80021f6:	4620      	mov	r0, r4
 80021f8:	f7ff ff66 	bl	80020c8 <USB_OTG_FlushRxFifo>
  /* Clear all pending Device Interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 80021fc:	6925      	ldr	r5, [r4, #16]
 80021fe:	2200      	movs	r2, #0
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8002200:	f04f 30ff 	mov.w	r0, #4294967295
#endif  
  /* Flush the FIFOs */
  USB_OTG_FlushTxFifo(pdev , 0x10); /* all Tx FIFOs */
  USB_OTG_FlushRxFifo(pdev);
  /* Clear all pending Device Interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 8002204:	612a      	str	r2, [r5, #16]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
 8002206:	616a      	str	r2, [r5, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8002208:	61a8      	str	r0, [r5, #24]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
 800220a:	61ea      	str	r2, [r5, #28]
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 800220c:	7863      	ldrb	r3, [r4, #1]
 800220e:	2b00      	cmp	r3, #0
 8002210:	d031      	beq.n	8002276 <USB_OTG_CoreInitDev+0xa6>
* @brief  USB_OTG_CoreInitDev : Initializes the USB_OTG controller registers 
*         for device mode
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
 8002212:	f104 0014 	add.w	r0, r4, #20
    else
    {
      depctl.d32 = 0;
    }
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
 8002216:	4617      	mov	r7, r2
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 8002218:	26ff      	movs	r6, #255	; 0xff
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[i]->DIEPCTL);
 800221a:	f850 3f04 	ldr.w	r3, [r0, #4]!
 800221e:	6819      	ldr	r1, [r3, #0]
    if (depctl.b.epena)
 8002220:	f3c1 6e07 	ubfx	lr, r1, #24, #8
 8002224:	f00e 0c80 	and.w	ip, lr, #128	; 0x80
 8002228:	fa5f f18c 	uxtb.w	r1, ip
    {
      depctl.d32 = 0;
      depctl.b.epdis = 1;
      depctl.b.snak = 1;
 800222c:	2900      	cmp	r1, #0
 800222e:	bf18      	it	ne
 8002230:	f04f 4190 	movne.w	r1, #1207959552	; 0x48000000
    }
    else
    {
      depctl.d32 = 0;
    }
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
 8002234:	6019      	str	r1, [r3, #0]
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
 8002236:	611f      	str	r7, [r3, #16]
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 8002238:	609e      	str	r6, [r3, #8]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 800223a:	7863      	ldrb	r3, [r4, #1]
 800223c:	3201      	adds	r2, #1
 800223e:	4293      	cmp	r3, r2
 8002240:	d8eb      	bhi.n	800221a <USB_OTG_CoreInitDev+0x4a>
    }
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
  }
  for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
 8002242:	b1c3      	cbz	r3, 8002276 <USB_OTG_CoreInitDev+0xa6>
* @brief  USB_OTG_CoreInitDev : Initializes the USB_OTG controller registers 
*         for device mode
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
 8002244:	2200      	movs	r2, #0
 8002246:	f104 0050 	add.w	r0, r4, #80	; 0x50
    else
    {
      depctl.d32 = 0;
    }
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPCTL, depctl.d32);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
 800224a:	4617      	mov	r7, r2
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 800224c:	26ff      	movs	r6, #255	; 0xff
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
  }
  for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
  {
    USB_OTG_DEPCTL_TypeDef  depctl;
    depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[i]->DOEPCTL);
 800224e:	f850 3f04 	ldr.w	r3, [r0, #4]!
 8002252:	6819      	ldr	r1, [r3, #0]
    if (depctl.b.epena)
 8002254:	f3c1 6e07 	ubfx	lr, r1, #24, #8
 8002258:	f00e 0c80 	and.w	ip, lr, #128	; 0x80
 800225c:	fa5f f18c 	uxtb.w	r1, ip
    {
      depctl.d32 = 0;
      depctl.b.epdis = 1;
      depctl.b.snak = 1;
 8002260:	2900      	cmp	r1, #0
 8002262:	bf18      	it	ne
 8002264:	f04f 4190 	movne.w	r1, #1207959552	; 0x48000000
    }
    else
    {
      depctl.d32 = 0;
    }
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPCTL, depctl.d32);
 8002268:	6019      	str	r1, [r3, #0]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
 800226a:	611f      	str	r7, [r3, #16]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 800226c:	609e      	str	r6, [r3, #8]
    }
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
  }
  for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
 800226e:	7863      	ldrb	r3, [r4, #1]
 8002270:	3201      	adds	r2, #1
 8002272:	4293      	cmp	r3, r2
 8002274:	d8eb      	bhi.n	800224e <USB_OTG_CoreInitDev+0x7e>
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  msk.d32 = 0;
  msk.b.txfifoundrn = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPMSK, msk.d32, msk.d32);
 8002276:	692b      	ldr	r3, [r5, #16]
 8002278:	f443 7080 	orr.w	r0, r3, #256	; 0x100
 800227c:	6128      	str	r0, [r5, #16]
  
  if (pdev->cfg.dma_enable == 1)
 800227e:	78e2      	ldrb	r2, [r4, #3]
 8002280:	2a01      	cmp	r2, #1
 8002282:	d108      	bne.n	8002296 <USB_OTG_CoreInitDev+0xc6>
  {
    dthrctl.d32 = 0;
    dthrctl.b.non_iso_thr_en = 1;
    dthrctl.b.iso_thr_en = 1;
    dthrctl.b.tx_thr_len = 64;
 8002284:	2240      	movs	r2, #64	; 0x40
  
  if (pdev->cfg.dma_enable == 1)
  {
    dthrctl.d32 = 0;
    dthrctl.b.non_iso_thr_en = 1;
    dthrctl.b.iso_thr_en = 1;
 8002286:	2003      	movs	r0, #3
    dthrctl.b.tx_thr_len = 64;
 8002288:	f362 008a 	bfi	r0, r2, #2, #9
    dthrctl.b.rx_thr_en = 1;
 800228c:	f440 3180 	orr.w	r1, r0, #65536	; 0x10000
    dthrctl.b.rx_thr_len = 64;
 8002290:	f362 4159 	bfi	r1, r2, #17, #9
    USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DTHRCTL, dthrctl.d32);  
 8002294:	6329      	str	r1, [r5, #48]	; 0x30
  }
  USB_OTG_EnableDevInt(pdev);
 8002296:	4620      	mov	r0, r4
 8002298:	f7ff ff7a 	bl	8002190 <USB_OTG_EnableDevInt>
  return status;
}
 800229c:	2000      	movs	r0, #0
 800229e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
*/
void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
{
  USB_OTG_DCFG_TypeDef   dcfg;
  
  dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
 80022a0:	6816      	ldr	r6, [r2, #0]
    
    /* Set Full speed phy */
    USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
    
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 80022a2:	68e0      	ldr	r0, [r4, #12]
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
    
    
    /* EP1 TX*/
    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
 80022a4:	27c0      	movs	r7, #192	; 0xc0
    
    /* Set Full speed phy */
    USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
    
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 80022a6:	2580      	movs	r5, #128	; 0x80
    
    /* EP0 TX*/
    nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
 80022a8:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
    
    
    /* EP1 TX*/
    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
 80022ac:	f367 030f 	bfi	r3, r7, #0, #16
void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
{
  USB_OTG_DCFG_TypeDef   dcfg;
  
  dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
  dcfg.b.devspd = speed;
 80022b0:	f046 0603 	orr.w	r6, r6, #3
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCFG, dcfg.d32);
 80022b4:	6016      	str	r6, [r2, #0]
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
    
    
    /* EP1 TX*/
    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
    txfifosize.b.depth = TX1_FIFO_FS_SIZE;
 80022b6:	f365 431f 	bfi	r3, r5, #16, #16
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
    
    /* EP0 TX*/
    nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
 80022ba:	f365 010f 	bfi	r1, r5, #0, #16
    txfifosize.b.depth = TX1_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
    
    
    /* EP2 TX*/
    txfifosize.b.startaddr += txfifosize.b.depth;
 80022be:	f44f 72a0 	mov.w	r2, #320	; 0x140
    
    /* Set Full speed phy */
    USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
    
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 80022c2:	6245      	str	r5, [r0, #36]	; 0x24
    
    /* EP0 TX*/
    nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
 80022c4:	6281      	str	r1, [r0, #40]	; 0x28
    
    
    /* EP1 TX*/
    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
    txfifosize.b.depth = TX1_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
 80022c6:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
    
    
    /* EP2 TX*/
    txfifosize.b.startaddr += txfifosize.b.depth;
 80022ca:	f362 030f 	bfi	r3, r2, #0, #16
    txfifosize.b.depth = TX2_FIFO_FS_SIZE;
 80022ce:	f36f 431f 	bfc	r3, #16, #16
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[1], txfifosize.d32 );
 80022d2:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
    
    
    /* EP3 TX*/  
    txfifosize.b.startaddr += txfifosize.b.depth;
    txfifosize.b.depth = TX3_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[2], txfifosize.d32 );
 80022d6:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
 80022da:	e788      	b.n	80021ee <USB_OTG_CoreInitDev+0x1e>

080022dc <USB_OTG_GetDeviceSpeed>:
{
  USB_OTG_DSTS_TypeDef  dsts;
  enum USB_OTG_SPEED speed = USB_SPEED_UNKNOWN;
  
  
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 80022dc:	6900      	ldr	r0, [r0, #16]
 80022de:	6883      	ldr	r3, [r0, #8]
  
  switch (dsts.b.enumspd)
 80022e0:	f3c3 0341 	ubfx	r3, r3, #1, #2
 80022e4:	1e5a      	subs	r2, r3, #1
 80022e6:	2a02      	cmp	r2, #2
 80022e8:	d804      	bhi.n	80022f4 <USB_OTG_GetDeviceSpeed+0x18>
 80022ea:	4a03      	ldr	r2, [pc, #12]	; (80022f8 <USB_OTG_GetDeviceSpeed+0x1c>)
 80022ec:	18d1      	adds	r1, r2, r3
 80022ee:	f811 0c01 	ldrb.w	r0, [r1, #-1]
 80022f2:	4770      	bx	lr
 80022f4:	2003      	movs	r0, #3
    speed = USB_SPEED_LOW;
    break;
  }
  
  return speed;
}
 80022f6:	4770      	bx	lr
 80022f8:	0800fff8 	.word	0x0800fff8

080022fc <USB_OTG_EP0Activate>:
  USB_OTG_DEPCTL_TypeDef  diepctl;
  USB_OTG_DCTL_TypeDef    dctl;
  
  dctl.d32 = 0;
  /* Read the Device Status and Endpoint 0 Control registers */
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 80022fc:	6903      	ldr	r3, [r0, #16]
  diepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL);
 80022fe:	6982      	ldr	r2, [r0, #24]
  USB_OTG_DEPCTL_TypeDef  diepctl;
  USB_OTG_DCTL_TypeDef    dctl;
  
  dctl.d32 = 0;
  /* Read the Device Status and Endpoint 0 Control registers */
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8002300:	6898      	ldr	r0, [r3, #8]
  diepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL);
 8002302:	6811      	ldr	r1, [r2, #0]
  /* Set the MPS of the IN EP based on the enumeration speed */
  switch (dsts.b.enumspd)
 8002304:	f3c0 0041 	ubfx	r0, r0, #1, #2
 8002308:	2802      	cmp	r0, #2
 800230a:	d008      	beq.n	800231e <USB_OTG_EP0Activate+0x22>
  {
  case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
  case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
  case DSTS_ENUMSPD_FS_PHY_48MHZ:
    diepctl.b.mps = DEP0CTL_MPS_64;
 800230c:	f36f 010a 	bfc	r1, #0, #11
    break;
  case DSTS_ENUMSPD_LS_PHY_6MHZ:
    diepctl.b.mps = DEP0CTL_MPS_8;
    break;
  }
  USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL, diepctl.d32);
 8002310:	6011      	str	r1, [r2, #0]
  dctl.b.cgnpinnak = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, dctl.d32);
 8002312:	6859      	ldr	r1, [r3, #4]
 8002314:	f441 7280 	orr.w	r2, r1, #256	; 0x100
 8002318:	605a      	str	r2, [r3, #4]
  return status;
}
 800231a:	2000      	movs	r0, #0
 800231c:	4770      	bx	lr
  case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
  case DSTS_ENUMSPD_FS_PHY_48MHZ:
    diepctl.b.mps = DEP0CTL_MPS_64;
    break;
  case DSTS_ENUMSPD_LS_PHY_6MHZ:
    diepctl.b.mps = DEP0CTL_MPS_8;
 800231e:	2003      	movs	r0, #3
 8002320:	f360 010a 	bfi	r1, r0, #0, #11
    break;
  }
  USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL, diepctl.d32);
 8002324:	6011      	str	r1, [r2, #0]
  dctl.b.cgnpinnak = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, dctl.d32);
 8002326:	6859      	ldr	r1, [r3, #4]
 8002328:	f441 7280 	orr.w	r2, r1, #256	; 0x100
 800232c:	605a      	str	r2, [r3, #4]
  return status;
}
 800232e:	2000      	movs	r0, #0
 8002330:	4770      	bx	lr
 8002332:	bf00      	nop

08002334 <USB_OTG_EPActivate>:
* @brief  USB_OTG_EPActivate : Activates an EP
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPActivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 8002334:	b470      	push	{r4, r5, r6}
  
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 8002336:	784b      	ldrb	r3, [r1, #1]
  USB_OTG_DAINT_TypeDef  daintmsk;
  __IO uint32_t *addr;
  
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;
 8002338:	2200      	movs	r2, #0
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 800233a:	2b01      	cmp	r3, #1
 800233c:	d027      	beq.n	800238e <USB_OTG_EPActivate+0x5a>
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 800233e:	780c      	ldrb	r4, [r1, #0]
 8002340:	eb00 0c84 	add.w	ip, r0, r4, lsl #2
    daintmsk.ep.out = 1 << ep->num;
 8002344:	2501      	movs	r5, #1
 8002346:	fa15 f304 	lsls.w	r3, r5, r4
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 800234a:	f8dc 4054 	ldr.w	r4, [ip, #84]	; 0x54
    daintmsk.ep.out = 1 << ep->num;
 800234e:	f363 421f 	bfi	r2, r3, #16, #16
  }
  /* If the EP is already active don't change the EP Control
  * register. */
  depctl.d32 = USB_OTG_READ_REG32(addr);
 8002352:	6823      	ldr	r3, [r4, #0]
  if (!depctl.b.usbactep)
 8002354:	f3c3 2507 	ubfx	r5, r3, #8, #8
 8002358:	f005 0c80 	and.w	ip, r5, #128	; 0x80
 800235c:	fa5f f58c 	uxtb.w	r5, ip
 8002360:	b975      	cbnz	r5, 8002380 <USB_OTG_EPActivate+0x4c>
  {
    depctl.b.mps    = ep->maxpacket;
 8002362:	688e      	ldr	r6, [r1, #8]
    depctl.b.eptype = ep->type;
 8002364:	78cd      	ldrb	r5, [r1, #3]
    depctl.b.txfnum = ep->tx_fifo_num;
 8002366:	f8b1 c006 	ldrh.w	ip, [r1, #6]
  /* If the EP is already active don't change the EP Control
  * register. */
  depctl.d32 = USB_OTG_READ_REG32(addr);
  if (!depctl.b.usbactep)
  {
    depctl.b.mps    = ep->maxpacket;
 800236a:	f366 030a 	bfi	r3, r6, #0, #11
    depctl.b.eptype = ep->type;
 800236e:	f365 4393 	bfi	r3, r5, #18, #2
    depctl.b.txfnum = ep->tx_fifo_num;
 8002372:	f36c 5399 	bfi	r3, ip, #22, #4
    depctl.b.setd0pid = 1;
 8002376:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    depctl.b.usbactep = 1;
 800237a:	f443 4100 	orr.w	r1, r3, #32768	; 0x8000
    USB_OTG_WRITE_REG32(addr, depctl.d32);
 800237e:	6021      	str	r1, [r4, #0]
  {
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, 0, daintmsk.d32);
  }
  else
#endif   
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, 0, daintmsk.d32);
 8002380:	6900      	ldr	r0, [r0, #16]
 8002382:	69c1      	ldr	r1, [r0, #28]
 8002384:	430a      	orrs	r2, r1
 8002386:	61c2      	str	r2, [r0, #28]
  return status;
}
 8002388:	2000      	movs	r0, #0
 800238a:	bc70      	pop	{r4, r5, r6}
 800238c:	4770      	bx	lr
  depctl.d32 = 0;
  daintmsk.d32 = 0;
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 800238e:	780c      	ldrb	r4, [r1, #0]
 8002390:	eb00 0584 	add.w	r5, r0, r4, lsl #2
    daintmsk.ep.in = 1 << ep->num;
 8002394:	40a3      	lsls	r3, r4
 8002396:	f363 020f 	bfi	r2, r3, #0, #16
  depctl.d32 = 0;
  daintmsk.d32 = 0;
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 800239a:	69ac      	ldr	r4, [r5, #24]
 800239c:	e7d9      	b.n	8002352 <USB_OTG_EPActivate+0x1e>
 800239e:	bf00      	nop

080023a0 <USB_OTG_EPDeactivate>:
* @brief  USB_OTG_EPDeactivate : Deactivates an EP
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPDeactivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 80023a0:	b430      	push	{r4, r5}
  __IO uint32_t *addr;
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 80023a2:	784a      	ldrb	r2, [r1, #1]
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_DEPCTL_TypeDef  depctl;
  USB_OTG_DAINT_TypeDef  daintmsk;
  __IO uint32_t *addr;
  
  depctl.d32 = 0;
 80023a4:	2300      	movs	r3, #0
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 80023a6:	2a01      	cmp	r2, #1
  USB_OTG_DEPCTL_TypeDef  depctl;
  USB_OTG_DAINT_TypeDef  daintmsk;
  __IO uint32_t *addr;
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
 80023a8:	461c      	mov	r4, r3
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 80023aa:	d014      	beq.n	80023d6 <USB_OTG_EPDeactivate+0x36>
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 80023ac:	7809      	ldrb	r1, [r1, #0]
 80023ae:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
    daintmsk.ep.out = 1 << ep->num;
 80023b2:	2501      	movs	r5, #1
 80023b4:	fa15 f201 	lsls.w	r2, r5, r1
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 80023b8:	f8dc 1054 	ldr.w	r1, [ip, #84]	; 0x54
    daintmsk.ep.out = 1 << ep->num;
 80023bc:	f362 441f 	bfi	r4, r2, #16, #16
  {
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, daintmsk.d32, 0);
  }
  else
#endif    
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, daintmsk.d32, 0);
 80023c0:	6900      	ldr	r0, [r0, #16]
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
    daintmsk.ep.out = 1 << ep->num;
  }
  depctl.b.usbactep = 0;
 80023c2:	f36f 33cf 	bfc	r3, #15, #1
  USB_OTG_WRITE_REG32(addr, depctl.d32);
 80023c6:	600b      	str	r3, [r1, #0]
  {
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, daintmsk.d32, 0);
  }
  else
#endif    
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, daintmsk.d32, 0);
 80023c8:	69c3      	ldr	r3, [r0, #28]
 80023ca:	ea23 0404 	bic.w	r4, r3, r4
 80023ce:	61c4      	str	r4, [r0, #28]
  return status;
}
 80023d0:	2000      	movs	r0, #0
 80023d2:	bc30      	pop	{r4, r5}
 80023d4:	4770      	bx	lr
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 80023d6:	7809      	ldrb	r1, [r1, #0]
 80023d8:	eb00 0581 	add.w	r5, r0, r1, lsl #2
    daintmsk.ep.in = 1 << ep->num;
 80023dc:	408a      	lsls	r2, r1
 80023de:	f362 040f 	bfi	r4, r2, #0, #16
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 80023e2:	69a9      	ldr	r1, [r5, #24]
 80023e4:	e7ec      	b.n	80023c0 <USB_OTG_EPDeactivate+0x20>
 80023e6:	bf00      	nop

080023e8 <USB_OTG_EPStartXfer>:
*         starts the xfer
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPStartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 80023e8:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t fifoemptymsk = 0;  
  
  depctl.d32 = 0;
  deptsiz.d32 = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
 80023ea:	784b      	ldrb	r3, [r1, #1]
 80023ec:	2b01      	cmp	r3, #1
 80023ee:	d041      	beq.n	8002474 <USB_OTG_EPStartXfer+0x8c>
    }    
  }
  else
  {
    /* OUT endpoint */
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL));
 80023f0:	f891 c000 	ldrb.w	ip, [r1]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ));
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    if (ep->xfer_len == 0)
 80023f4:	694e      	ldr	r6, [r1, #20]
    }    
  }
  else
  {
    /* OUT endpoint */
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL));
 80023f6:	eb00 038c 	add.w	r3, r0, ip, lsl #2
 80023fa:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80023fc:	681c      	ldr	r4, [r3, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ));
 80023fe:	691a      	ldr	r2, [r3, #16]
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    if (ep->xfer_len == 0)
 8002400:	b1f6      	cbz	r6, 8002440 <USB_OTG_EPStartXfer+0x58>
      deptsiz.b.xfersize = ep->maxpacket;
      deptsiz.b.pktcnt = 1;
    }
    else
    {
      deptsiz.b.pktcnt = (ep->xfer_len + (ep->maxpacket - 1)) / ep->maxpacket;
 8002402:	688f      	ldr	r7, [r1, #8]
 8002404:	19f5      	adds	r5, r6, r7
 8002406:	3d01      	subs	r5, #1
 8002408:	fbb5 f5f7 	udiv	r5, r5, r7
 800240c:	05ad      	lsls	r5, r5, #22
 800240e:	0dad      	lsrs	r5, r5, #22
 8002410:	f365 42dc 	bfi	r2, r5, #19, #10
      deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
 8002414:	fb07 f505 	mul.w	r5, r7, r5
 8002418:	f365 0212 	bfi	r2, r5, #0, #19
    }
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
 800241c:	611a      	str	r2, [r3, #16]
    
    if (pdev->cfg.dma_enable == 1)
 800241e:	78c2      	ldrb	r2, [r0, #3]
 8002420:	2a01      	cmp	r2, #1
 8002422:	d017      	beq.n	8002454 <USB_OTG_EPStartXfer+0x6c>
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
    }
    
    if (ep->type == EP_TYPE_ISOC)
 8002424:	78ca      	ldrb	r2, [r1, #3]
 8002426:	2a01      	cmp	r2, #1
 8002428:	d01e      	beq.n	8002468 <USB_OTG_EPStartXfer+0x80>
      }
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL, depctl.d32);
 800242a:	f891 c000 	ldrb.w	ip, [r1]
 800242e:	eb00 018c 	add.w	r1, r0, ip, lsl #2
        depctl.b.setd0pid = 1;
      }
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 8002432:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL, depctl.d32);
 8002436:	6d48      	ldr	r0, [r1, #84]	; 0x54
 8002438:	6004      	str	r4, [r0, #0]
  }
  return status;
}
 800243a:	2000      	movs	r0, #0
 800243c:	bcf0      	pop	{r4, r5, r6, r7}
 800243e:	4770      	bx	lr
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = ep->maxpacket;
 8002440:	688d      	ldr	r5, [r1, #8]
 8002442:	f365 0212 	bfi	r2, r5, #0, #19
      deptsiz.b.pktcnt = 1;
 8002446:	2501      	movs	r5, #1
 8002448:	f365 42dc 	bfi	r2, r5, #19, #10
    else
    {
      deptsiz.b.pktcnt = (ep->xfer_len + (ep->maxpacket - 1)) / ep->maxpacket;
      deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
    }
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
 800244c:	611a      	str	r2, [r3, #16]
    
    if (pdev->cfg.dma_enable == 1)
 800244e:	78c2      	ldrb	r2, [r0, #3]
 8002450:	2a01      	cmp	r2, #1
 8002452:	d1e7      	bne.n	8002424 <USB_OTG_EPStartXfer+0x3c>
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
 8002454:	780b      	ldrb	r3, [r1, #0]
 8002456:	690a      	ldr	r2, [r1, #16]
 8002458:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
 800245c:	f8dc 3054 	ldr.w	r3, [ip, #84]	; 0x54
 8002460:	615a      	str	r2, [r3, #20]
    }
    
    if (ep->type == EP_TYPE_ISOC)
 8002462:	78ca      	ldrb	r2, [r1, #3]
 8002464:	2a01      	cmp	r2, #1
 8002466:	d1e0      	bne.n	800242a <USB_OTG_EPStartXfer+0x42>
    {
      if (ep->even_odd_frame)
 8002468:	794b      	ldrb	r3, [r1, #5]
 800246a:	2b00      	cmp	r3, #0
 800246c:	d072      	beq.n	8002554 <USB_OTG_EPStartXfer+0x16c>
      {
        depctl.b.setd1pid = 1;
 800246e:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
 8002472:	e7da      	b.n	800242a <USB_OTG_EPStartXfer+0x42>
  depctl.d32 = 0;
  deptsiz.d32 = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
 8002474:	780d      	ldrb	r5, [r1, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 8002476:	694a      	ldr	r2, [r1, #20]
  depctl.d32 = 0;
  deptsiz.d32 = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
 8002478:	eb00 0485 	add.w	r4, r0, r5, lsl #2
 800247c:	69a5      	ldr	r5, [r4, #24]
 800247e:	682e      	ldr	r6, [r5, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
 8002480:	692c      	ldr	r4, [r5, #16]
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 8002482:	2a00      	cmp	r2, #0
 8002484:	d061      	beq.n	800254a <USB_OTG_EPStartXfer+0x162>
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      deptsiz.b.xfersize = ep->xfer_len;
      deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
 8002486:	688b      	ldr	r3, [r1, #8]

      if (ep->type == EP_TYPE_ISOC)
 8002488:	78cf      	ldrb	r7, [r1, #3]
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      deptsiz.b.xfersize = ep->xfer_len;
      deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
 800248a:	eb02 0c03 	add.w	ip, r2, r3
 800248e:	f10c 3cff 	add.w	ip, ip, #4294967295
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      deptsiz.b.xfersize = ep->xfer_len;
 8002492:	f362 0412 	bfi	r4, r2, #0, #19
      deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
 8002496:	fbbc f3f3 	udiv	r3, ip, r3
 800249a:	f363 44dc 	bfi	r4, r3, #19, #10

      if (ep->type == EP_TYPE_ISOC)
 800249e:	2f01      	cmp	r7, #1
      {
        deptsiz.b.mc = 1;
 80024a0:	bf08      	it	eq
 80024a2:	f367 745e 	bfieq	r4, r7, #29, #2
      }       
    }
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ, deptsiz.d32);
 80024a6:	612c      	str	r4, [r5, #16]
    
    if (pdev->cfg.dma_enable == 1)
 80024a8:	78c5      	ldrb	r5, [r0, #3]
 80024aa:	2d01      	cmp	r5, #1
 80024ac:	d05f      	beq.n	800256e <USB_OTG_EPStartXfer+0x186>
    {
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);
    }
    else
    {
      if (ep->type != EP_TYPE_ISOC)
 80024ae:	78cb      	ldrb	r3, [r1, #3]
 80024b0:	2b01      	cmp	r3, #1
 80024b2:	d052      	beq.n	800255a <USB_OTG_EPStartXfer+0x172>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0)
 80024b4:	b162      	cbz	r2, 80024d0 <USB_OTG_EPStartXfer+0xe8>
        {
          fifoemptymsk = 1 << ep->num;
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 80024b6:	6903      	ldr	r3, [r0, #16]
      if (ep->type != EP_TYPE_ISOC)
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0)
        {
          fifoemptymsk = 1 << ep->num;
 80024b8:	780c      	ldrb	r4, [r1, #0]
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 80024ba:	6b5d      	ldr	r5, [r3, #52]	; 0x34
      if (ep->type != EP_TYPE_ISOC)
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0)
        {
          fifoemptymsk = 1 << ep->num;
 80024bc:	2701      	movs	r7, #1
 80024be:	fa17 f404 	lsls.w	r4, r7, r4
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 80024c2:	432c      	orrs	r4, r5
 80024c4:	635c      	str	r4, [r3, #52]	; 0x34
        }
      }
    }
    
    
    if (ep->type == EP_TYPE_ISOC)
 80024c6:	f891 c003 	ldrb.w	ip, [r1, #3]
 80024ca:	f1bc 0f01 	cmp.w	ip, #1
 80024ce:	d044      	beq.n	800255a <USB_OTG_EPStartXfer+0x172>
    } 
    
    /* EP enable, IN data in FIFO */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);
 80024d0:	780d      	ldrb	r5, [r1, #0]
 80024d2:	eb00 0c85 	add.w	ip, r0, r5, lsl #2
      }
    } 
    
    /* EP enable, IN data in FIFO */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 80024d6:	f046 4604 	orr.w	r6, r6, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);
 80024da:	f8dc 3018 	ldr.w	r3, [ip, #24]
 80024de:	601e      	str	r6, [r3, #0]

    if (ep->type == EP_TYPE_ISOC)
 80024e0:	78cd      	ldrb	r5, [r1, #3]
 80024e2:	2d01      	cmp	r5, #1
 80024e4:	d1a9      	bne.n	800243a <USB_OTG_EPStartXfer+0x52>
                                uint8_t             *src, 
                                uint8_t             ch_ep_num, 
                                uint16_t            len)
{
  USB_OTG_STS status = USB_OTG_OK;
  if (pdev->cfg.dma_enable == 0)
 80024e6:	78c4      	ldrb	r4, [r0, #3]
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);

    if (ep->type == EP_TYPE_ISOC)
    {
      USB_OTG_WritePacket(pdev, ep->xfer_buff, ep->num, ep->xfer_len);   
 80024e8:	68cb      	ldr	r3, [r1, #12]
 80024ea:	7809      	ldrb	r1, [r1, #0]
                                uint8_t             *src, 
                                uint8_t             ch_ep_num, 
                                uint16_t            len)
{
  USB_OTG_STS status = USB_OTG_OK;
  if (pdev->cfg.dma_enable == 0)
 80024ec:	2c00      	cmp	r4, #0
 80024ee:	d1a4      	bne.n	800243a <USB_OTG_EPStartXfer+0x52>
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
 80024f0:	b294      	uxth	r4, r2
 80024f2:	1ce2      	adds	r2, r4, #3
    fifo = pdev->regs.DFIFO[ch_ep_num];
 80024f4:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    for (i = 0; i < count32b; i++, src+=4)
 80024f8:	1092      	asrs	r2, r2, #2
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
 80024fa:	f8d0 40d0 	ldr.w	r4, [r0, #208]	; 0xd0
    for (i = 0; i < count32b; i++, src+=4)
 80024fe:	d09c      	beq.n	800243a <USB_OTG_EPStartXfer+0x52>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8002500:	f853 1b04 	ldr.w	r1, [r3], #4
 8002504:	1e56      	subs	r6, r2, #1
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8002506:	2a01      	cmp	r2, #1
 8002508:	f006 0601 	and.w	r6, r6, #1
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 800250c:	6021      	str	r1, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 800250e:	4628      	mov	r0, r5
 8002510:	d093      	beq.n	800243a <USB_OTG_EPStartXfer+0x52>
 8002512:	b12e      	cbz	r6, 8002520 <USB_OTG_EPStartXfer+0x138>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8002514:	f853 1b04 	ldr.w	r1, [r3], #4
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8002518:	2002      	movs	r0, #2
 800251a:	4282      	cmp	r2, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 800251c:	6021      	str	r1, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 800251e:	d08c      	beq.n	800243a <USB_OTG_EPStartXfer+0x52>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8002520:	4619      	mov	r1, r3
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8002522:	3002      	adds	r0, #2
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8002524:	f851 5b04 	ldr.w	r5, [r1], #4
 8002528:	6025      	str	r5, [r4, #0]
 800252a:	685d      	ldr	r5, [r3, #4]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 800252c:	1d0b      	adds	r3, r1, #4
 800252e:	4282      	cmp	r2, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8002530:	6025      	str	r5, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8002532:	d082      	beq.n	800243a <USB_OTG_EPStartXfer+0x52>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8002534:	4619      	mov	r1, r3
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8002536:	3002      	adds	r0, #2
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8002538:	f851 5b04 	ldr.w	r5, [r1], #4
 800253c:	6025      	str	r5, [r4, #0]
 800253e:	685d      	ldr	r5, [r3, #4]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8002540:	1d0b      	adds	r3, r1, #4
 8002542:	4282      	cmp	r2, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8002544:	6025      	str	r5, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8002546:	d1eb      	bne.n	8002520 <USB_OTG_EPStartXfer+0x138>
 8002548:	e777      	b.n	800243a <USB_OTG_EPStartXfer+0x52>
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = 0;
 800254a:	f362 0412 	bfi	r4, r2, #0, #19
      deptsiz.b.pktcnt = 1;
 800254e:	f363 44dc 	bfi	r4, r3, #19, #10
 8002552:	e7a8      	b.n	80024a6 <USB_OTG_EPStartXfer+0xbe>
      {
        depctl.b.setd1pid = 1;
      }
      else
      {
        depctl.b.setd0pid = 1;
 8002554:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
 8002558:	e767      	b.n	800242a <USB_OTG_EPStartXfer+0x42>
    }
    
    
    if (ep->type == EP_TYPE_ISOC)
    {
      dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 800255a:	6905      	ldr	r5, [r0, #16]
 800255c:	68ab      	ldr	r3, [r5, #8]
      
      if (((dsts.b.soffn)&0x1) == 0)
 800255e:	f413 7f80 	tst.w	r3, #256	; 0x100
      {
        depctl.b.setd1pid = 1;
 8002562:	bf0c      	ite	eq
 8002564:	f046 5600 	orreq.w	r6, r6, #536870912	; 0x20000000
      }
      else
      {
        depctl.b.setd0pid = 1;
 8002568:	f046 5680 	orrne.w	r6, r6, #268435456	; 0x10000000
 800256c:	e7b0      	b.n	80024d0 <USB_OTG_EPStartXfer+0xe8>
    }
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ, deptsiz.d32);
    
    if (pdev->cfg.dma_enable == 1)
    {
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);
 800256e:	780d      	ldrb	r5, [r1, #0]
 8002570:	690c      	ldr	r4, [r1, #16]
 8002572:	eb00 0c85 	add.w	ip, r0, r5, lsl #2
 8002576:	f8dc 3018 	ldr.w	r3, [ip, #24]
 800257a:	615c      	str	r4, [r3, #20]
 800257c:	e7a3      	b.n	80024c6 <USB_OTG_EPStartXfer+0xde>
 800257e:	bf00      	nop

08002580 <USB_OTG_EP0StartXfer>:
*         starts the xfer
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EP0StartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 8002580:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t fifoemptymsk = 0;
  
  depctl.d32   = 0;
  deptsiz.d32  = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
 8002582:	784b      	ldrb	r3, [r1, #1]
 8002584:	2b01      	cmp	r3, #1
*         starts the xfer
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EP0StartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 8002586:	b082      	sub	sp, #8
  uint32_t fifoemptymsk = 0;
  
  depctl.d32   = 0;
  deptsiz.d32  = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
 8002588:	d02f      	beq.n	80025ea <USB_OTG_EP0StartXfer+0x6a>
    }
  }
  else
  {
    /* OUT endpoint */
    depctl.d32  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 800258a:	f891 c000 	ldrb.w	ip, [r1]
    deptsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ);
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
 800258e:	694e      	ldr	r6, [r1, #20]
    }
  }
  else
  {
    /* OUT endpoint */
    depctl.d32  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 8002590:	eb00 048c 	add.w	r4, r0, ip, lsl #2
 8002594:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8002596:	681a      	ldr	r2, [r3, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ);
 8002598:	691d      	ldr	r5, [r3, #16]
 800259a:	9500      	str	r5, [sp, #0]
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
 800259c:	b1fe      	cbz	r6, 80025de <USB_OTG_EP0StartXfer+0x5e>
      deptsiz.b.xfersize = ep->maxpacket;
      deptsiz.b.pktcnt = 1;
    }
    else
    {
      ep->xfer_len = ep->maxpacket;
 800259e:	688e      	ldr	r6, [r1, #8]
      deptsiz.b.xfersize = ep->maxpacket;
 80025a0:	f89d 5000 	ldrb.w	r5, [sp]
      deptsiz.b.pktcnt = 1;
 80025a4:	f89d 4002 	ldrb.w	r4, [sp, #2]
      deptsiz.b.xfersize = ep->maxpacket;
      deptsiz.b.pktcnt = 1;
    }
    else
    {
      ep->xfer_len = ep->maxpacket;
 80025a8:	614e      	str	r6, [r1, #20]
      deptsiz.b.xfersize = ep->maxpacket;
 80025aa:	f366 0506 	bfi	r5, r6, #0, #7
      deptsiz.b.pktcnt = 1;
 80025ae:	2601      	movs	r6, #1
 80025b0:	f366 04c4 	bfi	r4, r6, #3, #2
      deptsiz.b.pktcnt = 1;
    }
    else
    {
      ep->xfer_len = ep->maxpacket;
      deptsiz.b.xfersize = ep->maxpacket;
 80025b4:	f88d 5000 	strb.w	r5, [sp]
      deptsiz.b.pktcnt = 1;
 80025b8:	f88d 4002 	strb.w	r4, [sp, #2]
    }
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
 80025bc:	9c00      	ldr	r4, [sp, #0]
 80025be:	611c      	str	r4, [r3, #16]
    if (pdev->cfg.dma_enable == 1)
 80025c0:	78c3      	ldrb	r3, [r0, #3]
 80025c2:	2b01      	cmp	r3, #1
 80025c4:	d041      	beq.n	800264a <USB_OTG_EP0StartXfer+0xca>
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32 (&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL), depctl.d32);
 80025c6:	f891 c000 	ldrb.w	ip, [r1]
 80025ca:	eb00 008c 	add.w	r0, r0, ip, lsl #2
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 80025ce:	f042 4104 	orr.w	r1, r2, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32 (&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL), depctl.d32);
 80025d2:	6d42      	ldr	r2, [r0, #84]	; 0x54
 80025d4:	6011      	str	r1, [r2, #0]
    
  }
  return status;
}
 80025d6:	2000      	movs	r0, #0
 80025d8:	b002      	add	sp, #8
 80025da:	bcf0      	pop	{r4, r5, r6, r7}
 80025dc:	4770      	bx	lr
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = ep->maxpacket;
 80025de:	f89d 5000 	ldrb.w	r5, [sp]
      deptsiz.b.pktcnt = 1;
 80025e2:	f89d 4002 	ldrb.w	r4, [sp, #2]
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = ep->maxpacket;
 80025e6:	688e      	ldr	r6, [r1, #8]
 80025e8:	e7df      	b.n	80025aa <USB_OTG_EP0StartXfer+0x2a>
  depctl.d32   = 0;
  deptsiz.d32  = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    in_regs = pdev->regs.INEP_REGS[0];
 80025ea:	6982      	ldr	r2, [r0, #24]
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 80025ec:	694c      	ldr	r4, [r1, #20]
  deptsiz.d32  = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    in_regs = pdev->regs.INEP_REGS[0];
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
 80025ee:	6815      	ldr	r5, [r2, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
 80025f0:	6916      	ldr	r6, [r2, #16]
 80025f2:	9600      	str	r6, [sp, #0]
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 80025f4:	2c00      	cmp	r4, #0
 80025f6:	d030      	beq.n	800265a <USB_OTG_EP0StartXfer+0xda>
      deptsiz.b.pktcnt = 1;
      
    }
    else
    {
      if (ep->xfer_len > ep->maxpacket)
 80025f8:	688b      	ldr	r3, [r1, #8]
 80025fa:	429c      	cmp	r4, r3
 80025fc:	d942      	bls.n	8002684 <USB_OTG_EP0StartXfer+0x104>
      {
        ep->xfer_len = ep->maxpacket;
        deptsiz.b.xfersize = ep->maxpacket;
 80025fe:	f89d 4000 	ldrb.w	r4, [sp]
    }
    else
    {
      if (ep->xfer_len > ep->maxpacket)
      {
        ep->xfer_len = ep->maxpacket;
 8002602:	614b      	str	r3, [r1, #20]
        deptsiz.b.xfersize = ep->maxpacket;
 8002604:	f363 0406 	bfi	r4, r3, #0, #7
 8002608:	f88d 4000 	strb.w	r4, [sp]
      }
      else
      {
        deptsiz.b.xfersize = ep->xfer_len;
      }
      deptsiz.b.pktcnt = 1;
 800260c:	f89d c002 	ldrb.w	ip, [sp, #2]
 8002610:	2401      	movs	r4, #1
 8002612:	f364 0cc4 	bfi	ip, r4, #3, #2
 8002616:	f88d c002 	strb.w	ip, [sp, #2]
    }
    USB_OTG_WRITE_REG32(&in_regs->DIEPTSIZ, deptsiz.d32);
 800261a:	9b00      	ldr	r3, [sp, #0]
 800261c:	6113      	str	r3, [r2, #16]
    
    if (pdev->cfg.dma_enable == 1)
 800261e:	78c3      	ldrb	r3, [r0, #3]
 8002620:	2b01      	cmp	r3, #1
 8002622:	d027      	beq.n	8002674 <USB_OTG_EP0StartXfer+0xf4>
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);  
    }
    
    /* EP enable, IN data in FIFO */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 8002624:	f045 4304 	orr.w	r3, r5, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32(&in_regs->DIEPCTL, depctl.d32);
 8002628:	6013      	str	r3, [r2, #0]
    
    
    
    if (pdev->cfg.dma_enable == 0)
 800262a:	78c2      	ldrb	r2, [r0, #3]
 800262c:	2a00      	cmp	r2, #0
 800262e:	d1d2      	bne.n	80025d6 <USB_OTG_EP0StartXfer+0x56>
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0)
 8002630:	694a      	ldr	r2, [r1, #20]
 8002632:	2a00      	cmp	r2, #0
 8002634:	d0cf      	beq.n	80025d6 <USB_OTG_EP0StartXfer+0x56>
      {
        {
          fifoemptymsk |= 1 << ep->num;
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 8002636:	6903      	ldr	r3, [r0, #16]
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0)
      {
        {
          fifoemptymsk |= 1 << ep->num;
 8002638:	780a      	ldrb	r2, [r1, #0]
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 800263a:	6b59      	ldr	r1, [r3, #52]	; 0x34
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0)
      {
        {
          fifoemptymsk |= 1 << ep->num;
 800263c:	2001      	movs	r0, #1
 800263e:	fa10 f202 	lsls.w	r2, r0, r2
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 8002642:	ea42 0001 	orr.w	r0, r2, r1
 8002646:	6358      	str	r0, [r3, #52]	; 0x34
 8002648:	e7c5      	b.n	80025d6 <USB_OTG_EP0StartXfer+0x56>
      deptsiz.b.pktcnt = 1;
    }
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
    if (pdev->cfg.dma_enable == 1)
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
 800264a:	780b      	ldrb	r3, [r1, #0]
 800264c:	690c      	ldr	r4, [r1, #16]
 800264e:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
 8002652:	f8dc 3054 	ldr.w	r3, [ip, #84]	; 0x54
 8002656:	615c      	str	r4, [r3, #20]
 8002658:	e7b5      	b.n	80025c6 <USB_OTG_EP0StartXfer+0x46>
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = 0;
 800265a:	f89d 7000 	ldrb.w	r7, [sp]
      deptsiz.b.pktcnt = 1;
 800265e:	f89d 6002 	ldrb.w	r6, [sp, #2]
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = 0;
 8002662:	f364 0706 	bfi	r7, r4, #0, #7
      deptsiz.b.pktcnt = 1;
 8002666:	f363 06c4 	bfi	r6, r3, #3, #2
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = 0;
 800266a:	f88d 7000 	strb.w	r7, [sp]
      deptsiz.b.pktcnt = 1;
 800266e:	f88d 6002 	strb.w	r6, [sp, #2]
 8002672:	e7d2      	b.n	800261a <USB_OTG_EP0StartXfer+0x9a>
    }
    USB_OTG_WRITE_REG32(&in_regs->DIEPTSIZ, deptsiz.d32);
    
    if (pdev->cfg.dma_enable == 1)
    {
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);  
 8002674:	780b      	ldrb	r3, [r1, #0]
 8002676:	690c      	ldr	r4, [r1, #16]
 8002678:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
 800267c:	f8dc 3018 	ldr.w	r3, [ip, #24]
 8002680:	615c      	str	r4, [r3, #20]
 8002682:	e7cf      	b.n	8002624 <USB_OTG_EP0StartXfer+0xa4>
        ep->xfer_len = ep->maxpacket;
        deptsiz.b.xfersize = ep->maxpacket;
      }
      else
      {
        deptsiz.b.xfersize = ep->xfer_len;
 8002684:	f89d 3000 	ldrb.w	r3, [sp]
 8002688:	f364 0306 	bfi	r3, r4, #0, #7
 800268c:	f88d 3000 	strb.w	r3, [sp]
 8002690:	e7bc      	b.n	800260c <USB_OTG_EP0StartXfer+0x8c>
 8002692:	bf00      	nop

08002694 <USB_OTG_EPSetStall>:
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
 8002694:	784b      	ldrb	r3, [r1, #1]
 8002696:	2b01      	cmp	r3, #1
 8002698:	d00a      	beq.n	80026b0 <USB_OTG_EPSetStall+0x1c>
    depctl.b.stall = 1;
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
  }
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 800269a:	7809      	ldrb	r1, [r1, #0]
 800269c:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
 80026a0:	f8dc 3054 	ldr.w	r3, [ip, #84]	; 0x54
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 80026a4:	681a      	ldr	r2, [r3, #0]
    /* set the stall bit */
    depctl.b.stall = 1;
 80026a6:	f442 1000 	orr.w	r0, r2, #2097152	; 0x200000
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
 80026aa:	6018      	str	r0, [r3, #0]
  }
  return status;
}
 80026ac:	2000      	movs	r0, #0
 80026ae:	4770      	bx	lr
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 80026b0:	780b      	ldrb	r3, [r1, #0]
 80026b2:	eb00 0283 	add.w	r2, r0, r3, lsl #2
 80026b6:	6992      	ldr	r2, [r2, #24]
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 80026b8:	6813      	ldr	r3, [r2, #0]
    /* set the disable and stall bits */
    if (depctl.b.epena)
 80026ba:	f3c3 6c07 	ubfx	ip, r3, #24, #8
 80026be:	f00c 0080 	and.w	r0, ip, #128	; 0x80
 80026c2:	b2c1      	uxtb	r1, r0
 80026c4:	b109      	cbz	r1, 80026ca <USB_OTG_EPSetStall+0x36>
    {
      depctl.b.epdis = 1;
 80026c6:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    }
    depctl.b.stall = 1;
 80026ca:	f443 1100 	orr.w	r1, r3, #2097152	; 0x200000
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
 80026ce:	6011      	str	r1, [r2, #0]
    /* set the stall bit */
    depctl.b.stall = 1;
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
  }
  return status;
}
 80026d0:	2000      	movs	r0, #0
 80026d2:	4770      	bx	lr

080026d4 <USB_OTG_EPClearStall>:
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  
  if (ep->is_in == 1)
 80026d4:	f891 c001 	ldrb.w	ip, [r1, #1]
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 80026d8:	780b      	ldrb	r3, [r1, #0]
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 80026da:	78c9      	ldrb	r1, [r1, #3]
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  
  if (ep->is_in == 1)
 80026dc:	f1bc 0f01 	cmp.w	ip, #1
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 80026e0:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
 80026e4:	bf0c      	ite	eq
 80026e6:	f8dc 2018 	ldreq.w	r2, [ip, #24]
  }
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 80026ea:	f8dc 2054 	ldrne.w	r2, [ip, #84]	; 0x54
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 80026ee:	1e88      	subs	r0, r1, #2
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
  }
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 80026f0:	6813      	ldr	r3, [r2, #0]
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 80026f2:	b2c1      	uxtb	r1, r0
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
 80026f4:	f36f 5355 	bfc	r3, #21, #1
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 80026f8:	2901      	cmp	r1, #1
  {
    depctl.b.setd0pid = 1; /* DATA0 */
 80026fa:	bf98      	it	ls
 80026fc:	f043 5380 	orrls.w	r3, r3, #268435456	; 0x10000000
  }
  USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
 8002700:	6013      	str	r3, [r2, #0]
  return status;
}
 8002702:	2000      	movs	r0, #0
 8002704:	4770      	bx	lr
 8002706:	bf00      	nop

08002708 <USB_OTG_ReadDevAllOutEp_itr>:
* @retval OUT endpoint interrupt bits
*/
uint32_t USB_OTG_ReadDevAllOutEp_itr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v;
  v  = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
 8002708:	6903      	ldr	r3, [r0, #16]
 800270a:	699a      	ldr	r2, [r3, #24]
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
 800270c:	69d9      	ldr	r1, [r3, #28]
 800270e:	ea01 0002 	and.w	r0, r1, r2
  return ((v & 0xffff0000) >> 16);
}
 8002712:	0c00      	lsrs	r0, r0, #16
 8002714:	4770      	bx	lr
 8002716:	bf00      	nop

08002718 <USB_OTG_ReadDevOutEP_itr>:
* @retval Device OUT EP Interrupt register
*/
uint32_t USB_OTG_ReadDevOutEP_itr(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
  uint32_t v;
  v  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[epnum]->DOEPINT);
 8002718:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOEPMSK);
 800271c:	6902      	ldr	r2, [r0, #16]
* @retval Device OUT EP Interrupt register
*/
uint32_t USB_OTG_ReadDevOutEP_itr(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
  uint32_t v;
  v  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[epnum]->DOEPINT);
 800271e:	f8dc 1054 	ldr.w	r1, [ip, #84]	; 0x54
 8002722:	688b      	ldr	r3, [r1, #8]
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOEPMSK);
 8002724:	6950      	ldr	r0, [r2, #20]
  return v;
}
 8002726:	4018      	ands	r0, r3
 8002728:	4770      	bx	lr
 800272a:	bf00      	nop

0800272c <USB_OTG_ReadDevAllInEPItr>:
* @retval int status register
*/
uint32_t USB_OTG_ReadDevAllInEPItr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v;
  v = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
 800272c:	6902      	ldr	r2, [r0, #16]
 800272e:	6991      	ldr	r1, [r2, #24]
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
 8002730:	69d3      	ldr	r3, [r2, #28]
 8002732:	ea01 0003 	and.w	r0, r1, r3
  return (v & 0xffff);
}
 8002736:	b280      	uxth	r0, r0
 8002738:	4770      	bx	lr
 800273a:	bf00      	nop

0800273c <USB_OTG_EP0_OutStart>:
* @brief  configures EPO to receive SETUP packets
* @param  None
* @retval : None
*/
void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
{
 800273c:	b082      	sub	sp, #8
  USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
  doeptsize0.d32 = 0;
  doeptsize0.b.supcnt = 3;
  doeptsize0.b.pktcnt = 1;
 800273e:	2201      	movs	r2, #1
* @retval : None
*/
void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
  doeptsize0.d32 = 0;
 8002740:	2300      	movs	r3, #0
  doeptsize0.b.supcnt = 3;
  doeptsize0.b.pktcnt = 1;
 8002742:	2100      	movs	r1, #0
* @retval : None
*/
void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
  doeptsize0.d32 = 0;
 8002744:	9300      	str	r3, [sp, #0]
  doeptsize0.b.supcnt = 3;
  doeptsize0.b.pktcnt = 1;
 8002746:	f362 01c4 	bfi	r1, r2, #3, #2
  doeptsize0.b.xfersize = 8 * 3;
 800274a:	2318      	movs	r3, #24
*/
void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
  doeptsize0.d32 = 0;
  doeptsize0.b.supcnt = 3;
 800274c:	22c0      	movs	r2, #192	; 0xc0
 800274e:	f88d 2003 	strb.w	r2, [sp, #3]
  doeptsize0.b.pktcnt = 1;
 8002752:	f88d 1002 	strb.w	r1, [sp, #2]
  doeptsize0.b.xfersize = 8 * 3;
 8002756:	f88d 3000 	strb.w	r3, [sp]
  USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPTSIZ, doeptsize0.d32 );
 800275a:	6d43      	ldr	r3, [r0, #84]	; 0x54
 800275c:	9900      	ldr	r1, [sp, #0]
 800275e:	6119      	str	r1, [r3, #16]
  
  if (pdev->cfg.dma_enable == 1)
 8002760:	78c2      	ldrb	r2, [r0, #3]
 8002762:	2a01      	cmp	r2, #1
 8002764:	d106      	bne.n	8002774 <USB_OTG_EP0_OutStart+0x38>
  {
    USB_OTG_DEPCTL_TypeDef  doepctl;
    doepctl.d32 = 0;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPDMA, 
 8002766:	f500 61b9 	add.w	r1, r0, #1480	; 0x5c8
 800276a:	6159      	str	r1, [r3, #20]
    
    /* EP enable */
    doepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[0]->DOEPCTL);
    doepctl.b.epena = 1;
    doepctl.d32 = 0x80008000;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPCTL, doepctl.d32);
 800276c:	f04f 2080 	mov.w	r0, #2147516416	; 0x80008000
    doepctl.d32 = 0;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPDMA, 
                        (uint32_t)&pdev->dev.setup_packet);
    
    /* EP enable */
    doepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[0]->DOEPCTL);
 8002770:	681a      	ldr	r2, [r3, #0]
    doepctl.b.epena = 1;
    doepctl.d32 = 0x80008000;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPCTL, doepctl.d32);
 8002772:	6018      	str	r0, [r3, #0]
  }
}
 8002774:	b002      	add	sp, #8
 8002776:	4770      	bx	lr

08002778 <USB_OTG_ActiveRemoteWakeup>:
  
  USB_OTG_DCTL_TypeDef     dctl;
  USB_OTG_DSTS_TypeDef     dsts;
  USB_OTG_PCGCCTL_TypeDef  power;  
  
  if (pdev->dev.DevRemoteWakeup) 
 8002778:	f8d0 3114 	ldr.w	r3, [r0, #276]	; 0x114
* @brief  USB_OTG_RemoteWakeup : active remote wakeup signalling
* @param  None
* @retval : None
*/
void USB_OTG_ActiveRemoteWakeup(USB_OTG_CORE_HANDLE *pdev)
{
 800277c:	b510      	push	{r4, lr}
 800277e:	4604      	mov	r4, r0
  
  USB_OTG_DCTL_TypeDef     dctl;
  USB_OTG_DSTS_TypeDef     dsts;
  USB_OTG_PCGCCTL_TypeDef  power;  
  
  if (pdev->dev.DevRemoteWakeup) 
 8002780:	b1db      	cbz	r3, 80027ba <USB_OTG_ActiveRemoteWakeup+0x42>
  {
    dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8002782:	6903      	ldr	r3, [r0, #16]
 8002784:	689a      	ldr	r2, [r3, #8]
    if(dsts.b.suspsts == 1)
 8002786:	f012 0f01 	tst.w	r2, #1
 800278a:	d016      	beq.n	80027ba <USB_OTG_ActiveRemoteWakeup+0x42>
    {
      if(pdev->cfg.low_power)
 800278c:	7a81      	ldrb	r1, [r0, #10]
 800278e:	b141      	cbz	r1, 80027a2 <USB_OTG_ActiveRemoteWakeup+0x2a>
      {
        /* un-gate USB Core clock */
        power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
 8002790:	f8d0 210c 	ldr.w	r2, [r0, #268]	; 0x10c
        power.b.gatehclk = 0;
        power.b.stoppclk = 0;
        USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 8002794:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
    {
      if(pdev->cfg.low_power)
      {
        /* un-gate USB Core clock */
        power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
        power.b.gatehclk = 0;
 8002798:	f36f 0241 	bfc	r2, #1, #1
        power.b.stoppclk = 0;
 800279c:	f36f 0200 	bfc	r2, #0, #1
        USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 80027a0:	6002      	str	r2, [r0, #0]
      }   
      /* active Remote wakeup signaling */
      dctl.d32 = 0;
      dctl.b.rmtwkupsig = 1;
      USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, 0, dctl.d32);
 80027a2:	6859      	ldr	r1, [r3, #4]
 80027a4:	f041 0201 	orr.w	r2, r1, #1
 80027a8:	605a      	str	r2, [r3, #4]
      USB_OTG_BSP_mDelay(5);
 80027aa:	2005      	movs	r0, #5
 80027ac:	f001 f991 	bl	8003ad2 <USB_OTG_BSP_mDelay>
      USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
 80027b0:	6923      	ldr	r3, [r4, #16]
 80027b2:	6858      	ldr	r0, [r3, #4]
 80027b4:	f020 0101 	bic.w	r1, r0, #1
 80027b8:	6059      	str	r1, [r3, #4]
 80027ba:	bd10      	pop	{r4, pc}

080027bc <USB_OTG_UngateClock>:
* @param  None
* @retval : None
*/
void USB_OTG_UngateClock(USB_OTG_CORE_HANDLE *pdev)
{
  if(pdev->cfg.low_power)
 80027bc:	7a83      	ldrb	r3, [r0, #10]
 80027be:	b16b      	cbz	r3, 80027dc <USB_OTG_UngateClock+0x20>
  {
    
    USB_OTG_DSTS_TypeDef     dsts;
    USB_OTG_PCGCCTL_TypeDef  power; 
    
    dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 80027c0:	6902      	ldr	r2, [r0, #16]
 80027c2:	6891      	ldr	r1, [r2, #8]
    
    if(dsts.b.suspsts == 1)
 80027c4:	f011 0f01 	tst.w	r1, #1
 80027c8:	d008      	beq.n	80027dc <USB_OTG_UngateClock+0x20>
    {
      /* un-gate USB Core clock */
      power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
 80027ca:	f8d0 310c 	ldr.w	r3, [r0, #268]	; 0x10c
      power.b.gatehclk = 0;
      power.b.stoppclk = 0;
      USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 80027ce:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
    
    if(dsts.b.suspsts == 1)
    {
      /* un-gate USB Core clock */
      power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
      power.b.gatehclk = 0;
 80027d2:	f36f 0341 	bfc	r3, #1, #1
      power.b.stoppclk = 0;
 80027d6:	f36f 0300 	bfc	r3, #0, #1
      USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 80027da:	6003      	str	r3, [r0, #0]
 80027dc:	4770      	bx	lr
 80027de:	bf00      	nop

080027e0 <USB_OTG_StopDevice>:
* @brief  Stop the device and clean up fifo's
* @param  None
* @retval : None
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
{
 80027e0:	b570      	push	{r4, r5, r6, lr}
  uint32_t i;
  
  pdev->dev.device_status = 1;
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80027e2:	7843      	ldrb	r3, [r0, #1]
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t i;
  
  pdev->dev.device_status = 1;
 80027e4:	2201      	movs	r2, #1
* @brief  Stop the device and clean up fifo's
* @param  None
* @retval : None
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
{
 80027e6:	4604      	mov	r4, r0
  uint32_t i;
  
  pdev->dev.device_status = 1;
 80027e8:	f880 2112 	strb.w	r2, [r0, #274]	; 0x112
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80027ec:	b163      	cbz	r3, 8002808 <USB_OTG_StopDevice+0x28>
/**
* @brief  Stop the device and clean up fifo's
* @param  None
* @retval : None
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
 80027ee:	f100 0214 	add.w	r2, r0, #20
{
  uint32_t i;
  
  pdev->dev.device_status = 1;
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80027f2:	2300      	movs	r3, #0
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 80027f4:	21ff      	movs	r1, #255	; 0xff
 80027f6:	f852 5f04 	ldr.w	r5, [r2, #4]!
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 80027fa:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
  
  pdev->dev.device_status = 1;
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 80027fc:	60a9      	str	r1, [r5, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 80027fe:	6081      	str	r1, [r0, #8]
{
  uint32_t i;
  
  pdev->dev.device_status = 1;
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002800:	7860      	ldrb	r0, [r4, #1]
 8002802:	3301      	adds	r3, #1
 8002804:	4298      	cmp	r0, r3
 8002806:	d8f6      	bhi.n	80027f6 <USB_OTG_StopDevice+0x16>
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }

  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 8002808:	6923      	ldr	r3, [r4, #16]
 800280a:	2200      	movs	r2, #0
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
 800280c:	f04f 31ff 	mov.w	r1, #4294967295
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }

  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 8002810:	611a      	str	r2, [r3, #16]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
 8002812:	4620      	mov	r0, r4
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }

  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
 8002814:	615a      	str	r2, [r3, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
 8002816:	61da      	str	r2, [r3, #28]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
 8002818:	6199      	str	r1, [r3, #24]
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
 800281a:	f7ff fc55 	bl	80020c8 <USB_OTG_FlushRxFifo>
  USB_OTG_FlushTxFifo(pdev ,  0x10 );  
 800281e:	4620      	mov	r0, r4
 8002820:	2110      	movs	r1, #16
}
 8002822:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
  USB_OTG_FlushTxFifo(pdev ,  0x10 );  
 8002826:	e425      	b.n	8002074 <USB_OTG_FlushTxFifo>

08002828 <USB_OTG_GetEPStatus>:
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  uint32_t Status = 0;  
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
 8002828:	784b      	ldrb	r3, [r1, #1]
 800282a:	2b01      	cmp	r3, #1
 800282c:	d01a      	beq.n	8002864 <USB_OTG_GetEPStatus+0x3c>
      Status = USB_OTG_EP_TX_VALID;     

  }
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 800282e:	780b      	ldrb	r3, [r1, #0]
 8002830:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 8002834:	6d42      	ldr	r2, [r0, #84]	; 0x54
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 8002836:	6811      	ldr	r1, [r2, #0]
    if (depctl.b.stall == 1)  
 8002838:	f3c1 4007 	ubfx	r0, r1, #16, #8
 800283c:	f000 0c20 	and.w	ip, r0, #32
 8002840:	fa5f f38c 	uxtb.w	r3, ip
 8002844:	b95b      	cbnz	r3, 800285e <USB_OTG_GetEPStatus+0x36>
      Status = USB_OTG_EP_RX_STALL;
    else if (depctl.b.naksts == 1)
 8002846:	f000 0102 	and.w	r1, r0, #2
 800284a:	fa5f fc81 	uxtb.w	ip, r1
      Status = USB_OTG_EP_RX_NAK;
 800284e:	f1bc 0f00 	cmp.w	ip, #0
 8002852:	bf0c      	ite	eq
 8002854:	f44f 5040 	moveq.w	r0, #12288	; 0x3000
 8002858:	f44f 5000 	movne.w	r0, #8192	; 0x2000
 800285c:	4770      	bx	lr
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
    if (depctl.b.stall == 1)  
      Status = USB_OTG_EP_RX_STALL;
 800285e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
      Status = USB_OTG_EP_RX_VALID; 
  } 
  
  /* Return the current status */
  return Status;
}
 8002862:	4770      	bx	lr
  uint32_t Status = 0;  
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 8002864:	7809      	ldrb	r1, [r1, #0]
 8002866:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
 800286a:	f8dc 3018 	ldr.w	r3, [ip, #24]
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 800286e:	6818      	ldr	r0, [r3, #0]
    
    if (depctl.b.stall == 1)  
 8002870:	f3c0 4007 	ubfx	r0, r0, #16, #8
 8002874:	f000 0220 	and.w	r2, r0, #32
 8002878:	b2d1      	uxtb	r1, r2
 800287a:	b939      	cbnz	r1, 800288c <USB_OTG_GetEPStatus+0x64>
      Status = USB_OTG_EP_TX_STALL;
    else if (depctl.b.naksts == 1)
 800287c:	f000 0002 	and.w	r0, r0, #2
 8002880:	b2c2      	uxtb	r2, r0
      Status = USB_OTG_EP_TX_NAK;
 8002882:	2a00      	cmp	r2, #0
 8002884:	bf0c      	ite	eq
 8002886:	2030      	moveq	r0, #48	; 0x30
 8002888:	2020      	movne	r0, #32
 800288a:	4770      	bx	lr
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
    
    if (depctl.b.stall == 1)  
      Status = USB_OTG_EP_TX_STALL;
 800288c:	2010      	movs	r0, #16
 800288e:	4770      	bx	lr

08002890 <USB_OTG_SetEPStatus>:
*         Status : new Status
*         ep : EP structure
* @retval : None
*/
void USB_OTG_SetEPStatus (USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep , uint32_t Status)
{
 8002890:	b470      	push	{r4, r5, r6}
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;

  /* Process for IN endpoint */
  if (ep->is_in == 1)
 8002892:	784d      	ldrb	r5, [r1, #1]
 8002894:	2d01      	cmp	r5, #1
 8002896:	d016      	beq.n	80028c6 <USB_OTG_SetEPStatus+0x36>
    else if (Status == USB_OTG_EP_TX_DIS)
      depctl.b.usbactep = 0;
  } 
  else /* Process for OUT endpoint */
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 8002898:	f891 c000 	ldrb.w	ip, [r1]
 800289c:	eb00 068c 	add.w	r6, r0, ip, lsl #2
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);    
    
    if (Status == USB_OTG_EP_RX_STALL)  {
 80028a0:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    else if (Status == USB_OTG_EP_TX_DIS)
      depctl.b.usbactep = 0;
  } 
  else /* Process for OUT endpoint */
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 80028a4:	6d75      	ldr	r5, [r6, #84]	; 0x54
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);    
 80028a6:	682c      	ldr	r4, [r5, #0]
 80028a8:	4626      	mov	r6, r4
    
    if (Status == USB_OTG_EP_RX_STALL)  {
 80028aa:	d019      	beq.n	80028e0 <USB_OTG_SetEPStatus+0x50>
      depctl.b.stall = 1;
    }
    else if (Status == USB_OTG_EP_RX_NAK)
 80028ac:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 80028b0:	d013      	beq.n	80028da <USB_OTG_SetEPStatus+0x4a>
      depctl.b.snak = 1;
    else if (Status == USB_OTG_EP_RX_VALID)
 80028b2:	f5b2 5f40 	cmp.w	r2, #12288	; 0x3000
 80028b6:	d018      	beq.n	80028ea <USB_OTG_SetEPStatus+0x5a>
      }  
      depctl.b.cnak = 1;
      depctl.b.usbactep = 1;    
      depctl.b.epena = 1;
    }
    else if (Status == USB_OTG_EP_RX_DIS)
 80028b8:	b912      	cbnz	r2, 80028c0 <USB_OTG_SetEPStatus+0x30>
    {
      depctl.b.usbactep = 0;    
 80028ba:	f362 36cf 	bfi	r6, r2, #15, #1
 80028be:	4634      	mov	r4, r6
    }
  }

  USB_OTG_WRITE_REG32(depctl_addr, depctl.d32); 
 80028c0:	602c      	str	r4, [r5, #0]
}
 80028c2:	bc70      	pop	{r4, r5, r6}
 80028c4:	4770      	bx	lr
  depctl.d32 = 0;

  /* Process for IN endpoint */
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 80028c6:	780b      	ldrb	r3, [r1, #0]
 80028c8:	eb00 0483 	add.w	r4, r0, r3, lsl #2
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
    
    if (Status == USB_OTG_EP_TX_STALL)  
 80028cc:	2a10      	cmp	r2, #16
  depctl.d32 = 0;

  /* Process for IN endpoint */
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 80028ce:	69a5      	ldr	r5, [r4, #24]
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 80028d0:	682c      	ldr	r4, [r5, #0]
 80028d2:	4626      	mov	r6, r4
    
    if (Status == USB_OTG_EP_TX_STALL)  
 80028d4:	d018      	beq.n	8002908 <USB_OTG_SetEPStatus+0x78>
    {
      USB_OTG_EPSetStall(pdev, ep); return;
    }
    else if (Status == USB_OTG_EP_TX_NAK)
 80028d6:	2a20      	cmp	r2, #32
 80028d8:	d105      	bne.n	80028e6 <USB_OTG_SetEPStatus+0x56>
    
    if (Status == USB_OTG_EP_RX_STALL)  {
      depctl.b.stall = 1;
    }
    else if (Status == USB_OTG_EP_RX_NAK)
      depctl.b.snak = 1;
 80028da:	f044 6400 	orr.w	r4, r4, #134217728	; 0x8000000
 80028de:	e7ef      	b.n	80028c0 <USB_OTG_SetEPStatus+0x30>
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);    
    
    if (Status == USB_OTG_EP_RX_STALL)  {
      depctl.b.stall = 1;
 80028e0:	f444 1400 	orr.w	r4, r4, #2097152	; 0x200000
 80028e4:	e7ec      	b.n	80028c0 <USB_OTG_SetEPStatus+0x30>
    {
      USB_OTG_EPSetStall(pdev, ep); return;
    }
    else if (Status == USB_OTG_EP_TX_NAK)
      depctl.b.snak = 1;
    else if (Status == USB_OTG_EP_TX_VALID)
 80028e6:	2a30      	cmp	r2, #48	; 0x30
 80028e8:	d1e6      	bne.n	80028b8 <USB_OTG_SetEPStatus+0x28>
    }
    else if (Status == USB_OTG_EP_RX_NAK)
      depctl.b.snak = 1;
    else if (Status == USB_OTG_EP_RX_VALID)
    {
      if (depctl.b.stall == 1)
 80028ea:	f3c4 4c07 	ubfx	ip, r4, #16, #8
 80028ee:	f00c 0320 	and.w	r3, ip, #32
 80028f2:	b2da      	uxtb	r2, r3
 80028f4:	b922      	cbnz	r2, 8002900 <USB_OTG_SetEPStatus+0x70>
      {  
        ep->even_odd_frame = 0;
        USB_OTG_EPClearStall(pdev, ep);
        return;
      }  
      depctl.b.cnak = 1;
 80028f6:	f044 6080 	orr.w	r0, r4, #67108864	; 0x4000000
      depctl.b.usbactep = 1;    
      depctl.b.epena = 1;
 80028fa:	f040 2480 	orr.w	r4, r0, #2147516416	; 0x80008000
 80028fe:	e7df      	b.n	80028c0 <USB_OTG_SetEPStatus+0x30>
      depctl.b.snak = 1;
    else if (Status == USB_OTG_EP_RX_VALID)
    {
      if (depctl.b.stall == 1)
      {  
        ep->even_odd_frame = 0;
 8002900:	2200      	movs	r2, #0
 8002902:	714a      	strb	r2, [r1, #5]
      depctl.b.usbactep = 0;    
    }
  }

  USB_OTG_WRITE_REG32(depctl_addr, depctl.d32); 
}
 8002904:	bc70      	pop	{r4, r5, r6}
    else if (Status == USB_OTG_EP_RX_VALID)
    {
      if (depctl.b.stall == 1)
      {  
        ep->even_odd_frame = 0;
        USB_OTG_EPClearStall(pdev, ep);
 8002906:	e6e5      	b.n	80026d4 <USB_OTG_EPClearStall>
      depctl.b.usbactep = 0;    
    }
  }

  USB_OTG_WRITE_REG32(depctl_addr, depctl.d32); 
}
 8002908:	bc70      	pop	{r4, r5, r6}
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
    
    if (Status == USB_OTG_EP_TX_STALL)  
    {
      USB_OTG_EPSetStall(pdev, ep); return;
 800290a:	e6c3      	b.n	8002694 <USB_OTG_EPSetStall>

0800290c <DCD_Init>:



void DCD_Init(USB_OTG_CORE_HANDLE *pdev , 
              USB_OTG_CORE_ID_TypeDef coreID)
{
 800290c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002910:	4604      	mov	r4, r0
  uint32_t i;
  USB_OTG_EP *ep;
  
  USB_OTG_SelectCore (pdev , coreID);
 8002912:	f7ff fa3b 	bl	8001d8c <USB_OTG_SelectCore>
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002916:	7866      	ldrb	r6, [r4, #1]
  uint32_t i;
  USB_OTG_EP *ep;
  
  USB_OTG_SelectCore (pdev , coreID);
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
 8002918:	2701      	movs	r7, #1
  pdev->dev.device_address = 0;
 800291a:	2100      	movs	r1, #0
  uint32_t i;
  USB_OTG_EP *ep;
  
  USB_OTG_SelectCore (pdev , coreID);
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
 800291c:	f884 7112 	strb.w	r7, [r4, #274]	; 0x112
  pdev->dev.device_address = 0;
 8002920:	f884 1113 	strb.w	r1, [r4, #275]	; 0x113
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002924:	2e00      	cmp	r6, #0
 8002926:	f000 809a 	beq.w	8002a5e <DCD_Init+0x152>
 800292a:	1e73      	subs	r3, r6, #1
    ep->is_in = 1;
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 800292c:	f04f 0e40 	mov.w	lr, #64	; 0x40
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002930:	42b7      	cmp	r7, r6
 8002932:	ea03 0207 	and.w	r2, r3, r7
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
 8002936:	f884 7119 	strb.w	r7, [r4, #281]	; 0x119
    ep->num = i;
 800293a:	f884 1118 	strb.w	r1, [r4, #280]	; 0x118
    ep->tx_fifo_num = i;
 800293e:	f8a4 111e 	strh.w	r1, [r4, #286]	; 0x11e
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 8002942:	f884 111b 	strb.w	r1, [r4, #283]	; 0x11b
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 8002946:	f8c4 e120 	str.w	lr, [r4, #288]	; 0x120
    ep->xfer_buff = 0;
 800294a:	f8c4 1124 	str.w	r1, [r4, #292]	; 0x124
    ep->xfer_len = 0;
 800294e:	f8c4 112c 	str.w	r1, [r4, #300]	; 0x12c
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002952:	4638      	mov	r0, r7
 8002954:	f104 0328 	add.w	r3, r4, #40	; 0x28
 8002958:	d234      	bcs.n	80029c4 <DCD_Init+0xb8>
 800295a:	b192      	cbz	r2, 8002982 <DCD_Init+0x76>
 800295c:	2002      	movs	r0, #2
 800295e:	42b0      	cmp	r0, r6
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
 8002960:	f883 7119 	strb.w	r7, [r3, #281]	; 0x119
    ep->num = i;
 8002964:	f883 7118 	strb.w	r7, [r3, #280]	; 0x118
    ep->tx_fifo_num = i;
 8002968:	f8a3 711e 	strh.w	r7, [r3, #286]	; 0x11e
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 800296c:	f883 111b 	strb.w	r1, [r3, #283]	; 0x11b
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 8002970:	f8c3 e120 	str.w	lr, [r3, #288]	; 0x120
    ep->xfer_buff = 0;
 8002974:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
    ep->xfer_len = 0;
 8002978:	f8c3 112c 	str.w	r1, [r3, #300]	; 0x12c
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 800297c:	f104 0350 	add.w	r3, r4, #80	; 0x50
 8002980:	d220      	bcs.n	80029c4 <DCD_Init+0xb8>
 8002982:	1c45      	adds	r5, r0, #1
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
    ep->num = i;
 8002984:	f883 0118 	strb.w	r0, [r3, #280]	; 0x118
    ep->tx_fifo_num = i;
 8002988:	f8a3 011e 	strh.w	r0, [r3, #286]	; 0x11e
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 800298c:	3002      	adds	r0, #2
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
 800298e:	f883 7119 	strb.w	r7, [r3, #281]	; 0x119
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 8002992:	f883 111b 	strb.w	r1, [r3, #283]	; 0x11b
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 8002996:	f8c3 e120 	str.w	lr, [r3, #288]	; 0x120
    ep->xfer_buff = 0;
 800299a:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
    ep->xfer_len = 0;
 800299e:	f8c3 112c 	str.w	r1, [r3, #300]	; 0x12c
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
 80029a2:	f883 7141 	strb.w	r7, [r3, #321]	; 0x141
    ep->num = i;
 80029a6:	f883 5140 	strb.w	r5, [r3, #320]	; 0x140
    ep->tx_fifo_num = i;
 80029aa:	f8a3 5146 	strh.w	r5, [r3, #326]	; 0x146
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 80029ae:	f883 1143 	strb.w	r1, [r3, #323]	; 0x143
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 80029b2:	f8c3 e148 	str.w	lr, [r3, #328]	; 0x148
    ep->xfer_buff = 0;
 80029b6:	f8c3 114c 	str.w	r1, [r3, #332]	; 0x14c
    ep->xfer_len = 0;
 80029ba:	f8c3 1154 	str.w	r1, [r3, #340]	; 0x154
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80029be:	3350      	adds	r3, #80	; 0x50
 80029c0:	42b0      	cmp	r0, r6
 80029c2:	d3de      	bcc.n	8002982 <DCD_Init+0x76>
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 80029c4:	2001      	movs	r0, #1
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80029c6:	2200      	movs	r2, #0
    ep->is_in = 0;
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 80029c8:	2740      	movs	r7, #64	; 0x40
 80029ca:	1e71      	subs	r1, r6, #1
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 80029cc:	42b0      	cmp	r0, r6
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 80029ce:	f884 2371 	strb.w	r2, [r4, #881]	; 0x371
    ep->num = i;
 80029d2:	f884 2370 	strb.w	r2, [r4, #880]	; 0x370
    ep->tx_fifo_num = i;
 80029d6:	f8a4 2376 	strh.w	r2, [r4, #886]	; 0x376
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
 80029da:	f884 2373 	strb.w	r2, [r4, #883]	; 0x373
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 80029de:	f8c4 7378 	str.w	r7, [r4, #888]	; 0x378
    ep->xfer_buff = 0;
 80029e2:	f8c4 237c 	str.w	r2, [r4, #892]	; 0x37c
    ep->xfer_len = 0;
 80029e6:	f8c4 2384 	str.w	r2, [r4, #900]	; 0x384
 80029ea:	ea01 0100 	and.w	r1, r1, r0
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 80029ee:	f104 0328 	add.w	r3, r4, #40	; 0x28
 80029f2:	d234      	bcs.n	8002a5e <DCD_Init+0x152>
 80029f4:	b191      	cbz	r1, 8002a1c <DCD_Init+0x110>
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
    ep->num = i;
 80029f6:	f883 0370 	strb.w	r0, [r3, #880]	; 0x370
    ep->tx_fifo_num = i;
 80029fa:	f8a3 0376 	strh.w	r0, [r3, #886]	; 0x376
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 80029fe:	2002      	movs	r0, #2
 8002a00:	42b0      	cmp	r0, r6
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 8002a02:	f883 2371 	strb.w	r2, [r3, #881]	; 0x371
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
 8002a06:	f883 2373 	strb.w	r2, [r3, #883]	; 0x373
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 8002a0a:	f8c3 7378 	str.w	r7, [r3, #888]	; 0x378
    ep->xfer_buff = 0;
 8002a0e:	f8c3 237c 	str.w	r2, [r3, #892]	; 0x37c
    ep->xfer_len = 0;
 8002a12:	f8c3 2384 	str.w	r2, [r3, #900]	; 0x384
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8002a16:	f104 0350 	add.w	r3, r4, #80	; 0x50
 8002a1a:	d220      	bcs.n	8002a5e <DCD_Init+0x152>
 8002a1c:	1c45      	adds	r5, r0, #1
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
    ep->num = i;
 8002a1e:	f883 0370 	strb.w	r0, [r3, #880]	; 0x370
    ep->tx_fifo_num = i;
 8002a22:	f8a3 0376 	strh.w	r0, [r3, #886]	; 0x376
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8002a26:	3002      	adds	r0, #2
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 8002a28:	f883 2371 	strb.w	r2, [r3, #881]	; 0x371
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
 8002a2c:	f883 2373 	strb.w	r2, [r3, #883]	; 0x373
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 8002a30:	f8c3 7378 	str.w	r7, [r3, #888]	; 0x378
    ep->xfer_buff = 0;
 8002a34:	f8c3 237c 	str.w	r2, [r3, #892]	; 0x37c
    ep->xfer_len = 0;
 8002a38:	f8c3 2384 	str.w	r2, [r3, #900]	; 0x384
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 8002a3c:	f883 2399 	strb.w	r2, [r3, #921]	; 0x399
    ep->num = i;
 8002a40:	f883 5398 	strb.w	r5, [r3, #920]	; 0x398
    ep->tx_fifo_num = i;
 8002a44:	f8a3 539e 	strh.w	r5, [r3, #926]	; 0x39e
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
 8002a48:	f883 239b 	strb.w	r2, [r3, #923]	; 0x39b
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 8002a4c:	f8c3 73a0 	str.w	r7, [r3, #928]	; 0x3a0
    ep->xfer_buff = 0;
 8002a50:	f8c3 23a4 	str.w	r2, [r3, #932]	; 0x3a4
    ep->xfer_len = 0;
 8002a54:	f8c3 23ac 	str.w	r2, [r3, #940]	; 0x3ac
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8002a58:	3350      	adds	r3, #80	; 0x50
 8002a5a:	42b0      	cmp	r0, r6
 8002a5c:	d3de      	bcc.n	8002a1c <DCD_Init+0x110>
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  USB_OTG_DisableGlobalInt(pdev);
 8002a5e:	4620      	mov	r0, r4
 8002a60:	f7ff fb00 	bl	8002064 <USB_OTG_DisableGlobalInt>
  
  /*Init the Core (common init.) */
  USB_OTG_CoreInit(pdev);
 8002a64:	4620      	mov	r0, r4
 8002a66:	f7ff fa73 	bl	8001f50 <USB_OTG_CoreInit>


  /* Force Device Mode*/
  USB_OTG_SetCurrentMode(pdev, DEVICE_MODE);
 8002a6a:	2100      	movs	r1, #0
 8002a6c:	4620      	mov	r0, r4
 8002a6e:	f7ff fb51 	bl	8002114 <USB_OTG_SetCurrentMode>
  
  /* Init Device */
  USB_OTG_CoreInitDev(pdev);
 8002a72:	4620      	mov	r0, r4
 8002a74:	f7ff fbac 	bl	80021d0 <USB_OTG_CoreInitDev>
  
  
  /* Enable USB Global interrupt */
  USB_OTG_EnableGlobalInt(pdev);
 8002a78:	4620      	mov	r0, r4
}
 8002a7a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  /* Init Device */
  USB_OTG_CoreInitDev(pdev);
  
  
  /* Enable USB Global interrupt */
  USB_OTG_EnableGlobalInt(pdev);
 8002a7e:	f7ff bae9 	b.w	8002054 <USB_OTG_EnableGlobalInt>
 8002a82:	bf00      	nop

08002a84 <DCD_EP_Open>:
*/
uint32_t DCD_EP_Open(USB_OTG_CORE_HANDLE *pdev , 
                     uint8_t ep_addr,
                     uint16_t ep_mps,
                     uint8_t ep_type)
{
 8002a84:	b538      	push	{r3, r4, r5, lr}
  USB_OTG_EP *ep;
  
  if ((ep_addr & 0x80) == 0x80)
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002a86:	f001 057f 	and.w	r5, r1, #127	; 0x7f
                     uint16_t ep_mps,
                     uint8_t ep_type)
{
  USB_OTG_EP *ep;
  
  if ((ep_addr & 0x80) == 0x80)
 8002a8a:	b2cc      	uxtb	r4, r1
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002a8c:	eb05 0185 	add.w	r1, r5, r5, lsl #2
 8002a90:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
                     uint16_t ep_mps,
                     uint8_t ep_type)
{
  USB_OTG_EP *ep;
  
  if ((ep_addr & 0x80) == 0x80)
 8002a94:	f014 0f80 	tst.w	r4, #128	; 0x80
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002a98:	bf14      	ite	ne
 8002a9a:	f501 718c 	addne.w	r1, r1, #280	; 0x118
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8002a9e:	f501 715c 	addeq.w	r1, r1, #880	; 0x370
  }
  ep->num   = ep_addr & 0x7F;
 8002aa2:	b2ed      	uxtb	r5, r5
  
  ep->is_in = (0x80 & ep_addr) != 0;
 8002aa4:	09e4      	lsrs	r4, r4, #7
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
 8002aa6:	700d      	strb	r5, [r1, #0]
  
  ep->is_in = (0x80 & ep_addr) != 0;
 8002aa8:	704c      	strb	r4, [r1, #1]
  ep->maxpacket = ep_mps;
 8002aaa:	608a      	str	r2, [r1, #8]
  ep->type = ep_type;
 8002aac:	70cb      	strb	r3, [r1, #3]
  if (ep->is_in)
 8002aae:	b104      	cbz	r4, 8002ab2 <DCD_EP_Open+0x2e>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 8002ab0:	80cd      	strh	r5, [r1, #6]
  }
  /* Set initial data PID. */
  if (ep_type == USB_OTG_EP_BULK )
 8002ab2:	2b02      	cmp	r3, #2
 8002ab4:	d101      	bne.n	8002aba <DCD_EP_Open+0x36>
  {
    ep->data_pid_start = 0;
 8002ab6:	2300      	movs	r3, #0
 8002ab8:	710b      	strb	r3, [r1, #4]
  }
  USB_OTG_EPActivate(pdev , ep );
 8002aba:	f7ff fc3b 	bl	8002334 <USB_OTG_EPActivate>
  return 0;
}
 8002abe:	2000      	movs	r0, #0
 8002ac0:	bd38      	pop	{r3, r4, r5, pc}
 8002ac2:	bf00      	nop

08002ac4 <DCD_EP_Close>:
{
  USB_OTG_EP *ep;
  
  if ((ep_addr&0x80) == 0x80)
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002ac4:	f001 027f 	and.w	r2, r1, #127	; 0x7f
* @param pdev: device instance
* @param ep_addr: endpoint address
* @retval : status
*/
uint32_t DCD_EP_Close(USB_OTG_CORE_HANDLE *pdev , uint8_t  ep_addr)
{
 8002ac8:	b508      	push	{r3, lr}
  USB_OTG_EP *ep;
  
  if ((ep_addr&0x80) == 0x80)
 8002aca:	b2cb      	uxtb	r3, r1
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002acc:	eb02 0182 	add.w	r1, r2, r2, lsl #2
*/
uint32_t DCD_EP_Close(USB_OTG_CORE_HANDLE *pdev , uint8_t  ep_addr)
{
  USB_OTG_EP *ep;
  
  if ((ep_addr&0x80) == 0x80)
 8002ad0:	f013 0f80 	tst.w	r3, #128	; 0x80
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002ad4:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
 8002ad8:	bf14      	ite	ne
 8002ada:	f501 718c 	addne.w	r1, r1, #280	; 0x118
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8002ade:	f501 715c 	addeq.w	r1, r1, #880	; 0x370
  }
  ep->num   = ep_addr & 0x7F;
  ep->is_in = (0x80 & ep_addr) != 0;
 8002ae2:	09db      	lsrs	r3, r3, #7
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
 8002ae4:	700a      	strb	r2, [r1, #0]
  ep->is_in = (0x80 & ep_addr) != 0;
 8002ae6:	704b      	strb	r3, [r1, #1]
  USB_OTG_EPDeactivate(pdev , ep );
 8002ae8:	f7ff fc5a 	bl	80023a0 <USB_OTG_EPDeactivate>
  return 0;
}
 8002aec:	2000      	movs	r0, #0
 8002aee:	bd08      	pop	{r3, pc}

08002af0 <DCD_EP_PrepareRx>:
                            uint8_t *pbuf,                        
                            uint16_t  buf_len)
{
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8002af0:	f001 017f 	and.w	r1, r1, #127	; 0x7f
*/
uint32_t   DCD_EP_PrepareRx( USB_OTG_CORE_HANDLE *pdev,
                            uint8_t   ep_addr,
                            uint8_t *pbuf,                        
                            uint16_t  buf_len)
{
 8002af4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8002af6:	eb01 0581 	add.w	r5, r1, r1, lsl #2
 8002afa:	00ec      	lsls	r4, r5, #3
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
 8002afc:	1905      	adds	r5, r0, r4
  ep->xfer_len = buf_len;
  ep->xfer_count = 0;
 8002afe:	2700      	movs	r7, #0
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
 8002b00:	b2ce      	uxtb	r6, r1
 8002b02:	f885 6370 	strb.w	r6, [r5, #880]	; 0x370
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
  ep->xfer_len = buf_len;
  ep->xfer_count = 0;
  ep->is_in = 0;
 8002b06:	f885 7371 	strb.w	r7, [r5, #881]	; 0x371
  ep->num = ep_addr & 0x7F;
  
  if (pdev->cfg.dma_enable == 1)
 8002b0a:	f890 e003 	ldrb.w	lr, [r0, #3]
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
  ep->xfer_len = buf_len;
 8002b0e:	f8c5 3384 	str.w	r3, [r5, #900]	; 0x384
  ep->xfer_count = 0;
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
  
  if (pdev->cfg.dma_enable == 1)
 8002b12:	f1be 0f01 	cmp.w	lr, #1
                            uint8_t *pbuf,                        
                            uint16_t  buf_len)
{
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8002b16:	f504 745c 	add.w	r4, r4, #880	; 0x370
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
  
  if (pdev->cfg.dma_enable == 1)
  {
    ep->dma_addr = (uint32_t)pbuf;  
 8002b1a:	bf08      	it	eq
 8002b1c:	b2f6      	uxtbeq	r6, r6
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
 8002b1e:	f8c5 237c 	str.w	r2, [r5, #892]	; 0x37c
  ep->xfer_len = buf_len;
  ep->xfer_count = 0;
 8002b22:	f8c5 7388 	str.w	r7, [r5, #904]	; 0x388
                            uint8_t *pbuf,                        
                            uint16_t  buf_len)
{
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8002b26:	eb00 0104 	add.w	r1, r0, r4
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
  
  if (pdev->cfg.dma_enable == 1)
  {
    ep->dma_addr = (uint32_t)pbuf;  
 8002b2a:	bf08      	it	eq
 8002b2c:	f8c5 2380 	streq.w	r2, [r5, #896]	; 0x380
  }
  
  if ( ep->num == 0 )
 8002b30:	b11e      	cbz	r6, 8002b3a <DCD_EP_PrepareRx+0x4a>
  {
    USB_OTG_EP0StartXfer(pdev , ep);
  }
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
 8002b32:	f7ff fc59 	bl	80023e8 <USB_OTG_EPStartXfer>
  }
  return 0;
}
 8002b36:	2000      	movs	r0, #0
 8002b38:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ep->dma_addr = (uint32_t)pbuf;  
  }
  
  if ( ep->num == 0 )
  {
    USB_OTG_EP0StartXfer(pdev , ep);
 8002b3a:	f7ff fd21 	bl	8002580 <USB_OTG_EP0StartXfer>
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
  }
  return 0;
}
 8002b3e:	2000      	movs	r0, #0
 8002b40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002b42:	bf00      	nop

08002b44 <DCD_EP_Tx>:
*/
uint32_t  DCD_EP_Tx ( USB_OTG_CORE_HANDLE *pdev,
                     uint8_t   ep_addr,
                     uint8_t   *pbuf,
                     uint32_t   buf_len)
{
 8002b44:	b570      	push	{r4, r5, r6, lr}
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002b46:	f001 057f 	and.w	r5, r1, #127	; 0x7f
 8002b4a:	eb05 0485 	add.w	r4, r5, r5, lsl #2
 8002b4e:	00e1      	lsls	r1, r4, #3
  
  /* Setup and start the Transfer */
  ep->is_in = 1;
 8002b50:	1844      	adds	r4, r0, r1
                     uint8_t   *pbuf,
                     uint32_t   buf_len)
{
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002b52:	f501 768c 	add.w	r6, r1, #280	; 0x118
 8002b56:	1981      	adds	r1, r0, r6
  
  /* Setup and start the Transfer */
  ep->is_in = 1;
  ep->num = ep_addr & 0x7F;  
  ep->xfer_buff = pbuf;
 8002b58:	f8c4 2124 	str.w	r2, [r4, #292]	; 0x124
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
  
  /* Setup and start the Transfer */
  ep->is_in = 1;
 8002b5c:	2601      	movs	r6, #1
  ep->num = ep_addr & 0x7F;  
  ep->xfer_buff = pbuf;
  ep->dma_addr = (uint32_t)pbuf;  
 8002b5e:	f8c4 2128 	str.w	r2, [r4, #296]	; 0x128
  ep->xfer_count = 0;
 8002b62:	2200      	movs	r2, #0
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
  
  /* Setup and start the Transfer */
  ep->is_in = 1;
 8002b64:	f884 6119 	strb.w	r6, [r4, #281]	; 0x119
  ep->num = ep_addr & 0x7F;  
 8002b68:	f884 5118 	strb.w	r5, [r4, #280]	; 0x118
  ep->xfer_buff = pbuf;
  ep->dma_addr = (uint32_t)pbuf;  
  ep->xfer_count = 0;
 8002b6c:	f8c4 2130 	str.w	r2, [r4, #304]	; 0x130
  ep->xfer_len  = buf_len;
 8002b70:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
  
  if ( ep->num == 0 )
 8002b74:	b11d      	cbz	r5, 8002b7e <DCD_EP_Tx+0x3a>
  {
    USB_OTG_EP0StartXfer(pdev , ep);
  }
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
 8002b76:	f7ff fc37 	bl	80023e8 <USB_OTG_EPStartXfer>
  }
  return 0;
}
 8002b7a:	2000      	movs	r0, #0
 8002b7c:	bd70      	pop	{r4, r5, r6, pc}
  ep->xfer_count = 0;
  ep->xfer_len  = buf_len;
  
  if ( ep->num == 0 )
  {
    USB_OTG_EP0StartXfer(pdev , ep);
 8002b7e:	f7ff fcff 	bl	8002580 <USB_OTG_EP0StartXfer>
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
  }
  return 0;
}
 8002b82:	2000      	movs	r0, #0
 8002b84:	bd70      	pop	{r4, r5, r6, pc}
 8002b86:	bf00      	nop

08002b88 <DCD_EP_Stall>:
* @retval : status
*/
uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 8002b88:	b2ca      	uxtb	r2, r1
 8002b8a:	f012 0f80 	tst.w	r2, #128	; 0x80
* @param pdev: device instance
* @param epnum: endpoint address
* @retval : status
*/
uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
{
 8002b8e:	b510      	push	{r4, lr}
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 8002b90:	d111      	bne.n	8002bb6 <DCD_EP_Stall+0x2e>
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8002b92:	eb01 0e81 	add.w	lr, r1, r1, lsl #2
 8002b96:	eb00 0cce 	add.w	ip, r0, lr, lsl #3
 8002b9a:	f50c 735c 	add.w	r3, ip, #880	; 0x370
 8002b9e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
  }

  ep->is_stall = 1;
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 8002ba2:	09d2      	lsrs	r2, r2, #7
  else
  {
    ep = &pdev->dev.out_ep[epnum];
  }

  ep->is_stall = 1;
 8002ba4:	2401      	movs	r4, #1
  ep->num   = epnum & 0x7F;
 8002ba6:	7019      	strb	r1, [r3, #0]
  else
  {
    ep = &pdev->dev.out_ep[epnum];
  }

  ep->is_stall = 1;
 8002ba8:	709c      	strb	r4, [r3, #2]
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 8002baa:	705a      	strb	r2, [r3, #1]
  
  USB_OTG_EPSetStall(pdev , ep);
 8002bac:	4619      	mov	r1, r3
 8002bae:	f7ff fd71 	bl	8002694 <USB_OTG_EPSetStall>
  return (0);
}
 8002bb2:	2000      	movs	r0, #0
 8002bb4:	bd10      	pop	{r4, pc}
uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];
 8002bb6:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8002bba:	eb01 0481 	add.w	r4, r1, r1, lsl #2
 8002bbe:	eb00 03c4 	add.w	r3, r0, r4, lsl #3
 8002bc2:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8002bc6:	e7ec      	b.n	8002ba2 <DCD_EP_Stall+0x1a>

08002bc8 <DCD_EP_ClrStall>:
* @retval : status
*/
uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 8002bc8:	b2ca      	uxtb	r2, r1
 8002bca:	f012 0f80 	tst.w	r2, #128	; 0x80
* @param pdev: device instance
* @param epnum: endpoint address
* @retval : status
*/
uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
 8002bce:	b510      	push	{r4, lr}
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 8002bd0:	d111      	bne.n	8002bf6 <DCD_EP_ClrStall+0x2e>
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8002bd2:	eb01 0e81 	add.w	lr, r1, r1, lsl #2
 8002bd6:	eb00 0cce 	add.w	ip, r0, lr, lsl #3
 8002bda:	f50c 735c 	add.w	r3, ip, #880	; 0x370
 8002bde:	f001 017f 	and.w	r1, r1, #127	; 0x7f
  }
  
  ep->is_stall = 0;  
 8002be2:	2400      	movs	r4, #0
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 8002be4:	09d2      	lsrs	r2, r2, #7
  {
    ep = &pdev->dev.out_ep[epnum];
  }
  
  ep->is_stall = 0;  
  ep->num   = epnum & 0x7F;
 8002be6:	7019      	strb	r1, [r3, #0]
  else
  {
    ep = &pdev->dev.out_ep[epnum];
  }
  
  ep->is_stall = 0;  
 8002be8:	709c      	strb	r4, [r3, #2]
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 8002bea:	705a      	strb	r2, [r3, #1]
  
  USB_OTG_EPClearStall(pdev , ep);
 8002bec:	4619      	mov	r1, r3
 8002bee:	f7ff fd71 	bl	80026d4 <USB_OTG_EPClearStall>
  return (0);
}
 8002bf2:	4620      	mov	r0, r4
 8002bf4:	bd10      	pop	{r4, pc}
uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
 8002bf6:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8002bfa:	eb01 0481 	add.w	r4, r1, r1, lsl #2
 8002bfe:	eb00 03c4 	add.w	r3, r0, r4, lsl #3
 8002c02:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8002c06:	e7ec      	b.n	8002be2 <DCD_EP_ClrStall+0x1a>

08002c08 <DCD_EP_Flush>:
* @retval : status
*/
uint32_t  DCD_EP_Flush (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{

  if ((epnum & 0x80) == 0x80)
 8002c08:	f011 0f80 	tst.w	r1, #128	; 0x80
* @param pdev: device instance
* @param epnum: endpoint address
* @retval : status
*/
uint32_t  DCD_EP_Flush (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
 8002c0c:	b508      	push	{r3, lr}

  if ((epnum & 0x80) == 0x80)
 8002c0e:	d103      	bne.n	8002c18 <DCD_EP_Flush+0x10>
  {
    USB_OTG_FlushTxFifo(pdev, epnum & 0x7F);
  }
  else
  {
    USB_OTG_FlushRxFifo(pdev);
 8002c10:	f7ff fa5a 	bl	80020c8 <USB_OTG_FlushRxFifo>
  }

  return (0);
}
 8002c14:	2000      	movs	r0, #0
 8002c16:	bd08      	pop	{r3, pc}
uint32_t  DCD_EP_Flush (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{

  if ((epnum & 0x80) == 0x80)
  {
    USB_OTG_FlushTxFifo(pdev, epnum & 0x7F);
 8002c18:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8002c1c:	f7ff fa2a 	bl	8002074 <USB_OTG_FlushTxFifo>
  {
    USB_OTG_FlushRxFifo(pdev);
  }

  return (0);
}
 8002c20:	2000      	movs	r0, #0
 8002c22:	bd08      	pop	{r3, pc}

08002c24 <DCD_EP_SetAddress>:
void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
{
  USB_OTG_DCFG_TypeDef  dcfg;
  dcfg.d32 = 0;
  dcfg.b.devaddr = address;
  USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
 8002c24:	6903      	ldr	r3, [r0, #16]
* @retval : status
*/
void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
{
  USB_OTG_DCFG_TypeDef  dcfg;
  dcfg.d32 = 0;
 8002c26:	2200      	movs	r2, #0
  dcfg.b.devaddr = address;
  USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
 8002c28:	6818      	ldr	r0, [r3, #0]
*/
void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
{
  USB_OTG_DCFG_TypeDef  dcfg;
  dcfg.d32 = 0;
  dcfg.b.devaddr = address;
 8002c2a:	f361 120a 	bfi	r2, r1, #4, #7
  USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
 8002c2e:	4302      	orrs	r2, r0
 8002c30:	601a      	str	r2, [r3, #0]
}
 8002c32:	4770      	bx	lr

08002c34 <DCD_DevConnect>:
*/
void  DCD_DevConnect (USB_OTG_CORE_HANDLE *pdev)
{
#ifndef USE_OTG_MODE
  USB_OTG_DCTL_TypeDef  dctl;
  dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 8002c34:	6903      	ldr	r3, [r0, #16]
 8002c36:	685a      	ldr	r2, [r3, #4]
  /* Connect device */
  dctl.b.sftdiscon  = 0;
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
  USB_OTG_BSP_mDelay(3);
 8002c38:	2003      	movs	r0, #3
{
#ifndef USE_OTG_MODE
  USB_OTG_DCTL_TypeDef  dctl;
  dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
  /* Connect device */
  dctl.b.sftdiscon  = 0;
 8002c3a:	f36f 0241 	bfc	r2, #1, #1
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
 8002c3e:	605a      	str	r2, [r3, #4]
  USB_OTG_BSP_mDelay(3);
 8002c40:	f000 bf47 	b.w	8003ad2 <USB_OTG_BSP_mDelay>

08002c44 <DCD_DevDisconnect>:
*/
void  DCD_DevDisconnect (USB_OTG_CORE_HANDLE *pdev)
{
#ifndef USE_OTG_MODE
  USB_OTG_DCTL_TypeDef  dctl;
  dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 8002c44:	6903      	ldr	r3, [r0, #16]
 8002c46:	6858      	ldr	r0, [r3, #4]
  /* Disconnect device for 3ms */
  dctl.b.sftdiscon  = 1;
 8002c48:	f040 0202 	orr.w	r2, r0, #2
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
  USB_OTG_BSP_mDelay(3);
 8002c4c:	2003      	movs	r0, #3
#ifndef USE_OTG_MODE
  USB_OTG_DCTL_TypeDef  dctl;
  dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
  /* Disconnect device for 3ms */
  dctl.b.sftdiscon  = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
 8002c4e:	605a      	str	r2, [r3, #4]
  USB_OTG_BSP_mDelay(3);
 8002c50:	f000 bf3f 	b.w	8003ad2 <USB_OTG_BSP_mDelay>

08002c54 <DCD_GetEPStatus>:
uint32_t DCD_GetEPStatus(USB_OTG_CORE_HANDLE *pdev ,uint8_t epnum)
{
  USB_OTG_EP *ep;
  uint32_t Status = 0;  
  
  if ((0x80 & epnum) == 0x80)
 8002c54:	f011 0f80 	tst.w	r1, #128	; 0x80
 8002c58:	d107      	bne.n	8002c6a <DCD_GetEPStatus+0x16>
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8002c5a:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8002c5e:	eb00 0cc1 	add.w	ip, r0, r1, lsl #3
 8002c62:	f50c 715c 	add.w	r1, ip, #880	; 0x370
  }
  
  Status = USB_OTG_GetEPStatus(pdev ,ep);
 8002c66:	f7ff bddf 	b.w	8002828 <USB_OTG_GetEPStatus>
  USB_OTG_EP *ep;
  uint32_t Status = 0;  
  
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
 8002c6a:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 8002c6e:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 8002c72:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
 8002c76:	f501 718c 	add.w	r1, r1, #280	; 0x118
 8002c7a:	e7f4      	b.n	8002c66 <DCD_GetEPStatus+0x12>

08002c7c <DCD_SetEPStatus>:
*/
void DCD_SetEPStatus (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum , uint32_t Status)
{
  USB_OTG_EP *ep;
  
  if ((0x80 & epnum) == 0x80)
 8002c7c:	f011 0f80 	tst.w	r1, #128	; 0x80
 8002c80:	d107      	bne.n	8002c92 <DCD_SetEPStatus+0x16>
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8002c82:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 8002c86:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
 8002c8a:	f501 715c 	add.w	r1, r1, #880	; 0x370
  }
  
   USB_OTG_SetEPStatus(pdev ,ep , Status);
 8002c8e:	f7ff bdff 	b.w	8002890 <USB_OTG_SetEPStatus>
{
  USB_OTG_EP *ep;
  
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
 8002c92:	f001 0c7f 	and.w	ip, r1, #127	; 0x7f
 8002c96:	eb0c 038c 	add.w	r3, ip, ip, lsl #2
 8002c9a:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
 8002c9e:	f501 718c 	add.w	r1, r1, #280	; 0x118
 8002ca2:	e7f4      	b.n	8002c8e <DCD_SetEPStatus+0x12>

08002ca4 <USBD_OTG_ISR_Handler>:
*         handles all USB Interrupts
* @param  pdev: device instance
* @retval status
*/
uint32_t USBD_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
{
 8002ca4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002ca8:	b083      	sub	sp, #12
 8002caa:	4606      	mov	r6, r0
  USB_OTG_GINTSTS_TypeDef  gintr_status;
  uint32_t retval = 0;
  
  if (USB_OTG_IsDeviceMode(pdev)) /* ensure that we are in device mode */
 8002cac:	f7ff fa52 	bl	8002154 <USB_OTG_IsDeviceMode>
 8002cb0:	b910      	cbnz	r0, 8002cb8 <USBD_OTG_ISR_Handler+0x14>
      retval |= DCD_OTG_ISR(pdev);
    }   
#endif    
  }
  return retval;
}
 8002cb2:	b003      	add	sp, #12
 8002cb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  USB_OTG_GINTSTS_TypeDef  gintr_status;
  uint32_t retval = 0;
  
  if (USB_OTG_IsDeviceMode(pdev)) /* ensure that we are in device mode */
  {
    gintr_status.d32 = USB_OTG_ReadCoreItr(pdev);
 8002cb8:	4630      	mov	r0, r6
 8002cba:	f7ff fa59 	bl	8002170 <USB_OTG_ReadCoreItr>
    if (!gintr_status.d32) /* avoid spurious interrupt */
 8002cbe:	4681      	mov	r9, r0
 8002cc0:	2800      	cmp	r0, #0
 8002cc2:	d0f6      	beq.n	8002cb2 <USBD_OTG_ISR_Handler+0xe>
    {
      return 0;
    }
    
    if (gintr_status.b.outepintr)
 8002cc4:	f3c0 4107 	ubfx	r1, r0, #16, #8
 8002cc8:	f001 0008 	and.w	r0, r1, #8
 8002ccc:	b2c0      	uxtb	r0, r0
 8002cce:	2800      	cmp	r0, #0
 8002cd0:	f040 8118 	bne.w	8002f04 <USBD_OTG_ISR_Handler+0x260>
    {
      retval |= DCD_HandleOutEP_ISR(pdev);
    }    
    
    if (gintr_status.b.inepint)
 8002cd4:	f3c9 4e07 	ubfx	lr, r9, #16, #8
 8002cd8:	f00e 0c04 	and.w	ip, lr, #4
 8002cdc:	fa5f f38c 	uxtb.w	r3, ip
 8002ce0:	2b00      	cmp	r3, #0
 8002ce2:	d166      	bne.n	8002db2 <USBD_OTG_ISR_Handler+0x10e>
    {
      retval |= DCD_HandleInEP_ISR(pdev);
    }
    
    if (gintr_status.b.modemismatch)
 8002ce4:	f009 0c02 	and.w	ip, r9, #2
 8002ce8:	fa5f f38c 	uxtb.w	r3, ip
 8002cec:	b113      	cbz	r3, 8002cf4 <USBD_OTG_ISR_Handler+0x50>
      USB_OTG_GINTSTS_TypeDef  gintsts;
      
      /* Clear interrupt */
      gintsts.d32 = 0;
      gintsts.b.modemismatch = 1;
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002cee:	68f2      	ldr	r2, [r6, #12]
    {
      USB_OTG_GINTSTS_TypeDef  gintsts;
      
      /* Clear interrupt */
      gintsts.d32 = 0;
      gintsts.b.modemismatch = 1;
 8002cf0:	2102      	movs	r1, #2
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002cf2:	6151      	str	r1, [r2, #20]
    }
    
    if (gintr_status.b.wkupintr)
 8002cf4:	f3c9 6107 	ubfx	r1, r9, #24, #8
 8002cf8:	f001 0c80 	and.w	ip, r1, #128	; 0x80
 8002cfc:	fa5f f38c 	uxtb.w	r3, ip
 8002d00:	b193      	cbz	r3, 8002d28 <USBD_OTG_ISR_Handler+0x84>
{
  USB_OTG_GINTSTS_TypeDef  gintsts;
  USB_OTG_DCTL_TypeDef     devctl;
  USB_OTG_PCGCCTL_TypeDef  power;
  
  if(pdev->cfg.low_power)
 8002d02:	7ab0      	ldrb	r0, [r6, #10]
 8002d04:	2800      	cmp	r0, #0
 8002d06:	f040 8204 	bne.w	8003112 <USBD_OTG_ISR_Handler+0x46e>
  }
  
  /* Clear the Remote Wake-up Signaling */
  devctl.d32 = 0;
  devctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, devctl.d32, 0);
 8002d0a:	6933      	ldr	r3, [r6, #16]
  
  /* Inform upper layer by the Resume Event */
  USBD_DCD_INT_fops->Resume (pdev);
 8002d0c:	4aa8      	ldr	r2, [pc, #672]	; (8002fb0 <USBD_OTG_ISR_Handler+0x30c>)
  }
  
  /* Clear the Remote Wake-up Signaling */
  devctl.d32 = 0;
  devctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, devctl.d32, 0);
 8002d0e:	6859      	ldr	r1, [r3, #4]
  
  /* Inform upper layer by the Resume Event */
  USBD_DCD_INT_fops->Resume (pdev);
 8002d10:	6810      	ldr	r0, [r2, #0]
  }
  
  /* Clear the Remote Wake-up Signaling */
  devctl.d32 = 0;
  devctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, devctl.d32, 0);
 8002d12:	f021 0101 	bic.w	r1, r1, #1
 8002d16:	6059      	str	r1, [r3, #4]
  
  /* Inform upper layer by the Resume Event */
  USBD_DCD_INT_fops->Resume (pdev);
 8002d18:	6982      	ldr	r2, [r0, #24]
 8002d1a:	4630      	mov	r0, r6
 8002d1c:	4790      	blx	r2
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.wkupintr = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002d1e:	68f0      	ldr	r0, [r6, #12]
  /* Inform upper layer by the Resume Event */
  USBD_DCD_INT_fops->Resume (pdev);
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.wkupintr = 1;
 8002d20:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002d24:	6141      	str	r1, [r0, #20]
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
    }
    
    if (gintr_status.b.wkupintr)
    {
      retval |= DCD_HandleResume_ISR(pdev);
 8002d26:	2001      	movs	r0, #1
    }
    
    if (gintr_status.b.usbsuspend)
 8002d28:	f3c9 2107 	ubfx	r1, r9, #8, #8
 8002d2c:	f001 0c08 	and.w	ip, r1, #8
 8002d30:	fa5f f38c 	uxtb.w	r3, ip
 8002d34:	2b00      	cmp	r3, #0
 8002d36:	f040 81cb 	bne.w	80030d0 <USBD_OTG_ISR_Handler+0x42c>
    {
      retval |= DCD_HandleUSBSuspend_ISR(pdev);
    }
    if (gintr_status.b.sofintr)
 8002d3a:	f009 0c08 	and.w	ip, r9, #8
 8002d3e:	fa5f f28c 	uxtb.w	r2, ip
 8002d42:	2a00      	cmp	r2, #0
 8002d44:	f040 81ba 	bne.w	80030bc <USBD_OTG_ISR_Handler+0x418>
    {
      retval |= DCD_HandleSof_ISR(pdev);
      
    }
    
    if (gintr_status.b.rxstsqlvl)
 8002d48:	f009 0c10 	and.w	ip, r9, #16
 8002d4c:	fa5f f38c 	uxtb.w	r3, ip
 8002d50:	2b00      	cmp	r3, #0
 8002d52:	f040 818d 	bne.w	8003070 <USBD_OTG_ISR_Handler+0x3cc>
    {
      retval |= DCD_HandleRxStatusQueueLevel_ISR(pdev);
      
    }
    
    if (gintr_status.b.usbreset)
 8002d56:	f3c9 2107 	ubfx	r1, r9, #8, #8
 8002d5a:	f001 0c10 	and.w	ip, r1, #16
 8002d5e:	fa5f f38c 	uxtb.w	r3, ip
 8002d62:	2b00      	cmp	r3, #0
 8002d64:	f040 814a 	bne.w	8002ffc <USBD_OTG_ISR_Handler+0x358>
    {
      retval |= DCD_HandleUsbReset_ISR(pdev);
      
    }
    if (gintr_status.b.enumdone)
 8002d68:	f3c9 2107 	ubfx	r1, r9, #8, #8
 8002d6c:	f001 0c20 	and.w	ip, r1, #32
 8002d70:	fa5f f38c 	uxtb.w	r3, ip
 8002d74:	2b00      	cmp	r3, #0
 8002d76:	f040 8128 	bne.w	8002fca <USBD_OTG_ISR_Handler+0x326>
    {
      retval |= DCD_HandleEnumDone_ISR(pdev);
    }
    
    if (gintr_status.b.incomplisoin)
 8002d7a:	f3c9 4207 	ubfx	r2, r9, #16, #8
 8002d7e:	f002 0c10 	and.w	ip, r2, #16
 8002d82:	fa5f f18c 	uxtb.w	r1, ip
 8002d86:	2900      	cmp	r1, #0
 8002d88:	f040 8114 	bne.w	8002fb4 <USBD_OTG_ISR_Handler+0x310>
    {
      retval |= DCD_IsoINIncomplete_ISR(pdev);
    }

    if (gintr_status.b.incomplisoout)
 8002d8c:	f3c9 4107 	ubfx	r1, r9, #16, #8
 8002d90:	f001 0c20 	and.w	ip, r1, #32
 8002d94:	fa5f f38c 	uxtb.w	r3, ip
 8002d98:	2b00      	cmp	r3, #0
 8002d9a:	d08a      	beq.n	8002cb2 <USBD_OTG_ISR_Handler+0xe>
{
  USB_OTG_GINTSTS_TypeDef gintsts;  
  
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoOUTIncomplete (pdev); 
 8002d9c:	4a84      	ldr	r2, [pc, #528]	; (8002fb0 <USBD_OTG_ISR_Handler+0x30c>)
 8002d9e:	6811      	ldr	r1, [r2, #0]
 8002da0:	4630      	mov	r0, r6
 8002da2:	6a0b      	ldr	r3, [r1, #32]
 8002da4:	4798      	blx	r3
  
  /* Clear interrupt */
  gintsts.b.incomplisoout = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002da6:	68f0      	ldr	r0, [r6, #12]
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoOUTIncomplete (pdev); 
  
  /* Clear interrupt */
  gintsts.b.incomplisoout = 1;
 8002da8:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002dac:	6142      	str	r2, [r0, #20]
      retval |= DCD_IsoINIncomplete_ISR(pdev);
    }

    if (gintr_status.b.incomplisoout)
    {
      retval |= DCD_IsoOUTIncomplete_ISR(pdev);
 8002dae:	2001      	movs	r0, #1
 8002db0:	e77f      	b.n	8002cb2 <USBD_OTG_ISR_Handler+0xe>
  
  uint32_t ep_intr;
  uint32_t epnum = 0;
  uint32_t fifoemptymsk;
  diepint.d32 = 0;
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
 8002db2:	4630      	mov	r0, r6
 8002db4:	f7ff fcba 	bl	800272c <USB_OTG_ReadDevAllInEPItr>
  
  while ( ep_intr )
 8002db8:	4682      	mov	sl, r0
 8002dba:	2800      	cmp	r0, #0
 8002dbc:	f000 80a0 	beq.w	8002f00 <USBD_OTG_ISR_Handler+0x25c>
 8002dc0:	4637      	mov	r7, r6
 8002dc2:	4634      	mov	r4, r6
static uint32_t DCD_HandleInEP_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_DIEPINTn_TypeDef  diepint;
  
  uint32_t ep_intr;
  uint32_t epnum = 0;
 8002dc4:	f04f 0b00 	mov.w	fp, #0
      {
        CLEAR_IN_EP_INTR(epnum, inepnakeff);
      }
      if ( diepint.b.epdisabled )
      {
        CLEAR_IN_EP_INTR(epnum, epdisabled);
 8002dc8:	f8cd 9004 	str.w	r9, [sp, #4]
 8002dcc:	46b0      	mov	r8, r6
  diepint.d32 = 0;
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
  
  while ( ep_intr )
  {
    if (ep_intr&0x1) /* In ITR */
 8002dce:	f01a 0f01 	tst.w	sl, #1
 8002dd2:	f000 808a 	beq.w	8002eea <USBD_OTG_ISR_Handler+0x246>
* @retval status
*/
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
 8002dd6:	f8d8 3010 	ldr.w	r3, [r8, #16]
  diepint.d32 = 0;
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
  
  while ( ep_intr )
  {
    if (ep_intr&0x1) /* In ITR */
 8002dda:	fa5f f68b 	uxtb.w	r6, fp
* @retval status
*/
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
 8002dde:	6919      	ldr	r1, [r3, #16]
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
 8002de0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  msk |= ((emp >> epnum) & 0x1) << 7;
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 8002de2:	eb08 0c86 	add.w	ip, r8, r6, lsl #2
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
  msk |= ((emp >> epnum) & 0x1) << 7;
 8002de6:	fa32 f506 	lsrs.w	r5, r2, r6
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 8002dea:	f8dc 0018 	ldr.w	r0, [ip, #24]
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
  msk |= ((emp >> epnum) & 0x1) << 7;
 8002dee:	01ed      	lsls	r5, r5, #7
 8002df0:	f005 02ff 	and.w	r2, r5, #255	; 0xff
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 8002df4:	6880      	ldr	r0, [r0, #8]
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
  msk |= ((emp >> epnum) & 0x1) << 7;
 8002df6:	ea42 0901 	orr.w	r9, r2, r1
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 8002dfa:	ea09 0500 	and.w	r5, r9, r0
  while ( ep_intr )
  {
    if (ep_intr&0x1) /* In ITR */
    {
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
 8002dfe:	b2ed      	uxtb	r5, r5
 8002e00:	f015 0f01 	tst.w	r5, #1
 8002e04:	f040 81b7 	bne.w	8003176 <USBD_OTG_ISR_Handler+0x4d2>
            /* prepare to rx more setup packets */
            USB_OTG_EP0_OutStart(pdev);
          }
        }           
      }
      if ( diepint.b.ahberr )
 8002e08:	f005 0904 	and.w	r9, r5, #4
 8002e0c:	fa5f f389 	uxtb.w	r3, r9
 8002e10:	b113      	cbz	r3, 8002e18 <USBD_OTG_ISR_Handler+0x174>
      {
        CLEAR_IN_EP_INTR(epnum, ahberr);
 8002e12:	69ba      	ldr	r2, [r7, #24]
 8002e14:	2504      	movs	r5, #4
 8002e16:	6095      	str	r5, [r2, #8]
      }
      if ( diepint.b.timeout )
 8002e18:	f005 0008 	and.w	r0, r5, #8
 8002e1c:	b2c1      	uxtb	r1, r0
 8002e1e:	b111      	cbz	r1, 8002e26 <USBD_OTG_ISR_Handler+0x182>
      {
        CLEAR_IN_EP_INTR(epnum, timeout);
 8002e20:	69bb      	ldr	r3, [r7, #24]
 8002e22:	2508      	movs	r5, #8
 8002e24:	609d      	str	r5, [r3, #8]
      }
      if (diepint.b.intktxfemp)
 8002e26:	f005 0c10 	and.w	ip, r5, #16
 8002e2a:	fa5f f28c 	uxtb.w	r2, ip
 8002e2e:	b112      	cbz	r2, 8002e36 <USBD_OTG_ISR_Handler+0x192>
      {
        CLEAR_IN_EP_INTR(epnum, intktxfemp);
 8002e30:	69b9      	ldr	r1, [r7, #24]
 8002e32:	2510      	movs	r5, #16
 8002e34:	608d      	str	r5, [r1, #8]
      }
      if (diepint.b.intknepmis)
 8002e36:	f005 0920 	and.w	r9, r5, #32
 8002e3a:	fa5f f089 	uxtb.w	r0, r9
 8002e3e:	b110      	cbz	r0, 8002e46 <USBD_OTG_ISR_Handler+0x1a2>
      {
        CLEAR_IN_EP_INTR(epnum, intknepmis);
 8002e40:	69bb      	ldr	r3, [r7, #24]
 8002e42:	2520      	movs	r5, #32
 8002e44:	609d      	str	r5, [r3, #8]
      }
      if (diepint.b.inepnakeff)
 8002e46:	f005 0c40 	and.w	ip, r5, #64	; 0x40
 8002e4a:	fa5f f28c 	uxtb.w	r2, ip
 8002e4e:	b112      	cbz	r2, 8002e56 <USBD_OTG_ISR_Handler+0x1b2>
      {
        CLEAR_IN_EP_INTR(epnum, inepnakeff);
 8002e50:	69b9      	ldr	r1, [r7, #24]
 8002e52:	2540      	movs	r5, #64	; 0x40
 8002e54:	608d      	str	r5, [r1, #8]
      }
      if ( diepint.b.epdisabled )
 8002e56:	f005 0902 	and.w	r9, r5, #2
 8002e5a:	fa5f f089 	uxtb.w	r0, r9
 8002e5e:	b110      	cbz	r0, 8002e66 <USBD_OTG_ISR_Handler+0x1c2>
      {
        CLEAR_IN_EP_INTR(epnum, epdisabled);
 8002e60:	69bb      	ldr	r3, [r7, #24]
 8002e62:	2502      	movs	r5, #2
 8002e64:	609d      	str	r5, [r3, #8]
      }       
      if (diepint.b.emptyintr)
 8002e66:	f005 0580 	and.w	r5, r5, #128	; 0x80
 8002e6a:	b2ed      	uxtb	r5, r5
 8002e6c:	2d00      	cmp	r5, #0
 8002e6e:	d03c      	beq.n	8002eea <USBD_OTG_ISR_Handler+0x246>
  uint32_t len32b;
  txstatus.d32 = 0;
  
  ep = &pdev->dev.in_ep[epnum];    
  
  len = ep->xfer_len - ep->xfer_count;
 8002e70:	f8d4 112c 	ldr.w	r1, [r4, #300]	; 0x12c
 8002e74:	f8d4 0130 	ldr.w	r0, [r4, #304]	; 0x130
  {
    len = ep->maxpacket;
  }
  
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 8002e78:	69bb      	ldr	r3, [r7, #24]
  if (len > ep->maxpacket)
  {
    len = ep->maxpacket;
  }
  
  len32b = (len + 3) / 4;
 8002e7a:	f8d4 2120 	ldr.w	r2, [r4, #288]	; 0x120
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 8002e7e:	f8d3 9018 	ldr.w	r9, [r3, #24]
  uint32_t len32b;
  txstatus.d32 = 0;
  
  ep = &pdev->dev.in_ep[epnum];    
  
  len = ep->xfer_len - ep->xfer_count;
 8002e82:	1a0d      	subs	r5, r1, r0
  if (len > ep->maxpacket)
  {
    len = ep->maxpacket;
  }
  
  len32b = (len + 3) / 4;
 8002e84:	4295      	cmp	r5, r2
 8002e86:	bf34      	ite	cc
 8002e88:	46ac      	movcc	ip, r5
 8002e8a:	4694      	movcs	ip, r2
 8002e8c:	f10c 0c03 	add.w	ip, ip, #3
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002e90:	fa1f f989 	uxth.w	r9, r9
 8002e94:	ebb9 0f9c 	cmp.w	r9, ip, lsr #2
 8002e98:	d925      	bls.n	8002ee6 <USBD_OTG_ISR_Handler+0x242>
 8002e9a:	4281      	cmp	r1, r0
 8002e9c:	d923      	bls.n	8002ee6 <USBD_OTG_ISR_Handler+0x242>
          ep->xfer_count < ep->xfer_len &&
 8002e9e:	b311      	cbz	r1, 8002ee6 <USBD_OTG_ISR_Handler+0x242>
 8002ea0:	f8d4 1124 	ldr.w	r1, [r4, #292]	; 0x124
 8002ea4:	e006      	b.n	8002eb4 <USBD_OTG_ISR_Handler+0x210>
 8002ea6:	f8d4 512c 	ldr.w	r5, [r4, #300]	; 0x12c
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002eaa:	42aa      	cmp	r2, r5
 8002eac:	d21b      	bcs.n	8002ee6 <USBD_OTG_ISR_Handler+0x242>
 8002eae:	1aad      	subs	r5, r5, r2
 8002eb0:	f8d4 2120 	ldr.w	r2, [r4, #288]	; 0x120
          ep->xfer_count < ep->xfer_len &&
            ep->xfer_len != 0)
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 8002eb4:	4295      	cmp	r5, r2
 8002eb6:	bf28      	it	cs
 8002eb8:	4615      	movcs	r5, r2
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3) / 4;
    
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
 8002eba:	b2ab      	uxth	r3, r5
 8002ebc:	4632      	mov	r2, r6
 8002ebe:	4640      	mov	r0, r8
 8002ec0:	f7fe ff16 	bl	8001cf0 <USB_OTG_WritePacket>
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
 8002ec4:	f8d4 2130 	ldr.w	r2, [r4, #304]	; 0x130
    
    txstatus.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 8002ec8:	69bb      	ldr	r3, [r7, #24]
    }
    len32b = (len + 3) / 4;
    
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
    
    ep->xfer_buff  += len;
 8002eca:	f8d4 1124 	ldr.w	r1, [r4, #292]	; 0x124
    ep->xfer_count += len;
 8002ece:	18aa      	adds	r2, r5, r2
 8002ed0:	f8c4 2130 	str.w	r2, [r4, #304]	; 0x130
    
    txstatus.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 8002ed4:	6998      	ldr	r0, [r3, #24]
    }
    len32b = (len + 3) / 4;
    
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
    
    ep->xfer_buff  += len;
 8002ed6:	1949      	adds	r1, r1, r5
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002ed8:	b280      	uxth	r0, r0
    
    if (len > ep->maxpacket)
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3) / 4;
 8002eda:	3503      	adds	r5, #3
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002edc:	ebb0 0f95 	cmp.w	r0, r5, lsr #2
    }
    len32b = (len + 3) / 4;
    
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
    
    ep->xfer_buff  += len;
 8002ee0:	f8c4 1124 	str.w	r1, [r4, #292]	; 0x124
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002ee4:	d8df      	bhi.n	8002ea6 <USBD_OTG_ISR_Handler+0x202>
      if (diepint.b.emptyintr)
      {
        
        DCD_WriteEmptyTxFifo(pdev , epnum);
        
        CLEAR_IN_EP_INTR(epnum, emptyintr);
 8002ee6:	2680      	movs	r6, #128	; 0x80
 8002ee8:	609e      	str	r6, [r3, #8]
      }
    }
    epnum++;
    ep_intr >>= 1;
 8002eea:	3428      	adds	r4, #40	; 0x28
 8002eec:	3704      	adds	r7, #4
  uint32_t epnum = 0;
  uint32_t fifoemptymsk;
  diepint.d32 = 0;
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
  
  while ( ep_intr )
 8002eee:	ea5f 0a5a 	movs.w	sl, sl, lsr #1
 8002ef2:	d002      	beq.n	8002efa <USBD_OTG_ISR_Handler+0x256>
        DCD_WriteEmptyTxFifo(pdev , epnum);
        
        CLEAR_IN_EP_INTR(epnum, emptyintr);
      }
    }
    epnum++;
 8002ef4:	f10b 0b01 	add.w	fp, fp, #1
 8002ef8:	e769      	b.n	8002dce <USBD_OTG_ISR_Handler+0x12a>
 8002efa:	f8dd 9004 	ldr.w	r9, [sp, #4]
 8002efe:	4646      	mov	r6, r8
      retval |= DCD_HandleOutEP_ISR(pdev);
    }    
    
    if (gintr_status.b.inepint)
    {
      retval |= DCD_HandleInEP_ISR(pdev);
 8002f00:	2001      	movs	r0, #1
 8002f02:	e6ef      	b.n	8002ce4 <USBD_OTG_ISR_Handler+0x40>
  uint32_t epnum = 0;
  
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
 8002f04:	4630      	mov	r0, r6
 8002f06:	f7ff fbff 	bl	8002708 <USB_OTG_ReadDevAllOutEp_itr>
  
  while ( ep_intr )
 8002f0a:	4604      	mov	r4, r0
 8002f0c:	2800      	cmp	r0, #0
 8002f0e:	d04d      	beq.n	8002fac <USBD_OTG_ISR_Handler+0x308>
      if ( doepint.b.setup )
      {
        
        /* inform the upper layer that a setup packet is available */
        /* SETUP COMPLETE */
        USBD_DCD_INT_fops->SetupStage(pdev);
 8002f10:	f8df b09c 	ldr.w	fp, [pc, #156]	; 8002fb0 <USBD_OTG_ISR_Handler+0x30c>
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
  
  while ( ep_intr )
 8002f14:	4635      	mov	r5, r6
 8002f16:	46b0      	mov	r8, r6
static uint32_t DCD_HandleOutEP_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t ep_intr;
  USB_OTG_DOEPINTn_TypeDef  doepint;
  USB_OTG_DEPXFRSIZ_TypeDef  deptsiz;
  uint32_t epnum = 0;
 8002f18:	2700      	movs	r7, #0
        CLEAR_OUT_EP_INTR(epnum, epdisabled);
      }
      /* AHB Error */
      if ( doepint.b.ahberr )
      {
        CLEAR_OUT_EP_INTR(epnum, ahberr);
 8002f1a:	46ca      	mov	sl, r9
 8002f1c:	e005      	b.n	8002f2a <USBD_OTG_ISR_Handler+0x286>
        USBD_DCD_INT_fops->SetupStage(pdev);
        CLEAR_OUT_EP_INTR(epnum, setup);
      }
    }
    epnum++;
    ep_intr >>= 1;
 8002f1e:	3504      	adds	r5, #4
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
  
  while ( ep_intr )
 8002f20:	0864      	lsrs	r4, r4, #1
        USBD_DCD_INT_fops->SetupStage(pdev);
        CLEAR_OUT_EP_INTR(epnum, setup);
      }
    }
    epnum++;
    ep_intr >>= 1;
 8002f22:	f108 0828 	add.w	r8, r8, #40	; 0x28
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
  
  while ( ep_intr )
 8002f26:	d040      	beq.n	8002faa <USBD_OTG_ISR_Handler+0x306>
        /* SETUP COMPLETE */
        USBD_DCD_INT_fops->SetupStage(pdev);
        CLEAR_OUT_EP_INTR(epnum, setup);
      }
    }
    epnum++;
 8002f28:	3701      	adds	r7, #1
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
  
  while ( ep_intr )
  {
    if (ep_intr&0x1)
 8002f2a:	f014 0f01 	tst.w	r4, #1
 8002f2e:	d0f6      	beq.n	8002f1e <USBD_OTG_ISR_Handler+0x27a>
 8002f30:	fa5f f987 	uxtb.w	r9, r7
    {
      
      doepint.d32 = USB_OTG_ReadDevOutEP_itr(pdev, epnum);
 8002f34:	4630      	mov	r0, r6
 8002f36:	4649      	mov	r1, r9
 8002f38:	f7ff fbee 	bl	8002718 <USB_OTG_ReadDevOutEP_itr>
      
      /* Transfer complete */
      if ( doepint.b.xfercompl )
 8002f3c:	b2c0      	uxtb	r0, r0
 8002f3e:	f010 0f01 	tst.w	r0, #1
 8002f42:	d013      	beq.n	8002f6c <USBD_OTG_ISR_Handler+0x2c8>
      {
        /* Clear the bit in DOEPINTn for this interrupt */
        CLEAR_OUT_EP_INTR(epnum, xfercompl);
 8002f44:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8002f46:	2001      	movs	r0, #1
 8002f48:	6098      	str	r0, [r3, #8]
        if (pdev->cfg.dma_enable == 1)
 8002f4a:	78f2      	ldrb	r2, [r6, #3]
 8002f4c:	2a01      	cmp	r2, #1
 8002f4e:	f000 8142 	beq.w	80031d6 <USBD_OTG_ISR_Handler+0x532>
          pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
            deptsiz.b.xfersize;
        }
        /* Inform upper layer: data ready */
        /* RX COMPLETE */
        USBD_DCD_INT_fops->DataOutStage(pdev , epnum);
 8002f52:	f8db 1000 	ldr.w	r1, [fp]
 8002f56:	4630      	mov	r0, r6
 8002f58:	680b      	ldr	r3, [r1, #0]
 8002f5a:	4649      	mov	r1, r9
 8002f5c:	4798      	blx	r3
        
        if (pdev->cfg.dma_enable == 1)
 8002f5e:	f896 9003 	ldrb.w	r9, [r6, #3]
 8002f62:	f1b9 0f01 	cmp.w	r9, #1
 8002f66:	f000 8129 	beq.w	80031bc <USBD_OTG_ISR_Handler+0x518>
 8002f6a:	2001      	movs	r0, #1
            USB_OTG_EP0_OutStart(pdev);
          }
        }        
      }
      /* Endpoint disable  */
      if ( doepint.b.epdisabled )
 8002f6c:	f000 0902 	and.w	r9, r0, #2
 8002f70:	fa5f f289 	uxtb.w	r2, r9
 8002f74:	b112      	cbz	r2, 8002f7c <USBD_OTG_ISR_Handler+0x2d8>
      {
        /* Clear the bit in DOEPINTn for this interrupt */
        CLEAR_OUT_EP_INTR(epnum, epdisabled);
 8002f76:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8002f78:	2002      	movs	r0, #2
 8002f7a:	6098      	str	r0, [r3, #8]
      }
      /* AHB Error */
      if ( doepint.b.ahberr )
 8002f7c:	f000 0c04 	and.w	ip, r0, #4
 8002f80:	fa5f f18c 	uxtb.w	r1, ip
 8002f84:	b111      	cbz	r1, 8002f8c <USBD_OTG_ISR_Handler+0x2e8>
      {
        CLEAR_OUT_EP_INTR(epnum, ahberr);
 8002f86:	6d6a      	ldr	r2, [r5, #84]	; 0x54
 8002f88:	2004      	movs	r0, #4
 8002f8a:	6090      	str	r0, [r2, #8]
      }
      /* Setup Phase Done (control EPs) */
      if ( doepint.b.setup )
 8002f8c:	f000 0e08 	and.w	lr, r0, #8
 8002f90:	fa5f f08e 	uxtb.w	r0, lr
 8002f94:	2800      	cmp	r0, #0
 8002f96:	d0c2      	beq.n	8002f1e <USBD_OTG_ISR_Handler+0x27a>
      {
        
        /* inform the upper layer that a setup packet is available */
        /* SETUP COMPLETE */
        USBD_DCD_INT_fops->SetupStage(pdev);
 8002f98:	f8db 1000 	ldr.w	r1, [fp]
 8002f9c:	4630      	mov	r0, r6
 8002f9e:	688a      	ldr	r2, [r1, #8]
 8002fa0:	4790      	blx	r2
        CLEAR_OUT_EP_INTR(epnum, setup);
 8002fa2:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8002fa4:	2108      	movs	r1, #8
 8002fa6:	6099      	str	r1, [r3, #8]
 8002fa8:	e7b9      	b.n	8002f1e <USBD_OTG_ISR_Handler+0x27a>
 8002faa:	46d1      	mov	r9, sl
      return 0;
    }
    
    if (gintr_status.b.outepintr)
    {
      retval |= DCD_HandleOutEP_ISR(pdev);
 8002fac:	2001      	movs	r0, #1
 8002fae:	e691      	b.n	8002cd4 <USBD_OTG_ISR_Handler+0x30>
 8002fb0:	20000134 	.word	0x20000134
{
  USB_OTG_GINTSTS_TypeDef gintsts;  
  
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoINIncomplete (pdev); 
 8002fb4:	488d      	ldr	r0, [pc, #564]	; (80031ec <USBD_OTG_ISR_Handler+0x548>)
 8002fb6:	6802      	ldr	r2, [r0, #0]
 8002fb8:	4630      	mov	r0, r6
 8002fba:	69d1      	ldr	r1, [r2, #28]
 8002fbc:	4788      	blx	r1
  
  /* Clear interrupt */
  gintsts.b.incomplisoin = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002fbe:	68f3      	ldr	r3, [r6, #12]
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoINIncomplete (pdev); 
  
  /* Clear interrupt */
  gintsts.b.incomplisoin = 1;
 8002fc0:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002fc4:	6158      	str	r0, [r3, #20]
      retval |= DCD_HandleEnumDone_ISR(pdev);
    }
    
    if (gintr_status.b.incomplisoin)
    {
      retval |= DCD_IsoINIncomplete_ISR(pdev);
 8002fc6:	2001      	movs	r0, #1
 8002fc8:	e6e0      	b.n	8002d8c <USBD_OTG_ISR_Handler+0xe8>
static uint32_t DCD_HandleEnumDone_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_GINTSTS_TypeDef  gintsts;
  USB_OTG_GUSBCFG_TypeDef  gusbcfg;
  
  USB_OTG_EP0Activate(pdev);
 8002fca:	4630      	mov	r0, r6
 8002fcc:	f7ff f996 	bl	80022fc <USB_OTG_EP0Activate>
  
  /* Set USB turn-around time based on device speed and PHY interface. */
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8002fd0:	68f4      	ldr	r4, [r6, #12]
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
 8002fd2:	4630      	mov	r0, r6
  USB_OTG_GUSBCFG_TypeDef  gusbcfg;
  
  USB_OTG_EP0Activate(pdev);
  
  /* Set USB turn-around time based on device speed and PHY interface. */
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8002fd4:	68e4      	ldr	r4, [r4, #12]
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
 8002fd6:	f7ff f981 	bl	80022dc <USB_OTG_GetDeviceSpeed>
 8002fda:	2803      	cmp	r0, #3
 8002fdc:	f000 80c1 	beq.w	8003162 <USBD_OTG_ISR_Handler+0x4be>
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
    gusbcfg.b.usbtrdtim = 9;
  }
  else
  {
    pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8002fe0:	2001      	movs	r0, #1
    pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;  
 8002fe2:	2140      	movs	r1, #64	; 0x40
    gusbcfg.b.usbtrdtim = 5;
 8002fe4:	2305      	movs	r3, #5
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
    gusbcfg.b.usbtrdtim = 9;
  }
  else
  {
    pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8002fe6:	70b0      	strb	r0, [r6, #2]
    pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;  
 8002fe8:	80b1      	strh	r1, [r6, #4]
    gusbcfg.b.usbtrdtim = 5;
 8002fea:	f363 248d 	bfi	r4, r3, #10, #4
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
 8002fee:	68f3      	ldr	r3, [r6, #12]
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.enumdone = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, gintsts.d32 );
 8002ff0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    pdev->cfg.speed            = USB_OTG_SPEED_FULL;
    pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;  
    gusbcfg.b.usbtrdtim = 5;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
 8002ff4:	60dc      	str	r4, [r3, #12]
      retval |= DCD_HandleUsbReset_ISR(pdev);
      
    }
    if (gintr_status.b.enumdone)
    {
      retval |= DCD_HandleEnumDone_ISR(pdev);
 8002ff6:	2001      	movs	r0, #1
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.enumdone = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, gintsts.d32 );
 8002ff8:	615a      	str	r2, [r3, #20]
 8002ffa:	e6be      	b.n	8002d7a <USBD_OTG_ISR_Handler+0xd6>
  dcfg.d32 = 0;
  gintsts.d32 = 0;
  
  /* Clear the Remote Wake-up Signaling */
  dctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
 8002ffc:	6930      	ldr	r0, [r6, #16]
 8002ffe:	6843      	ldr	r3, [r0, #4]
  USB_OTG_DCFG_TypeDef     dcfg;
  USB_OTG_DCTL_TypeDef     dctl;
  USB_OTG_GINTSTS_TypeDef  gintsts;
  uint32_t i;
  
  dctl.d32 = 0;
 8003000:	2400      	movs	r4, #0
  dcfg.d32 = 0;
  gintsts.d32 = 0;
  
  /* Clear the Remote Wake-up Signaling */
  dctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
 8003002:	f023 0201 	bic.w	r2, r3, #1
 8003006:	6042      	str	r2, [r0, #4]
  
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
 8003008:	4621      	mov	r1, r4
 800300a:	4630      	mov	r0, r6
 800300c:	f7ff f832 	bl	8002074 <USB_OTG_FlushTxFifo>
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8003010:	7875      	ldrb	r5, [r6, #1]
 8003012:	b16d      	cbz	r5, 8003030 <USBD_OTG_ISR_Handler+0x38c>
* @brief  STM32_USBF_OTG_ISR_Handler
*         handles all USB Interrupts
* @param  pdev: device instance
* @retval status
*/
uint32_t USBD_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
 8003014:	f106 0214 	add.w	r2, r6, #20
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
  
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8003018:	4623      	mov	r3, r4
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 800301a:	21ff      	movs	r1, #255	; 0xff
 800301c:	f852 5f04 	ldr.w	r5, [r2, #4]!
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 8003020:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 8003022:	60a9      	str	r1, [r5, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 8003024:	6081      	str	r1, [r0, #8]
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
  
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8003026:	f896 e001 	ldrb.w	lr, [r6, #1]
 800302a:	3301      	adds	r3, #1
 800302c:	4573      	cmp	r3, lr
 800302e:	d3f5      	bcc.n	800301c <USBD_OTG_ISR_Handler+0x378>
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
  
  daintmsk.ep.in = 1;
 8003030:	2501      	movs	r5, #1
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8003032:	6933      	ldr	r3, [r6, #16]
  
  daintmsk.ep.in = 1;
 8003034:	f365 040f 	bfi	r4, r5, #0, #16
  
  doepmsk.b.setup = 1;
  doepmsk.b.xfercompl = 1;
  doepmsk.b.ahberr = 1;
  doepmsk.b.epdisabled = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, doepmsk.d32 );
 8003038:	210f      	movs	r1, #15
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 800303a:	f04f 32ff 	mov.w	r2, #4294967295
  diepmsk.b.xfercompl = 1;
  diepmsk.b.timeout = 1;
  diepmsk.b.epdisabled = 1;
  diepmsk.b.ahberr = 1;
  diepmsk.b.intknepmis = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, diepmsk.d32 );
 800303e:	202f      	movs	r0, #47	; 0x2f
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
  
  daintmsk.ep.in = 1;
  daintmsk.ep.out = 1;
 8003040:	f365 441f 	bfi	r4, r5, #16, #16
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8003044:	619a      	str	r2, [r3, #24]
  
  daintmsk.ep.in = 1;
  daintmsk.ep.out = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, daintmsk.d32 );
 8003046:	61dc      	str	r4, [r3, #28]
  
  doepmsk.b.setup = 1;
  doepmsk.b.xfercompl = 1;
  doepmsk.b.ahberr = 1;
  doepmsk.b.epdisabled = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, doepmsk.d32 );
 8003048:	6159      	str	r1, [r3, #20]
  diepmsk.b.xfercompl = 1;
  diepmsk.b.timeout = 1;
  diepmsk.b.epdisabled = 1;
  diepmsk.b.ahberr = 1;
  diepmsk.b.intknepmis = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, diepmsk.d32 );
 800304a:	6118      	str	r0, [r3, #16]
#ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED  
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DINEP1MSK, diepmsk.d32 );
#endif
  /* Reset Device Address */
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
 800304c:	681a      	ldr	r2, [r3, #0]
  dcfg.b.devaddr = 0;
 800304e:	f36f 120a 	bfc	r2, #4, #7
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32);
 8003052:	601a      	str	r2, [r3, #0]
  
  
  /* setup EP0 to receive SETUP packets */
  USB_OTG_EP0_OutStart(pdev);
 8003054:	4630      	mov	r0, r6
 8003056:	f7ff fb71 	bl	800273c <USB_OTG_EP0_OutStart>
  gintsts.d32 = 0;
  gintsts.b.usbreset = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
  
  /*Reset internal state machine */
  USBD_DCD_INT_fops->Reset(pdev);
 800305a:	4964      	ldr	r1, [pc, #400]	; (80031ec <USBD_OTG_ISR_Handler+0x548>)
  USB_OTG_EP0_OutStart(pdev);
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbreset = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 800305c:	68f2      	ldr	r2, [r6, #12]
  
  /*Reset internal state machine */
  USBD_DCD_INT_fops->Reset(pdev);
 800305e:	680b      	ldr	r3, [r1, #0]
  /* setup EP0 to receive SETUP packets */
  USB_OTG_EP0_OutStart(pdev);
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbreset = 1;
 8003060:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8003064:	6150      	str	r0, [r2, #20]
  
  /*Reset internal state machine */
  USBD_DCD_INT_fops->Reset(pdev);
 8003066:	6919      	ldr	r1, [r3, #16]
 8003068:	4630      	mov	r0, r6
 800306a:	4788      	blx	r1
      
    }
    
    if (gintr_status.b.usbreset)
    {
      retval |= DCD_HandleUsbReset_ISR(pdev);
 800306c:	4628      	mov	r0, r5
 800306e:	e67b      	b.n	8002d68 <USBD_OTG_ISR_Handler+0xc4>
  USB_OTG_EP *ep;
  
  /* Disable the Rx Status Queue Level interrupt */
  int_mask.d32 = 0;
  int_mask.b.rxstsqlvl = 1;
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32, 0);
 8003070:	68f3      	ldr	r3, [r6, #12]
 8003072:	699d      	ldr	r5, [r3, #24]
 8003074:	f025 0410 	bic.w	r4, r5, #16
 8003078:	619c      	str	r4, [r3, #24]
  
  /* Get the Status from the top of the FIFO */
  status.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRXSTSP );
 800307a:	6a1c      	ldr	r4, [r3, #32]
  
  ep = &pdev->dev.out_ep[status.b.epnum];
  
  switch (status.b.pktsts)
 800307c:	f3c4 4243 	ubfx	r2, r4, #17, #4
 8003080:	2a02      	cmp	r2, #2
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32, 0);
  
  /* Get the Status from the top of the FIFO */
  status.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRXSTSP );
  
  ep = &pdev->dev.out_ep[status.b.epnum];
 8003082:	f004 050f 	and.w	r5, r4, #15
  
  switch (status.b.pktsts)
 8003086:	d04e      	beq.n	8003126 <USBD_OTG_ISR_Handler+0x482>
 8003088:	2a06      	cmp	r2, #6
 800308a:	d111      	bne.n	80030b0 <USBD_OTG_ISR_Handler+0x40c>
    break;
  case STS_SETUP_COMP:
    break;
  case STS_SETUP_UPDT:
    /* Copy the setup packet received in FIFO into the setup buffer in RAM */
    USB_OTG_ReadPacket(pdev , pdev->dev.setup_packet, 8);
 800308c:	f506 61b9 	add.w	r1, r6, #1480	; 0x5c8
 8003090:	4630      	mov	r0, r6
 8003092:	2208      	movs	r2, #8
    ep->xfer_count += status.b.bcnt;
 8003094:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    break;
  case STS_SETUP_COMP:
    break;
  case STS_SETUP_UPDT:
    /* Copy the setup packet received in FIFO into the setup buffer in RAM */
    USB_OTG_ReadPacket(pdev , pdev->dev.setup_packet, 8);
 8003098:	f7fe fe52 	bl	8001d40 <USB_OTG_ReadPacket>
    ep->xfer_count += status.b.bcnt;
 800309c:	eb06 0cc5 	add.w	ip, r6, r5, lsl #3
 80030a0:	f3c4 140a 	ubfx	r4, r4, #4, #11
 80030a4:	f8dc 1388 	ldr.w	r1, [ip, #904]	; 0x388
 80030a8:	68f3      	ldr	r3, [r6, #12]
 80030aa:	1860      	adds	r0, r4, r1
 80030ac:	f8cc 0388 	str.w	r0, [ip, #904]	; 0x388
  default:
    break;
  }
  
  /* Enable the Rx Status Queue Level interrupt */
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, int_mask.d32);
 80030b0:	6998      	ldr	r0, [r3, #24]
 80030b2:	f040 0210 	orr.w	r2, r0, #16
 80030b6:	619a      	str	r2, [r3, #24]
      
    }
    
    if (gintr_status.b.rxstsqlvl)
    {
      retval |= DCD_HandleRxStatusQueueLevel_ISR(pdev);
 80030b8:	2001      	movs	r0, #1
 80030ba:	e64c      	b.n	8002d56 <USBD_OTG_ISR_Handler+0xb2>
static uint32_t DCD_HandleSof_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_GINTSTS_TypeDef  GINTSTS;
  
  
  USBD_DCD_INT_fops->SOF(pdev);
 80030bc:	484b      	ldr	r0, [pc, #300]	; (80031ec <USBD_OTG_ISR_Handler+0x548>)
 80030be:	6802      	ldr	r2, [r0, #0]
 80030c0:	4630      	mov	r0, r6
 80030c2:	68d1      	ldr	r1, [r2, #12]
 80030c4:	4788      	blx	r1
  
  /* Clear interrupt */
  GINTSTS.d32 = 0;
  GINTSTS.b.sofintr = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, GINTSTS.d32);
 80030c6:	68f3      	ldr	r3, [r6, #12]
  
  USBD_DCD_INT_fops->SOF(pdev);
  
  /* Clear interrupt */
  GINTSTS.d32 = 0;
  GINTSTS.b.sofintr = 1;
 80030c8:	2008      	movs	r0, #8
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, GINTSTS.d32);
 80030ca:	6158      	str	r0, [r3, #20]
    {
      retval |= DCD_HandleUSBSuspend_ISR(pdev);
    }
    if (gintr_status.b.sofintr)
    {
      retval |= DCD_HandleSof_ISR(pdev);
 80030cc:	2001      	movs	r0, #1
 80030ce:	e63b      	b.n	8002d48 <USBD_OTG_ISR_Handler+0xa4>
{
  USB_OTG_GINTSTS_TypeDef  gintsts;
  USB_OTG_PCGCCTL_TypeDef  power;
  USB_OTG_DSTS_TypeDef     dsts;
  
  USBD_DCD_INT_fops->Suspend (pdev);      
 80030d0:	4846      	ldr	r0, [pc, #280]	; (80031ec <USBD_OTG_ISR_Handler+0x548>)
 80030d2:	6803      	ldr	r3, [r0, #0]
 80030d4:	4630      	mov	r0, r6
 80030d6:	695a      	ldr	r2, [r3, #20]
 80030d8:	4790      	blx	r2
  
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 80030da:	6931      	ldr	r1, [r6, #16]
    
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbsuspend = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 80030dc:	68f3      	ldr	r3, [r6, #12]
  USB_OTG_PCGCCTL_TypeDef  power;
  USB_OTG_DSTS_TypeDef     dsts;
  
  USBD_DCD_INT_fops->Suspend (pdev);      
  
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 80030de:	6889      	ldr	r1, [r1, #8]
    
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbsuspend = 1;
 80030e0:	f44f 6200 	mov.w	r2, #2048	; 0x800
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 80030e4:	615a      	str	r2, [r3, #20]
  
  if((pdev->cfg.low_power) && (dsts.b.suspsts == 1))
 80030e6:	7ab0      	ldrb	r0, [r6, #10]
 80030e8:	b188      	cbz	r0, 800310e <USBD_OTG_ISR_Handler+0x46a>
 80030ea:	f011 0f01 	tst.w	r1, #1
 80030ee:	d00e      	beq.n	800310e <USBD_OTG_ISR_Handler+0x46a>
  {
	/*  switch-off the clocks */
    power.d32 = 0;
    power.b.stoppclk = 1;
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);  
 80030f0:	f8d6 310c 	ldr.w	r3, [r6, #268]	; 0x10c
    
    power.b.gatehclk = 1;
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);
    
    /* Request to enter Sleep mode after exit from current ISR */
    SCB->SCR |= (SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk);
 80030f4:	4a3e      	ldr	r2, [pc, #248]	; (80031f0 <USBD_OTG_ISR_Handler+0x54c>)
  if((pdev->cfg.low_power) && (dsts.b.suspsts == 1))
  {
	/*  switch-off the clocks */
    power.d32 = 0;
    power.b.stoppclk = 1;
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);  
 80030f6:	6819      	ldr	r1, [r3, #0]
 80030f8:	f041 0001 	orr.w	r0, r1, #1
 80030fc:	6018      	str	r0, [r3, #0]
    
    power.b.gatehclk = 1;
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);
 80030fe:	6819      	ldr	r1, [r3, #0]
 8003100:	f041 0003 	orr.w	r0, r1, #3
 8003104:	6018      	str	r0, [r3, #0]
    
    /* Request to enter Sleep mode after exit from current ISR */
    SCB->SCR |= (SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk);
 8003106:	6913      	ldr	r3, [r2, #16]
 8003108:	f043 0106 	orr.w	r1, r3, #6
 800310c:	6111      	str	r1, [r2, #16]
      retval |= DCD_HandleResume_ISR(pdev);
    }
    
    if (gintr_status.b.usbsuspend)
    {
      retval |= DCD_HandleUSBSuspend_ISR(pdev);
 800310e:	2001      	movs	r0, #1
 8003110:	e613      	b.n	8002d3a <USBD_OTG_ISR_Handler+0x96>
  USB_OTG_PCGCCTL_TypeDef  power;
  
  if(pdev->cfg.low_power)
  {
    /* un-gate USB Core clock */
    power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
 8003112:	f8d6 310c 	ldr.w	r3, [r6, #268]	; 0x10c
    power.b.gatehclk = 0;
    power.b.stoppclk = 0;
    USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 8003116:	f8d6 210c 	ldr.w	r2, [r6, #268]	; 0x10c
  
  if(pdev->cfg.low_power)
  {
    /* un-gate USB Core clock */
    power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
    power.b.gatehclk = 0;
 800311a:	f36f 0341 	bfc	r3, #1, #1
    power.b.stoppclk = 0;
 800311e:	f36f 0300 	bfc	r3, #0, #1
    USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 8003122:	6013      	str	r3, [r2, #0]
 8003124:	e5f1      	b.n	8002d0a <USBD_OTG_ISR_Handler+0x66>
  switch (status.b.pktsts)
  {
  case STS_GOUT_NAK:
    break;
  case STS_DATA_UPDT:
    if (status.b.bcnt)
 8003126:	f647 72f0 	movw	r2, #32752	; 0x7ff0
 800312a:	ea04 0102 	and.w	r1, r4, r2
 800312e:	2900      	cmp	r1, #0
 8003130:	d0be      	beq.n	80030b0 <USBD_OTG_ISR_Handler+0x40c>
    {
      USB_OTG_ReadPacket(pdev,ep->xfer_buff, status.b.bcnt);
 8003132:	eb05 0e85 	add.w	lr, r5, r5, lsl #2
 8003136:	eb06 05ce 	add.w	r5, r6, lr, lsl #3
 800313a:	f3c4 140a 	ubfx	r4, r4, #4, #11
 800313e:	4622      	mov	r2, r4
 8003140:	f8d5 137c 	ldr.w	r1, [r5, #892]	; 0x37c
 8003144:	4630      	mov	r0, r6
 8003146:	f7fe fdfb 	bl	8001d40 <USB_OTG_ReadPacket>
      ep->xfer_buff += status.b.bcnt;
 800314a:	f8d5 237c 	ldr.w	r2, [r5, #892]	; 0x37c
      ep->xfer_count += status.b.bcnt;
 800314e:	f8d5 1388 	ldr.w	r1, [r5, #904]	; 0x388
 8003152:	68f3      	ldr	r3, [r6, #12]
    break;
  case STS_DATA_UPDT:
    if (status.b.bcnt)
    {
      USB_OTG_ReadPacket(pdev,ep->xfer_buff, status.b.bcnt);
      ep->xfer_buff += status.b.bcnt;
 8003154:	1910      	adds	r0, r2, r4
      ep->xfer_count += status.b.bcnt;
 8003156:	1864      	adds	r4, r4, r1
    break;
  case STS_DATA_UPDT:
    if (status.b.bcnt)
    {
      USB_OTG_ReadPacket(pdev,ep->xfer_buff, status.b.bcnt);
      ep->xfer_buff += status.b.bcnt;
 8003158:	f8c5 037c 	str.w	r0, [r5, #892]	; 0x37c
      ep->xfer_count += status.b.bcnt;
 800315c:	f8c5 4388 	str.w	r4, [r5, #904]	; 0x388
 8003160:	e7a6      	b.n	80030b0 <USBD_OTG_ISR_Handler+0x40c>
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
  {
    pdev->cfg.speed            = USB_OTG_SPEED_HIGH;
 8003162:	2200      	movs	r2, #0
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
 8003164:	f44f 7e00 	mov.w	lr, #512	; 0x200
    gusbcfg.b.usbtrdtim = 9;
 8003168:	2009      	movs	r0, #9
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
  {
    pdev->cfg.speed            = USB_OTG_SPEED_HIGH;
 800316a:	70b2      	strb	r2, [r6, #2]
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
 800316c:	f8a6 e004 	strh.w	lr, [r6, #4]
    gusbcfg.b.usbtrdtim = 9;
 8003170:	f360 248d 	bfi	r4, r0, #10, #4
 8003174:	e73b      	b.n	8002fee <USBD_OTG_ISR_Handler+0x34a>
      {
        fifoemptymsk = 0x1 << epnum;
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
        CLEAR_IN_EP_INTR(epnum, xfercompl);
        /* TX COMPLETE */
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 8003176:	4d1d      	ldr	r5, [pc, #116]	; (80031ec <USBD_OTG_ISR_Handler+0x548>)
    {
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
      {
        fifoemptymsk = 0x1 << epnum;
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
 8003178:	6b58      	ldr	r0, [r3, #52]	; 0x34
        CLEAR_IN_EP_INTR(epnum, xfercompl);
        /* TX COMPLETE */
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 800317a:	6829      	ldr	r1, [r5, #0]
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
      {
        fifoemptymsk = 0x1 << epnum;
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
        CLEAR_IN_EP_INTR(epnum, xfercompl);
 800317c:	69ba      	ldr	r2, [r7, #24]
    if (ep_intr&0x1) /* In ITR */
    {
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
      {
        fifoemptymsk = 0x1 << epnum;
 800317e:	2501      	movs	r5, #1
 8003180:	fa05 fe0b 	lsl.w	lr, r5, fp
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
 8003184:	ea20 000e 	bic.w	r0, r0, lr
 8003188:	6358      	str	r0, [r3, #52]	; 0x34
        CLEAR_IN_EP_INTR(epnum, xfercompl);
        /* TX COMPLETE */
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 800318a:	684b      	ldr	r3, [r1, #4]
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
      {
        fifoemptymsk = 0x1 << epnum;
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
        CLEAR_IN_EP_INTR(epnum, xfercompl);
 800318c:	6095      	str	r5, [r2, #8]
        /* TX COMPLETE */
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 800318e:	4640      	mov	r0, r8
 8003190:	4631      	mov	r1, r6
 8003192:	4798      	blx	r3
        
        if (pdev->cfg.dma_enable == 1)
 8003194:	f898 9003 	ldrb.w	r9, [r8, #3]
 8003198:	45a9      	cmp	r9, r5
 800319a:	f47f ae35 	bne.w	8002e08 <USBD_OTG_ISR_Handler+0x164>
        {
          if((epnum == 0) && (pdev->dev.device_state == USB_OTG_EP0_STATUS_IN))
 800319e:	f1bb 0f00 	cmp.w	fp, #0
 80031a2:	d104      	bne.n	80031ae <USBD_OTG_ISR_Handler+0x50a>
 80031a4:	f898 c111 	ldrb.w	ip, [r8, #273]	; 0x111
 80031a8:	f1bc 0f04 	cmp.w	ip, #4
 80031ac:	d001      	beq.n	80031b2 <USBD_OTG_ISR_Handler+0x50e>
          {
            /* prepare to rx more setup packets */
            USB_OTG_EP0_OutStart(pdev);
 80031ae:	464d      	mov	r5, r9
 80031b0:	e62a      	b.n	8002e08 <USBD_OTG_ISR_Handler+0x164>
 80031b2:	4640      	mov	r0, r8
 80031b4:	f7ff fac2 	bl	800273c <USB_OTG_EP0_OutStart>
 80031b8:	464d      	mov	r5, r9
 80031ba:	e625      	b.n	8002e08 <USBD_OTG_ISR_Handler+0x164>
        /* RX COMPLETE */
        USBD_DCD_INT_fops->DataOutStage(pdev , epnum);
        
        if (pdev->cfg.dma_enable == 1)
        {
          if((epnum == 0) && (pdev->dev.device_state == USB_OTG_EP0_STATUS_OUT))
 80031bc:	b927      	cbnz	r7, 80031c8 <USBD_OTG_ISR_Handler+0x524>
 80031be:	f896 e111 	ldrb.w	lr, [r6, #273]	; 0x111
 80031c2:	f1be 0f05 	cmp.w	lr, #5
 80031c6:	d001      	beq.n	80031cc <USBD_OTG_ISR_Handler+0x528>
          {
            /* prepare to rx more setup packets */
            USB_OTG_EP0_OutStart(pdev);
 80031c8:	4648      	mov	r0, r9
 80031ca:	e6cf      	b.n	8002f6c <USBD_OTG_ISR_Handler+0x2c8>
 80031cc:	4630      	mov	r0, r6
 80031ce:	f7ff fab5 	bl	800273c <USB_OTG_EP0_OutStart>
 80031d2:	4648      	mov	r0, r9
 80031d4:	e6ca      	b.n	8002f6c <USBD_OTG_ISR_Handler+0x2c8>
      {
        /* Clear the bit in DOEPINTn for this interrupt */
        CLEAR_OUT_EP_INTR(epnum, xfercompl);
        if (pdev->cfg.dma_enable == 1)
        {
          deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[epnum]->DOEPTSIZ));
 80031d6:	691a      	ldr	r2, [r3, #16]
          /*ToDo : handle more than one single MPS size packet */
          pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
 80031d8:	f8d8 1378 	ldr.w	r1, [r8, #888]	; 0x378
            deptsiz.b.xfersize;
 80031dc:	f3c2 0c12 	ubfx	ip, r2, #0, #19
        CLEAR_OUT_EP_INTR(epnum, xfercompl);
        if (pdev->cfg.dma_enable == 1)
        {
          deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[epnum]->DOEPTSIZ));
          /*ToDo : handle more than one single MPS size packet */
          pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
 80031e0:	ebcc 0301 	rsb	r3, ip, r1
 80031e4:	f8c8 3388 	str.w	r3, [r8, #904]	; 0x388
 80031e8:	e6b3      	b.n	8002f52 <USBD_OTG_ISR_Handler+0x2ae>
 80031ea:	bf00      	nop
 80031ec:	20000134 	.word	0x20000134
 80031f0:	e000ed00 	.word	0xe000ed00

080031f4 <USBD_Resume>:
*/

static uint8_t USBD_Resume(USB_OTG_CORE_HANDLE  *pdev)
{
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceResumed(); 
 80031f4:	f8d0 15e4 	ldr.w	r1, [r0, #1508]	; 0x5e4
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Resume(USB_OTG_CORE_HANDLE  *pdev)
{
 80031f8:	b510      	push	{r4, lr}
 80031fa:	4604      	mov	r4, r0
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceResumed(); 
 80031fc:	6908      	ldr	r0, [r1, #16]
 80031fe:	4780      	blx	r0
  pdev->dev.device_status = USB_OTG_CONFIGURED;  
 8003200:	2303      	movs	r3, #3
 8003202:	f884 3112 	strb.w	r3, [r4, #274]	; 0x112
  return USBD_OK;
}
 8003206:	2000      	movs	r0, #0
 8003208:	bd10      	pop	{r4, pc}
 800320a:	bf00      	nop

0800320c <USBD_Suspend>:
static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev)
{
  
  pdev->dev.device_status  = USB_OTG_SUSPENDED;
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceSuspended(); 
 800320c:	f8d0 15e4 	ldr.w	r1, [r0, #1508]	; 0x5e4
*/

static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev)
{
  
  pdev->dev.device_status  = USB_OTG_SUSPENDED;
 8003210:	2204      	movs	r2, #4
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev)
{
 8003212:	b508      	push	{r3, lr}
  
  pdev->dev.device_status  = USB_OTG_SUSPENDED;
 8003214:	f880 2112 	strb.w	r2, [r0, #274]	; 0x112
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceSuspended(); 
 8003218:	68cb      	ldr	r3, [r1, #12]
 800321a:	4798      	blx	r3
  return USBD_OK;
}
 800321c:	2000      	movs	r0, #0
 800321e:	bd08      	pop	{r3, pc}

08003220 <USBD_SOF>:
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_SOF(USB_OTG_CORE_HANDLE  *pdev)
{
 8003220:	b508      	push	{r3, lr}
  if(pdev->dev.class_cb->SOF)
 8003222:	f8d0 35e0 	ldr.w	r3, [r0, #1504]	; 0x5e0
 8003226:	69db      	ldr	r3, [r3, #28]
 8003228:	b103      	cbz	r3, 800322c <USBD_SOF+0xc>
  {
    pdev->dev.class_cb->SOF(pdev); 
 800322a:	4798      	blx	r3
  }
  return USBD_OK;
}
 800322c:	2000      	movs	r0, #0
 800322e:	bd08      	pop	{r3, pc}

08003230 <USBD_IsoINIncomplete>:
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoINIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
  pdev->dev.class_cb->IsoINIncomplete(pdev);   
 8003230:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
*         Handle iso in incomplete event
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoINIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
 8003234:	b508      	push	{r3, lr}
  pdev->dev.class_cb->IsoINIncomplete(pdev);   
 8003236:	6a0b      	ldr	r3, [r1, #32]
 8003238:	4798      	blx	r3
  return USBD_OK;
}
 800323a:	2000      	movs	r0, #0
 800323c:	bd08      	pop	{r3, pc}
 800323e:	bf00      	nop

08003240 <USBD_IsoOUTIncomplete>:
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoOUTIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
  pdev->dev.class_cb->IsoOUTIncomplete(pdev);   
 8003240:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
*         Handle iso out incomplete event
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoOUTIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
 8003244:	b508      	push	{r3, lr}
  pdev->dev.class_cb->IsoOUTIncomplete(pdev);   
 8003246:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8003248:	4798      	blx	r3
  return USBD_OK;
}
 800324a:	2000      	movs	r0, #0
 800324c:	bd08      	pop	{r3, pc}
 800324e:	bf00      	nop

08003250 <USBD_Reset>:
*/

static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
{
  /* Open EP0 OUT */
  DCD_EP_Open(pdev,
 8003250:	2100      	movs	r1, #0
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
{
 8003252:	b510      	push	{r4, lr}
  /* Open EP0 OUT */
  DCD_EP_Open(pdev,
 8003254:	460b      	mov	r3, r1
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
{
 8003256:	4604      	mov	r4, r0
  /* Open EP0 OUT */
  DCD_EP_Open(pdev,
 8003258:	2240      	movs	r2, #64	; 0x40
 800325a:	f7ff fc13 	bl	8002a84 <DCD_EP_Open>
              0x00,
              USB_OTG_MAX_EP0_SIZE,
              EP_TYPE_CTRL);
  
  /* Open EP0 IN */
  DCD_EP_Open(pdev,
 800325e:	2180      	movs	r1, #128	; 0x80
 8003260:	2240      	movs	r2, #64	; 0x40
 8003262:	2300      	movs	r3, #0
 8003264:	4620      	mov	r0, r4
 8003266:	f7ff fc0d 	bl	8002a84 <DCD_EP_Open>
              USB_OTG_MAX_EP0_SIZE,
              EP_TYPE_CTRL);
  
  /* Upon Reset call usr call back */
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.usr_cb->DeviceReset(pdev->cfg.speed);
 800326a:	f8d4 15e4 	ldr.w	r1, [r4, #1508]	; 0x5e4
 800326e:	78a0      	ldrb	r0, [r4, #2]
              0x80,
              USB_OTG_MAX_EP0_SIZE,
              EP_TYPE_CTRL);
  
  /* Upon Reset call usr call back */
  pdev->dev.device_status = USB_OTG_DEFAULT;
 8003270:	2201      	movs	r2, #1
 8003272:	f884 2112 	strb.w	r2, [r4, #274]	; 0x112
  pdev->dev.usr_cb->DeviceReset(pdev->cfg.speed);
 8003276:	684b      	ldr	r3, [r1, #4]
 8003278:	4798      	blx	r3
  
  return USBD_OK;
}
 800327a:	2000      	movs	r0, #0
 800327c:	bd10      	pop	{r4, pc}
 800327e:	bf00      	nop

08003280 <USBD_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_SetupStage(USB_OTG_CORE_HANDLE *pdev)
{
 8003280:	b510      	push	{r4, lr}
 8003282:	b082      	sub	sp, #8
  USB_SETUP_REQ req;
  
  USBD_ParseSetupRequest(pdev , &req);
 8003284:	4669      	mov	r1, sp
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_SetupStage(USB_OTG_CORE_HANDLE *pdev)
{
 8003286:	4604      	mov	r4, r0
  USB_SETUP_REQ req;
  
  USBD_ParseSetupRequest(pdev , &req);
 8003288:	f000 f93c 	bl	8003504 <USBD_ParseSetupRequest>
  
  switch (req.bmRequest & 0x1F) 
 800328c:	f89d 1000 	ldrb.w	r1, [sp]
 8003290:	f001 031f 	and.w	r3, r1, #31
 8003294:	2b01      	cmp	r3, #1
 8003296:	d014      	beq.n	80032c2 <USBD_SetupStage+0x42>
 8003298:	2b02      	cmp	r3, #2
 800329a:	d00d      	beq.n	80032b8 <USBD_SetupStage+0x38>
 800329c:	b13b      	cbz	r3, 80032ae <USBD_SetupStage+0x2e>
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &req);   
    break;
    
  default:           
    DCD_EP_Stall(pdev , req.bmRequest & 0x80);
 800329e:	4620      	mov	r0, r4
 80032a0:	f001 0180 	and.w	r1, r1, #128	; 0x80
 80032a4:	f7ff fc70 	bl	8002b88 <DCD_EP_Stall>
    break;
  }  
  return USBD_OK;
}
 80032a8:	2000      	movs	r0, #0
 80032aa:	b002      	add	sp, #8
 80032ac:	bd10      	pop	{r4, pc}
  USBD_ParseSetupRequest(pdev , &req);
  
  switch (req.bmRequest & 0x1F) 
  {
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &req);
 80032ae:	4620      	mov	r0, r4
 80032b0:	4669      	mov	r1, sp
 80032b2:	f000 f9f1 	bl	8003698 <USBD_StdDevReq>
    break;
 80032b6:	e7f7      	b.n	80032a8 <USBD_SetupStage+0x28>
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &req);
    break;
    
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &req);   
 80032b8:	4620      	mov	r0, r4
 80032ba:	4669      	mov	r1, sp
 80032bc:	f000 f960 	bl	8003580 <USBD_StdEPReq>
    break;
 80032c0:	e7f2      	b.n	80032a8 <USBD_SetupStage+0x28>
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &req);
    break;
    
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &req);
 80032c2:	4620      	mov	r0, r4
 80032c4:	4669      	mov	r1, sp
 80032c6:	f000 f9cd 	bl	8003664 <USBD_StdItfReq>
    break;
 80032ca:	e7ed      	b.n	80032a8 <USBD_SetupStage+0x28>

080032cc <USBD_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
static uint8_t USBD_DataInStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
 80032cc:	b538      	push	{r3, r4, r5, lr}
 80032ce:	4604      	mov	r4, r0
  USB_OTG_EP *ep;
  
  if(epnum == 0) 
 80032d0:	b929      	cbnz	r1, 80032de <USBD_DataInStage+0x12>
  {
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
 80032d2:	f890 3111 	ldrb.w	r3, [r0, #273]	; 0x111
 80032d6:	2b02      	cmp	r3, #2
 80032d8:	d00d      	beq.n	80032f6 <USBD_DataInStage+0x2a>
          (pdev->dev.device_status == USB_OTG_CONFIGURED))
  {
    pdev->dev.class_cb->DataIn(pdev, epnum); 
  }  
  return USBD_OK;
}
 80032da:	2000      	movs	r0, #0
 80032dc:	bd38      	pop	{r3, r4, r5, pc}
          USBD_CtlReceiveStatus(pdev);
        }
      }
    }
  }
  else if((pdev->dev.class_cb->DataIn != NULL)&& 
 80032de:	f8d0 25e0 	ldr.w	r2, [r0, #1504]	; 0x5e0
 80032e2:	6953      	ldr	r3, [r2, #20]
 80032e4:	2b00      	cmp	r3, #0
 80032e6:	d0f8      	beq.n	80032da <USBD_DataInStage+0xe>
 80032e8:	f890 c112 	ldrb.w	ip, [r0, #274]	; 0x112
 80032ec:	f1bc 0f03 	cmp.w	ip, #3
 80032f0:	d1f3      	bne.n	80032da <USBD_DataInStage+0xe>
          (pdev->dev.device_status == USB_OTG_CONFIGURED))
  {
    pdev->dev.class_cb->DataIn(pdev, epnum); 
 80032f2:	4798      	blx	r3
 80032f4:	e7f1      	b.n	80032da <USBD_DataInStage+0xe>
  if(epnum == 0) 
  {
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
    {
      if(ep->rem_data_len > ep->maxpacket)
 80032f6:	f8d0 2134 	ldr.w	r2, [r0, #308]	; 0x134
 80032fa:	f8d0 3120 	ldr.w	r3, [r0, #288]	; 0x120
 80032fe:	429a      	cmp	r2, r3
 8003300:	d910      	bls.n	8003324 <USBD_DataInStage+0x58>
      {
        ep->rem_data_len -=  ep->maxpacket;
        if(pdev->cfg.dma_enable == 1)
 8003302:	78c1      	ldrb	r1, [r0, #3]
 8003304:	2901      	cmp	r1, #1
 8003306:	f8d0 1124 	ldr.w	r1, [r0, #292]	; 0x124
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 800330a:	ebc3 0202 	rsb	r2, r3, r2
        if(pdev->cfg.dma_enable == 1)
        {
          /* in slave mode this, is handled by the TxFifoEmpty ISR */
          ep->xfer_buff += ep->maxpacket;
 800330e:	bf08      	it	eq
 8003310:	18c9      	addeq	r1, r1, r3
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 8003312:	f8c0 2134 	str.w	r2, [r0, #308]	; 0x134
        if(pdev->cfg.dma_enable == 1)
        {
          /* in slave mode this, is handled by the TxFifoEmpty ISR */
          ep->xfer_buff += ep->maxpacket;
 8003316:	bf08      	it	eq
 8003318:	f8c0 1124 	streq.w	r1, [r0, #292]	; 0x124
        }
        USBD_CtlContinueSendData (pdev, 
 800331c:	b292      	uxth	r2, r2
 800331e:	f000 f8a5 	bl	800346c <USBD_CtlContinueSendData>
 8003322:	e7da      	b.n	80032da <USBD_DataInStage+0xe>
                                  ep->xfer_buff, 
                                  ep->rem_data_len);
      }
      else
      { /* last packet is MPS multiple, so send ZLP packet */
        if((ep->total_data_len % ep->maxpacket == 0) &&
 8003324:	f8d0 2138 	ldr.w	r2, [r0, #312]	; 0x138
 8003328:	fbb2 f5f3 	udiv	r5, r2, r3
 800332c:	fb03 2515 	mls	r5, r3, r5, r2
 8003330:	b95d      	cbnz	r5, 800334a <USBD_DataInStage+0x7e>
 8003332:	4293      	cmp	r3, r2
 8003334:	d809      	bhi.n	800334a <USBD_DataInStage+0x7e>
           (ep->total_data_len >= ep->maxpacket) &&
 8003336:	f8d0 313c 	ldr.w	r3, [r0, #316]	; 0x13c
 800333a:	429a      	cmp	r2, r3
 800333c:	d205      	bcs.n	800334a <USBD_DataInStage+0x7e>
             (ep->total_data_len < ep->ctl_data_len ))
        {
          
          USBD_CtlContinueSendData(pdev , NULL, 0);
 800333e:	462a      	mov	r2, r5
 8003340:	f000 f894 	bl	800346c <USBD_CtlContinueSendData>
          ep->ctl_data_len = 0;
 8003344:	f8c4 513c 	str.w	r5, [r4, #316]	; 0x13c
 8003348:	e7c7      	b.n	80032da <USBD_DataInStage+0xe>
        }
        else
        {
          if((pdev->dev.class_cb->EP0_TxSent != NULL)&&
 800334a:	f8d4 05e0 	ldr.w	r0, [r4, #1504]	; 0x5e0
 800334e:	68c3      	ldr	r3, [r0, #12]
 8003350:	b123      	cbz	r3, 800335c <USBD_DataInStage+0x90>
 8003352:	f894 c112 	ldrb.w	ip, [r4, #274]	; 0x112
 8003356:	f1bc 0f03 	cmp.w	ip, #3
 800335a:	d003      	beq.n	8003364 <USBD_DataInStage+0x98>
             (pdev->dev.device_status == USB_OTG_CONFIGURED))
          {
            pdev->dev.class_cb->EP0_TxSent(pdev); 
          }          
          USBD_CtlReceiveStatus(pdev);
 800335c:	4620      	mov	r0, r4
 800335e:	f000 f8b9 	bl	80034d4 <USBD_CtlReceiveStatus>
 8003362:	e7ba      	b.n	80032da <USBD_DataInStage+0xe>
        else
        {
          if((pdev->dev.class_cb->EP0_TxSent != NULL)&&
             (pdev->dev.device_status == USB_OTG_CONFIGURED))
          {
            pdev->dev.class_cb->EP0_TxSent(pdev); 
 8003364:	4620      	mov	r0, r4
 8003366:	4798      	blx	r3
 8003368:	e7f8      	b.n	800335c <USBD_DataInStage+0x90>
 800336a:	bf00      	nop

0800336c <USBD_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
static uint8_t USBD_DataOutStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
 800336c:	b510      	push	{r4, lr}
 800336e:	4604      	mov	r4, r0
  USB_OTG_EP *ep;
  
  if(epnum == 0) 
 8003370:	b929      	cbnz	r1, 800337e <USBD_DataOutStage+0x12>
  {
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
 8003372:	f890 3111 	ldrb.w	r3, [r0, #273]	; 0x111
 8003376:	2b03      	cmp	r3, #3
 8003378:	d00d      	beq.n	8003396 <USBD_DataOutStage+0x2a>
          (pdev->dev.device_status == USB_OTG_CONFIGURED))
  {
    pdev->dev.class_cb->DataOut(pdev, epnum); 
  }  
  return USBD_OK;
}
 800337a:	2000      	movs	r0, #0
 800337c:	bd10      	pop	{r4, pc}
        }
        USBD_CtlSendStatus(pdev);
      }
    }
  }
  else if((pdev->dev.class_cb->DataOut != NULL)&&
 800337e:	f8d0 25e0 	ldr.w	r2, [r0, #1504]	; 0x5e0
 8003382:	6993      	ldr	r3, [r2, #24]
 8003384:	2b00      	cmp	r3, #0
 8003386:	d0f8      	beq.n	800337a <USBD_DataOutStage+0xe>
 8003388:	f890 c112 	ldrb.w	ip, [r0, #274]	; 0x112
 800338c:	f1bc 0f03 	cmp.w	ip, #3
 8003390:	d1f3      	bne.n	800337a <USBD_DataOutStage+0xe>
          (pdev->dev.device_status == USB_OTG_CONFIGURED))
  {
    pdev->dev.class_cb->DataOut(pdev, epnum); 
 8003392:	4798      	blx	r3
 8003394:	e7f1      	b.n	800337a <USBD_DataOutStage+0xe>
  if(epnum == 0) 
  {
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
    {
      if(ep->rem_data_len > ep->maxpacket)
 8003396:	f8d0 238c 	ldr.w	r2, [r0, #908]	; 0x38c
 800339a:	f8d0 3378 	ldr.w	r3, [r0, #888]	; 0x378
 800339e:	429a      	cmp	r2, r3
 80033a0:	d912      	bls.n	80033c8 <USBD_DataOutStage+0x5c>
      {
        ep->rem_data_len -=  ep->maxpacket;
        
        if(pdev->cfg.dma_enable == 1)
 80033a2:	78c1      	ldrb	r1, [r0, #3]
 80033a4:	2901      	cmp	r1, #1
 80033a6:	f8d0 137c 	ldr.w	r1, [r0, #892]	; 0x37c
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 80033aa:	ebc3 0202 	rsb	r2, r3, r2
        
        if(pdev->cfg.dma_enable == 1)
        {
          /* in slave mode this, is handled by the RxSTSQLvl ISR */
          ep->xfer_buff += ep->maxpacket; 
 80033ae:	bf04      	itt	eq
 80033b0:	18c9      	addeq	r1, r1, r3
 80033b2:	f8c0 137c 	streq.w	r1, [r0, #892]	; 0x37c
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 80033b6:	f8c0 238c 	str.w	r2, [r0, #908]	; 0x38c
          /* in slave mode this, is handled by the RxSTSQLvl ISR */
          ep->xfer_buff += ep->maxpacket; 
        }        
        USBD_CtlContinueRx (pdev, 
                            ep->xfer_buff,
                            MIN(ep->rem_data_len ,ep->maxpacket));
 80033ba:	429a      	cmp	r2, r3
 80033bc:	bf28      	it	cs
 80033be:	461a      	movcs	r2, r3
        if(pdev->cfg.dma_enable == 1)
        {
          /* in slave mode this, is handled by the RxSTSQLvl ISR */
          ep->xfer_buff += ep->maxpacket; 
        }        
        USBD_CtlContinueRx (pdev, 
 80033c0:	b292      	uxth	r2, r2
 80033c2:	f000 f86d 	bl	80034a0 <USBD_CtlContinueRx>
 80033c6:	e7d8      	b.n	800337a <USBD_DataOutStage+0xe>
                            ep->xfer_buff,
                            MIN(ep->rem_data_len ,ep->maxpacket));
      }
      else
      {
        if((pdev->dev.class_cb->EP0_RxReady != NULL)&&
 80033c8:	f8d0 35e0 	ldr.w	r3, [r0, #1504]	; 0x5e0
 80033cc:	691b      	ldr	r3, [r3, #16]
 80033ce:	b123      	cbz	r3, 80033da <USBD_DataOutStage+0x6e>
 80033d0:	f890 c112 	ldrb.w	ip, [r0, #274]	; 0x112
 80033d4:	f1bc 0f03 	cmp.w	ip, #3
 80033d8:	d003      	beq.n	80033e2 <USBD_DataOutStage+0x76>
           (pdev->dev.device_status == USB_OTG_CONFIGURED))
        {
          pdev->dev.class_cb->EP0_RxReady(pdev); 
        }
        USBD_CtlSendStatus(pdev);
 80033da:	4620      	mov	r0, r4
 80033dc:	f000 f86a 	bl	80034b4 <USBD_CtlSendStatus>
 80033e0:	e7cb      	b.n	800337a <USBD_DataOutStage+0xe>
      else
      {
        if((pdev->dev.class_cb->EP0_RxReady != NULL)&&
           (pdev->dev.device_status == USB_OTG_CONFIGURED))
        {
          pdev->dev.class_cb->EP0_RxReady(pdev); 
 80033e2:	4798      	blx	r3
 80033e4:	e7f9      	b.n	80033da <USBD_DataOutStage+0x6e>
 80033e6:	bf00      	nop

080033e8 <USBD_Init>:
void USBD_Init(USB_OTG_CORE_HANDLE *pdev,
               USB_OTG_CORE_ID_TypeDef coreID,
               USBD_DEVICE *pDevice,                  
               USBD_Class_cb_TypeDef *class_cb, 
               USBD_Usr_cb_TypeDef *usr_cb)
{
 80033e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80033ec:	9d06      	ldr	r5, [sp, #24]
 80033ee:	4604      	mov	r4, r0
 80033f0:	4616      	mov	r6, r2
 80033f2:	461f      	mov	r7, r3
 80033f4:	4688      	mov	r8, r1
  /* Hardware Init */
  USB_OTG_BSP_Init(pdev);  
 80033f6:	f000 fafb 	bl	80039f0 <USB_OTG_BSP_Init>
  pdev->dev.class_cb = class_cb;
  pdev->dev.usr_cb = usr_cb;  
  pdev->dev.usr_device = pDevice;    
  
  /* set USB OTG core params */
  DCD_Init(pdev , coreID);
 80033fa:	4620      	mov	r0, r4
 80033fc:	4641      	mov	r1, r8
  USB_OTG_BSP_Init(pdev);  
  
  USBD_DeInit(pdev);
  
  /*Register class and user callbacks */
  pdev->dev.class_cb = class_cb;
 80033fe:	f8c4 75e0 	str.w	r7, [r4, #1504]	; 0x5e0
  pdev->dev.usr_cb = usr_cb;  
 8003402:	f8c4 55e4 	str.w	r5, [r4, #1508]	; 0x5e4
  pdev->dev.usr_device = pDevice;    
 8003406:	f8c4 65e8 	str.w	r6, [r4, #1512]	; 0x5e8
  
  /* set USB OTG core params */
  DCD_Init(pdev , coreID);
 800340a:	f7ff fa7f 	bl	800290c <DCD_Init>
  
  /* Upon Init call usr callback */
  pdev->dev.usr_cb->Init();
 800340e:	f8d4 05e4 	ldr.w	r0, [r4, #1508]	; 0x5e4
 8003412:	6803      	ldr	r3, [r0, #0]
 8003414:	4798      	blx	r3
  
  /* Enable Interrupts */
  USB_OTG_BSP_EnableInterrupt(pdev);
 8003416:	4620      	mov	r0, r4
}
 8003418:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  
  /* Upon Init call usr callback */
  pdev->dev.usr_cb->Init();
  
  /* Enable Interrupts */
  USB_OTG_BSP_EnableInterrupt(pdev);
 800341c:	f000 bb3a 	b.w	8003a94 <USB_OTG_BSP_EnableInterrupt>

08003420 <USBD_DeInit>:
USBD_Status USBD_DeInit(USB_OTG_CORE_HANDLE *pdev)
{
  /* Software Init */
  
  return USBD_OK;
}
 8003420:	2000      	movs	r0, #0
 8003422:	4770      	bx	lr

08003424 <USBD_SetCfg>:
* @retval status
*/

USBD_Status USBD_SetCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
  pdev->dev.class_cb->Init(pdev, cfgidx); 
 8003424:	f8d0 35e0 	ldr.w	r3, [r0, #1504]	; 0x5e0
* @param  cfgidx: configuration index
* @retval status
*/

USBD_Status USBD_SetCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
 8003428:	b510      	push	{r4, lr}
 800342a:	4604      	mov	r4, r0
  pdev->dev.class_cb->Init(pdev, cfgidx); 
 800342c:	681a      	ldr	r2, [r3, #0]
 800342e:	4790      	blx	r2
  
  /* Upon set config call usr call back */
  pdev->dev.usr_cb->DeviceConfigured();
 8003430:	f8d4 05e4 	ldr.w	r0, [r4, #1508]	; 0x5e4
 8003434:	6883      	ldr	r3, [r0, #8]
 8003436:	4798      	blx	r3
  return USBD_OK; 
}
 8003438:	2000      	movs	r0, #0
 800343a:	bd10      	pop	{r4, pc}

0800343c <USBD_ClrCfg>:
* @param  cfgidx: configuration index
* @retval status: USBD_Status
*/
USBD_Status USBD_ClrCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
  pdev->dev.class_cb->DeInit(pdev, cfgidx);   
 800343c:	f8d0 25e0 	ldr.w	r2, [r0, #1504]	; 0x5e0
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_Status
*/
USBD_Status USBD_ClrCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
 8003440:	b508      	push	{r3, lr}
  pdev->dev.class_cb->DeInit(pdev, cfgidx);   
 8003442:	6853      	ldr	r3, [r2, #4]
 8003444:	4798      	blx	r3
  return USBD_OK;
}
 8003446:	2000      	movs	r0, #0
 8003448:	bd08      	pop	{r3, pc}
 800344a:	bf00      	nop

0800344c <USBD_CtlSendData>:
* @retval status
*/
USBD_Status  USBD_CtlSendData (USB_OTG_CORE_HANDLE  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 800344c:	4613      	mov	r3, r2
 800344e:	460a      	mov	r2, r1
  USBD_Status ret = USBD_OK;
  
  pdev->dev.in_ep[0].total_data_len = len;
  pdev->dev.in_ep[0].rem_data_len   = len;
  pdev->dev.device_state = USB_OTG_EP0_DATA_IN;
 8003450:	2102      	movs	r1, #2
* @retval status
*/
USBD_Status  USBD_CtlSendData (USB_OTG_CORE_HANDLE  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 8003452:	b510      	push	{r4, lr}
  USBD_Status ret = USBD_OK;
  
  pdev->dev.in_ep[0].total_data_len = len;
 8003454:	f8c0 3138 	str.w	r3, [r0, #312]	; 0x138
  pdev->dev.in_ep[0].rem_data_len   = len;
 8003458:	f8c0 3134 	str.w	r3, [r0, #308]	; 0x134
  pdev->dev.device_state = USB_OTG_EP0_DATA_IN;
 800345c:	f880 1111 	strb.w	r1, [r0, #273]	; 0x111

  DCD_EP_Tx (pdev, 0, pbuf, len);
 8003460:	2100      	movs	r1, #0
 8003462:	f7ff fb6f 	bl	8002b44 <DCD_EP_Tx>
 
  return ret;
}
 8003466:	2000      	movs	r0, #0
 8003468:	bd10      	pop	{r4, pc}
 800346a:	bf00      	nop

0800346c <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_Status  USBD_CtlContinueSendData (USB_OTG_CORE_HANDLE  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 800346c:	b510      	push	{r4, lr}
 800346e:	460c      	mov	r4, r1
 8003470:	4613      	mov	r3, r2
  USBD_Status ret = USBD_OK;
  
  DCD_EP_Tx (pdev, 0, pbuf, len);
 8003472:	2100      	movs	r1, #0
 8003474:	4622      	mov	r2, r4
 8003476:	f7ff fb65 	bl	8002b44 <DCD_EP_Tx>
  
  
  return ret;
}
 800347a:	2000      	movs	r0, #0
 800347c:	bd10      	pop	{r4, pc}
 800347e:	bf00      	nop

08003480 <USBD_CtlPrepareRx>:
* @retval status
*/
USBD_Status  USBD_CtlPrepareRx (USB_OTG_CORE_HANDLE  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
 8003480:	4613      	mov	r3, r2
 8003482:	460a      	mov	r2, r1
  USBD_Status ret = USBD_OK;
  
  pdev->dev.out_ep[0].total_data_len = len;
  pdev->dev.out_ep[0].rem_data_len   = len;
  pdev->dev.device_state = USB_OTG_EP0_DATA_OUT;
 8003484:	2103      	movs	r1, #3
* @retval status
*/
USBD_Status  USBD_CtlPrepareRx (USB_OTG_CORE_HANDLE  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
 8003486:	b510      	push	{r4, lr}
  USBD_Status ret = USBD_OK;
  
  pdev->dev.out_ep[0].total_data_len = len;
 8003488:	f8c0 3390 	str.w	r3, [r0, #912]	; 0x390
  pdev->dev.out_ep[0].rem_data_len   = len;
 800348c:	f8c0 338c 	str.w	r3, [r0, #908]	; 0x38c
  pdev->dev.device_state = USB_OTG_EP0_DATA_OUT;
 8003490:	f880 1111 	strb.w	r1, [r0, #273]	; 0x111
  
  DCD_EP_PrepareRx (pdev,
 8003494:	2100      	movs	r1, #0
 8003496:	f7ff fb2b 	bl	8002af0 <DCD_EP_PrepareRx>
                    pbuf,
                    len);
  

  return ret;
}
 800349a:	2000      	movs	r0, #0
 800349c:	bd10      	pop	{r4, pc}
 800349e:	bf00      	nop

080034a0 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_Status  USBD_CtlContinueRx (USB_OTG_CORE_HANDLE  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 80034a0:	b510      	push	{r4, lr}
 80034a2:	460c      	mov	r4, r1
 80034a4:	4613      	mov	r3, r2
  USBD_Status ret = USBD_OK;
  
  DCD_EP_PrepareRx (pdev,
 80034a6:	2100      	movs	r1, #0
 80034a8:	4622      	mov	r2, r4
 80034aa:	f7ff fb21 	bl	8002af0 <DCD_EP_PrepareRx>
                    0,                     
                    pbuf,                         
                    len);
  return ret;
}
 80034ae:	2000      	movs	r0, #0
 80034b0:	bd10      	pop	{r4, pc}
 80034b2:	bf00      	nop

080034b4 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 80034b4:	b538      	push	{r3, r4, r5, lr}
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
  DCD_EP_Tx (pdev,
 80034b6:	2100      	movs	r1, #0
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
 80034b8:	2504      	movs	r5, #4
*         send zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 80034ba:	4604      	mov	r4, r0
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
  DCD_EP_Tx (pdev,
 80034bc:	460a      	mov	r2, r1
 80034be:	460b      	mov	r3, r1
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
 80034c0:	f880 5111 	strb.w	r5, [r0, #273]	; 0x111
  DCD_EP_Tx (pdev,
 80034c4:	f7ff fb3e 	bl	8002b44 <DCD_EP_Tx>
             0,
             NULL, 
             0); 
  
  USB_OTG_EP0_OutStart(pdev);  
 80034c8:	4620      	mov	r0, r4
 80034ca:	f7ff f937 	bl	800273c <USB_OTG_EP0_OutStart>
  
  return ret;
}
 80034ce:	2000      	movs	r0, #0
 80034d0:	bd38      	pop	{r3, r4, r5, pc}
 80034d2:	bf00      	nop

080034d4 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 80034d4:	b538      	push	{r3, r4, r5, lr}
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
  DCD_EP_PrepareRx ( pdev,
 80034d6:	2100      	movs	r1, #0
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
 80034d8:	2505      	movs	r5, #5
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 80034da:	4604      	mov	r4, r0
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
  DCD_EP_PrepareRx ( pdev,
 80034dc:	460a      	mov	r2, r1
 80034de:	460b      	mov	r3, r1
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
 80034e0:	f880 5111 	strb.w	r5, [r0, #273]	; 0x111
  DCD_EP_PrepareRx ( pdev,
 80034e4:	f7ff fb04 	bl	8002af0 <DCD_EP_PrepareRx>
                    0,
                    NULL,
                    0);  

  USB_OTG_EP0_OutStart(pdev);
 80034e8:	4620      	mov	r0, r4
 80034ea:	f7ff f927 	bl	800273c <USB_OTG_EP0_OutStart>
  
  return ret;
}
 80034ee:	2000      	movs	r0, #0
 80034f0:	bd38      	pop	{r3, r4, r5, pc}
 80034f2:	bf00      	nop

080034f4 <USBD_GetRxCount>:
*         epnum: endpoint index
* @retval Rx Data blength
*/
uint16_t  USBD_GetRxCount (USB_OTG_CORE_HANDLE  *pdev , uint8_t epnum)
{
  return pdev->dev.out_ep[epnum].xfer_count;
 80034f4:	eb01 0281 	add.w	r2, r1, r1, lsl #2
 80034f8:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
}
 80034fc:	f8b1 0388 	ldrh.w	r0, [r1, #904]	; 0x388
 8003500:	4770      	bx	lr
 8003502:	bf00      	nop

08003504 <USBD_ParseSetupRequest>:
*/

void USBD_ParseSetupRequest( USB_OTG_CORE_HANDLE  *pdev,
                            USB_SETUP_REQ *req)
{
  req->bmRequest     = *(uint8_t *)  (pdev->dev.setup_packet);
 8003504:	f890 25c8 	ldrb.w	r2, [r0, #1480]	; 0x5c8
 8003508:	700a      	strb	r2, [r1, #0]
  req->bRequest      = *(uint8_t *)  (pdev->dev.setup_packet +  1);
 800350a:	f890 c5c9 	ldrb.w	ip, [r0, #1481]	; 0x5c9
 800350e:	f881 c001 	strb.w	ip, [r1, #1]
  req->wValue        = SWAPBYTE      (pdev->dev.setup_packet +  2);
 8003512:	f890 35cb 	ldrb.w	r3, [r0, #1483]	; 0x5cb
 8003516:	f890 25ca 	ldrb.w	r2, [r0, #1482]	; 0x5ca
 800351a:	021b      	lsls	r3, r3, #8
 800351c:	eb03 0c02 	add.w	ip, r3, r2
 8003520:	f8a1 c002 	strh.w	ip, [r1, #2]
  req->wIndex        = SWAPBYTE      (pdev->dev.setup_packet +  4);
 8003524:	f890 35cd 	ldrb.w	r3, [r0, #1485]	; 0x5cd
 8003528:	f890 25cc 	ldrb.w	r2, [r0, #1484]	; 0x5cc
 800352c:	021b      	lsls	r3, r3, #8
 800352e:	eb03 0c02 	add.w	ip, r3, r2
 8003532:	f8a1 c004 	strh.w	ip, [r1, #4]
  req->wLength       = SWAPBYTE      (pdev->dev.setup_packet +  6);
 8003536:	f890 35cf 	ldrb.w	r3, [r0, #1487]	; 0x5cf
 800353a:	f890 25ce 	ldrb.w	r2, [r0, #1486]	; 0x5ce
 800353e:	021b      	lsls	r3, r3, #8
 8003540:	eb03 0c02 	add.w	ip, r3, r2
 8003544:	fa1f f28c 	uxth.w	r2, ip
  
  pdev->dev.in_ep[0].ctl_data_len = req->wLength  ;
  pdev->dev.device_state = USB_OTG_EP0_SETUP;
 8003548:	2301      	movs	r3, #1
{
  req->bmRequest     = *(uint8_t *)  (pdev->dev.setup_packet);
  req->bRequest      = *(uint8_t *)  (pdev->dev.setup_packet +  1);
  req->wValue        = SWAPBYTE      (pdev->dev.setup_packet +  2);
  req->wIndex        = SWAPBYTE      (pdev->dev.setup_packet +  4);
  req->wLength       = SWAPBYTE      (pdev->dev.setup_packet +  6);
 800354a:	80ca      	strh	r2, [r1, #6]
  
  pdev->dev.in_ep[0].ctl_data_len = req->wLength  ;
 800354c:	f8c0 213c 	str.w	r2, [r0, #316]	; 0x13c
  pdev->dev.device_state = USB_OTG_EP0_SETUP;
 8003550:	f880 3111 	strb.w	r3, [r0, #273]	; 0x111
}
 8003554:	4770      	bx	lr
 8003556:	bf00      	nop

08003558 <USBD_CtlError>:
* @retval None
*/

void USBD_CtlError( USB_OTG_CORE_HANDLE  *pdev,
                            USB_SETUP_REQ *req)
{
 8003558:	b510      	push	{r4, lr}
  if((req->bmRequest & 0x80) == 0x80)
 800355a:	f991 3000 	ldrsb.w	r3, [r1]
 800355e:	2b00      	cmp	r3, #0
* @retval None
*/

void USBD_CtlError( USB_OTG_CORE_HANDLE  *pdev,
                            USB_SETUP_REQ *req)
{
 8003560:	4604      	mov	r4, r0
  if((req->bmRequest & 0x80) == 0x80)
 8003562:	db09      	blt.n	8003578 <USBD_CtlError+0x20>
  {
    DCD_EP_Stall(pdev , 0x80);
  }
  else 
  {
    if(req->wLength == 0)
 8003564:	88c9      	ldrh	r1, [r1, #6]
 8003566:	b139      	cbz	r1, 8003578 <USBD_CtlError+0x20>
    {
       DCD_EP_Stall(pdev , 0x80);
    }
    else
    {
      DCD_EP_Stall(pdev , 0);
 8003568:	2100      	movs	r1, #0
 800356a:	f7ff fb0d 	bl	8002b88 <DCD_EP_Stall>
    }
  }
  USB_OTG_EP0_OutStart(pdev);  
 800356e:	4620      	mov	r0, r4
}
 8003570:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    else
    {
      DCD_EP_Stall(pdev , 0);
    }
  }
  USB_OTG_EP0_OutStart(pdev);  
 8003574:	f7ff b8e2 	b.w	800273c <USB_OTG_EP0_OutStart>
  }
  else 
  {
    if(req->wLength == 0)
    {
       DCD_EP_Stall(pdev , 0x80);
 8003578:	2180      	movs	r1, #128	; 0x80
 800357a:	f7ff fb05 	bl	8002b88 <DCD_EP_Stall>
 800357e:	e7f6      	b.n	800356e <USBD_CtlError+0x16>

08003580 <USBD_StdEPReq>:
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdEPReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 8003580:	b538      	push	{r3, r4, r5, lr}
  uint8_t   ep_addr;
  USBD_Status ret = USBD_OK; 
  
  ep_addr  = LOBYTE(req->wIndex);   
  
  switch (req->bRequest) 
 8003582:	784b      	ldrb	r3, [r1, #1]
{
  
  uint8_t   ep_addr;
  USBD_Status ret = USBD_OK; 
  
  ep_addr  = LOBYTE(req->wIndex);   
 8003584:	790a      	ldrb	r2, [r1, #4]
  
  switch (req->bRequest) 
 8003586:	2b01      	cmp	r3, #1
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdEPReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 8003588:	460c      	mov	r4, r1
 800358a:	4605      	mov	r5, r0
  uint8_t   ep_addr;
  USBD_Status ret = USBD_OK; 
  
  ep_addr  = LOBYTE(req->wIndex);   
  
  switch (req->bRequest) 
 800358c:	d00e      	beq.n	80035ac <USBD_StdEPReq+0x2c>
 800358e:	d303      	bcc.n	8003598 <USBD_StdEPReq+0x18>
 8003590:	2b03      	cmp	r3, #3
 8003592:	d017      	beq.n	80035c4 <USBD_StdEPReq+0x44>
    
  default:
    break;
  }
  return ret;
}
 8003594:	2000      	movs	r0, #0
 8003596:	bd38      	pop	{r3, r4, r5, pc}
      break;    
    }
    break;
    
  case USB_REQ_GET_STATUS:                  
    switch (pdev->dev.device_status) 
 8003598:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 800359c:	2b02      	cmp	r3, #2
 800359e:	d009      	beq.n	80035b4 <USBD_StdEPReq+0x34>
 80035a0:	2b03      	cmp	r3, #3
 80035a2:	d03c      	beq.n	800361e <USBD_StdEPReq+0x9e>
                        (uint8_t *)&USBD_ep_status,
                        2);
      break;
      
    default:                         
       USBD_CtlError(pdev , req);
 80035a4:	f7ff ffd8 	bl	8003558 <USBD_CtlError>
    
  default:
    break;
  }
  return ret;
}
 80035a8:	2000      	movs	r0, #0
 80035aa:	bd38      	pop	{r3, r4, r5, pc}
    }
    break;
    
  case USB_REQ_CLEAR_FEATURE :
    
    switch (pdev->dev.device_status) 
 80035ac:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 80035b0:	2b02      	cmp	r3, #2
 80035b2:	d11f      	bne.n	80035f4 <USBD_StdEPReq+0x74>
    
  case USB_REQ_GET_STATUS:                  
    switch (pdev->dev.device_status) 
    {
    case USB_OTG_ADDRESSED:          
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80035b4:	2a00      	cmp	r2, #0
 80035b6:	d0ed      	beq.n	8003594 <USBD_StdEPReq+0x14>
 80035b8:	2a80      	cmp	r2, #128	; 0x80
 80035ba:	d0eb      	beq.n	8003594 <USBD_StdEPReq+0x14>
      {
        DCD_EP_Stall(pdev , ep_addr);
 80035bc:	4611      	mov	r1, r2
 80035be:	f7ff fae3 	bl	8002b88 <DCD_EP_Stall>
 80035c2:	e7e7      	b.n	8003594 <USBD_StdEPReq+0x14>
  switch (req->bRequest) 
  {
    
  case USB_REQ_SET_FEATURE :
    
    switch (pdev->dev.device_status) 
 80035c4:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 80035c8:	2b02      	cmp	r3, #2
 80035ca:	d0f3      	beq.n	80035b4 <USBD_StdEPReq+0x34>
 80035cc:	2b03      	cmp	r3, #3
 80035ce:	d1e9      	bne.n	80035a4 <USBD_StdEPReq+0x24>
        DCD_EP_Stall(pdev , ep_addr);
      }
      break;	
      
    case USB_OTG_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 80035d0:	884b      	ldrh	r3, [r1, #2]
 80035d2:	b92b      	cbnz	r3, 80035e0 <USBD_StdEPReq+0x60>
      {
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80035d4:	b122      	cbz	r2, 80035e0 <USBD_StdEPReq+0x60>
 80035d6:	2a80      	cmp	r2, #128	; 0x80
 80035d8:	d002      	beq.n	80035e0 <USBD_StdEPReq+0x60>
        { 
          DCD_EP_Stall(pdev , ep_addr);
 80035da:	4611      	mov	r1, r2
 80035dc:	f7ff fad4 	bl	8002b88 <DCD_EP_Stall>
          
        }
      }
      pdev->dev.class_cb->Setup (pdev, req);   
 80035e0:	f8d5 15e0 	ldr.w	r1, [r5, #1504]	; 0x5e0
 80035e4:	4628      	mov	r0, r5
 80035e6:	688a      	ldr	r2, [r1, #8]
 80035e8:	4621      	mov	r1, r4
 80035ea:	4790      	blx	r2
      USBD_CtlSendStatus(pdev);
 80035ec:	4628      	mov	r0, r5
 80035ee:	f7ff ff61 	bl	80034b4 <USBD_CtlSendStatus>
      
      break;
 80035f2:	e7cf      	b.n	8003594 <USBD_StdEPReq+0x14>
    }
    break;
    
  case USB_REQ_CLEAR_FEATURE :
    
    switch (pdev->dev.device_status) 
 80035f4:	2b03      	cmp	r3, #3
 80035f6:	d1d5      	bne.n	80035a4 <USBD_StdEPReq+0x24>
        DCD_EP_Stall(pdev , ep_addr);
      }
      break;	
      
    case USB_OTG_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 80035f8:	884b      	ldrh	r3, [r1, #2]
 80035fa:	2b00      	cmp	r3, #0
 80035fc:	d1ca      	bne.n	8003594 <USBD_StdEPReq+0x14>
      {
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80035fe:	b152      	cbz	r2, 8003616 <USBD_StdEPReq+0x96>
 8003600:	2a80      	cmp	r2, #128	; 0x80
 8003602:	d008      	beq.n	8003616 <USBD_StdEPReq+0x96>
        {        
          DCD_EP_ClrStall(pdev , ep_addr);
 8003604:	4611      	mov	r1, r2
 8003606:	f7ff fadf 	bl	8002bc8 <DCD_EP_ClrStall>
          pdev->dev.class_cb->Setup (pdev, req);
 800360a:	f8d5 15e0 	ldr.w	r1, [r5, #1504]	; 0x5e0
 800360e:	4628      	mov	r0, r5
 8003610:	688a      	ldr	r2, [r1, #8]
 8003612:	4621      	mov	r1, r4
 8003614:	4790      	blx	r2
        }
        USBD_CtlSendStatus(pdev);
 8003616:	4628      	mov	r0, r5
 8003618:	f7ff ff4c 	bl	80034b4 <USBD_CtlSendStatus>
 800361c:	e7ba      	b.n	8003594 <USBD_StdEPReq+0x14>
      break;	
      
    case USB_OTG_CONFIGURED:         
      
      
      if ((ep_addr & 0x80)== 0x80)
 800361e:	f012 0f80 	tst.w	r2, #128	; 0x80
 8003622:	d10e      	bne.n	8003642 <USBD_StdEPReq+0xc2>
          USBD_ep_status = 0x0000;  
        }
      }
      else if ((ep_addr & 0x80)== 0x00)
      {
        if(pdev->dev.out_ep[ep_addr].is_stall)
 8003624:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8003628:	eb00 03c2 	add.w	r3, r0, r2, lsl #3
 800362c:	f893 3372 	ldrb.w	r3, [r3, #882]	; 0x372
 8003630:	b98b      	cbnz	r3, 8003656 <USBD_StdEPReq+0xd6>
          USBD_ep_status = 0x0001;     
        }
        
        else 
        {
          USBD_ep_status = 0x0000;     
 8003632:	4a0b      	ldr	r2, [pc, #44]	; (8003660 <USBD_StdEPReq+0xe0>)
 8003634:	6013      	str	r3, [r2, #0]
        }      
      }
      USBD_CtlSendData (pdev,
 8003636:	4628      	mov	r0, r5
 8003638:	4909      	ldr	r1, [pc, #36]	; (8003660 <USBD_StdEPReq+0xe0>)
 800363a:	2202      	movs	r2, #2
 800363c:	f7ff ff06 	bl	800344c <USBD_CtlSendData>
                        (uint8_t *)&USBD_ep_status,
                        2);
      break;
 8003640:	e7a8      	b.n	8003594 <USBD_StdEPReq+0x14>
    case USB_OTG_CONFIGURED:         
      
      
      if ((ep_addr & 0x80)== 0x80)
      {
        if(pdev->dev.in_ep[ep_addr & 0x7F].is_stall)
 8003642:	f002 0e7f 	and.w	lr, r2, #127	; 0x7f
 8003646:	eb0e 0c8e 	add.w	ip, lr, lr, lsl #2
 800364a:	eb00 00cc 	add.w	r0, r0, ip, lsl #3
 800364e:	f890 311a 	ldrb.w	r3, [r0, #282]	; 0x11a
 8003652:	2b00      	cmp	r3, #0
 8003654:	d0ed      	beq.n	8003632 <USBD_StdEPReq+0xb2>
      }
      else if ((ep_addr & 0x80)== 0x00)
      {
        if(pdev->dev.out_ep[ep_addr].is_stall)
        {
          USBD_ep_status = 0x0001;     
 8003656:	4802      	ldr	r0, [pc, #8]	; (8003660 <USBD_StdEPReq+0xe0>)
 8003658:	2101      	movs	r1, #1
 800365a:	6001      	str	r1, [r0, #0]
 800365c:	e7eb      	b.n	8003636 <USBD_StdEPReq+0xb6>
 800365e:	bf00      	nop
 8003660:	20000e38 	.word	0x20000e38

08003664 <USBD_StdItfReq>:
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdItfReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 8003664:	b538      	push	{r3, r4, r5, lr}
  USBD_Status ret = USBD_OK; 
  
  switch (pdev->dev.device_status) 
 8003666:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 800366a:	2b03      	cmp	r3, #3
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdItfReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 800366c:	4604      	mov	r4, r0
 800366e:	460d      	mov	r5, r1
  USBD_Status ret = USBD_OK; 
  
  switch (pdev->dev.device_status) 
 8003670:	d003      	beq.n	800367a <USBD_StdItfReq+0x16>
       USBD_CtlError(pdev , req);
    }
    break;
    
  default:
     USBD_CtlError(pdev , req);
 8003672:	f7ff ff71 	bl	8003558 <USBD_CtlError>
    break;
  }
  return ret;
}
 8003676:	2000      	movs	r0, #0
 8003678:	bd38      	pop	{r3, r4, r5, pc}
  
  switch (pdev->dev.device_status) 
  {
  case USB_OTG_CONFIGURED:
    
    if (LOBYTE(req->wIndex) <= USBD_ITF_MAX_NUM) 
 800367a:	790a      	ldrb	r2, [r1, #4]
 800367c:	2a01      	cmp	r2, #1
 800367e:	d8f8      	bhi.n	8003672 <USBD_StdItfReq+0xe>
    {
      pdev->dev.class_cb->Setup (pdev, req); 
 8003680:	f8d0 25e0 	ldr.w	r2, [r0, #1504]	; 0x5e0
 8003684:	6893      	ldr	r3, [r2, #8]
 8003686:	4798      	blx	r3
      
      if((req->wLength == 0)&& (ret == USBD_OK))
 8003688:	88e8      	ldrh	r0, [r5, #6]
 800368a:	2800      	cmp	r0, #0
 800368c:	d1f3      	bne.n	8003676 <USBD_StdItfReq+0x12>
      {
         USBD_CtlSendStatus(pdev);
 800368e:	4620      	mov	r0, r4
 8003690:	f7ff ff10 	bl	80034b4 <USBD_CtlSendStatus>
 8003694:	e7ef      	b.n	8003676 <USBD_StdItfReq+0x12>
 8003696:	bf00      	nop

08003698 <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdDevReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 8003698:	b570      	push	{r4, r5, r6, lr}
  USBD_Status ret = USBD_OK;  
  
  switch (req->bRequest) 
 800369a:	784b      	ldrb	r3, [r1, #1]
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdDevReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 800369c:	b082      	sub	sp, #8
 800369e:	460c      	mov	r4, r1
 80036a0:	4605      	mov	r5, r0
  USBD_Status ret = USBD_OK;  
  
  switch (req->bRequest) 
 80036a2:	2b09      	cmp	r3, #9
 80036a4:	d813      	bhi.n	80036ce <USBD_StdDevReq+0x36>
 80036a6:	e8df f003 	tbb	[pc, r3]
 80036aa:	2a18      	.short	0x2a18
 80036ac:	57124012 	.word	0x57124012
 80036b0:	058b1274 	.word	0x058b1274
                           USB_SETUP_REQ *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 80036b4:	78a1      	ldrb	r1, [r4, #2]
 80036b6:	4e9b      	ldr	r6, [pc, #620]	; (8003924 <USBD_StdDevReq+0x28c>)
  
  if (cfgidx > USBD_CFG_MAX_NUM ) 
 80036b8:	2901      	cmp	r1, #1
                           USB_SETUP_REQ *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 80036ba:	7131      	strb	r1, [r6, #4]
  
  if (cfgidx > USBD_CFG_MAX_NUM ) 
 80036bc:	d807      	bhi.n	80036ce <USBD_StdDevReq+0x36>
  {            
     USBD_CtlError(pdev , req);                              
  } 
  else 
  {
    switch (pdev->dev.device_status) 
 80036be:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 80036c2:	2b02      	cmp	r3, #2
 80036c4:	f000 813f 	beq.w	8003946 <USBD_StdDevReq+0x2ae>
 80036c8:	2b03      	cmp	r3, #3
 80036ca:	f000 80cd 	beq.w	8003868 <USBD_StdDevReq+0x1d0>
  case USB_REQ_CLEAR_FEATURE:                                   
    USBD_ClrFeature (pdev , req);
    break;
    
  default:  
    USBD_CtlError(pdev , req);
 80036ce:	4621      	mov	r1, r4
 80036d0:	f7ff ff42 	bl	8003558 <USBD_CtlError>
    break;
  }
  
  return ret;
}
 80036d4:	2000      	movs	r0, #0
 80036d6:	b002      	add	sp, #8
 80036d8:	bd70      	pop	{r4, r5, r6, pc}
*/
static void USBD_GetStatus(USB_OTG_CORE_HANDLE  *pdev, 
                           USB_SETUP_REQ *req)
{
  
  switch (pdev->dev.device_status) 
 80036da:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 80036de:	1e99      	subs	r1, r3, #2
 80036e0:	2901      	cmp	r1, #1
 80036e2:	d8f4      	bhi.n	80036ce <USBD_StdDevReq+0x36>
  {
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    
    if (pdev->dev.DevRemoteWakeup) 
 80036e4:	f8d0 0114 	ldr.w	r0, [r0, #276]	; 0x114
 80036e8:	2800      	cmp	r0, #0
 80036ea:	d17e      	bne.n	80037ea <USBD_StdDevReq+0x152>
    {
      USBD_cfg_status = USB_CONFIG_SELF_POWERED | USB_CONFIG_REMOTE_WAKEUP;                                
    }
    else
    {
      USBD_cfg_status = USB_CONFIG_SELF_POWERED;   
 80036ec:	4b8d      	ldr	r3, [pc, #564]	; (8003924 <USBD_StdDevReq+0x28c>)
 80036ee:	2001      	movs	r0, #1
 80036f0:	60d8      	str	r0, [r3, #12]
    }
    
    USBD_CtlSendData (pdev, 
 80036f2:	4628      	mov	r0, r5
 80036f4:	498c      	ldr	r1, [pc, #560]	; (8003928 <USBD_StdDevReq+0x290>)
 80036f6:	2201      	movs	r2, #1
 80036f8:	f7ff fea8 	bl	800344c <USBD_CtlSendData>
 80036fc:	e7ea      	b.n	80036d4 <USBD_StdDevReq+0x3c>
* @retval status
*/
static void USBD_ClrFeature(USB_OTG_CORE_HANDLE  *pdev, 
                            USB_SETUP_REQ *req)
{
  switch (pdev->dev.device_status)
 80036fe:	f890 2112 	ldrb.w	r2, [r0, #274]	; 0x112
 8003702:	1e91      	subs	r1, r2, #2
 8003704:	2901      	cmp	r1, #1
 8003706:	d8e2      	bhi.n	80036ce <USBD_StdDevReq+0x36>
  {
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 8003708:	f8b4 c002 	ldrh.w	ip, [r4, #2]
 800370c:	f1bc 0f01 	cmp.w	ip, #1
 8003710:	d1e0      	bne.n	80036d4 <USBD_StdDevReq+0x3c>
    {
      pdev->dev.DevRemoteWakeup = 0; 
      pdev->dev.class_cb->Setup (pdev, req);   
 8003712:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
  {
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
    {
      pdev->dev.DevRemoteWakeup = 0; 
 8003716:	2200      	movs	r2, #0
      pdev->dev.class_cb->Setup (pdev, req);   
 8003718:	688b      	ldr	r3, [r1, #8]
  {
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
    {
      pdev->dev.DevRemoteWakeup = 0; 
 800371a:	f8c0 2114 	str.w	r2, [r0, #276]	; 0x114
      pdev->dev.class_cb->Setup (pdev, req);   
 800371e:	4621      	mov	r1, r4
 8003720:	4798      	blx	r3
      USBD_CtlSendStatus(pdev);
 8003722:	4628      	mov	r0, r5
 8003724:	f7ff fec6 	bl	80034b4 <USBD_CtlSendStatus>
 8003728:	e7d4      	b.n	80036d4 <USBD_StdDevReq+0x3c>
{

  USB_OTG_DCTL_TypeDef     dctl;
  uint8_t test_mode = 0;
 
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 800372a:	8863      	ldrh	r3, [r4, #2]
 800372c:	2b01      	cmp	r3, #1
 800372e:	f000 811c 	beq.w	800396a <USBD_StdDevReq+0x2d2>
    pdev->dev.DevRemoteWakeup = 1;  
    pdev->dev.class_cb->Setup (pdev, req);   
    USBD_CtlSendStatus(pdev);
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
 8003732:	2b02      	cmp	r3, #2
 8003734:	d1ce      	bne.n	80036d4 <USBD_StdDevReq+0x3c>
           ((req->wIndex & 0xFF) == 0))
 8003736:	88a3      	ldrh	r3, [r4, #4]
    pdev->dev.DevRemoteWakeup = 1;  
    pdev->dev.class_cb->Setup (pdev, req);   
    USBD_CtlSendStatus(pdev);
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
 8003738:	f013 0fff 	tst.w	r3, #255	; 0xff
 800373c:	d1ca      	bne.n	80036d4 <USBD_StdDevReq+0x3c>
           ((req->wIndex & 0xFF) == 0))
  {
    dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 800373e:	6901      	ldr	r1, [r0, #16]
    
    test_mode = req->wIndex >> 8;
    switch (test_mode) 
 8003740:	0a1c      	lsrs	r4, r3, #8
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
           ((req->wIndex & 0xFF) == 0))
  {
    dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 8003742:	684a      	ldr	r2, [r1, #4]
    
    test_mode = req->wIndex >> 8;
    switch (test_mode) 
 8003744:	1e63      	subs	r3, r4, #1
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
           ((req->wIndex & 0xFF) == 0))
  {
    dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 8003746:	4610      	mov	r0, r2
    
    test_mode = req->wIndex >> 8;
    switch (test_mode) 
 8003748:	2b04      	cmp	r3, #4
 800374a:	f200 80a4 	bhi.w	8003896 <USBD_StdDevReq+0x1fe>
 800374e:	e8df f003 	tbb	[pc, r3]
 8003752:	b1a7      	.short	0xb1a7
 8003754:	b6ac      	.short	0xb6ac
 8003756:	9e          	.byte	0x9e
 8003757:	00          	.byte	0x00
static void USBD_SetAddress(USB_OTG_CORE_HANDLE  *pdev, 
                            USB_SETUP_REQ *req)
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 8003758:	88a3      	ldrh	r3, [r4, #4]
 800375a:	2b00      	cmp	r3, #0
 800375c:	d140      	bne.n	80037e0 <USBD_StdDevReq+0x148>
 800375e:	88e2      	ldrh	r2, [r4, #6]
 8003760:	2a00      	cmp	r2, #0
 8003762:	d13d      	bne.n	80037e0 <USBD_StdDevReq+0x148>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    
    if (pdev->dev.device_status == USB_OTG_CONFIGURED) 
 8003764:	f890 e112 	ldrb.w	lr, [r0, #274]	; 0x112
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8003768:	8862      	ldrh	r2, [r4, #2]
    
    if (pdev->dev.device_status == USB_OTG_CONFIGURED) 
 800376a:	f1be 0f03 	cmp.w	lr, #3
 800376e:	d0ae      	beq.n	80036ce <USBD_StdDevReq+0x36>
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8003770:	f002 047f 	and.w	r4, r2, #127	; 0x7f
    {
      USBD_CtlError(pdev , req);
    } 
    else 
    {
      pdev->dev.device_address = dev_addr;
 8003774:	f880 4113 	strb.w	r4, [r0, #275]	; 0x113
      DCD_EP_SetAddress(pdev, dev_addr);               
 8003778:	4621      	mov	r1, r4
 800377a:	f7ff fa53 	bl	8002c24 <DCD_EP_SetAddress>
      USBD_CtlSendStatus(pdev);                         
 800377e:	4628      	mov	r0, r5
 8003780:	f7ff fe98 	bl	80034b4 <USBD_CtlSendStatus>
      
      if (dev_addr != 0) 
 8003784:	2c00      	cmp	r4, #0
 8003786:	f000 80ec 	beq.w	8003962 <USBD_StdDevReq+0x2ca>
      {
        pdev->dev.device_status  = USB_OTG_ADDRESSED;
 800378a:	2002      	movs	r0, #2
 800378c:	f885 0112 	strb.w	r0, [r5, #274]	; 0x112
 8003790:	e7a0      	b.n	80036d4 <USBD_StdDevReq+0x3c>
                               USB_SETUP_REQ *req)
{
  uint16_t len;
  uint8_t *pbuf;
  
  switch (req->wValue >> 8)
 8003792:	8862      	ldrh	r2, [r4, #2]
 8003794:	0a11      	lsrs	r1, r2, #8
 8003796:	1e4b      	subs	r3, r1, #1
 8003798:	2b06      	cmp	r3, #6
 800379a:	d898      	bhi.n	80036ce <USBD_StdDevReq+0x36>
 800379c:	a101      	add	r1, pc, #4	; (adr r1, 80037a4 <USBD_StdDevReq+0x10c>)
 800379e:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 80037a2:	bf00      	nop
 80037a4:	08003847 	.word	0x08003847
 80037a8:	08003809 	.word	0x08003809
 80037ac:	080037f3 	.word	0x080037f3
 80037b0:	080036cf 	.word	0x080036cf
 80037b4:	080036cf 	.word	0x080036cf
 80037b8:	080036cf 	.word	0x080036cf
 80037bc:	080036cf 	.word	0x080036cf
*/
static void USBD_GetConfig(USB_OTG_CORE_HANDLE  *pdev, 
                           USB_SETUP_REQ *req)
{
 
  if (req->wLength != 1) 
 80037c0:	88e2      	ldrh	r2, [r4, #6]
 80037c2:	2a01      	cmp	r2, #1
 80037c4:	d183      	bne.n	80036ce <USBD_StdDevReq+0x36>
  {                   
     USBD_CtlError(pdev , req);
  }
  else 
  {
    switch (pdev->dev.device_status )  
 80037c6:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 80037ca:	2b02      	cmp	r3, #2
 80037cc:	f000 80b7 	beq.w	800393e <USBD_StdDevReq+0x2a6>
 80037d0:	2b03      	cmp	r3, #3
 80037d2:	f47f af7c 	bne.w	80036ce <USBD_StdDevReq+0x36>
                        1);
      break;
      
    case USB_OTG_CONFIGURED:                   
      
      USBD_CtlSendData (pdev, 
 80037d6:	f500 7188 	add.w	r1, r0, #272	; 0x110
 80037da:	f7ff fe37 	bl	800344c <USBD_CtlSendData>
 80037de:	e779      	b.n	80036d4 <USBD_StdDevReq+0x3c>
      }
    }
  } 
  else 
  {
     USBD_CtlError(pdev , req);                        
 80037e0:	4628      	mov	r0, r5
 80037e2:	4621      	mov	r1, r4
 80037e4:	f7ff feb8 	bl	8003558 <USBD_CtlError>
 80037e8:	e774      	b.n	80036d4 <USBD_StdDevReq+0x3c>
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    
    if (pdev->dev.DevRemoteWakeup) 
    {
      USBD_cfg_status = USB_CONFIG_SELF_POWERED | USB_CONFIG_REMOTE_WAKEUP;                                
 80037ea:	494e      	ldr	r1, [pc, #312]	; (8003924 <USBD_StdDevReq+0x28c>)
 80037ec:	2203      	movs	r2, #3
 80037ee:	60ca      	str	r2, [r1, #12]
 80037f0:	e77f      	b.n	80036f2 <USBD_StdDevReq+0x5a>
    pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    pdev->dev.pConfig_descriptor = pbuf;    
    break;
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
 80037f2:	fa5f fc82 	uxtb.w	ip, r2
 80037f6:	f1bc 0f05 	cmp.w	ip, #5
 80037fa:	f63f af68 	bhi.w	80036ce <USBD_StdDevReq+0x36>
 80037fe:	e8df f00c 	tbb	[pc, ip]
 8003802:	8795      	.short	0x8795
 8003804:	636c757e 	.word	0x636c757e
      len = 8;
    }
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetConfigDescriptor(pdev->cfg.speed, &len);
 8003808:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
 800380c:	7880      	ldrb	r0, [r0, #2]
 800380e:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8003810:	f10d 0106 	add.w	r1, sp, #6
 8003814:	4798      	blx	r3
       (pdev->cfg.phy_itface  == USB_OTG_ULPI_PHY))
    {
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetOtherConfigDescriptor(pdev->cfg.speed, &len);
    }
#endif  
    pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8003816:	2202      	movs	r2, #2
 8003818:	7042      	strb	r2, [r0, #1]
      len = 8;
    }
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetConfigDescriptor(pdev->cfg.speed, &len);
 800381a:	4601      	mov	r1, r0
    {
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetOtherConfigDescriptor(pdev->cfg.speed, &len);
    }
#endif  
    pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    pdev->dev.pConfig_descriptor = pbuf;    
 800381c:	f8c5 05ec 	str.w	r0, [r5, #1516]	; 0x5ec
  default: 
     USBD_CtlError(pdev , req);
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
 8003820:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8003824:	2b00      	cmp	r3, #0
 8003826:	f43f af55 	beq.w	80036d4 <USBD_StdDevReq+0x3c>
 800382a:	88e2      	ldrh	r2, [r4, #6]
 800382c:	2a00      	cmp	r2, #0
 800382e:	f43f af51 	beq.w	80036d4 <USBD_StdDevReq+0x3c>
  {
    
    len = MIN(len , req->wLength);
 8003832:	429a      	cmp	r2, r3
 8003834:	bf38      	it	cc
 8003836:	4613      	movcc	r3, r2
    
    USBD_CtlSendData (pdev, 
 8003838:	4628      	mov	r0, r5
 800383a:	461a      	mov	r2, r3
  }
  
  if((len != 0)&& (req->wLength != 0))
  {
    
    len = MIN(len , req->wLength);
 800383c:	f8ad 3006 	strh.w	r3, [sp, #6]
    
    USBD_CtlSendData (pdev, 
 8003840:	f7ff fe04 	bl	800344c <USBD_CtlSendData>
 8003844:	e746      	b.n	80036d4 <USBD_StdDevReq+0x3c>
  uint8_t *pbuf;
  
  switch (req->wValue >> 8)
  {
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->dev.usr_device->GetDeviceDescriptor(pdev->cfg.speed, &len);
 8003846:	f8d0 35e8 	ldr.w	r3, [r0, #1512]	; 0x5e8
 800384a:	7880      	ldrb	r0, [r0, #2]
 800384c:	681a      	ldr	r2, [r3, #0]
 800384e:	f10d 0106 	add.w	r1, sp, #6
 8003852:	4790      	blx	r2
    if ((req->wLength == 64) ||( pdev->dev.device_status == USB_OTG_DEFAULT))  
 8003854:	88e2      	ldrh	r2, [r4, #6]
 8003856:	2a40      	cmp	r2, #64	; 0x40
  uint8_t *pbuf;
  
  switch (req->wValue >> 8)
  {
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->dev.usr_device->GetDeviceDescriptor(pdev->cfg.speed, &len);
 8003858:	4601      	mov	r1, r0
    if ((req->wLength == 64) ||( pdev->dev.device_status == USB_OTG_DEFAULT))  
 800385a:	d003      	beq.n	8003864 <USBD_StdDevReq+0x1cc>
 800385c:	f895 0112 	ldrb.w	r0, [r5, #274]	; 0x112
 8003860:	2801      	cmp	r0, #1
 8003862:	d1dd      	bne.n	8003820 <USBD_StdDevReq+0x188>
  default: 
     USBD_CtlError(pdev , req);
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
 8003864:	2308      	movs	r3, #8
 8003866:	e7e1      	b.n	800382c <USBD_StdDevReq+0x194>
         USBD_CtlSendStatus(pdev);
      }
      break;
      
    case USB_OTG_CONFIGURED:
      if (cfgidx == 0) 
 8003868:	2900      	cmp	r1, #0
 800386a:	f000 8089 	beq.w	8003980 <USBD_StdDevReq+0x2e8>
        pdev->dev.device_config = cfgidx;          
        USBD_ClrCfg(pdev , cfgidx);
        USBD_CtlSendStatus(pdev);
        
      } 
      else  if (cfgidx != pdev->dev.device_config) 
 800386e:	f890 1110 	ldrb.w	r1, [r0, #272]	; 0x110
 8003872:	2901      	cmp	r1, #1
 8003874:	d008      	beq.n	8003888 <USBD_StdDevReq+0x1f0>
      {
        /* Clear old configuration */
        USBD_ClrCfg(pdev , pdev->dev.device_config);
 8003876:	f7ff fde1 	bl	800343c <USBD_ClrCfg>
        
        /* set new configuration */
        pdev->dev.device_config = cfgidx;
 800387a:	7931      	ldrb	r1, [r6, #4]
        USBD_SetCfg(pdev , cfgidx);
 800387c:	4628      	mov	r0, r5
      {
        /* Clear old configuration */
        USBD_ClrCfg(pdev , pdev->dev.device_config);
        
        /* set new configuration */
        pdev->dev.device_config = cfgidx;
 800387e:	f885 1110 	strb.w	r1, [r5, #272]	; 0x110
        USBD_SetCfg(pdev , cfgidx);
 8003882:	f7ff fdcf 	bl	8003424 <USBD_SetCfg>
        USBD_CtlSendStatus(pdev);
 8003886:	4628      	mov	r0, r5
 8003888:	f7ff fe14 	bl	80034b4 <USBD_CtlSendStatus>
 800388c:	e722      	b.n	80036d4 <USBD_StdDevReq+0x3c>
    case 4: // TEST_PACKET
      dctl.b.tstctl = 4;
      break;
      
    case 5: // TEST_FORCE_ENABLE
      dctl.b.tstctl = 5;
 800388e:	2305      	movs	r3, #5
 8003890:	f363 1006 	bfi	r0, r3, #4, #3
 8003894:	4602      	mov	r2, r0
      break;
    }
    USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
 8003896:	604a      	str	r2, [r1, #4]
    USBD_CtlSendStatus(pdev);
 8003898:	4628      	mov	r0, r5
 800389a:	f7ff fe0b 	bl	80034b4 <USBD_CtlSendStatus>
 800389e:	e719      	b.n	80036d4 <USBD_StdDevReq+0x3c>
    
    test_mode = req->wIndex >> 8;
    switch (test_mode) 
    {
    case 1: // TEST_J
      dctl.b.tstctl = 1;
 80038a0:	2201      	movs	r2, #1
 80038a2:	f362 1006 	bfi	r0, r2, #4, #3
 80038a6:	4602      	mov	r2, r0
 80038a8:	e7f5      	b.n	8003896 <USBD_StdDevReq+0x1fe>
    case 2: // TEST_K	
      dctl.b.tstctl = 2;
      break;
      
    case 3: // TEST_SE0_NAK
      dctl.b.tstctl = 3;
 80038aa:	2403      	movs	r4, #3
 80038ac:	f364 1006 	bfi	r0, r4, #4, #3
 80038b0:	4602      	mov	r2, r0
 80038b2:	e7f0      	b.n	8003896 <USBD_StdDevReq+0x1fe>
    case 1: // TEST_J
      dctl.b.tstctl = 1;
      break;
      
    case 2: // TEST_K	
      dctl.b.tstctl = 2;
 80038b4:	2302      	movs	r3, #2
 80038b6:	f363 1006 	bfi	r0, r3, #4, #3
 80038ba:	4602      	mov	r2, r0
 80038bc:	e7eb      	b.n	8003896 <USBD_StdDevReq+0x1fe>
    case 3: // TEST_SE0_NAK
      dctl.b.tstctl = 3;
      break;
      
    case 4: // TEST_PACKET
      dctl.b.tstctl = 4;
 80038be:	2204      	movs	r2, #4
 80038c0:	f362 1006 	bfi	r0, r2, #4, #3
 80038c4:	4602      	mov	r2, r0
 80038c6:	e7e6      	b.n	8003896 <USBD_StdDevReq+0x1fe>
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->dev.usr_device->GetConfigurationStrDescriptor(pdev->cfg.speed, &len);
      break;
      
    case USBD_IDX_INTERFACE_STR:
      pbuf = pdev->dev.usr_device->GetInterfaceStrDescriptor(pdev->cfg.speed, &len);
 80038c8:	f8d0 15e8 	ldr.w	r1, [r0, #1512]	; 0x5e8
 80038cc:	7880      	ldrb	r0, [r0, #2]
 80038ce:	698a      	ldr	r2, [r1, #24]
 80038d0:	f10d 0106 	add.w	r1, sp, #6
 80038d4:	4790      	blx	r2
 80038d6:	4601      	mov	r1, r0
 80038d8:	e7a2      	b.n	8003820 <USBD_StdDevReq+0x188>
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->dev.usr_device->GetSerialStrDescriptor(pdev->cfg.speed, &len);
      break;
      
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->dev.usr_device->GetConfigurationStrDescriptor(pdev->cfg.speed, &len);
 80038da:	f8d0 35e8 	ldr.w	r3, [r0, #1512]	; 0x5e8
 80038de:	7880      	ldrb	r0, [r0, #2]
 80038e0:	695a      	ldr	r2, [r3, #20]
 80038e2:	f10d 0106 	add.w	r1, sp, #6
 80038e6:	4790      	blx	r2
 80038e8:	4601      	mov	r1, r0
 80038ea:	e799      	b.n	8003820 <USBD_StdDevReq+0x188>
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->dev.usr_device->GetProductStrDescriptor(pdev->cfg.speed, &len);
      break;
      
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->dev.usr_device->GetSerialStrDescriptor(pdev->cfg.speed, &len);
 80038ec:	f8d0 15e8 	ldr.w	r1, [r0, #1512]	; 0x5e8
 80038f0:	7880      	ldrb	r0, [r0, #2]
 80038f2:	690b      	ldr	r3, [r1, #16]
 80038f4:	f10d 0106 	add.w	r1, sp, #6
 80038f8:	4798      	blx	r3
 80038fa:	4601      	mov	r1, r0
 80038fc:	e790      	b.n	8003820 <USBD_StdDevReq+0x188>
    case USBD_IDX_MFC_STR:
      pbuf = pdev->dev.usr_device->GetManufacturerStrDescriptor(pdev->cfg.speed, &len);
      break;
      
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->dev.usr_device->GetProductStrDescriptor(pdev->cfg.speed, &len);
 80038fe:	f8d0 25e8 	ldr.w	r2, [r0, #1512]	; 0x5e8
 8003902:	7880      	ldrb	r0, [r0, #2]
 8003904:	68d3      	ldr	r3, [r2, #12]
 8003906:	f10d 0106 	add.w	r1, sp, #6
 800390a:	4798      	blx	r3
 800390c:	4601      	mov	r1, r0
 800390e:	e787      	b.n	8003820 <USBD_StdDevReq+0x188>
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->dev.usr_device->GetLangIDStrDescriptor(pdev->cfg.speed, &len);        
      break;
      
    case USBD_IDX_MFC_STR:
      pbuf = pdev->dev.usr_device->GetManufacturerStrDescriptor(pdev->cfg.speed, &len);
 8003910:	f8d0 15e8 	ldr.w	r1, [r0, #1512]	; 0x5e8
 8003914:	7880      	ldrb	r0, [r0, #2]
 8003916:	688a      	ldr	r2, [r1, #8]
 8003918:	f10d 0106 	add.w	r1, sp, #6
 800391c:	4790      	blx	r2
 800391e:	4601      	mov	r1, r0
 8003920:	e77e      	b.n	8003820 <USBD_StdDevReq+0x188>
 8003922:	bf00      	nop
 8003924:	20000e38 	.word	0x20000e38
 8003928:	20000e44 	.word	0x20000e44
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
    {
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->dev.usr_device->GetLangIDStrDescriptor(pdev->cfg.speed, &len);        
 800392c:	f8d0 35e8 	ldr.w	r3, [r0, #1512]	; 0x5e8
 8003930:	7880      	ldrb	r0, [r0, #2]
 8003932:	685a      	ldr	r2, [r3, #4]
 8003934:	f10d 0106 	add.w	r1, sp, #6
 8003938:	4790      	blx	r2
 800393a:	4601      	mov	r1, r0
 800393c:	e770      	b.n	8003820 <USBD_StdDevReq+0x188>
  {
    switch (pdev->dev.device_status )  
    {
    case USB_OTG_ADDRESSED:                     
      
      USBD_CtlSendData (pdev, 
 800393e:	4916      	ldr	r1, [pc, #88]	; (8003998 <USBD_StdDevReq+0x300>)
 8003940:	f7ff fd84 	bl	800344c <USBD_CtlSendData>
 8003944:	e6c6      	b.n	80036d4 <USBD_StdDevReq+0x3c>
  else 
  {
    switch (pdev->dev.device_status) 
    {
    case USB_OTG_ADDRESSED:
      if (cfgidx) 
 8003946:	2900      	cmp	r1, #0
 8003948:	d09e      	beq.n	8003888 <USBD_StdDevReq+0x1f0>
      {                                			   							   							   				
        pdev->dev.device_config = cfgidx;
 800394a:	2101      	movs	r1, #1
        pdev->dev.device_status = USB_OTG_CONFIGURED;
 800394c:	2303      	movs	r3, #3
    switch (pdev->dev.device_status) 
    {
    case USB_OTG_ADDRESSED:
      if (cfgidx) 
      {                                			   							   							   				
        pdev->dev.device_config = cfgidx;
 800394e:	f880 1110 	strb.w	r1, [r0, #272]	; 0x110
        pdev->dev.device_status = USB_OTG_CONFIGURED;
 8003952:	f880 3112 	strb.w	r3, [r0, #274]	; 0x112
        USBD_SetCfg(pdev , cfgidx);
 8003956:	f7ff fd65 	bl	8003424 <USBD_SetCfg>
        USBD_CtlSendStatus(pdev);
 800395a:	4628      	mov	r0, r5
 800395c:	f7ff fdaa 	bl	80034b4 <USBD_CtlSendStatus>
 8003960:	e6b8      	b.n	80036d4 <USBD_StdDevReq+0x3c>
      {
        pdev->dev.device_status  = USB_OTG_ADDRESSED;
      } 
      else 
      {
        pdev->dev.device_status  = USB_OTG_DEFAULT; 
 8003962:	2101      	movs	r1, #1
 8003964:	f885 1112 	strb.w	r1, [r5, #274]	; 0x112
 8003968:	e6b4      	b.n	80036d4 <USBD_StdDevReq+0x3c>
  uint8_t test_mode = 0;
 
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
  {
    pdev->dev.DevRemoteWakeup = 1;  
    pdev->dev.class_cb->Setup (pdev, req);   
 800396a:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
  USB_OTG_DCTL_TypeDef     dctl;
  uint8_t test_mode = 0;
 
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
  {
    pdev->dev.DevRemoteWakeup = 1;  
 800396e:	f8c0 3114 	str.w	r3, [r0, #276]	; 0x114
    pdev->dev.class_cb->Setup (pdev, req);   
 8003972:	688a      	ldr	r2, [r1, #8]
 8003974:	4621      	mov	r1, r4
 8003976:	4790      	blx	r2
    USBD_CtlSendStatus(pdev);
 8003978:	4628      	mov	r0, r5
        USBD_ClrCfg(pdev , pdev->dev.device_config);
        
        /* set new configuration */
        pdev->dev.device_config = cfgidx;
        USBD_SetCfg(pdev , cfgidx);
        USBD_CtlSendStatus(pdev);
 800397a:	f7ff fd9b 	bl	80034b4 <USBD_CtlSendStatus>
 800397e:	e6a9      	b.n	80036d4 <USBD_StdDevReq+0x3c>
      break;
      
    case USB_OTG_CONFIGURED:
      if (cfgidx == 0) 
      {                           
        pdev->dev.device_status = USB_OTG_ADDRESSED;
 8003980:	2202      	movs	r2, #2
 8003982:	f880 2112 	strb.w	r2, [r0, #274]	; 0x112
        pdev->dev.device_config = cfgidx;          
 8003986:	f880 1110 	strb.w	r1, [r0, #272]	; 0x110
        USBD_ClrCfg(pdev , cfgidx);
 800398a:	f7ff fd57 	bl	800343c <USBD_ClrCfg>
        USBD_CtlSendStatus(pdev);
 800398e:	4628      	mov	r0, r5
 8003990:	f7ff fd90 	bl	80034b4 <USBD_CtlSendStatus>
 8003994:	e69e      	b.n	80036d4 <USBD_StdDevReq+0x3c>
 8003996:	bf00      	nop
 8003998:	20000e40 	.word	0x20000e40

0800399c <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 800399c:	b430      	push	{r4, r5}
  uint8_t idx = 0;
  
  if (desc != NULL) 
 800399e:	b1f8      	cbz	r0, 80039e0 <USBD_GetString+0x44>
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != NULL) 
 80039a0:	7803      	ldrb	r3, [r0, #0]
 80039a2:	2b00      	cmp	r3, #0
 80039a4:	d01e      	beq.n	80039e4 <USBD_GetString+0x48>
 80039a6:	4604      	mov	r4, r0
 80039a8:	2300      	movs	r3, #0
 80039aa:	f814 5f01 	ldrb.w	r5, [r4, #1]!
    {
        len++;
 80039ae:	3301      	adds	r3, #1
 80039b0:	b2db      	uxtb	r3, r3
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != NULL) 
 80039b2:	2d00      	cmp	r5, #0
 80039b4:	d1f9      	bne.n	80039aa <USBD_GetString+0xe>
 80039b6:	005c      	lsls	r4, r3, #1
 80039b8:	1ca3      	adds	r3, r4, #2
 80039ba:	b2dc      	uxtb	r4, r3
{
  uint8_t idx = 0;
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
 80039bc:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 80039be:	2203      	movs	r2, #3
  uint8_t idx = 0;
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
 80039c0:	700c      	strb	r4, [r1, #0]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 80039c2:	704a      	strb	r2, [r1, #1]
    
    while (*desc != NULL) 
 80039c4:	7802      	ldrb	r2, [r0, #0]
 80039c6:	b15a      	cbz	r2, 80039e0 <USBD_GetString+0x44>
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 80039c8:	2302      	movs	r3, #2
    
    while (*desc != NULL) 
    {
      unicode[idx++] = *desc++;
      unicode[idx++] =  0x00;
 80039ca:	2500      	movs	r5, #0
 80039cc:	1c5c      	adds	r4, r3, #1
 80039ce:	b2e4      	uxtb	r4, r4
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
    
    while (*desc != NULL) 
    {
      unicode[idx++] = *desc++;
 80039d0:	54ca      	strb	r2, [r1, r3]
      unicode[idx++] =  0x00;
 80039d2:	550d      	strb	r5, [r1, r4]
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
    
    while (*desc != NULL) 
 80039d4:	f810 2f01 	ldrb.w	r2, [r0, #1]!
    {
      unicode[idx++] = *desc++;
      unicode[idx++] =  0x00;
 80039d8:	3302      	adds	r3, #2
 80039da:	b2db      	uxtb	r3, r3
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
    
    while (*desc != NULL) 
 80039dc:	2a00      	cmp	r2, #0
 80039de:	d1f5      	bne.n	80039cc <USBD_GetString+0x30>
    {
      unicode[idx++] = *desc++;
      unicode[idx++] =  0x00;
    }
  } 
}
 80039e0:	bc30      	pop	{r4, r5}
 80039e2:	4770      	bx	lr
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != NULL) 
 80039e4:	2402      	movs	r4, #2
 80039e6:	4623      	mov	r3, r4
 80039e8:	e7e8      	b.n	80039bc <USBD_GetString+0x20>
 80039ea:	bf00      	nop

080039ec <USB_OTG_BSP_ConfigVBUS>:
#include "stm32f4xx_conf.h"


void USB_OTG_BSP_ConfigVBUS(USB_OTG_CORE_HANDLE *pdev) {

}
 80039ec:	4770      	bx	lr

080039ee <USB_OTG_BSP_DriveVBUS>:

void USB_OTG_BSP_DriveVBUS(USB_OTG_CORE_HANDLE *pdev,uint8_t state) {

}
 80039ee:	4770      	bx	lr

080039f0 <USB_OTG_BSP_Init>:
* @param  None
* @retval None
*/

void USB_OTG_BSP_Init(USB_OTG_CORE_HANDLE *pdev)
{
 80039f0:	b537      	push	{r0, r1, r2, r4, r5, lr}
#endif


 #ifdef USE_USB_OTG_FS

  RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOA , ENABLE);
 80039f2:	2001      	movs	r0, #1
 80039f4:	4601      	mov	r1, r0
 80039f6:	f7fd fc93 	bl	8001320 <RCC_AHB1PeriphClockCmd>

  /* Configure SOF VBUS ID DM DP Pins */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8  |
 80039fa:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
 80039fe:	9300      	str	r3, [sp, #0]
    GPIO_Pin_9  |
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8003a00:	2302      	movs	r3, #2
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8  |
    GPIO_Pin_9  |
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8003a02:	2503      	movs	r5, #3
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8003a04:	f88d 3004 	strb.w	r3, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8003a08:	4669      	mov	r1, sp
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8003a0a:	3b02      	subs	r3, #2
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8003a0c:	4820      	ldr	r0, [pc, #128]	; (8003a90 <USB_OTG_BSP_Init+0xa0>)
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8003a0e:	f88d 3006 	strb.w	r3, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 8003a12:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8  |
    GPIO_Pin_9  |
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8003a16:	f88d 5005 	strb.w	r5, [sp, #5]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8003a1a:	f7fd fec1 	bl	80017a0 <GPIO_Init>

  GPIO_PinAFConfig(GPIOA,GPIO_PinSource8,GPIO_AF_OTG1_FS) ;
 8003a1e:	2108      	movs	r1, #8
 8003a20:	220a      	movs	r2, #10
 8003a22:	481b      	ldr	r0, [pc, #108]	; (8003a90 <USB_OTG_BSP_Init+0xa0>)
 8003a24:	f7fd ffb4 	bl	8001990 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_OTG1_FS) ;
 8003a28:	2109      	movs	r1, #9
 8003a2a:	220a      	movs	r2, #10
 8003a2c:	4818      	ldr	r0, [pc, #96]	; (8003a90 <USB_OTG_BSP_Init+0xa0>)
 8003a2e:	f7fd ffaf 	bl	8001990 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource11,GPIO_AF_OTG1_FS) ;
 8003a32:	210b      	movs	r1, #11
 8003a34:	220a      	movs	r2, #10
 8003a36:	4816      	ldr	r0, [pc, #88]	; (8003a90 <USB_OTG_BSP_Init+0xa0>)
 8003a38:	f7fd ffaa 	bl	8001990 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;
 8003a3c:	220a      	movs	r2, #10
 8003a3e:	210c      	movs	r1, #12
 8003a40:	4813      	ldr	r0, [pc, #76]	; (8003a90 <USB_OTG_BSP_Init+0xa0>)
 8003a42:	f7fd ffa5 	bl	8001990 <GPIO_PinAFConfig>

  /* this for ID line debug */


  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 8003a46:	2401      	movs	r4, #1
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;

  /* this for ID line debug */


  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
 8003a48:	f44f 6380 	mov.w	r3, #1024	; 0x400
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8003a4c:	4669      	mov	r1, sp
 8003a4e:	4810      	ldr	r0, [pc, #64]	; (8003a90 <USB_OTG_BSP_Init+0xa0>)
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;

  /* this for ID line debug */


  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
 8003a50:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 8003a52:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
 8003a56:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8003a5a:	f88d 5005 	strb.w	r5, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8003a5e:	f7fd fe9f 	bl	80017a0 <GPIO_Init>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_OTG1_FS) ;
 8003a62:	210a      	movs	r1, #10
 8003a64:	460a      	mov	r2, r1
 8003a66:	480a      	ldr	r0, [pc, #40]	; (8003a90 <USB_OTG_BSP_Init+0xa0>)
 8003a68:	f7fd ff92 	bl	8001990 <GPIO_PinAFConfig>

  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 8003a6c:	4621      	mov	r1, r4
 8003a6e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8003a72:	f7fd fc8d 	bl	8001390 <RCC_APB2PeriphClockCmd>
  RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_OTG_FS, ENABLE) ;
 8003a76:	2080      	movs	r0, #128	; 0x80
 8003a78:	4621      	mov	r1, r4
 8003a7a:	f7fd fc5f 	bl	800133c <RCC_AHB2PeriphClockCmd>

 #endif //USB_OTG_HS


  /* enable the PWR clock */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
 8003a7e:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8003a82:	4621      	mov	r1, r4
 8003a84:	f7fd fcbc 	bl	8001400 <RCC_APB1PeriphResetCmd>
  NVIC_Init(&NVIC_InitStructure);

  EXTI_ClearITPendingBit(EXTI_Line20);
#endif

  EXTI_ClearITPendingBit(EXTI_Line0);
 8003a88:	4620      	mov	r0, r4
 8003a8a:	f7fd fdf7 	bl	800167c <EXTI_ClearITPendingBit>
}
 8003a8e:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8003a90:	40020000 	.word	0x40020000

08003a94 <USB_OTG_BSP_EnableInterrupt>:
*         Enabele USB Global interrupt
* @param  None
* @retval None
*/
void USB_OTG_BSP_EnableInterrupt(USB_OTG_CORE_HANDLE *pdev)
{
 8003a94:	b507      	push	{r0, r1, r2, lr}
  NVIC_InitTypeDef NVIC_InitStructure;

  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
 8003a96:	f44f 60c0 	mov.w	r0, #1536	; 0x600
 8003a9a:	f000 f8f5 	bl	8003c88 <NVIC_PriorityGroupConfig>
#ifdef USE_USB_OTG_HS
  NVIC_InitStructure.NVIC_IRQChannel = OTG_HS_IRQn;
#else
  NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;
 8003a9e:	2343      	movs	r3, #67	; 0x43
 8003aa0:	f88d 3004 	strb.w	r3, [sp, #4]
#endif
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 11;
 8003aa4:	3b38      	subs	r3, #56	; 0x38
 8003aa6:	f88d 3005 	strb.w	r3, [sp, #5]
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
 8003aaa:	3b08      	subs	r3, #8
 8003aac:	f88d 3006 	strb.w	r3, [sp, #6]
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
 8003ab0:	a801      	add	r0, sp, #4
#else
  NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;
#endif
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 11;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8003ab2:	3b02      	subs	r3, #2
 8003ab4:	f88d 3007 	strb.w	r3, [sp, #7]
  NVIC_Init(&NVIC_InitStructure);
 8003ab8:	f000 f8f0 	bl	8003c9c <NVIC_Init>
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 11;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
#endif
}
 8003abc:	bd0e      	pop	{r1, r2, r3, pc}

08003abe <USB_OTG_BSP_uDelay>:
* @retval None
*/
void USB_OTG_BSP_uDelay (const uint32_t usec)
{
  uint32_t count = 0;
  const uint32_t utime = (120 * usec / 7);
 8003abe:	2378      	movs	r3, #120	; 0x78
 8003ac0:	2207      	movs	r2, #7
 8003ac2:	4343      	muls	r3, r0
 8003ac4:	fbb3 f3f2 	udiv	r3, r3, r2
* @param  usec : Value of delay required in micro sec
* @retval None
*/
void USB_OTG_BSP_uDelay (const uint32_t usec)
{
  uint32_t count = 0;
 8003ac8:	3a07      	subs	r2, #7
  const uint32_t utime = (120 * usec / 7);
  do
  {
    if ( ++count > utime )
 8003aca:	3201      	adds	r2, #1
 8003acc:	429a      	cmp	r2, r3
 8003ace:	d9fc      	bls.n	8003aca <USB_OTG_BSP_uDelay+0xc>
    {
      return ;
    }
  }
  while (1);
}
 8003ad0:	4770      	bx	lr

08003ad2 <USB_OTG_BSP_mDelay>:
* @param  msec : Value of delay required in milli sec
* @retval None
*/
void USB_OTG_BSP_mDelay (const uint32_t msec)
{
  USB_OTG_BSP_uDelay(msec * 1000);
 8003ad2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8003ad6:	4358      	muls	r0, r3
 8003ad8:	e7f1      	b.n	8003abe <USB_OTG_BSP_uDelay>
 8003ada:	bf00      	nop

08003adc <VCP_Init>:
 * @param  None
 * @retval Result of the opeartion (USBD_OK in all cases)
 */
static uint16_t VCP_Init(void) {
	return USBD_OK;
}
 8003adc:	2000      	movs	r0, #0
 8003ade:	4770      	bx	lr

08003ae0 <VCP_DeInit>:
 * @param  None
 * @retval Result of the opeartion (USBD_OK in all cases)
 */
static uint16_t VCP_DeInit(void) {
	return USBD_OK;
}
 8003ae0:	2000      	movs	r0, #0
 8003ae2:	4770      	bx	lr

08003ae4 <VCP_Ctrl>:
 * @param  Buf: Buffer containing command data (request parameters)
 * @param  Len: Number of data to be sent (in bytes)
 * @retval Result of the opeartion (USBD_OK in all cases)
 */
static uint16_t VCP_Ctrl(uint32_t Cmd, uint8_t* Buf, uint32_t Len) {
	switch (Cmd) {
 8003ae4:	2821      	cmp	r0, #33	; 0x21
 8003ae6:	d10f      	bne.n	8003b08 <VCP_Ctrl+0x24>
	case SET_LINE_CODING:
		/* Not  needed for this driver */
		break;

	case GET_LINE_CODING:
		Buf[0] = (uint8_t) (linecoding.bitrate);
 8003ae8:	4b08      	ldr	r3, [pc, #32]	; (8003b0c <VCP_Ctrl+0x28>)
 8003aea:	681a      	ldr	r2, [r3, #0]
 8003aec:	700a      	strb	r2, [r1, #0]
		Buf[1] = (uint8_t) (linecoding.bitrate >> 8);
 8003aee:	681a      	ldr	r2, [r3, #0]
 8003af0:	0a12      	lsrs	r2, r2, #8
 8003af2:	704a      	strb	r2, [r1, #1]
		Buf[2] = (uint8_t) (linecoding.bitrate >> 16);
 8003af4:	885a      	ldrh	r2, [r3, #2]
 8003af6:	708a      	strb	r2, [r1, #2]
		Buf[3] = (uint8_t) (linecoding.bitrate >> 24);
 8003af8:	78da      	ldrb	r2, [r3, #3]
 8003afa:	70ca      	strb	r2, [r1, #3]
		Buf[4] = linecoding.format;
 8003afc:	791a      	ldrb	r2, [r3, #4]
 8003afe:	710a      	strb	r2, [r1, #4]
		Buf[5] = linecoding.paritytype;
 8003b00:	795a      	ldrb	r2, [r3, #5]
 8003b02:	714a      	strb	r2, [r1, #5]
		Buf[6] = linecoding.datatype;
 8003b04:	799b      	ldrb	r3, [r3, #6]
 8003b06:	718b      	strb	r3, [r1, #6]
	default:
		break;
	}

	return USBD_OK;
}
 8003b08:	2000      	movs	r0, #0
 8003b0a:	4770      	bx	lr
 8003b0c:	20000138 	.word	0x20000138

08003b10 <VCP_DataTx>:
 *         this function.
 * @param  Buf: Buffer of data to be sent
 * @param  Len: Number of data to be sent (in bytes)
 * @retval Result of the opeartion: USBD_OK if all operations are OK else VCP_FAIL
 */
static uint16_t VCP_DataTx(uint8_t* Buf, uint32_t Len) {
 8003b10:	b570      	push	{r4, r5, r6, lr}
	uint32_t i = 0;
 8003b12:	2300      	movs	r3, #0
	while (i < Len) {
 8003b14:	e00c      	b.n	8003b30 <VCP_DataTx+0x20>
		APP_Rx_Buffer[APP_Rx_ptr_in] = *(Buf + i);
 8003b16:	4a08      	ldr	r2, [pc, #32]	; (8003b38 <VCP_DataTx+0x28>)
 8003b18:	5cc6      	ldrb	r6, [r0, r3]
 8003b1a:	6814      	ldr	r4, [r2, #0]
 8003b1c:	4d07      	ldr	r5, [pc, #28]	; (8003b3c <VCP_DataTx+0x2c>)
 8003b1e:	552e      	strb	r6, [r5, r4]
		APP_Rx_ptr_in++;
 8003b20:	3401      	adds	r4, #1
		i++;
 8003b22:	3301      	adds	r3, #1
		/* To avoid buffer overflow */
		if (APP_Rx_ptr_in == APP_RX_DATA_SIZE) {
 8003b24:	f5b4 6f00 	cmp.w	r4, #2048	; 0x800
 */
static uint16_t VCP_DataTx(uint8_t* Buf, uint32_t Len) {
	uint32_t i = 0;
	while (i < Len) {
		APP_Rx_Buffer[APP_Rx_ptr_in] = *(Buf + i);
		APP_Rx_ptr_in++;
 8003b28:	6014      	str	r4, [r2, #0]
		i++;
		/* To avoid buffer overflow */
		if (APP_Rx_ptr_in == APP_RX_DATA_SIZE) {
 8003b2a:	d101      	bne.n	8003b30 <VCP_DataTx+0x20>
			APP_Rx_ptr_in = 0;
 8003b2c:	2400      	movs	r4, #0
 8003b2e:	6014      	str	r4, [r2, #0]
 * @param  Len: Number of data to be sent (in bytes)
 * @retval Result of the opeartion: USBD_OK if all operations are OK else VCP_FAIL
 */
static uint16_t VCP_DataTx(uint8_t* Buf, uint32_t Len) {
	uint32_t i = 0;
	while (i < Len) {
 8003b30:	428b      	cmp	r3, r1
 8003b32:	d1f0      	bne.n	8003b16 <VCP_DataTx+0x6>
			APP_Rx_ptr_in = 0;
		}
	}

	return USBD_OK;
}
 8003b34:	2000      	movs	r0, #0
 8003b36:	bd70      	pop	{r4, r5, r6, pc}
 8003b38:	20000e2c 	.word	0x20000e2c
 8003b3c:	200021d0 	.word	0x200021d0

08003b40 <VCP_DataRx>:
		APP_Tx_Buffer[APP_tx_ptr_head] = *(Buf + i);
		APP_tx_ptr_head++;
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
			APP_tx_ptr_head = 0;

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8003b40:	4b0c      	ldr	r3, [pc, #48]	; (8003b74 <VCP_DataRx+0x34>)
#define APP_TX_BUF_SIZE 128
uint8_t APP_Tx_Buffer[APP_TX_BUF_SIZE];
uint32_t APP_tx_ptr_head;
uint32_t APP_tx_ptr_tail;

static uint16_t VCP_DataRx(uint8_t* Buf, uint32_t Len) {
 8003b42:	b5f0      	push	{r4, r5, r6, r7, lr}
		APP_Tx_Buffer[APP_tx_ptr_head] = *(Buf + i);
		APP_tx_ptr_head++;
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
			APP_tx_ptr_head = 0;

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8003b44:	681d      	ldr	r5, [r3, #0]
uint32_t APP_tx_ptr_tail;

static uint16_t VCP_DataRx(uint8_t* Buf, uint32_t Len) {
	uint32_t i;

	for (i = 0; i < Len; i++) {
 8003b46:	2300      	movs	r3, #0
 8003b48:	e00e      	b.n	8003b68 <VCP_DataRx+0x28>
		APP_Tx_Buffer[APP_tx_ptr_head] = *(Buf + i);
 8003b4a:	4a0b      	ldr	r2, [pc, #44]	; (8003b78 <VCP_DataRx+0x38>)
 8003b4c:	5cc7      	ldrb	r7, [r0, r3]
 8003b4e:	6814      	ldr	r4, [r2, #0]
 8003b50:	4e0a      	ldr	r6, [pc, #40]	; (8003b7c <VCP_DataRx+0x3c>)
 8003b52:	5537      	strb	r7, [r6, r4]
		APP_tx_ptr_head++;
 8003b54:	3401      	adds	r4, #1
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
 8003b56:	2c80      	cmp	r4, #128	; 0x80
static uint16_t VCP_DataRx(uint8_t* Buf, uint32_t Len) {
	uint32_t i;

	for (i = 0; i < Len; i++) {
		APP_Tx_Buffer[APP_tx_ptr_head] = *(Buf + i);
		APP_tx_ptr_head++;
 8003b58:	6014      	str	r4, [r2, #0]
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
 8003b5a:	d101      	bne.n	8003b60 <VCP_DataRx+0x20>
			APP_tx_ptr_head = 0;
 8003b5c:	3c80      	subs	r4, #128	; 0x80
 8003b5e:	6014      	str	r4, [r2, #0]

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8003b60:	6812      	ldr	r2, [r2, #0]
 8003b62:	42aa      	cmp	r2, r5
 8003b64:	d004      	beq.n	8003b70 <VCP_DataRx+0x30>
uint32_t APP_tx_ptr_tail;

static uint16_t VCP_DataRx(uint8_t* Buf, uint32_t Len) {
	uint32_t i;

	for (i = 0; i < Len; i++) {
 8003b66:	3301      	adds	r3, #1
 8003b68:	428b      	cmp	r3, r1
 8003b6a:	d1ee      	bne.n	8003b4a <VCP_DataRx+0xa>

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
			return USBD_FAIL;
	}

	return USBD_OK;
 8003b6c:	2000      	movs	r0, #0
 8003b6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		APP_tx_ptr_head++;
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
			APP_tx_ptr_head = 0;

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
			return USBD_FAIL;
 8003b70:	2002      	movs	r0, #2
	}

	return USBD_OK;
}
 8003b72:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003b74:	20002a84 	.word	0x20002a84
 8003b78:	20002a98 	.word	0x20002a98
 8003b7c:	20002a04 	.word	0x20002a04

08003b80 <VCP_put_char>:
 *         Sends one char over the USB serial link.
 * @param  buf: char to be sent
 * @retval none
 */

void VCP_put_char(uint8_t buf) {
 8003b80:	b507      	push	{r0, r1, r2, lr}
 8003b82:	ab02      	add	r3, sp, #8
	VCP_DataTx(&buf, 1);
 8003b84:	2101      	movs	r1, #1
 *         Sends one char over the USB serial link.
 * @param  buf: char to be sent
 * @retval none
 */

void VCP_put_char(uint8_t buf) {
 8003b86:	f803 0d01 	strb.w	r0, [r3, #-1]!
	VCP_DataTx(&buf, 1);
 8003b8a:	4618      	mov	r0, r3
 8003b8c:	f7ff ffc0 	bl	8003b10 <VCP_DataTx>
}
 8003b90:	bd0e      	pop	{r1, r2, r3, pc}

08003b92 <VCP_send_str>:

void VCP_send_str(uint8_t* buf) {
	uint32_t i = 0;
 8003b92:	2100      	movs	r1, #0
	while (*(buf + i)) {
 8003b94:	e000      	b.n	8003b98 <VCP_send_str+0x6>
		i++;
 8003b96:	3101      	adds	r1, #1
	VCP_DataTx(&buf, 1);
}

void VCP_send_str(uint8_t* buf) {
	uint32_t i = 0;
	while (*(buf + i)) {
 8003b98:	5c43      	ldrb	r3, [r0, r1]
 8003b9a:	2b00      	cmp	r3, #0
 8003b9c:	d1fb      	bne.n	8003b96 <VCP_send_str+0x4>
		i++;
	}
	VCP_DataTx(buf, i);
 8003b9e:	e7b7      	b.n	8003b10 <VCP_DataTx>

08003ba0 <VCP_send_buffer>:
}

void VCP_send_buffer(uint8_t* buf, int len) {
	VCP_DataTx(buf, len);
 8003ba0:	e7b6      	b.n	8003b10 <VCP_DataTx>

08003ba2 <VCP_get_char_test>:

	return USBD_OK;
}

int VCP_get_char_test(void) {
	return APP_tx_ptr_head != APP_tx_ptr_tail;
 8003ba2:	4b04      	ldr	r3, [pc, #16]	; (8003bb4 <VCP_get_char_test+0x12>)
 8003ba4:	6818      	ldr	r0, [r3, #0]
 8003ba6:	4b04      	ldr	r3, [pc, #16]	; (8003bb8 <VCP_get_char_test+0x16>)
 8003ba8:	681b      	ldr	r3, [r3, #0]
}
 8003baa:	1ac0      	subs	r0, r0, r3
 8003bac:	bf18      	it	ne
 8003bae:	2001      	movne	r0, #1
 8003bb0:	4770      	bx	lr
 8003bb2:	bf00      	nop
 8003bb4:	20002a98 	.word	0x20002a98
 8003bb8:	20002a84 	.word	0x20002a84

08003bbc <VCP_get_char>:

int VCP_get_char(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8003bbc:	4b0a      	ldr	r3, [pc, #40]	; (8003be8 <VCP_get_char+0x2c>)
 8003bbe:	490b      	ldr	r1, [pc, #44]	; (8003bec <VCP_get_char+0x30>)
 8003bc0:	681a      	ldr	r2, [r3, #0]
 8003bc2:	6809      	ldr	r1, [r1, #0]
 8003bc4:	4291      	cmp	r1, r2
 8003bc6:	d00b      	beq.n	8003be0 <VCP_get_char+0x24>
		return 0;

	*buf = APP_Tx_Buffer[APP_tx_ptr_tail];
 8003bc8:	4909      	ldr	r1, [pc, #36]	; (8003bf0 <VCP_get_char+0x34>)
 8003bca:	5c8a      	ldrb	r2, [r1, r2]
 8003bcc:	7002      	strb	r2, [r0, #0]
	APP_tx_ptr_tail++;
 8003bce:	681a      	ldr	r2, [r3, #0]
 8003bd0:	3201      	adds	r2, #1
	if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
 8003bd2:	2a80      	cmp	r2, #128	; 0x80
int VCP_get_char(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
		return 0;

	*buf = APP_Tx_Buffer[APP_tx_ptr_tail];
	APP_tx_ptr_tail++;
 8003bd4:	601a      	str	r2, [r3, #0]
	if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
 8003bd6:	d105      	bne.n	8003be4 <VCP_get_char+0x28>
		APP_tx_ptr_tail = 0;
 8003bd8:	3a80      	subs	r2, #128	; 0x80
 8003bda:	601a      	str	r2, [r3, #0]

	return 1;
 8003bdc:	2001      	movs	r0, #1
 8003bde:	4770      	bx	lr
	return APP_tx_ptr_head != APP_tx_ptr_tail;
}

int VCP_get_char(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
		return 0;
 8003be0:	2000      	movs	r0, #0
 8003be2:	4770      	bx	lr
	*buf = APP_Tx_Buffer[APP_tx_ptr_tail];
	APP_tx_ptr_tail++;
	if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
		APP_tx_ptr_tail = 0;

	return 1;
 8003be4:	2001      	movs	r0, #1
}
 8003be6:	4770      	bx	lr
 8003be8:	20002a84 	.word	0x20002a84
 8003bec:	20002a98 	.word	0x20002a98
 8003bf0:	20002a04 	.word	0x20002a04

08003bf4 <VCP_get_string>:

int VCP_get_string(uint8_t *buf) {
 8003bf4:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8003bf6:	4a1f      	ldr	r2, [pc, #124]	; (8003c74 <VCP_get_string+0x80>)
 8003bf8:	4c1f      	ldr	r4, [pc, #124]	; (8003c78 <VCP_get_string+0x84>)
 8003bfa:	6813      	ldr	r3, [r2, #0]
 8003bfc:	6821      	ldr	r1, [r4, #0]
 8003bfe:	4299      	cmp	r1, r3
 8003c00:	4626      	mov	r6, r4
 8003c02:	d108      	bne.n	8003c16 <VCP_get_string+0x22>
 8003c04:	e033      	b.n	8003c6e <VCP_get_string+0x7a>
		return 0;

	while (!APP_Tx_Buffer[APP_tx_ptr_tail]
			|| APP_Tx_Buffer[APP_tx_ptr_tail] == '\n'
			|| APP_Tx_Buffer[APP_tx_ptr_tail] == '\r') {
		APP_tx_ptr_tail++;
 8003c06:	3301      	adds	r3, #1
		if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
			APP_tx_ptr_tail = 0;
 8003c08:	2b80      	cmp	r3, #128	; 0x80
 8003c0a:	bf08      	it	eq
 8003c0c:	2300      	moveq	r3, #0
		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8003c0e:	4299      	cmp	r1, r3
 8003c10:	d101      	bne.n	8003c16 <VCP_get_string+0x22>
 8003c12:	6011      	str	r1, [r2, #0]
 8003c14:	e02b      	b.n	8003c6e <VCP_get_string+0x7a>

int VCP_get_string(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
		return 0;

	while (!APP_Tx_Buffer[APP_tx_ptr_tail]
 8003c16:	4c19      	ldr	r4, [pc, #100]	; (8003c7c <VCP_get_string+0x88>)
			|| APP_Tx_Buffer[APP_tx_ptr_tail] == '\n'
			|| APP_Tx_Buffer[APP_tx_ptr_tail] == '\r') {
		APP_tx_ptr_tail++;
		if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
			APP_tx_ptr_tail = 0;
		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8003c18:	5ce5      	ldrb	r5, [r4, r3]
 8003c1a:	2d0d      	cmp	r5, #13
 8003c1c:	4625      	mov	r5, r4
 8003c1e:	d803      	bhi.n	8003c28 <VCP_get_string+0x34>
 8003c20:	56e4      	ldrsb	r4, [r4, r3]
 8003c22:	4f17      	ldr	r7, [pc, #92]	; (8003c80 <VCP_get_string+0x8c>)
 8003c24:	40a7      	lsls	r7, r4
 8003c26:	d4ee      	bmi.n	8003c06 <VCP_get_string+0x12>
 8003c28:	6013      	str	r3, [r2, #0]

int VCP_get_string(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
		return 0;

	while (!APP_Tx_Buffer[APP_tx_ptr_tail]
 8003c2a:	2300      	movs	r3, #0
			return 0;
	}

	int i = 0;
	do {
		*(buf + i) = APP_Tx_Buffer[i + APP_tx_ptr_tail];
 8003c2c:	18ec      	adds	r4, r5, r3
 8003c2e:	6811      	ldr	r1, [r2, #0]
 8003c30:	5c61      	ldrb	r1, [r4, r1]
 8003c32:	54c1      	strb	r1, [r0, r3]
		i++;

		if ((APP_tx_ptr_tail + i) == APP_TX_BUF_SIZE)
 8003c34:	6811      	ldr	r1, [r2, #0]
	}

	int i = 0;
	do {
		*(buf + i) = APP_Tx_Buffer[i + APP_tx_ptr_tail];
		i++;
 8003c36:	3301      	adds	r3, #1

		if ((APP_tx_ptr_tail + i) == APP_TX_BUF_SIZE)
 8003c38:	185c      	adds	r4, r3, r1
 8003c3a:	2c80      	cmp	r4, #128	; 0x80
			i = -APP_tx_ptr_tail;
 8003c3c:	bf08      	it	eq
 8003c3e:	424b      	negeq	r3, r1
		if (APP_tx_ptr_head == (APP_tx_ptr_tail + i))
 8003c40:	6834      	ldr	r4, [r6, #0]
 8003c42:	1859      	adds	r1, r3, r1
 8003c44:	428c      	cmp	r4, r1
 8003c46:	d012      	beq.n	8003c6e <VCP_get_string+0x7a>
 8003c48:	5c6c      	ldrb	r4, [r5, r1]
 8003c4a:	2c0d      	cmp	r4, #13
 8003c4c:	d8ee      	bhi.n	8003c2c <VCP_get_string+0x38>
 8003c4e:	4c0b      	ldr	r4, [pc, #44]	; (8003c7c <VCP_get_string+0x88>)
 8003c50:	5661      	ldrsb	r1, [r4, r1]
 8003c52:	4c0b      	ldr	r4, [pc, #44]	; (8003c80 <VCP_get_string+0x8c>)
 8003c54:	408c      	lsls	r4, r1
 8003c56:	d5e9      	bpl.n	8003c2c <VCP_get_string+0x38>

	} while (APP_Tx_Buffer[APP_tx_ptr_tail + i]
			&& APP_Tx_Buffer[APP_tx_ptr_tail + i] != '\n'
			&& APP_Tx_Buffer[APP_tx_ptr_tail + i] != '\r');

	*(buf + i) = 0;
 8003c58:	2100      	movs	r1, #0
 8003c5a:	54c1      	strb	r1, [r0, r3]
	APP_tx_ptr_tail += i;
 8003c5c:	6811      	ldr	r1, [r2, #0]
 8003c5e:	1859      	adds	r1, r3, r1
	if (APP_tx_ptr_tail >= APP_TX_BUF_SIZE)
 8003c60:	297f      	cmp	r1, #127	; 0x7f
	} while (APP_Tx_Buffer[APP_tx_ptr_tail + i]
			&& APP_Tx_Buffer[APP_tx_ptr_tail + i] != '\n'
			&& APP_Tx_Buffer[APP_tx_ptr_tail + i] != '\r');

	*(buf + i) = 0;
	APP_tx_ptr_tail += i;
 8003c62:	6011      	str	r1, [r2, #0]
	if (APP_tx_ptr_tail >= APP_TX_BUF_SIZE)
 8003c64:	d904      	bls.n	8003c70 <VCP_get_string+0x7c>
		APP_tx_ptr_tail -= APP_TX_BUF_SIZE;
 8003c66:	4a03      	ldr	r2, [pc, #12]	; (8003c74 <VCP_get_string+0x80>)
 8003c68:	3980      	subs	r1, #128	; 0x80
 8003c6a:	6011      	str	r1, [r2, #0]
 8003c6c:	e000      	b.n	8003c70 <VCP_get_string+0x7c>
		i++;

		if ((APP_tx_ptr_tail + i) == APP_TX_BUF_SIZE)
			i = -APP_tx_ptr_tail;
		if (APP_tx_ptr_head == (APP_tx_ptr_tail + i))
			return 0;
 8003c6e:	2300      	movs	r3, #0
	*(buf + i) = 0;
	APP_tx_ptr_tail += i;
	if (APP_tx_ptr_tail >= APP_TX_BUF_SIZE)
		APP_tx_ptr_tail -= APP_TX_BUF_SIZE;
	return i;
}
 8003c70:	4618      	mov	r0, r3
 8003c72:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003c74:	20002a84 	.word	0x20002a84
 8003c78:	20002a98 	.word	0x20002a98
 8003c7c:	20002a04 	.word	0x20002a04
 8003c80:	80240000 	.word	0x80240000

08003c84 <EVAL_COM_IRQHandler>:
 * @param  None.
 * @retval None.
 */
void EVAL_COM_IRQHandler(void) {

}
 8003c84:	4770      	bx	lr
 8003c86:	bf00      	nop

08003c88 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8003c88:	f040 61be 	orr.w	r1, r0, #99614720	; 0x5f00000
 8003c8c:	4b02      	ldr	r3, [pc, #8]	; (8003c98 <NVIC_PriorityGroupConfig+0x10>)
 8003c8e:	f441 2020 	orr.w	r0, r1, #655360	; 0xa0000
 8003c92:	60d8      	str	r0, [r3, #12]
}
 8003c94:	4770      	bx	lr
 8003c96:	bf00      	nop
 8003c98:	e000ed00 	.word	0xe000ed00

08003c9c <NVIC_Init>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8003c9c:	78c3      	ldrb	r3, [r0, #3]
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8003c9e:	b470      	push	{r4, r5, r6}
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8003ca0:	b963      	cbnz	r3, 8003cbc <NVIC_Init+0x20>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003ca2:	7802      	ldrb	r2, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003ca4:	2101      	movs	r1, #1
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003ca6:	0950      	lsrs	r0, r2, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003ca8:	f002 031f 	and.w	r3, r2, #31
 8003cac:	fa11 f203 	lsls.w	r2, r1, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003cb0:	3020      	adds	r0, #32
 8003cb2:	4916      	ldr	r1, [pc, #88]	; (8003d0c <NVIC_Init+0x70>)
 8003cb4:	f841 2020 	str.w	r2, [r1, r0, lsl #2]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 8003cb8:	bc70      	pop	{r4, r5, r6}
 8003cba:	4770      	bx	lr
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003cbc:	4b14      	ldr	r3, [pc, #80]	; (8003d10 <NVIC_Init+0x74>)
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8003cbe:	7846      	ldrb	r6, [r0, #1]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003cc0:	68dc      	ldr	r4, [r3, #12]
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 8003cc2:	7885      	ldrb	r5, [r0, #2]
        
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003cc4:	7801      	ldrb	r1, [r0, #0]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003cc6:	43e2      	mvns	r2, r4
 8003cc8:	f3c2 2202 	ubfx	r2, r2, #8, #3
    tmppre = (0x4 - tmppriority);
 8003ccc:	f1c2 0c04 	rsb	ip, r2, #4
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8003cd0:	fa5f f48c 	uxtb.w	r4, ip
 8003cd4:	fa16 f404 	lsls.w	r4, r6, r4
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
 8003cd8:	260f      	movs	r6, #15
 8003cda:	fa56 f202 	asrs.w	r2, r6, r2
    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
        
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003cde:	f5a3 6340 	sub.w	r3, r3, #3072	; 0xc00
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 8003ce2:	ea02 0c05 	and.w	ip, r2, r5
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8003ce6:	b2e4      	uxtb	r4, r4
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 8003ce8:	ea4c 0204 	orr.w	r2, ip, r4
        
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003cec:	eb01 0c03 	add.w	ip, r1, r3
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
        
    tmppriority = tmppriority << 0x04;
 8003cf0:	0112      	lsls	r2, r2, #4
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003cf2:	f88c 2300 	strb.w	r2, [ip, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003cf6:	7800      	ldrb	r0, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003cf8:	2201      	movs	r2, #1
 8003cfa:	f000 031f 	and.w	r3, r0, #31
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003cfe:	0941      	lsrs	r1, r0, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003d00:	fa12 f003 	lsls.w	r0, r2, r3
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003d04:	4a01      	ldr	r2, [pc, #4]	; (8003d0c <NVIC_Init+0x70>)
 8003d06:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
 8003d0a:	e7d5      	b.n	8003cb8 <NVIC_Init+0x1c>
 8003d0c:	e000e100 	.word	0xe000e100
 8003d10:	e000ed00 	.word	0xe000ed00

08003d14 <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 8003d14:	f021 4c60 	bic.w	ip, r1, #3758096384	; 0xe0000000
 8003d18:	f02c 027f 	bic.w	r2, ip, #127	; 0x7f
 8003d1c:	4b02      	ldr	r3, [pc, #8]	; (8003d28 <NVIC_SetVectorTable+0x14>)
 8003d1e:	ea42 0100 	orr.w	r1, r2, r0
 8003d22:	6099      	str	r1, [r3, #8]
}
 8003d24:	4770      	bx	lr
 8003d26:	bf00      	nop
 8003d28:	e000ed00 	.word	0xe000ed00

08003d2c <NVIC_SystemLPConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 8003d2c:	b929      	cbnz	r1, 8003d3a <NVIC_SystemLPConfig+0xe>
  {
    SCB->SCR |= LowPowerMode;
  }
  else
  {
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
 8003d2e:	4b05      	ldr	r3, [pc, #20]	; (8003d44 <NVIC_SystemLPConfig+0x18>)
 8003d30:	691a      	ldr	r2, [r3, #16]
 8003d32:	ea22 0100 	bic.w	r1, r2, r0
 8003d36:	6119      	str	r1, [r3, #16]
 8003d38:	4770      	bx	lr
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    SCB->SCR |= LowPowerMode;
 8003d3a:	4b02      	ldr	r3, [pc, #8]	; (8003d44 <NVIC_SystemLPConfig+0x18>)
 8003d3c:	691a      	ldr	r2, [r3, #16]
 8003d3e:	4310      	orrs	r0, r2
 8003d40:	6118      	str	r0, [r3, #16]
 8003d42:	4770      	bx	lr
 8003d44:	e000ed00 	.word	0xe000ed00

08003d48 <SysTick_CLKSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8003d48:	4b04      	ldr	r3, [pc, #16]	; (8003d5c <SysTick_CLKSourceConfig+0x14>)
 8003d4a:	681a      	ldr	r2, [r3, #0]
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 8003d4c:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8003d4e:	bf0c      	ite	eq
 8003d50:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8003d54:	f022 0204 	bicne.w	r2, r2, #4
 8003d58:	601a      	str	r2, [r3, #0]
 8003d5a:	4770      	bx	lr
 8003d5c:	e000e010 	.word	0xe000e010

08003d60 <hex>:
 * ************************************************************************************** */
/* bin to ascii lookup table */
static const char h[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
static char* hex(char *p, u8 c)	// Convert 'c' to hex, placing in output *p.
{
		*p++ = h[((c >> 4) & 0x0f)];	// Hi order nibble
 8003d60:	4a06      	ldr	r2, [pc, #24]	; (8003d7c <hex+0x1c>)
 8003d62:	090b      	lsrs	r3, r1, #4
 * static char* hex(char *p, u8 c)	// Convert 'c' to hex, placing in output *p.
 * ************************************************************************************** */
/* bin to ascii lookup table */
static const char h[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
static char* hex(char *p, u8 c)	// Convert 'c' to hex, placing in output *p.
{
 8003d64:	b510      	push	{r4, lr}
		*p++ = h[((c >> 4) & 0x0f)];	// Hi order nibble
		*p++ = h[(c & 0x0f)];		// Lo order nibble
 8003d66:	f001 010f 	and.w	r1, r1, #15
 * ************************************************************************************** */
/* bin to ascii lookup table */
static const char h[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
static char* hex(char *p, u8 c)	// Convert 'c' to hex, placing in output *p.
{
		*p++ = h[((c >> 4) & 0x0f)];	// Hi order nibble
 8003d6a:	5cd4      	ldrb	r4, [r2, r3]
 8003d6c:	4603      	mov	r3, r0
		*p++ = h[(c & 0x0f)];		// Lo order nibble
 8003d6e:	5c52      	ldrb	r2, [r2, r1]
 * ************************************************************************************** */
/* bin to ascii lookup table */
static const char h[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
static char* hex(char *p, u8 c)	// Convert 'c' to hex, placing in output *p.
{
		*p++ = h[((c >> 4) & 0x0f)];	// Hi order nibble
 8003d70:	f803 4b01 	strb.w	r4, [r3], #1
		*p++ = h[(c & 0x0f)];		// Lo order nibble
 8003d74:	7042      	strb	r2, [r0, #1]
		return p;			// Return new output pointer position
}
 8003d76:	1c58      	adds	r0, r3, #1
 8003d78:	bd10      	pop	{r4, pc}
 8003d7a:	bf00      	nop
 8003d7c:	0800fffc 	.word	0x0800fffc

08003d80 <strstuff>:
/* Note: It is up to the caller to have the struct initialized, initially and after the 
message has been "consumed."  When there are errors this routine re-initializes.  */

static void strstuff(struct PCTOGATEWAY* ptr, u8 c)
{
	*ptr->cmprs.p++ = c;			// Save binary byte in binary byte array
 8003d80:	6d83      	ldr	r3, [r0, #88]	; 0x58
 * ************************************************************************************** */
/* Note: It is up to the caller to have the struct initialized, initially and after the 
message has been "consumed."  When there are errors this routine re-initializes.  */

static void strstuff(struct PCTOGATEWAY* ptr, u8 c)
{
 8003d82:	b510      	push	{r4, lr}
	*ptr->cmprs.p++ = c;			// Save binary byte in binary byte array
 8003d84:	f803 1b01 	strb.w	r1, [r3], #1
 8003d88:	6583      	str	r3, [r0, #88]	; 0x58
	if (ptr->cmprs.ct > 0)			// Skip storing ascii for sequence number
 8003d8a:	f9b0 305c 	ldrsh.w	r3, [r0, #92]	; 0x5c
 * ************************************************************************************** */
/* Note: It is up to the caller to have the struct initialized, initially and after the 
message has been "consumed."  When there are errors this routine re-initializes.  */

static void strstuff(struct PCTOGATEWAY* ptr, u8 c)
{
 8003d8e:	4604      	mov	r4, r0
	*ptr->cmprs.p++ = c;			// Save binary byte in binary byte array
	if (ptr->cmprs.ct > 0)			// Skip storing ascii for sequence number
 8003d90:	2b00      	cmp	r3, #0
 8003d92:	dd03      	ble.n	8003d9c <strstuff+0x1c>
		ptr->pasc = hex(ptr->pasc, c);	// Convert 'c' to hex and save in ascii array	
 8003d94:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8003d96:	f7ff ffe3 	bl	8003d60 <hex>
 8003d9a:	6320      	str	r0, [r4, #48]	; 0x30
	ptr->cmprs.ct += 1;			// Binary byte count
 8003d9c:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
 8003da0:	3301      	adds	r3, #1
 8003da2:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
	return;
}
 8003da6:	bd10      	pop	{r4, pc}

08003da8 <strwrd>:
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
static void strwrd(u8* pout, u32 x)
{ // Store u32 in byte array
	*pout++ = (u8)x; *pout++ = (x >> 8); *pout++ = (x >> 16); *pout = (x >> 24); return;
 8003da8:	4603      	mov	r3, r0
 8003daa:	0a0a      	lsrs	r2, r1, #8
 8003dac:	f803 1b01 	strb.w	r1, [r3], #1
 8003db0:	7042      	strb	r2, [r0, #1]
 8003db2:	0c0a      	lsrs	r2, r1, #16
 8003db4:	0e09      	lsrs	r1, r1, #24
 8003db6:	705a      	strb	r2, [r3, #1]
 8003db8:	7099      	strb	r1, [r3, #2]
}
 8003dba:	4770      	bx	lr

08003dbc <getwd>:
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
static u32 getwd(u8* p) // Move non-aligned bytes into a 4 byte word
{
	return ((*(p+3) << 24) | (*(p+2) << 16) | (*(p+1) << 8) | (*p + 0));
 8003dbc:	7883      	ldrb	r3, [r0, #2]
 8003dbe:	78c2      	ldrb	r2, [r0, #3]
 8003dc0:	041b      	lsls	r3, r3, #16
 8003dc2:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8003dc6:	7802      	ldrb	r2, [r0, #0]
 8003dc8:	7840      	ldrb	r0, [r0, #1]
 8003dca:	4313      	orrs	r3, r2
}
 8003dcc:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8003dd0:	4770      	bx	lr

08003dd2 <CANgenchksum>:
 * @param	: p = pointer to array to be checksummed
 * @param	: ct = number of bytes to be checksummed
 * @return	: Checksum
 * ************************************************************************************** */
u8 CANgenchksum(u8* p, int ct)
{
 8003dd2:	b510      	push	{r4, lr}
	int i = 0;
	u32 x = CHECKSUM_INITIAL;
 8003dd4:	f24a 53a5 	movw	r3, #42405	; 0xa5a5
	for (i = 0; i < ct; i++)
 8003dd8:	2200      	movs	r2, #0
 8003dda:	e002      	b.n	8003de2 <CANgenchksum+0x10>
		x += *p++;
 8003ddc:	5c84      	ldrb	r4, [r0, r2]
 * ************************************************************************************** */
u8 CANgenchksum(u8* p, int ct)
{
	int i = 0;
	u32 x = CHECKSUM_INITIAL;
	for (i = 0; i < ct; i++)
 8003dde:	3201      	adds	r2, #1
		x += *p++;
 8003de0:	191b      	adds	r3, r3, r4
 * ************************************************************************************** */
u8 CANgenchksum(u8* p, int ct)
{
	int i = 0;
	u32 x = CHECKSUM_INITIAL;
	for (i = 0; i < ct; i++)
 8003de2:	428a      	cmp	r2, r1
 8003de4:	dbfa      	blt.n	8003ddc <CANgenchksum+0xa>
		x += *p++;
	x += (x >> 16);	// Add carries into high half word
 8003de6:	eb03 4313 	add.w	r3, r3, r3, lsr #16
	x += (x >> 16);	// Add carry if previous add generated a carry
 8003dea:	eb03 4313 	add.w	r3, r3, r3, lsr #16
	x += (x >> 8);  // Add high byte of low half word
 8003dee:	eb03 2313 	add.w	r3, r3, r3, lsr #8
	x += (x >> 8);  // Add carry if previous add generated a carry
	return (u8)x;
 8003df2:	eb03 2313 	add.w	r3, r3, r3, lsr #8
}
 8003df6:	b2d8      	uxtb	r0, r3
 8003df8:	bd10      	pop	{r4, pc}

08003dfa <PC_msg_initg>:
 * @param	: Pointer to gateway message wrapper (see common_can.h)
 * ************************************************************************************** */
void PC_msg_initg(struct PCTOGATEWAY* p)
{
	p->pasc = &p->asc[0];		// Pointer that will store incoming ascii chars
	p->cmprs.p = &p->cmprs.cm[0];	// Pointer that will store incoming binary bytes
 8003dfa:	f100 0340 	add.w	r3, r0, #64	; 0x40
 8003dfe:	6583      	str	r3, [r0, #88]	; 0x58
	p->ctasc = 0;			// Byte counter
 8003e00:	2300      	movs	r3, #0
 8003e02:	8743      	strh	r3, [r0, #58]	; 0x3a
	p->ct = 0;			// Byte counter
 8003e04:	8703      	strh	r3, [r0, #56]	; 0x38
	p->cmprs.ct = 0;		// Byte counter
 8003e06:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
	p->chk = CHECKSUM_INITIAL;	// Checksum initial value
 8003e0a:	f24a 53a5 	movw	r3, #42405	; 0xa5a5
 8003e0e:	6343      	str	r3, [r0, #52]	; 0x34
	p->prev = ~CAN_PC_ESCAPE;	// Begin with received byte not an escape.
 8003e10:	2382      	movs	r3, #130	; 0x82
 * @brief	: Initialize struct for building a gateway message from the PC
 * @param	: Pointer to gateway message wrapper (see common_can.h)
 * ************************************************************************************** */
void PC_msg_initg(struct PCTOGATEWAY* p)
{
	p->pasc = &p->asc[0];		// Pointer that will store incoming ascii chars
 8003e12:	6300      	str	r0, [r0, #48]	; 0x30
	p->cmprs.p = &p->cmprs.cm[0];	// Pointer that will store incoming binary bytes
	p->ctasc = 0;			// Byte counter
	p->ct = 0;			// Byte counter
	p->cmprs.ct = 0;		// Byte counter
	p->chk = CHECKSUM_INITIAL;	// Checksum initial value
	p->prev = ~CAN_PC_ESCAPE;	// Begin with received byte not an escape.
 8003e14:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
	return;
}
 8003e18:	4770      	bx	lr

08003e1a <PC_msg_getASCII>:
//printf("%c",c);
//debugR += 1;
	

	/* End of msg check */
	if (c == '\n')
 8003e1a:	290a      	cmp	r1, #10
int debugR;

/* Note: It is up to the caller to have the struct initialized, initially and after the 
message has been "consumed."  When there are errors this routine re-initializes.  */
int PC_msg_getASCII(struct PCTOGATEWAY* ptr, u8 c)
{			
 8003e1c:	b538      	push	{r3, r4, r5, lr}
 8003e1e:	4604      	mov	r4, r0
//printf("%c",c);
//debugR += 1;
	

	/* End of msg check */
	if (c == '\n')
 8003e20:	d13c      	bne.n	8003e9c <PC_msg_getASCII+0x82>
//xprintf (6,"in ct: %i debugR: %i ctasc: %i \n",i, debugR, ptr->ctasc);
//for (w = 0; w < i; w++)
//xprintf(6,"%02x ",ptr->cmprs.cm[w]);
//xprintf(6,"\n\r");
//debugR = 0;
		*ptr->pasc++ = c;	// Store '\n'
 8003e22:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8003e24:	f803 1b01 	strb.w	r1, [r3], #1
		ptr->ctasc -= 2; // Adjust for not storing seq number bytes, but added '\n'
 8003e28:	8f45      	ldrh	r5, [r0, #58]	; 0x3a
//xprintf (6,"in ct: %i debugR: %i ctasc: %i \n",i, debugR, ptr->ctasc);
//for (w = 0; w < i; w++)
//xprintf(6,"%02x ",ptr->cmprs.cm[w]);
//xprintf(6,"\n\r");
//debugR = 0;
		*ptr->pasc++ = c;	// Store '\n'
 8003e2a:	6303      	str	r3, [r0, #48]	; 0x30
		ptr->ctasc -= 2; // Adjust for not storing seq number bytes, but added '\n'
 8003e2c:	3d02      	subs	r5, #2
 8003e2e:	b2ad      	uxth	r5, r5

		ptr->seq = ptr->cmprs.cm[0];		// First binary byte is the sequence number
 8003e30:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
		ptr->cmprs.seq = ptr->cmprs.cm[0];	// Save for binary folk

		/* Check count for even pairing of hex char pairs */
		if ((ptr->ctasc & 0x1) != 0) // Should be odd at this point
 8003e34:	f015 0f01 	tst.w	r5, #1
//for (w = 0; w < i; w++)
//xprintf(6,"%02x ",ptr->cmprs.cm[w]);
//xprintf(6,"\n\r");
//debugR = 0;
		*ptr->pasc++ = c;	// Store '\n'
		ptr->ctasc -= 2; // Adjust for not storing seq number bytes, but added '\n'
 8003e38:	8745      	strh	r5, [r0, #58]	; 0x3a

		ptr->seq = ptr->cmprs.cm[0];		// First binary byte is the sequence number
 8003e3a:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
		ptr->cmprs.seq = ptr->cmprs.cm[0];	// Save for binary folk
 8003e3e:	f880 305e 	strb.w	r3, [r0, #94]	; 0x5e

		/* Check count for even pairing of hex char pairs */
		if ((ptr->ctasc & 0x1) != 0) // Should be odd at this point
 8003e42:	d008      	beq.n	8003e56 <PC_msg_getASCII+0x3c>
		{ // Here, not an even pairing for the binary bytes
			PC_msg_initg(ptr);	// Initialize struct for the next message
 8003e44:	f7ff ffd9 	bl	8003dfa <PC_msg_initg>
			PC_oddeven_ct_err += 1;	// Running count of this type of error.
 8003e48:	4b28      	ldr	r3, [pc, #160]	; (8003eec <PC_msg_getASCII+0xd2>)
			return -4;	// Return error code.		{	
 8003e4a:	f06f 0003 	mvn.w	r0, #3

		/* Check count for even pairing of hex char pairs */
		if ((ptr->ctasc & 0x1) != 0) // Should be odd at this point
		{ // Here, not an even pairing for the binary bytes
			PC_msg_initg(ptr);	// Initialize struct for the next message
			PC_oddeven_ct_err += 1;	// Running count of this type of error.
 8003e4e:	681a      	ldr	r2, [r3, #0]
 8003e50:	3201      	adds	r2, #1
 8003e52:	601a      	str	r2, [r3, #0]
			return -4;	// Return error code.		{	
 8003e54:	bd38      	pop	{r3, r4, r5, pc}
		}

		if (ptr->ctasc < 5)		// Too few incoming bytes to comprise a valid anything?
 8003e56:	b22d      	sxth	r5, r5
 8003e58:	2d04      	cmp	r5, #4
 8003e5a:	dc08      	bgt.n	8003e6e <PC_msg_getASCII+0x54>
		{ // Here yes.
			PC_msg_initg(ptr);	// Initialize struct for the next message
 8003e5c:	f7ff ffcd 	bl	8003dfa <PC_msg_initg>
			PC_toofew_ct_err += 1;	// Running count of this type of error.
 8003e60:	4b22      	ldr	r3, [pc, #136]	; (8003eec <PC_msg_getASCII+0xd2>)
			return -2;	// Return error code.
 8003e62:	f06f 0001 	mvn.w	r0, #1
		}

		if (ptr->ctasc < 5)		// Too few incoming bytes to comprise a valid anything?
		{ // Here yes.
			PC_msg_initg(ptr);	// Initialize struct for the next message
			PC_toofew_ct_err += 1;	// Running count of this type of error.
 8003e66:	685a      	ldr	r2, [r3, #4]
 8003e68:	3201      	adds	r2, #1
 8003e6a:	605a      	str	r2, [r3, #4]
			return -2;	// Return error code.
 8003e6c:	bd38      	pop	{r3, r4, r5, pc}
		}

		/* Binary byte count is the ascii ct divided by 2, less checksum */
		ptr->cmprs.ct = (ptr->ctasc >> 1);	// Number of binary bytes of msg data
 8003e6e:	106d      	asrs	r5, r5, #1
 8003e70:	f8a0 505c 	strh.w	r5, [r0, #92]	; 0x5c
					
		/* Check checksum. */	
		x = ptr->cmprs.cm[ptr->cmprs.ct];	// Checksum received
 8003e74:	b22d      	sxth	r5, r5
		zz=CANgenchksum(&ptr->cmprs.cm[0], (ptr->cmprs.ct));	// Checksum computed
 8003e76:	3040      	adds	r0, #64	; 0x40
 8003e78:	4629      	mov	r1, r5
 8003e7a:	f7ff ffaa 	bl	8003dd2 <CANgenchksum>

		/* Binary byte count is the ascii ct divided by 2, less checksum */
		ptr->cmprs.ct = (ptr->ctasc >> 1);	// Number of binary bytes of msg data
					
		/* Check checksum. */	
		x = ptr->cmprs.cm[ptr->cmprs.ct];	// Checksum received
 8003e7e:	1965      	adds	r5, r4, r5
		zz=CANgenchksum(&ptr->cmprs.cm[0], (ptr->cmprs.ct));	// Checksum computed
//xprintf(6," CHKRCV %02x CMP %02x\n\r",x,zz);

		/* Compute checksum and compare. */
		if (zz  == x)
 8003e80:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 8003e84:	4283      	cmp	r3, r0
 8003e86:	d02c      	beq.n	8003ee2 <PC_msg_getASCII+0xc8>
//printf("CHKSM: %02x %02x %02x  ptr->cmprs.ct: %i ptr->ctasc: %i\n",x,xx,zz,ptr->cmprs.ct, ptr->ctasc);
//int j;
//for (j = 0; j < ptr->cmprs.ct+2; j++)
//  printf("%02x",ptr->cmprs.cm[j]);
//printf("\n");
			PC_msg_initg(ptr);	// Initialize struct for the next message
 8003e88:	4620      	mov	r0, r4
 8003e8a:	f7ff ffb6 	bl	8003dfa <PC_msg_initg>
			PC_chksum_ct_err += 1;	// Running count of checksum errors
 8003e8e:	4b17      	ldr	r3, [pc, #92]	; (8003eec <PC_msg_getASCII+0xd2>)
			return -1;	// Return error code.
 8003e90:	f04f 30ff 	mov.w	r0, #4294967295
//int j;
//for (j = 0; j < ptr->cmprs.ct+2; j++)
//  printf("%02x",ptr->cmprs.cm[j]);
//printf("\n");
			PC_msg_initg(ptr);	// Initialize struct for the next message
			PC_chksum_ct_err += 1;	// Running count of checksum errors
 8003e94:	689a      	ldr	r2, [r3, #8]
 8003e96:	3201      	adds	r2, #1
 8003e98:	609a      	str	r2, [r3, #8]
			return -1;	// Return error code.
 8003e9a:	bd38      	pop	{r3, r4, r5, pc}
		}
	}
	if ( (ptr->ctasc & 0x1) == 0) // Even?
 8003e9c:	8f43      	ldrh	r3, [r0, #58]	; 0x3a
 8003e9e:	4a14      	ldr	r2, [pc, #80]	; (8003ef0 <PC_msg_getASCII+0xd6>)
 8003ea0:	f013 0f01 	tst.w	r3, #1
 8003ea4:	6d83      	ldr	r3, [r0, #88]	; 0x58
 8003ea6:	d104      	bne.n	8003eb2 <PC_msg_getASCII+0x98>
	{ // Here yes.  Even chars -> hi ord nibble of byte
		*ptr->cmprs.p = (hxbn[c] << 4); // Convert hex char to bin 4 bit
 8003ea8:	1852      	adds	r2, r2, r1
 8003eaa:	7c12      	ldrb	r2, [r2, #16]
 8003eac:	0112      	lsls	r2, r2, #4
 8003eae:	701a      	strb	r2, [r3, #0]
 8003eb0:	e007      	b.n	8003ec2 <PC_msg_getASCII+0xa8>
	}
	else
	{ // Here, Odd chars -> low ord nibble of byte
		*ptr->cmprs.p++ |= hxbn[c];	// Add nibble.  Byte complete.  Advance pointer.
 8003eb2:	1852      	adds	r2, r2, r1
 8003eb4:	7c10      	ldrb	r0, [r2, #16]
 8003eb6:	781a      	ldrb	r2, [r3, #0]
 8003eb8:	ea40 0202 	orr.w	r2, r0, r2
 8003ebc:	f803 2b01 	strb.w	r2, [r3], #1
 8003ec0:	65a3      	str	r3, [r4, #88]	; 0x58
	}

	/* Copy incoming chars into asc buffer. */
	*ptr->pasc++ = c; 	// Store incoming chars char array (for those who want raw ascii lines)
 8003ec2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003ec4:	f803 1b01 	strb.w	r1, [r3], #1
 8003ec8:	6323      	str	r3, [r4, #48]	; 0x30
	ptr->ctasc += 1;	// Count incoming chars
 8003eca:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
 8003ecc:	3301      	adds	r3, #1
 8003ece:	8763      	strh	r3, [r4, #58]	; 0x3a

	/* Max length check */
	if (ptr->ctasc > 37) 
 8003ed0:	b21b      	sxth	r3, r3
 8003ed2:	2b25      	cmp	r3, #37	; 0x25
 8003ed4:	dd07      	ble.n	8003ee6 <PC_msg_getASCII+0xcc>
	{ // Here incoming chars exceed the max number for a max size CAN msg
		PC_msg_initg(ptr);	// Initialize struct for the next message
 8003ed6:	4620      	mov	r0, r4
 8003ed8:	f7ff ff8f 	bl	8003dfa <PC_msg_initg>
		return -3;		// Return an error code
 8003edc:	f06f 0002 	mvn.w	r0, #2
 8003ee0:	bd38      	pop	{r3, r4, r5, pc}
//xprintf(6," CHKRCV %02x CMP %02x\n\r",x,zz);

		/* Compute checksum and compare. */
		if (zz  == x)
		{ // Here checksum good
				return 1;	// $$$$ COMPLETE & SUCCESS $$$$
 8003ee2:	2001      	movs	r0, #1
 8003ee4:	bd38      	pop	{r3, r4, r5, pc}
	{ // Here incoming chars exceed the max number for a max size CAN msg
		PC_msg_initg(ptr);	// Initialize struct for the next message
		return -3;		// Return an error code
	}

	return 0;
 8003ee6:	2000      	movs	r0, #0
}
 8003ee8:	bd38      	pop	{r3, r4, r5, pc}
 8003eea:	bf00      	nop
 8003eec:	20000e48 	.word	0x20000e48
 8003ef0:	0800fffc 	.word	0x0800fffc

08003ef4 <PC_msg_get>:

int PC_msg_get(struct PCTOGATEWAY* ptr, u8 c)
{			
	int i;

	switch (c)
 8003ef4:	290a      	cmp	r1, #10
	ptr->cmprs.ct += 1;			// Binary byte count
	return;
}

int PC_msg_get(struct PCTOGATEWAY* ptr, u8 c)
{			
 8003ef6:	b570      	push	{r4, r5, r6, lr}
 8003ef8:	4604      	mov	r4, r0
 8003efa:	460d      	mov	r5, r1
	int i;

	switch (c)
 8003efc:	d002      	beq.n	8003f04 <PC_msg_get+0x10>
 8003efe:	297d      	cmp	r1, #125	; 0x7d
 8003f00:	d149      	bne.n	8003f96 <PC_msg_get+0xa2>
 8003f02:	e040      	b.n	8003f86 <PC_msg_get+0x92>
	{
	case CAN_PC_FRAMEBOUNDARY:	// Possible end of message
		if (ptr->prev == CAN_PC_ESCAPE)
 8003f04:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8003f08:	2b7d      	cmp	r3, #125	; 0x7d
 8003f0a:	d044      	beq.n	8003f96 <PC_msg_get+0xa2>
		{ // Here, previous byte was an escape byte
			strstuff(ptr, c); // Store binary, ascii, and count binary bytes
		}
		else
		{ // Here, frame without preceding escape means End of Message
			i = ptr->cmprs.p - &ptr->cmprs.cm[0] - 1; // Number of bytes received in this frame less chksum
 8003f0c:	6d85      	ldr	r5, [r0, #88]	; 0x58
 8003f0e:	f100 0340 	add.w	r3, r0, #64	; 0x40
 8003f12:	3d01      	subs	r5, #1
 8003f14:	1aed      	subs	r5, r5, r3
			ptr->cmprs.ct = i;	// Save for others
 8003f16:	b2ae      	uxth	r6, r5
			if (i < 3)		// Too few bytes to comprise a valid msg?
 8003f18:	2d02      	cmp	r5, #2
			strstuff(ptr, c); // Store binary, ascii, and count binary bytes
		}
		else
		{ // Here, frame without preceding escape means End of Message
			i = ptr->cmprs.p - &ptr->cmprs.cm[0] - 1; // Number of bytes received in this frame less chksum
			ptr->cmprs.ct = i;	// Save for others
 8003f1a:	f8a0 605c 	strh.w	r6, [r0, #92]	; 0x5c
			if (i < 3)		// Too few bytes to comprise a valid msg?
 8003f1e:	dc08      	bgt.n	8003f32 <PC_msg_get+0x3e>
			{ // Here yes. (min binary msg plus checksum = 3 bytes)
				PC_msg_initg(ptr);	// Initialize struct for the next message
 8003f20:	f7ff ff6b 	bl	8003dfa <PC_msg_initg>
				PC_toofew_ct_err += 1;	// Running count of this type of error.
 8003f24:	4b22      	ldr	r3, [pc, #136]	; (8003fb0 <PC_msg_get+0xbc>)
				return -2;	// Return error code.
 8003f26:	f06f 0001 	mvn.w	r0, #1
			i = ptr->cmprs.p - &ptr->cmprs.cm[0] - 1; // Number of bytes received in this frame less chksum
			ptr->cmprs.ct = i;	// Save for others
			if (i < 3)		// Too few bytes to comprise a valid msg?
			{ // Here yes. (min binary msg plus checksum = 3 bytes)
				PC_msg_initg(ptr);	// Initialize struct for the next message
				PC_toofew_ct_err += 1;	// Running count of this type of error.
 8003f2a:	685a      	ldr	r2, [r3, #4]
 8003f2c:	3201      	adds	r2, #1
 8003f2e:	605a      	str	r2, [r3, #4]
				return -2;	// Return error code.
 8003f30:	bd70      	pop	{r4, r5, r6, pc}
			}

			if (i >= (PCTOGATEWAYSIZE/2) )	// Too many bytes to comprise a valid msg?
 8003f32:	2d17      	cmp	r5, #23
 8003f34:	dd08      	ble.n	8003f48 <PC_msg_get+0x54>
			{ // Here yes.
				PC_msg_initg(ptr);	// Initialize struct for the next message
 8003f36:	f7ff ff60 	bl	8003dfa <PC_msg_initg>
				PC_toomany_ct_err += 1;	// Running count of this type of error.
 8003f3a:	4b1d      	ldr	r3, [pc, #116]	; (8003fb0 <PC_msg_get+0xbc>)
				return -3;	// Return error code.
 8003f3c:	f06f 0002 	mvn.w	r0, #2
			}

			if (i >= (PCTOGATEWAYSIZE/2) )	// Too many bytes to comprise a valid msg?
			{ // Here yes.
				PC_msg_initg(ptr);	// Initialize struct for the next message
				PC_toomany_ct_err += 1;	// Running count of this type of error.
 8003f40:	68da      	ldr	r2, [r3, #12]
 8003f42:	3201      	adds	r2, #1
 8003f44:	60da      	str	r2, [r3, #12]
				return -3;	// Return error code.
 8003f46:	bd70      	pop	{r4, r5, r6, pc}
			}

			/* Check checksum. */	
			if ( (CANgenchksum(&ptr->cmprs.cm[0], i)) == ptr->cmprs.cm[i])
 8003f48:	4618      	mov	r0, r3
 8003f4a:	4629      	mov	r1, r5
 8003f4c:	f7ff ff41 	bl	8003dd2 <CANgenchksum>
 8003f50:	1965      	adds	r5, r4, r5
 8003f52:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 8003f56:	4283      	cmp	r3, r0
 8003f58:	d10b      	bne.n	8003f72 <PC_msg_get+0x7e>
			{ // Here checksum good
/* If incoming, complete & valid, messages are to be buffered, this is where the index for the
  buffer array would be advanced. */
				ptr->ctasc = (ptr->cmprs.ct * 2) + 1; // Compute byte ct for ascii array
				*ptr->pasc = '\0';	// Zero string terminator JIC a bozo forgot msg ends with '\n'
 8003f5a:	6b23      	ldr	r3, [r4, #48]	; 0x30
			/* Check checksum. */	
			if ( (CANgenchksum(&ptr->cmprs.cm[0], i)) == ptr->cmprs.cm[i])
			{ // Here checksum good
/* If incoming, complete & valid, messages are to be buffered, this is where the index for the
  buffer array would be advanced. */
				ptr->ctasc = (ptr->cmprs.ct * 2) + 1; // Compute byte ct for ascii array
 8003f5c:	0076      	lsls	r6, r6, #1
 8003f5e:	3601      	adds	r6, #1
				*ptr->pasc = '\0';	// Zero string terminator JIC a bozo forgot msg ends with '\n'
 8003f60:	2200      	movs	r2, #0
			/* Check checksum. */	
			if ( (CANgenchksum(&ptr->cmprs.cm[0], i)) == ptr->cmprs.cm[i])
			{ // Here checksum good
/* If incoming, complete & valid, messages are to be buffered, this is where the index for the
  buffer array would be advanced. */
				ptr->ctasc = (ptr->cmprs.ct * 2) + 1; // Compute byte ct for ascii array
 8003f62:	8766      	strh	r6, [r4, #58]	; 0x3a
				*ptr->pasc = '\0';	// Zero string terminator JIC a bozo forgot msg ends with '\n'
 8003f64:	701a      	strb	r2, [r3, #0]
				ptr->seq = ptr->cmprs.cm[0];
 8003f66:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
				return 1;		// $$$$ COMPLETE & SUCCESS $$$$
 8003f6a:	2001      	movs	r0, #1
			{ // Here checksum good
/* If incoming, complete & valid, messages are to be buffered, this is where the index for the
  buffer array would be advanced. */
				ptr->ctasc = (ptr->cmprs.ct * 2) + 1; // Compute byte ct for ascii array
				*ptr->pasc = '\0';	// Zero string terminator JIC a bozo forgot msg ends with '\n'
				ptr->seq = ptr->cmprs.cm[0];
 8003f6c:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
				return 1;		// $$$$ COMPLETE & SUCCESS $$$$
 8003f70:	bd70      	pop	{r4, r5, r6, pc}
			}
			else
			{ // Here, failed
				PC_msg_initg(ptr);	// Initialize struct for the next message
 8003f72:	4620      	mov	r0, r4
 8003f74:	f7ff ff41 	bl	8003dfa <PC_msg_initg>
				PC_chksum_ct_err += 1;	// Running count of checksum errors
 8003f78:	4b0d      	ldr	r3, [pc, #52]	; (8003fb0 <PC_msg_get+0xbc>)
				return -1;		// Return error code.
 8003f7a:	f04f 30ff 	mov.w	r0, #4294967295
				return 1;		// $$$$ COMPLETE & SUCCESS $$$$
			}
			else
			{ // Here, failed
				PC_msg_initg(ptr);	// Initialize struct for the next message
				PC_chksum_ct_err += 1;	// Running count of checksum errors
 8003f7e:	689a      	ldr	r2, [r3, #8]
 8003f80:	3201      	adds	r2, #1
 8003f82:	609a      	str	r2, [r3, #8]
				return -1;		// Return error code.
 8003f84:	bd70      	pop	{r4, r5, r6, pc}
			}
		}			
		break;

	case CAN_PC_ESCAPE: // Possible escape data byte, or escape for next byte.
		if (ptr->prev == CAN_PC_ESCAPE)
 8003f86:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8003f8a:	2b7d      	cmp	r3, #125	; 0x7d
 8003f8c:	d105      	bne.n	8003f9a <PC_msg_get+0xa6>
		{
			strstuff(ptr, c); // Store binary, ascii, and count binary bytes
 8003f8e:	f7ff fef7 	bl	8003d80 <strstuff>
			c = ~CAN_PC_ESCAPE;		// Set "previous" to not an escape
 8003f92:	2582      	movs	r5, #130	; 0x82
 8003f94:	e001      	b.n	8003f9a <PC_msg_get+0xa6>
		}
		break;

	default: // All other bytes come here.
			strstuff(ptr, c); // Store binary, ascii, and count binary bytes
 8003f96:	f7ff fef3 	bl	8003d80 <strstuff>
		break;
	}
	/* Prevent buffer overflow. */
	if ( ptr->pasc >= (&ptr->asc[0] + PCTOGATEWAYSIZE - 3 ) ) ptr->pasc -= 2; // Hold at end with space to allow '\n' '\0'
 8003f9a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003f9c:	f104 022d 	add.w	r2, r4, #45	; 0x2d
 8003fa0:	4293      	cmp	r3, r2
 8003fa2:	d301      	bcc.n	8003fa8 <PC_msg_get+0xb4>
 8003fa4:	3b02      	subs	r3, #2
 8003fa6:	6323      	str	r3, [r4, #48]	; 0x30

	ptr->prev = c;	// Save previous char for byte stuffing check.
 8003fa8:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c

	return 0;	// Return: binary fram not complete
 8003fac:	2000      	movs	r0, #0
}
 8003fae:	bd70      	pop	{r4, r5, r6, pc}
 8003fb0:	20000e48 	.word	0x20000e48

08003fb4 <CAN_id_valid>:
 *		: -1 = faux CAN msg id bit 0 on
 *              : -2 = faux CAN msg id: 11 bit id, but stray bits in remaining 18 bits
 * ************************************************************************************** */
int CAN_id_valid(u32 id)
{
	if ( (id & 0x1) != 0 ) return -1; // faux ID
 8003fb4:	f010 0f01 	tst.w	r0, #1
 8003fb8:	d10b      	bne.n	8003fd2 <CAN_id_valid+0x1e>
	if ( (id & 0x4) == 0 ) // Check IDE (extended id bit)
 8003fba:	f010 0f04 	tst.w	r0, #4
 8003fbe:	d10b      	bne.n	8003fd8 <CAN_id_valid+0x24>
	{ // Here, an 11 bit address is specified
		if ((id & 0x001ffff8) != 0) return -2; // 11 bit id with stray bits in extended field
 8003fc0:	4b06      	ldr	r3, [pc, #24]	; (8003fdc <CAN_id_valid+0x28>)
 8003fc2:	ea00 0303 	and.w	r3, r0, r3
 8003fc6:	2b00      	cmp	r3, #0
 8003fc8:	bf0c      	ite	eq
 8003fca:	4618      	moveq	r0, r3
 8003fcc:	f06f 0001 	mvnne.w	r0, #1
 8003fd0:	4770      	bx	lr
 *		: -1 = faux CAN msg id bit 0 on
 *              : -2 = faux CAN msg id: 11 bit id, but stray bits in remaining 18 bits
 * ************************************************************************************** */
int CAN_id_valid(u32 id)
{
	if ( (id & 0x1) != 0 ) return -1; // faux ID
 8003fd2:	f04f 30ff 	mov.w	r0, #4294967295
 8003fd6:	4770      	bx	lr
	if ( (id & 0x4) == 0 ) // Check IDE (extended id bit)
	{ // Here, an 11 bit address is specified
		if ((id & 0x001ffff8) != 0) return -2; // 11 bit id with stray bits in extended field
		return 0; // Here, 11b is OK.
	}
	return 1;	// Here 29 bit is OK.
 8003fd8:	2001      	movs	r0, #1
}
 8003fda:	4770      	bx	lr
 8003fdc:	001ffff8 	.word	0x001ffff8

08003fe0 <PC_msg_asctobin>:
cc -> payload byte ct (0 - 8)
11... -> payload bytes (0 - 8)
\n is the line terminator of the ascii input
*/
int PC_msg_asctobin(struct PCTOGATEWAY* ptr, char* pin)
{
 8003fe0:	b570      	push	{r4, r5, r6, lr}
 8003fe2:	4604      	mov	r4, r0
 8003fe4:	460e      	mov	r6, r1
	int ct = 0;
	u8 x;
	u32 id;

	u8* pcmprs = &ptr->cmprs.cm[0];
 8003fe6:	f100 0540 	add.w	r5, r0, #64	; 0x40
	PC_msg_initg(ptr);	// Reset pointers
 8003fea:	f7ff ff06 	bl	8003dfa <PC_msg_initg>
11... -> payload bytes (0 - 8)
\n is the line terminator of the ascii input
*/
int PC_msg_asctobin(struct PCTOGATEWAY* ptr, char* pin)
{
	int ct = 0;
 8003fee:	2300      	movs	r3, #0

	u8* pcmprs = &ptr->cmprs.cm[0];
	PC_msg_initg(ptr);	// Reset pointers

	
	while  ( (!((*pin == 0) || (*pin == '\n'))) && (ct < PCTOGATEWAYSIZE)  )
 8003ff0:	e010      	b.n	8004014 <PC_msg_asctobin+0x34>
	{
		if ( (ct & 0x1) == 0) // Even?
 8003ff2:	f013 0f01 	tst.w	r3, #1
 8003ff6:	491b      	ldr	r1, [pc, #108]	; (8004064 <PC_msg_asctobin+0x84>)
 8003ff8:	d104      	bne.n	8004004 <PC_msg_asctobin+0x24>
		{ // Here yes.  Even chars -> hi ord nibble of byte
			*pcmprs = (hxbn[(u8)(*pin)] << 4);
 8003ffa:	188a      	adds	r2, r1, r2
 8003ffc:	7c12      	ldrb	r2, [r2, #16]
 8003ffe:	0112      	lsls	r2, r2, #4
 8004000:	702a      	strb	r2, [r5, #0]
 8004002:	e006      	b.n	8004012 <PC_msg_asctobin+0x32>
		}
		else
		{ // Here, Odd chars -> low ord nibble of byte
			*pcmprs++ |= hxbn[(u8)(*pin)];	// Add nibble.  Byte complete.  Advance pointer.
 8004004:	188a      	adds	r2, r1, r2
 8004006:	7828      	ldrb	r0, [r5, #0]
 8004008:	7c12      	ldrb	r2, [r2, #16]
 800400a:	ea40 0202 	orr.w	r2, r0, r2
 800400e:	f805 2b01 	strb.w	r2, [r5], #1
		}
		pin ++; ct +=1;
 8004012:	3301      	adds	r3, #1

	u8* pcmprs = &ptr->cmprs.cm[0];
	PC_msg_initg(ptr);	// Reset pointers

	
	while  ( (!((*pin == 0) || (*pin == '\n'))) && (ct < PCTOGATEWAYSIZE)  )
 8004014:	5cf2      	ldrb	r2, [r6, r3]
 8004016:	b122      	cbz	r2, 8004022 <PC_msg_asctobin+0x42>
 8004018:	2a0a      	cmp	r2, #10
 800401a:	d002      	beq.n	8004022 <PC_msg_asctobin+0x42>
 800401c:	2b30      	cmp	r3, #48	; 0x30
 800401e:	d1e8      	bne.n	8003ff2 <PC_msg_asctobin+0x12>
 8004020:	e017      	b.n	8004052 <PC_msg_asctobin+0x72>
		{ // Here, Odd chars -> low ord nibble of byte
			*pcmprs++ |= hxbn[(u8)(*pin)];	// Add nibble.  Byte complete.  Advance pointer.
		}
		pin ++; ct +=1;
	}
	if (ct >= PCTOGATEWAYSIZE)	return -5; // Error: run-away (no terminator)
 8004022:	2b2f      	cmp	r3, #47	; 0x2f
 8004024:	dc15      	bgt.n	8004052 <PC_msg_asctobin+0x72>

	/* Compute size of resulting binary msg. */
	ptr->cmprs.ct = (pcmprs - &ptr->cmprs.cm[0]);
 8004026:	f104 0340 	add.w	r3, r4, #64	; 0x40
 800402a:	1aed      	subs	r5, r5, r3

	/* Validity check */
	x = (u8)(ptr->cmprs.cm[4]);		// Should be the dlc
 800402c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
		pin ++; ct +=1;
	}
	if (ct >= PCTOGATEWAYSIZE)	return -5; // Error: run-away (no terminator)

	/* Compute size of resulting binary msg. */
	ptr->cmprs.ct = (pcmprs - &ptr->cmprs.cm[0]);
 8004030:	f8a4 505c 	strh.w	r5, [r4, #92]	; 0x5c

	/* Validity check */
	x = (u8)(ptr->cmprs.cm[4]);		// Should be the dlc
	if ( x > 8 ) return -1;		// Return: too many bytes for payload count
 8004034:	2b08      	cmp	r3, #8
 8004036:	d80f      	bhi.n	8004058 <PC_msg_asctobin+0x78>

	if (ptr->cmprs.ct != (x + 5)) return -2; // Size inconsistent with dlc count
 8004038:	b22d      	sxth	r5, r5
 800403a:	3305      	adds	r3, #5
 800403c:	429d      	cmp	r5, r3
 800403e:	d10e      	bne.n	800405e <PC_msg_asctobin+0x7e>
	id = (u32)(ptr->cmprs.cm[0]);		// Get ID in binary word form
	if (CAN_id_valid(id) != 0) return -3;	// Bits in extended field, but 11 bit id specified
 8004040:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
 8004044:	f7ff ffb6 	bl	8003fb4 <CAN_id_valid>
 8004048:	2800      	cmp	r0, #0
 800404a:	bf18      	it	ne
 800404c:	f06f 0002 	mvnne.w	r0, #2
 8004050:	bd70      	pop	{r4, r5, r6, pc}
		{ // Here, Odd chars -> low ord nibble of byte
			*pcmprs++ |= hxbn[(u8)(*pin)];	// Add nibble.  Byte complete.  Advance pointer.
		}
		pin ++; ct +=1;
	}
	if (ct >= PCTOGATEWAYSIZE)	return -5; // Error: run-away (no terminator)
 8004052:	f06f 0004 	mvn.w	r0, #4
 8004056:	bd70      	pop	{r4, r5, r6, pc}
	/* Compute size of resulting binary msg. */
	ptr->cmprs.ct = (pcmprs - &ptr->cmprs.cm[0]);

	/* Validity check */
	x = (u8)(ptr->cmprs.cm[4]);		// Should be the dlc
	if ( x > 8 ) return -1;		// Return: too many bytes for payload count
 8004058:	f04f 30ff 	mov.w	r0, #4294967295
 800405c:	bd70      	pop	{r4, r5, r6, pc}

	if (ptr->cmprs.ct != (x + 5)) return -2; // Size inconsistent with dlc count
 800405e:	f06f 0001 	mvn.w	r0, #1
	id = (u32)(ptr->cmprs.cm[0]);		// Get ID in binary word form
	if (CAN_id_valid(id) != 0) return -3;	// Bits in extended field, but 11 bit id specified
	
	return 0;
}
 8004062:	bd70      	pop	{r4, r5, r6, pc}
 8004064:	0800fffc 	.word	0x0800fffc

08004068 <PC_msg_prep>:
 * ************************************************************************************** */
/*
Note, in the very worst-case the output may be over (2*ct+3) the size of the input.
*/
int PC_msg_prep(u8* pout, int outsize, u8* pin, int ct)
{
 8004068:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800406a:	4604      	mov	r4, r0
	u8 *p1 = pin;	// Redundant?
	u8 *p2 = pout;	// Working pointer
	u8 *p2e = pout + outsize; // End of output buffer pointer
 800406c:	1846      	adds	r6, r0, r1
	u8 chk;		// Checksum computed on input bytes
	int i;

	/* Compute chksum on input message. */
	chk = CANgenchksum(pin, ct);
 800406e:	4610      	mov	r0, r2
 8004070:	4619      	mov	r1, r3
 * ************************************************************************************** */
/*
Note, in the very worst-case the output may be over (2*ct+3) the size of the input.
*/
int PC_msg_prep(u8* pout, int outsize, u8* pin, int ct)
{
 8004072:	4615      	mov	r5, r2
 8004074:	461f      	mov	r7, r3
	u8 *p2e = pout + outsize; // End of output buffer pointer
	u8 chk;		// Checksum computed on input bytes
	int i;

	/* Compute chksum on input message. */
	chk = CANgenchksum(pin, ct);
 8004076:	f7ff feac 	bl	8003dd2 <CANgenchksum>
Note, in the very worst-case the output may be over (2*ct+3) the size of the input.
*/
int PC_msg_prep(u8* pout, int outsize, u8* pin, int ct)
{
	u8 *p1 = pin;	// Redundant?
	u8 *p2 = pout;	// Working pointer
 800407a:	4623      	mov	r3, r4

	/* Compute chksum on input message. */
	chk = CANgenchksum(pin, ct);
	
	/* Set up CAN msg with byte stuffing in output buffer. */
	for (i = 0; i < ct; i++)
 800407c:	2200      	movs	r2, #0
 800407e:	e015      	b.n	80040ac <PC_msg_prep+0x44>
	{
		if ((*p1 == CAN_PC_FRAMEBOUNDARY) || (*p1 == CAN_PC_ESCAPE) )
 8004080:	5ca9      	ldrb	r1, [r5, r2]
 8004082:	290a      	cmp	r1, #10
 8004084:	d001      	beq.n	800408a <PC_msg_prep+0x22>
 8004086:	297d      	cmp	r1, #125	; 0x7d
 8004088:	d107      	bne.n	800409a <PC_msg_prep+0x32>
		{
			*p2++ = (CAN_PC_ESCAPE); // Precede the following char with an escape byte
 800408a:	4619      	mov	r1, r3
 800408c:	f04f 0c7d 	mov.w	ip, #125	; 0x7d
 8004090:	f801 cb01 	strb.w	ip, [r1], #1
			if (p2 >= p2e) p2--;  // Prevent some bozo from overrunning the buffer.
 8004094:	42b1      	cmp	r1, r6
 8004096:	bf38      	it	cc
 8004098:	460b      	movcc	r3, r1
		}
		*p2++ = *p1++;		// Place the real byte with precision.
 800409a:	f815 c002 	ldrb.w	ip, [r5, r2]
 800409e:	4619      	mov	r1, r3
 80040a0:	f801 cb01 	strb.w	ip, [r1], #1

	/* Compute chksum on input message. */
	chk = CANgenchksum(pin, ct);
	
	/* Set up CAN msg with byte stuffing in output buffer. */
	for (i = 0; i < ct; i++)
 80040a4:	3201      	adds	r2, #1
 80040a6:	42b1      	cmp	r1, r6
 80040a8:	bf38      	it	cc
 80040aa:	460b      	movcc	r3, r1
 80040ac:	42ba      	cmp	r2, r7
 80040ae:	dbe7      	blt.n	8004080 <PC_msg_prep+0x18>
		*p2++ = *p1++;		// Place the real byte with precision.
		if (p2 >= p2e) p2 -= 1; // Prevent buffer overflow by a thoughtless scoundrel.
	}

	/* Set up chksum byte stuffing in output buffer. */
	if ((chk == CAN_PC_FRAMEBOUNDARY) || (chk == CAN_PC_ESCAPE) )
 80040b0:	280a      	cmp	r0, #10
 80040b2:	d001      	beq.n	80040b8 <PC_msg_prep+0x50>
 80040b4:	287d      	cmp	r0, #125	; 0x7d
 80040b6:	d106      	bne.n	80040c6 <PC_msg_prep+0x5e>
	{
		*p2++ = (CAN_PC_ESCAPE); // Precede following char with escape
 80040b8:	461a      	mov	r2, r3
 80040ba:	217d      	movs	r1, #125	; 0x7d
 80040bc:	f802 1b01 	strb.w	r1, [r2], #1
		if (p2 >= p2e) p2--;  	// Prevent some jerk from jamming too many bytes.
 80040c0:	42b2      	cmp	r2, r6
 80040c2:	bf38      	it	cc
 80040c4:	4613      	movcc	r3, r2
	}
	*p2++ = chk;			// Quietly place the checksum.
 80040c6:	461a      	mov	r2, r3
 80040c8:	f802 0b01 	strb.w	r0, [r2], #1
	if (p2 >= p2e) p2--; 		// Prevent buffer overflow by some nefarious nerd.

	*p2++ = (CAN_PC_FRAMEBOUNDARY);	// Set up End of Frame byte
 80040cc:	42b2      	cmp	r2, r6
 80040ce:	bf28      	it	cs
 80040d0:	461a      	movcs	r2, r3
 80040d2:	230a      	movs	r3, #10
 80040d4:	f802 3b01 	strb.w	r3, [r2], #1

	return (p2 - pout);		// Return number of bytes in output
}
 80040d8:	1b10      	subs	r0, r2, r4
 80040da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080040dc <PC_msg_prepASCII>:

int PC_msg_prepASCII(char* pout, int outsize, struct PCTOGATECOMPRESSED* p)
{
	u8* pin = &p->cm[0];	// Pointer to CAN binary msg
	char *p2 = pout;	// Working pointer
	char *p2e = pout + outsize - 4; // End of output buffer pointer (less checksum and newline)
 80040dc:	3904      	subs	r1, #4
11 = 1st byte, 22 = 2nd byte, (ascii/hex)
CC = checksum byte (ascii/hex) (checksum is made on binary data, including sequence number byte)
*/

int PC_msg_prepASCII(char* pout, int outsize, struct PCTOGATECOMPRESSED* p)
{
 80040de:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80040e2:	4604      	mov	r4, r0
	u8* pin = &p->cm[0];	// Pointer to CAN binary msg
	char *p2 = pout;	// Working pointer
	char *p2e = pout + outsize - 4; // End of output buffer pointer (less checksum and newline)
 80040e4:	eb00 0801 	add.w	r8, r0, r1
	u8 chk;			// Checksum computed on input bytes
	int i = 0;		// Counter for copying

	/* Compute checksum on binary message, including sequence number */
	chk = CANgenchksum(&p->cm[0], p->ct);
 80040e8:	4610      	mov	r0, r2
 80040ea:	f9b2 101c 	ldrsh.w	r1, [r2, #28]
11 = 1st byte, 22 = 2nd byte, (ascii/hex)
CC = checksum byte (ascii/hex) (checksum is made on binary data, including sequence number byte)
*/

int PC_msg_prepASCII(char* pout, int outsize, struct PCTOGATECOMPRESSED* p)
{
 80040ee:	4616      	mov	r6, r2
	char *p2e = pout + outsize - 4; // End of output buffer pointer (less checksum and newline)
	u8 chk;			// Checksum computed on input bytes
	int i = 0;		// Counter for copying

	/* Compute checksum on binary message, including sequence number */
	chk = CANgenchksum(&p->cm[0], p->ct);
 80040f0:	f7ff fe6f 	bl	8003dd2 <CANgenchksum>
	
	/* Convert binary input message to ASCII/HEX output message */
	while ((p2 < p2e) && (i++ < p->ct)) 
 80040f4:	2500      	movs	r5, #0
	char *p2e = pout + outsize - 4; // End of output buffer pointer (less checksum and newline)
	u8 chk;			// Checksum computed on input bytes
	int i = 0;		// Counter for copying

	/* Compute checksum on binary message, including sequence number */
	chk = CANgenchksum(&p->cm[0], p->ct);
 80040f6:	4607      	mov	r7, r0
*/

int PC_msg_prepASCII(char* pout, int outsize, struct PCTOGATECOMPRESSED* p)
{
	u8* pin = &p->cm[0];	// Pointer to CAN binary msg
	char *p2 = pout;	// Working pointer
 80040f8:	4620      	mov	r0, r4

	/* Compute checksum on binary message, including sequence number */
	chk = CANgenchksum(&p->cm[0], p->ct);
	
	/* Convert binary input message to ASCII/HEX output message */
	while ((p2 < p2e) && (i++ < p->ct)) 
 80040fa:	e003      	b.n	8004104 <PC_msg_prepASCII+0x28>
		p2 = hex(p2, *pin++);
 80040fc:	5d71      	ldrb	r1, [r6, r5]
 80040fe:	f7ff fe2f 	bl	8003d60 <hex>
 8004102:	3501      	adds	r5, #1

	/* Compute checksum on binary message, including sequence number */
	chk = CANgenchksum(&p->cm[0], p->ct);
	
	/* Convert binary input message to ASCII/HEX output message */
	while ((p2 < p2e) && (i++ < p->ct)) 
 8004104:	4540      	cmp	r0, r8
 8004106:	d203      	bcs.n	8004110 <PC_msg_prepASCII+0x34>
 8004108:	f9b6 301c 	ldrsh.w	r3, [r6, #28]
 800410c:	429d      	cmp	r5, r3
 800410e:	dbf5      	blt.n	80040fc <PC_msg_prepASCII+0x20>
		p2 = hex(p2, *pin++);

	/* Add checksum to line */
	p2 = hex(p2, chk);
 8004110:	4639      	mov	r1, r7
 8004112:	f7ff fe25 	bl	8003d60 <hex>

	/* Add terminator we have chosen ('\n') */
	*p2++ = ASCIIMSGTERMINATOR;
 8004116:	230a      	movs	r3, #10
 8004118:	f800 3b01 	strb.w	r3, [r0], #1
//if (p->ct >= 16) while(1==1);
	return (p2 - pout);	// Return number of bytes in output	
}
 800411c:	1b00      	subs	r0, r0, r4
 800411e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08004122 <CANcompress>:
static void strhalfwrd(u8* pout, u32 x)
{ // Store u32 in byte array
	*pout++ = (u8)x; *pout++ = (x >> 8); return;
}
int CANcompress(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pin)
{
 8004122:	b570      	push	{r4, r5, r6, lr}
 8004124:	4604      	mov	r4, r0

	u32 i;
	int ret;
	u32 tmp;
	/* Identify id types--11b, 29b, faux CAN id. */
	ret = CAN_id_valid(pin->id);
 8004126:	6808      	ldr	r0, [r1, #0]
static void strhalfwrd(u8* pout, u32 x)
{ // Store u32 in byte array
	*pout++ = (u8)x; *pout++ = (x >> 8); return;
}
int CANcompress(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pin)
{
 8004128:	460e      	mov	r6, r1

	u32 i;
	int ret;
	u32 tmp;
	/* Identify id types--11b, 29b, faux CAN id. */
	ret = CAN_id_valid(pin->id);
 800412a:	f7ff ff43 	bl	8003fb4 <CAN_id_valid>
	if (ret < 0) return ret;	// Return: not a valid CAN bus msg id
 800412e:	2800      	cmp	r0, #0
 8004130:	db3d      	blt.n	80041ae <CANcompress+0x8c>

	pout->cm[0] = pout->seq;	// Place sequence number ahead of CAN msg bytes
 8004132:	7fa3      	ldrb	r3, [r4, #30]
 8004134:	7023      	strb	r3, [r4, #0]

	tmp = (pin->dlc & 0xf);
 8004136:	6875      	ldr	r5, [r6, #4]
 8004138:	f005 050f 	and.w	r5, r5, #15
	
	if (ret > 0)
 800413c:	d015      	beq.n	800416a <CANcompress+0x48>
	{ // Here, 29 bit id msg
		strwrd( &pout->cm[1], ( pin->id | 0x1 ) ); // Low ord bit ON
 800413e:	6831      	ldr	r1, [r6, #0]
 8004140:	1c60      	adds	r0, r4, #1
 8004142:	f041 0101 	orr.w	r1, r1, #1
 8004146:	f7ff fe2f 	bl	8003da8 <strwrd>

		if (tmp > 8) return -1;	// JIC a bogus count
 800414a:	2d08      	cmp	r5, #8
 800414c:	d82a      	bhi.n	80041a4 <CANcompress+0x82>
		pout->cm[5] = (u8)tmp;
 800414e:	7165      	strb	r5, [r4, #5]

		for (i = 0; i < tmp; i++)	// Copy payload
 8004150:	2300      	movs	r3, #0
 8004152:	e004      	b.n	800415e <CANcompress+0x3c>
}
static void strhalfwrd(u8* pout, u32 x)
{ // Store u32 in byte array
	*pout++ = (u8)x; *pout++ = (x >> 8); return;
}
int CANcompress(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pin)
 8004154:	18f1      	adds	r1, r6, r3

		if (tmp > 8) return -1;	// JIC a bogus count
		pout->cm[5] = (u8)tmp;

		for (i = 0; i < tmp; i++)	// Copy payload
			pout->cm[i+6] = pin->cd.u8[i];
 8004156:	7a09      	ldrb	r1, [r1, #8]
}
static void strhalfwrd(u8* pout, u32 x)
{ // Store u32 in byte array
	*pout++ = (u8)x; *pout++ = (x >> 8); return;
}
int CANcompress(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pin)
 8004158:	18e2      	adds	r2, r4, r3

		if (tmp > 8) return -1;	// JIC a bogus count
		pout->cm[5] = (u8)tmp;

		for (i = 0; i < tmp; i++)	// Copy payload
			pout->cm[i+6] = pin->cd.u8[i];
 800415a:	7191      	strb	r1, [r2, #6]
		strwrd( &pout->cm[1], ( pin->id | 0x1 ) ); // Low ord bit ON

		if (tmp > 8) return -1;	// JIC a bogus count
		pout->cm[5] = (u8)tmp;

		for (i = 0; i < tmp; i++)	// Copy payload
 800415c:	3301      	adds	r3, #1
 800415e:	42ab      	cmp	r3, r5
 8004160:	d1f8      	bne.n	8004154 <CANcompress+0x32>
			pout->cm[i+6] = pin->cd.u8[i];

		pout->ct = (tmp + 6);	// Save number of bytes in compressed msg
 8004162:	3306      	adds	r3, #6
 8004164:	83a3      	strh	r3, [r4, #28]
		return 0;
 8004166:	2000      	movs	r0, #0
 8004168:	bd70      	pop	{r4, r5, r6, pc}
	}
	/* Here, 11 bit id msg */
	if (tmp > 8) return -2;		// JIC a bogus count
 800416a:	2d08      	cmp	r5, #8
 800416c:	d81d      	bhi.n	80041aa <CANcompress+0x88>

	pout->ct = (tmp + 3);	// Save number of bytes in compressed msg (w seq number)
 800416e:	1ceb      	adds	r3, r5, #3
 8004170:	83a3      	strh	r3, [r4, #28]

	if ((pin->id & 0x2) != 0) // Check RTR bit
 8004172:	6833      	ldr	r3, [r6, #0]
 8004174:	f013 0f02 	tst.w	r3, #2
 8004178:	d109      	bne.n	800418e <CANcompress+0x6c>
 800417a:	4603      	mov	r3, r0
 800417c:	e004      	b.n	8004188 <CANcompress+0x66>
}
static void strhalfwrd(u8* pout, u32 x)
{ // Store u32 in byte array
	*pout++ = (u8)x; *pout++ = (x >> 8); return;
}
int CANcompress(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pin)
 800417e:	18f1      	adds	r1, r6, r3
		tmp = 9; // RTR code 9 means dlc = 0
	}
	else
	{
		for (i = 0; i < tmp; i++) // Copy payload
			pout->cm[i+3] = pin->cd.u8[i];
 8004180:	7a09      	ldrb	r1, [r1, #8]
}
static void strhalfwrd(u8* pout, u32 x)
{ // Store u32 in byte array
	*pout++ = (u8)x; *pout++ = (x >> 8); return;
}
int CANcompress(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pin)
 8004182:	18e2      	adds	r2, r4, r3
		tmp = 9; // RTR code 9 means dlc = 0
	}
	else
	{
		for (i = 0; i < tmp; i++) // Copy payload
			pout->cm[i+3] = pin->cd.u8[i];
 8004184:	70d1      	strb	r1, [r2, #3]
	{ // Here, give RTR a special dlc count
		tmp = 9; // RTR code 9 means dlc = 0
	}
	else
	{
		for (i = 0; i < tmp; i++) // Copy payload
 8004186:	3301      	adds	r3, #1
 8004188:	42ab      	cmp	r3, r5
 800418a:	d1f8      	bne.n	800417e <CANcompress+0x5c>
 800418c:	e000      	b.n	8004190 <CANcompress+0x6e>

	pout->ct = (tmp + 3);	// Save number of bytes in compressed msg (w seq number)

	if ((pin->id & 0x2) != 0) // Check RTR bit
	{ // Here, give RTR a special dlc count
		tmp = 9; // RTR code 9 means dlc = 0
 800418e:	2509      	movs	r5, #9
	{
		for (i = 0; i < tmp; i++) // Copy payload
			pout->cm[i+3] = pin->cd.u8[i];
	}
	/* 11b id plus dlc|rtr  */
	strhalfwrd( &pout->cm[1], (pin->id >> 16) );
 8004190:	6833      	ldr	r3, [r6, #0]
 8004192:	0c1a      	lsrs	r2, r3, #16
{ // Store u32 in byte array
	*pout++ = (u8)x; *pout++ = (x >> 8); *pout++ = (x >> 16); *pout = (x >> 24); return;
}
static void strhalfwrd(u8* pout, u32 x)
{ // Store u32 in byte array
	*pout++ = (u8)x; *pout++ = (x >> 8); return;
 8004194:	0e1b      	lsrs	r3, r3, #24
 8004196:	70a3      	strb	r3, [r4, #2]
		for (i = 0; i < tmp; i++) // Copy payload
			pout->cm[i+3] = pin->cd.u8[i];
	}
	/* 11b id plus dlc|rtr  */
	strhalfwrd( &pout->cm[1], (pin->id >> 16) );
	pout->cm[1] &= ~0x1f;
 8004198:	f022 031f 	bic.w	r3, r2, #31
	pout->cm[1] |= (u8)(tmp << 1);	
 800419c:	ea43 0545 	orr.w	r5, r3, r5, lsl #1
 80041a0:	7065      	strb	r5, [r4, #1]

	return 0;
 80041a2:	bd70      	pop	{r4, r5, r6, pc}
	
	if (ret > 0)
	{ // Here, 29 bit id msg
		strwrd( &pout->cm[1], ( pin->id | 0x1 ) ); // Low ord bit ON

		if (tmp > 8) return -1;	// JIC a bogus count
 80041a4:	f04f 30ff 	mov.w	r0, #4294967295
 80041a8:	bd70      	pop	{r4, r5, r6, pc}

		pout->ct = (tmp + 6);	// Save number of bytes in compressed msg
		return 0;
	}
	/* Here, 11 bit id msg */
	if (tmp > 8) return -2;		// JIC a bogus count
 80041aa:	f06f 0001 	mvn.w	r0, #1
	strhalfwrd( &pout->cm[1], (pin->id >> 16) );
	pout->cm[1] &= ~0x1f;
	pout->cm[1] |= (u8)(tmp << 1);	

	return 0;
}
 80041ae:	bd70      	pop	{r4, r5, r6, pc}

080041b0 <CANcompress_G>:
 *		: pout->c[] = msg bytes
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANcompress_G(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pcan)
{
 80041b0:	b538      	push	{r3, r4, r5, lr}
	u32 i;
	u32 tmp;

	pout->cm[0] = pout->seq;		// Place sequence number ahead of CAN msg bytes
 80041b2:	7f83      	ldrb	r3, [r0, #30]
 *		: pout->c[] = msg bytes
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANcompress_G(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pcan)
{
 80041b4:	4604      	mov	r4, r0
	u32 i;
	u32 tmp;

	pout->cm[0] = pout->seq;		// Place sequence number ahead of CAN msg bytes
 80041b6:	f800 3b01 	strb.w	r3, [r0], #1
 *		: pout->c[] = msg bytes
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANcompress_G(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pcan)
{
 80041ba:	460d      	mov	r5, r1
	u32 i;
	u32 tmp;

	pout->cm[0] = pout->seq;		// Place sequence number ahead of CAN msg bytes
	strwrd( &pout->cm[1], pcan->id );	// 
 80041bc:	6809      	ldr	r1, [r1, #0]
 80041be:	f7ff fdf3 	bl	8003da8 <strwrd>
	tmp = (pcan->dlc & 0xf);
 80041c2:	686a      	ldr	r2, [r5, #4]
 80041c4:	f002 020f 	and.w	r2, r2, #15

	if (tmp > 8) return -1;
 80041c8:	2a08      	cmp	r2, #8
 80041ca:	d80d      	bhi.n	80041e8 <CANcompress_G+0x38>
	pout->cm[5] = tmp;
 80041cc:	7162      	strb	r2, [r4, #5]

	for (i = 0; i < tmp; i++)	// Copy payload
 80041ce:	2300      	movs	r3, #0
 80041d0:	e004      	b.n	80041dc <CANcompress_G+0x2c>
 *		: pout->ct = total number of bytes in compressed msg
 *		: pout->c[] = msg bytes
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANcompress_G(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pcan)
 80041d2:	18e8      	adds	r0, r5, r3

	if (tmp > 8) return -1;
	pout->cm[5] = tmp;

	for (i = 0; i < tmp; i++)	// Copy payload
		pout->cm[i+6] = pcan->cd.u8[i];
 80041d4:	7a00      	ldrb	r0, [r0, #8]
 *		: pout->ct = total number of bytes in compressed msg
 *		: pout->c[] = msg bytes
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANcompress_G(struct PCTOGATECOMPRESSED* pout, struct CANRCVBUF* pcan)
 80041d6:	18e1      	adds	r1, r4, r3

	if (tmp > 8) return -1;
	pout->cm[5] = tmp;

	for (i = 0; i < tmp; i++)	// Copy payload
		pout->cm[i+6] = pcan->cd.u8[i];
 80041d8:	7188      	strb	r0, [r1, #6]
	tmp = (pcan->dlc & 0xf);

	if (tmp > 8) return -1;
	pout->cm[5] = tmp;

	for (i = 0; i < tmp; i++)	// Copy payload
 80041da:	3301      	adds	r3, #1
 80041dc:	4293      	cmp	r3, r2
 80041de:	d1f8      	bne.n	80041d2 <CANcompress_G+0x22>
		pout->cm[i+6] = pcan->cd.u8[i];

	pout->ct = (tmp + 6);	// Save number of bytes in compressed msg
 80041e0:	3306      	adds	r3, #6
 80041e2:	83a3      	strh	r3, [r4, #28]

	return 0;
 80041e4:	2000      	movs	r0, #0
 80041e6:	bd38      	pop	{r3, r4, r5, pc}

	pout->cm[0] = pout->seq;		// Place sequence number ahead of CAN msg bytes
	strwrd( &pout->cm[1], pcan->id );	// 
	tmp = (pcan->dlc & 0xf);

	if (tmp > 8) return -1;
 80041e8:	f04f 30ff 	mov.w	r0, #4294967295
		pout->cm[i+6] = pcan->cd.u8[i];

	pout->ct = (tmp + 6);	// Save number of bytes in compressed msg

	return 0;
}
 80041ec:	bd38      	pop	{r3, r4, r5, pc}

080041ee <CANuncompress>:
{
	return ((*(p+1) << 8) | (*p + 0));
}

int CANuncompress(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
{
 80041ee:	b570      	push	{r4, r5, r6, lr}
	u32 i;
	u32 tmp = 0;
	if ((pin->cm[1] & 0x01) != 0)	// Is this an 11 bit or 29 bit id?
 80041f0:	784b      	ldrb	r3, [r1, #1]
{
	return ((*(p+1) << 8) | (*p + 0));
}

int CANuncompress(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
{
 80041f2:	460d      	mov	r5, r1
	u32 i;
	u32 tmp = 0;
	if ((pin->cm[1] & 0x01) != 0)	// Is this an 11 bit or 29 bit id?
 80041f4:	f013 0101 	ands.w	r1, r3, #1
{
	return ((*(p+1) << 8) | (*p + 0));
}

int CANuncompress(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
{
 80041f8:	4604      	mov	r4, r0
 80041fa:	8bae      	ldrh	r6, [r5, #28]
	u32 i;
	u32 tmp = 0;
	if ((pin->cm[1] & 0x01) != 0)	// Is this an 11 bit or 29 bit id?
 80041fc:	d019      	beq.n	8004232 <CANuncompress+0x44>
	{ // Here, a 29 bit 
		if (pin->ct < 6) return -1;	// Too few bytes to a valid 29b compressed msg
 80041fe:	b236      	sxth	r6, r6
 8004200:	2e05      	cmp	r6, #5
 8004202:	dd3b      	ble.n	800427c <CANuncompress+0x8e>
		pout->id = getwd (&pin->cm[1]);	// Get 4 bytes into word format
 8004204:	1c68      	adds	r0, r5, #1
 8004206:	f7ff fdd9 	bl	8003dbc <getwd>
		pout->id &= ~0x1;		// Low bit OFF (reserved for hardware transmit trigger)
 800420a:	f020 0001 	bic.w	r0, r0, #1
 800420e:	6020      	str	r0, [r4, #0]

		tmp = pin->cm[5];		// dlc byte
 8004210:	796a      	ldrb	r2, [r5, #5]
		if (tmp > 8)	return -2;	// dlc: payload ct too large (> 8)
 8004212:	2a08      	cmp	r2, #8
 8004214:	d835      	bhi.n	8004282 <CANuncompress+0x94>
		pout->dlc = tmp;
		
		if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count
 8004216:	1d93      	adds	r3, r2, #6
 8004218:	429e      	cmp	r6, r3
		pout->id = getwd (&pin->cm[1]);	// Get 4 bytes into word format
		pout->id &= ~0x1;		// Low bit OFF (reserved for hardware transmit trigger)

		tmp = pin->cm[5];		// dlc byte
		if (tmp > 8)	return -2;	// dlc: payload ct too large (> 8)
		pout->dlc = tmp;
 800421a:	6062      	str	r2, [r4, #4]
		
		if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count
 800421c:	d134      	bne.n	8004288 <CANuncompress+0x9a>
 800421e:	2300      	movs	r3, #0
 8004220:	e004      	b.n	800422c <CANuncompress+0x3e>
static u32 gethalfwd(u8* p) // Move non-aligned bytes into a 2 byte half-word
{
	return ((*(p+1) << 8) | (*p + 0));
}

int CANuncompress(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
 8004222:	18e8      	adds	r0, r5, r3
		pout->dlc = tmp;
		
		if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count

		for (i = 0; i < tmp; i++)	// Copy payload
			pout->cd.u8[i] = pin->cm[i + 5];
 8004224:	7940      	ldrb	r0, [r0, #5]
static u32 gethalfwd(u8* p) // Move non-aligned bytes into a 2 byte half-word
{
	return ((*(p+1) << 8) | (*p + 0));
}

int CANuncompress(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
 8004226:	18e1      	adds	r1, r4, r3
		pout->dlc = tmp;
		
		if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count

		for (i = 0; i < tmp; i++)	// Copy payload
			pout->cd.u8[i] = pin->cm[i + 5];
 8004228:	7208      	strb	r0, [r1, #8]
		if (tmp > 8)	return -2;	// dlc: payload ct too large (> 8)
		pout->dlc = tmp;
		
		if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count

		for (i = 0; i < tmp; i++)	// Copy payload
 800422a:	3301      	adds	r3, #1
 800422c:	4293      	cmp	r3, r2
 800422e:	d3f8      	bcc.n	8004222 <CANuncompress+0x34>
 8004230:	e022      	b.n	8004278 <CANuncompress+0x8a>
			pout->cd.u8[i] = pin->cm[i + 5];
		return 0;	// Success with 29 bit id msg.
	}
	/* Here, an 11 bit id. */
	if (pin->ct < 3) return -4;		// Too few bytes to a valid 11b compressed msg
 8004232:	b232      	sxth	r2, r6
 8004234:	2a02      	cmp	r2, #2
 8004236:	dd2a      	ble.n	800428e <CANuncompress+0xa0>
{
	return ((*(p+3) << 24) | (*(p+2) << 16) | (*(p+1) << 8) | (*p + 0));
}
static u32 gethalfwd(u8* p) // Move non-aligned bytes into a 2 byte half-word
{
	return ((*(p+1) << 8) | (*p + 0));
 8004238:	78aa      	ldrb	r2, [r5, #2]
 800423a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	/* Here, an 11 bit id. */
	if (pin->ct < 3) return -4;		// Too few bytes to a valid 11b compressed msg

	/* Extract id and dlc|rtr from half word */
	tmp = gethalfwd (&pin->cm[1]);		// Get 2 bytes into half word form
	pout->id = ((tmp << 16) & 0xffe00000);	// Positon 11b id with dlc stripped.
 800423e:	095a      	lsrs	r2, r3, #5
	tmp = ((tmp >> 1) & 0xf);		// Extract dlc embedded in id's low ord bits
 8004240:	085b      	lsrs	r3, r3, #1
 8004242:	f003 030f 	and.w	r3, r3, #15
	/* Here, an 11 bit id. */
	if (pin->ct < 3) return -4;		// Too few bytes to a valid 11b compressed msg

	/* Extract id and dlc|rtr from half word */
	tmp = gethalfwd (&pin->cm[1]);		// Get 2 bytes into half word form
	pout->id = ((tmp << 16) & 0xffe00000);	// Positon 11b id with dlc stripped.
 8004246:	0552      	lsls	r2, r2, #21
	tmp = ((tmp >> 1) & 0xf);		// Extract dlc embedded in id's low ord bits
	pout->dlc = tmp;			// Set payload byte ct

	if (tmp > 9)	return -5;		// dlc: payload ct too large (> 8)
 8004248:	2b09      	cmp	r3, #9
	/* Here, an 11 bit id. */
	if (pin->ct < 3) return -4;		// Too few bytes to a valid 11b compressed msg

	/* Extract id and dlc|rtr from half word */
	tmp = gethalfwd (&pin->cm[1]);		// Get 2 bytes into half word form
	pout->id = ((tmp << 16) & 0xffe00000);	// Positon 11b id with dlc stripped.
 800424a:	6002      	str	r2, [r0, #0]
	tmp = ((tmp >> 1) & 0xf);		// Extract dlc embedded in id's low ord bits
	pout->dlc = tmp;			// Set payload byte ct
 800424c:	6043      	str	r3, [r0, #4]

	if (tmp > 9)	return -5;		// dlc: payload ct too large (> 8)
 800424e:	d821      	bhi.n	8004294 <CANuncompress+0xa6>
	if (tmp == 9)				// Check for RTR
 8004250:	d103      	bne.n	800425a <CANuncompress+0x6c>
	{ // Here, dlc count code means RTR
		pout->id |= 0x2;		// Set RTR bit in id
 8004252:	f042 0202 	orr.w	r2, r2, #2
 8004256:	6002      	str	r2, [r0, #0]
		pout->dlc = 0;			// RTR only has zero payload ct
 8004258:	6041      	str	r1, [r0, #4]
	}

	if (pin->ct != (s16)(3 + pout->dlc)) return -6; // dlc doesn't match byte count
 800425a:	6862      	ldr	r2, [r4, #4]
 800425c:	b236      	sxth	r6, r6
 800425e:	1cd3      	adds	r3, r2, #3
 8004260:	b21b      	sxth	r3, r3
 8004262:	429e      	cmp	r6, r3
 8004264:	d119      	bne.n	800429a <CANuncompress+0xac>
 8004266:	2300      	movs	r3, #0
 8004268:	e004      	b.n	8004274 <CANuncompress+0x86>
static u32 gethalfwd(u8* p) // Move non-aligned bytes into a 2 byte half-word
{
	return ((*(p+1) << 8) | (*p + 0));
}

int CANuncompress(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
 800426a:	18e8      	adds	r0, r5, r3
	}

	if (pin->ct != (s16)(3 + pout->dlc)) return -6; // dlc doesn't match byte count

	for (i = 0; i < pout->dlc; i++)		// Copy payload
		pout->cd.u8[i] = pin->cm[i + 3];
 800426c:	78c0      	ldrb	r0, [r0, #3]
static u32 gethalfwd(u8* p) // Move non-aligned bytes into a 2 byte half-word
{
	return ((*(p+1) << 8) | (*p + 0));
}

int CANuncompress(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
 800426e:	18e1      	adds	r1, r4, r3
	}

	if (pin->ct != (s16)(3 + pout->dlc)) return -6; // dlc doesn't match byte count

	for (i = 0; i < pout->dlc; i++)		// Copy payload
		pout->cd.u8[i] = pin->cm[i + 3];
 8004270:	7208      	strb	r0, [r1, #8]
		pout->dlc = 0;			// RTR only has zero payload ct
	}

	if (pin->ct != (s16)(3 + pout->dlc)) return -6; // dlc doesn't match byte count

	for (i = 0; i < pout->dlc; i++)		// Copy payload
 8004272:	3301      	adds	r3, #1
 8004274:	4293      	cmp	r3, r2
 8004276:	d1f8      	bne.n	800426a <CANuncompress+0x7c>
		pout->cd.u8[i] = pin->cm[i + 3];

	return 0;	// Success with 11 bit id msg.
 8004278:	2000      	movs	r0, #0
 800427a:	bd70      	pop	{r4, r5, r6, pc}
{
	u32 i;
	u32 tmp = 0;
	if ((pin->cm[1] & 0x01) != 0)	// Is this an 11 bit or 29 bit id?
	{ // Here, a 29 bit 
		if (pin->ct < 6) return -1;	// Too few bytes to a valid 29b compressed msg
 800427c:	f04f 30ff 	mov.w	r0, #4294967295
 8004280:	bd70      	pop	{r4, r5, r6, pc}
		pout->id = getwd (&pin->cm[1]);	// Get 4 bytes into word format
		pout->id &= ~0x1;		// Low bit OFF (reserved for hardware transmit trigger)

		tmp = pin->cm[5];		// dlc byte
		if (tmp > 8)	return -2;	// dlc: payload ct too large (> 8)
 8004282:	f06f 0001 	mvn.w	r0, #1
 8004286:	bd70      	pop	{r4, r5, r6, pc}
		pout->dlc = tmp;
		
		if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count
 8004288:	f06f 0002 	mvn.w	r0, #2
 800428c:	bd70      	pop	{r4, r5, r6, pc}
		for (i = 0; i < tmp; i++)	// Copy payload
			pout->cd.u8[i] = pin->cm[i + 5];
		return 0;	// Success with 29 bit id msg.
	}
	/* Here, an 11 bit id. */
	if (pin->ct < 3) return -4;		// Too few bytes to a valid 11b compressed msg
 800428e:	f06f 0003 	mvn.w	r0, #3
 8004292:	bd70      	pop	{r4, r5, r6, pc}
	tmp = gethalfwd (&pin->cm[1]);		// Get 2 bytes into half word form
	pout->id = ((tmp << 16) & 0xffe00000);	// Positon 11b id with dlc stripped.
	tmp = ((tmp >> 1) & 0xf);		// Extract dlc embedded in id's low ord bits
	pout->dlc = tmp;			// Set payload byte ct

	if (tmp > 9)	return -5;		// dlc: payload ct too large (> 8)
 8004294:	f06f 0004 	mvn.w	r0, #4
 8004298:	bd70      	pop	{r4, r5, r6, pc}
	{ // Here, dlc count code means RTR
		pout->id |= 0x2;		// Set RTR bit in id
		pout->dlc = 0;			// RTR only has zero payload ct
	}

	if (pin->ct != (s16)(3 + pout->dlc)) return -6; // dlc doesn't match byte count
 800429a:	f06f 0005 	mvn.w	r0, #5

	for (i = 0; i < pout->dlc; i++)		// Copy payload
		pout->cd.u8[i] = pin->cm[i + 3];

	return 0;	// Success with 11 bit id msg.
}
 800429e:	bd70      	pop	{r4, r5, r6, pc}

080042a0 <CANuncompress_G>:
 *		: -3 = dlc doesn't match byte count in a 29 bit id msg
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANuncompress_G(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
{
 80042a0:	b570      	push	{r4, r5, r6, lr}
	u32 i;
	u32 tmp = 0;

	if (pin->ct < 6) return -1;		// Too few bytes to a valid msg	
 80042a2:	f9b1 601c 	ldrsh.w	r6, [r1, #28]
 *		: -3 = dlc doesn't match byte count in a 29 bit id msg
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANuncompress_G(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
{
 80042a6:	4604      	mov	r4, r0
	u32 i;
	u32 tmp = 0;

	if (pin->ct < 6) return -1;		// Too few bytes to a valid msg	
 80042a8:	2e05      	cmp	r6, #5
 *		: -3 = dlc doesn't match byte count in a 29 bit id msg
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANuncompress_G(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
{
 80042aa:	460d      	mov	r5, r1
	u32 i;
	u32 tmp = 0;

	if (pin->ct < 6) return -1;		// Too few bytes to a valid msg	
 80042ac:	dd15      	ble.n	80042da <CANuncompress_G+0x3a>
	pout->id = getwd (&pin->cm[1]);		// Get 4 bytes into word format
 80042ae:	1c48      	adds	r0, r1, #1
 80042b0:	f7ff fd84 	bl	8003dbc <getwd>
 80042b4:	6020      	str	r0, [r4, #0]
	tmp = pin->cm[5];			// dlc byte
 80042b6:	796a      	ldrb	r2, [r5, #5]
	if (tmp > 8)	return -2;		// dlc: payload ct too large (> 8)
 80042b8:	2a08      	cmp	r2, #8
 80042ba:	d811      	bhi.n	80042e0 <CANuncompress_G+0x40>
	if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count
 80042bc:	1d93      	adds	r3, r2, #6
 80042be:	429e      	cmp	r6, r3
 80042c0:	d111      	bne.n	80042e6 <CANuncompress_G+0x46>
	pout->dlc = tmp;
 80042c2:	6062      	str	r2, [r4, #4]
	for (i = 0; i < tmp; i++)		// Copy payload
 80042c4:	2300      	movs	r3, #0
 80042c6:	e004      	b.n	80042d2 <CANuncompress_G+0x32>
 *		: -2 = dlc: payload ct too large (> 8) in a 29 bit id msg
 *		: -3 = dlc doesn't match byte count in a 29 bit id msg
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANuncompress_G(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
 80042c8:	18e8      	adds	r0, r5, r3
	tmp = pin->cm[5];			// dlc byte
	if (tmp > 8)	return -2;		// dlc: payload ct too large (> 8)
	if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count
	pout->dlc = tmp;
	for (i = 0; i < tmp; i++)		// Copy payload
		pout->cd.u8[i] = pin->cm[i + 6];
 80042ca:	7980      	ldrb	r0, [r0, #6]
 *		: -2 = dlc: payload ct too large (> 8) in a 29 bit id msg
 *		: -3 = dlc doesn't match byte count in a 29 bit id msg
 * Note: see '../svn_discoveryf4/docs/trunk/Userdocs/gateway_format.txt'
 * Note: 'cm[0] holds the sequence number
 * ************************************************************************************** */
int CANuncompress_G(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
 80042cc:	18e1      	adds	r1, r4, r3
	tmp = pin->cm[5];			// dlc byte
	if (tmp > 8)	return -2;		// dlc: payload ct too large (> 8)
	if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count
	pout->dlc = tmp;
	for (i = 0; i < tmp; i++)		// Copy payload
		pout->cd.u8[i] = pin->cm[i + 6];
 80042ce:	7208      	strb	r0, [r1, #8]
	pout->id = getwd (&pin->cm[1]);		// Get 4 bytes into word format
	tmp = pin->cm[5];			// dlc byte
	if (tmp > 8)	return -2;		// dlc: payload ct too large (> 8)
	if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count
	pout->dlc = tmp;
	for (i = 0; i < tmp; i++)		// Copy payload
 80042d0:	3301      	adds	r3, #1
 80042d2:	4293      	cmp	r3, r2
 80042d4:	d3f8      	bcc.n	80042c8 <CANuncompress_G+0x28>
		pout->cd.u8[i] = pin->cm[i + 6];
	return 0;	// Success with 29 bit id msg.
 80042d6:	2000      	movs	r0, #0
 80042d8:	bd70      	pop	{r4, r5, r6, pc}
int CANuncompress_G(struct CANRCVBUF* pout,  struct PCTOGATECOMPRESSED* pin)
{
	u32 i;
	u32 tmp = 0;

	if (pin->ct < 6) return -1;		// Too few bytes to a valid msg	
 80042da:	f04f 30ff 	mov.w	r0, #4294967295
 80042de:	bd70      	pop	{r4, r5, r6, pc}
	pout->id = getwd (&pin->cm[1]);		// Get 4 bytes into word format
	tmp = pin->cm[5];			// dlc byte
	if (tmp > 8)	return -2;		// dlc: payload ct too large (> 8)
 80042e0:	f06f 0001 	mvn.w	r0, #1
 80042e4:	bd70      	pop	{r4, r5, r6, pc}
	if (pin->ct != (s16)(6 + tmp)) return -3; // dlc doesn't match byte count
 80042e6:	f06f 0002 	mvn.w	r0, #2
	pout->dlc = tmp;
	for (i = 0; i < tmp; i++)		// Copy payload
		pout->cd.u8[i] = pin->cm[i + 6];
	return 0;	// Success with 29 bit id msg.
}
 80042ea:	bd70      	pop	{r4, r5, r6, pc}

080042ec <USB_PC_get_msg_mode>:
 *              : 1 = ascii-- mode 0 converted to ascii/hex, with '\n' new line framing
 *              : ... other modes in the future?
*/

int USB_PC_get_msg_mode(int fd, struct PCTOGATEWAY* ptr, struct CANRCVBUF* pcan )
{
 80042ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int retstatus;
	int temp = 0;
	char c;

	if (localct <= 0) // Is the buffer empty?
 80042ee:	4d36      	ldr	r5, [pc, #216]	; (80043c8 <USB_PC_get_msg_mode+0xdc>)
 *              : 1 = ascii-- mode 0 converted to ascii/hex, with '\n' new line framing
 *              : ... other modes in the future?
*/

int USB_PC_get_msg_mode(int fd, struct PCTOGATEWAY* ptr, struct CANRCVBUF* pcan )
{
 80042f0:	460c      	mov	r4, r1
	int retstatus;
	int temp = 0;
	char c;

	if (localct <= 0) // Is the buffer empty?
 80042f2:	682b      	ldr	r3, [r5, #0]
 *              : 1 = ascii-- mode 0 converted to ascii/hex, with '\n' new line framing
 *              : ... other modes in the future?
*/

int USB_PC_get_msg_mode(int fd, struct PCTOGATEWAY* ptr, struct CANRCVBUF* pcan )
{
 80042f4:	4616      	mov	r6, r2
	int retstatus;
	int temp = 0;
	char c;

	if (localct <= 0) // Is the buffer empty?
 80042f6:	2b00      	cmp	r3, #0
 80042f8:	dc10      	bgt.n	800431c <USB_PC_get_msg_mode+0x30>
	{ // Here yes.
		/* Try to replenish buffer if it is empty. */
		localct = read(fd, localbuf, GETLOCALBUFSZ); // Seek a fist-full, or more, bytes
 80042fa:	1d2f      	adds	r7, r5, #4
 80042fc:	4639      	mov	r1, r7
 80042fe:	f44f 7280 	mov.w	r2, #256	; 0x100
 8004302:	f004 f9e5 	bl	80086d0 <read>
		if (localct == 0) return  0;	// But, if alas, there were none, return empty handed :(
 8004306:	2800      	cmp	r0, #0
	char c;

	if (localct <= 0) // Is the buffer empty?
	{ // Here yes.
		/* Try to replenish buffer if it is empty. */
		localct = read(fd, localbuf, GETLOCALBUFSZ); // Seek a fist-full, or more, bytes
 8004308:	6028      	str	r0, [r5, #0]
		if (localct == 0) return  0;	// But, if alas, there were none, return empty handed :(
 800430a:	d054      	beq.n	80043b6 <USB_PC_get_msg_mode+0xca>
		if (localct  < 0) return -4;	// Ooops!
 800430c:	db55      	blt.n	80043ba <USB_PC_get_msg_mode+0xce>

		plocalbuf = &localbuf[0];	// Reset pointer for removing buffer bytes.
 800430e:	4b2f      	ldr	r3, [pc, #188]	; (80043cc <USB_PC_get_msg_mode+0xe0>)
 8004310:	601f      	str	r7, [r3, #0]
debug_inct += localct; // Debug: running ct of bytes
 8004312:	f8d5 7104 	ldr.w	r7, [r5, #260]	; 0x104
 8004316:	19c0      	adds	r0, r0, r7
 8004318:	f8c5 0104 	str.w	r0, [r5, #260]	; 0x104
	}

	switch (ptr->mode_link)	// To use 'switch' for just two cases is lame, but allows for easy addition of more modes.
 800431c:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
 8004320:	2b01      	cmp	r3, #1
 8004322:	d028      	beq.n	8004376 <USB_PC_get_msg_mode+0x8a>
 8004324:	d30f      	bcc.n	8004346 <USB_PC_get_msg_mode+0x5a>
 8004326:	2b02      	cmp	r3, #2
 8004328:	d14a      	bne.n	80043c0 <USB_PC_get_msg_mode+0xd4>
 800432a:	e03f      	b.n	80043ac <USB_PC_get_msg_mode+0xc0>
	{
	case 0:	// BINARY Mode (byte stuffing/frame byte format) 
		while (localct > 0)	// Onward through those bytes!
		{
			localct -= 1;		// Like a pacman, take a byte
 800432c:	4a26      	ldr	r2, [pc, #152]	; (80043c8 <USB_PC_get_msg_mode+0xdc>)
 800432e:	3b01      	subs	r3, #1
 8004330:	6013      	str	r3, [r2, #0]
			c = *plocalbuf++;	//   and move one step.
 8004332:	4a26      	ldr	r2, [pc, #152]	; (80043cc <USB_PC_get_msg_mode+0xe0>)
	
			if ( (retstatus = PC_msg_get(ptr,c)) != 0) // Did this byte complete a msg?
 8004334:	4620      	mov	r0, r4
	{
	case 0:	// BINARY Mode (byte stuffing/frame byte format) 
		while (localct > 0)	// Onward through those bytes!
		{
			localct -= 1;		// Like a pacman, take a byte
			c = *plocalbuf++;	//   and move one step.
 8004336:	6813      	ldr	r3, [r2, #0]
 8004338:	f813 1b01 	ldrb.w	r1, [r3], #1
 800433c:	6013      	str	r3, [r2, #0]
	
			if ( (retstatus = PC_msg_get(ptr,c)) != 0) // Did this byte complete a msg?
 800433e:	f7ff fdd9 	bl	8003ef4 <PC_msg_get>
 8004342:	1e07      	subs	r7, r0, #0
 8004344:	d110      	bne.n	8004368 <USB_PC_get_msg_mode+0x7c>
	}

	switch (ptr->mode_link)	// To use 'switch' for just two cases is lame, but allows for easy addition of more modes.
	{
	case 0:	// BINARY Mode (byte stuffing/frame byte format) 
		while (localct > 0)	// Onward through those bytes!
 8004346:	682b      	ldr	r3, [r5, #0]
 8004348:	2b00      	cmp	r3, #0
 800434a:	dcef      	bgt.n	800432c <USB_PC_get_msg_mode+0x40>
 800434c:	e031      	b.n	80043b2 <USB_PC_get_msg_mode+0xc6>
		break;

	case 1: // ASCII Mode (ascii/hex only with '\n' newline)
		while (localct > 0)	// Rattle through those chars!
		{
			localct -= 1;		// Count chars
 800434e:	4a1e      	ldr	r2, [pc, #120]	; (80043c8 <USB_PC_get_msg_mode+0xdc>)
 8004350:	3b01      	subs	r3, #1
 8004352:	6013      	str	r3, [r2, #0]
			c = *plocalbuf++;	
 8004354:	4a1d      	ldr	r2, [pc, #116]	; (80043cc <USB_PC_get_msg_mode+0xe0>)

			if ( (retstatus = PC_msg_getASCII(ptr, c)) != 0) // Did this char complete a msg?
 8004356:	4620      	mov	r0, r4

	case 1: // ASCII Mode (ascii/hex only with '\n' newline)
		while (localct > 0)	// Rattle through those chars!
		{
			localct -= 1;		// Count chars
			c = *plocalbuf++;	
 8004358:	6813      	ldr	r3, [r2, #0]
 800435a:	f813 1b01 	ldrb.w	r1, [r3], #1
 800435e:	6013      	str	r3, [r2, #0]

			if ( (retstatus = PC_msg_getASCII(ptr, c)) != 0) // Did this char complete a msg?
 8004360:	f7ff fd5b 	bl	8003e1a <PC_msg_getASCII>
 8004364:	1e07      	subs	r7, r0, #0
 8004366:	d006      	beq.n	8004376 <USB_PC_get_msg_mode+0x8a>
			{ // Here, either a good line, or an error, such as too many or few chars, checksum err, or odd number char pairs
				if (retstatus >= 1)
 8004368:	dd2c      	ble.n	80043c4 <USB_PC_get_msg_mode+0xd8>
					temp = CANuncompress(pcan, &ptr->cmprs); 
 800436a:	4630      	mov	r0, r6
 800436c:	f104 0140 	add.w	r1, r4, #64	; 0x40
 8004370:	f7ff ff3d 	bl	80041ee <CANuncompress>
 8004374:	e016      	b.n	80043a4 <USB_PC_get_msg_mode+0xb8>
			}		
		}
		break;

	case 1: // ASCII Mode (ascii/hex only with '\n' newline)
		while (localct > 0)	// Rattle through those chars!
 8004376:	682b      	ldr	r3, [r5, #0]
 8004378:	2b00      	cmp	r3, #0
 800437a:	dce8      	bgt.n	800434e <USB_PC_get_msg_mode+0x62>
 800437c:	e019      	b.n	80043b2 <USB_PC_get_msg_mode+0xc6>
		break;
		
	case 2: // ASCII Mode (Gonzaga project: minimal compression)
		while (localct > 0)	// Rattle through those chars!
		{
			localct -= 1;		// Count chars
 800437e:	4a12      	ldr	r2, [pc, #72]	; (80043c8 <USB_PC_get_msg_mode+0xdc>)
 8004380:	3b01      	subs	r3, #1
 8004382:	6013      	str	r3, [r2, #0]
			c = *plocalbuf++;
 8004384:	4a11      	ldr	r2, [pc, #68]	; (80043cc <USB_PC_get_msg_mode+0xe0>)
//xprintf(6,"%c",c);

			if ( (retstatus = PC_msg_getASCII(ptr, c)) != 0) // Did this char complete a msg?
 8004386:	4620      	mov	r0, r4
		
	case 2: // ASCII Mode (Gonzaga project: minimal compression)
		while (localct > 0)	// Rattle through those chars!
		{
			localct -= 1;		// Count chars
			c = *plocalbuf++;
 8004388:	6813      	ldr	r3, [r2, #0]
 800438a:	f813 1b01 	ldrb.w	r1, [r3], #1
 800438e:	6013      	str	r3, [r2, #0]
//xprintf(6,"%c",c);

			if ( (retstatus = PC_msg_getASCII(ptr, c)) != 0) // Did this char complete a msg?
 8004390:	f7ff fd43 	bl	8003e1a <PC_msg_getASCII>
 8004394:	1e07      	subs	r7, r0, #0
 8004396:	d009      	beq.n	80043ac <USB_PC_get_msg_mode+0xc0>
			{ // Here, either a good line, or an error, such as too many or few chars, checksum err, or odd number char pairs
				if (retstatus >= 1)
 8004398:	dd14      	ble.n	80043c4 <USB_PC_get_msg_mode+0xd8>
					temp = CANuncompress_G(pcan, &ptr->cmprs); 
 800439a:	4630      	mov	r0, r6
 800439c:	f104 0140 	add.w	r1, r4, #64	; 0x40
 80043a0:	f7ff ff7e 	bl	80042a0 <CANuncompress_G>
				if (temp < 0) return temp -= 4;
 80043a4:	2800      	cmp	r0, #0
 80043a6:	da0d      	bge.n	80043c4 <USB_PC_get_msg_mode+0xd8>
 80043a8:	1f07      	subs	r7, r0, #4
 80043aa:	e00b      	b.n	80043c4 <USB_PC_get_msg_mode+0xd8>
			}		
		}
		break;
		
	case 2: // ASCII Mode (Gonzaga project: minimal compression)
		while (localct > 0)	// Rattle through those chars!
 80043ac:	682b      	ldr	r3, [r5, #0]
 80043ae:	2b00      	cmp	r3, #0
 80043b0:	dce5      	bgt.n	800437e <USB_PC_get_msg_mode+0x92>

	default:	return -3; // The bozo calling this routine failed miserably setting up the struct.
		break;	
	}

	return 0; // No more bytes to work with, AND msg is not complete...sorry, maybe next time.
 80043b2:	2700      	movs	r7, #0
 80043b4:	e006      	b.n	80043c4 <USB_PC_get_msg_mode+0xd8>

	if (localct <= 0) // Is the buffer empty?
	{ // Here yes.
		/* Try to replenish buffer if it is empty. */
		localct = read(fd, localbuf, GETLOCALBUFSZ); // Seek a fist-full, or more, bytes
		if (localct == 0) return  0;	// But, if alas, there were none, return empty handed :(
 80043b6:	4607      	mov	r7, r0
 80043b8:	e004      	b.n	80043c4 <USB_PC_get_msg_mode+0xd8>
		if (localct  < 0) return -4;	// Ooops!
 80043ba:	f06f 0703 	mvn.w	r7, #3
 80043be:	e001      	b.n	80043c4 <USB_PC_get_msg_mode+0xd8>
			}		

		}
		break;

	default:	return -3; // The bozo calling this routine failed miserably setting up the struct.
 80043c0:	f06f 0702 	mvn.w	r7, #2
		break;	
	}

	return 0; // No more bytes to work with, AND msg is not complete...sorry, maybe next time.
}
 80043c4:	4638      	mov	r0, r7
 80043c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80043c8:	20000e5c 	.word	0x20000e5c
 80043cc:	20000154 	.word	0x20000154

080043d0 <USB_toPC_msgASCII>:
#define BUFFSIZE (PCTOGATEWAYSIZE*2+4)
static char b[BUFFSIZE];	// Sufficiently large output buffer
unsigned int debug_outct = 0; // Debug: Running count of outgoing chars

int USB_toPC_msgASCII(int fd, struct PCTOGATECOMPRESSED* p)
{
 80043d0:	b570      	push	{r4, r5, r6, lr}
	int sz;

	/* Convert binary to ascii, and prepare with sequence number at beginning, plus checksum and newline termination */
	sz = PC_msg_prepASCII(&b[0], BUFFSIZE, p);
 80043d2:	4c07      	ldr	r4, [pc, #28]	; (80043f0 <USB_toPC_msgASCII+0x20>)
#define BUFFSIZE (PCTOGATEWAYSIZE*2+4)
static char b[BUFFSIZE];	// Sufficiently large output buffer
unsigned int debug_outct = 0; // Debug: Running count of outgoing chars

int USB_toPC_msgASCII(int fd, struct PCTOGATECOMPRESSED* p)
{
 80043d4:	4605      	mov	r5, r0
 80043d6:	460a      	mov	r2, r1
	int sz;

	/* Convert binary to ascii, and prepare with sequence number at beginning, plus checksum and newline termination */
	sz = PC_msg_prepASCII(&b[0], BUFFSIZE, p);
 80043d8:	4620      	mov	r0, r4
 80043da:	2164      	movs	r1, #100	; 0x64
 80043dc:	f7ff fe7e 	bl	80040dc <PC_msg_prepASCII>

	/* Send to USB or other output */
	return	write(fd, b, sz);
 80043e0:	4621      	mov	r1, r4
int USB_toPC_msgASCII(int fd, struct PCTOGATECOMPRESSED* p)
{
	int sz;

	/* Convert binary to ascii, and prepare with sequence number at beginning, plus checksum and newline termination */
	sz = PC_msg_prepASCII(&b[0], BUFFSIZE, p);
 80043e2:	4602      	mov	r2, r0

	/* Send to USB or other output */
	return	write(fd, b, sz);
 80043e4:	4628      	mov	r0, r5
}
 80043e6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

	/* Convert binary to ascii, and prepare with sequence number at beginning, plus checksum and newline termination */
	sz = PC_msg_prepASCII(&b[0], BUFFSIZE, p);

	/* Send to USB or other output */
	return	write(fd, b, sz);
 80043ea:	f004 b97f 	b.w	80086ec <write>
 80043ee:	bf00      	nop
 80043f0:	20000f64 	.word	0x20000f64

080043f4 <USB_toPC_msgBIN>:
 * @brief	: fd = file descriptor
 * @param	: p = Pointer to struct with bytes to send to PC
 * @return	: count of bytes written
 * ************************************************************************************** */
int USB_toPC_msgBIN(int fd, struct PCTOGATECOMPRESSED* p)
{
 80043f4:	b510      	push	{r4, lr}
//for (i = 0; i < p->ct; i++)
//  xprintf(6,"%02x ",p->cm[i]);
//xprintf (6,"\n\r");

	/* Make an array with seq number, CAN msg. */
	if (p->ct >= PCTOGATEWAYSIZE) return -1; 	// Prevent overruns
 80043f6:	f9b1 301c 	ldrsh.w	r3, [r1, #28]
 * @brief	: fd = file descriptor
 * @param	: p = Pointer to struct with bytes to send to PC
 * @return	: count of bytes written
 * ************************************************************************************** */
int USB_toPC_msgBIN(int fd, struct PCTOGATECOMPRESSED* p)
{
 80043fa:	b09a      	sub	sp, #104	; 0x68
//for (i = 0; i < p->ct; i++)
//  xprintf(6,"%02x ",p->cm[i]);
//xprintf (6,"\n\r");

	/* Make an array with seq number, CAN msg. */
	if (p->ct >= PCTOGATEWAYSIZE) return -1; 	// Prevent overruns
 80043fc:	2b2f      	cmp	r3, #47	; 0x2f
 * @brief	: fd = file descriptor
 * @param	: p = Pointer to struct with bytes to send to PC
 * @return	: count of bytes written
 * ************************************************************************************** */
int USB_toPC_msgBIN(int fd, struct PCTOGATECOMPRESSED* p)
{
 80043fe:	4604      	mov	r4, r0
 8004400:	460a      	mov	r2, r1
//for (i = 0; i < p->ct; i++)
//  xprintf(6,"%02x ",p->cm[i]);
//xprintf (6,"\n\r");

	/* Make an array with seq number, CAN msg. */
	if (p->ct >= PCTOGATEWAYSIZE) return -1; 	// Prevent overruns
 8004402:	dc09      	bgt.n	8004418 <USB_toPC_msgBIN+0x24>
	/* Prepare msg for sending.  Add byte stuffing, framing, and checksum to input bytes. */
	sz = PC_msg_prep(&b[0], BUFFSIZE, &p->cm[0], p->ct);
 8004404:	2164      	movs	r1, #100	; 0x64
 8004406:	a801      	add	r0, sp, #4
 8004408:	f7ff fe2e 	bl	8004068 <PC_msg_prep>

	/* Send to USB, or other output per file descriptor. */
	return write(fd, b, sz); // Return count of bytes actually written
 800440c:	a901      	add	r1, sp, #4
//xprintf (6,"\n\r");

	/* Make an array with seq number, CAN msg. */
	if (p->ct >= PCTOGATEWAYSIZE) return -1; 	// Prevent overruns
	/* Prepare msg for sending.  Add byte stuffing, framing, and checksum to input bytes. */
	sz = PC_msg_prep(&b[0], BUFFSIZE, &p->cm[0], p->ct);
 800440e:	4602      	mov	r2, r0

	/* Send to USB, or other output per file descriptor. */
	return write(fd, b, sz); // Return count of bytes actually written
 8004410:	4620      	mov	r0, r4
 8004412:	f004 f96b 	bl	80086ec <write>
 8004416:	e001      	b.n	800441c <USB_toPC_msgBIN+0x28>
//for (i = 0; i < p->ct; i++)
//  xprintf(6,"%02x ",p->cm[i]);
//xprintf (6,"\n\r");

	/* Make an array with seq number, CAN msg. */
	if (p->ct >= PCTOGATEWAYSIZE) return -1; 	// Prevent overruns
 8004418:	f04f 30ff 	mov.w	r0, #4294967295
	/* Prepare msg for sending.  Add byte stuffing, framing, and checksum to input bytes. */
	sz = PC_msg_prep(&b[0], BUFFSIZE, &p->cm[0], p->ct);

	/* Send to USB, or other output per file descriptor. */
	return write(fd, b, sz); // Return count of bytes actually written
}
 800441c:	b01a      	add	sp, #104	; 0x68
 800441e:	bd10      	pop	{r4, pc}

08004420 <USB_toPC_msg_mode>:
 * @return	: postive = number of bytes written
 *              : negative = error
 *              : -1 = The bozo that called this routine gave us booogus ptr->mode_link|send!
 * ************************************************************************************** */
int USB_toPC_msg_mode(int fd, struct PCTOGATEWAY* ptr, struct CANRCVBUF* pcan)
{
 8004420:	b570      	push	{r4, r5, r6, lr}
 8004422:	460d      	mov	r5, r1
	switch (ptr->mode_link)	// 'switch' for just two cases is lame, but allow for many more modes.
 8004424:	f895 303e 	ldrb.w	r3, [r5, #62]	; 0x3e
 * @return	: postive = number of bytes written
 *              : negative = error
 *              : -1 = The bozo that called this routine gave us booogus ptr->mode_link|send!
 * ************************************************************************************** */
int USB_toPC_msg_mode(int fd, struct PCTOGATEWAY* ptr, struct CANRCVBUF* pcan)
{
 8004428:	4604      	mov	r4, r0
	switch (ptr->mode_link)	// 'switch' for just two cases is lame, but allow for many more modes.
 800442a:	2b01      	cmp	r3, #1
 * @return	: postive = number of bytes written
 *              : negative = error
 *              : -1 = The bozo that called this routine gave us booogus ptr->mode_link|send!
 * ************************************************************************************** */
int USB_toPC_msg_mode(int fd, struct PCTOGATEWAY* ptr, struct CANRCVBUF* pcan)
{
 800442c:	4611      	mov	r1, r2
	switch (ptr->mode_link)	// 'switch' for just two cases is lame, but allow for many more modes.
 800442e:	d00c      	beq.n	800444a <USB_toPC_msg_mode+0x2a>
 8004430:	d302      	bcc.n	8004438 <USB_toPC_msg_mode+0x18>
 8004432:	2b02      	cmp	r3, #2
 8004434:	d117      	bne.n	8004466 <USB_toPC_msg_mode+0x46>
 8004436:	e00d      	b.n	8004454 <USB_toPC_msg_mode+0x34>
	{
	case 0:	// BINARY Mode: PC<->gateway
		CANcompress(&ptr->cmprs, pcan);		// Compress
 8004438:	3540      	adds	r5, #64	; 0x40
 800443a:	4628      	mov	r0, r5
 800443c:	f7ff fe71 	bl	8004122 <CANcompress>
		return USB_toPC_msgBIN(fd, &ptr->cmprs);
 8004440:	4620      	mov	r0, r4
 8004442:	4629      	mov	r1, r5
		CANcompress_G(&ptr->cmprs, pcan);	// dlc = one byte the only compression
		return USB_toPC_msgASCII(fd, &ptr->cmprs);
		break;
	}
	return -1;
}
 8004444:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
{
	switch (ptr->mode_link)	// 'switch' for just two cases is lame, but allow for many more modes.
	{
	case 0:	// BINARY Mode: PC<->gateway
		CANcompress(&ptr->cmprs, pcan);		// Compress
		return USB_toPC_msgBIN(fd, &ptr->cmprs);
 8004448:	e7d4      	b.n	80043f4 <USB_toPC_msgBIN>
		ptr->cmprs.cm[0] = ptr->cmprs.seq;			// Place seq number at beginning

		break; // JIC

	case 1: // ASCII/HEX mode: PC<->gateway (same "strong" compression as case 0 above)
		CANcompress(&ptr->cmprs, pcan);		// Heavy compression
 800444a:	3540      	adds	r5, #64	; 0x40
 800444c:	4628      	mov	r0, r5
 800444e:	f7ff fe68 	bl	8004122 <CANcompress>
 8004452:	e003      	b.n	800445c <USB_toPC_msg_mode+0x3c>
		return USB_toPC_msgASCII(fd, &ptr->cmprs);
		break; // JIC

	case 2: // ASCII/HEX Gonzaga format (minimal compression)
		CANcompress_G(&ptr->cmprs, pcan);	// dlc = one byte the only compression
 8004454:	3540      	adds	r5, #64	; 0x40
 8004456:	4628      	mov	r0, r5
 8004458:	f7ff feaa 	bl	80041b0 <CANcompress_G>
		return USB_toPC_msgASCII(fd, &ptr->cmprs);
 800445c:	4620      	mov	r0, r4
 800445e:	4629      	mov	r1, r5
		break;
	}
	return -1;
}
 8004460:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return USB_toPC_msgASCII(fd, &ptr->cmprs);
		break; // JIC

	case 2: // ASCII/HEX Gonzaga format (minimal compression)
		CANcompress_G(&ptr->cmprs, pcan);	// dlc = one byte the only compression
		return USB_toPC_msgASCII(fd, &ptr->cmprs);
 8004464:	e7b4      	b.n	80043d0 <USB_toPC_msgASCII>
		break;
	}
	return -1;
}
 8004466:	f04f 30ff 	mov.w	r0, #4294967295
 800446a:	bd70      	pop	{r4, r5, r6, pc}

0800446c <USB_toPC_msg_asciican>:
 *              : negative = error
 *              : -1 = The bozo that called this routine gave us booogus ptr->mode_link!
 * @NOTE	: Be sure ptr->mode_link is set!
 * ************************************************************************************** */
int USB_toPC_msg_asciican(int fd, char* pin, struct PCTOGATEWAY* ptr)
{
 800446c:	b530      	push	{r4, r5, lr}
 800446e:	4604      	mov	r4, r0
 8004470:	b085      	sub	sp, #20
	int ret;
	struct CANRCVBUF can;

	/* Convert msg to binary */
	ret = PC_msg_asctobin(ptr, pin);
 8004472:	4610      	mov	r0, r2
 *              : negative = error
 *              : -1 = The bozo that called this routine gave us booogus ptr->mode_link!
 * @NOTE	: Be sure ptr->mode_link is set!
 * ************************************************************************************** */
int USB_toPC_msg_asciican(int fd, char* pin, struct PCTOGATEWAY* ptr)
{
 8004474:	4615      	mov	r5, r2
	int ret;
	struct CANRCVBUF can;

	/* Convert msg to binary */
	ret = PC_msg_asctobin(ptr, pin);
 8004476:	f7ff fdb3 	bl	8003fe0 <PC_msg_asctobin>
	if (ret < 0) return ret;
 800447a:	2800      	cmp	r0, #0
 800447c:	db08      	blt.n	8004490 <USB_toPC_msg_asciican+0x24>


	/* Handle binary msg no differently than others */
	ptr->cmprs.seq = ptr->seq;		// Add sequence number (for PC checking for missing msgs)
 800447e:	f895 303d 	ldrb.w	r3, [r5, #61]	; 0x3d
	
	/* Send as we would any msg that is in binary form. */
	return USB_toPC_msg_mode(fd, ptr, &can);
 8004482:	4620      	mov	r0, r4
	ret = PC_msg_asctobin(ptr, pin);
	if (ret < 0) return ret;


	/* Handle binary msg no differently than others */
	ptr->cmprs.seq = ptr->seq;		// Add sequence number (for PC checking for missing msgs)
 8004484:	f885 305e 	strb.w	r3, [r5, #94]	; 0x5e
	
	/* Send as we would any msg that is in binary form. */
	return USB_toPC_msg_mode(fd, ptr, &can);
 8004488:	4629      	mov	r1, r5
 800448a:	466a      	mov	r2, sp
 800448c:	f7ff ffc8 	bl	8004420 <USB_toPC_msg_mode>
}
 8004490:	b005      	add	sp, #20
 8004492:	bd30      	pop	{r4, r5, pc}

08004494 <lcd_clear>:

	lcd_clear(uartnumber);
	lcd_moveCursor(uartnumber,0, 0);
}

void lcd_clear(int uartnumber) {
 8004494:	b510      	push	{r4, lr}
	bsp_uart_putc_uartnum(uartnumber, 254);
 8004496:	21fe      	movs	r1, #254	; 0xfe

	lcd_clear(uartnumber);
	lcd_moveCursor(uartnumber,0, 0);
}

void lcd_clear(int uartnumber) {
 8004498:	4604      	mov	r4, r0
	bsp_uart_putc_uartnum(uartnumber, 254);
 800449a:	f001 fb26 	bl	8005aea <bsp_uart_putc_uartnum>
	bsp_uart_putc_uartnum(uartnumber, 0x01); // clear screen
 800449e:	4620      	mov	r0, r4
 80044a0:	2101      	movs	r1, #1
}
 80044a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lcd_moveCursor(uartnumber,0, 0);
}

void lcd_clear(int uartnumber) {
	bsp_uart_putc_uartnum(uartnumber, 254);
	bsp_uart_putc_uartnum(uartnumber, 0x01); // clear screen
 80044a6:	f001 bb20 	b.w	8005aea <bsp_uart_putc_uartnum>

080044aa <lcd_on>:
}

void lcd_on(int uartnumber) {
 80044aa:	b510      	push	{r4, lr}
	bsp_uart_putc_uartnum(uartnumber, 254);
 80044ac:	21fe      	movs	r1, #254	; 0xfe
void lcd_clear(int uartnumber) {
	bsp_uart_putc_uartnum(uartnumber, 254);
	bsp_uart_putc_uartnum(uartnumber, 0x01); // clear screen
}

void lcd_on(int uartnumber) {
 80044ae:	4604      	mov	r4, r0
	bsp_uart_putc_uartnum(uartnumber, 254);
 80044b0:	f001 fb1b 	bl	8005aea <bsp_uart_putc_uartnum>
	bsp_uart_putc_uartnum(uartnumber, 0x0C); // clear screen
 80044b4:	4620      	mov	r0, r4
 80044b6:	210c      	movs	r1, #12
}
 80044b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bsp_uart_putc_uartnum(uartnumber, 0x01); // clear screen
}

void lcd_on(int uartnumber) {
	bsp_uart_putc_uartnum(uartnumber, 254);
	bsp_uart_putc_uartnum(uartnumber, 0x0C); // clear screen
 80044bc:	f001 bb15 	b.w	8005aea <bsp_uart_putc_uartnum>

080044c0 <lcd_off>:
}

void lcd_off(int uartnumber) {
 80044c0:	b510      	push	{r4, lr}
	bsp_uart_putc_uartnum(uartnumber, 254);
 80044c2:	21fe      	movs	r1, #254	; 0xfe
void lcd_on(int uartnumber) {
	bsp_uart_putc_uartnum(uartnumber, 254);
	bsp_uart_putc_uartnum(uartnumber, 0x0C); // clear screen
}

void lcd_off(int uartnumber) {
 80044c4:	4604      	mov	r4, r0
	bsp_uart_putc_uartnum(uartnumber, 254);
 80044c6:	f001 fb10 	bl	8005aea <bsp_uart_putc_uartnum>
	bsp_uart_putc_uartnum(uartnumber, 0x08); // clear screen
 80044ca:	4620      	mov	r0, r4
 80044cc:	2108      	movs	r1, #8
}
 80044ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bsp_uart_putc_uartnum(uartnumber, 0x0C); // clear screen
}

void lcd_off(int uartnumber) {
	bsp_uart_putc_uartnum(uartnumber, 254);
	bsp_uart_putc_uartnum(uartnumber, 0x08); // clear screen
 80044d2:	f001 bb0a 	b.w	8005aea <bsp_uart_putc_uartnum>

080044d6 <lcd_print>:
}

void lcd_print(int uartnumber, char* p) 
{
 80044d6:	b530      	push	{r4, r5, lr}
 80044d8:	b087      	sub	sp, #28
 80044da:	4605      	mov	r5, r0
	char vv[21];
	strncpy(vv, p, 20);
 80044dc:	2214      	movs	r2, #20
 80044de:	4668      	mov	r0, sp
	bsp_uart_putc_uartnum(uartnumber, 254);
	bsp_uart_putc_uartnum(uartnumber, 0x08); // clear screen
}

void lcd_print(int uartnumber, char* p) 
{
 80044e0:	460c      	mov	r4, r1
	char vv[21];
	strncpy(vv, p, 20);
 80044e2:	f002 fd83 	bl	8006fec <strncpy>
	vv[20] = 0;
	bsp_uart_puts_uartnum(uartnumber, p);
 80044e6:	4628      	mov	r0, r5
 80044e8:	4621      	mov	r1, r4
}
 80044ea:	b007      	add	sp, #28
 80044ec:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
void lcd_print(int uartnumber, char* p) 
{
	char vv[21];
	strncpy(vv, p, 20);
	vv[20] = 0;
	bsp_uart_puts_uartnum(uartnumber, p);
 80044f0:	f001 bb1b 	b.w	8005b2a <bsp_uart_puts_uartnum>

080044f4 <lcd_moveCursor>:
void lcd_printToLine(int uartnumber, int line, char* p) {
	lcd_moveCursor(uartnumber, line, 0);
	lcd_print(uartnumber, p);
}

void lcd_moveCursor(int uartnumber, int row, int col) {
 80044f4:	b570      	push	{r4, r5, r6, lr}
 80044f6:	460d      	mov	r5, r1
	bsp_uart_putc_uartnum(uartnumber, 254); // move cursor command
 80044f8:	21fe      	movs	r1, #254	; 0xfe
void lcd_printToLine(int uartnumber, int line, char* p) {
	lcd_moveCursor(uartnumber, line, 0);
	lcd_print(uartnumber, p);
}

void lcd_moveCursor(int uartnumber, int row, int col) {
 80044fa:	4604      	mov	r4, r0
 80044fc:	4616      	mov	r6, r2
	bsp_uart_putc_uartnum(uartnumber, 254); // move cursor command
 80044fe:	f001 faf4 	bl	8005aea <bsp_uart_putc_uartnum>

	// determine position
	if (row == 0) {
 8004502:	b915      	cbnz	r5, 800450a <lcd_moveCursor+0x16>
		bsp_uart_putc_uartnum(uartnumber, 128 + col);
 8004504:	f1a6 0180 	sub.w	r1, r6, #128	; 0x80
 8004508:	e00d      	b.n	8004526 <lcd_moveCursor+0x32>
	} else if (row == 1) {
 800450a:	2d01      	cmp	r5, #1
 800450c:	d102      	bne.n	8004514 <lcd_moveCursor+0x20>
		bsp_uart_putc_uartnum(uartnumber, 192 + col);
 800450e:	f1a6 0140 	sub.w	r1, r6, #64	; 0x40
 8004512:	e008      	b.n	8004526 <lcd_moveCursor+0x32>
	} else if (row == 2) {
 8004514:	2d02      	cmp	r5, #2
 8004516:	d102      	bne.n	800451e <lcd_moveCursor+0x2a>
		bsp_uart_putc_uartnum(uartnumber, 148 + col);
 8004518:	f1a6 016c 	sub.w	r1, r6, #108	; 0x6c
 800451c:	e003      	b.n	8004526 <lcd_moveCursor+0x32>
	} else if (row == 3) {
 800451e:	2d03      	cmp	r5, #3
 8004520:	d107      	bne.n	8004532 <lcd_moveCursor+0x3e>
		bsp_uart_putc_uartnum(uartnumber, 212 + col);
 8004522:	f1a6 012c 	sub.w	r1, r6, #44	; 0x2c
 8004526:	4620      	mov	r0, r4
 8004528:	b2c9      	uxtb	r1, r1
	}
 800452a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	} else if (row == 1) {
		bsp_uart_putc_uartnum(uartnumber, 192 + col);
	} else if (row == 2) {
		bsp_uart_putc_uartnum(uartnumber, 148 + col);
	} else if (row == 3) {
		bsp_uart_putc_uartnum(uartnumber, 212 + col);
 800452e:	f001 badc 	b.w	8005aea <bsp_uart_putc_uartnum>
 8004532:	bd70      	pop	{r4, r5, r6, pc}

08004534 <lcd_printToLine>:
	strncpy(vv, p, 20);
	vv[20] = 0;
	bsp_uart_puts_uartnum(uartnumber, p);
}

void lcd_printToLine(int uartnumber, int line, char* p) {
 8004534:	b570      	push	{r4, r5, r6, lr}
 8004536:	4614      	mov	r4, r2
	lcd_moveCursor(uartnumber, line, 0);
 8004538:	2200      	movs	r2, #0
	strncpy(vv, p, 20);
	vv[20] = 0;
	bsp_uart_puts_uartnum(uartnumber, p);
}

void lcd_printToLine(int uartnumber, int line, char* p) {
 800453a:	4605      	mov	r5, r0
	lcd_moveCursor(uartnumber, line, 0);
 800453c:	f7ff ffda 	bl	80044f4 <lcd_moveCursor>
	lcd_print(uartnumber, p);
 8004540:	4628      	mov	r0, r5
 8004542:	4621      	mov	r1, r4
}
 8004544:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bsp_uart_puts_uartnum(uartnumber, p);
}

void lcd_printToLine(int uartnumber, int line, char* p) {
	lcd_moveCursor(uartnumber, line, 0);
	lcd_print(uartnumber, p);
 8004548:	e7c5      	b.n	80044d6 <lcd_print>

0800454a <lcd_init>:

#include "bsp_uart.h"
#include "4x20lcd.h"
#include <string.h>

void lcd_init(int uartnumber) {
 800454a:	b513      	push	{r0, r1, r4, lr}
	// 9600 baud
	bsp_uart_int_init_number(uartnumber, 9600, 0, 20, 0xC0);
 800454c:	23c0      	movs	r3, #192	; 0xc0

#include "bsp_uart.h"
#include "4x20lcd.h"
#include <string.h>

void lcd_init(int uartnumber) {
 800454e:	4604      	mov	r4, r0
	// 9600 baud
	bsp_uart_int_init_number(uartnumber, 9600, 0, 20, 0xC0);
 8004550:	2200      	movs	r2, #0
 8004552:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 8004556:	9300      	str	r3, [sp, #0]
 8004558:	3bac      	subs	r3, #172	; 0xac
 800455a:	f001 fb71 	bl	8005c40 <bsp_uart_int_init_number>

	lcd_off(uartnumber);
 800455e:	4620      	mov	r0, r4
 8004560:	f7ff ffae 	bl	80044c0 <lcd_off>
	lcd_on(uartnumber);
 8004564:	4620      	mov	r0, r4
 8004566:	f7ff ffa0 	bl	80044aa <lcd_on>

	lcd_clear(uartnumber);
 800456a:	4620      	mov	r0, r4
 800456c:	f7ff ff92 	bl	8004494 <lcd_clear>
	lcd_moveCursor(uartnumber,0, 0);
 8004570:	2100      	movs	r1, #0
 8004572:	4620      	mov	r0, r4
 8004574:	460a      	mov	r2, r1
}
 8004576:	b002      	add	sp, #8
 8004578:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

	lcd_off(uartnumber);
	lcd_on(uartnumber);

	lcd_clear(uartnumber);
	lcd_moveCursor(uartnumber,0, 0);
 800457c:	e7ba      	b.n	80044f4 <lcd_moveCursor>
	...

08004580 <DISCgpiopins_Config>:
{
/* ----------------------------- PORTA -------------------------------------- */
/* ----------------------------- PORTB -------------------------------------- */
/* ----------------------------- PORTC -------------------------------------- */
/* ----------------------------- PORTD -------------------------------------- */
	RCC_AHB1ENR |= (1<<3);	// Enable port D clocking (p 110, p 148)
 8004580:	4b0d      	ldr	r3, [pc, #52]	; (80045b8 <DISCgpiopins_Config+0x38>)
 8004582:	681a      	ldr	r2, [r3, #0]
 8004584:	f042 0208 	orr.w	r2, r2, #8
 8004588:	601a      	str	r2, [r3, #0]

	/* PD12,13,14,15 are the green, orange, red, blue LEDs on the Discovery board */
	GPIOD_MODER    =   (GPIOD_MODER   & (~(0x00ff << 24))) | (0x0055 << 24);	// Mode = General purpose output
 800458a:	4b0c      	ldr	r3, [pc, #48]	; (80045bc <DISCgpiopins_Config+0x3c>)
 800458c:	681a      	ldr	r2, [r3, #0]
 800458e:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8004592:	f042 42aa 	orr.w	r2, r2, #1426063360	; 0x55000000
 8004596:	601a      	str	r2, [r3, #0]
	GPIOD_OTYPER   =   (GPIOD_OTYPER  & (~(0x000f << 12))) | (0x0000 << 12);	// Type output = push-pull
 8004598:	685a      	ldr	r2, [r3, #4]
 800459a:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
 800459e:	605a      	str	r2, [r3, #4]
	GPIOD_OSPEEDR  =   (GPIOD_OSPEEDR & (~(0x00ff << 24))) | (0x00aa << 24);	// Pin speed = Speed 50 MHz
 80045a0:	689a      	ldr	r2, [r3, #8]
 80045a2:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 80045a6:	f042 422a 	orr.w	r2, r2, #2852126720	; 0xaa000000
 80045aa:	609a      	str	r2, [r3, #8]
	GPIOD_PUPDR    =   (GPIOD_PUPDR   & (~(0x00ff << 24))) | (0x0000 << 24);	// Pull up/down = none.
 80045ac:	68da      	ldr	r2, [r3, #12]
 80045ae:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 80045b2:	60da      	str	r2, [r3, #12]

	return;
}
 80045b4:	4770      	bx	lr
 80045b6:	bf00      	nop
 80045b8:	40023830 	.word	0x40023830
 80045bc:	40020c00 	.word	0x40020c00

080045c0 <DISCgpiopins_default>:
/* ----------------------------- PORTB -------------------------------------- */
/* ----------------------------- PORTC -------------------------------------- */
/* ----------------------------- PORTD -------------------------------------- */
/* ----------------------------- PORTE -------------------------------------- */
	return;
}
 80045c0:	4770      	bx	lr

080045c2 <f4gpiopins_Config>:
 * void f4gpiopins_Config(volatile u32 * p, u16 pinnumber, struct PINCONFIG * s  );
 * @param	: See comments on each in source code
 * @brief	: Configure one gpio pin 
 ******************************************************************************/
void f4gpiopins_Config(volatile u32 * p, u16 pinnumber, struct PINCONFIG * s)
{
 80045c2:	b5f0      	push	{r4, r5, r6, r7, lr}

	/* Make sure bus clocking is enabled so that gpio registers can be accessed (p 110) */
	u32 x = ((u32)p - (u32)GPIOA) >> 10;	// Shift count for enabling RCC_AHB1ENR
 80045c4:	f100 443f 	add.w	r4, r0, #3204448256	; 0xbf000000
 80045c8:	f504 047e 	add.w	r4, r4, #16646144	; 0xfe0000
	RCC_AHB1ENR |= ((1 << x) & 0x01ff);	// Enable port clocking
 80045cc:	2601      	movs	r6, #1
 80045ce:	4d29      	ldr	r5, [pc, #164]	; (8004674 <f4gpiopins_Config+0xb2>)
 ******************************************************************************/
void f4gpiopins_Config(volatile u32 * p, u16 pinnumber, struct PINCONFIG * s)
{

	/* Make sure bus clocking is enabled so that gpio registers can be accessed (p 110) */
	u32 x = ((u32)p - (u32)GPIOA) >> 10;	// Shift count for enabling RCC_AHB1ENR
 80045d0:	0aa3      	lsrs	r3, r4, #10
	RCC_AHB1ENR |= ((1 << x) & 0x01ff);	// Enable port clocking
 80045d2:	fa16 f303 	lsls.w	r3, r6, r3
 80045d6:	682f      	ldr	r7, [r5, #0]
 80045d8:	05db      	lsls	r3, r3, #23
 80045da:	0ddb      	lsrs	r3, r3, #23
 80045dc:	433b      	orrs	r3, r7
 80045de:	602b      	str	r3, [r5, #0]
00: Input (reset state)
01: General purpose output mode
10: Alternate function mode
11: Analog mode
*/
	GPIO_MODER(p)  &= ~(0x03 << (pinnumber << 1));		// Reset old mode values
 80045e0:	fa11 f306 	lsls.w	r3, r1, r6
 80045e4:	2503      	movs	r5, #3
 80045e6:	6804      	ldr	r4, [r0, #0]
 80045e8:	409d      	lsls	r5, r3
 80045ea:	43ed      	mvns	r5, r5
 80045ec:	ea05 0404 	and.w	r4, r5, r4
 80045f0:	6004      	str	r4, [r0, #0]
	GPIO_MODER(p)  |= ((s->mode & 0x03) << (pinnumber << 1));	// Add new values
 80045f2:	7817      	ldrb	r7, [r2, #0]
 80045f4:	6804      	ldr	r4, [r0, #0]
 80045f6:	f007 0703 	and.w	r7, r7, #3
 80045fa:	409f      	lsls	r7, r3
 80045fc:	4327      	orrs	r7, r4
 80045fe:	4604      	mov	r4, r0
/* TYPE GPIO_OTYPER
These bits are written by software to configure the output type of the I/O port.
0: Output push-pull (reset state)
1: Output open-drain
*/
	GPIO_MODER(p+1) &= ~(0x01 << pinnumber);		// Reset old type bit
 8004600:	408e      	lsls	r6, r1
01: General purpose output mode
10: Alternate function mode
11: Analog mode
*/
	GPIO_MODER(p)  &= ~(0x03 << (pinnumber << 1));		// Reset old mode values
	GPIO_MODER(p)  |= ((s->mode & 0x03) << (pinnumber << 1));	// Add new values
 8004602:	f844 7b04 	str.w	r7, [r4], #4
/* TYPE GPIO_OTYPER
These bits are written by software to configure the output type of the I/O port.
0: Output push-pull (reset state)
1: Output open-drain
*/
	GPIO_MODER(p+1) &= ~(0x01 << pinnumber);		// Reset old type bit
 8004606:	6847      	ldr	r7, [r0, #4]
 8004608:	ea27 0606 	bic.w	r6, r7, r6
 800460c:	6046      	str	r6, [r0, #4]
	GPIO_MODER(p+1) |=  ((s->type & 0x01) << pinnumber);// Add new type bit
 800460e:	7856      	ldrb	r6, [r2, #1]
 8004610:	6847      	ldr	r7, [r0, #4]
 8004612:	f006 0601 	and.w	r6, r6, #1
 8004616:	408e      	lsls	r6, r1
 8004618:	433e      	orrs	r6, r7
 800461a:	6046      	str	r6, [r0, #4]
01: 25 MHz Medium speed
10: 50 MHz Fast speed
11: 100 MHz High speed on 30 pF (80 MHz Output max speed on 15 pF)
*/

	GPIO_MODER(p+2) &= ~(0x03 << (pinnumber << 1));		// Reset old speed values
 800461c:	6886      	ldr	r6, [r0, #8]
 800461e:	ea05 0606 	and.w	r6, r5, r6
 8004622:	6086      	str	r6, [r0, #8]
	GPIO_MODER(p+2) |= ((s->speed & 0x03) << (pinnumber << 1));// Add new values
 8004624:	7896      	ldrb	r6, [r2, #2]
 8004626:	6887      	ldr	r7, [r0, #8]
 8004628:	f006 0603 	and.w	r6, r6, #3
 800462c:	409e      	lsls	r6, r3
 800462e:	433e      	orrs	r6, r7
 8004630:	6086      	str	r6, [r0, #8]
00: No pull-up, pull-down
01: Pull-up
10: Pull-down
11: Reserved
*/
	GPIO_MODER(p+3) &= ~(0x03 << (pinnumber << 1));		// Reset old pupdn values
 8004632:	68c6      	ldr	r6, [r0, #12]
 8004634:	4035      	ands	r5, r6
 8004636:	60c5      	str	r5, [r0, #12]
	GPIO_MODER(p+3) |= ((s->pupdn & 0x03) << (pinnumber << 1));	// Add new values
 8004638:	78d6      	ldrb	r6, [r2, #3]
 800463a:	68c5      	ldr	r5, [r0, #12]
 800463c:	f006 0603 	and.w	r6, r6, #3
 8004640:	fa16 f303 	lsls.w	r3, r6, r3
 8004644:	432b      	orrs	r3, r5
                                  1111: AF15
0111: AF7

GPIO_AFRL
*/
	if (pinnumber >= 8)
 8004646:	2907      	cmp	r1, #7
01: Pull-up
10: Pull-down
11: Reserved
*/
	GPIO_MODER(p+3) &= ~(0x03 << (pinnumber << 1));		// Reset old pupdn values
	GPIO_MODER(p+3) |= ((s->pupdn & 0x03) << (pinnumber << 1));	// Add new values
 8004648:	60c3      	str	r3, [r0, #12]
                                  1111: AF15
0111: AF7

GPIO_AFRL
*/
	if (pinnumber >= 8)
 800464a:	d902      	bls.n	8004652 <f4gpiopins_Config+0x90>
	{ // Here, the high register (pins 8 - 15) (p 152)
		pinnumber -= 8;		// adjust shift count 
 800464c:	3908      	subs	r1, #8
 800464e:	b289      	uxth	r1, r1
 8004650:	4620      	mov	r0, r4
		p++;			// Point to high register
	}

	GPIO_MODER(p+8) &= ~(0x0f << (pinnumber << 2));			// Remove old AF settings
 8004652:	6a04      	ldr	r4, [r0, #32]
 8004654:	0089      	lsls	r1, r1, #2
 8004656:	230f      	movs	r3, #15
 8004658:	408b      	lsls	r3, r1
 800465a:	ea24 0303 	bic.w	r3, r4, r3
 800465e:	6203      	str	r3, [r0, #32]
	GPIO_MODER(p+8) |=  ((s->afrl & 0x0f) << (pinnumber << 2));	// Add new settings
 8004660:	7912      	ldrb	r2, [r2, #4]
 8004662:	6a03      	ldr	r3, [r0, #32]
 8004664:	f002 020f 	and.w	r2, r2, #15
 8004668:	fa12 f101 	lsls.w	r1, r2, r1
 800466c:	4319      	orrs	r1, r3
 800466e:	6201      	str	r1, [r0, #32]

	return;
}
 8004670:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004672:	bf00      	nop
 8004674:	40023830 	.word	0x40023830

08004678 <bitcvt>:
 ----------------------------------------------------------------------------------------------*/
static u8 bitcvt(u8 bit)
{
	if (bit != 0) return 1;
	return 0;
}
 8004678:	3800      	subs	r0, #0
 800467a:	bf18      	it	ne
 800467c:	2001      	movne	r0, #1
 800467e:	4770      	bx	lr

08004680 <loadmbx>:
int unsigned can_debugM = 0;	// Msgs removed from buffer

static void loadmbx(struct CANRCVBUF *px)
{
	/* Load the mailbox with the message. */
	CAN_TIxR (CAN1, CAN_MBOX0) = px->id;		// CAN_TIxR  mailbox   identifier register p 659
 8004680:	6802      	ldr	r2, [r0, #0]
 8004682:	4b07      	ldr	r3, [pc, #28]	; (80046a0 <loadmbx+0x20>)
 8004684:	601a      	str	r2, [r3, #0]
	CAN_TDTxR(CAN1, CAN_MBOX0) = px->dlc;		// CAN_TDTxR: mailbox  time & length p 660
 8004686:	6841      	ldr	r1, [r0, #4]
 8004688:	4a06      	ldr	r2, [pc, #24]	; (80046a4 <loadmbx+0x24>)
 800468a:	6011      	str	r1, [r2, #0]
	CAN_TDLxR(CAN1, CAN_MBOX0) = px->cd.ui[0];	// CAN_TDLxRL mailbox  data low  register p 661 
 800468c:	6881      	ldr	r1, [r0, #8]
 800468e:	6051      	str	r1, [r2, #4]
	CAN_TDHxR(CAN1, CAN_MBOX0) = px->cd.ui[1];	// CAN_TDLxRH mailbox  data low  register p 661 
 8004690:	68c1      	ldr	r1, [r0, #12]
 8004692:	6091      	str	r1, [r2, #8]

	/* Request a transmission */
	CAN_TIxR (CAN1, CAN_MBOX0) |= 0x1;	// Set TXRQ bit in ID register of mailbox p 669
 8004694:	681a      	ldr	r2, [r3, #0]
 8004696:	f042 0201 	orr.w	r2, r2, #1
 800469a:	601a      	str	r2, [r3, #0]

	return;
}
 800469c:	4770      	bx	lr
 800469e:	bf00      	nop
 80046a0:	40006580 	.word	0x40006580
 80046a4:	40006584 	.word	0x40006584

080046a8 <can_init_pod_ldr>:
 * @brief 	: Setup CAN pins and hardware
 * @param	: p = pointer to 'struct CAN_PARAMS' with setup values
 * @return	:  n = remaining counts; 0 = enter init mode timedout;-1 = exit init mode timeout; -2 = bad port
*******************************************************************************/
int can_init_pod_ldr(struct CAN_PARAMS *p)
{
 80046a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int can_timeout;	// Counter for breaking 'while' loops

	/* Enable clocking to CAN module */
	RCC_APB1ENR |= (1<<25);		// CAN1_EN p 144
 80046aa:	4b89      	ldr	r3, [pc, #548]	; (80048d0 <can_init_pod_ldr+0x228>)
 80046ac:	681a      	ldr	r2, [r3, #0]
 80046ae:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 80046b2:	601a      	str	r2, [r3, #0]

	 /* Note: calculations for PCLK1 = 36MHz */
//	unsigned int brp = (pclk1_freq / 18) / 500000;	// baudrate is set to 500k bit/s

	/* Setup remapping and configure port pins */
	switch (p->port)
 80046b4:	7a03      	ldrb	r3, [r0, #8]
 80046b6:	2b02      	cmp	r3, #2
 * @brief 	: Setup CAN pins and hardware
 * @param	: p = pointer to 'struct CAN_PARAMS' with setup values
 * @return	:  n = remaining counts; 0 = enter init mode timedout;-1 = exit init mode timeout; -2 = bad port
*******************************************************************************/
int can_init_pod_ldr(struct CAN_PARAMS *p)
{
 80046b8:	4604      	mov	r4, r0

	 /* Note: calculations for PCLK1 = 36MHz */
//	unsigned int brp = (pclk1_freq / 18) / 500000;	// baudrate is set to 500k bit/s

	/* Setup remapping and configure port pins */
	switch (p->port)
 80046ba:	d00c      	beq.n	80046d6 <can_init_pod_ldr+0x2e>
 80046bc:	2b03      	cmp	r3, #3
 80046be:	d012      	beq.n	80046e6 <can_init_pod_ldr+0x3e>
 80046c0:	2b00      	cmp	r3, #0
 80046c2:	f040 80fc 	bne.w	80048be <can_init_pod_ldr+0x216>
	{
	case 0:	// CAN on port A

		/*  Setup CAN TXD: PA12 for alternate function push/pull output */
	f4gpiopins_Config ((volatile u32*)GPIOA, 12, (struct PINCONFIG*)&outputaf);
 80046c6:	4883      	ldr	r0, [pc, #524]	; (80048d4 <can_init_pod_ldr+0x22c>)
 80046c8:	4a83      	ldr	r2, [pc, #524]	; (80048d8 <can_init_pod_ldr+0x230>)
 80046ca:	210c      	movs	r1, #12
 80046cc:	f7ff ff79 	bl	80045c2 <f4gpiopins_Config>

		/* Setup CAN RXD: PB11 for input pull up */
	f4gpiopins_Config ((volatile u32*)GPIOA, 11, (struct PINCONFIG*)&inputpup);
 80046d0:	4880      	ldr	r0, [pc, #512]	; (80048d4 <can_init_pod_ldr+0x22c>)
 80046d2:	210b      	movs	r1, #11
 80046d4:	e00e      	b.n	80046f4 <can_init_pod_ldr+0x4c>
		break;

	case 2:	// CAN on port B

		/*  Setup CAN TXD: PB09 for alternate function push/pull output  */
	f4gpiopins_Config ((volatile u32*)GPIOB,  9, (struct PINCONFIG*)&outputaf);
 80046d6:	4881      	ldr	r0, [pc, #516]	; (80048dc <can_init_pod_ldr+0x234>)
 80046d8:	4a7f      	ldr	r2, [pc, #508]	; (80048d8 <can_init_pod_ldr+0x230>)
 80046da:	2109      	movs	r1, #9
 80046dc:	f7ff ff71 	bl	80045c2 <f4gpiopins_Config>

		/* Setup CAN RXD: PB08 for input pull up */
	f4gpiopins_Config ((volatile u32*)GPIOB,  8, (struct PINCONFIG*)&inputpup);
 80046e0:	487e      	ldr	r0, [pc, #504]	; (80048dc <can_init_pod_ldr+0x234>)
 80046e2:	2108      	movs	r1, #8
 80046e4:	e006      	b.n	80046f4 <can_init_pod_ldr+0x4c>
		break;

	case 3:	// CAN on port D

		/*  Setup CAN TXD: PD01 for alternate function push/pull  */
	f4gpiopins_Config ((volatile u32*)GPIOD,  1, (struct PINCONFIG*)&outputaf);
 80046e6:	487e      	ldr	r0, [pc, #504]	; (80048e0 <can_init_pod_ldr+0x238>)
 80046e8:	4a7b      	ldr	r2, [pc, #492]	; (80048d8 <can_init_pod_ldr+0x230>)
 80046ea:	2101      	movs	r1, #1
 80046ec:	f7ff ff69 	bl	80045c2 <f4gpiopins_Config>

		/* Setup CAN RXD: PD00 for input pull up */
	f4gpiopins_Config ((volatile u32*)GPIOD,  0, (struct PINCONFIG*)&inputpup);
 80046f0:	487b      	ldr	r0, [pc, #492]	; (80048e0 <can_init_pod_ldr+0x238>)
 80046f2:	2100      	movs	r1, #0
		break;
	}

	/* ---------- Set Initialization mode -------------------- */
	/* Request initialization p 632, 648.  DEBUG freeze bit on */
	CAN_MCR(CAN1) &= CAN_MCR_DBF;	// Clear DBF since it is set coming out RESET
 80046f4:	4d7b      	ldr	r5, [pc, #492]	; (80048e4 <can_init_pod_ldr+0x23c>)

		/*  Setup CAN TXD: PD01 for alternate function push/pull  */
	f4gpiopins_Config ((volatile u32*)GPIOD,  1, (struct PINCONFIG*)&outputaf);

		/* Setup CAN RXD: PD00 for input pull up */
	f4gpiopins_Config ((volatile u32*)GPIOD,  0, (struct PINCONFIG*)&inputpup);
 80046f6:	4a7c      	ldr	r2, [pc, #496]	; (80048e8 <can_init_pod_ldr+0x240>)
 80046f8:	f7ff ff63 	bl	80045c2 <f4gpiopins_Config>
		break;
	}

	/* ---------- Set Initialization mode -------------------- */
	/* Request initialization p 632, 648.  DEBUG freeze bit on */
	CAN_MCR(CAN1) &= CAN_MCR_DBF;	// Clear DBF since it is set coming out RESET
 80046fc:	682b      	ldr	r3, [r5, #0]
 80046fe:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8004702:	602b      	str	r3, [r5, #0]
	CAN_MCR(CAN1) = ((bitcvt(p->dbf) << 16) | (CAN_MCR_INRQ) );
 8004704:	7ba0      	ldrb	r0, [r4, #14]
 8004706:	f7ff ffb7 	bl	8004678 <bitcvt>
 800470a:	0400      	lsls	r0, r0, #16
 800470c:	f040 0001 	orr.w	r0, r0, #1

	/* The initialization request (above) causes the INAK bit to be set.  This bit goes off when 11 consecutive
	   recessive bits have been received p 633 */
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
 8004710:	4b76      	ldr	r3, [pc, #472]	; (80048ec <can_init_pod_ldr+0x244>)
	}

	/* ---------- Set Initialization mode -------------------- */
	/* Request initialization p 632, 648.  DEBUG freeze bit on */
	CAN_MCR(CAN1) &= CAN_MCR_DBF;	// Clear DBF since it is set coming out RESET
	CAN_MCR(CAN1) = ((bitcvt(p->dbf) << 16) | (CAN_MCR_INRQ) );
 8004712:	6028      	str	r0, [r5, #0]

	/* The initialization request (above) causes the INAK bit to be set.  This bit goes off when 11 consecutive
	   recessive bits have been received p 633 */
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
	while ( ((CAN_MSR(CAN1) & CAN_MSR_INAK) == 0 ) && (can_timeout-- >= 0) );	// Wait until initialization mode starts or times out
 8004714:	4a76      	ldr	r2, [pc, #472]	; (80048f0 <can_init_pod_ldr+0x248>)
 8004716:	6810      	ldr	r0, [r2, #0]
 8004718:	f010 0001 	ands.w	r0, r0, #1
 800471c:	d003      	beq.n	8004726 <can_init_pod_ldr+0x7e>
	if (can_timeout <= 0 ) return 0;	// Timed out
 800471e:	2b00      	cmp	r3, #0
 8004720:	f340 80d0 	ble.w	80048c4 <can_init_pod_ldr+0x21c>
 8004724:	e004      	b.n	8004730 <can_init_pod_ldr+0x88>
	CAN_MCR(CAN1) = ((bitcvt(p->dbf) << 16) | (CAN_MCR_INRQ) );

	/* The initialization request (above) causes the INAK bit to be set.  This bit goes off when 11 consecutive
	   recessive bits have been received p 633 */
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
	while ( ((CAN_MSR(CAN1) & CAN_MSR_INAK) == 0 ) && (can_timeout-- >= 0) );	// Wait until initialization mode starts or times out
 8004726:	3b01      	subs	r3, #1
 8004728:	f113 0f02 	cmn.w	r3, #2
 800472c:	d1f2      	bne.n	8004714 <can_init_pod_ldr+0x6c>
 800472e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	/* Compute baud rate prescalar code (BRP), given the baud rate and pclk1_freq, and sampling intervals p 645, fig 233 */
	/* set BTR register so that sample point is at about 72% bit time from bit start */
//	#define TBS1	12	// Bit segment 1
//	#define TBS2	5	// Bit segment 2
	u32 brp;		// Baud rate code
	brp = (pclk1_freq/(1 + (bitcvt(p->tbs1)) + (bitcvt(p->tbs2)))) / p->baudrate;
 8004730:	7b60      	ldrb	r0, [r4, #13]
	//                         SJW                      TBS2                       TBS1                      BRP
//	CAN_BTR(CAN1) &= ~( ((          0x03) << 24) | ((           0x07) << 20) | ((           0x0F) << 16) | ((          0x1FF) << 0) ); 
//	CAN_BTR(CAN1) |=  ( (((SJW-1) & 0x03) << 24) | (((TBS2-1) & 0x07) << 20) | (((TBS1-1) & 0x0F) << 16) | (((brp-1) & 0x1FF) << 0) );


	CAN_BTR(CAN1) = 0x01230000; 	// Set register to RESET value p 657
 8004732:	4d70      	ldr	r5, [pc, #448]	; (80048f4 <can_init_pod_ldr+0x24c>)
	/* Compute baud rate prescalar code (BRP), given the baud rate and pclk1_freq, and sampling intervals p 645, fig 233 */
	/* set BTR register so that sample point is at about 72% bit time from bit start */
//	#define TBS1	12	// Bit segment 1
//	#define TBS2	5	// Bit segment 2
	u32 brp;		// Baud rate code
	brp = (pclk1_freq/(1 + (bitcvt(p->tbs1)) + (bitcvt(p->tbs2)))) / p->baudrate;
 8004734:	f7ff ffa0 	bl	8004678 <bitcvt>
 8004738:	4606      	mov	r6, r0
 800473a:	7b20      	ldrb	r0, [r4, #12]
 800473c:	f7ff ff9c 	bl	8004678 <bitcvt>
 8004740:	4b6d      	ldr	r3, [pc, #436]	; (80048f8 <can_init_pod_ldr+0x250>)
 8004742:	1836      	adds	r6, r6, r0
 8004744:	681b      	ldr	r3, [r3, #0]
 8004746:	3601      	adds	r6, #1
 8004748:	fbb3 f6f6 	udiv	r6, r3, r6
 800474c:	6863      	ldr	r3, [r4, #4]
 800474e:	fbb6 f6f3 	udiv	r6, r6, r3
	//                         SJW                      TBS2                       TBS1                      BRP
//	CAN_BTR(CAN1) &= ~( ((          0x03) << 24) | ((           0x07) << 20) | ((           0x0F) << 16) | ((          0x1FF) << 0) ); 
//	CAN_BTR(CAN1) |=  ( (((SJW-1) & 0x03) << 24) | (((TBS2-1) & 0x07) << 20) | (((TBS1-1) & 0x0F) << 16) | (((brp-1) & 0x1FF) << 0) );


	CAN_BTR(CAN1) = 0x01230000; 	// Set register to RESET value p 657
 8004752:	4b6a      	ldr	r3, [pc, #424]	; (80048fc <can_init_pod_ldr+0x254>)
 8004754:	602b      	str	r3, [r5, #0]

	CAN_BTR(CAN1) |=    (bitcvt(p->silm)            << 31);	// Silent mode bit
 8004756:	7a60      	ldrb	r0, [r4, #9]
 8004758:	682f      	ldr	r7, [r5, #0]
 800475a:	f7ff ff8d 	bl	8004678 <bitcvt>
 800475e:	ea47 70c0 	orr.w	r0, r7, r0, lsl #31
 8004762:	6028      	str	r0, [r5, #0]
	CAN_BTR(CAN1) |=    (bitcvt(p->lbkm)            << 30);	// Loopback mode bit
 8004764:	7aa0      	ldrb	r0, [r4, #10]
 8004766:	682f      	ldr	r7, [r5, #0]
 8004768:	f7ff ff86 	bl	8004678 <bitcvt>
 800476c:	ea47 7080 	orr.w	r0, r7, r0, lsl #30
 8004770:	6028      	str	r0, [r5, #0]
	CAN_BTR(CAN1) |=  (((bitcvt(p->sjw )-1) & 0x03) << 24);	// Resynchronization jump width
 8004772:	7ae0      	ldrb	r0, [r4, #11]
 8004774:	682f      	ldr	r7, [r5, #0]
 8004776:	f7ff ff7f 	bl	8004678 <bitcvt>
 800477a:	3801      	subs	r0, #1
 800477c:	f000 0003 	and.w	r0, r0, #3
 8004780:	ea47 6700 	orr.w	r7, r7, r0, lsl #24
 8004784:	602f      	str	r7, [r5, #0]
	CAN_BTR(CAN1) |=  (((bitcvt(p->tbs2)-1) & 0x07) << 20);	// Time segment 2
 8004786:	7b20      	ldrb	r0, [r4, #12]
 8004788:	682f      	ldr	r7, [r5, #0]
 800478a:	f7ff ff75 	bl	8004678 <bitcvt>
 800478e:	3801      	subs	r0, #1
 8004790:	f000 0007 	and.w	r0, r0, #7
 8004794:	ea47 5700 	orr.w	r7, r7, r0, lsl #20
 8004798:	602f      	str	r7, [r5, #0]
	CAN_BTR(CAN1) |=  (((bitcvt(p->tbs1)-1) & 0x0F) << 16); // Time segment 1
 800479a:	7b60      	ldrb	r0, [r4, #13]
 800479c:	682f      	ldr	r7, [r5, #0]
 800479e:	f7ff ff6b 	bl	8004678 <bitcvt>
 80047a2:	3801      	subs	r0, #1
 80047a4:	f000 000f 	and.w	r0, r0, #15
 80047a8:	ea47 4700 	orr.w	r7, r7, r0, lsl #16
 80047ac:	602f      	str	r7, [r5, #0]
	CAN_BTR(CAN1) |=  (((brp-1)            & 0x3FF)  << 0); // Baud rate prescalar
 80047ae:	3e01      	subs	r6, #1
 80047b0:	682b      	ldr	r3, [r5, #0]
 80047b2:	05b6      	lsls	r6, r6, #22
 80047b4:	0db6      	lsrs	r6, r6, #22
 80047b6:	431e      	orrs	r6, r3
 80047b8:	602e      	str	r6, [r5, #0]
        0: The CAN hardware will automatically retransmit the message until it has been
        successfully transmitted according to the CAN standard.
        1: A message will be transmitted only once, independently of the transmission result
        (successful, error or arbitration lost).
 */
	CAN_MCR(CAN1) &= ~(0xfe);				// Clear bits except for INAQ
 80047ba:	f855 3c1c 	ldr.w	r3, [r5, #-28]
 80047be:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
 80047c2:	f845 3c1c 	str.w	r3, [r5, #-28]
	CAN_MCR(CAN1) |=  (bitcvt(p->ttcm) << 7);	// Time triggered communication mode
 80047c6:	7be0      	ldrb	r0, [r4, #15]
 80047c8:	f855 6c1c 	ldr.w	r6, [r5, #-28]
 80047cc:	f7ff ff54 	bl	8004678 <bitcvt>
 80047d0:	ea46 10c0 	orr.w	r0, r6, r0, lsl #7
 80047d4:	f845 0c1c 	str.w	r0, [r5, #-28]
	CAN_MCR(CAN1) |=  (bitcvt(p->abom) << 6);	// Automatic bus-off management
 80047d8:	7c20      	ldrb	r0, [r4, #16]
 80047da:	f855 6c1c 	ldr.w	r6, [r5, #-28]
 80047de:	f7ff ff4b 	bl	8004678 <bitcvt>
 80047e2:	ea46 1080 	orr.w	r0, r6, r0, lsl #6
 80047e6:	f845 0c1c 	str.w	r0, [r5, #-28]
	CAN_MCR(CAN1) |=  (bitcvt(p->awum) << 5);	// Auto WakeUp Mode
 80047ea:	7c60      	ldrb	r0, [r4, #17]
 80047ec:	f855 6c1c 	ldr.w	r6, [r5, #-28]
 80047f0:	f7ff ff42 	bl	8004678 <bitcvt>
 80047f4:	ea46 1040 	orr.w	r0, r6, r0, lsl #5
 80047f8:	f845 0c1c 	str.w	r0, [r5, #-28]
	CAN_MCR(CAN1) |=  (bitcvt(p->nart) << 4);	// No Automatic ReTry (0 = retry; non-zero = auto retry)
 80047fc:	7ca0      	ldrb	r0, [r4, #18]
 80047fe:	f855 6c1c 	ldr.w	r6, [r5, #-28]
 8004802:	f7ff ff39 	bl	8004678 <bitcvt>
 8004806:	ea46 1000 	orr.w	r0, r6, r0, lsl #4
 800480a:	f845 0c1c 	str.w	r0, [r5, #-28]

	/* Leave initialization mode */
	CAN_MCR(CAN1) &= ~CAN_MCR_INRQ;
 800480e:	f855 3c1c 	ldr.w	r3, [r5, #-28]
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
 8004812:	4a36      	ldr	r2, [pc, #216]	; (80048ec <can_init_pod_ldr+0x244>)
	CAN_MCR(CAN1) |=  (bitcvt(p->abom) << 6);	// Automatic bus-off management
	CAN_MCR(CAN1) |=  (bitcvt(p->awum) << 5);	// Auto WakeUp Mode
	CAN_MCR(CAN1) |=  (bitcvt(p->nart) << 4);	// No Automatic ReTry (0 = retry; non-zero = auto retry)

	/* Leave initialization mode */
	CAN_MCR(CAN1) &= ~CAN_MCR_INRQ;
 8004814:	f023 0301 	bic.w	r3, r3, #1
 8004818:	f845 3c1c 	str.w	r3, [r5, #-28]
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
	while ( ((CAN_MSR(CAN1) & CAN_MSR_INAK) != 0 ) && (can_timeout-- >= 0) );	// Wait until initialization mode starts or times out
 800481c:	4b34      	ldr	r3, [pc, #208]	; (80048f0 <can_init_pod_ldr+0x248>)
 800481e:	681b      	ldr	r3, [r3, #0]
 8004820:	f013 0f01 	tst.w	r3, #1
 8004824:	d102      	bne.n	800482c <can_init_pod_ldr+0x184>
	if (can_timeout <= 0 ) return -1;	// Timed out
 8004826:	2a00      	cmp	r2, #0
 8004828:	dc07      	bgt.n	800483a <can_init_pod_ldr+0x192>
 800482a:	e04d      	b.n	80048c8 <can_init_pod_ldr+0x220>
	CAN_MCR(CAN1) |=  (bitcvt(p->nart) << 4);	// No Automatic ReTry (0 = retry; non-zero = auto retry)

	/* Leave initialization mode */
	CAN_MCR(CAN1) &= ~CAN_MCR_INRQ;
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
	while ( ((CAN_MSR(CAN1) & CAN_MSR_INAK) != 0 ) && (can_timeout-- >= 0) );	// Wait until initialization mode starts or times out
 800482c:	3a01      	subs	r2, #1
 800482e:	f112 0f02 	cmn.w	r2, #2
 8004832:	d1f3      	bne.n	800481c <can_init_pod_ldr+0x174>
	if (can_timeout <= 0 ) return -1;	// Timed out
 8004834:	f04f 30ff 	mov.w	r0, #4294967295
 8004838:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

/* CYCCNT counter is in the Cortex-M-series core.  See the following for details 
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html */
	*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
 800483a:	4b31      	ldr	r3, [pc, #196]	; (8004900 <can_init_pod_ldr+0x258>)
	// Handles high priority CAN msgs, e.g. RESETALL, TIMESYNCx
	NVICIPR (NVIC_I2C1_EV_IRQ, NVIC_I2C1_EV_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
	NVICISER(NVIC_I2C1_EV_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')

	// Handles non-high priority msgs, e.g. sensor readings
	NVICIPR (NVIC_I2C1_ER_IRQ, NVIC_I2C1_ER_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
 800483c:	4d31      	ldr	r5, [pc, #196]	; (8004904 <can_init_pod_ldr+0x25c>)
	while ( ((CAN_MSR(CAN1) & CAN_MSR_INAK) != 0 ) && (can_timeout-- >= 0) );	// Wait until initialization mode starts or times out
	if (can_timeout <= 0 ) return -1;	// Timed out

/* CYCCNT counter is in the Cortex-M-series core.  See the following for details 
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html */
	*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
 800483e:	6819      	ldr	r1, [r3, #0]
	NVICIPR (NVIC_I2C1_EV_IRQ, NVIC_I2C1_EV_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
	NVICISER(NVIC_I2C1_EV_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')

	// Handles non-high priority msgs, e.g. sensor readings
	NVICIPR (NVIC_I2C1_ER_IRQ, NVIC_I2C1_ER_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
	NVICISER(NVIC_I2C1_ER_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')
 8004840:	4c31      	ldr	r4, [pc, #196]	; (8004908 <can_init_pod_ldr+0x260>)
	*(volatile unsigned int*)0xE0001000 |= 0x1;	// Enable DTW_CYCCNT (Data Watch cycle counter)

	/* Set and enable interrupt controller for doing software interrupt */
	// Handles high priority CAN msgs, e.g. RESETALL, TIMESYNCx
	NVICIPR (NVIC_I2C1_EV_IRQ, NVIC_I2C1_EV_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
	NVICISER(NVIC_I2C1_EV_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')
 8004842:	4832      	ldr	r0, [pc, #200]	; (800490c <can_init_pod_ldr+0x264>)
	while ( ((CAN_MSR(CAN1) & CAN_MSR_INAK) != 0 ) && (can_timeout-- >= 0) );	// Wait until initialization mode starts or times out
	if (can_timeout <= 0 ) return -1;	// Timed out

/* CYCCNT counter is in the Cortex-M-series core.  See the following for details 
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html */
	*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
 8004844:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 8004848:	6019      	str	r1, [r3, #0]
	*(volatile unsigned int*)0xE0001000 |= 0x1;	// Enable DTW_CYCCNT (Data Watch cycle counter)
 800484a:	4b31      	ldr	r3, [pc, #196]	; (8004910 <can_init_pod_ldr+0x268>)
 800484c:	6819      	ldr	r1, [r3, #0]
 800484e:	f041 0101 	orr.w	r1, r1, #1
 8004852:	6019      	str	r1, [r3, #0]

	/* Set and enable interrupt controller for doing software interrupt */
	// Handles high priority CAN msgs, e.g. RESETALL, TIMESYNCx
	NVICIPR (NVIC_I2C1_EV_IRQ, NVIC_I2C1_EV_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
 8004854:	4b2f      	ldr	r3, [pc, #188]	; (8004914 <can_init_pod_ldr+0x26c>)
 8004856:	6819      	ldr	r1, [r3, #0]
 8004858:	f041 4110 	orr.w	r1, r1, #2415919104	; 0x90000000
 800485c:	6019      	str	r1, [r3, #0]
	NVICISER(NVIC_I2C1_EV_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')

	// Handles non-high priority msgs, e.g. sensor readings
	NVICIPR (NVIC_I2C1_ER_IRQ, NVIC_I2C1_ER_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
 800485e:	6829      	ldr	r1, [r5, #0]
	NVICISER(NVIC_I2C1_ER_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')
 8004860:	6826      	ldr	r6, [r4, #0]
	*(volatile unsigned int*)0xE0001000 |= 0x1;	// Enable DTW_CYCCNT (Data Watch cycle counter)

	/* Set and enable interrupt controller for doing software interrupt */
	// Handles high priority CAN msgs, e.g. RESETALL, TIMESYNCx
	NVICIPR (NVIC_I2C1_EV_IRQ, NVIC_I2C1_EV_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
	NVICISER(NVIC_I2C1_EV_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')
 8004862:	6803      	ldr	r3, [r0, #0]
	// Handles non-high priority msgs, e.g. sensor readings
	NVICIPR (NVIC_I2C1_ER_IRQ, NVIC_I2C1_ER_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
	NVICISER(NVIC_I2C1_ER_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')

	// Handles non-high priority msgs, e.g. sensor readings
	NVICIPR (NVIC_I2C2_ER_IRQ, NVIC_I2C2_ER_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
 8004864:	f441 0160 	orr.w	r1, r1, #14680064	; 0xe00000
 8004868:	f041 01a0 	orr.w	r1, r1, #160	; 0xa0
 800486c:	6029      	str	r1, [r5, #0]
	NVICISER(NVIC_I2C2_ER_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')
 800486e:	f046 0105 	orr.w	r1, r6, #5
 8004872:	6021      	str	r1, [r4, #0]
	NVICISER(NVIC_CAN1_RX1_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_SCE_IRQ, NVIC_CAN_SCE_IRQ_PRIORITY );// Set interrupt priority
	NVICISER(NVIC_CAN1_SCE_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_TX_IRQ, NVIC_USB_HP_CAN_TX_IRQ_PRIORITY );// Set interrupt priority
 8004874:	4928      	ldr	r1, [pc, #160]	; (8004918 <can_init_pod_ldr+0x270>)
	// Handles non-high priority msgs, e.g. sensor readings
	NVICIPR (NVIC_I2C2_ER_IRQ, NVIC_I2C2_ER_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
	NVICISER(NVIC_I2C2_ER_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')

	/* Set and enable interrupt controller for CAN interrupts */
	NVICIPR (NVIC_CAN1_RX1_IRQ, NVIC_CAN_RX1_IRQ_PRIORITY );	// Set interrupt priority
 8004876:	4c29      	ldr	r4, [pc, #164]	; (800491c <can_init_pod_ldr+0x274>)
	NVICISER(NVIC_CAN1_RX1_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_SCE_IRQ, NVIC_CAN_SCE_IRQ_PRIORITY );// Set interrupt priority
	NVICISER(NVIC_CAN1_SCE_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_TX_IRQ, NVIC_USB_HP_CAN_TX_IRQ_PRIORITY );// Set interrupt priority
 8004878:	680e      	ldr	r6, [r1, #0]
	// Handles non-high priority msgs, e.g. sensor readings
	NVICIPR (NVIC_I2C2_ER_IRQ, NVIC_I2C2_ER_IRQ_PRIORITY );	// Set interrupt priority ('../lib/libusartstm32/nvicdirect.h')
	NVICISER(NVIC_I2C2_ER_IRQ);			// Enable interrupt controller ('../lib/libusartstm32/nvicdirect.h')

	/* Set and enable interrupt controller for CAN interrupts */
	NVICIPR (NVIC_CAN1_RX1_IRQ, NVIC_CAN_RX1_IRQ_PRIORITY );	// Set interrupt priority
 800487a:	6825      	ldr	r5, [r4, #0]
	NVICISER(NVIC_CAN1_RX1_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_SCE_IRQ, NVIC_CAN_SCE_IRQ_PRIORITY );// Set interrupt priority
	NVICISER(NVIC_CAN1_SCE_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_TX_IRQ, NVIC_USB_HP_CAN_TX_IRQ_PRIORITY );// Set interrupt priority
 800487c:	f046 46e0 	orr.w	r6, r6, #1879048192	; 0x70000000
 8004880:	600e      	str	r6, [r1, #0]
	NVICISER(NVIC_CAN1_TX_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_RX0_IRQ, NVIC_USB_LP_CAN_RX0_IRQ_PRIORITY );// Set interrupt priority
 8004882:	4927      	ldr	r1, [pc, #156]	; (8004920 <can_init_pod_ldr+0x278>)
	NVICISER(NVIC_CAN1_RX0_IRQ);				// Enable interrupt controller
 8004884:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
	NVICISER(NVIC_CAN1_SCE_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_TX_IRQ, NVIC_USB_HP_CAN_TX_IRQ_PRIORITY );// Set interrupt priority
	NVICISER(NVIC_CAN1_TX_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_RX0_IRQ, NVIC_USB_LP_CAN_RX0_IRQ_PRIORITY );// Set interrupt priority
 8004888:	ea45 0101 	orr.w	r1, r5, r1
	NVICISER(NVIC_CAN1_RX0_IRQ);				// Enable interrupt controller
 800488c:	f443 03f0 	orr.w	r3, r3, #7864320	; 0x780000
	NVICISER(NVIC_CAN1_SCE_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_TX_IRQ, NVIC_USB_HP_CAN_TX_IRQ_PRIORITY );// Set interrupt priority
	NVICISER(NVIC_CAN1_TX_IRQ);				// Enable interrupt controller

	NVICIPR (NVIC_CAN1_RX0_IRQ, NVIC_USB_LP_CAN_RX0_IRQ_PRIORITY );// Set interrupt priority
 8004890:	6021      	str	r1, [r4, #0]
	NVICISER(NVIC_CAN1_RX0_IRQ);				// Enable interrupt controller
 8004892:	6003      	str	r3, [r0, #0]
	       0: No interrupt generated when state of FMP[1:0] bits are not 00b.
	       1: Interrupt generated when state of FMP[1:0] bits are not 00b.
	   Bit 4 FMPIE1: FIFO message pending interrupt enable
	       0: No interrupt generated when state of FMP[1:0] bits are not 00b.
	       1: Interrupt generated when state of FMP[1:0] bits are not 00b. */
	CAN_IER(CAN1) |= CAN_IER_FMPIE0;	// FIFO 0 p 655
 8004894:	4b23      	ldr	r3, [pc, #140]	; (8004924 <can_init_pod_ldr+0x27c>)
 8004896:	6819      	ldr	r1, [r3, #0]
 8004898:	f041 0102 	orr.w	r1, r1, #2
 800489c:	6019      	str	r1, [r3, #0]
	CAN_IER(CAN1) |= CAN_IER_FMPIE1;	// FIFO 1 p 655
 800489e:	6819      	ldr	r1, [r3, #0]
 80048a0:	f041 0110 	orr.w	r1, r1, #16
 80048a4:	6019      	str	r1, [r3, #0]
	CAN_IER(CAN1) |= 0x1;	// Bit0: 1: Interrupt generated when RQCPx bit is set. p 656.
 80048a6:	6819      	ldr	r1, [r3, #0]
 80048a8:	f041 0101 	orr.w	r1, r1, #1
 80048ac:	6019      	str	r1, [r3, #0]

	/* Wait until ready */
	while ( (CAN_TSR(CAN1) & CAN_TSR_TME0) == 0);         // Wait for transmit mailbox 0 to be empty
 80048ae:	4b1e      	ldr	r3, [pc, #120]	; (8004928 <can_init_pod_ldr+0x280>)
 80048b0:	681b      	ldr	r3, [r3, #0]
 80048b2:	f013 6f80 	tst.w	r3, #67108864	; 0x4000000
 80048b6:	d0fa      	beq.n	80048ae <can_init_pod_ldr+0x206>

	return (CAN_TIMEOUT - can_timeout);	// Return wait loop count
 80048b8:	480c      	ldr	r0, [pc, #48]	; (80048ec <can_init_pod_ldr+0x244>)
 80048ba:	1a80      	subs	r0, r0, r2
 80048bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		/* Setup CAN RXD: PD00 for input pull up */
	f4gpiopins_Config ((volatile u32*)GPIOD,  0, (struct PINCONFIG*)&inputpup);

		break;
	default:
		return -2;
 80048be:	f06f 0001 	mvn.w	r0, #1
 80048c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* The initialization request (above) causes the INAK bit to be set.  This bit goes off when 11 consecutive
	   recessive bits have been received p 633 */
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
	while ( ((CAN_MSR(CAN1) & CAN_MSR_INAK) == 0 ) && (can_timeout-- >= 0) );	// Wait until initialization mode starts or times out
	if (can_timeout <= 0 ) return 0;	// Timed out
 80048c4:	2000      	movs	r0, #0
 80048c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* Leave initialization mode */
	CAN_MCR(CAN1) &= ~CAN_MCR_INRQ;
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
	while ( ((CAN_MSR(CAN1) & CAN_MSR_INAK) != 0 ) && (can_timeout-- >= 0) );	// Wait until initialization mode starts or times out
	if (can_timeout <= 0 ) return -1;	// Timed out
 80048c8:	f04f 30ff 	mov.w	r0, #4294967295

	/* Wait until ready */
	while ( (CAN_TSR(CAN1) & CAN_TSR_TME0) == 0);         // Wait for transmit mailbox 0 to be empty

	return (CAN_TIMEOUT - can_timeout);	// Return wait loop count
}
 80048cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80048ce:	bf00      	nop
 80048d0:	40023840 	.word	0x40023840
 80048d4:	40020000 	.word	0x40020000
 80048d8:	0801010c 	.word	0x0801010c
 80048dc:	40020400 	.word	0x40020400
 80048e0:	40020c00 	.word	0x40020c00
 80048e4:	40006400 	.word	0x40006400
 80048e8:	08010111 	.word	0x08010111
 80048ec:	005b8d80 	.word	0x005b8d80
 80048f0:	40006404 	.word	0x40006404
 80048f4:	4000641c 	.word	0x4000641c
 80048f8:	200016cc 	.word	0x200016cc
 80048fc:	01230000 	.word	0x01230000
 8004900:	e000edfc 	.word	0xe000edfc
 8004904:	e000e420 	.word	0xe000e420
 8004908:	e000e104 	.word	0xe000e104
 800490c:	e000e100 	.word	0xe000e100
 8004910:	e0001000 	.word	0xe0001000
 8004914:	e000e41c 	.word	0xe000e41c
 8004918:	e000e410 	.word	0xe000e410
 800491c:	e000e414 	.word	0xe000e414
 8004920:	00703070 	.word	0x00703070
 8004924:	40006414 	.word	0x40006414
 8004928:	40006408 	.word	0x40006408

0800492c <can_nxp_setRS_ldr>:
	GPIO_OSPEED_100MHZ, 	// speed: fastest 
	GPIO_PUPD_NONE, 	// pull up/down: none
	0 };			// AFRLy & AFRHy selection: not applicable

void can_nxp_setRS_ldr(int rs, volatile u32 * p, u16 pinnumber )
{
 800492c:	b570      	push	{r4, r5, r6, lr}
 800492e:	4606      	mov	r6, r0
 8004930:	460c      	mov	r4, r1
	// Floating input = resistor controls slope
	// Pin HI = standby;
	// Pin LO = high speed;

	/* Setup the i/o pin as output push-pull */
	f4gpiopins_Config ( p, pinnumber, (struct PINCONFIG*)&outputpp);
 8004932:	4608      	mov	r0, r1
	GPIO_OSPEED_100MHZ, 	// speed: fastest 
	GPIO_PUPD_NONE, 	// pull up/down: none
	0 };			// AFRLy & AFRHy selection: not applicable

void can_nxp_setRS_ldr(int rs, volatile u32 * p, u16 pinnumber )
{
 8004934:	4615      	mov	r5, r2
	// Floating input = resistor controls slope
	// Pin HI = standby;
	// Pin LO = high speed;

	/* Setup the i/o pin as output push-pull */
	f4gpiopins_Config ( p, pinnumber, (struct PINCONFIG*)&outputpp);
 8004936:	4611      	mov	r1, r2
 8004938:	4a06      	ldr	r2, [pc, #24]	; (8004954 <can_nxp_setRS_ldr+0x28>)
 800493a:	f7ff fe42 	bl	80045c2 <f4gpiopins_Config>
 800493e:	2301      	movs	r3, #1


	if (rs == 0)
 8004940:	b91e      	cbnz	r6, 800494a <can_nxp_setRS_ldr+0x1e>
		GPIO_BSRR(p) = (1<<(pinnumber+16));	// Set bit LO for SILENT mode
 8004942:	3510      	adds	r5, #16
 8004944:	40ab      	lsls	r3, r5
 8004946:	6623      	str	r3, [r4, #96]	; 0x60
 8004948:	bd70      	pop	{r4, r5, r6, pc}
	else
		GPIO_BSRR(p) = (1<<pinnumber);	// Set bit HI for NORMAL mode
 800494a:	fa13 f505 	lsls.w	r5, r3, r5
 800494e:	6625      	str	r5, [r4, #96]	; 0x60
 8004950:	bd70      	pop	{r4, r5, r6, pc}
 8004952:	bf00      	nop
 8004954:	08010116 	.word	0x08010116

08004958 <can_filter_unitid_ldr>:
 * @return	: Nothing for now.
*******************************************************************************/
static u32 myunitid_local;
void can_filter_unitid_ldr(u32 myunitid)
{
	myunitid_local = myunitid;	// Save unit id number locally (for RESET msg checking)
 8004958:	4a14      	ldr	r2, [pc, #80]	; (80049ac <can_filter_unitid_ldr+0x54>)
      the CAN_FA1R register).
      If a filter bank is not used, it is recommended to leave it non active (leave the corresponding
      FACT bit cleared).
*/
	/* CAN filter master register p 665 */
	CAN_FMR(CAN1)  |= CAN_FMR_FINIT;	// FINIT = 1; Initialization mode ON for setting up filter banks
 800495a:	4b15      	ldr	r3, [pc, #84]	; (80049b0 <can_filter_unitid_ldr+0x58>)
 * @param	: "my" can id
 * @return	: Nothing for now.
*******************************************************************************/
static u32 myunitid_local;
void can_filter_unitid_ldr(u32 myunitid)
{
 800495c:	b510      	push	{r4, lr}
	myunitid_local = myunitid;	// Save unit id number locally (for RESET msg checking)
 800495e:	6010      	str	r0, [r2, #0]
      the CAN_FA1R register).
      If a filter bank is not used, it is recommended to leave it non active (leave the corresponding
      FACT bit cleared).
*/
	/* CAN filter master register p 665 */
	CAN_FMR(CAN1)  |= CAN_FMR_FINIT;	// FINIT = 1; Initialization mode ON for setting up filter banks
 8004960:	6819      	ldr	r1, [r3, #0]
 8004962:	f041 0101 	orr.w	r1, r1, #1
 8004966:	6019      	str	r1, [r3, #0]
	   or when the FINIT bit of the CAN_FMR register is set. */

	/*   Set 16 bit filter mask and ID p 640 fig 229 */
	// Note: '>>16' is because for 16b scale mode the unit id goes in the low order word.
	// (CANx, <bank>) =  <[15:8] mask>      <[7:0] id>
	CAN_FiR1(CAN1, 0) = CAN_UNITID_MASK | (CAN_RESETALL  >> 16);	// All units accept this msg
 8004968:	4912      	ldr	r1, [pc, #72]	; (80049b4 <can_filter_unitid_ldr+0x5c>)
 800496a:	f04f 74f0 	mov.w	r4, #31457280	; 0x1e00000
 800496e:	600c      	str	r4, [r1, #0]
	CAN_FiR2(CAN1, 0) = CAN_UNITID_MASK | (CAN_TIMESYNC1 >> 16);	// All units accept this msg
 8004970:	3420      	adds	r4, #32
 8004972:	604c      	str	r4, [r1, #4]
	CAN_FiR1(CAN1, 1) = CAN_UNITID_MASK | (CAN_TIMESYNC2 >> 16);	// All units accept this msg
	CAN_FiR2(CAN1, 1) = CAN_UNITID_MASK | (CAN_TIMESYNC3 >> 16);	// All units accept this msg
	CAN_FiR1(CAN1, 2) = CAN_UNITID_MASK | (myunitid      >> 16);	// 'IAMUNITNUMBER' is unique to this unit
 8004974:	0c00      	lsrs	r0, r0, #16
	/*   Set 16 bit filter mask and ID p 640 fig 229 */
	// Note: '>>16' is because for 16b scale mode the unit id goes in the low order word.
	// (CANx, <bank>) =  <[15:8] mask>      <[7:0] id>
	CAN_FiR1(CAN1, 0) = CAN_UNITID_MASK | (CAN_RESETALL  >> 16);	// All units accept this msg
	CAN_FiR2(CAN1, 0) = CAN_UNITID_MASK | (CAN_TIMESYNC1 >> 16);	// All units accept this msg
	CAN_FiR1(CAN1, 1) = CAN_UNITID_MASK | (CAN_TIMESYNC2 >> 16);	// All units accept this msg
 8004976:	3420      	adds	r4, #32
 8004978:	608c      	str	r4, [r1, #8]
	CAN_FiR2(CAN1, 1) = CAN_UNITID_MASK | (CAN_TIMESYNC3 >> 16);	// All units accept this msg
	CAN_FiR1(CAN1, 2) = CAN_UNITID_MASK | (myunitid      >> 16);	// 'IAMUNITNUMBER' is unique to this unit
 800497a:	f040 70f0 	orr.w	r0, r0, #31457280	; 0x1e00000
	// Note: '>>16' is because for 16b scale mode the unit id goes in the low order word.
	// (CANx, <bank>) =  <[15:8] mask>      <[7:0] id>
	CAN_FiR1(CAN1, 0) = CAN_UNITID_MASK | (CAN_RESETALL  >> 16);	// All units accept this msg
	CAN_FiR2(CAN1, 0) = CAN_UNITID_MASK | (CAN_TIMESYNC1 >> 16);	// All units accept this msg
	CAN_FiR1(CAN1, 1) = CAN_UNITID_MASK | (CAN_TIMESYNC2 >> 16);	// All units accept this msg
	CAN_FiR2(CAN1, 1) = CAN_UNITID_MASK | (CAN_TIMESYNC3 >> 16);	// All units accept this msg
 800497e:	3420      	adds	r4, #32
 8004980:	60cc      	str	r4, [r1, #12]
	CAN_FiR1(CAN1, 2) = CAN_UNITID_MASK | (myunitid      >> 16);	// 'IAMUNITNUMBER' is unique to this unit
 8004982:	6108      	str	r0, [r1, #16]
	CAN_FiR2(CAN1, 2) = CAN_NEVERUSEID;			// Set leftover odd 16b mask|id 
 8004984:	f04f 30ff 	mov.w	r0, #4294967295
 8004988:	6148      	str	r0, [r1, #20]
	can_filt16num = 5;	// Show that filter bank 2, FiR2 is available
 800498a:	2105      	movs	r1, #5
 800498c:	8091      	strh	r1, [r2, #4]
2) Both (32b) registers of the pair must be setup, otherwise the register that is not set will be used in the filtering,
   and this can cause strange results since the mask|id might pass unwanted msgs.
3) Setting a register to zero passes *all* messages, (since the mask is 100% don't cares).
*/
	/* Assign filter to FIFO 1. Default: All messages pass through FIFO p 667 */
	CAN_FFA1R(CAN1) |= 0x3;	// Filter banks 0 and 1 pass through FIFO 1
 800498e:	4a0a      	ldr	r2, [pc, #40]	; (80049b8 <can_filter_unitid_ldr+0x60>)
 8004990:	6811      	ldr	r1, [r2, #0]
 8004992:	f041 0103 	orr.w	r1, r1, #3
 8004996:	6011      	str	r1, [r2, #0]
	/* Bits 27:0 FACTx: Filter active
            The software sets this bit to activate Filter x. To modify the Filter x registers (CAN_FxR[0:7]),
            the FACTx bit must be cleared or the FINIT bit of the CAN_FMR register must be set.
            0: Filter x is not active
            1: Filter x is active */
	CAN_FA1R(CAN1) |= 0x7;	// Activate filter banks 0, 1, 2. p 667
 8004998:	6891      	ldr	r1, [r2, #8]
 800499a:	f041 0107 	orr.w	r1, r1, #7
 800499e:	6091      	str	r1, [r2, #8]

	/* Remove filter registers from initialization mode */
	CAN_FMR(CAN1)  &= ~CAN_FMR_FINIT;	// FINIT = 0; Set initialization mode off for filter banks p 665
 80049a0:	681a      	ldr	r2, [r3, #0]
 80049a2:	f022 0201 	bic.w	r2, r2, #1
 80049a6:	601a      	str	r2, [r3, #0]

	return;
}
 80049a8:	bd10      	pop	{r4, pc}
 80049aa:	bf00      	nop
 80049ac:	20000fd0 	.word	0x20000fd0
 80049b0:	40006600 	.word	0x40006600
 80049b4:	40006640 	.word	0x40006640
 80049b8:	40006614 	.word	0x40006614

080049bc <can_filtermask16_add_ldr>:
 NOTE: These mask|ID's assign to the FIFO 0 (default)
*******************************************************************************/
u16 can_filtermask16_add_ldr(u32 m)
{
	/* F103 has 14 banks that can hold two 16 bit mask|ID's */
	if (can_filt16num >= (14 * 2)) return -1;
 80049bc:	4a17      	ldr	r2, [pc, #92]	; (8004a1c <can_filtermask16_add_ldr+0x60>)
 80049be:	8893      	ldrh	r3, [r2, #4]
 80049c0:	2b1b      	cmp	r3, #27
 * @param	: mask and ID: e.g. (CAN_UNITID_MASK | (CAN_TIMESYNC3 >> 16)
 * @return	: Filter number; negative for you have filled it up!
 NOTE: These mask|ID's assign to the FIFO 0 (default)
*******************************************************************************/
u16 can_filtermask16_add_ldr(u32 m)
{
 80049c2:	b510      	push	{r4, lr}
	/* F103 has 14 banks that can hold two 16 bit mask|ID's */
	if (can_filt16num >= (14 * 2)) return -1;
 80049c4:	d827      	bhi.n	8004a16 <can_filtermask16_add_ldr+0x5a>

	/* CAN filter master register p 665 */
	CAN_FMR(CAN1)  |= CAN_FMR_FINIT;	// FINIT = 1; Initialization mode ON for setting up filter banks
 80049c6:	4916      	ldr	r1, [pc, #88]	; (8004a20 <can_filtermask16_add_ldr+0x64>)
 80049c8:	680c      	ldr	r4, [r1, #0]

	if ((can_filt16num & 0x1) != 0)	// Does the last filter bank assigned have an used slot?
 80049ca:	f013 0f01 	tst.w	r3, #1
{
	/* F103 has 14 banks that can hold two 16 bit mask|ID's */
	if (can_filt16num >= (14 * 2)) return -1;

	/* CAN filter master register p 665 */
	CAN_FMR(CAN1)  |= CAN_FMR_FINIT;	// FINIT = 1; Initialization mode ON for setting up filter banks
 80049ce:	f044 0401 	orr.w	r4, r4, #1
 80049d2:	600c      	str	r4, [r1, #0]
 80049d4:	ea4f 0453 	mov.w	r4, r3, lsr #1

	if ((can_filt16num & 0x1) != 0)	// Does the last filter bank assigned have an used slot?
 80049d8:	d004      	beq.n	80049e4 <can_filtermask16_add_ldr+0x28>
	{ // Here, odd, therefore we can add this to the currently assigned filter bank
		CAN_FiR2(CAN1,(can_filt16num >> 1)) = m;	// Fill the 2nd slot
 80049da:	4b12      	ldr	r3, [pc, #72]	; (8004a24 <can_filtermask16_add_ldr+0x68>)
 80049dc:	18e3      	adds	r3, r4, r3
 80049de:	00db      	lsls	r3, r3, #3
 80049e0:	6058      	str	r0, [r3, #4]
 80049e2:	e00e      	b.n	8004a02 <can_filtermask16_add_ldr+0x46>
	}
	else
	{ /* Here, the count is even, so a new filter bank must be used */
		CAN_FiR1(CAN1,(can_filt16num >> 1)) = m;	// Fill the 1st slot
 80049e4:	4b0f      	ldr	r3, [pc, #60]	; (8004a24 <can_filtermask16_add_ldr+0x68>)
 80049e6:	b2a4      	uxth	r4, r4
 80049e8:	18e3      	adds	r3, r4, r3
 80049ea:	00db      	lsls	r3, r3, #3
		CAN_FiR2(CAN1,(can_filt16num >> 1)) = CAN_NEVERUSEID;	// Initialize the odd, 2nd 16b mask|id 
 80049ec:	f04f 31ff 	mov.w	r1, #4294967295
	{ // Here, odd, therefore we can add this to the currently assigned filter bank
		CAN_FiR2(CAN1,(can_filt16num >> 1)) = m;	// Fill the 2nd slot
	}
	else
	{ /* Here, the count is even, so a new filter bank must be used */
		CAN_FiR1(CAN1,(can_filt16num >> 1)) = m;	// Fill the 1st slot
 80049f0:	6018      	str	r0, [r3, #0]
		CAN_FiR2(CAN1,(can_filt16num >> 1)) = CAN_NEVERUSEID;	// Initialize the odd, 2nd 16b mask|id 
 80049f2:	6059      	str	r1, [r3, #4]

		/* Activate the newly assigned filter bank */
		CAN_FA1R(CAN1) |= (1 << (can_filt16num >> 1));
 80049f4:	490c      	ldr	r1, [pc, #48]	; (8004a28 <can_filtermask16_add_ldr+0x6c>)
 80049f6:	2301      	movs	r3, #1
 80049f8:	6808      	ldr	r0, [r1, #0]
 80049fa:	fa13 f404 	lsls.w	r4, r3, r4
 80049fe:	4304      	orrs	r4, r0
 8004a00:	600c      	str	r4, [r1, #0]
	}

	/* Update the count of mask|ID's we have set up */
	can_filt16num += 1;	// Show another was added
 8004a02:	8893      	ldrh	r3, [r2, #4]
 8004a04:	3301      	adds	r3, #1
 8004a06:	8093      	strh	r3, [r2, #4]

	/* Remove filter registers from initialization mode */
	CAN_FMR(CAN1)  &= ~CAN_FMR_FINIT;	// FINIT = 0; Set initialization mode off for filter banks p 665
 8004a08:	4b05      	ldr	r3, [pc, #20]	; (8004a20 <can_filtermask16_add_ldr+0x64>)
 8004a0a:	681a      	ldr	r2, [r3, #0]
 8004a0c:	f022 0201 	bic.w	r2, r2, #1
 8004a10:	601a      	str	r2, [r3, #0]
	
	return 0;
 8004a12:	2000      	movs	r0, #0
 8004a14:	bd10      	pop	{r4, pc}
 NOTE: These mask|ID's assign to the FIFO 0 (default)
*******************************************************************************/
u16 can_filtermask16_add_ldr(u32 m)
{
	/* F103 has 14 banks that can hold two 16 bit mask|ID's */
	if (can_filt16num >= (14 * 2)) return -1;
 8004a16:	f64f 70ff 	movw	r0, #65535	; 0xffff

	/* Remove filter registers from initialization mode */
	CAN_FMR(CAN1)  &= ~CAN_FMR_FINIT;	// FINIT = 0; Set initialization mode off for filter banks p 665
	
	return 0;
}
 8004a1a:	bd10      	pop	{r4, pc}
 8004a1c:	20000fd0 	.word	0x20000fd0
 8004a20:	40006600 	.word	0x40006600
 8004a24:	08000cc8 	.word	0x08000cc8
 8004a28:	4000661c 	.word	0x4000661c

08004a2c <canrcv_get_ldr>:
 * @return	: struct with pointer to buffer, ptr = zero if no new data
 ******************************************************************************/
struct CANRCVBUF* canrcv_get_ldr(void)
{
	struct CANRCVBUF *p;
	if (canbufIDXi == canbufIDXm) return 0;	// Return showing no new data
 8004a2c:	4b08      	ldr	r3, [pc, #32]	; (8004a50 <canrcv_get_ldr+0x24>)
 8004a2e:	689a      	ldr	r2, [r3, #8]
 8004a30:	68d9      	ldr	r1, [r3, #12]
 8004a32:	4291      	cmp	r1, r2
 8004a34:	d009      	beq.n	8004a4a <canrcv_get_ldr+0x1e>

	p = &canbuf[canbufIDXm];	// Get return pointer value

	canbufIDXm += 1; if (canbufIDXm >= CANRCVBUFSIZE) canbufIDXm = 0; // Wrap around end	
 8004a36:	1c51      	adds	r1, r2, #1
 8004a38:	293f      	cmp	r1, #63	; 0x3f
 8004a3a:	6099      	str	r1, [r3, #8]
 8004a3c:	dd01      	ble.n	8004a42 <canrcv_get_ldr+0x16>
 8004a3e:	2100      	movs	r1, #0
 8004a40:	6099      	str	r1, [r3, #8]
	return p;			// Return pointer to buffer
 8004a42:	4804      	ldr	r0, [pc, #16]	; (8004a54 <canrcv_get_ldr+0x28>)
 8004a44:	eb00 1002 	add.w	r0, r0, r2, lsl #4
 8004a48:	4770      	bx	lr
 * @return	: struct with pointer to buffer, ptr = zero if no new data
 ******************************************************************************/
struct CANRCVBUF* canrcv_get_ldr(void)
{
	struct CANRCVBUF *p;
	if (canbufIDXi == canbufIDXm) return 0;	// Return showing no new data
 8004a4a:	2000      	movs	r0, #0

	p = &canbuf[canbufIDXm];	// Get return pointer value

	canbufIDXm += 1; if (canbufIDXm >= CANRCVBUFSIZE) canbufIDXm = 0; // Wrap around end	
	return p;			// Return pointer to buffer
}
 8004a4c:	4770      	bx	lr
 8004a4e:	bf00      	nop
 8004a50:	20000fd0 	.word	0x20000fd0
 8004a54:	20000fe0 	.word	0x20000fe0

08004a58 <canrcvtim_get_ldr>:
 * @return	: struct with pointer to buffer, ptr = zero if no new data
 ******************************************************************************/
struct CANRCVTIMBUF* canrcvtim_get_ldr(void)
{
	struct CANRCVTIMBUF *p;
	if (canbuftimIDXi == canbuftimIDXm) return 0;	// Return showing no new data
 8004a58:	4b0a      	ldr	r3, [pc, #40]	; (8004a84 <canrcvtim_get_ldr+0x2c>)
 8004a5a:	f8d3 2410 	ldr.w	r2, [r3, #1040]	; 0x410
 8004a5e:	f8d3 1414 	ldr.w	r1, [r3, #1044]	; 0x414
 8004a62:	4291      	cmp	r1, r2
 8004a64:	d00c      	beq.n	8004a80 <canrcvtim_get_ldr+0x28>

	p = &cantimbuf[canbuftimIDXm];	// Get return pointer value	

	/* Advance index ('m' = mainline) */
	canbuftimIDXm += 1; if (canbuftimIDXm >= CANRCVTIMBUFSIZE) canbuftimIDXm = 0;// Reset to beginning
 8004a66:	1c51      	adds	r1, r2, #1
 8004a68:	290f      	cmp	r1, #15
 8004a6a:	f8c3 1410 	str.w	r1, [r3, #1040]	; 0x410
 8004a6e:	dd02      	ble.n	8004a76 <canrcvtim_get_ldr+0x1e>
 8004a70:	2100      	movs	r1, #0
 8004a72:	f8c3 1410 	str.w	r1, [r3, #1040]	; 0x410
	return p;			// Return pointer to buffer
 8004a76:	4b04      	ldr	r3, [pc, #16]	; (8004a88 <canrcvtim_get_ldr+0x30>)
 8004a78:	2018      	movs	r0, #24
 8004a7a:	fb00 3002 	mla	r0, r0, r2, r3
 8004a7e:	4770      	bx	lr
 * @return	: struct with pointer to buffer, ptr = zero if no new data
 ******************************************************************************/
struct CANRCVTIMBUF* canrcvtim_get_ldr(void)
{
	struct CANRCVTIMBUF *p;
	if (canbuftimIDXi == canbuftimIDXm) return 0;	// Return showing no new data
 8004a80:	2000      	movs	r0, #0
	p = &cantimbuf[canbuftimIDXm];	// Get return pointer value	

	/* Advance index ('m' = mainline) */
	canbuftimIDXm += 1; if (canbuftimIDXm >= CANRCVTIMBUFSIZE) canbuftimIDXm = 0;// Reset to beginning
	return p;			// Return pointer to buffer
}
 8004a82:	4770      	bx	lr
 8004a84:	20000fd0 	.word	0x20000fd0
 8004a88:	200013e8 	.word	0x200013e8

08004a8c <can_msg_txchkbuff_ldr>:
 ******************************************************************************/
int can_msg_txchkbuff_ldr(void)
{
	int temp;
	/* Compute remaining msgs in buffer */
	temp = (canxmtIDXi - canxmtIDXm);
 8004a8c:	4b04      	ldr	r3, [pc, #16]	; (8004aa0 <can_msg_txchkbuff_ldr+0x14>)
 8004a8e:	f8d3 0598 	ldr.w	r0, [r3, #1432]	; 0x598
 8004a92:	f8d3 359c 	ldr.w	r3, [r3, #1436]	; 0x59c
	if (temp < 0) temp += CANXMTBUFSIZE;
 8004a96:	1ac0      	subs	r0, r0, r3
 8004a98:	bf48      	it	mi
 8004a9a:	3010      	addmi	r0, #16
	
	return	temp-1; // Return number msg remaining buffered
}
 8004a9c:	3801      	subs	r0, #1
 8004a9e:	4770      	bx	lr
 8004aa0:	20000fd0 	.word	0x20000fd0

08004aa4 <can_msg_put_ldr>:
 * @param	: pointer to struct with msg: id, dlc, data
 * @return	: number msg remaining buffered
 * ==> NOTE: dlc is expected to be set when this routine is entered.
 ******************************************************************************/
int can_msg_put_ldr(struct CANRCVBUF *px)
{
 8004aa4:	b570      	push	{r4, r5, r6, lr}
	/* Copy msg into buffer */
	canxmtbuf[canxmtIDXm] = *px;	// Add msg to buffer
 8004aa6:	4c15      	ldr	r4, [pc, #84]	; (8004afc <can_msg_put_ldr+0x58>)
 8004aa8:	c80f      	ldmia	r0, {r0, r1, r2, r3}
 8004aaa:	f8d4 659c 	ldr.w	r6, [r4, #1436]	; 0x59c
 8004aae:	eb04 1506 	add.w	r5, r4, r6, lsl #4

	/* Advance buffer index */
	canxmtIDXm += 1; if (canxmtIDXm >= CANXMTBUFSIZE)    canxmtIDXm = 0;
 8004ab2:	3601      	adds	r6, #1
 * ==> NOTE: dlc is expected to be set when this routine is entered.
 ******************************************************************************/
int can_msg_put_ldr(struct CANRCVBUF *px)
{
	/* Copy msg into buffer */
	canxmtbuf[canxmtIDXm] = *px;	// Add msg to buffer
 8004ab4:	f505 65b4 	add.w	r5, r5, #1440	; 0x5a0

	/* Advance buffer index */
	canxmtIDXm += 1; if (canxmtIDXm >= CANXMTBUFSIZE)    canxmtIDXm = 0;
 8004ab8:	2e0f      	cmp	r6, #15
 * ==> NOTE: dlc is expected to be set when this routine is entered.
 ******************************************************************************/
int can_msg_put_ldr(struct CANRCVBUF *px)
{
	/* Copy msg into buffer */
	canxmtbuf[canxmtIDXm] = *px;	// Add msg to buffer
 8004aba:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}

	/* Advance buffer index */
	canxmtIDXm += 1; if (canxmtIDXm >= CANXMTBUFSIZE)    canxmtIDXm = 0;
 8004abe:	f8c4 659c 	str.w	r6, [r4, #1436]	; 0x59c
 8004ac2:	dd02      	ble.n	8004aca <can_msg_put_ldr+0x26>
 8004ac4:	2300      	movs	r3, #0
 8004ac6:	f8c4 359c 	str.w	r3, [r4, #1436]	; 0x59c

can_debugP += 1;	// Msgs added to buffer
 8004aca:	f8d4 36a0 	ldr.w	r3, [r4, #1696]	; 0x6a0
 8004ace:	4a0b      	ldr	r2, [pc, #44]	; (8004afc <can_msg_put_ldr+0x58>)
 8004ad0:	3301      	adds	r3, #1
 8004ad2:	f8c4 36a0 	str.w	r3, [r4, #1696]	; 0x6a0

	/* Load mailbox if it is empty and the interrupt request bit has been turned off p 655 */
	// Mailbox needs to be loaded if TME0 and RQCP0 bits are mailbox empty and interrupt request serviced 
	if ( (CAN_TSR(CAN1) & (CAN_TSR_TME0 | CAN_TSR_RQCP0)) == CAN_TSR_TME0)  
 8004ad6:	4b0a      	ldr	r3, [pc, #40]	; (8004b00 <can_msg_put_ldr+0x5c>)
 8004ad8:	6819      	ldr	r1, [r3, #0]
 8004ada:	4b0a      	ldr	r3, [pc, #40]	; (8004b04 <can_msg_put_ldr+0x60>)
 8004adc:	ea01 0303 	and.w	r3, r1, r3
 8004ae0:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8004ae4:	d107      	bne.n	8004af6 <can_msg_put_ldr+0x52>
	{ // Here yes.  Mailbox is empty.  Load mailbox, set TXRQ	
		loadmbx(&canxmtbuf[canxmtIDXi]);
 8004ae6:	f8d2 0598 	ldr.w	r0, [r2, #1432]	; 0x598
 8004aea:	f502 63b4 	add.w	r3, r2, #1440	; 0x5a0
 8004aee:	eb03 1000 	add.w	r0, r3, r0, lsl #4
 8004af2:	f7ff fdc5 	bl	8004680 <loadmbx>
	}
	
	return	can_msg_txchkbuff_ldr(); // Return number msg remaining buffered
}
 8004af6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	if ( (CAN_TSR(CAN1) & (CAN_TSR_TME0 | CAN_TSR_RQCP0)) == CAN_TSR_TME0)  
	{ // Here yes.  Mailbox is empty.  Load mailbox, set TXRQ	
		loadmbx(&canxmtbuf[canxmtIDXi]);
	}
	
	return	can_msg_txchkbuff_ldr(); // Return number msg remaining buffered
 8004afa:	e7c7      	b.n	8004a8c <can_msg_txchkbuff_ldr>
 8004afc:	20000fd0 	.word	0x20000fd0
 8004b00:	40006408 	.word	0x40006408
 8004b04:	04000001 	.word	0x04000001

08004b08 <can_msg_rcv_expand_ldr>:
 * @return	: nothing
 ******************************************************************************/
void can_msg_rcv_expand_ldr(struct CANRCVBUF *px)
{
	int i;
	int temp = (px->dlc & 0xf);	// Get byte count in received msg
 8004b08:	6842      	ldr	r2, [r0, #4]
 8004b0a:	f002 020f 	and.w	r2, r2, #15
	if (temp > 8) temp = 8;		// JIC the number exceeds the array
 8004b0e:	2a08      	cmp	r2, #8
 * @brief	: Fill bytes not received with zeros
 * @param	: pointer to struct with msg: id, dlc & data
 * @return	: nothing
 ******************************************************************************/
void can_msg_rcv_expand_ldr(struct CANRCVBUF *px)
{
 8004b10:	b510      	push	{r4, lr}
	int i;
	int temp = (px->dlc & 0xf);	// Get byte count in received msg
	if (temp > 8) temp = 8;		// JIC the number exceeds the array
 8004b12:	dc01      	bgt.n	8004b18 <can_msg_rcv_expand_ldr+0x10>
	if (temp <= 0) { px->cd.ull = 0; return; }
 8004b14:	b90a      	cbnz	r2, 8004b1a <can_msg_rcv_expand_ldr+0x12>
 8004b16:	e002      	b.n	8004b1e <can_msg_rcv_expand_ldr+0x16>
 ******************************************************************************/
void can_msg_rcv_expand_ldr(struct CANRCVBUF *px)
{
	int i;
	int temp = (px->dlc & 0xf);	// Get byte count in received msg
	if (temp > 8) temp = 8;		// JIC the number exceeds the array
 8004b18:	2208      	movs	r2, #8
 8004b1a:	2307      	movs	r3, #7
 8004b1c:	e008      	b.n	8004b30 <can_msg_rcv_expand_ldr+0x28>
	if (temp <= 0) { px->cd.ull = 0; return; }
 8004b1e:	2200      	movs	r2, #0
 8004b20:	2300      	movs	r3, #0
 8004b22:	e9c0 2302 	strd	r2, r3, [r0, #8]
 8004b26:	bd10      	pop	{r4, pc}
 * void can_msg_rcv_expand_ldr(struct CANRCVBUF *px);
 * @brief	: Fill bytes not received with zeros
 * @param	: pointer to struct with msg: id, dlc & data
 * @return	: nothing
 ******************************************************************************/
void can_msg_rcv_expand_ldr(struct CANRCVBUF *px)
 8004b28:	18c1      	adds	r1, r0, r3
	if (temp > 8) temp = 8;		// JIC the number exceeds the array
	if (temp <= 0) { px->cd.ull = 0; return; }
	
	/* Clear bytes not received. */
	for (i = 7; i >= temp; i--)	// Work from hi-ord byte down
		px->cd.uc[i] = 0;	// Set unsent byte to zero
 8004b2a:	2400      	movs	r4, #0
 8004b2c:	720c      	strb	r4, [r1, #8]
	int temp = (px->dlc & 0xf);	// Get byte count in received msg
	if (temp > 8) temp = 8;		// JIC the number exceeds the array
	if (temp <= 0) { px->cd.ull = 0; return; }
	
	/* Clear bytes not received. */
	for (i = 7; i >= temp; i--)	// Work from hi-ord byte down
 8004b2e:	3b01      	subs	r3, #1
 8004b30:	4293      	cmp	r3, r2
 8004b32:	daf9      	bge.n	8004b28 <can_msg_rcv_expand_ldr+0x20>
 8004b34:	bd10      	pop	{r4, pc}

08004b36 <can_msg_setsize_ldr>:
 * @param	: pointer to struct with msg: id, dlc & data
 * @return	: nothing
 ******************************************************************************/
void can_msg_setsize_ldr(struct CANRCVBUF *px, int count)
{
	px->dlc &= ~0xf;	// Clear dlc field
 8004b36:	6843      	ldr	r3, [r0, #4]
	px->dlc |= count & 0xf;	// Add new count
 8004b38:	f001 010f 	and.w	r1, r1, #15
 * @param	: pointer to struct with msg: id, dlc & data
 * @return	: nothing
 ******************************************************************************/
void can_msg_setsize_ldr(struct CANRCVBUF *px, int count)
{
	px->dlc &= ~0xf;	// Clear dlc field
 8004b3c:	f023 030f 	bic.w	r3, r3, #15
	px->dlc |= count & 0xf;	// Add new count
 8004b40:	4319      	orrs	r1, r3
 8004b42:	6041      	str	r1, [r0, #4]
	return;
}
 8004b44:	4770      	bx	lr

08004b46 <canmsg_send_ldr>:
 * @param	: data1 = 1st 4 bytes of payload
 * @param	: data2 = 2nd 4 bytes of payload
 * @brief 	: send CAN msg
 *####################################################################################### */
void canmsg_send_ldr(struct CANRCVBUF * p, int data1, int data2)
{
 8004b46:	b510      	push	{r4, lr}
	p->cd.ui[0] = data1;
 8004b48:	6081      	str	r1, [r0, #8]
	p->cd.ui[1] = data2;
 8004b4a:	60c2      	str	r2, [r0, #12]

//	can_msg_rcv_compress(p);	// Set byte count: according to MSB
	can_msg_setsize_ldr(p, 8);	// Set byte count: Fixed xmt
 8004b4c:	2108      	movs	r1, #8
 * @param	: data1 = 1st 4 bytes of payload
 * @param	: data2 = 2nd 4 bytes of payload
 * @brief 	: send CAN msg
 *####################################################################################### */
void canmsg_send_ldr(struct CANRCVBUF * p, int data1, int data2)
{
 8004b4e:	4604      	mov	r4, r0
	p->cd.ui[0] = data1;
	p->cd.ui[1] = data2;

//	can_msg_rcv_compress(p);	// Set byte count: according to MSB
	can_msg_setsize_ldr(p, 8);	// Set byte count: Fixed xmt
 8004b50:	f7ff fff1 	bl	8004b36 <can_msg_setsize_ldr>

 	/* Setup CAN msg in output buffer/queue */
	if ( can_msg_put_ldr(p) <= 0)
 8004b54:	4620      	mov	r0, r4
 8004b56:	f7ff ffa5 	bl	8004aa4 <can_msg_put_ldr>
 8004b5a:	2800      	cmp	r0, #0
 8004b5c:	dc05      	bgt.n	8004b6a <canmsg_send_ldr+0x24>
		can_msgovrflow += 1;
 8004b5e:	4b03      	ldr	r3, [pc, #12]	; (8004b6c <canmsg_send_ldr+0x26>)
 8004b60:	f8d3 26a4 	ldr.w	r2, [r3, #1700]	; 0x6a4
 8004b64:	3201      	adds	r2, #1
 8004b66:	f8c3 26a4 	str.w	r2, [r3, #1700]	; 0x6a4
 8004b6a:	bd10      	pop	{r4, pc}
 8004b6c:	20000fd0 	.word	0x20000fd0

08004b70 <canmsg_send_ldr_n>:
 *####################################################################################### */
void canmsg_send_ldr_n(struct CANRCVBUF * p, u8* pin, s32 n)
{
	u8* pout = &p->cd.uc[0];	// Pointer into CAN msg payload field

	if (n > 8) n = 8;	if (n < 0) n = 0; // Make sure 'n' is bounded.
 8004b70:	2a08      	cmp	r2, #8
 * @param	: pc = pointer to bytes to send
 * @param	: n = number of bytes to send
 * @brief 	: send CAN msg that is less than 8 bytes
 *####################################################################################### */
void canmsg_send_ldr_n(struct CANRCVBUF * p, u8* pin, s32 n)
{
 8004b72:	b510      	push	{r4, lr}
	u8* pout = &p->cd.uc[0];	// Pointer into CAN msg payload field

	if (n > 8) n = 8;	if (n < 0) n = 0; // Make sure 'n' is bounded.
 8004b74:	bfd8      	it	le
 8004b76:	ea22 72e2 	bicle.w	r2, r2, r2, asr #31
 * @param	: pc = pointer to bytes to send
 * @param	: n = number of bytes to send
 * @brief 	: send CAN msg that is less than 8 bytes
 *####################################################################################### */
void canmsg_send_ldr_n(struct CANRCVBUF * p, u8* pin, s32 n)
{
 8004b7a:	4604      	mov	r4, r0
	u8* pout = &p->cd.uc[0];	// Pointer into CAN msg payload field
 8004b7c:	f100 0308 	add.w	r3, r0, #8

	if (n > 8) n = 8;	if (n < 0) n = 0; // Make sure 'n' is bounded.
 8004b80:	bfc8      	it	gt
 8004b82:	2208      	movgt	r2, #8
 8004b84:	e004      	b.n	8004b90 <canmsg_send_ldr_n+0x20>
	while (n > 0) {*pout++ = *pin++; n -= 1;} // Copy data to payload
 8004b86:	f811 0b01 	ldrb.w	r0, [r1], #1
 8004b8a:	f803 0b01 	strb.w	r0, [r3], #1
 8004b8e:	3a01      	subs	r2, #1
 8004b90:	2a00      	cmp	r2, #0
 8004b92:	dcf8      	bgt.n	8004b86 <canmsg_send_ldr_n+0x16>

//	can_msg_rcv_compress(p);	// Set byte count: according to MSB
	can_msg_setsize_ldr(p, n);	// Set byte count: Fixed xmt
 8004b94:	4620      	mov	r0, r4
 8004b96:	4611      	mov	r1, r2
 8004b98:	f7ff ffcd 	bl	8004b36 <can_msg_setsize_ldr>

 	/* Setup CAN msg in output buffer/queue */
	if ( can_msg_put_ldr(p) <= 0)
 8004b9c:	4620      	mov	r0, r4
 8004b9e:	f7ff ff81 	bl	8004aa4 <can_msg_put_ldr>
 8004ba2:	2800      	cmp	r0, #0
 8004ba4:	dc05      	bgt.n	8004bb2 <canmsg_send_ldr_n+0x42>
		can_msgovrflow += 1;
 8004ba6:	4b03      	ldr	r3, [pc, #12]	; (8004bb4 <canmsg_send_ldr_n+0x44>)
 8004ba8:	f8d3 26a4 	ldr.w	r2, [r3, #1700]	; 0x6a4
 8004bac:	3201      	adds	r2, #1
 8004bae:	f8c3 26a4 	str.w	r2, [r3, #1700]	; 0x6a4
 8004bb2:	bd10      	pop	{r4, pc}
 8004bb4:	20000fd0 	.word	0x20000fd0

08004bb8 <CAN1_TX_IRQHandler>:
–   Transmit mailbox 1 becomes empty, RQCP1 bit in the CAN_TSR register set.
–   Transmit mailbox 2 becomes empty, RQCP2 bit in the CAN_TSR register set. */
u32 can_terr = 0; 	// Count of TERR flags

void CAN1_TX_IRQHandler(void)
{
 8004bb8:	b508      	push	{r3, lr}
	int temp;
//while (1==1);
	CAN_TSR(CAN1) = (CAN_TSR_RQCP1 | CAN_TSR_RQCP2);	// JIC mbx 2 & 3 have a flag
 8004bba:	4a19      	ldr	r2, [pc, #100]	; (8004c20 <CAN1_TX_IRQHandler+0x68>)
 8004bbc:	4b19      	ldr	r3, [pc, #100]	; (8004c24 <CAN1_TX_IRQHandler+0x6c>)
 8004bbe:	601a      	str	r2, [r3, #0]

	if ((CAN_TSR(CAN1) & CAN_TSR_RQCP0) != 0) // Is mailbox0 RQCP0 (request complete) ON?
 8004bc0:	681a      	ldr	r2, [r3, #0]
 8004bc2:	f012 0f01 	tst.w	r2, #1
 8004bc6:	d027      	beq.n	8004c18 <CAN1_TX_IRQHandler+0x60>
	{ // Here, yes.  
		/* Primitive error handling */
		if ((CAN_TSR(CAN1) & 0x8) != 0) can_terr += 1; // Count errors
 8004bc8:	681b      	ldr	r3, [r3, #0]
 8004bca:	f013 0f08 	tst.w	r3, #8
 8004bce:	4b16      	ldr	r3, [pc, #88]	; (8004c28 <CAN1_TX_IRQHandler+0x70>)
 8004bd0:	d004      	beq.n	8004bdc <CAN1_TX_IRQHandler+0x24>
 8004bd2:	f8d3 26a8 	ldr.w	r2, [r3, #1704]	; 0x6a8
 8004bd6:	3201      	adds	r2, #1
 8004bd8:	f8c3 26a8 	str.w	r2, [r3, #1704]	; 0x6a8

		/* Clear RQCPx  */
		CAN_TSR(CAN1) = CAN_TSR_RQCP0;	// Clear RQPx (which clears TERRx, ALSTx, TXOKx)
 8004bdc:	4a11      	ldr	r2, [pc, #68]	; (8004c24 <CAN1_TX_IRQHandler+0x6c>)
 8004bde:	2101      	movs	r1, #1
 8004be0:	6011      	str	r1, [r2, #0]
		
		/* Advance buffer index */
		canxmtIDXi += 1; if (canxmtIDXi >= CANXMTBUFSIZE)    canxmtIDXi = 0;
 8004be2:	f8d3 2598 	ldr.w	r2, [r3, #1432]	; 0x598
 8004be6:	1852      	adds	r2, r2, r1
 8004be8:	2a0f      	cmp	r2, #15
 8004bea:	f8c3 2598 	str.w	r2, [r3, #1432]	; 0x598
 8004bee:	dd03      	ble.n	8004bf8 <CAN1_TX_IRQHandler+0x40>
 8004bf0:	4a0d      	ldr	r2, [pc, #52]	; (8004c28 <CAN1_TX_IRQHandler+0x70>)
 8004bf2:	3901      	subs	r1, #1
 8004bf4:	f8c2 1598 	str.w	r1, [r2, #1432]	; 0x598
can_debugM += 1;	// Buffer msgs loaded to mbx
 8004bf8:	f8d3 26ac 	ldr.w	r2, [r3, #1708]	; 0x6ac
 8004bfc:	3201      	adds	r2, #1
 8004bfe:	f8c3 26ac 	str.w	r2, [r3, #1708]	; 0x6ac

		/* Load more data, if buffer not empty */
		if (canxmtIDXm != canxmtIDXi)	// Are we caught up?
 8004c02:	f8d3 2598 	ldr.w	r2, [r3, #1432]	; 0x598
 8004c06:	f8d3 359c 	ldr.w	r3, [r3, #1436]	; 0x59c
 8004c0a:	4293      	cmp	r3, r2
 8004c0c:	d004      	beq.n	8004c18 <CAN1_TX_IRQHandler+0x60>
		{ // Here, no.  Msgs remain in buffer
			loadmbx(&canxmtbuf[canxmtIDXi]);	// Load mailbox, set TXRQ
 8004c0e:	4807      	ldr	r0, [pc, #28]	; (8004c2c <CAN1_TX_IRQHandler+0x74>)
 8004c10:	eb00 1002 	add.w	r0, r0, r2, lsl #4
 8004c14:	f7ff fd34 	bl	8004680 <loadmbx>
		}
	}
	temp = CAN_TSR(CAN1);	// JIC Prevent tail-chaining
 8004c18:	4b02      	ldr	r3, [pc, #8]	; (8004c24 <CAN1_TX_IRQHandler+0x6c>)
 8004c1a:	681b      	ldr	r3, [r3, #0]

	return;
}
 8004c1c:	bd08      	pop	{r3, pc}
 8004c1e:	bf00      	nop
 8004c20:	00010100 	.word	0x00010100
 8004c24:	40006408 	.word	0x40006408
 8004c28:	20000fd0 	.word	0x20000fd0
 8004c2c:	20001570 	.word	0x20001570

08004c30 <CAN1_RX0_IRQHandler>:
void CAN1_RX0_IRQHandler(void)
{
	int temp;
//while(1==1);
	/* Save message in a circular buffer */
	canbuf[canbufIDXi].id     = CAN_RI0R(CAN1);	// ID, RTR, IDE
 8004c30:	4b11      	ldr	r3, [pc, #68]	; (8004c78 <CAN1_RX0_IRQHandler+0x48>)
 8004c32:	4a12      	ldr	r2, [pc, #72]	; (8004c7c <CAN1_RX0_IRQHandler+0x4c>)
 8004c34:	68d9      	ldr	r1, [r3, #12]
 8004c36:	6810      	ldr	r0, [r2, #0]
 8004c38:	eb03 1201 	add.w	r2, r3, r1, lsl #4
 8004c3c:	6110      	str	r0, [r2, #16]
	canbuf[canbufIDXi].dlc	  = CAN_RDT0R(CAN1);	// time, data length CAN_RDTxR p 663
 8004c3e:	4810      	ldr	r0, [pc, #64]	; (8004c80 <CAN1_RX0_IRQHandler+0x50>)
 8004c40:	6800      	ldr	r0, [r0, #0]
 8004c42:	6150      	str	r0, [r2, #20]
	canbuf[canbufIDXi].cd.ui[0] = CAN_RDL0R(CAN1);	// Data (32b) High, Data (32b) Low
 8004c44:	480f      	ldr	r0, [pc, #60]	; (8004c84 <CAN1_RX0_IRQHandler+0x54>)
 8004c46:	6800      	ldr	r0, [r0, #0]
 8004c48:	6190      	str	r0, [r2, #24]
	canbuf[canbufIDXi].cd.ui[1] = CAN_RDH0R(CAN1);	// Data (32b) High, Data (32b) Low
 8004c4a:	480f      	ldr	r0, [pc, #60]	; (8004c88 <CAN1_RX0_IRQHandler+0x58>)
 8004c4c:	6800      	ldr	r0, [r0, #0]
 8004c4e:	61d0      	str	r0, [r2, #28]
//			SCB_AIRCR = (0x5FA << 16) | SCB_AIRCR_SYSRESETREQ;	// Cause a RESET
//	}


	/* Release FIFO 0 */	
	CAN_RF0R(CAN1) |= CAN_RF0R_RFOM0;	// Write bit 5
 8004c50:	4a0e      	ldr	r2, [pc, #56]	; (8004c8c <CAN1_RX0_IRQHandler+0x5c>)
 8004c52:	6810      	ldr	r0, [r2, #0]
 8004c54:	f040 0020 	orr.w	r0, r0, #32
 8004c58:	6010      	str	r0, [r2, #0]

	/* Advance index in circular buffer */
	canbufIDXi += 1; if (canbufIDXi >= CANRCVBUFSIZE) canbufIDXi = 0;// Reset to beginning
 8004c5a:	1c4a      	adds	r2, r1, #1
 8004c5c:	2a3f      	cmp	r2, #63	; 0x3f
 8004c5e:	60da      	str	r2, [r3, #12]
 8004c60:	dd01      	ble.n	8004c66 <CAN1_RX0_IRQHandler+0x36>
 8004c62:	2200      	movs	r2, #0
 8004c64:	60da      	str	r2, [r3, #12]
		
	/* Trigger a pending interrupt, which will cause a chain of related routines to execute */
	NVICISPR(NVIC_I2C1_ER_IRQ);	// Set pending (low priority) interrupt ('../lib/libusartstm32/nvicdirect.h')
 8004c66:	4b0a      	ldr	r3, [pc, #40]	; (8004c90 <CAN1_RX0_IRQHandler+0x60>)
 8004c68:	681a      	ldr	r2, [r3, #0]
 8004c6a:	f042 0201 	orr.w	r2, r2, #1
 8004c6e:	601a      	str	r2, [r3, #0]

	temp = CAN_RF0R(CAN1);	// Read register to avoid tail-chaining
 8004c70:	4b06      	ldr	r3, [pc, #24]	; (8004c8c <CAN1_RX0_IRQHandler+0x5c>)
 8004c72:	681b      	ldr	r3, [r3, #0]

	return;
}
 8004c74:	4770      	bx	lr
 8004c76:	bf00      	nop
 8004c78:	20000fd0 	.word	0x20000fd0
 8004c7c:	400065b0 	.word	0x400065b0
 8004c80:	400065b4 	.word	0x400065b4
 8004c84:	400065b8 	.word	0x400065b8
 8004c88:	400065bc 	.word	0x400065bc
 8004c8c:	4000640c 	.word	0x4000640c
 8004c90:	e000e204 	.word	0xe000e204

08004c94 <CAN1_RX1_IRQHandler>:
–   FIFO1 overrun condition, FOVR1 bit in the CAN_RF1R register set. */
void CAN1_RX1_IRQHandler(void)
{ // Here, FMP1 bits are not 00.
	int temp;
//while(1==1);
	fifo1cycnt = *(volatile unsigned int *)0xE0001004; // DWT_CYCNT
 8004c94:	4b28      	ldr	r3, [pc, #160]	; (8004d38 <CAN1_RX1_IRQHandler+0xa4>)
 8004c96:	6818      	ldr	r0, [r3, #0]
 8004c98:	4b28      	ldr	r3, [pc, #160]	; (8004d3c <CAN1_RX1_IRQHandler+0xa8>)
	fifo1msgflg += 1;
 8004c9a:	f8d3 26b4 	ldr.w	r2, [r3, #1716]	; 0x6b4
 8004c9e:	3201      	adds	r2, #1
/* p 647,8 The FIFO 1 interrupt can be generated by the following three events (only X = enabled):
X   Reception of a new message, FMP1 bits in the CAN_RF1R register are not ‘00’.
–   FIFO1 full condition, FULL1 bit in the CAN_RF1R register set.
–   FIFO1 overrun condition, FOVR1 bit in the CAN_RF1R register set. */
void CAN1_RX1_IRQHandler(void)
{ // Here, FMP1 bits are not 00.
 8004ca0:	b510      	push	{r4, lr}
	int temp;
//while(1==1);
	fifo1cycnt = *(volatile unsigned int *)0xE0001004; // DWT_CYCNT
	fifo1msgflg += 1;
 8004ca2:	f8c3 26b4 	str.w	r2, [r3, #1716]	; 0x6b4

	/* Save time & message in a circular buffer */
	cantimbuf[canbuftimIDXi].U.ull    = fifo1cycnt;// Get current tick time
 8004ca6:	f8d3 2414 	ldr.w	r2, [r3, #1044]	; 0x414
–   FIFO1 overrun condition, FOVR1 bit in the CAN_RF1R register set. */
void CAN1_RX1_IRQHandler(void)
{ // Here, FMP1 bits are not 00.
	int temp;
//while(1==1);
	fifo1cycnt = *(volatile unsigned int *)0xE0001004; // DWT_CYCNT
 8004caa:	f8c3 06b0 	str.w	r0, [r3, #1712]	; 0x6b0
	fifo1msgflg += 1;

	/* Save time & message in a circular buffer */
	cantimbuf[canbuftimIDXi].U.ull    = fifo1cycnt;// Get current tick time
 8004cae:	2418      	movs	r4, #24
 8004cb0:	4362      	muls	r2, r4
 8004cb2:	f503 6183 	add.w	r1, r3, #1048	; 0x418
 8004cb6:	188c      	adds	r4, r1, r2
 8004cb8:	5088      	str	r0, [r1, r2]
 8004cba:	2100      	movs	r1, #0
 8004cbc:	6061      	str	r1, [r4, #4]
	cantimbuf[canbuftimIDXi].R.id     = CAN_RI1R(CAN1);	// ID, RTR, IDE
 8004cbe:	4920      	ldr	r1, [pc, #128]	; (8004d40 <CAN1_RX1_IRQHandler+0xac>)
 8004cc0:	189a      	adds	r2, r3, r2
 8004cc2:	6809      	ldr	r1, [r1, #0]
 8004cc4:	f8c2 1420 	str.w	r1, [r2, #1056]	; 0x420
	cantimbuf[canbuftimIDXi].R.dlc	  = CAN_RDT1R(CAN1);	// time, data length CAN_RDTxR p 663
 8004cc8:	491e      	ldr	r1, [pc, #120]	; (8004d44 <CAN1_RX1_IRQHandler+0xb0>)
 8004cca:	6809      	ldr	r1, [r1, #0]
 8004ccc:	f8c2 1424 	str.w	r1, [r2, #1060]	; 0x424
	cantimbuf[canbuftimIDXi].R.cd.ui[0] = CAN_RDL1R(CAN1);	// Data (32b) Low
 8004cd0:	491d      	ldr	r1, [pc, #116]	; (8004d48 <CAN1_RX1_IRQHandler+0xb4>)
 8004cd2:	6809      	ldr	r1, [r1, #0]
 8004cd4:	f8c2 1428 	str.w	r1, [r2, #1064]	; 0x428
	cantimbuf[canbuftimIDXi].R.cd.ui[1] = CAN_RDH1R(CAN1);	// Data (32b) High
 8004cd8:	491c      	ldr	r1, [pc, #112]	; (8004d4c <CAN1_RX1_IRQHandler+0xb8>)
 8004cda:	6809      	ldr	r1, [r1, #0]
 8004cdc:	f8c2 142c 	str.w	r1, [r2, #1068]	; 0x42c

	/* Release FIFO 1 */	
	CAN_RF1R(CAN1) |= CAN_RF1R_RFOM1;		// Write bit 5 to release FIFO msg
 8004ce0:	491b      	ldr	r1, [pc, #108]	; (8004d50 <CAN1_RX1_IRQHandler+0xbc>)
 8004ce2:	6808      	ldr	r0, [r1, #0]
 8004ce4:	f040 0020 	orr.w	r0, r0, #32
 8004ce8:	6008      	str	r0, [r1, #0]
//		SCB_AIRCR = (0x5FA << 16) | SCB_AIRCR_SYSRESETREQ;	// Cause a RESET
//	}

	// Note: in the following the RTR & IDE bits must be off, so it won't be confused with 29 bit addresses
	/* Did some ask to reset the wait loop timeout delay? */
	if ( canbuf[canbufIDXi].id == (CAN_RESETALL | CAN_DATAID_WAITDELAYRESET) )
 8004cea:	68d9      	ldr	r1, [r3, #12]
 8004cec:	eb03 1101 	add.w	r1, r3, r1, lsl #4
 8004cf0:	6909      	ldr	r1, [r1, #16]
 8004cf2:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
 8004cf6:	d10c      	bne.n	8004d12 <CAN1_RX1_IRQHandler+0x7e>
	{	if ( (cantimbuf[canbuftimIDXi].R.dlc & 0xf) == 4 )	// Only one 4 byte value allowed
 8004cf8:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
 8004cfc:	f001 010f 	and.w	r1, r1, #15
 8004d00:	2904      	cmp	r1, #4
 8004d02:	d106      	bne.n	8004d12 <CAN1_RX1_IRQHandler+0x7e>
			can_waitdelay_ct += cantimbuf[canbuftimIDXi].R.cd.ui[0];	// Add pay load value to ctr
 8004d04:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
 8004d08:	f8d3 26b8 	ldr.w	r2, [r3, #1720]	; 0x6b8
 8004d0c:	188a      	adds	r2, r1, r2
 8004d0e:	f8c3 26b8 	str.w	r2, [r3, #1720]	; 0x6b8
	}
	
	/* Advance index in circular buffer */
	canbuftimIDXi += 1; if (canbuftimIDXi >= CANRCVTIMBUFSIZE) canbuftimIDXi = 0;// Reset to beginning
 8004d12:	f8d3 2414 	ldr.w	r2, [r3, #1044]	; 0x414
 8004d16:	3201      	adds	r2, #1
 8004d18:	2a0f      	cmp	r2, #15
 8004d1a:	f8c3 2414 	str.w	r2, [r3, #1044]	; 0x414
 8004d1e:	dd03      	ble.n	8004d28 <CAN1_RX1_IRQHandler+0x94>
 8004d20:	4b06      	ldr	r3, [pc, #24]	; (8004d3c <CAN1_RX1_IRQHandler+0xa8>)
 8004d22:	2200      	movs	r2, #0
 8004d24:	f8c3 2414 	str.w	r2, [r3, #1044]	; 0x414

	/* Trigger a pending interrupt, which will cause a chain of related routines to execute */
	NVICISPR(NVIC_I2C1_EV_IRQ);	// Set pending (low priority) interrupt ('../lib/libusartstm32/nvicdirect.h')
 8004d28:	4b0a      	ldr	r3, [pc, #40]	; (8004d54 <CAN1_RX1_IRQHandler+0xc0>)
 8004d2a:	681a      	ldr	r2, [r3, #0]
 8004d2c:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8004d30:	601a      	str	r2, [r3, #0]

	temp = CAN_RF1R(CAN1);	// Read back register to avoid tail-chaining
 8004d32:	4b07      	ldr	r3, [pc, #28]	; (8004d50 <CAN1_RX1_IRQHandler+0xbc>)
 8004d34:	681b      	ldr	r3, [r3, #0]

	return;
}
 8004d36:	bd10      	pop	{r4, pc}
 8004d38:	e0001004 	.word	0xe0001004
 8004d3c:	20000fd0 	.word	0x20000fd0
 8004d40:	400065c0 	.word	0x400065c0
 8004d44:	400065c4 	.word	0x400065c4
 8004d48:	400065c8 	.word	0x400065c8
 8004d4c:	400065cc 	.word	0x400065cc
 8004d50:	40006410 	.word	0x40006410
 8004d54:	e000e200 	.word	0xe000e200

08004d58 <CAN1_SCE_IRQHandler>:
–   Entry into Sleep mode. */
void CAN1_SCE_IRQHandler(void)
{
//while(1==1);
	return;
}
 8004d58:	4770      	bx	lr

08004d5a <I2C1_EV_IRQHandler>:
/*#######################################################################################
 * ISR routine for FIFO 1 (higher than other low priority level)
 *####################################################################################### */
void I2C1_EV_IRQHandler(void)
{
 8004d5a:	b508      	push	{r3, lr}
/* This interrupt is caused by the CAN FIFO 1 (time sync message) interrupt for further processing at a low interrupt priority */

	/* Call other routines if an address is set up */
	if (highpriority_ptr != 0)	// Having no address for the following is bad.
 8004d5c:	4b02      	ldr	r3, [pc, #8]	; (8004d68 <I2C1_EV_IRQHandler+0xe>)
 8004d5e:	f8d3 36bc 	ldr.w	r3, [r3, #1724]	; 0x6bc
 8004d62:	b103      	cbz	r3, 8004d66 <I2C1_EV_IRQHandler+0xc>
		(*highpriority_ptr)();	// Go do something
 8004d64:	4798      	blx	r3
 8004d66:	bd08      	pop	{r3, pc}
 8004d68:	20000fd0 	.word	0x20000fd0

08004d6c <I2C1_ER_IRQHandler>:
}
/*#######################################################################################
 * ISR routine for FIFO 0 low priority level
 *####################################################################################### */
void I2C1_ER_IRQHandler(void)
{
 8004d6c:	b508      	push	{r3, lr}
	/* Call other routines if an address is set up */
	if (lowpriority_ptr != 0)	// Having no address for the following is bad.
 8004d6e:	4b03      	ldr	r3, [pc, #12]	; (8004d7c <I2C1_ER_IRQHandler+0x10>)
 8004d70:	f8d3 36c0 	ldr.w	r3, [r3, #1728]	; 0x6c0
 8004d74:	b103      	cbz	r3, 8004d78 <I2C1_ER_IRQHandler+0xc>
		(*lowpriority_ptr)();	// Go do something
 8004d76:	4798      	blx	r3
 8004d78:	bd08      	pop	{r3, pc}
 8004d7a:	bf00      	nop
 8004d7c:	20000fd0 	.word	0x20000fd0

08004d80 <I2C2_EV_IRQHandler>:
}
/*#######################################################################################
 * ISR routine for SYSTICK low priority level
 *####################################################################################### */
void I2C2_EV_IRQHandler(void)
{
 8004d80:	b508      	push	{r3, lr}
	/* Call other routines if an address is set up */
	if (systickLOpriority_ptr != 0)	// Having no address for the following is bad.
 8004d82:	4b03      	ldr	r3, [pc, #12]	; (8004d90 <I2C2_EV_IRQHandler+0x10>)
 8004d84:	f8d3 36c4 	ldr.w	r3, [r3, #1732]	; 0x6c4
 8004d88:	b103      	cbz	r3, 8004d8c <I2C2_EV_IRQHandler+0xc>
		(*systickLOpriority_ptr)();	// Go do something
 8004d8a:	4798      	blx	r3
 8004d8c:	bd08      	pop	{r3, pc}
 8004d8e:	bf00      	nop
 8004d90:	20000fd0 	.word	0x20000fd0

08004d94 <I2C2_ER_IRQHandler>:
}
/*#######################################################################################
 * ISR routine for very low priority following CAN_sync routine
 *####################################################################################### */
void I2C2_ER_IRQHandler(void)
{
 8004d94:	b508      	push	{r3, lr}
	/* Call other routines if an address is set up */
	if (fifo1veryLOpriority_ptr != 0)	// Having no address for the following is bad.
 8004d96:	4b03      	ldr	r3, [pc, #12]	; (8004da4 <I2C2_ER_IRQHandler+0x10>)
 8004d98:	f8d3 36c8 	ldr.w	r3, [r3, #1736]	; 0x6c8
 8004d9c:	b103      	cbz	r3, 8004da0 <I2C2_ER_IRQHandler+0xc>
		(*fifo1veryLOpriority_ptr)();	// Go do something
 8004d9e:	4798      	blx	r3
 8004da0:	bd08      	pop	{r3, pc}
 8004da2:	bf00      	nop
 8004da4:	20000fd0 	.word	0x20000fd0

08004da8 <loop>:
{
	LEDSALL_off;
	return;
}	
static void loop(volatile int ct)
{
 8004da8:	b082      	sub	sp, #8
 8004daa:	9001      	str	r0, [sp, #4]
	while (ct > 0) ct -= 1; 
 8004dac:	e002      	b.n	8004db4 <loop+0xc>
 8004dae:	9b01      	ldr	r3, [sp, #4]
 8004db0:	3b01      	subs	r3, #1
 8004db2:	9301      	str	r3, [sp, #4]
 8004db4:	9b01      	ldr	r3, [sp, #4]
 8004db6:	2b00      	cmp	r3, #0
 8004db8:	dcf9      	bgt.n	8004dae <loop+0x6>
	return;
}
 8004dba:	b002      	add	sp, #8
 8004dbc:	4770      	bx	lr

08004dbe <panic_leds>:
 * @brief	: Configure gpio pins for Discovery F4 board
 ******************************************************************************/
int PanicCount;

void panic_leds(unsigned int count)
{
 8004dbe:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	unsigned int i;
	volatile int x;		// Loop ct for timing pause
	volatile int xon;	// Loop ct for timing LED on duration
	volatile int xoff;	// Loop ct for timing LED off duration
	int sw = 0;
PanicCount = count; // Usefull for debugging this
 8004dc0:	4b1d      	ldr	r3, [pc, #116]	; (8004e38 <panic_leds+0x7a>)
	/* Have clocks been setup? */
	if (sysclk_freq < 1000000)
 8004dc2:	4a1e      	ldr	r2, [pc, #120]	; (8004e3c <panic_leds+0x7e>)
	unsigned int i;
	volatile int x;		// Loop ct for timing pause
	volatile int xon;	// Loop ct for timing LED on duration
	volatile int xoff;	// Loop ct for timing LED off duration
	int sw = 0;
PanicCount = count; // Usefull for debugging this
 8004dc4:	6018      	str	r0, [r3, #0]
	/* Have clocks been setup? */
	if (sysclk_freq < 1000000)
 8004dc6:	4b1e      	ldr	r3, [pc, #120]	; (8004e40 <panic_leds+0x82>)
 8004dc8:	6819      	ldr	r1, [r3, #0]
 8004dca:	4291      	cmp	r1, r2
	{ // Here, no.  We are running on the 8 MHz HSI oscillator
		sysclk_freq = 8000000;	// Set default
 8004dcc:	bf9c      	itt	ls
 8004dce:	4d1d      	ldrls	r5, [pc, #116]	; (8004e44 <panic_leds+0x86>)
 8004dd0:	601d      	strls	r5, [r3, #0]
		sw = 8000000;	// Not zero
	}

	/* Setup timing for pause */
	x = sysclk_freq/10;
 8004dd2:	681b      	ldr	r3, [r3, #0]
{
	unsigned int i;
	volatile int x;		// Loop ct for timing pause
	volatile int xon;	// Loop ct for timing LED on duration
	volatile int xoff;	// Loop ct for timing LED off duration
	int sw = 0;
 8004dd4:	bf88      	it	hi
 8004dd6:	2500      	movhi	r5, #0
		sysclk_freq = 8000000;	// Set default
		sw = 8000000;	// Not zero
	}

	/* Setup timing for pause */
	x = sysclk_freq/10;
 8004dd8:	220a      	movs	r2, #10
 8004dda:	fbb3 f2f2 	udiv	r2, r3, r2
 8004dde:	9203      	str	r2, [sp, #12]

	/* Setup timing for fast flash */
	xon =  sysclk_freq/250;
 8004de0:	22fa      	movs	r2, #250	; 0xfa
 8004de2:	fbb3 f2f2 	udiv	r2, r3, r2
 8004de6:	9202      	str	r2, [sp, #8]
	xoff = sysclk_freq/40;
 8004de8:	2228      	movs	r2, #40	; 0x28
 8004dea:	fbb3 f3f2 	udiv	r3, r3, r2
 8004dee:	9301      	str	r3, [sp, #4]

	/* Limit max count */
	if (count == 0) count = 6; // Bogus count

	/* Be sure we have the ports and pins setup for the LEDs */
	RCC_AHB1ENR |= 0x08;	// Enable IO port D
 8004df0:	4b15      	ldr	r3, [pc, #84]	; (8004e48 <panic_leds+0x8a>)
 8004df2:	681a      	ldr	r2, [r3, #0]
 8004df4:	f042 0208 	orr.w	r2, r2, #8
 * @brief	: Configure gpio pins for Discovery F4 board
 ******************************************************************************/
int PanicCount;

void panic_leds(unsigned int count)
{
 8004df8:	4604      	mov	r4, r0

	/* Limit max count */
	if (count == 0) count = 6; // Bogus count

	/* Be sure we have the ports and pins setup for the LEDs */
	RCC_AHB1ENR |= 0x08;	// Enable IO port D
 8004dfa:	601a      	str	r2, [r3, #0]
	/* Setup timing for fast flash */
	xon =  sysclk_freq/250;
	xoff = sysclk_freq/40;

	/* Limit max count */
	if (count == 0) count = 6; // Bogus count
 8004dfc:	2800      	cmp	r0, #0
 8004dfe:	bf08      	it	eq
 8004e00:	2406      	moveq	r4, #6

	/* Be sure we have the ports and pins setup for the LEDs */
	RCC_AHB1ENR |= 0x08;	// Enable IO port D
	DISCgpiopins_Config();	// Configure pins
 8004e02:	f7ff fbbd 	bl	8004580 <DISCgpiopins_Config>

	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	if (sw == 0)
 8004e06:	b175      	cbz	r5, 8004e26 <panic_leds+0x68>
 8004e08:	e014      	b.n	8004e34 <panic_leds+0x76>
#include "libopencm3/stm32/f4/rcc.h"

extern unsigned int	sysclk_freq;	/* 	SYSCLK freq		E.g. 72000000	*/
static void allon(void)
{
	LEDSALL_on;
 8004e0a:	4e10      	ldr	r6, [pc, #64]	; (8004e4c <panic_leds+0x8e>)
 8004e0c:	f44f 4370 	mov.w	r3, #61440	; 0xf000
 8004e10:	6033      	str	r3, [r6, #0]
	{
		while (1==1)
		{
			for (i = 0; i < count; i++)
			{
				allon();	loop(xon);
 8004e12:	9802      	ldr	r0, [sp, #8]
 8004e14:	f7ff ffc8 	bl	8004da8 <loop>
	LEDSALL_on;
	return;
}
static void alloff(void)
{
	LEDSALL_off;
 8004e18:	f04f 4370 	mov.w	r3, #4026531840	; 0xf0000000
 8004e1c:	6033      	str	r3, [r6, #0]
		while (1==1)
		{
			for (i = 0; i < count; i++)
			{
				allon();	loop(xon);
				alloff();	loop(xoff);			
 8004e1e:	9801      	ldr	r0, [sp, #4]
 8004e20:	f7ff ffc2 	bl	8004da8 <loop>
	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	if (sw == 0)
	{
		while (1==1)
		{
			for (i = 0; i < count; i++)
 8004e24:	3501      	adds	r5, #1
 8004e26:	42a5      	cmp	r5, r4
 8004e28:	d3ef      	bcc.n	8004e0a <panic_leds+0x4c>
			{
				allon();	loop(xon);
				alloff();	loop(xoff);			
			}
			loop(x);
 8004e2a:	9803      	ldr	r0, [sp, #12]
 8004e2c:	f7ff ffbc 	bl	8004da8 <loop>
	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	if (sw == 0)
	{
		while (1==1)
		{
			for (i = 0; i < count; i++)
 8004e30:	2500      	movs	r5, #0
 8004e32:	e7f8      	b.n	8004e26 <panic_leds+0x68>
				alloff();	loop(xoff);			
			}
			loop(x);
		}
	}
}
 8004e34:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
 8004e36:	bf00      	nop
 8004e38:	200016b0 	.word	0x200016b0
 8004e3c:	000f423f 	.word	0x000f423f
 8004e40:	200016d4 	.word	0x200016d4
 8004e44:	007a1200 	.word	0x007a1200
 8004e48:	40023830 	.word	0x40023830
 8004e4c:	40020c18 	.word	0x40020c18

08004e50 <CAN_gateway_send>:
 * @param	: pg = Pointer to message buffer (see common_can.h)
 * @return	: 0 = OK; -1 = dlc greater than 8; -2 = illegal extended address
 * ************************************************************************************** */

int CAN_gateway_send(struct CANRCVBUF* pg)
{
 8004e50:	b508      	push	{r3, lr}
	/* Check number of bytes in payload and limit to 8. */
	if ((pg->dlc & 0x0f) > 8) 
 8004e52:	6843      	ldr	r3, [r0, #4]
 8004e54:	f003 030f 	and.w	r3, r3, #15
 8004e58:	2b08      	cmp	r3, #8
 8004e5a:	d80b      	bhi.n	8004e74 <CAN_gateway_send+0x24>
		return -1;	// Payload ct too big
	
	/* Check if an illegal id combination */
	if ( ((pg->id & 0x001ffff9) != 0) && ((pg->id & 0x04) == 0) ) 
 8004e5c:	6802      	ldr	r2, [r0, #0]
 8004e5e:	4b08      	ldr	r3, [pc, #32]	; (8004e80 <CAN_gateway_send+0x30>)
 8004e60:	ea02 0303 	and.w	r3, r2, r3
 8004e64:	b113      	cbz	r3, 8004e6c <CAN_gateway_send+0x1c>
 8004e66:	f012 0f04 	tst.w	r2, #4
 8004e6a:	d006      	beq.n	8004e7a <CAN_gateway_send+0x2a>
	{ // Here, in the additional 18 extended id bits one or more are on, but IDE flag is for standard id (11 bits)
		return -2; // Illegal id
	}

	/* Add msg to CAN outgoing buffer. */
	can_msg_put_ldr(pg);
 8004e6c:	f7ff fe1a 	bl	8004aa4 <can_msg_put_ldr>

	return 0;
 8004e70:	2000      	movs	r0, #0
 8004e72:	bd08      	pop	{r3, pc}

int CAN_gateway_send(struct CANRCVBUF* pg)
{
	/* Check number of bytes in payload and limit to 8. */
	if ((pg->dlc & 0x0f) > 8) 
		return -1;	// Payload ct too big
 8004e74:	f04f 30ff 	mov.w	r0, #4294967295
 8004e78:	bd08      	pop	{r3, pc}
	
	/* Check if an illegal id combination */
	if ( ((pg->id & 0x001ffff9) != 0) && ((pg->id & 0x04) == 0) ) 
	{ // Here, in the additional 18 extended id bits one or more are on, but IDE flag is for standard id (11 bits)
		return -2; // Illegal id
 8004e7a:	f06f 0001 	mvn.w	r0, #1

	/* Add msg to CAN outgoing buffer. */
	can_msg_put_ldr(pg);

	return 0;
}
 8004e7e:	bd08      	pop	{r3, pc}
 8004e80:	001ffff9 	.word	0x001ffff9

08004e84 <spi2rw_init>:
/******************************************************************************
 * void spi2rw_init(void);
 *  @brief Initialize SPI 
*******************************************************************************/ 
void spi2rw_init(void)
{
 8004e84:	b538      	push	{r3, r4, r5, lr}
	/* Enable bus clocking for SPI2 */
	RCC_APB1ENR |= (1<<14);	// Enable SPI2 clocking
 8004e86:	4b17      	ldr	r3, [pc, #92]	; (8004ee4 <spi2rw_init+0x60>)

	/* Set up pins for SPI2 use. */
	f4gpiopins_Config ((volatile u32*)GPIOB, 12, (struct PINCONFIG*)&outputcs);	// CS
 8004e88:	4c17      	ldr	r4, [pc, #92]	; (8004ee8 <spi2rw_init+0x64>)
 *  @brief Initialize SPI 
*******************************************************************************/ 
void spi2rw_init(void)
{
	/* Enable bus clocking for SPI2 */
	RCC_APB1ENR |= (1<<14);	// Enable SPI2 clocking
 8004e8a:	681a      	ldr	r2, [r3, #0]

	/* Set up pins for SPI2 use. */
	f4gpiopins_Config ((volatile u32*)GPIOB, 12, (struct PINCONFIG*)&outputcs);	// CS
 8004e8c:	4817      	ldr	r0, [pc, #92]	; (8004eec <spi2rw_init+0x68>)
 *  @brief Initialize SPI 
*******************************************************************************/ 
void spi2rw_init(void)
{
	/* Enable bus clocking for SPI2 */
	RCC_APB1ENR |= (1<<14);	// Enable SPI2 clocking
 8004e8e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8004e92:	601a      	str	r2, [r3, #0]

	/* Set up pins for SPI2 use. */
	f4gpiopins_Config ((volatile u32*)GPIOB, 12, (struct PINCONFIG*)&outputcs);	// CS
 8004e94:	210c      	movs	r1, #12
 8004e96:	4622      	mov	r2, r4
	f4gpiopins_Config ((volatile u32*)GPIOB, 13, (struct PINCONFIG*)&outputaf);	// SCK
 8004e98:	1d65      	adds	r5, r4, #5
{
	/* Enable bus clocking for SPI2 */
	RCC_APB1ENR |= (1<<14);	// Enable SPI2 clocking

	/* Set up pins for SPI2 use. */
	f4gpiopins_Config ((volatile u32*)GPIOB, 12, (struct PINCONFIG*)&outputcs);	// CS
 8004e9a:	f7ff fb92 	bl	80045c2 <f4gpiopins_Config>
	f4gpiopins_Config ((volatile u32*)GPIOB, 13, (struct PINCONFIG*)&outputaf);	// SCK
 8004e9e:	4813      	ldr	r0, [pc, #76]	; (8004eec <spi2rw_init+0x68>)
 8004ea0:	210d      	movs	r1, #13
 8004ea2:	462a      	mov	r2, r5
 8004ea4:	f7ff fb8d 	bl	80045c2 <f4gpiopins_Config>
	f4gpiopins_Config ((volatile u32*)GPIOB, 14, (struct PINCONFIG*)&inputaf);	// MISO
 8004ea8:	4810      	ldr	r0, [pc, #64]	; (8004eec <spi2rw_init+0x68>)
 8004eaa:	210e      	movs	r1, #14
 8004eac:	f104 020a 	add.w	r2, r4, #10
 8004eb0:	f7ff fb87 	bl	80045c2 <f4gpiopins_Config>
	f4gpiopins_Config ((volatile u32*)GPIOB, 15, (struct PINCONFIG*)&outputaf);	// MOSI
 8004eb4:	462a      	mov	r2, r5
 8004eb6:	480d      	ldr	r0, [pc, #52]	; (8004eec <spi2rw_init+0x68>)
 8004eb8:	210f      	movs	r1, #15
 8004eba:	f7ff fb82 	bl	80045c2 <f4gpiopins_Config>

	GPIO_BSRR(GPIOB)  = (1<<12);// Set /CS high
 8004ebe:	4b0c      	ldr	r3, [pc, #48]	; (8004ef0 <spi2rw_init+0x6c>)
 8004ec0:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8004ec4:	601a      	str	r2, [r3, #0]

	// Set divisor to max.  If APB1 is 42 Mhz, then divide by 256 = 164062.5 Hz, 48 us per byte
/* NOTE: The following line is where the "phase" is set for the clock and polarity */
	//          (SSM SSI)  |enable peripheral | baud divisor | master select | CK 1 when idle    | phase  | lsb first)
	SPI2_CR1 =  (0x3 << 8) |   (1 << 6)       | (0x7 << 3)   |   (1 << 2)    |    (1 << 1)       |  0x01  | (1 << 7)  ;
 8004ec6:	4b0b      	ldr	r3, [pc, #44]	; (8004ef4 <spi2rw_init+0x70>)
 8004ec8:	f240 32ff 	movw	r2, #1023	; 0x3ff
 8004ecc:	601a      	str	r2, [r3, #0]
	
	/* SPI-CR2 use default, no interrupt masks enabled at this point */

	/* Set and enable interrupt controller for SPI2 */
	NVICIPR (NVIC_SPI2_IRQ, SPI2_PRIORITY );	// Set interrupt priority
 8004ece:	4b0a      	ldr	r3, [pc, #40]	; (8004ef8 <spi2rw_init+0x74>)
 8004ed0:	681a      	ldr	r2, [r3, #0]
 8004ed2:	f042 0250 	orr.w	r2, r2, #80	; 0x50
 8004ed6:	601a      	str	r2, [r3, #0]
	NVICISER(NVIC_SPI2_IRQ);			// Enable interrupt controller for SPI2
 8004ed8:	4b08      	ldr	r3, [pc, #32]	; (8004efc <spi2rw_init+0x78>)
 8004eda:	681a      	ldr	r2, [r3, #0]
 8004edc:	f042 0210 	orr.w	r2, r2, #16
 8004ee0:	601a      	str	r2, [r3, #0]

	return;
}
 8004ee2:	bd38      	pop	{r3, r4, r5, pc}
 8004ee4:	40023840 	.word	0x40023840
 8004ee8:	0801011b 	.word	0x0801011b
 8004eec:	40020400 	.word	0x40020400
 8004ef0:	40020418 	.word	0x40020418
 8004ef4:	40003800 	.word	0x40003800
 8004ef8:	e000e424 	.word	0xe000e424
 8004efc:	e000e104 	.word	0xe000e104

08004f00 <spi2_busy>:
 * @return	: 0 = /CS line is low; not-zero (busy) = /CS line is high (not busy)
*******************************************************************************/
unsigned short spi2_busy(void)
{
/* The /CS line is used to show if the SPI transfer is in progress */
	return (GPIOB_ODR & (1<<12));	// Return /CS bit
 8004f00:	4b02      	ldr	r3, [pc, #8]	; (8004f0c <spi2_busy+0xc>)
 8004f02:	6818      	ldr	r0, [r3, #0]
}
 8004f04:	f400 5080 	and.w	r0, r0, #4096	; 0x1000
 8004f08:	4770      	bx	lr
 8004f0a:	bf00      	nop
 8004f0c:	40020414 	.word	0x40020414

08004f10 <spi2_rw>:
 * @param	: char *pout = pointer to byte array with bytes to output
 * @param	: char *pin  = pointer to byte array to receive bytes coming in
 * @param	: int count  = byte count of number of write/read cycles
*******************************************************************************/
void spi2_rw (char *pout, char * pin, int count)
{
 8004f10:	b570      	push	{r4, r5, r6, lr}
 8004f12:	4604      	mov	r4, r0
 8004f14:	460d      	mov	r5, r1
 8004f16:	4616      	mov	r6, r2
	/* The following should not be necessary, but it is here JIC. */
	while ( spi2_busy() == 0 );	// Loop until a prior spi communication is complete
 8004f18:	f7ff fff2 	bl	8004f00 <spi2_busy>
 8004f1c:	2800      	cmp	r0, #0
 8004f1e:	d0fb      	beq.n	8004f18 <spi2_rw+0x8>

	GPIO_BSRR(GPIOB)  = (1<<(12+16));	// Set /CS low (show busy)
 8004f20:	4b08      	ldr	r3, [pc, #32]	; (8004f44 <spi2_rw+0x34>)
 8004f22:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004f26:	601a      	str	r2, [r3, #0]
	spi2_outptr = pout;		// Set pointer for interrupt handler to store outgoing data
	spi2_inptr = pin;		// Set pointer for interrupt handler to store incoming data
 8004f28:	4b07      	ldr	r3, [pc, #28]	; (8004f48 <spi2_rw+0x38>)
	spi2_cnt = count;		// Set byte count for interrupt handler
	SPI2_DR = *spi2_outptr++;	// Load outgoing byte to start spi cycle
 8004f2a:	4a08      	ldr	r2, [pc, #32]	; (8004f4c <spi2_rw+0x3c>)
	/* The following should not be necessary, but it is here JIC. */
	while ( spi2_busy() == 0 );	// Loop until a prior spi communication is complete

	GPIO_BSRR(GPIOB)  = (1<<(12+16));	// Set /CS low (show busy)
	spi2_outptr = pout;		// Set pointer for interrupt handler to store outgoing data
	spi2_inptr = pin;		// Set pointer for interrupt handler to store incoming data
 8004f2c:	601d      	str	r5, [r3, #0]
	spi2_cnt = count;		// Set byte count for interrupt handler
 8004f2e:	605e      	str	r6, [r3, #4]
	SPI2_DR = *spi2_outptr++;	// Load outgoing byte to start spi cycle
 8004f30:	f814 1b01 	ldrb.w	r1, [r4], #1
 8004f34:	6011      	str	r1, [r2, #0]
 8004f36:	609c      	str	r4, [r3, #8]
	SPI2_CR2 |= (SPI_CR2_RXNEIE);	// Enable receive buffer loaded (not empty) interrupt
 8004f38:	4b05      	ldr	r3, [pc, #20]	; (8004f50 <spi2_rw+0x40>)
 8004f3a:	681a      	ldr	r2, [r3, #0]
 8004f3c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8004f40:	601a      	str	r2, [r3, #0]
	return;
}
 8004f42:	bd70      	pop	{r4, r5, r6, pc}
 8004f44:	40020418 	.word	0x40020418
 8004f48:	200016b4 	.word	0x200016b4
 8004f4c:	4000380c 	.word	0x4000380c
 8004f50:	40003804 	.word	0x40003804

08004f54 <SPI2_IRQHandler>:
off (not really necessary), and the i/o pin with the CS line is brought back high. 
*/

	volatile unsigned int dummy;

	if ( (SPI2_SR & SPI_SR_RXNE) != 0)  // Check for bogus interrupt
 8004f54:	4b15      	ldr	r3, [pc, #84]	; (8004fac <SPI2_IRQHandler+0x58>)
 8004f56:	681b      	ldr	r3, [r3, #0]
 8004f58:	f013 0f01 	tst.w	r3, #1
 * ISR routine
 *####################################################################################### */
int spidebug1;

void SPI2_IRQHandler(void)
{      
 8004f5c:	b507      	push	{r0, r1, r2, lr}
off (not really necessary), and the i/o pin with the CS line is brought back high. 
*/

	volatile unsigned int dummy;

	if ( (SPI2_SR & SPI_SR_RXNE) != 0)  // Check for bogus interrupt
 8004f5e:	d020      	beq.n	8004fa2 <SPI2_IRQHandler+0x4e>
	{ /* Here, valid receive interrupt. */
		*spi2_inptr++ = SPI2_DR;	// Get byte that was read
 8004f60:	4b13      	ldr	r3, [pc, #76]	; (8004fb0 <SPI2_IRQHandler+0x5c>)
 8004f62:	4914      	ldr	r1, [pc, #80]	; (8004fb4 <SPI2_IRQHandler+0x60>)
 8004f64:	681a      	ldr	r2, [r3, #0]
 8004f66:	6808      	ldr	r0, [r1, #0]
 8004f68:	f802 0b01 	strb.w	r0, [r2], #1
 8004f6c:	601a      	str	r2, [r3, #0]
		spi2_cnt -= 1;	 		// Decrement byte count
 8004f6e:	685a      	ldr	r2, [r3, #4]
 8004f70:	3a01      	subs	r2, #1
		if (spi2_cnt <= 0)		// Have we exhausted the count?
 8004f72:	2a00      	cmp	r2, #0
	volatile unsigned int dummy;

	if ( (SPI2_SR & SPI_SR_RXNE) != 0)  // Check for bogus interrupt
	{ /* Here, valid receive interrupt. */
		*spi2_inptr++ = SPI2_DR;	// Get byte that was read
		spi2_cnt -= 1;	 		// Decrement byte count
 8004f74:	605a      	str	r2, [r3, #4]
		if (spi2_cnt <= 0)		// Have we exhausted the count?
 8004f76:	dc0c      	bgt.n	8004f92 <SPI2_IRQHandler+0x3e>
		{ /* Here, yes, this byte is the reponse from the last byte transmitted */ 
			SPI2_CR2 &= ~SPI_CR2_RXNEIE;	// Turn off RXE interrupt enable
 8004f78:	4a0f      	ldr	r2, [pc, #60]	; (8004fb8 <SPI2_IRQHandler+0x64>)
			GPIO_BSRR(GPIOB)  = (1<<12);// Set /CS high (show not busy)
			if (spi2_readdoneptr != 0) // Skip if pointer is NULL
 8004f7a:	68db      	ldr	r3, [r3, #12]
	{ /* Here, valid receive interrupt. */
		*spi2_inptr++ = SPI2_DR;	// Get byte that was read
		spi2_cnt -= 1;	 		// Decrement byte count
		if (spi2_cnt <= 0)		// Have we exhausted the count?
		{ /* Here, yes, this byte is the reponse from the last byte transmitted */ 
			SPI2_CR2 &= ~SPI_CR2_RXNEIE;	// Turn off RXE interrupt enable
 8004f7c:	6811      	ldr	r1, [r2, #0]
 8004f7e:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 8004f82:	6011      	str	r1, [r2, #0]
			GPIO_BSRR(GPIOB)  = (1<<12);// Set /CS high (show not busy)
 8004f84:	4a0d      	ldr	r2, [pc, #52]	; (8004fbc <SPI2_IRQHandler+0x68>)
 8004f86:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8004f8a:	6011      	str	r1, [r2, #0]
			if (spi2_readdoneptr != 0) // Skip if pointer is NULL
 8004f8c:	b163      	cbz	r3, 8004fa8 <SPI2_IRQHandler+0x54>
				(*spi2_readdoneptr)();	// In case we want to do something else
 8004f8e:	4798      	blx	r3
 8004f90:	e00a      	b.n	8004fa8 <SPI2_IRQHandler+0x54>
			return;
		}
		else
		{
spidebug1 +=1;
 8004f92:	691a      	ldr	r2, [r3, #16]
 8004f94:	3201      	adds	r2, #1
 8004f96:	611a      	str	r2, [r3, #16]
			SPI2_DR = *spi2_outptr++;	// Load outgoing byte to start next spi cycle
 8004f98:	689a      	ldr	r2, [r3, #8]
 8004f9a:	f812 0b01 	ldrb.w	r0, [r2], #1
 8004f9e:	6008      	str	r0, [r1, #0]
 8004fa0:	609a      	str	r2, [r3, #8]
		}
	}
	dummy = SPI2_SR; // Prevent tail-chaining.
 8004fa2:	4b02      	ldr	r3, [pc, #8]	; (8004fac <SPI2_IRQHandler+0x58>)
 8004fa4:	681b      	ldr	r3, [r3, #0]
 8004fa6:	9301      	str	r3, [sp, #4]
	return;
}
 8004fa8:	bd0e      	pop	{r1, r2, r3, pc}
 8004faa:	bf00      	nop
 8004fac:	40003808 	.word	0x40003808
 8004fb0:	200016b4 	.word	0x200016b4
 8004fb4:	4000380c 	.word	0x4000380c
 8004fb8:	40003804 	.word	0x40003804
 8004fbc:	40020418 	.word	0x40020418

08004fc0 <convert>:
	pclk2_freq  =   hclk_freq/convert(clocks->apb2);	// APB2 driven from AHB
 	return;                                           
}
/* Convert 0,4,5,6,7 input to 1,2,4,8,16 */
unsigned int convert(unsigned int ucX)
{	
 8004fc0:	2301      	movs	r3, #1
	return (ucX == 0)?:(1 << (ucX-3) );
 8004fc2:	b118      	cbz	r0, 8004fcc <convert+0xc>
 8004fc4:	3803      	subs	r0, #3
 8004fc6:	fa13 f000 	lsls.w	r0, r3, r0
 8004fca:	4770      	bx	lr
 8004fcc:	4618      	mov	r0, r3
}
 8004fce:	4770      	bx	lr

08004fd0 <clockspecifysetup>:
 * @brief	: Setup the clocks & bus freq dividers
 * @param	: chase: 0 = use HSI (internal 8 MHz RC osc), 1 = use HSE (external Xtal osc)
 * @return	: static variables are set from input paramaters passed in struct
 ******************************************************************************/
void clockspecifysetup(struct CLOCKS *clocks)
{
 8004fd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004fd2:	4603      	mov	r3, r0
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
	unsigned short sw_pll = 0;		// 0 = pll not used; 1 = pll used
	unsigned short pllp = clocks->pllp;	// Likely the clocks struct was a "const" and we may have to override the value given
 8004fd4:	89c4      	ldrh	r4, [r0, #14]

	/* See Ref manual page 85 figure 9 */
	/* Note: Out of reset, the HSI (internal rc osc) is selected and ready. */


	switch (clocks->hso)	// Select high speed oscillator source
 8004fd6:	781a      	ldrb	r2, [r3, #0]
{
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
	unsigned short sw_pll = 0;		// 0 = pll not used; 1 = pll used
	unsigned short pllp = clocks->pllp;	// Likely the clocks struct was a "const" and we may have to override the value given
	unsigned short pllm = clocks->pllm;
 8004fd8:	8a41      	ldrh	r1, [r0, #18]
	unsigned short plln = clocks->plln;
	unsigned short pllq = clocks->pllq;
 8004fda:	899d      	ldrh	r5, [r3, #12]
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
	unsigned short sw_pll = 0;		// 0 = pll not used; 1 = pll used
	unsigned short pllp = clocks->pllp;	// Likely the clocks struct was a "const" and we may have to override the value given
	unsigned short pllm = clocks->pllm;
	unsigned short plln = clocks->plln;
 8004fdc:	8a00      	ldrh	r0, [r0, #16]
	unsigned short pllq = clocks->pllq;
	unsigned int	freq = clocks->freq;	
 8004fde:	689e      	ldr	r6, [r3, #8]

	/* See Ref manual page 85 figure 9 */
	/* Note: Out of reset, the HSI (internal rc osc) is selected and ready. */


	switch (clocks->hso)	// Select high speed oscillator source
 8004fe0:	2a04      	cmp	r2, #4
 8004fe2:	d834      	bhi.n	800504e <clockspecifysetup+0x7e>
 8004fe4:	e8df f002 	tbb	[pc, r2]
 8004fe8:	1e110334 	.word	0x1e110334
 8004fec:	28          	.byte	0x28
 8004fed:	00          	.byte	0x00
		/* No action needed needed since HSI is already running and ready.  
			This osc as system clock is what got us to this point! */
		freq = 16000000;				// The internal RC osc is always 16MHz
		break;
	case 1: // Use external xtal controlled osc
		RCC_CR = RCC_CR_HSEON;			// Start hi-speed external oscillator
 8004fee:	4a6a      	ldr	r2, [pc, #424]	; (8005198 <clockspecifysetup+0x1c8>)
 8004ff0:	f44f 3780 	mov.w	r7, #65536	; 0x10000
 8004ff4:	6017      	str	r7, [r2, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 8004ff6:	4a68      	ldr	r2, [pc, #416]	; (8005198 <clockspecifysetup+0x1c8>)
 8004ff8:	6817      	ldr	r7, [r2, #0]
 8004ffa:	f417 3f00 	tst.w	r7, #131072	; 0x20000
 8004ffe:	d0fa      	beq.n	8004ff6 <clockspecifysetup+0x26>
		usSW = 0x01;				// SWS = HSE as system clock
RCC_CR &= ~RCC_CR_HSION;	// Turn off HSI osc
 8005000:	6817      	ldr	r7, [r2, #0]
 8005002:	f027 0701 	bic.w	r7, r7, #1
 8005006:	6017      	str	r7, [r2, #0]
 8005008:	e01f      	b.n	800504a <clockspecifysetup+0x7a>
		break;
	case 2: // Use external signal input
		RCC_CR = RCC_CR_HSEBYP;			// By-pass external osc and use external signal
 800500a:	4a63      	ldr	r2, [pc, #396]	; (8005198 <clockspecifysetup+0x1c8>)
 800500c:	f44f 2780 	mov.w	r7, #262144	; 0x40000
 8005010:	6017      	str	r7, [r2, #0]
		RCC_CR = RCC_CR_HSEON;			// Start hi-speed external clock
 8005012:	f44f 3780 	mov.w	r7, #65536	; 0x10000
 8005016:	6017      	str	r7, [r2, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 8005018:	4a5f      	ldr	r2, [pc, #380]	; (8005198 <clockspecifysetup+0x1c8>)
 800501a:	6812      	ldr	r2, [r2, #0]
 800501c:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8005020:	d0fa      	beq.n	8005018 <clockspecifysetup+0x48>
 8005022:	e012      	b.n	800504a <clockspecifysetup+0x7a>
		usSW = 0x01;				// SWS = HSE as system clock
		break;
	case 3: // Use remapped external osc *xtal*
//$$$		AFIO_MAPR |= (1 << 15); 		// Bit 15 PD01_REMAP: Port D0/Port D1 mapping on OSC_IN/OSC_OUT		
		RCC_CR = RCC_CR_HSEON;			// Start oscillators hi-speed internal and external
 8005024:	4a5c      	ldr	r2, [pc, #368]	; (8005198 <clockspecifysetup+0x1c8>)
 8005026:	f44f 3780 	mov.w	r7, #65536	; 0x10000
 800502a:	6017      	str	r7, [r2, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 800502c:	4a5a      	ldr	r2, [pc, #360]	; (8005198 <clockspecifysetup+0x1c8>)
 800502e:	6812      	ldr	r2, [r2, #0]
 8005030:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8005034:	d0fa      	beq.n	800502c <clockspecifysetup+0x5c>
 8005036:	e008      	b.n	800504a <clockspecifysetup+0x7a>
		usSW = 0x01;				// SWS = HSE as system clock
		break;
	case 4: // Use remapped external osc *signal*
//$$$		AFIO_MAPR |= (1 << 15); 		// Bit 15 PD01_REMAP: Port D0/Port D1 mapping on OSC_IN/OSC_OUT		
		RCC_CR = RCC_CR_HSEBYP;			// By-pass external osc and use external signal
 8005038:	4a57      	ldr	r2, [pc, #348]	; (8005198 <clockspecifysetup+0x1c8>)
 800503a:	f44f 2780 	mov.w	r7, #262144	; 0x40000
 800503e:	6017      	str	r7, [r2, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 8005040:	4a55      	ldr	r2, [pc, #340]	; (8005198 <clockspecifysetup+0x1c8>)
 8005042:	6812      	ldr	r2, [r2, #0]
 8005044:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8005048:	d0fa      	beq.n	8005040 <clockspecifysetup+0x70>
		usSW = 0x01;				// SWS = HSE as system clock
 800504a:	2201      	movs	r2, #1
 800504c:	e002      	b.n	8005054 <clockspecifysetup+0x84>
 800504e:	e7fe      	b.n	800504e <clockspecifysetup+0x7e>
	switch (clocks->hso)	// Select high speed oscillator source
	{
	case 0:	// Use internal 16 Mhz rc osc
		/* No action needed needed since HSI is already running and ready.  
			This osc as system clock is what got us to this point! */
		freq = 16000000;				// The internal RC osc is always 16MHz
 8005050:	4e52      	ldr	r6, [pc, #328]	; (800519c <clockspecifysetup+0x1cc>)
 * @param	: chase: 0 = use HSI (internal 8 MHz RC osc), 1 = use HSE (external Xtal osc)
 * @return	: static variables are set from input paramaters passed in struct
 ******************************************************************************/
void clockspecifysetup(struct CLOCKS *clocks)
{
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
 8005052:	2200      	movs	r2, #0
This register is used to configure the PLL clock outputs according to the formulas:
●    f(VCO clock) = f(PLL clock input) × (PLLN / PLLM)
●    f(PLL general clock output) = f(VCO clock) / PLLP
●    f(USB OTG FS, SDIO, RNG clock output) = f(VCO clock) / PLLQ
*/
	if ( (plln != 0) && (pllm != 0) ) // Is PLL multiplier/divider specifed?
 8005054:	2800      	cmp	r0, #0
 8005056:	d041      	beq.n	80050dc <clockspecifysetup+0x10c>
 8005058:	2900      	cmp	r1, #0
 800505a:	d041      	beq.n	80050e0 <clockspecifysetup+0x110>
	{ // Here, yes the PLL is to be used

		/* Make sure pllp is valid */
		if ((clocks->pllp >> 1) == 0 ) pllp = 2;
 800505c:	89df      	ldrh	r7, [r3, #14]
 800505e:	087f      	lsrs	r7, r7, #1
 8005060:	d003      	beq.n	800506a <clockspecifysetup+0x9a>
		if ((clocks->pllp >> 1) >  4 ) pllp = 8;
 8005062:	2f04      	cmp	r7, #4
 8005064:	bf88      	it	hi
 8005066:	2408      	movhi	r4, #8
 8005068:	e000      	b.n	800506c <clockspecifysetup+0x9c>
*/
	if ( (plln != 0) && (pllm != 0) ) // Is PLL multiplier/divider specifed?
	{ // Here, yes the PLL is to be used

		/* Make sure pllp is valid */
		if ((clocks->pllp >> 1) == 0 ) pllp = 2;
 800506a:	2402      	movs	r4, #2
		if ((clocks->pllp >> 1) >  4 ) pllp = 8;

		/* Make sure plln, pllm is within range */
		if (plln > 432 ) while (1==1);
 800506c:	f5b0 7fd8 	cmp.w	r0, #432	; 0x1b0
 8005070:	d900      	bls.n	8005074 <clockspecifysetup+0xa4>
 8005072:	e7fe      	b.n	8005072 <clockspecifysetup+0xa2>
		if (plln <   2 ) while (1==1);
 8005074:	2801      	cmp	r0, #1
 8005076:	d100      	bne.n	800507a <clockspecifysetup+0xaa>
 8005078:	e7fe      	b.n	8005078 <clockspecifysetup+0xa8>
		if (pllm >  64 ) while (1==1);
 800507a:	2940      	cmp	r1, #64	; 0x40
 800507c:	d900      	bls.n	8005080 <clockspecifysetup+0xb0>
 800507e:	e7fe      	b.n	800507e <clockspecifysetup+0xae>
		if (pllm <   2 ) while (1==1);	
 8005080:	2901      	cmp	r1, #1
 8005082:	d100      	bne.n	8005086 <clockspecifysetup+0xb6>
 8005084:	e7fe      	b.n	8005084 <clockspecifysetup+0xb4>

		/* Divider for 48 MHz peripherals */
		if ((pllq == 0) || (pllq > 15)) pllq = 15;	
 8005086:	1e6f      	subs	r7, r5, #1
 8005088:	b2bf      	uxth	r7, r7
 800508a:	2f0e      	cmp	r7, #14
 800508c:	bf88      	it	hi
 800508e:	250f      	movhi	r5, #15

		vco_freq = (freq * clocks->plln) / clocks->pllm; 	// VCO freq
 8005090:	8a1f      	ldrh	r7, [r3, #16]
 8005092:	437e      	muls	r6, r7
 8005094:	8a5f      	ldrh	r7, [r3, #18]
 8005096:	fbb6 f6f7 	udiv	r6, r6, r7

		/* Don't blast ahead if the VCO freq is out of range */
		if (vco_freq > 432000000) while(1==1); 	// SCREWED
 800509a:	4f41      	ldr	r7, [pc, #260]	; (80051a0 <clockspecifysetup+0x1d0>)
 800509c:	42be      	cmp	r6, r7
 800509e:	d900      	bls.n	80050a2 <clockspecifysetup+0xd2>
 80050a0:	e7fe      	b.n	80050a0 <clockspecifysetup+0xd0>
		if (vco_freq < 64) 	  while(1==1); 	// SCREWED
 80050a2:	2e3f      	cmp	r6, #63	; 0x3f
 80050a4:	d800      	bhi.n	80050a8 <clockspecifysetup+0xd8>
 80050a6:	e7fe      	b.n	80050a6 <clockspecifysetup+0xd6>
		
		sysclk_freq = vco_freq / pllp;
 80050a8:	4f3e      	ldr	r7, [pc, #248]	; (80051a4 <clockspecifysetup+0x1d4>)
 80050aa:	fbb6 f6f4 	udiv	r6, r6, r4
 80050ae:	603e      	str	r6, [r7, #0]

		/* Don't blast ahead if the sysclk freq is too high */
		if (sysclk_freq > 168000000)	while(1==1); // SCREWED
 80050b0:	4f3d      	ldr	r7, [pc, #244]	; (80051a8 <clockspecifysetup+0x1d8>)
 80050b2:	42be      	cmp	r6, r7
 80050b4:	d900      	bls.n	80050b8 <clockspecifysetup+0xe8>
 80050b6:	e7fe      	b.n	80050b6 <clockspecifysetup+0xe6>

		/* Setup PLL counts */
		RCC_PLLCFGR = (pllq << 24) | ( (clocks->pllsrc & 0x01) << 22) | ( pllp << 16) | ( (plln & 0x01ff) << 6) | (pllm);
 80050b8:	785e      	ldrb	r6, [r3, #1]
 80050ba:	05c0      	lsls	r0, r0, #23
 80050bc:	0dc0      	lsrs	r0, r0, #23
 80050be:	f006 0601 	and.w	r6, r6, #1
 80050c2:	0180      	lsls	r0, r0, #6
 80050c4:	ea40 5086 	orr.w	r0, r0, r6, lsl #22
 80050c8:	ea40 0101 	orr.w	r1, r0, r1
 80050cc:	ea41 4404 	orr.w	r4, r1, r4, lsl #16
 80050d0:	4836      	ldr	r0, [pc, #216]	; (80051ac <clockspecifysetup+0x1dc>)
 80050d2:	ea44 6505 	orr.w	r5, r4, r5, lsl #24
 80050d6:	6005      	str	r5, [r0, #0]

		sw_pll = 1;
 80050d8:	2601      	movs	r6, #1
 80050da:	e002      	b.n	80050e2 <clockspecifysetup+0x112>
 ******************************************************************************/
void clockspecifysetup(struct CLOCKS *clocks)
{
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
	unsigned short sw_pll = 0;		// 0 = pll not used; 1 = pll used
 80050dc:	4606      	mov	r6, r0
 80050de:	e000      	b.n	80050e2 <clockspecifysetup+0x112>
 80050e0:	460e      	mov	r6, r1

		sw_pll = 1;
	}

	/* Determine number of flash wait states p 55.  2.7-3.6v ONLY */
	if (sysclk_freq >  30) ws = 1;
 80050e2:	4930      	ldr	r1, [pc, #192]	; (80051a4 <clockspecifysetup+0x1d4>)
 80050e4:	680c      	ldr	r4, [r1, #0]
 80050e6:	2c1e      	cmp	r4, #30
 80050e8:	d94e      	bls.n	8005188 <clockspecifysetup+0x1b8>
	if (sysclk_freq >  60) ws = 2;
 80050ea:	2c3c      	cmp	r4, #60	; 0x3c
 80050ec:	d94e      	bls.n	800518c <clockspecifysetup+0x1bc>
	if (sysclk_freq >  90) ws = 3;
 80050ee:	2c5a      	cmp	r4, #90	; 0x5a
 80050f0:	d94e      	bls.n	8005190 <clockspecifysetup+0x1c0>
	if (sysclk_freq > 120) ws = 4;
 80050f2:	2c78      	cmp	r4, #120	; 0x78
 80050f4:	d94e      	bls.n	8005194 <clockspecifysetup+0x1c4>
 80050f6:	2c96      	cmp	r4, #150	; 0x96
 80050f8:	bf8c      	ite	hi
 80050fa:	2105      	movhi	r1, #5
 80050fc:	2104      	movls	r1, #4
	if (sysclk_freq > 150) ws = 5;

	/* Set wait states in register */
	FLASH_ACR |= ws;
 80050fe:	482c      	ldr	r0, [pc, #176]	; (80051b0 <clockspecifysetup+0x1e0>)
 8005100:	6805      	ldr	r5, [r0, #0]
 8005102:	ea41 0505 	orr.w	r5, r1, r5
 8005106:	6005      	str	r5, [r0, #0]

	/* Wait for register to become effective p 55 */
	while ((FLASH_ACR & 0x07) != ws);
 8005108:	4829      	ldr	r0, [pc, #164]	; (80051b0 <clockspecifysetup+0x1e0>)
 800510a:	6800      	ldr	r0, [r0, #0]
 800510c:	f000 0007 	and.w	r0, r0, #7
 8005110:	4288      	cmp	r0, r1
 8005112:	d1f9      	bne.n	8005108 <clockspecifysetup+0x138>


	/* Clock configuraton register (Ref manual, page 97)	*/
	// Setup up bus dividers
	RCC_CFGR = (clocks->apb2  << 13)  |	/* (3b) PPRE2: ABP2 prescaler bit code	(4-7)		*/ 
 8005114:	78dd      	ldrb	r5, [r3, #3]
		   (clocks->apb1  << 10)  |	/* (3b) PPRE1: APB1 prescaler bit code	(4-7)		*/ 
 8005116:	7898      	ldrb	r0, [r3, #2]
		   (clocks->ahb   <<  4)  ;	/* (4b) HPRE:  AHB  prescaler bit code	(8-15)		*/
 8005118:	791b      	ldrb	r3, [r3, #4]
	while ((FLASH_ACR & 0x07) != ws);


	/* Clock configuraton register (Ref manual, page 97)	*/
	// Setup up bus dividers
	RCC_CFGR = (clocks->apb2  << 13)  |	/* (3b) PPRE2: ABP2 prescaler bit code	(4-7)		*/ 
 800511a:	4926      	ldr	r1, [pc, #152]	; (80051b4 <clockspecifysetup+0x1e4>)
 800511c:	036f      	lsls	r7, r5, #13
 800511e:	ea47 2780 	orr.w	r7, r7, r0, lsl #10
		   (clocks->apb1  << 10)  |	/* (3b) PPRE1: APB1 prescaler bit code	(4-7)		*/ 
 8005122:	ea47 1703 	orr.w	r7, r7, r3, lsl #4
		   (clocks->ahb   <<  4)  ;	/* (4b) HPRE:  AHB  prescaler bit code	(8-15)		*/


	if (sw_pll == 1)	// Are we using the PLL?
 8005126:	2e01      	cmp	r6, #1
	while ((FLASH_ACR & 0x07) != ws);


	/* Clock configuraton register (Ref manual, page 97)	*/
	// Setup up bus dividers
	RCC_CFGR = (clocks->apb2  << 13)  |	/* (3b) PPRE2: ABP2 prescaler bit code	(4-7)		*/ 
 8005128:	600f      	str	r7, [r1, #0]
		   (clocks->apb1  << 10)  |	/* (3b) PPRE1: APB1 prescaler bit code	(4-7)		*/ 
		   (clocks->ahb   <<  4)  ;	/* (4b) HPRE:  AHB  prescaler bit code	(8-15)		*/


	if (sw_pll == 1)	// Are we using the PLL?
 800512a:	d10a      	bne.n	8005142 <clockspecifysetup+0x172>
	{ // Here yes, start PLL
		// Enable PLL
		RCC_CR |= (1<<24);			// PLLON:  Turn PLL on
 800512c:	4a1a      	ldr	r2, [pc, #104]	; (8005198 <clockspecifysetup+0x1c8>)
 800512e:	6811      	ldr	r1, [r2, #0]
 8005130:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 8005134:	6011      	str	r1, [r2, #0]
		while ((RCC_CR & (1<<25) ) == 0);	// PLLRDY: Wait for PLL to become ready
 8005136:	4a18      	ldr	r2, [pc, #96]	; (8005198 <clockspecifysetup+0x1c8>)
 8005138:	6812      	ldr	r2, [r2, #0]
 800513a:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 800513e:	d0fa      	beq.n	8005136 <clockspecifysetup+0x166>

		// Select PLL as system clock source 
		usSW = 0x02;				// Change the usSW code for PLL
 8005140:	2202      	movs	r2, #2
	}

	

	/* Switch the system clock source to the one specified */
	RCC_CFGR = (RCC_CFGR & ~0x03) | usSW;		// Set system clock source (it has been running on HSI (internal 8 MHz rc clock)
 8005142:	491c      	ldr	r1, [pc, #112]	; (80051b4 <clockspecifysetup+0x1e4>)
 8005144:	680e      	ldr	r6, [r1, #0]
 8005146:	f026 0603 	bic.w	r6, r6, #3
 800514a:	ea42 0606 	orr.w	r6, r2, r6
 800514e:	600e      	str	r6, [r1, #0]
	while ( (RCC_CFGR & 0x0c) != (unsigned short)(usSW << 2) );	// Wait until system is running on the clock source
 8005150:	0092      	lsls	r2, r2, #2
 8005152:	4918      	ldr	r1, [pc, #96]	; (80051b4 <clockspecifysetup+0x1e4>)
 8005154:	6809      	ldr	r1, [r1, #0]
 8005156:	f001 010c 	and.w	r1, r1, #12
 800515a:	4291      	cmp	r1, r2
 800515c:	d1f9      	bne.n	8005152 <clockspecifysetup+0x182>


	/* Compute static variables with bus freqs that other routines will use to for their setup */
	hclk_freq   = sysclk_freq/ahbtbl[(clocks->ahb)];	// AHB bus freq = sysclck/ ahb bus divider
 800515e:	4a16      	ldr	r2, [pc, #88]	; (80051b8 <clockspecifysetup+0x1e8>)
 8005160:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8005164:	fbb4 f4f3 	udiv	r4, r4, r3
 8005168:	4b14      	ldr	r3, [pc, #80]	; (80051bc <clockspecifysetup+0x1ec>)
 800516a:	601c      	str	r4, [r3, #0]
	pclk1_freq  =   hclk_freq/convert(clocks->apb1);	// APB1 driven from AHB (must not exceed 36 MHz)
 800516c:	f7ff ff28 	bl	8004fc0 <convert>
 8005170:	4b13      	ldr	r3, [pc, #76]	; (80051c0 <clockspecifysetup+0x1f0>)
 8005172:	fbb4 f0f0 	udiv	r0, r4, r0
 8005176:	6018      	str	r0, [r3, #0]
	pclk2_freq  =   hclk_freq/convert(clocks->apb2);	// APB2 driven from AHB
 8005178:	4628      	mov	r0, r5
 800517a:	f7ff ff21 	bl	8004fc0 <convert>
 800517e:	4b11      	ldr	r3, [pc, #68]	; (80051c4 <clockspecifysetup+0x1f4>)
 8005180:	fbb4 f0f0 	udiv	r0, r4, r0
 8005184:	6018      	str	r0, [r3, #0]
 	return;                                           
}
 8005186:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 * @return	: static variables are set from input paramaters passed in struct
 ******************************************************************************/
void clockspecifysetup(struct CLOCKS *clocks)
{
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
 8005188:	2100      	movs	r1, #0
 800518a:	e7b8      	b.n	80050fe <clockspecifysetup+0x12e>

		sw_pll = 1;
	}

	/* Determine number of flash wait states p 55.  2.7-3.6v ONLY */
	if (sysclk_freq >  30) ws = 1;
 800518c:	2101      	movs	r1, #1
 800518e:	e7b6      	b.n	80050fe <clockspecifysetup+0x12e>
	if (sysclk_freq >  60) ws = 2;
 8005190:	2102      	movs	r1, #2
 8005192:	e7b4      	b.n	80050fe <clockspecifysetup+0x12e>
	if (sysclk_freq >  90) ws = 3;
 8005194:	2103      	movs	r1, #3
 8005196:	e7b2      	b.n	80050fe <clockspecifysetup+0x12e>
 8005198:	40023800 	.word	0x40023800
 800519c:	00f42400 	.word	0x00f42400
 80051a0:	19bfcc00 	.word	0x19bfcc00
 80051a4:	200016d4 	.word	0x200016d4
 80051a8:	0a037a00 	.word	0x0a037a00
 80051ac:	40023804 	.word	0x40023804
 80051b0:	40023c00 	.word	0x40023c00
 80051b4:	40023808 	.word	0x40023808
 80051b8:	0801012a 	.word	0x0801012a
 80051bc:	200016c8 	.word	0x200016c8
 80051c0:	200016cc 	.word	0x200016cc
 80051c4:	200016d0 	.word	0x200016d0

080051c8 <clockI2Ssetup>:
int clockI2Ssetup(unsigned int R, unsigned int N)
{
	int i = 10000;	// Anti-hang loop counter
	
	/* Check input value ranges */
	if (R <   2) return 1;
 80051c8:	2801      	cmp	r0, #1
 * @param	: R = valid range: 2-7 (3 bits)
 * @param	: N = valid range: 192-432 (9 bits). 
 * @return	: 0 = OK; 1 = failed
 ******************************************************************************/
int clockI2Ssetup(unsigned int R, unsigned int N)
{
 80051ca:	b530      	push	{r4, r5, lr}
	int i = 10000;	// Anti-hang loop counter
	
	/* Check input value ranges */
	if (R <   2) return 1;
 80051cc:	d91f      	bls.n	800520e <clockI2Ssetup+0x46>
	if (R >   7) return 1;
 80051ce:	2807      	cmp	r0, #7
 80051d0:	d81d      	bhi.n	800520e <clockI2Ssetup+0x46>
	if (N < 192) return 1;
 80051d2:	29bf      	cmp	r1, #191	; 0xbf
 80051d4:	d91b      	bls.n	800520e <clockI2Ssetup+0x46>
	if (N > 432) return 1;
 80051d6:	f5b1 7fd8 	cmp.w	r1, #432	; 0x1b0
 80051da:	d81a      	bhi.n	8005212 <clockI2Ssetup+0x4a>

	/* Turn PLL off and reset counters */
	RCC_CR &= ~(1<<26);			// Disable PLL2I2S if previously enabled (p 92)
 80051dc:	4b0e      	ldr	r3, [pc, #56]	; (8005218 <clockI2Ssetup+0x50>)
	while ( (RCC_CR & (1<<27)) == 1 );	// Be sure it is not ready (p 93)
	RCC_PLLI2SCFGR &= ~(0x70007fc0) ;	// Reset current R & N setttings (p 132)
 80051de:	4c0f      	ldr	r4, [pc, #60]	; (800521c <clockI2Ssetup+0x54>)
	if (R >   7) return 1;
	if (N < 192) return 1;
	if (N > 432) return 1;

	/* Turn PLL off and reset counters */
	RCC_CR &= ~(1<<26);			// Disable PLL2I2S if previously enabled (p 92)
 80051e0:	681a      	ldr	r2, [r3, #0]
 80051e2:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 80051e6:	601a      	str	r2, [r3, #0]
	while ( (RCC_CR & (1<<27)) == 1 );	// Be sure it is not ready (p 93)
 80051e8:	681a      	ldr	r2, [r3, #0]
	RCC_PLLI2SCFGR &= ~(0x70007fc0) ;	// Reset current R & N setttings (p 132)
 80051ea:	4a0d      	ldr	r2, [pc, #52]	; (8005220 <clockI2Ssetup+0x58>)
 80051ec:	6815      	ldr	r5, [r2, #0]
 80051ee:	ea05 0404 	and.w	r4, r5, r4
 80051f2:	6014      	str	r4, [r2, #0]

	/* Set up new PLL counters (p 132) */
	RCC_PLLI2SCFGR |= (R << 28) | (N << 6) ;
 80051f4:	6814      	ldr	r4, [r2, #0]
 80051f6:	ea44 7000 	orr.w	r0, r4, r0, lsl #28
 80051fa:	ea40 1181 	orr.w	r1, r0, r1, lsl #6
 80051fe:	6011      	str	r1, [r2, #0]

	/* Enable PLL */
	RCC_CR |= (1<<26);	// Enable bit
 8005200:	681a      	ldr	r2, [r3, #0]
 8005202:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8005206:	601a      	str	r2, [r3, #0]

	/* Wait for it to come ready, but don't allow to hang forever. (p 93) */
	while ( ((RCC_CR & (1<<27)) == 1) && (--i > 0) );
 8005208:	681b      	ldr	r3, [r3, #0]
	if ( i < 0 ) return 1;		// Timed out

	return 0;
 800520a:	2000      	movs	r0, #0
 800520c:	bd30      	pop	{r4, r5, pc}
	int i = 10000;	// Anti-hang loop counter
	
	/* Check input value ranges */
	if (R <   2) return 1;
	if (R >   7) return 1;
	if (N < 192) return 1;
 800520e:	2001      	movs	r0, #1
 8005210:	bd30      	pop	{r4, r5, pc}
	if (N > 432) return 1;
 8005212:	2001      	movs	r0, #1
	/* Wait for it to come ready, but don't allow to hang forever. (p 93) */
	while ( ((RCC_CR & (1<<27)) == 1) && (--i > 0) );
	if ( i < 0 ) return 1;		// Timed out

	return 0;
}
 8005214:	bd30      	pop	{r4, r5, pc}
 8005216:	bf00      	nop
 8005218:	40023800 	.word	0x40023800
 800521c:	8fff803f 	.word	0x8fff803f
 8005220:	40023884 	.word	0x40023884

08005224 <nvic_dma_stream_vector_add>:
 * @param	: stream_number = 0-7 for stream selected
 * @return	: 0 = OK; -1 = irq number out of range; -2 or less = stream already in use
******************************************************************************/
int nvic_dma_stream_vector_add(void(*p)(u32*), u32* q, u32 dma_irq_number, u32 stream_number)
{
	if (stream_number > 7) return -1;	// JIC a bozo sent a bad number
 8005224:	2b07      	cmp	r3, #7
 * @param	: dma_irq_number = nvic irq number
 * @param	: stream_number = 0-7 for stream selected
 * @return	: 0 = OK; -1 = irq number out of range; -2 or less = stream already in use
******************************************************************************/
int nvic_dma_stream_vector_add(void(*p)(u32*), u32* q, u32 dma_irq_number, u32 stream_number)
{
 8005226:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (stream_number > 7) return -1;	// JIC a bozo sent a bad number
 8005228:	d863      	bhi.n	80052f2 <nvic_dma_stream_vector_add+0xce>

	/* Convert DMA irq number (vector position) to an index 0 - 7 */
	// --------- DMA1 -----------
	if ((dma_irq_number >= DMASTRM10) && (dma_irq_number <= DMASTRM16))
 800522a:	f1a2 040b 	sub.w	r4, r2, #11
 800522e:	2c06      	cmp	r4, #6
 8005230:	d815      	bhi.n	800525e <nvic_dma_stream_vector_add+0x3a>
	{
		if ((dma1_stream_use & (1 << stream_number)) != 0) return -2; 	// Already setup
 8005232:	4a39      	ldr	r2, [pc, #228]	; (8005318 <nvic_dma_stream_vector_add+0xf4>)
 8005234:	7815      	ldrb	r5, [r2, #0]
 8005236:	fa55 f603 	asrs.w	r6, r5, r3
 800523a:	f016 0601 	ands.w	r6, r6, #1
 800523e:	d15b      	bne.n	80052f8 <nvic_dma_stream_vector_add+0xd4>
		dma1_stream_use |=     (1 << stream_number);			// Set bit to show used
 8005240:	2701      	movs	r7, #1
 8005242:	fa17 f303 	lsls.w	r3, r7, r3
 8005246:	ea43 0505 	orr.w	r5, r3, r5
 800524a:	7015      	strb	r5, [r2, #0]
		dma1[(dma_irq_number - DMASTRM10)].jmp  = p; // Pointer to IRQ handler
		dma1[(dma_irq_number - DMASTRM10)].base = q; // Pointer to control block
		RCC_AHB1ENR |= (1<<21); // Enable DMA1 clocking
 800524c:	4b33      	ldr	r3, [pc, #204]	; (800531c <nvic_dma_stream_vector_add+0xf8>)
	// --------- DMA1 -----------
	if ((dma_irq_number >= DMASTRM10) && (dma_irq_number <= DMASTRM16))
	{
		if ((dma1_stream_use & (1 << stream_number)) != 0) return -2; 	// Already setup
		dma1_stream_use |=     (1 << stream_number);			// Set bit to show used
		dma1[(dma_irq_number - DMASTRM10)].jmp  = p; // Pointer to IRQ handler
 800524e:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 8005252:	6050      	str	r0, [r2, #4]
		dma1[(dma_irq_number - DMASTRM10)].base = q; // Pointer to control block
 8005254:	6091      	str	r1, [r2, #8]
		RCC_AHB1ENR |= (1<<21); // Enable DMA1 clocking
 8005256:	681a      	ldr	r2, [r3, #0]
 8005258:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800525c:	e046      	b.n	80052ec <nvic_dma_stream_vector_add+0xc8>
		return 0;
	}
	if (dma_irq_number == DMASTRM17)
 800525e:	2a2f      	cmp	r2, #47	; 0x2f
 8005260:	d110      	bne.n	8005284 <nvic_dma_stream_vector_add+0x60>
	{
		if ((dma1_stream_use & 0x80) != 0) return -3; 	// Already setup
 8005262:	4b2d      	ldr	r3, [pc, #180]	; (8005318 <nvic_dma_stream_vector_add+0xf4>)
 8005264:	781a      	ldrb	r2, [r3, #0]
 8005266:	f012 0f80 	tst.w	r2, #128	; 0x80
 800526a:	d148      	bne.n	80052fe <nvic_dma_stream_vector_add+0xda>
		dma1_stream_use |=     0x80;			// Set bit to show used
 800526c:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8005270:	701a      	strb	r2, [r3, #0]
		dma1[7].jmp  = p; 
 8005272:	63d8      	str	r0, [r3, #60]	; 0x3c
		dma1[7].base = q;
 8005274:	6419      	str	r1, [r3, #64]	; 0x40
		RCC_AHB1ENR |= (1<<21); // Enable DMA1 clocking
 8005276:	4b29      	ldr	r3, [pc, #164]	; (800531c <nvic_dma_stream_vector_add+0xf8>)
 8005278:	681a      	ldr	r2, [r3, #0]
 800527a:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800527e:	601a      	str	r2, [r3, #0]
		return 0;
 8005280:	2000      	movs	r0, #0
 8005282:	bdf0      	pop	{r4, r5, r6, r7, pc}

	// --------- DMA2 -----------
	}
	if ( (dma_irq_number >= DMASTRM20) && (dma_irq_number <= DMASTRM24 ))
 8005284:	f1a2 0438 	sub.w	r4, r2, #56	; 0x38
 8005288:	2c04      	cmp	r4, #4
 800528a:	d813      	bhi.n	80052b4 <nvic_dma_stream_vector_add+0x90>
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -4; 	// Already setup
 800528c:	4a22      	ldr	r2, [pc, #136]	; (8005318 <nvic_dma_stream_vector_add+0xf4>)
 800528e:	f892 5044 	ldrb.w	r5, [r2, #68]	; 0x44
 8005292:	fa55 f603 	asrs.w	r6, r5, r3
 8005296:	f016 0601 	ands.w	r6, r6, #1
 800529a:	d133      	bne.n	8005304 <nvic_dma_stream_vector_add+0xe0>
		dma2_stream_use |=     (1 << stream_number);			// Set bit to show used
 800529c:	2701      	movs	r7, #1
 800529e:	fa17 f303 	lsls.w	r3, r7, r3
 80052a2:	ea43 0505 	orr.w	r5, r3, r5
 80052a6:	f882 5044 	strb.w	r5, [r2, #68]	; 0x44
		dma2[dma_irq_number - DMASTRM20].jmp  = p; 
 80052aa:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 80052ae:	6490      	str	r0, [r2, #72]	; 0x48
		dma2[dma_irq_number - DMASTRM20].base = q;
 80052b0:	64d1      	str	r1, [r2, #76]	; 0x4c
 80052b2:	e017      	b.n	80052e4 <nvic_dma_stream_vector_add+0xc0>
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
		return 0;
	}
	if ( (dma_irq_number >= DMASTRM25) && (dma_irq_number <= DMASTRM27 ))
 80052b4:	f1a2 0444 	sub.w	r4, r2, #68	; 0x44
 80052b8:	2c02      	cmp	r4, #2
 80052ba:	d826      	bhi.n	800530a <nvic_dma_stream_vector_add+0xe6>
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -5; 	// Already setup
 80052bc:	4c16      	ldr	r4, [pc, #88]	; (8005318 <nvic_dma_stream_vector_add+0xf4>)
 80052be:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
 80052c2:	fa55 f603 	asrs.w	r6, r5, r3
 80052c6:	f016 0601 	ands.w	r6, r6, #1
 80052ca:	d121      	bne.n	8005310 <nvic_dma_stream_vector_add+0xec>
		dma2_stream_use |=     (1 << stream_number);			// Set bit to show used
 80052cc:	2701      	movs	r7, #1
 80052ce:	fa17 f303 	lsls.w	r3, r7, r3
 80052d2:	ea43 0505 	orr.w	r5, r3, r5
		dma2[dma_irq_number - DMASTRM25 + 5].jmp  = p; 
 80052d6:	3a3f      	subs	r2, #63	; 0x3f
		return 0;
	}
	if ( (dma_irq_number >= DMASTRM25) && (dma_irq_number <= DMASTRM27 ))
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -5; 	// Already setup
		dma2_stream_use |=     (1 << stream_number);			// Set bit to show used
 80052d8:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
		dma2[dma_irq_number - DMASTRM25 + 5].jmp  = p; 
 80052dc:	eb04 04c2 	add.w	r4, r4, r2, lsl #3
 80052e0:	64a0      	str	r0, [r4, #72]	; 0x48
		dma2[dma_irq_number - DMASTRM25 + 5].base = q; 
 80052e2:	64e1      	str	r1, [r4, #76]	; 0x4c
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
 80052e4:	4b0d      	ldr	r3, [pc, #52]	; (800531c <nvic_dma_stream_vector_add+0xf8>)
 80052e6:	681a      	ldr	r2, [r3, #0]
 80052e8:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 80052ec:	601a      	str	r2, [r3, #0]
		return 0;
 80052ee:	4630      	mov	r0, r6
 80052f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 * @param	: stream_number = 0-7 for stream selected
 * @return	: 0 = OK; -1 = irq number out of range; -2 or less = stream already in use
******************************************************************************/
int nvic_dma_stream_vector_add(void(*p)(u32*), u32* q, u32 dma_irq_number, u32 stream_number)
{
	if (stream_number > 7) return -1;	// JIC a bozo sent a bad number
 80052f2:	f04f 30ff 	mov.w	r0, #4294967295
 80052f6:	bdf0      	pop	{r4, r5, r6, r7, pc}

	/* Convert DMA irq number (vector position) to an index 0 - 7 */
	// --------- DMA1 -----------
	if ((dma_irq_number >= DMASTRM10) && (dma_irq_number <= DMASTRM16))
	{
		if ((dma1_stream_use & (1 << stream_number)) != 0) return -2; 	// Already setup
 80052f8:	f06f 0001 	mvn.w	r0, #1
 80052fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		RCC_AHB1ENR |= (1<<21); // Enable DMA1 clocking
		return 0;
	}
	if (dma_irq_number == DMASTRM17)
	{
		if ((dma1_stream_use & 0x80) != 0) return -3; 	// Already setup
 80052fe:	f06f 0002 	mvn.w	r0, #2
 8005302:	bdf0      	pop	{r4, r5, r6, r7, pc}

	// --------- DMA2 -----------
	}
	if ( (dma_irq_number >= DMASTRM20) && (dma_irq_number <= DMASTRM24 ))
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -4; 	// Already setup
 8005304:	f06f 0003 	mvn.w	r0, #3
 8005308:	bdf0      	pop	{r4, r5, r6, r7, pc}
		dma2[dma_irq_number - DMASTRM25 + 5].jmp  = p; 
		dma2[dma_irq_number - DMASTRM25 + 5].base = q; 
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
		return 0;
	}
	return -7;
 800530a:	f06f 0006 	mvn.w	r0, #6
 800530e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
		return 0;
	}
	if ( (dma_irq_number >= DMASTRM25) && (dma_irq_number <= DMASTRM27 ))
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -5; 	// Already setup
 8005310:	f06f 0004 	mvn.w	r0, #4
		dma2[dma_irq_number - DMASTRM25 + 5].base = q; 
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
		return 0;
	}
	return -7;
}
 8005314:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005316:	bf00      	nop
 8005318:	200016d8 	.word	0x200016d8
 800531c:	40023830 	.word	0x40023830

08005320 <DMA1_Stream0_IRQHandler>:
/* IRQ vectors for DMA streams points to the following.
   The following dispatches them to the routines of interest, along with one 32b pointer. */
//                                (*(  (void (**)(void))APPJUMP)   )(            );


void DMA1_Stream0_IRQHandler (void){(*dma1[0].jmp)(dma1[0].base); return;} 
 8005320:	4a02      	ldr	r2, [pc, #8]	; (800532c <DMA1_Stream0_IRQHandler+0xc>)
 8005322:	b508      	push	{r3, lr}
 8005324:	6890      	ldr	r0, [r2, #8]
 8005326:	6853      	ldr	r3, [r2, #4]
 8005328:	4798      	blx	r3
 800532a:	bd08      	pop	{r3, pc}
 800532c:	200016d8 	.word	0x200016d8

08005330 <DMA1_Stream1_IRQHandler>:
void DMA1_Stream1_IRQHandler (void){(*dma1[1].jmp)(dma1[1].base); return;}	
 8005330:	4a02      	ldr	r2, [pc, #8]	; (800533c <DMA1_Stream1_IRQHandler+0xc>)
 8005332:	b508      	push	{r3, lr}
 8005334:	6910      	ldr	r0, [r2, #16]
 8005336:	68d3      	ldr	r3, [r2, #12]
 8005338:	4798      	blx	r3
 800533a:	bd08      	pop	{r3, pc}
 800533c:	200016d8 	.word	0x200016d8

08005340 <DMA1_Stream2_IRQHandler>:
void DMA1_Stream2_IRQHandler (void){(*dma1[2].jmp)(dma1[2].base); return;}	
 8005340:	4a02      	ldr	r2, [pc, #8]	; (800534c <DMA1_Stream2_IRQHandler+0xc>)
 8005342:	b508      	push	{r3, lr}
 8005344:	6990      	ldr	r0, [r2, #24]
 8005346:	6953      	ldr	r3, [r2, #20]
 8005348:	4798      	blx	r3
 800534a:	bd08      	pop	{r3, pc}
 800534c:	200016d8 	.word	0x200016d8

08005350 <DMA1_Stream3_IRQHandler>:
void DMA1_Stream3_IRQHandler (void){(*dma1[3].jmp)(dma1[3].base); return;}	
 8005350:	4a02      	ldr	r2, [pc, #8]	; (800535c <DMA1_Stream3_IRQHandler+0xc>)
 8005352:	b508      	push	{r3, lr}
 8005354:	6a10      	ldr	r0, [r2, #32]
 8005356:	69d3      	ldr	r3, [r2, #28]
 8005358:	4798      	blx	r3
 800535a:	bd08      	pop	{r3, pc}
 800535c:	200016d8 	.word	0x200016d8

08005360 <DMA1_Stream4_IRQHandler>:
void DMA1_Stream4_IRQHandler (void){(*dma1[4].jmp)(dma1[4].base); return;}	
 8005360:	4a02      	ldr	r2, [pc, #8]	; (800536c <DMA1_Stream4_IRQHandler+0xc>)
 8005362:	b508      	push	{r3, lr}
 8005364:	6a90      	ldr	r0, [r2, #40]	; 0x28
 8005366:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8005368:	4798      	blx	r3
 800536a:	bd08      	pop	{r3, pc}
 800536c:	200016d8 	.word	0x200016d8

08005370 <DMA1_Stream5_IRQHandler>:
void DMA1_Stream5_IRQHandler (void){(*dma1[5].jmp)(dma1[5].base); return;}	
 8005370:	4a02      	ldr	r2, [pc, #8]	; (800537c <DMA1_Stream5_IRQHandler+0xc>)
 8005372:	b508      	push	{r3, lr}
 8005374:	6b10      	ldr	r0, [r2, #48]	; 0x30
 8005376:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8005378:	4798      	blx	r3
 800537a:	bd08      	pop	{r3, pc}
 800537c:	200016d8 	.word	0x200016d8

08005380 <DMA1_Stream6_IRQHandler>:
void DMA1_Stream6_IRQHandler (void){(*dma1[6].jmp)(dma1[6].base); return;}	
 8005380:	4a02      	ldr	r2, [pc, #8]	; (800538c <DMA1_Stream6_IRQHandler+0xc>)
 8005382:	b508      	push	{r3, lr}
 8005384:	6b90      	ldr	r0, [r2, #56]	; 0x38
 8005386:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8005388:	4798      	blx	r3
 800538a:	bd08      	pop	{r3, pc}
 800538c:	200016d8 	.word	0x200016d8

08005390 <DMA1_Stream7_IRQHandler>:
void DMA1_Stream7_IRQHandler (void){(*dma1[7].jmp)(dma1[7].base); return;}	
 8005390:	4a02      	ldr	r2, [pc, #8]	; (800539c <DMA1_Stream7_IRQHandler+0xc>)
 8005392:	b508      	push	{r3, lr}
 8005394:	6c10      	ldr	r0, [r2, #64]	; 0x40
 8005396:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8005398:	4798      	blx	r3
 800539a:	bd08      	pop	{r3, pc}
 800539c:	200016d8 	.word	0x200016d8

080053a0 <DMA2_Stream0_IRQHandler>:

void DMA2_Stream0_IRQHandler (void){(*dma2[0].jmp)(dma2[0].base); return;}	
 80053a0:	4a02      	ldr	r2, [pc, #8]	; (80053ac <DMA2_Stream0_IRQHandler+0xc>)
 80053a2:	b508      	push	{r3, lr}
 80053a4:	6cd0      	ldr	r0, [r2, #76]	; 0x4c
 80053a6:	6c93      	ldr	r3, [r2, #72]	; 0x48
 80053a8:	4798      	blx	r3
 80053aa:	bd08      	pop	{r3, pc}
 80053ac:	200016d8 	.word	0x200016d8

080053b0 <DMA2_Stream1_IRQHandler>:
void DMA2_Stream1_IRQHandler (void){(*dma2[1].jmp)(dma2[1].base); return;}	
 80053b0:	4a02      	ldr	r2, [pc, #8]	; (80053bc <DMA2_Stream1_IRQHandler+0xc>)
 80053b2:	b508      	push	{r3, lr}
 80053b4:	6d50      	ldr	r0, [r2, #84]	; 0x54
 80053b6:	6d13      	ldr	r3, [r2, #80]	; 0x50
 80053b8:	4798      	blx	r3
 80053ba:	bd08      	pop	{r3, pc}
 80053bc:	200016d8 	.word	0x200016d8

080053c0 <DMA2_Stream2_IRQHandler>:
void DMA2_Stream2_IRQHandler (void){(*dma2[2].jmp)(dma2[2].base); return;}	
 80053c0:	4a02      	ldr	r2, [pc, #8]	; (80053cc <DMA2_Stream2_IRQHandler+0xc>)
 80053c2:	b508      	push	{r3, lr}
 80053c4:	6dd0      	ldr	r0, [r2, #92]	; 0x5c
 80053c6:	6d93      	ldr	r3, [r2, #88]	; 0x58
 80053c8:	4798      	blx	r3
 80053ca:	bd08      	pop	{r3, pc}
 80053cc:	200016d8 	.word	0x200016d8

080053d0 <DMA2_Stream3_IRQHandler>:
void DMA2_Stream3_IRQHandler (void){(*dma2[3].jmp)(dma2[3].base); return;}	
 80053d0:	4a02      	ldr	r2, [pc, #8]	; (80053dc <DMA2_Stream3_IRQHandler+0xc>)
 80053d2:	b508      	push	{r3, lr}
 80053d4:	6e50      	ldr	r0, [r2, #100]	; 0x64
 80053d6:	6e13      	ldr	r3, [r2, #96]	; 0x60
 80053d8:	4798      	blx	r3
 80053da:	bd08      	pop	{r3, pc}
 80053dc:	200016d8 	.word	0x200016d8

080053e0 <DMA2_Stream4_IRQHandler>:
void DMA2_Stream4_IRQHandler (void){(*dma2[4].jmp)(dma2[4].base); return;}	
 80053e0:	4a02      	ldr	r2, [pc, #8]	; (80053ec <DMA2_Stream4_IRQHandler+0xc>)
 80053e2:	b508      	push	{r3, lr}
 80053e4:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 80053e6:	6e93      	ldr	r3, [r2, #104]	; 0x68
 80053e8:	4798      	blx	r3
 80053ea:	bd08      	pop	{r3, pc}
 80053ec:	200016d8 	.word	0x200016d8

080053f0 <DMA2_Stream5_IRQHandler>:

void DMA2_Stream5_IRQHandler (void){(*dma2[5].jmp)(dma2[5].base); return;}
 80053f0:	4a02      	ldr	r2, [pc, #8]	; (80053fc <DMA2_Stream5_IRQHandler+0xc>)
 80053f2:	b508      	push	{r3, lr}
 80053f4:	6f50      	ldr	r0, [r2, #116]	; 0x74
 80053f6:	6f13      	ldr	r3, [r2, #112]	; 0x70
 80053f8:	4798      	blx	r3
 80053fa:	bd08      	pop	{r3, pc}
 80053fc:	200016d8 	.word	0x200016d8

08005400 <DMA2_Stream6_IRQHandler>:
void DMA2_Stream6_IRQHandler (void){(*dma2[6].jmp)(dma2[6].base); return;}	
 8005400:	4a02      	ldr	r2, [pc, #8]	; (800540c <DMA2_Stream6_IRQHandler+0xc>)
 8005402:	b508      	push	{r3, lr}
 8005404:	6fd0      	ldr	r0, [r2, #124]	; 0x7c
 8005406:	6f93      	ldr	r3, [r2, #120]	; 0x78
 8005408:	4798      	blx	r3
 800540a:	bd08      	pop	{r3, pc}
 800540c:	200016d8 	.word	0x200016d8

08005410 <DMA2_Stream7_IRQHandler>:
void DMA2_Stream7_IRQHandler (void){(*dma2[7].jmp)(dma2[7].base); return;}	
 8005410:	4a03      	ldr	r2, [pc, #12]	; (8005420 <DMA2_Stream7_IRQHandler+0x10>)
 8005412:	b508      	push	{r3, lr}
 8005414:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84
 8005418:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 800541c:	4798      	blx	r3
 800541e:	bd08      	pop	{r3, pc}
 8005420:	200016d8 	.word	0x200016d8

08005424 <rxbuff_adv>:
 * @param	: pctl = pointer to control block
 * @param	: p = pointer to be advanced
 * @return	: new pointer 'p'
*******************************************************************************/
static u8* rxbuff_adv (struct CB_UART* pctl, u8* p)
{
 8005424:	4603      	mov	r3, r0
	p += 1; if (p >= pctl->rxbuff_end) p = pctl->rxbuff_base;
 8005426:	1c48      	adds	r0, r1, #1
 8005428:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800542a:	4290      	cmp	r0, r2
 800542c:	bf28      	it	cs
 800542e:	6ad8      	ldrcs	r0, [r3, #44]	; 0x2c
	return p;
}
 8005430:	4770      	bx	lr

08005432 <txbuff_adv>:
 * @param	: pctl = pointer to control block
 * @param	: p = pointer to be advanced
 * @return	: new pointer 'p'
*******************************************************************************/
static u8* txbuff_adv (struct CB_UART* pctl, u8* p)
{
 8005432:	4603      	mov	r3, r0
	p += 1; if (p >= pctl->txbuff_end) p = pctl->txbuff_base;
 8005434:	1c48      	adds	r0, r1, #1
 8005436:	699a      	ldr	r2, [r3, #24]
 8005438:	4290      	cmp	r0, r2
 800543a:	bf28      	it	cs
 800543c:	6958      	ldrcs	r0, [r3, #20]
	return p;
}
 800543e:	4770      	bx	lr

08005440 <common_dma>:
   routine. */
	int tmp;
	u8* ptmp;

	/* Are there bytes buffered? (Certainly yes if entered from mainline.) */  
	tmp = (pctl->txbuff_in - pctl->txbuff_out);
 8005440:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8005442:	6a02      	ldr	r2, [r0, #32]
 8005444:	1ad2      	subs	r2, r2, r3
	if (tmp == 0) return;	
 8005446:	2a00      	cmp	r2, #0
 * @brief	: Set up a disabled (idle) DMA to send if there are byte buffered
 * @param	: pctl = pointer to uart control block
 *####################################################################################### */

static void common_dma(struct CB_UART* pctl)
{
 8005448:	b530      	push	{r4, r5, lr}
	int tmp;
	u8* ptmp;

	/* Are there bytes buffered? (Certainly yes if entered from mainline.) */  
	tmp = (pctl->txbuff_in - pctl->txbuff_out);
	if (tmp == 0) return;	
 800544a:	d022      	beq.n	8005492 <common_dma+0x52>
 800544c:	68c1      	ldr	r1, [r0, #12]

	if (tmp < 0)	// Wrap around check.
 800544e:	da07      	bge.n	8005460 <common_dma+0x20>
	{ // Here, there is wrap-around, so send what remains in (non-circular) buffer.
	  // (Upon the next DMA interrupt what remains after the wrap-around will be sent.)

		// Compute number of bytes remaining to the end of the buffer
		tmp = (pctl->txbuff_end - pctl->txbuff_out); 			// Remaining ct
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; 	// Set TX mem address
 8005450:	6804      	ldr	r4, [r0, #0]
	if (tmp < 0)	// Wrap around check.
	{ // Here, there is wrap-around, so send what remains in (non-circular) buffer.
	  // (Upon the next DMA interrupt what remains after the wrap-around will be sent.)

		// Compute number of bytes remaining to the end of the buffer
		tmp = (pctl->txbuff_end - pctl->txbuff_out); 			// Remaining ct
 8005452:	6982      	ldr	r2, [r0, #24]
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; 	// Set TX mem address
 8005454:	2518      	movs	r5, #24
 8005456:	fb05 4101 	mla	r1, r5, r1, r4
	if (tmp < 0)	// Wrap around check.
	{ // Here, there is wrap-around, so send what remains in (non-circular) buffer.
	  // (Upon the next DMA interrupt what remains after the wrap-around will be sent.)

		// Compute number of bytes remaining to the end of the buffer
		tmp = (pctl->txbuff_end - pctl->txbuff_out); 			// Remaining ct
 800545a:	1ad2      	subs	r2, r2, r3
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; 	// Set TX mem address
 800545c:	61cb      	str	r3, [r1, #28]
 800545e:	e008      	b.n	8005472 <common_dma+0x32>
		pctl->txbuff_dmanext = pctl->txbuff_base;				// Save new start ptr
	}
	else
	{ // Here, no wrap around, so all buffered bytes can be sent with one setting
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; // Set TX mem address
 8005460:	6804      	ldr	r4, [r0, #0]
 8005462:	2518      	movs	r5, #24
 8005464:	fb05 4101 	mla	r1, r5, r1, r4
 8005468:	61cb      	str	r3, [r1, #28]
// redundant	tmp = pctl->txbuff_in - pctl->txbuff_out);		// Number of bytes to send
		ptmp = tmp + pctl->txbuff_out;
		if (ptmp >= pctl->txbuff_end)
 800546a:	6981      	ldr	r1, [r0, #24]
	}
	else
	{ // Here, no wrap around, so all buffered bytes can be sent with one setting
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; // Set TX mem address
// redundant	tmp = pctl->txbuff_in - pctl->txbuff_out);		// Number of bytes to send
		ptmp = tmp + pctl->txbuff_out;
 800546c:	189b      	adds	r3, r3, r2
		if (ptmp >= pctl->txbuff_end)
 800546e:	428b      	cmp	r3, r1
 8005470:	d300      	bcc.n	8005474 <common_dma+0x34>
			ptmp = pctl->txbuff_base;
 8005472:	6943      	ldr	r3, [r0, #20]
		pctl->txbuff_dmanext = ptmp;				// Save new start ptr
	}

	DMA_SNDTR(pctl->idma,pctl->txdma_stream)  = tmp;		// Set number of bytes
 8005474:	6804      	ldr	r4, [r0, #0]
 8005476:	68c1      	ldr	r1, [r0, #12]
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; // Set TX mem address
// redundant	tmp = pctl->txbuff_in - pctl->txbuff_out);		// Number of bytes to send
		ptmp = tmp + pctl->txbuff_out;
		if (ptmp >= pctl->txbuff_end)
			ptmp = pctl->txbuff_base;
		pctl->txbuff_dmanext = ptmp;				// Save new start ptr
 8005478:	6283      	str	r3, [r0, #40]	; 0x28
	}

	DMA_SNDTR(pctl->idma,pctl->txdma_stream)  = tmp;		// Set number of bytes
 800547a:	2318      	movs	r3, #24
 800547c:	4359      	muls	r1, r3
 800547e:	3414      	adds	r4, #20
 8005480:	5062      	str	r2, [r4, r1]
	DMA_SCR (pctl->idma,pctl->txdma_stream) |= 0x1;		// Enable DMA and away we go!
 8005482:	6802      	ldr	r2, [r0, #0]
 8005484:	68c1      	ldr	r1, [r0, #12]
 8005486:	3210      	adds	r2, #16
 8005488:	434b      	muls	r3, r1
 800548a:	58d1      	ldr	r1, [r2, r3]
 800548c:	f041 0101 	orr.w	r1, r1, #1
 8005490:	50d1      	str	r1, [r2, r3]
 8005492:	bd30      	pop	{r4, r5, pc}

08005494 <DMA_UART_IRQHandler>:
{
	/* The following is for consistency in the code in this file. ('nvic_dma_mgr.c' uses volatile u32*) */
	struct CB_UART* pctl = (struct CB_UART*)pall;

	/* Clear all interrupt flags for this DMA stream */
	if (pctl->txdma_stream > 3)
 8005494:	68c3      	ldr	r3, [r0, #12]
 8005496:	4a0a      	ldr	r2, [pc, #40]	; (80054c0 <DMA_UART_IRQHandler+0x2c>)
 8005498:	2b03      	cmp	r3, #3
 800549a:	d908      	bls.n	80054ae <DMA_UART_IRQHandler+0x1a>
	{// High register
		DMA_HIFCR(pctl->idma) = (0x3d << tcif_tbl[pctl->txdma_stream-4]);
 800549c:	18d3      	adds	r3, r2, r3
 800549e:	6801      	ldr	r1, [r0, #0]
 80054a0:	f813 3c04 	ldrb.w	r3, [r3, #-4]
 80054a4:	223d      	movs	r2, #61	; 0x3d
 80054a6:	fa12 f303 	lsls.w	r3, r2, r3
 80054aa:	60cb      	str	r3, [r1, #12]
 80054ac:	e005      	b.n	80054ba <DMA_UART_IRQHandler+0x26>
	}
	else
	{ // Low register
		DMA_LIFCR(pctl->idma) = (0x3d << tcif_tbl[pctl->txdma_stream]);
 80054ae:	5cd3      	ldrb	r3, [r2, r3]
 80054b0:	6801      	ldr	r1, [r0, #0]
 80054b2:	223d      	movs	r2, #61	; 0x3d
 80054b4:	fa12 f303 	lsls.w	r3, r2, r3
 80054b8:	608b      	str	r3, [r1, #8]
	}
	pctl->txbuff_out = pctl->txbuff_dmanext; // Update where in the buffer we have xmitted
 80054ba:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80054bc:	6243      	str	r3, [r0, #36]	; 0x24

	/* Here, check if there are bytes buffered and if so, figure out how to send them. */
	common_dma(pctl);
 80054be:	e7bf      	b.n	8005440 <common_dma>
 80054c0:	0801014c 	.word	0x0801014c

080054c4 <bsp_panic>:
static void common_dma(struct CB_UART* pctl);

/* Error trapping */
int PANIC_x;	// Global variable to look at.
void bsp_panic (int x)
{ PANIC_x = x; panic_leds(7); } // Save code, and flash LEDs 7x
 80054c4:	4b02      	ldr	r3, [pc, #8]	; (80054d0 <bsp_panic+0xc>)
 80054c6:	6018      	str	r0, [r3, #0]
 80054c8:	2007      	movs	r0, #7
 80054ca:	f7ff bc78 	b.w	8004dbe <panic_leds>
 80054ce:	bf00      	nop
 80054d0:	20001760 	.word	0x20001760

080054d4 <mapindex>:
 * @brief	: Edit & Map register base address to control block index & enable APBxENR
 * @param	: p = pointer to register base
 * @return	: 0 - 7 = OK; panic_leds for fail
******************************************************************************/	
static int mapindex(volatile u32 iuart)
{
 80054d4:	b507      	push	{r0, r1, r2, lr}
 80054d6:	9001      	str	r0, [sp, #4]
	int idx;

	/* Index v register base */
	switch (iuart)
 80054d8:	9b01      	ldr	r3, [sp, #4]
 80054da:	4a21      	ldr	r2, [pc, #132]	; (8005560 <mapindex+0x8c>)
 80054dc:	4293      	cmp	r3, r2
 80054de:	d030      	beq.n	8005542 <mapindex+0x6e>
 80054e0:	d806      	bhi.n	80054f0 <mapindex+0x1c>
 80054e2:	4a20      	ldr	r2, [pc, #128]	; (8005564 <mapindex+0x90>)
 80054e4:	4293      	cmp	r3, r2
 80054e6:	d01e      	beq.n	8005526 <mapindex+0x52>
 80054e8:	4a1f      	ldr	r2, [pc, #124]	; (8005568 <mapindex+0x94>)
 80054ea:	4293      	cmp	r3, r2
 80054ec:	d109      	bne.n	8005502 <mapindex+0x2e>
 80054ee:	e021      	b.n	8005534 <mapindex+0x60>
 80054f0:	4a1e      	ldr	r2, [pc, #120]	; (800556c <mapindex+0x98>)
 80054f2:	4293      	cmp	r3, r2
 80054f4:	d009      	beq.n	800550a <mapindex+0x36>
 80054f6:	4a1e      	ldr	r2, [pc, #120]	; (8005570 <mapindex+0x9c>)
 80054f8:	4293      	cmp	r3, r2
 80054fa:	d00d      	beq.n	8005518 <mapindex+0x44>
 80054fc:	4a1d      	ldr	r2, [pc, #116]	; (8005574 <mapindex+0xa0>)
 80054fe:	4293      	cmp	r3, r2
 8005500:	d026      	beq.n	8005550 <mapindex+0x7c>
	case UART4:	idx =  3; break;
	case UART5:	idx =  4; break;
	case USART6:	idx =  5; break;

	default:
		bsp_panic(-61);	// No match for request
 8005502:	f06f 003c 	mvn.w	r0, #60	; 0x3c
 8005506:	f7ff ffdd 	bl	80054c4 <bsp_panic>
	}
	/* Enable USART/UART module on appropriate bus */
	switch (idx)
	{
	case 0:	RCC_AHB2ENR |= (1 << 4); break;
 800550a:	4b1b      	ldr	r3, [pc, #108]	; (8005578 <mapindex+0xa4>)
 800550c:	681a      	ldr	r2, [r3, #0]
 800550e:	f042 0210 	orr.w	r2, r2, #16
 8005512:	601a      	str	r2, [r3, #0]
 8005514:	2000      	movs	r0, #0
 8005516:	e021      	b.n	800555c <mapindex+0x88>
	case 5:	RCC_AHB2ENR |= (1 << 5); break;	
 8005518:	4b17      	ldr	r3, [pc, #92]	; (8005578 <mapindex+0xa4>)
 800551a:	681a      	ldr	r2, [r3, #0]
 800551c:	f042 0220 	orr.w	r2, r2, #32
 8005520:	601a      	str	r2, [r3, #0]
 8005522:	2005      	movs	r0, #5
 8005524:	e01a      	b.n	800555c <mapindex+0x88>

	case 1:	RCC_AHB1ENR |= (1 << 17); break;
 8005526:	4b15      	ldr	r3, [pc, #84]	; (800557c <mapindex+0xa8>)
 8005528:	681a      	ldr	r2, [r3, #0]
 800552a:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800552e:	601a      	str	r2, [r3, #0]
 8005530:	2001      	movs	r0, #1
 8005532:	e013      	b.n	800555c <mapindex+0x88>
	case 2:	RCC_AHB1ENR |= (1 << 18); break;
 8005534:	4b11      	ldr	r3, [pc, #68]	; (800557c <mapindex+0xa8>)
 8005536:	681a      	ldr	r2, [r3, #0]
 8005538:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800553c:	601a      	str	r2, [r3, #0]
 800553e:	2002      	movs	r0, #2
 8005540:	e00c      	b.n	800555c <mapindex+0x88>
	case 3:	RCC_AHB1ENR |= (1 << 19); break;
 8005542:	4b0e      	ldr	r3, [pc, #56]	; (800557c <mapindex+0xa8>)
 8005544:	681a      	ldr	r2, [r3, #0]
 8005546:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 800554a:	601a      	str	r2, [r3, #0]
 800554c:	2003      	movs	r0, #3
 800554e:	e005      	b.n	800555c <mapindex+0x88>
	case 4:	RCC_AHB1ENR |= (1 << 20); break;
 8005550:	4b0a      	ldr	r3, [pc, #40]	; (800557c <mapindex+0xa8>)
 8005552:	681a      	ldr	r2, [r3, #0]
 8005554:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8005558:	601a      	str	r2, [r3, #0]
 800555a:	2004      	movs	r0, #4
	default:
		bsp_panic(-62);	// Wrong
	}

	return idx;
}
 800555c:	bd0e      	pop	{r1, r2, r3, pc}
 800555e:	bf00      	nop
 8005560:	40004c00 	.word	0x40004c00
 8005564:	40004400 	.word	0x40004400
 8005568:	40004800 	.word	0x40004800
 800556c:	40011000 	.word	0x40011000
 8005570:	40011400 	.word	0x40011400
 8005574:	40005000 	.word	0x40005000
 8005578:	40023834 	.word	0x40023834
 800557c:	40023830 	.word	0x40023830

08005580 <getbuff>:
 * @param	: rxbuffsize = requested size of rx buffer
 * @param	: txbuffsize = requested size of rx buffer
 * @return	: 0 = OK; -1; fail = led trap
******************************************************************************/	
static int getbuff(int idx, u32 rxbuffsize, u32 txbuffsize)
{
 8005580:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005582:	4604      	mov	r4, r0
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
 8005584:	4f13      	ldr	r7, [pc, #76]	; (80055d4 <getbuff+0x54>)
 8005586:	4608      	mov	r0, r1
 * @param	: rxbuffsize = requested size of rx buffer
 * @param	: txbuffsize = requested size of rx buffer
 * @return	: 0 = OK; -1; fail = led trap
******************************************************************************/	
static int getbuff(int idx, u32 rxbuffsize, u32 txbuffsize)
{
 8005588:	460d      	mov	r5, r1
 800558a:	4616      	mov	r6, r2
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
 800558c:	f000 ffd8 	bl	8006540 <malloc>
 8005590:	01a3      	lsls	r3, r4, #6
 8005592:	18fb      	adds	r3, r7, r3
 8005594:	6318      	str	r0, [r3, #48]	; 0x30
 8005596:	b910      	cbnz	r0, 800559e <getbuff+0x1e>
 8005598:	380d      	subs	r0, #13
 800559a:	f7ff ff93 	bl	80054c4 <bsp_panic>
	if ((cb_uart[idx].txbuff_base = malloc(txbuffsize)) == NULL) bsp_panic(-14);	// malloc failed to obtain tx buffer
 800559e:	4630      	mov	r0, r6
 80055a0:	f000 ffce 	bl	8006540 <malloc>
 80055a4:	01a4      	lsls	r4, r4, #6
 80055a6:	193b      	adds	r3, r7, r4
 80055a8:	6198      	str	r0, [r3, #24]
 80055aa:	b910      	cbnz	r0, 80055b2 <getbuff+0x32>
 80055ac:	380e      	subs	r0, #14
 80055ae:	f7ff ff89 	bl	80054c4 <bsp_panic>
	cb_uart[idx].rxbuff_end  = cb_uart[idx].rxbuff_base + rxbuffsize;
 80055b2:	193c      	adds	r4, r7, r4
	cb_uart[idx].txbuff_dmanext = cb_uart[idx].txbuff_base;
	cb_uart[idx].rxbuff_in   = cb_uart[idx].rxbuff_base;
	cb_uart[idx].txbuff_in   = cb_uart[idx].txbuff_base;
	
	return 0;
}
 80055b4:	2000      	movs	r0, #0
static int getbuff(int idx, u32 rxbuffsize, u32 txbuffsize)
{
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
	if ((cb_uart[idx].txbuff_base = malloc(txbuffsize)) == NULL) bsp_panic(-14);	// malloc failed to obtain tx buffer
	cb_uart[idx].rxbuff_end  = cb_uart[idx].rxbuff_base + rxbuffsize;
 80055b6:	6b22      	ldr	r2, [r4, #48]	; 0x30
	cb_uart[idx].txbuff_end  = cb_uart[idx].txbuff_base + txbuffsize;
	cb_uart[idx].rxbuff_size = rxbuffsize;
 80055b8:	63a5      	str	r5, [r4, #56]	; 0x38
static int getbuff(int idx, u32 rxbuffsize, u32 txbuffsize)
{
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
	if ((cb_uart[idx].txbuff_base = malloc(txbuffsize)) == NULL) bsp_panic(-14);	// malloc failed to obtain tx buffer
	cb_uart[idx].rxbuff_end  = cb_uart[idx].rxbuff_base + rxbuffsize;
 80055ba:	1953      	adds	r3, r2, r5
 80055bc:	6363      	str	r3, [r4, #52]	; 0x34
	cb_uart[idx].txbuff_end  = cb_uart[idx].txbuff_base + txbuffsize;
 80055be:	69a3      	ldr	r3, [r4, #24]
	cb_uart[idx].rxbuff_size = rxbuffsize;
	cb_uart[idx].txbuff_size = txbuffsize;
 80055c0:	6226      	str	r6, [r4, #32]
{
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
	if ((cb_uart[idx].txbuff_base = malloc(txbuffsize)) == NULL) bsp_panic(-14);	// malloc failed to obtain tx buffer
	cb_uart[idx].rxbuff_end  = cb_uart[idx].rxbuff_base + rxbuffsize;
	cb_uart[idx].txbuff_end  = cb_uart[idx].txbuff_base + txbuffsize;
 80055c2:	1999      	adds	r1, r3, r6
 80055c4:	61e1      	str	r1, [r4, #28]
	cb_uart[idx].rxbuff_size = rxbuffsize;
	cb_uart[idx].txbuff_size = txbuffsize;
	cb_uart[idx].rxbuff_out  = cb_uart[idx].rxbuff_base;
 80055c6:	6422      	str	r2, [r4, #64]	; 0x40
	cb_uart[idx].txbuff_out  = cb_uart[idx].txbuff_base;
 80055c8:	62a3      	str	r3, [r4, #40]	; 0x28
	cb_uart[idx].txbuff_dmanext = cb_uart[idx].txbuff_base;
 80055ca:	62e3      	str	r3, [r4, #44]	; 0x2c
	cb_uart[idx].rxbuff_in   = cb_uart[idx].rxbuff_base;
 80055cc:	63e2      	str	r2, [r4, #60]	; 0x3c
	cb_uart[idx].txbuff_in   = cb_uart[idx].txbuff_base;
 80055ce:	6263      	str	r3, [r4, #36]	; 0x24
	
	return 0;
}
 80055d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80055d2:	bf00      	nop
 80055d4:	20001760 	.word	0x20001760

080055d8 <uartnumber_to_baseaddr>:
*******************************************************************************/
static u32 uartnumber_to_baseaddr(u32 uartnumber)
{
	u32 iuart = 0;
	/* Convert uart number to uart register base address */
	switch (uartnumber)
 80055d8:	3801      	subs	r0, #1
 * @brief	: Map uart number (1-6) to uart module base address
 * @param	: uartnumber = (1 -6), e.g. 2 = USART2
 * @return	: USART/UART base address, e.g. USART2 = 0x40004400
*******************************************************************************/
static u32 uartnumber_to_baseaddr(u32 uartnumber)
{
 80055da:	b508      	push	{r3, lr}
	u32 iuart = 0;
	/* Convert uart number to uart register base address */
	switch (uartnumber)
 80055dc:	2805      	cmp	r0, #5
 80055de:	d80e      	bhi.n	80055fe <uartnumber_to_baseaddr+0x26>
 80055e0:	e8df f000 	tbb	[pc, r0]
 80055e4:	07051303 	.word	0x07051303
 80055e8:	0b09      	.short	0x0b09
	{
	case 1:	iuart = USART1;	break;
 80055ea:	4809      	ldr	r0, [pc, #36]	; (8005610 <uartnumber_to_baseaddr+0x38>)
 80055ec:	bd08      	pop	{r3, pc}
	case 2:	iuart = USART2;	break;
	case 3:	iuart = USART3;	break;
 80055ee:	4809      	ldr	r0, [pc, #36]	; (8005614 <uartnumber_to_baseaddr+0x3c>)
 80055f0:	bd08      	pop	{r3, pc}
	case 4:	iuart =  UART4;	break;
 80055f2:	4809      	ldr	r0, [pc, #36]	; (8005618 <uartnumber_to_baseaddr+0x40>)
 80055f4:	bd08      	pop	{r3, pc}
	case 5:	iuart =  UART5;	break;
 80055f6:	4809      	ldr	r0, [pc, #36]	; (800561c <uartnumber_to_baseaddr+0x44>)
 80055f8:	bd08      	pop	{r3, pc}
	case 6:	iuart = USART6;	break;
 80055fa:	4809      	ldr	r0, [pc, #36]	; (8005620 <uartnumber_to_baseaddr+0x48>)
 80055fc:	bd08      	pop	{r3, pc}

	default:
		bsp_panic(-66);	// No match for request
 80055fe:	f06f 0041 	mvn.w	r0, #65	; 0x41
 8005602:	f7ff ff5f 	bl	80054c4 <bsp_panic>
 * @param	: uartnumber = (1 -6), e.g. 2 = USART2
 * @return	: USART/UART base address, e.g. USART2 = 0x40004400
*******************************************************************************/
static u32 uartnumber_to_baseaddr(u32 uartnumber)
{
	u32 iuart = 0;
 8005606:	2000      	movs	r0, #0
 8005608:	bd08      	pop	{r3, pc}
	/* Convert uart number to uart register base address */
	switch (uartnumber)
	{
	case 1:	iuart = USART1;	break;
	case 2:	iuart = USART2;	break;
 800560a:	4806      	ldr	r0, [pc, #24]	; (8005624 <uartnumber_to_baseaddr+0x4c>)
	default:
		bsp_panic(-66);	// No match for request
	}	
	return iuart;

}
 800560c:	bd08      	pop	{r3, pc}
 800560e:	bf00      	nop
 8005610:	40011000 	.word	0x40011000
 8005614:	40004800 	.word	0x40004800
 8005618:	40004c00 	.word	0x40004c00
 800561c:	40005000 	.word	0x40005000
 8005620:	40011400 	.word	0x40011400
 8005624:	40004400 	.word	0x40004400

08005628 <irq_given_datastream>:
{
	u32	dma;
	int	num;
};
static struct IRQNUM irq_given_datastream(u32 iuart, int dmastream)
{
 8005628:	b570      	push	{r4, r5, r6, lr}
	struct IRQNUM irqnum = {0,0}; 
	if (dmastream < 0) bsp_panic(-714);
 800562a:	1e16      	subs	r6, r2, #0
{
	u32	dma;
	int	num;
};
static struct IRQNUM irq_given_datastream(u32 iuart, int dmastream)
{
 800562c:	4604      	mov	r4, r0
 800562e:	460d      	mov	r5, r1
	struct IRQNUM irqnum = {0,0}; 
	if (dmastream < 0) bsp_panic(-714);
 8005630:	da02      	bge.n	8005638 <irq_given_datastream+0x10>
 8005632:	480f      	ldr	r0, [pc, #60]	; (8005670 <irq_given_datastream+0x48>)
 8005634:	f7ff ff46 	bl	80054c4 <bsp_panic>

	if ((iuart == USART1) || (iuart == USART6))
 8005638:	4b0e      	ldr	r3, [pc, #56]	; (8005674 <irq_given_datastream+0x4c>)
 800563a:	429d      	cmp	r5, r3
 800563c:	d002      	beq.n	8005644 <irq_given_datastream+0x1c>
 800563e:	4b0e      	ldr	r3, [pc, #56]	; (8005678 <irq_given_datastream+0x50>)
 8005640:	429d      	cmp	r5, r3
 8005642:	d108      	bne.n	8005656 <irq_given_datastream+0x2e>
	{
		irqnum.dma = DMA2_BASE;
		if (dmastream > 4)	// Determine IRQ number for the stream 
 8005644:	2e04      	cmp	r6, #4
 8005646:	4b0d      	ldr	r3, [pc, #52]	; (800567c <irq_given_datastream+0x54>)
 8005648:	dd02      	ble.n	8005650 <irq_given_datastream+0x28>
 800564a:	6023      	str	r3, [r4, #0]
		{ irqnum.num = (DMASTRM25 + dmastream - 5); return irqnum;}
 800564c:	363f      	adds	r6, #63	; 0x3f
 800564e:	e00b      	b.n	8005668 <irq_given_datastream+0x40>
 8005650:	6023      	str	r3, [r4, #0]
		else
		{ irqnum.num = (DMASTRM20 + dmastream); return irqnum;}
 8005652:	3638      	adds	r6, #56	; 0x38
 8005654:	e008      	b.n	8005668 <irq_given_datastream+0x40>
	}

	irqnum.dma = DMA1_BASE;
	if (dmastream == 7)
 8005656:	2e07      	cmp	r6, #7
 8005658:	4b09      	ldr	r3, [pc, #36]	; (8005680 <irq_given_datastream+0x58>)
 800565a:	d103      	bne.n	8005664 <irq_given_datastream+0x3c>
 800565c:	6023      	str	r3, [r4, #0]
 800565e:	232f      	movs	r3, #47	; 0x2f
 8005660:	6063      	str	r3, [r4, #4]
		{ irqnum.num = (DMASTRM17); return irqnum;}
 8005662:	e002      	b.n	800566a <irq_given_datastream+0x42>
 8005664:	6023      	str	r3, [r4, #0]
	else
		{ irqnum.num = (DMASTRM10 + dmastream); return irqnum;}
 8005666:	360b      	adds	r6, #11
		{ irqnum.num = (DMASTRM20 + dmastream); return irqnum;}
	}

	irqnum.dma = DMA1_BASE;
	if (dmastream == 7)
		{ irqnum.num = (DMASTRM17); return irqnum;}
 8005668:	6066      	str	r6, [r4, #4]
	else
		{ irqnum.num = (DMASTRM10 + dmastream); return irqnum;}

	bsp_panic(-715);	// Shouldn't happen
	return irqnum;
}
 800566a:	4620      	mov	r0, r4
 800566c:	bd70      	pop	{r4, r5, r6, pc}
 800566e:	bf00      	nop
 8005670:	fffffd36 	.word	0xfffffd36
 8005674:	40011000 	.word	0x40011000
 8005678:	40011400 	.word	0x40011400
 800567c:	40026400 	.word	0x40026400
 8005680:	40026000 	.word	0x40026000

08005684 <bsp_uart_open>:
 * @return	: control block pointer
******************************************************************************/	
static const char* open_name[8] = {"tty1", "tty2", "tty3", "tty4", "tty5", "tty6", "tty7", "tty8"};

struct CB_UART* bsp_uart_open(const char *name)
{
 8005684:	b570      	push	{r4, r5, r6, lr}
	int i;
	for (i = 0; i < 8; i++)
	{
		if (strcmp(name, open_name[i]) == 0) break;
	}
	if (i >= 8) return (struct CB_UART*)-1;
 8005686:	4d09      	ldr	r5, [pc, #36]	; (80056ac <bsp_uart_open+0x28>)
 * @return	: control block pointer
******************************************************************************/	
static const char* open_name[8] = {"tty1", "tty2", "tty3", "tty4", "tty5", "tty6", "tty7", "tty8"};

struct CB_UART* bsp_uart_open(const char *name)
{
 8005688:	4606      	mov	r6, r0
	int i;
	for (i = 0; i < 8; i++)
 800568a:	2400      	movs	r4, #0
	{
		if (strcmp(name, open_name[i]) == 0) break;
 800568c:	4630      	mov	r0, r6
 800568e:	f855 1f04 	ldr.w	r1, [r5, #4]!
 8005692:	f001 fbbd 	bl	8006e10 <strcmp>
 8005696:	b128      	cbz	r0, 80056a4 <bsp_uart_open+0x20>
static const char* open_name[8] = {"tty1", "tty2", "tty3", "tty4", "tty5", "tty6", "tty7", "tty8"};

struct CB_UART* bsp_uart_open(const char *name)
{
	int i;
	for (i = 0; i < 8; i++)
 8005698:	3401      	adds	r4, #1
 800569a:	2c08      	cmp	r4, #8
 800569c:	d1f6      	bne.n	800568c <bsp_uart_open+0x8>
	{
		if (strcmp(name, open_name[i]) == 0) break;
	}
	if (i >= 8) return (struct CB_UART*)-1;
 800569e:	f04f 30ff 	mov.w	r0, #4294967295
 80056a2:	bd70      	pop	{r4, r5, r6, pc}
	
	return &cb_uart[i];	// Return control block ptr to 'open'
 80056a4:	4802      	ldr	r0, [pc, #8]	; (80056b0 <bsp_uart_open+0x2c>)
 80056a6:	01a4      	lsls	r4, r4, #6
 80056a8:	1900      	adds	r0, r0, r4
}
 80056aa:	bd70      	pop	{r4, r5, r6, pc}
 80056ac:	0801014c 	.word	0x0801014c
 80056b0:	20001764 	.word	0x20001764

080056b4 <bsp_uart_dma_init>:
 * @param	: dmastreamtx: DMA stream number for TX (0 - 7)
 * @param	: dma_tx_int_priority: interrupt priority, (0x00 - 0xf0) e.g. 0xc0, low 4 bits zero
 * @return	: 0 = success; fail traps to 'panic_leds'
*******************************************************************************/
int bsp_uart_dma_init(u32 iuart, u32 baud, u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority)
{
 80056b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80056b8:	b08b      	sub	sp, #44	; 0x2c
 80056ba:	4604      	mov	r4, r0
 80056bc:	9f14      	ldr	r7, [sp, #80]	; 0x50
 80056be:	9101      	str	r1, [sp, #4]
	u32 dma_channel_number_rx = 4;	// Initialize to prevent compiler warning
	u32 dma_channel_number_tx = 5;	


	/* Be sure arguments passed are within range */
	if (dmastreamrx > 7) bsp_panic(-1);
 80056c0:	2f07      	cmp	r7, #7
 * @param	: dmastreamtx: DMA stream number for TX (0 - 7)
 * @param	: dma_tx_int_priority: interrupt priority, (0x00 - 0xf0) e.g. 0xc0, low 4 bits zero
 * @return	: 0 = success; fail traps to 'panic_leds'
*******************************************************************************/
int bsp_uart_dma_init(u32 iuart, u32 baud, u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority)
{
 80056c2:	9202      	str	r2, [sp, #8]
 80056c4:	9303      	str	r3, [sp, #12]
 80056c6:	f8dd a054 	ldr.w	sl, [sp, #84]	; 0x54
	u32 dma_channel_number_rx = 4;	// Initialize to prevent compiler warning
	u32 dma_channel_number_tx = 5;	


	/* Be sure arguments passed are within range */
	if (dmastreamrx > 7) bsp_panic(-1);
 80056ca:	d903      	bls.n	80056d4 <bsp_uart_dma_init+0x20>
 80056cc:	f04f 30ff 	mov.w	r0, #4294967295
 80056d0:	f7ff fef8 	bl	80054c4 <bsp_panic>
	if (dmastreamtx > 7) bsp_panic(-2);
 80056d4:	f1ba 0f07 	cmp.w	sl, #7
 80056d8:	d903      	bls.n	80056e2 <bsp_uart_dma_init+0x2e>
 80056da:	f06f 0001 	mvn.w	r0, #1
 80056de:	f7ff fef1 	bl	80054c4 <bsp_panic>
	if ((dma_tx_int_priority & 0xffffff0f) != 0) bsp_panic(-3); // Bogus priority
 80056e2:	9916      	ldr	r1, [sp, #88]	; 0x58
 80056e4:	f031 01f0 	bics.w	r1, r1, #240	; 0xf0
 80056e8:	d003      	beq.n	80056f2 <bsp_uart_dma_init+0x3e>
 80056ea:	f06f 0002 	mvn.w	r0, #2
 80056ee:	f7ff fee9 	bl	80054c4 <bsp_panic>
	
	cb_Idx = mapindex(iuart);	// Map usart/uart register base to control block index
 80056f2:	4620      	mov	r0, r4
 80056f4:	f7ff feee 	bl	80054d4 <mapindex>

	/* Convert dma stream to dma base and irq number */
	dma_irq_number_tx = irq_given_datastream(iuart, dmastreamtx); // TX
 80056f8:	4621      	mov	r1, r4
 80056fa:	4652      	mov	r2, sl
	/* Be sure arguments passed are within range */
	if (dmastreamrx > 7) bsp_panic(-1);
	if (dmastreamtx > 7) bsp_panic(-2);
	if ((dma_tx_int_priority & 0xffffff0f) != 0) bsp_panic(-3); // Bogus priority
	
	cb_Idx = mapindex(iuart);	// Map usart/uart register base to control block index
 80056fc:	4683      	mov	fp, r0

	/* Convert dma stream to dma base and irq number */
	dma_irq_number_tx = irq_given_datastream(iuart, dmastreamtx); // TX
 80056fe:	a806      	add	r0, sp, #24
 8005700:	f7ff ff92 	bl	8005628 <irq_given_datastream>
	dma_irq_number_rx = irq_given_datastream(iuart, dmastreamrx); // RX
 8005704:	a804      	add	r0, sp, #16
 8005706:	4621      	mov	r1, r4
 8005708:	463a      	mov	r2, r7
	if ((dma_tx_int_priority & 0xffffff0f) != 0) bsp_panic(-3); // Bogus priority
	
	cb_Idx = mapindex(iuart);	// Map usart/uart register base to control block index

	/* Convert dma stream to dma base and irq number */
	dma_irq_number_tx = irq_given_datastream(iuart, dmastreamtx); // TX
 800570a:	9e06      	ldr	r6, [sp, #24]
 800570c:	9d07      	ldr	r5, [sp, #28]
	dma_irq_number_rx = irq_given_datastream(iuart, dmastreamrx); // RX
 800570e:	f7ff ff8b 	bl	8005628 <irq_given_datastream>
	
	/* The DMA determined should be the same...mostly a debugging issue. */
	if (dma_irq_number_tx.dma != dma_irq_number_rx.dma) bsp_panic(-333);
 8005712:	9b04      	ldr	r3, [sp, #16]
	
	cb_Idx = mapindex(iuart);	// Map usart/uart register base to control block index

	/* Convert dma stream to dma base and irq number */
	dma_irq_number_tx = irq_given_datastream(iuart, dmastreamtx); // TX
	dma_irq_number_rx = irq_given_datastream(iuart, dmastreamrx); // RX
 8005714:	f8dd 9014 	ldr.w	r9, [sp, #20]
	
	/* The DMA determined should be the same...mostly a debugging issue. */
	if (dma_irq_number_tx.dma != dma_irq_number_rx.dma) bsp_panic(-333);
 8005718:	429e      	cmp	r6, r3
 800571a:	d003      	beq.n	8005724 <bsp_uart_dma_init+0x70>
 800571c:	f46f 70a6 	mvn.w	r0, #332	; 0x14c
 8005720:	f7ff fed0 	bl	80054c4 <bsp_panic>
	dma_x = dma_irq_number_tx.dma;	// Lazy way of dealing with it later

	/* Set dma stream interrupt to revector to this routine; check if dma is in use. */
	tmp = nvic_dma_stream_vector_add( (void(*)(u32*))&DMA_UART_IRQHandler, (u32*)&cb_uart[cb_Idx], dma_irq_number_tx.num, dmastreamtx);
 8005724:	4a85      	ldr	r2, [pc, #532]	; (800593c <bsp_uart_dma_init+0x288>)
 8005726:	4886      	ldr	r0, [pc, #536]	; (8005940 <bsp_uart_dma_init+0x28c>)
 8005728:	ea4f 138b 	mov.w	r3, fp, lsl #6
 800572c:	eb02 0803 	add.w	r8, r2, r3
 8005730:	4641      	mov	r1, r8
 8005732:	462a      	mov	r2, r5
 8005734:	4653      	mov	r3, sl
 8005736:	f7ff fd75 	bl	8005224 <nvic_dma_stream_vector_add>
	if (tmp != 0) bsp_panic(-30 + tmp);
 800573a:	b110      	cbz	r0, 8005742 <bsp_uart_dma_init+0x8e>
 800573c:	381e      	subs	r0, #30
 800573e:	f7ff fec1 	bl	80054c4 <bsp_panic>

	/* RX doesn't interrupt, but we need to show that the stream has been taken */
	tmp = nvic_dma_stream_vector_add( (void(*)(u32*))&DMA_UART_IRQHandler, (u32*)&cb_uart[cb_Idx], dma_irq_number_rx.num, dmastreamrx);
 8005742:	487f      	ldr	r0, [pc, #508]	; (8005940 <bsp_uart_dma_init+0x28c>)
 8005744:	4641      	mov	r1, r8
 8005746:	464a      	mov	r2, r9
 8005748:	463b      	mov	r3, r7
 800574a:	f7ff fd6b 	bl	8005224 <nvic_dma_stream_vector_add>
	if (tmp != 0) bsp_panic(-130 + tmp);
 800574e:	b110      	cbz	r0, 8005756 <bsp_uart_dma_init+0xa2>
 8005750:	3882      	subs	r0, #130	; 0x82
 8005752:	f7ff feb7 	bl	80054c4 <bsp_panic>


	/* Load some parameters that might be important. */
	cb_uart[cb_Idx].idma = dma_x;	// Save dma register base address
 8005756:	4a7b      	ldr	r2, [pc, #492]	; (8005944 <bsp_uart_dma_init+0x290>)
 8005758:	ea4f 138b 	mov.w	r3, fp, lsl #6
 800575c:	18d3      	adds	r3, r2, r3
	cb_uart[cb_Idx].rxdma_stream = dmastreamrx; // Save stream number
	cb_uart[cb_Idx].txdma_stream = dmastreamtx; // Save stream number
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
	cb_uart[cb_Idx].flag = 2;	// Show this setup for dma driven
 800575e:	2102      	movs	r1, #2
	tmp = nvic_dma_stream_vector_add( (void(*)(u32*))&DMA_UART_IRQHandler, (u32*)&cb_uart[cb_Idx], dma_irq_number_rx.num, dmastreamrx);
	if (tmp != 0) bsp_panic(-130 + tmp);


	/* Load some parameters that might be important. */
	cb_uart[cb_Idx].idma = dma_x;	// Save dma register base address
 8005760:	605e      	str	r6, [r3, #4]
	cb_uart[cb_Idx].rxdma_stream = dmastreamrx; // Save stream number
 8005762:	60df      	str	r7, [r3, #12]
	cb_uart[cb_Idx].txdma_stream = dmastreamtx; // Save stream number
 8005764:	f8c3 a010 	str.w	sl, [r3, #16]
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
 8005768:	609c      	str	r4, [r3, #8]
	cb_uart[cb_Idx].flag = 2;	// Show this setup for dma driven
 800576a:	6159      	str	r1, [r3, #20]

	/* Find DMA channel numbers for RX and TX, given stream number */
	switch (dma_x)
 800576c:	4b76      	ldr	r3, [pc, #472]	; (8005948 <bsp_uart_dma_init+0x294>)
 800576e:	429e      	cmp	r6, r3
 8005770:	d003      	beq.n	800577a <bsp_uart_dma_init+0xc6>
 8005772:	4b76      	ldr	r3, [pc, #472]	; (800594c <bsp_uart_dma_init+0x298>)
 8005774:	429e      	cmp	r6, r3
 8005776:	d11f      	bne.n	80057b8 <bsp_uart_dma_init+0x104>
 8005778:	e00f      	b.n	800579a <bsp_uart_dma_init+0xe6>
	{
	case DMA1_BASE:
		if (dma1_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
 800577a:	f007 0207 	and.w	r2, r7, #7
 800577e:	4b74      	ldr	r3, [pc, #464]	; (8005950 <bsp_uart_dma_init+0x29c>)
 8005780:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8005784:	42a1      	cmp	r1, r4
 8005786:	d01b      	beq.n	80057c0 <bsp_uart_dma_init+0x10c>
		if (dma1_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
 8005788:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800578c:	6a1b      	ldr	r3, [r3, #32]
 800578e:	42a3      	cmp	r3, r4
 8005790:	d022      	beq.n	80057d8 <bsp_uart_dma_init+0x124>
		bsp_panic(-6);	// RX stream specified is not compatible with UART/DMA1
 8005792:	f06f 0005 	mvn.w	r0, #5
 8005796:	f7ff fe95 	bl	80054c4 <bsp_panic>

	case DMA2_BASE:
		if (dma2_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
 800579a:	4b6d      	ldr	r3, [pc, #436]	; (8005950 <bsp_uart_dma_init+0x29c>)
 800579c:	f007 0207 	and.w	r2, r7, #7
 80057a0:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80057a4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80057a6:	42a2      	cmp	r2, r4
 80057a8:	d00a      	beq.n	80057c0 <bsp_uart_dma_init+0x10c>
		if (dma2_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
 80057aa:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80057ac:	42a3      	cmp	r3, r4
 80057ae:	d00a      	beq.n	80057c6 <bsp_uart_dma_init+0x112>
		bsp_panic(-7);	// RX stream specified is not compatible with UART/DMA2
 80057b0:	f06f 0006 	mvn.w	r0, #6
 80057b4:	f7ff fe86 	bl	80054c4 <bsp_panic>
	default:
		bsp_panic(-8);	// Something seriously wrong here!
 80057b8:	f06f 0007 	mvn.w	r0, #7
 80057bc:	f7ff fe82 	bl	80054c4 <bsp_panic>
		if (dma1_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
		if (dma1_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
		bsp_panic(-6);	// RX stream specified is not compatible with UART/DMA1

	case DMA2_BASE:
		if (dma2_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
 80057c0:	f04f 0904 	mov.w	r9, #4
 80057c4:	e001      	b.n	80057ca <bsp_uart_dma_init+0x116>
		if (dma2_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
 80057c6:	f04f 0905 	mov.w	r9, #5
	default:
		bsp_panic(-8);	// Something seriously wrong here!

	}

	switch (dma_x)
 80057ca:	4b5f      	ldr	r3, [pc, #380]	; (8005948 <bsp_uart_dma_init+0x294>)
 80057cc:	429e      	cmp	r6, r3
 80057ce:	d005      	beq.n	80057dc <bsp_uart_dma_init+0x128>
 80057d0:	4b5e      	ldr	r3, [pc, #376]	; (800594c <bsp_uart_dma_init+0x298>)
 80057d2:	429e      	cmp	r6, r3
 80057d4:	d128      	bne.n	8005828 <bsp_uart_dma_init+0x174>
 80057d6:	e016      	b.n	8005806 <bsp_uart_dma_init+0x152>
	/* Find DMA channel numbers for RX and TX, given stream number */
	switch (dma_x)
	{
	case DMA1_BASE:
		if (dma1_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
		if (dma1_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
 80057d8:	f04f 0905 	mov.w	r9, #5
	}

	switch (dma_x)
	{
	case DMA1_BASE:
		if (dma1_txstreamtbl_4[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 4; break;}
 80057dc:	4b5c      	ldr	r3, [pc, #368]	; (8005950 <bsp_uart_dma_init+0x29c>)
 80057de:	f00a 0207 	and.w	r2, sl, #7
 80057e2:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80057e6:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 80057ea:	42a2      	cmp	r2, r4
 80057ec:	d024      	beq.n	8005838 <bsp_uart_dma_init+0x184>
		if (dma1_txstreamtbl_5[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 5; break;}
 80057ee:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 80057f2:	42a2      	cmp	r2, r4
 80057f4:	d023      	beq.n	800583e <bsp_uart_dma_init+0x18a>
		if (dma1_txstreamtbl_7[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 7; break;}
 80057f6:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 80057fa:	42a3      	cmp	r3, r4
 80057fc:	d019      	beq.n	8005832 <bsp_uart_dma_init+0x17e>
		bsp_panic(-9);	// TX stream specified is not compatible with UART/DMA1
 80057fe:	f06f 0008 	mvn.w	r0, #8
 8005802:	f7ff fe5f 	bl	80054c4 <bsp_panic>

	case DMA2_BASE:
		if (dma2_txstreamtbl_4[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 4; break;}
 8005806:	4b52      	ldr	r3, [pc, #328]	; (8005950 <bsp_uart_dma_init+0x29c>)
 8005808:	f00a 0207 	and.w	r2, sl, #7
 800580c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8005810:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8005814:	42a2      	cmp	r2, r4
 8005816:	d00f      	beq.n	8005838 <bsp_uart_dma_init+0x184>
		if (dma2_txstreamtbl_5[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 5; break;}
 8005818:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 800581c:	42a3      	cmp	r3, r4
 800581e:	d00e      	beq.n	800583e <bsp_uart_dma_init+0x18a>
		bsp_panic(-10);	// TX stream specified is not compatible with UART/DMA2
 8005820:	f06f 0009 	mvn.w	r0, #9
 8005824:	f7ff fe4e 	bl	80054c4 <bsp_panic>
	default:
		bsp_panic(-11);	// Something seriously wrong here!
 8005828:	f06f 000a 	mvn.w	r0, #10
 800582c:	f7ff fe4a 	bl	80054c4 <bsp_panic>
 8005830:	e005      	b.n	800583e <bsp_uart_dma_init+0x18a>
	switch (dma_x)
	{
	case DMA1_BASE:
		if (dma1_txstreamtbl_4[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 4; break;}
		if (dma1_txstreamtbl_5[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 5; break;}
		if (dma1_txstreamtbl_7[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 7; break;}
 8005832:	f04f 0807 	mov.w	r8, #7
 8005836:	e004      	b.n	8005842 <bsp_uart_dma_init+0x18e>
		bsp_panic(-9);	// TX stream specified is not compatible with UART/DMA1

	case DMA2_BASE:
		if (dma2_txstreamtbl_4[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 4; break;}
 8005838:	f04f 0804 	mov.w	r8, #4
 800583c:	e001      	b.n	8005842 <bsp_uart_dma_init+0x18e>
		if (dma2_txstreamtbl_5[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 5; break;}
 800583e:	f04f 0805 	mov.w	r8, #5
	default:
		bsp_panic(-11);	// Something seriously wrong here!

	}
static u32 qqq;
	qqq = dma_channel_number_rx;
 8005842:	4a40      	ldr	r2, [pc, #256]	; (8005944 <bsp_uart_dma_init+0x290>)
/* At this point we (should!) have a good DMA channel and stream that associates with the UART. */

	/* Set up UART pins, port & uart clockings.  THIS IS BOARD SPECIFIC */
	if (uart_pins(iuart, &uartpins) != 0) bsp_panic(-15);
 8005844:	4620      	mov	r0, r4
	default:
		bsp_panic(-11);	// Something seriously wrong here!

	}
static u32 qqq;
	qqq = dma_channel_number_rx;
 8005846:	f8c2 9204 	str.w	r9, [r2, #516]	; 0x204
/* At this point we (should!) have a good DMA channel and stream that associates with the UART. */

	/* Set up UART pins, port & uart clockings.  THIS IS BOARD SPECIFIC */
	if (uart_pins(iuart, &uartpins) != 0) bsp_panic(-15);
 800584a:	a908      	add	r1, sp, #32
 800584c:	f000 fa68 	bl	8005d20 <uart_pins>
 8005850:	b118      	cbz	r0, 800585a <bsp_uart_dma_init+0x1a6>
 8005852:	f06f 000e 	mvn.w	r0, #14
 8005856:	f7ff fe35 	bl	80054c4 <bsp_panic>

	/* Setup baud rate */
	usartx_setbaud (iuart, uartpins.pclk, baud);
 800585a:	4620      	mov	r0, r4
 800585c:	9908      	ldr	r1, [sp, #32]
 800585e:	9a01      	ldr	r2, [sp, #4]
 8005860:	f000 fb26 	bl	8005eb0 <usartx_setbaud>

	/* Obtain some buffer space */
	getbuff(cb_Idx, rxbuffsize, txbuffsize);
 8005864:	4658      	mov	r0, fp
 8005866:	9902      	ldr	r1, [sp, #8]
 8005868:	9a03      	ldr	r2, [sp, #12]
 800586a:	f7ff fe89 	bl	8005580 <getbuff>

	/* ---------- Set up UART ----------------------------------------------------------------------------------- */

	/* Set up CR1 ---------------------------------------------------- */
	USART_CR1(iuart) |= (1<<13) | (1<<3) | (1<<2);// Set Usart enable, tx enable, rx enable
 800586e:	68e3      	ldr	r3, [r4, #12]
	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 8005870:	4934      	ldr	r1, [pc, #208]	; (8005944 <bsp_uart_dma_init+0x290>)
	getbuff(cb_Idx, rxbuffsize, txbuffsize);

	/* ---------- Set up UART ----------------------------------------------------------------------------------- */

	/* Set up CR1 ---------------------------------------------------- */
	USART_CR1(iuart) |= (1<<13) | (1<<3) | (1<<2);// Set Usart enable, tx enable, rx enable
 8005872:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8005876:	f043 030c 	orr.w	r3, r3, #12
 800587a:	60e3      	str	r3, [r4, #12]

	/* Hook up usart tx and rx to dma channels */
	USART_CR3(iuart) |= (1<<7) | (1<<6);
 800587c:	6963      	ldr	r3, [r4, #20]
 800587e:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8005882:	6163      	str	r3, [r4, #20]
	/* After reset CR2 is 0x0000 and this is just fine */

	/* --------- Set up the DMA channels ------------------------------------------------------------------------ */

	/* Set peripheral address for RX */
	DMA_SPAR(dma_x,dmastreamrx) = (u32*)(iuart + 0x04); // Address of uart DR register
 8005884:	2318      	movs	r3, #24
 8005886:	fb03 6707 	mla	r7, r3, r7, r6
	/* Set peripheral address for TX */
	DMA_SPAR(dma_x,dmastreamtx) = (u32*)(iuart + 0x04); // Address of uart DR register

	/* DMA stream configuration register--RX p 325 */
	//                                       Channel number     | MINC    | CIRC   | Per->Mem 
	DMA_SCR(dma_x,dmastreamrx) = ( (dma_channel_number_rx<< 25) | (1<<10) | (1<<8) | (0x0<<6) );   
 800588a:	ea4f 6949 	mov.w	r9, r9, lsl #25

	/* Set peripheral address for RX */
	DMA_SPAR(dma_x,dmastreamrx) = (u32*)(iuart + 0x04); // Address of uart DR register

	/* Set peripheral address for TX */
	DMA_SPAR(dma_x,dmastreamtx) = (u32*)(iuart + 0x04); // Address of uart DR register
 800588e:	fb03 660a 	mla	r6, r3, sl, r6
	/* After reset CR2 is 0x0000 and this is just fine */

	/* --------- Set up the DMA channels ------------------------------------------------------------------------ */

	/* Set peripheral address for RX */
	DMA_SPAR(dma_x,dmastreamrx) = (u32*)(iuart + 0x04); // Address of uart DR register
 8005892:	3404      	adds	r4, #4
	/* Set peripheral address for TX */
	DMA_SPAR(dma_x,dmastreamtx) = (u32*)(iuart + 0x04); // Address of uart DR register

	/* DMA stream configuration register--RX p 325 */
	//                                       Channel number     | MINC    | CIRC   | Per->Mem 
	DMA_SCR(dma_x,dmastreamrx) = ( (dma_channel_number_rx<< 25) | (1<<10) | (1<<8) | (0x0<<6) );   
 8005894:	f449 63a0 	orr.w	r3, r9, #1280	; 0x500

	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));
 8005898:	ea4f 6848 	mov.w	r8, r8, lsl #25
	/* After reset CR2 is 0x0000 and this is just fine */

	/* --------- Set up the DMA channels ------------------------------------------------------------------------ */

	/* Set peripheral address for RX */
	DMA_SPAR(dma_x,dmastreamrx) = (u32*)(iuart + 0x04); // Address of uart DR register
 800589c:	61bc      	str	r4, [r7, #24]

	/* Set peripheral address for TX */
	DMA_SPAR(dma_x,dmastreamtx) = (u32*)(iuart + 0x04); // Address of uart DR register
 800589e:	61b4      	str	r4, [r6, #24]

	/* DMA stream configuration register--RX p 325 */
	//                                       Channel number     | MINC    | CIRC   | Per->Mem 
	DMA_SCR(dma_x,dmastreamrx) = ( (dma_channel_number_rx<< 25) | (1<<10) | (1<<8) | (0x0<<6) );   
 80058a0:	613b      	str	r3, [r7, #16]

	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));
 80058a2:	f448 3382 	orr.w	r3, r8, #66560	; 0x10400
 80058a6:	f043 0340 	orr.w	r3, r3, #64	; 0x40

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 80058aa:	ea4f 1b8b 	mov.w	fp, fp, lsl #6
	//                                       Channel number     | MINC    | CIRC   | Per->Mem 
	DMA_SCR(dma_x,dmastreamrx) = ( (dma_channel_number_rx<< 25) | (1<<10) | (1<<8) | (0x0<<6) );   

	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));
 80058ae:	6133      	str	r3, [r6, #16]

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 80058b0:	eb01 030b 	add.w	r3, r1, fp

	/* Set the number of bytes in the RX buff */
	DMA_SNDTR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_size;

	/* DMA for TX interrupts */
	NVICIPR (dma_irq_number_tx.num,dma_tx_int_priority);	// Set dma interrupt priority (tx)
 80058b4:	2d00      	cmp	r5, #0
	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 80058b6:	6b1a      	ldr	r2, [r3, #48]	; 0x30

	/* Set the number of bytes in the RX buff */
	DMA_SNDTR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_size;
 80058b8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 80058ba:	61fa      	str	r2, [r7, #28]

	/* Set the number of bytes in the RX buff */
	DMA_SNDTR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_size;
 80058bc:	617b      	str	r3, [r7, #20]

	/* DMA for TX interrupts */
	NVICIPR (dma_irq_number_tx.num,dma_tx_int_priority);	// Set dma interrupt priority (tx)
 80058be:	4b25      	ldr	r3, [pc, #148]	; (8005954 <bsp_uart_dma_init+0x2a0>)
 80058c0:	462a      	mov	r2, r5
 80058c2:	bfb8      	it	lt
 80058c4:	1cea      	addlt	r2, r5, #3
 80058c6:	f022 0203 	bic.w	r2, r2, #3
 80058ca:	ea05 0303 	and.w	r3, r5, r3
 80058ce:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
 80058d2:	2b00      	cmp	r3, #0
 80058d4:	f502 4264 	add.w	r2, r2, #58368	; 0xe400
 80058d8:	da03      	bge.n	80058e2 <bsp_uart_dma_init+0x22e>
 80058da:	3b01      	subs	r3, #1
 80058dc:	f063 0303 	orn	r3, r3, #3
 80058e0:	3301      	adds	r3, #1
 80058e2:	9916      	ldr	r1, [sp, #88]	; 0x58
 80058e4:	00db      	lsls	r3, r3, #3
 80058e6:	fa11 f303 	lsls.w	r3, r1, r3
 80058ea:	6811      	ldr	r1, [r2, #0]
	NVICISER(dma_irq_number_tx.num);			// Enable dma interrupt (tx)
 80058ec:	2d00      	cmp	r5, #0

	/* Set the number of bytes in the RX buff */
	DMA_SNDTR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_size;

	/* DMA for TX interrupts */
	NVICIPR (dma_irq_number_tx.num,dma_tx_int_priority);	// Set dma interrupt priority (tx)
 80058ee:	ea41 0303 	orr.w	r3, r1, r3
 80058f2:	6013      	str	r3, [r2, #0]
	NVICISER(dma_irq_number_tx.num);			// Enable dma interrupt (tx)
 80058f4:	462b      	mov	r3, r5
 80058f6:	bfb8      	it	lt
 80058f8:	f105 031f 	addlt.w	r3, r5, #31
 80058fc:	115a      	asrs	r2, r3, #5
 80058fe:	4b16      	ldr	r3, [pc, #88]	; (8005958 <bsp_uart_dma_init+0x2a4>)
 8005900:	18d3      	adds	r3, r2, r3
 8005902:	009a      	lsls	r2, r3, #2
 8005904:	4b15      	ldr	r3, [pc, #84]	; (800595c <bsp_uart_dma_init+0x2a8>)
 8005906:	ea05 0303 	and.w	r3, r5, r3
 800590a:	2b00      	cmp	r3, #0
 800590c:	da03      	bge.n	8005916 <bsp_uart_dma_init+0x262>
 800590e:	3b01      	subs	r3, #1
 8005910:	f063 031f 	orn	r3, r3, #31
 8005914:	3301      	adds	r3, #1
 8005916:	2101      	movs	r1, #1
 8005918:	fa11 f303 	lsls.w	r3, r1, r3
 800591c:	6811      	ldr	r1, [r2, #0]
 800591e:	ea41 0303 	orr.w	r3, r1, r3
 8005922:	6013      	str	r3, [r2, #0]

	/* Final enabling of DMA */
	DMA_SCR(dma_x,dmastreamrx) |= (0x1);		// Enable rx stream
 8005924:	693b      	ldr	r3, [r7, #16]
 8005926:	f043 0301 	orr.w	r3, r3, #1
 800592a:	613b      	str	r3, [r7, #16]
	DMA_SCR(dma_x,dmastreamtx) |= ((1<<4));	// TCIE (xfer complete interrupt), not enable stream
 800592c:	6933      	ldr	r3, [r6, #16]
 800592e:	f043 0310 	orr.w	r3, r3, #16
 8005932:	6133      	str	r3, [r6, #16]

	return 0;	// SUCCESS!
}
 8005934:	2000      	movs	r0, #0
 8005936:	b00b      	add	sp, #44	; 0x2c
 8005938:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800593c:	20001764 	.word	0x20001764
 8005940:	08005495 	.word	0x08005495
 8005944:	20001760 	.word	0x20001760
 8005948:	40026000 	.word	0x40026000
 800594c:	40026400 	.word	0x40026400
 8005950:	2000015c 	.word	0x2000015c
 8005954:	80000003 	.word	0x80000003
 8005958:	38003840 	.word	0x38003840
 800595c:	8000001f 	.word	0x8000001f

08005960 <bsp_uart_dma_init_number>:
 * int bsp_uart_dma_init_number(u32 uartnumber, u32 baud,u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority);
 * @brief	: A wrapper for 'int bsp_uart_dma_init' with uart number (1-6) rather than uart base address as the first argument
 * @return	: Same as bsp_uart_dma_init
*******************************************************************************/
int bsp_uart_dma_init_number(u32 uartnumber, u32 baud,u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority)
{
 8005960:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005964:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8005968:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
 800596c:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 800596e:	460e      	mov	r6, r1
 8005970:	4615      	mov	r5, r2
 8005972:	461c      	mov	r4, r3
	u32 iuart = uartnumber_to_baseaddr(uartnumber);
 8005974:	f7ff fe30 	bl	80055d8 <uartnumber_to_baseaddr>
	return  bsp_uart_dma_init(iuart, baud, rxbuffsize, txbuffsize, dmastreamrx, dmastreamtx, dma_tx_int_priority);
 8005978:	4631      	mov	r1, r6
 800597a:	462a      	mov	r2, r5
 800597c:	4623      	mov	r3, r4
 800597e:	f8cd 9020 	str.w	r9, [sp, #32]
 8005982:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
 8005986:	970a      	str	r7, [sp, #40]	; 0x28
}
 8005988:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 * @return	: Same as bsp_uart_dma_init
*******************************************************************************/
int bsp_uart_dma_init_number(u32 uartnumber, u32 baud,u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority)
{
	u32 iuart = uartnumber_to_baseaddr(uartnumber);
	return  bsp_uart_dma_init(iuart, baud, rxbuffsize, txbuffsize, dmastreamrx, dmastreamtx, dma_tx_int_priority);
 800598c:	e692      	b.n	80056b4 <bsp_uart_dma_init>

0800598e <bsp_uart_getcount_ptr>:
*******************************************************************************/
int bsp_uart_getcount_ptr(struct CB_UART* pctl)
{
	int	Diff;

	if (pctl->flag == 1)
 800598e:	6902      	ldr	r2, [r0, #16]
 8005990:	2a01      	cmp	r2, #1
 * @brief	: Get the number of bytes buffered
 * @param	: pctl = pointer uart control block
 * @return	: number of chars in currently buffered.
*******************************************************************************/
int bsp_uart_getcount_ptr(struct CB_UART* pctl)
{
 8005992:	4603      	mov	r3, r0
	int	Diff;

	if (pctl->flag == 1)
 8005994:	d101      	bne.n	800599a <bsp_uart_getcount_ptr+0xc>
	{ // Here, interrupt driven uart
		Diff = (int)(pctl->rxbuff_in - pctl->rxbuff_out);
 8005996:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8005998:	e009      	b.n	80059ae <bsp_uart_getcount_ptr+0x20>
		if (Diff < 0)
			Diff += pctl->rxbuff_size;  // Adjust for wrap
		return Diff;
	}

	if (pctl->flag == 2)
 800599a:	2a02      	cmp	r2, #2
 800599c:	d10d      	bne.n	80059ba <bsp_uart_getcount_ptr+0x2c>
	{ // Here, DMA driven uart
		/* Difference between where we are taking out chars, and where DMA is/was storing */
		Diff = ( pctl->rxbuff_end - DMA_SNDTR(pctl->idma,pctl->rxdma_stream) - pctl->rxbuff_out );
 800599e:	6801      	ldr	r1, [r0, #0]
 80059a0:	6882      	ldr	r2, [r0, #8]
 80059a2:	2018      	movs	r0, #24
 80059a4:	4342      	muls	r2, r0
 80059a6:	3114      	adds	r1, #20
 80059a8:	6b18      	ldr	r0, [r3, #48]	; 0x30
 80059aa:	588a      	ldr	r2, [r1, r2]
 80059ac:	1a80      	subs	r0, r0, r2
 80059ae:	6bda      	ldr	r2, [r3, #60]	; 0x3c
		if (Diff < 0)
 80059b0:	1a80      	subs	r0, r0, r2
 80059b2:	d503      	bpl.n	80059bc <bsp_uart_getcount_ptr+0x2e>
			Diff += pctl->rxbuff_size;  // Adjust for wrap
 80059b4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80059b6:	18c0      	adds	r0, r0, r3
 80059b8:	4770      	bx	lr
		return Diff;
	}
	return 0;	// Something wrong if we got here.
 80059ba:	2000      	movs	r0, #0
}
 80059bc:	4770      	bx	lr

080059be <bsp_uart_getcount_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_getcount_uartnum(int uartnum)	// Select by uart number (1 - n)
{
	if ( ((uartnum - 1) < 0) || ((uartnum - 1) > 7) ) return 0;
 80059be:	3801      	subs	r0, #1
 80059c0:	2807      	cmp	r0, #7
 80059c2:	d803      	bhi.n	80059cc <bsp_uart_getcount_uartnum+0xe>
	return bsp_uart_getcount_ptr(&cb_uart[uartnum - 1]);
 80059c4:	4b02      	ldr	r3, [pc, #8]	; (80059d0 <bsp_uart_getcount_uartnum+0x12>)
 80059c6:	0180      	lsls	r0, r0, #6
 80059c8:	1818      	adds	r0, r3, r0
 80059ca:	e7e0      	b.n	800598e <bsp_uart_getcount_ptr>
}
 80059cc:	2000      	movs	r0, #0
 80059ce:	4770      	bx	lr
 80059d0:	20001764 	.word	0x20001764

080059d4 <bsp_uart_getc_ptr>:
 * @brief	: Get one char
 * @param	: pctl = pointer uart control block
 * @return	: char from buffer
*******************************************************************************/
char bsp_uart_getc_ptr(struct CB_UART* pctl)
{
 80059d4:	b538      	push	{r3, r4, r5, lr}
 80059d6:	4604      	mov	r4, r0
	char	c;
	u32 	i = 0;
 80059d8:	2500      	movs	r5, #0

	/* Hang waiting for incoming bytes if bozo caller didn't check char count. */
	while (( bsp_uart_getcount_ptr(pctl) == 0)  && (i++ < 50000) ) ;
 80059da:	4620      	mov	r0, r4
 80059dc:	f7ff ffd7 	bl	800598e <bsp_uart_getcount_ptr>
 80059e0:	b120      	cbz	r0, 80059ec <bsp_uart_getc_ptr+0x18>
	if (i >= 50000) panic_leds(-50);
 80059e2:	f24c 334f 	movw	r3, #49999	; 0xc34f
 80059e6:	429d      	cmp	r5, r3
 80059e8:	d909      	bls.n	80059fe <bsp_uart_getc_ptr+0x2a>
 80059ea:	e004      	b.n	80059f6 <bsp_uart_getc_ptr+0x22>
{
	char	c;
	u32 	i = 0;

	/* Hang waiting for incoming bytes if bozo caller didn't check char count. */
	while (( bsp_uart_getcount_ptr(pctl) == 0)  && (i++ < 50000) ) ;
 80059ec:	3501      	adds	r5, #1
 80059ee:	f24c 3351 	movw	r3, #50001	; 0xc351
 80059f2:	429d      	cmp	r5, r3
 80059f4:	d1f1      	bne.n	80059da <bsp_uart_getc_ptr+0x6>
	if (i >= 50000) panic_leds(-50);
 80059f6:	f06f 0031 	mvn.w	r0, #49	; 0x31
 80059fa:	f7ff f9e0 	bl	8004dbe <panic_leds>

	c = *pctl->rxbuff_out;
 80059fe:	6be1      	ldr	r1, [r4, #60]	; 0x3c
	pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
 8005a00:	4620      	mov	r0, r4

	/* Hang waiting for incoming bytes if bozo caller didn't check char count. */
	while (( bsp_uart_getcount_ptr(pctl) == 0)  && (i++ < 50000) ) ;
	if (i >= 50000) panic_leds(-50);

	c = *pctl->rxbuff_out;
 8005a02:	780d      	ldrb	r5, [r1, #0]
	pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
 8005a04:	f7ff fd0e 	bl	8005424 <rxbuff_adv>
 8005a08:	63e0      	str	r0, [r4, #60]	; 0x3c
	return c;
}
 8005a0a:	4628      	mov	r0, r5
 8005a0c:	bd38      	pop	{r3, r4, r5, pc}

08005a0e <bsp_uart_getc_uartnum>:
/* ---------------------------------------------------------------------------- */
char bsp_uart_getc_uartnum(int uartnum)	// Select by uart number (1 - n)
{
	if (((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 8005a0e:	3801      	subs	r0, #1
 8005a10:	2807      	cmp	r0, #7
 8005a12:	d803      	bhi.n	8005a1c <bsp_uart_getc_uartnum+0xe>
	return bsp_uart_getc_ptr(&cb_uart[uartnum - 1]);
 8005a14:	4b02      	ldr	r3, [pc, #8]	; (8005a20 <bsp_uart_getc_uartnum+0x12>)
 8005a16:	0180      	lsls	r0, r0, #6
 8005a18:	1818      	adds	r0, r3, r0
 8005a1a:	e7db      	b.n	80059d4 <bsp_uart_getc_ptr>
}
 8005a1c:	2000      	movs	r0, #0
 8005a1e:	4770      	bx	lr
 8005a20:	20001764 	.word	0x20001764

08005a24 <bsp_uart_getn_ptr>:
 * @param	: pchr = pointer to output char buffer
 * @param	: len = number of bytes requested
 * @return	: number of chars actually transferred
*******************************************************************************/
int bsp_uart_getn_ptr(struct CB_UART* pctl, char *pchr, int len)
{
 8005a24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005a26:	4604      	mov	r4, r0
 8005a28:	460d      	mov	r5, r1
 8005a2a:	4617      	mov	r7, r2
	int 	i;
	int 	ct;

	ct = bsp_uart_getcount_ptr(pctl);
 8005a2c:	f7ff ffaf 	bl	800598e <bsp_uart_getcount_ptr>
	if (ct == 0) return 0;
 8005a30:	4606      	mov	r6, r0
 8005a32:	b178      	cbz	r0, 8005a54 <bsp_uart_getn_ptr+0x30>
 8005a34:	42be      	cmp	r6, r7
 8005a36:	bfa8      	it	ge
 8005a38:	463e      	movge	r6, r7

	if (ct > len) ct = len; // Check fo more ready than requested

	for (i = 0; i < ct; i++)
 8005a3a:	2700      	movs	r7, #0
 8005a3c:	e008      	b.n	8005a50 <bsp_uart_getn_ptr+0x2c>
	{
		*pchr++ = *pctl->rxbuff_out;	// Copy from buffer to output
 8005a3e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005a40:	781b      	ldrb	r3, [r3, #0]
 8005a42:	55eb      	strb	r3, [r5, r7]
		pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
 8005a44:	4620      	mov	r0, r4
 8005a46:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8005a48:	f7ff fcec 	bl	8005424 <rxbuff_adv>
	ct = bsp_uart_getcount_ptr(pctl);
	if (ct == 0) return 0;

	if (ct > len) ct = len; // Check fo more ready than requested

	for (i = 0; i < ct; i++)
 8005a4c:	3701      	adds	r7, #1
	{
		*pchr++ = *pctl->rxbuff_out;	// Copy from buffer to output
		pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
 8005a4e:	63e0      	str	r0, [r4, #60]	; 0x3c
	ct = bsp_uart_getcount_ptr(pctl);
	if (ct == 0) return 0;

	if (ct > len) ct = len; // Check fo more ready than requested

	for (i = 0; i < ct; i++)
 8005a50:	42b7      	cmp	r7, r6
 8005a52:	dbf4      	blt.n	8005a3e <bsp_uart_getn_ptr+0x1a>
	{
		*pchr++ = *pctl->rxbuff_out;	// Copy from buffer to output
		pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
	}
	return ct; // Return number transfered.
}
 8005a54:	4630      	mov	r0, r6
 8005a56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005a58 <bsp_uart_getn_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_getn_uartnum(int uartnum, char *pchr, int len)	// Select by uart number (1 - n)
{
	if ( ((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 8005a58:	3801      	subs	r0, #1
 8005a5a:	2807      	cmp	r0, #7
 8005a5c:	d803      	bhi.n	8005a66 <bsp_uart_getn_uartnum+0xe>
	return bsp_uart_getn_ptr(&cb_uart[uartnum - 1],  pchr, len);
 8005a5e:	4b03      	ldr	r3, [pc, #12]	; (8005a6c <bsp_uart_getn_uartnum+0x14>)
 8005a60:	0180      	lsls	r0, r0, #6
 8005a62:	1818      	adds	r0, r3, r0
 8005a64:	e7de      	b.n	8005a24 <bsp_uart_getn_ptr>
}
 8005a66:	2000      	movs	r0, #0
 8005a68:	4770      	bx	lr
 8005a6a:	bf00      	nop
 8005a6c:	20001764 	.word	0x20001764

08005a70 <bsp_uart_start_dma>:
 * @param	: pctl: control block poiner
 * @return	:
*******************************************************************************/
void bsp_uart_start_dma(struct CB_UART* pctl)
{
	if (pctl->flag != 2) return;	// Return, not DMA driven
 8005a70:	6902      	ldr	r2, [r0, #16]
 8005a72:	2a02      	cmp	r2, #2
 * @brief	: If DMA driven uart, start DMA sending if not already sending
 * @param	: pctl: control block poiner
 * @return	:
*******************************************************************************/
void bsp_uart_start_dma(struct CB_UART* pctl)
{
 8005a74:	b510      	push	{r4, lr}
	if (pctl->flag != 2) return;	// Return, not DMA driven
 8005a76:	d10f      	bne.n	8005a98 <bsp_uart_start_dma+0x28>
	
	/* Are we already running? */
	// First look at the enable bit
	if ((DMA_SCR(pctl->idma, pctl->txdma_stream) & 0x1) != 0) return;	// Already running
 8005a78:	6801      	ldr	r1, [r0, #0]
 8005a7a:	68c2      	ldr	r2, [r0, #12]
 8005a7c:	2418      	movs	r4, #24
 8005a7e:	4362      	muls	r2, r4
 8005a80:	3110      	adds	r1, #16
 8005a82:	5889      	ldr	r1, [r1, r2]
 8005a84:	f011 0f01 	tst.w	r1, #1
 8005a88:	d106      	bne.n	8005a98 <bsp_uart_start_dma+0x28>


	// Check if the counter has gone to zero
	if ( DMA_SNDTR(pctl->idma,pctl->txdma_stream) != 0) return;
 8005a8a:	6803      	ldr	r3, [r0, #0]
 8005a8c:	3314      	adds	r3, #20
 8005a8e:	589b      	ldr	r3, [r3, r2]
 8005a90:	b913      	cbnz	r3, 8005a98 <bsp_uart_start_dma+0x28>
	
	/* Not running.  If there are any to send, set up the DMA. */
	common_dma(pctl);

	return;
}
 8005a92:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

	// Check if the counter has gone to zero
	if ( DMA_SNDTR(pctl->idma,pctl->txdma_stream) != 0) return;
	
	/* Not running.  If there are any to send, set up the DMA. */
	common_dma(pctl);
 8005a96:	e4d3      	b.n	8005440 <common_dma>
 8005a98:	bd10      	pop	{r4, pc}

08005a9a <bsp_uart_send_int>:
 * @param	: pctl = pointer uart control block
 * @return	: 
*******************************************************************************/
void bsp_uart_send_int(struct CB_UART* pctl)
{
	if (pctl->flag != 1) return;	// Return not interrupt drive & initialized
 8005a9a:	6903      	ldr	r3, [r0, #16]
 8005a9c:	2b01      	cmp	r3, #1
 8005a9e:	d109      	bne.n	8005ab4 <bsp_uart_send_int+0x1a>

	if ((USART_CR1(pctl->iuart) & USART_CR1_TXEIE) != 0) // Already enabled?
 8005aa0:	6843      	ldr	r3, [r0, #4]
 8005aa2:	68db      	ldr	r3, [r3, #12]
 8005aa4:	f013 0f80 	tst.w	r3, #128	; 0x80
 8005aa8:	d104      	bne.n	8005ab4 <bsp_uart_send_int+0x1a>
		return;

	USART_CR1(pctl->iuart) |= USART_CR1_TXEIE ;	// Enable interrupt
 8005aaa:	6843      	ldr	r3, [r0, #4]
 8005aac:	68da      	ldr	r2, [r3, #12]
 8005aae:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8005ab2:	60da      	str	r2, [r3, #12]
 8005ab4:	4770      	bx	lr

08005ab6 <bsp_uart_putc_ptr>:
 * @param	: Char to be sent
 * @return	: 1 = one char add; 0 = no chars added; -1 = pctl was null
 * NOTE: this does not start an idle DMA, but starts an idle interrupt driven uart
*******************************************************************************/
int bsp_uart_putc_ptr(struct CB_UART* pctl, char c) // Select by control block ptr
{
 8005ab6:	b570      	push	{r4, r5, r6, lr}
 8005ab8:	460e      	mov	r6, r1
	u8* p;

	if (pctl == 0) return -1;
 8005aba:	4604      	mov	r4, r0
 8005abc:	b180      	cbz	r0, 8005ae0 <bsp_uart_putc_ptr+0x2a>

	/* Check if buffer filled.  Return zero if full. */
	p = txbuff_adv(pctl, pctl->txbuff_in); 	// Advance input pointer (circularly)
 8005abe:	6a05      	ldr	r5, [r0, #32]
 8005ac0:	4629      	mov	r1, r5
 8005ac2:	f7ff fcb6 	bl	8005432 <txbuff_adv>
	if (p == pctl->txbuff_out)  return 0; 	// Return zero, rather than overwrite buffer
 8005ac6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005ac8:	4298      	cmp	r0, r3
 8005aca:	d00c      	beq.n	8005ae6 <bsp_uart_putc_ptr+0x30>

	*pctl->txbuff_in = (u8)c;		// Store char
 8005acc:	702e      	strb	r6, [r5, #0]

	/* Update the input buffer pointer to the next position. */
	pctl->txbuff_in = p;
 8005ace:	6220      	str	r0, [r4, #32]

	/* Start sending if non-dma */
	bsp_uart_send_int(pctl);
 8005ad0:	4620      	mov	r0, r4
 8005ad2:	f7ff ffe2 	bl	8005a9a <bsp_uart_send_int>

	/* Start sending: if dma and not idle. */
	bsp_uart_start_dma(pctl); 
 8005ad6:	4620      	mov	r0, r4
 8005ad8:	f7ff ffca 	bl	8005a70 <bsp_uart_start_dma>

 	return 1; // Return byte count stored.
 8005adc:	2001      	movs	r0, #1
 8005ade:	bd70      	pop	{r4, r5, r6, pc}
*******************************************************************************/
int bsp_uart_putc_ptr(struct CB_UART* pctl, char c) // Select by control block ptr
{
	u8* p;

	if (pctl == 0) return -1;
 8005ae0:	f04f 30ff 	mov.w	r0, #4294967295
 8005ae4:	bd70      	pop	{r4, r5, r6, pc}

	/* Check if buffer filled.  Return zero if full. */
	p = txbuff_adv(pctl, pctl->txbuff_in); 	// Advance input pointer (circularly)
	if (p == pctl->txbuff_out)  return 0; 	// Return zero, rather than overwrite buffer
 8005ae6:	2000      	movs	r0, #0

	/* Start sending: if dma and not idle. */
	bsp_uart_start_dma(pctl); 

 	return 1; // Return byte count stored.
}
 8005ae8:	bd70      	pop	{r4, r5, r6, pc}

08005aea <bsp_uart_putc_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_putc_uartnum(int uartnum, char c)	// Select by uart number (1 - n)
{
	if (((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 8005aea:	3801      	subs	r0, #1
 8005aec:	2807      	cmp	r0, #7
 8005aee:	d803      	bhi.n	8005af8 <bsp_uart_putc_uartnum+0xe>
	return bsp_uart_putc_ptr(&cb_uart[uartnum - 1], c);
 8005af0:	4b02      	ldr	r3, [pc, #8]	; (8005afc <bsp_uart_putc_uartnum+0x12>)
 8005af2:	0180      	lsls	r0, r0, #6
 8005af4:	1818      	adds	r0, r3, r0
 8005af6:	e7de      	b.n	8005ab6 <bsp_uart_putc_ptr>
}
 8005af8:	2000      	movs	r0, #0
 8005afa:	4770      	bx	lr
 8005afc:	20001764 	.word	0x20001764

08005b00 <bsp_uart_puts_ptr>:
 * @param	: p = pointer to buffer with bytes to be added
 * @return	: count of bytes added to buffer
 * NOTE: this starts either DMA or interrupt driven 
*******************************************************************************/
int bsp_uart_puts_ptr(struct CB_UART* pctl, char* p) // Select: control blk ptr
{
 8005b00:	b570      	push	{r4, r5, r6, lr}
 8005b02:	460d      	mov	r5, r1
	u32 ct = 0;
	int ret;

	if (pctl == 0) return -1;	// Pointer not set
 8005b04:	4606      	mov	r6, r0
 8005b06:	b168      	cbz	r0, 8005b24 <bsp_uart_puts_ptr+0x24>
 8005b08:	2400      	movs	r4, #0
 8005b0a:	e006      	b.n	8005b1a <bsp_uart_puts_ptr+0x1a>
	
	while (*p != 0)
	{
		ret = bsp_uart_putc_ptr(pctl, *p);	// Put char
 8005b0c:	4630      	mov	r0, r6
 8005b0e:	f7ff ffd2 	bl	8005ab6 <bsp_uart_putc_ptr>
		if (ret > 0)
 8005b12:	2800      	cmp	r0, #0
		{ // Here, one byte was stored in buffer
			ct += ret;	// Add to count loaded
 8005b14:	bfc4      	itt	gt
 8005b16:	1824      	addgt	r4, r4, r0
			p++;
 8005b18:	3501      	addgt	r5, #1
	u32 ct = 0;
	int ret;

	if (pctl == 0) return -1;	// Pointer not set
	
	while (*p != 0)
 8005b1a:	7829      	ldrb	r1, [r5, #0]
 8005b1c:	2900      	cmp	r1, #0
 8005b1e:	d1f5      	bne.n	8005b0c <bsp_uart_puts_ptr+0xc>
			ct += ret;	// Add to count loaded
			p++;
		} // Note: loop hangs when buffer is full
	}

	return ct;
 8005b20:	4620      	mov	r0, r4
 8005b22:	bd70      	pop	{r4, r5, r6, pc}
int bsp_uart_puts_ptr(struct CB_UART* pctl, char* p) // Select: control blk ptr
{
	u32 ct = 0;
	int ret;

	if (pctl == 0) return -1;	// Pointer not set
 8005b24:	f04f 30ff 	mov.w	r0, #4294967295
			p++;
		} // Note: loop hangs when buffer is full
	}

	return ct;
}
 8005b28:	bd70      	pop	{r4, r5, r6, pc}

08005b2a <bsp_uart_puts_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_puts_uartnum(int uartnum,char* p)	// Select by uart number (1 - n)
{
	if (((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 8005b2a:	3801      	subs	r0, #1
 8005b2c:	2807      	cmp	r0, #7
 8005b2e:	d803      	bhi.n	8005b38 <bsp_uart_puts_uartnum+0xe>
	return bsp_uart_puts_ptr(&cb_uart[uartnum - 1], p);
 8005b30:	4b02      	ldr	r3, [pc, #8]	; (8005b3c <bsp_uart_puts_uartnum+0x12>)
 8005b32:	0180      	lsls	r0, r0, #6
 8005b34:	1818      	adds	r0, r3, r0
 8005b36:	e7e3      	b.n	8005b00 <bsp_uart_puts_ptr>
}
 8005b38:	2000      	movs	r0, #0
 8005b3a:	4770      	bx	lr
 8005b3c:	20001764 	.word	0x20001764

08005b40 <bsp_uart_putn_ptr>:
 * @param	: count = number of bytes to be added
 * @return	: count of bytes added to buffer
 * NOTE: this starts either DMA or interrupt driven 
*******************************************************************************/
int bsp_uart_putn_ptr(struct CB_UART* pctl, char* p, int len ) // Select: control blk ptr
{
 8005b40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005b42:	460c      	mov	r4, r1
 8005b44:	4616      	mov	r6, r2
	u32 ct = len;
	int ret;
/* 'ct' and 'len' separate in case we decide to change it to return when the ct loaded is not equal len. */
	if (pctl == 0) return -1;	// Pointer not set
 8005b46:	4607      	mov	r7, r0
 8005b48:	b170      	cbz	r0, 8005b68 <bsp_uart_putn_ptr+0x28>
 8005b4a:	4615      	mov	r5, r2
 8005b4c:	e008      	b.n	8005b60 <bsp_uart_putn_ptr+0x20>
	
	while (len > 0)
	{
		while ((ret = bsp_uart_putc_ptr(pctl, *p)) == 0) ; // Loop if full 
 8005b4e:	4638      	mov	r0, r7
 8005b50:	7821      	ldrb	r1, [r4, #0]
 8005b52:	f7ff ffb0 	bl	8005ab6 <bsp_uart_putc_ptr>
 8005b56:	2800      	cmp	r0, #0
 8005b58:	d0f9      	beq.n	8005b4e <bsp_uart_putn_ptr+0xe>
		if (ret < 0 ) return ret; // Error.
 8005b5a:	db07      	blt.n	8005b6c <bsp_uart_putn_ptr+0x2c>
		p++;		// 
 8005b5c:	3401      	adds	r4, #1
		len -= 1;	// Decrement input count
 8005b5e:	3d01      	subs	r5, #1
	u32 ct = len;
	int ret;
/* 'ct' and 'len' separate in case we decide to change it to return when the ct loaded is not equal len. */
	if (pctl == 0) return -1;	// Pointer not set
	
	while (len > 0)
 8005b60:	2d00      	cmp	r5, #0
 8005b62:	dcf4      	bgt.n	8005b4e <bsp_uart_putn_ptr+0xe>
		while ((ret = bsp_uart_putc_ptr(pctl, *p)) == 0) ; // Loop if full 
		if (ret < 0 ) return ret; // Error.
		p++;		// 
		len -= 1;	// Decrement input count
	}
	return (ct - len);	// Return count added to buffer
 8005b64:	1b70      	subs	r0, r6, r5
 8005b66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
int bsp_uart_putn_ptr(struct CB_UART* pctl, char* p, int len ) // Select: control blk ptr
{
	u32 ct = len;
	int ret;
/* 'ct' and 'len' separate in case we decide to change it to return when the ct loaded is not equal len. */
	if (pctl == 0) return -1;	// Pointer not set
 8005b68:	f04f 30ff 	mov.w	r0, #4294967295
		if (ret < 0 ) return ret; // Error.
		p++;		// 
		len -= 1;	// Decrement input count
	}
	return (ct - len);	// Return count added to buffer
}
 8005b6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005b6e <bsp_uart_putn_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_putn_uartnum(int uartnum, char* p, int len )	// Select by uart number (1 - n)
{
	if (((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 8005b6e:	3801      	subs	r0, #1
 8005b70:	2807      	cmp	r0, #7
 8005b72:	d803      	bhi.n	8005b7c <bsp_uart_putn_uartnum+0xe>
	return bsp_uart_putn_ptr(&cb_uart[uartnum - 1], p, len);
 8005b74:	4b02      	ldr	r3, [pc, #8]	; (8005b80 <bsp_uart_putn_uartnum+0x12>)
 8005b76:	0180      	lsls	r0, r0, #6
 8005b78:	1818      	adds	r0, r3, r0
 8005b7a:	e7e1      	b.n	8005b40 <bsp_uart_putn_ptr>
}
 8005b7c:	2000      	movs	r0, #0
 8005b7e:	4770      	bx	lr
 8005b80:	20001764 	.word	0x20001764

08005b84 <bsp_uart_int_init>:
 * @param	: uart_int_priority: interrupt priority, (0x00 - 0xf0) e.g. 0xc0, low 4 bits zero
 * @return	: 0 = success; fail traps to 'panic_leds'
*******************************************************************************/

int bsp_uart_int_init(u32 iuart, u32 baud, u32 rxbuffsize, u32 txbuffsize,  u32 uart_int_priority)
{
 8005b84:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8005b88:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
	u32 cb_Idx;
	struct UARTPINS uartpins;

	if ((uart_int_priority & 0xf) != 0) bsp_panic(-3); // Bogus priority
 8005b8c:	f018 0f0f 	tst.w	r8, #15
 * @param	: uart_int_priority: interrupt priority, (0x00 - 0xf0) e.g. 0xc0, low 4 bits zero
 * @return	: 0 = success; fail traps to 'panic_leds'
*******************************************************************************/

int bsp_uart_int_init(u32 iuart, u32 baud, u32 rxbuffsize, u32 txbuffsize,  u32 uart_int_priority)
{
 8005b90:	4604      	mov	r4, r0
 8005b92:	460e      	mov	r6, r1
 8005b94:	4615      	mov	r5, r2
 8005b96:	4699      	mov	r9, r3
	u32 cb_Idx;
	struct UARTPINS uartpins;

	if ((uart_int_priority & 0xf) != 0) bsp_panic(-3); // Bogus priority
 8005b98:	d003      	beq.n	8005ba2 <bsp_uart_int_init+0x1e>
 8005b9a:	f06f 0002 	mvn.w	r0, #2
 8005b9e:	f7ff fc91 	bl	80054c4 <bsp_panic>
	
	/* Map usart/uart register base to control block index & and enable APBxENR for USART/UART */
	cb_Idx = mapindex(iuart);	
 8005ba2:	4620      	mov	r0, r4
 8005ba4:	f7ff fc96 	bl	80054d4 <mapindex>
		
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
 8005ba8:	4b23      	ldr	r3, [pc, #140]	; (8005c38 <bsp_uart_int_init+0xb4>)
 8005baa:	0182      	lsls	r2, r0, #6
 8005bac:	1899      	adds	r1, r3, r2
	struct UARTPINS uartpins;

	if ((uart_int_priority & 0xf) != 0) bsp_panic(-3); // Bogus priority
	
	/* Map usart/uart register base to control block index & and enable APBxENR for USART/UART */
	cb_Idx = mapindex(iuart);	
 8005bae:	4607      	mov	r7, r0
		
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
	cb_uart[cb_Idx].flag = 1;	// Show this setup for interrupt driven
 8005bb0:	2001      	movs	r0, #1
 8005bb2:	6148      	str	r0, [r1, #20]
	if ((uart_int_priority & 0xf) != 0) bsp_panic(-3); // Bogus priority
	
	/* Map usart/uart register base to control block index & and enable APBxENR for USART/UART */
	cb_Idx = mapindex(iuart);	
		
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
 8005bb4:	608c      	str	r4, [r1, #8]
	cb_uart[cb_Idx].flag = 1;	// Show this setup for interrupt driven

	/* Mapping adjusted file number to a control block pointer */
	cb_map[cb_Idx] = &cb_uart[cb_Idx];
 8005bb6:	eb03 0187 	add.w	r1, r3, r7, lsl #2
 8005bba:	3304      	adds	r3, #4
 8005bbc:	189a      	adds	r2, r3, r2
 8005bbe:	f8c1 2208 	str.w	r2, [r1, #520]	; 0x208

	/* Set up UART pins, port & uart clockings.  THIS IS BOARD SPECIFIC */
	if (uart_pins(iuart, &uartpins) != 0) bsp_panic(-15);
 8005bc2:	4620      	mov	r0, r4
 8005bc4:	4669      	mov	r1, sp
 8005bc6:	f000 f8ab 	bl	8005d20 <uart_pins>
 8005bca:	b118      	cbz	r0, 8005bd4 <bsp_uart_int_init+0x50>
 8005bcc:	f06f 000e 	mvn.w	r0, #14
 8005bd0:	f7ff fc78 	bl	80054c4 <bsp_panic>

	/* Setup baud rate */
	usartx_setbaud (iuart, uartpins.pclk, baud);
 8005bd4:	4620      	mov	r0, r4
 8005bd6:	9900      	ldr	r1, [sp, #0]
 8005bd8:	4632      	mov	r2, r6
 8005bda:	f000 f969 	bl	8005eb0 <usartx_setbaud>

	/* Obtain some buffer space */
	getbuff(cb_Idx, rxbuffsize, txbuffsize);
 8005bde:	4629      	mov	r1, r5
 8005be0:	464a      	mov	r2, r9
 8005be2:	4638      	mov	r0, r7
 8005be4:	f7ff fccc 	bl	8005580 <getbuff>
	/* Setup CR2 ------------------------------------------------------------------- */
	/* After reset CR2 is 0x0000 and this is just fine */

	/* Set up CR1 ---------------------------------------------------- */
	//                    UE       RXNEIE    TE       RE
	USART_CR1(iuart) |= (1<<13) | (1<<5) | (1<<3) | (1<<2);
 8005be8:	68e3      	ldr	r3, [r4, #12]
 8005bea:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8005bee:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
 8005bf2:	60e3      	str	r3, [r4, #12]

	/* UART interrupt */
	NVICIPR (uartpins.irqnumber, uart_int_priority);	// Set uart interrupt priority (tx)
 8005bf4:	9a01      	ldr	r2, [sp, #4]
 8005bf6:	f022 0303 	bic.w	r3, r2, #3
 8005bfa:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8005bfe:	f503 4364 	add.w	r3, r3, #58368	; 0xe400
 8005c02:	f002 0203 	and.w	r2, r2, #3
 8005c06:	00d2      	lsls	r2, r2, #3
 8005c08:	fa08 f802 	lsl.w	r8, r8, r2
 8005c0c:	681a      	ldr	r2, [r3, #0]
 8005c0e:	ea42 0208 	orr.w	r2, r2, r8
 8005c12:	601a      	str	r2, [r3, #0]
	NVICISER(uartpins.irqnumber);				// Enable interrupt
 8005c14:	9a01      	ldr	r2, [sp, #4]
 8005c16:	4b09      	ldr	r3, [pc, #36]	; (8005c3c <bsp_uart_int_init+0xb8>)
 8005c18:	0951      	lsrs	r1, r2, #5
 8005c1a:	18cb      	adds	r3, r1, r3
 8005c1c:	009b      	lsls	r3, r3, #2
 8005c1e:	2101      	movs	r1, #1
 8005c20:	f002 021f 	and.w	r2, r2, #31
 8005c24:	fa11 f202 	lsls.w	r2, r1, r2
 8005c28:	6819      	ldr	r1, [r3, #0]
 8005c2a:	ea41 0202 	orr.w	r2, r1, r2
 8005c2e:	601a      	str	r2, [r3, #0]
	
	return 0;
}
 8005c30:	2000      	movs	r0, #0
 8005c32:	e8bd 83fe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, pc}
 8005c36:	bf00      	nop
 8005c38:	20001760 	.word	0x20001760
 8005c3c:	38003840 	.word	0x38003840

08005c40 <bsp_uart_int_init_number>:
 * int bsp_uart_int_init_number(u32 uartnumber, u32 baud,u32 rxbuffsize, u32 txbuffsize, u32 dma_tx_int_priority);
 * @brief	: A wrapper for 'int bsp_uart_int_init' with uart number (1-6) rather than uart base address as the first argument
 * @return	: Same as bsp_uart_int_init
*******************************************************************************/
int bsp_uart_int_init_number(u32 uartnumber, u32 baud, u32 rxbuffsize, u32 txbuffsize,  u32 uart_int_priority)
{
 8005c40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005c44:	9f06      	ldr	r7, [sp, #24]
 8005c46:	460e      	mov	r6, r1
 8005c48:	4615      	mov	r5, r2
 8005c4a:	461c      	mov	r4, r3
	u32 iuart = uartnumber_to_baseaddr(uartnumber);
 8005c4c:	f7ff fcc4 	bl	80055d8 <uartnumber_to_baseaddr>
	return  bsp_uart_int_init(iuart, baud, rxbuffsize, txbuffsize, uart_int_priority);
 8005c50:	4631      	mov	r1, r6
 8005c52:	462a      	mov	r2, r5
 8005c54:	4623      	mov	r3, r4
 8005c56:	9706      	str	r7, [sp, #24]
}
 8005c58:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 * @return	: Same as bsp_uart_int_init
*******************************************************************************/
int bsp_uart_int_init_number(u32 uartnumber, u32 baud, u32 rxbuffsize, u32 txbuffsize,  u32 uart_int_priority)
{
	u32 iuart = uartnumber_to_baseaddr(uartnumber);
	return  bsp_uart_int_init(iuart, baud, rxbuffsize, txbuffsize, uart_int_priority);
 8005c5c:	e792      	b.n	8005b84 <bsp_uart_int_init>

08005c5e <UART_IRQHandler>:
void  UART8_IRQHandler(void) {UART_IRQHandler(&cb_uart[7]); return;}

void UART_IRQHandler(struct CB_UART* pctl)
{
	/* Receive */
	if ((USART_SR(pctl->iuart) & USART_SR_RXNE) != 0) // Receive reg loaded?
 8005c5e:	6843      	ldr	r3, [r0, #4]
 8005c60:	681b      	ldr	r3, [r3, #0]
 8005c62:	f013 0f20 	tst.w	r3, #32
void USART6_IRQHandler(void) {UART_IRQHandler(&cb_uart[5]); return;}
void  UART7_IRQHandler(void) {UART_IRQHandler(&cb_uart[6]); return;}
void  UART8_IRQHandler(void) {UART_IRQHandler(&cb_uart[7]); return;}

void UART_IRQHandler(struct CB_UART* pctl)
{
 8005c66:	b510      	push	{r4, lr}
 8005c68:	4604      	mov	r4, r0
	/* Receive */
	if ((USART_SR(pctl->iuart) & USART_SR_RXNE) != 0) // Receive reg loaded?
 8005c6a:	d007      	beq.n	8005c7c <UART_IRQHandler+0x1e>
	{  // Here, receive interrupt flag is on. 
		*pctl->rxbuff_in = USART_DR(pctl->iuart);// Read and store char
 8005c6c:	6843      	ldr	r3, [r0, #4]
 8005c6e:	685a      	ldr	r2, [r3, #4]
 8005c70:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8005c72:	701a      	strb	r2, [r3, #0]

		/* Advance pointers to line buffers and array of counts and reset when end reached */	
		pctl->rxbuff_in = rxbuff_adv(pctl, pctl->rxbuff_in);	// Advance pointers common routine
 8005c74:	6b81      	ldr	r1, [r0, #56]	; 0x38
 8005c76:	f7ff fbd5 	bl	8005424 <rxbuff_adv>
 8005c7a:	63a0      	str	r0, [r4, #56]	; 0x38
	}

	/* Transmit */
	if ( (USART_CR1(pctl->iuart) & USART_CR1_TXEIE) != 0)
 8005c7c:	6863      	ldr	r3, [r4, #4]
 8005c7e:	68db      	ldr	r3, [r3, #12]
 8005c80:	f013 0f80 	tst.w	r3, #128	; 0x80
 8005c84:	d014      	beq.n	8005cb0 <UART_IRQHandler+0x52>
	{  // Here, yes.  Transmit interrupts are enabled so check if a tx interrupt
		if ( (USART_SR(pctl->iuart) & USART_SR_TXE) != 0) // Transmit register empty?
 8005c86:	6863      	ldr	r3, [r4, #4]
 8005c88:	681b      	ldr	r3, [r3, #0]
 8005c8a:	f013 0f80 	tst.w	r3, #128	; 0x80
 8005c8e:	d00f      	beq.n	8005cb0 <UART_IRQHandler+0x52>
		{ // Here, yes.
			USART_DR(pctl->iuart) = *pctl->txbuff_out;// Send next char, step pointer
 8005c90:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8005c92:	6863      	ldr	r3, [r4, #4]
 8005c94:	780a      	ldrb	r2, [r1, #0]

			/* Advance output pointer */
			pctl->txbuff_out = txbuff_adv(pctl, pctl->txbuff_out);
 8005c96:	4620      	mov	r0, r4
	/* Transmit */
	if ( (USART_CR1(pctl->iuart) & USART_CR1_TXEIE) != 0)
	{  // Here, yes.  Transmit interrupts are enabled so check if a tx interrupt
		if ( (USART_SR(pctl->iuart) & USART_SR_TXE) != 0) // Transmit register empty?
		{ // Here, yes.
			USART_DR(pctl->iuart) = *pctl->txbuff_out;// Send next char, step pointer
 8005c98:	605a      	str	r2, [r3, #4]

			/* Advance output pointer */
			pctl->txbuff_out = txbuff_adv(pctl, pctl->txbuff_out);
 8005c9a:	f7ff fbca 	bl	8005432 <txbuff_adv>

			/* Was the last byte loaded the last to send? */		
			if (pctl->txbuff_out == pctl->txbuff_in)
 8005c9e:	6a23      	ldr	r3, [r4, #32]
		if ( (USART_SR(pctl->iuart) & USART_SR_TXE) != 0) // Transmit register empty?
		{ // Here, yes.
			USART_DR(pctl->iuart) = *pctl->txbuff_out;// Send next char, step pointer

			/* Advance output pointer */
			pctl->txbuff_out = txbuff_adv(pctl, pctl->txbuff_out);
 8005ca0:	6260      	str	r0, [r4, #36]	; 0x24

			/* Was the last byte loaded the last to send? */		
			if (pctl->txbuff_out == pctl->txbuff_in)
 8005ca2:	4298      	cmp	r0, r3
 8005ca4:	d104      	bne.n	8005cb0 <UART_IRQHandler+0x52>
			{ // Here yes. 
				USART_CR1(pctl->iuart) &= ~USART_CR1_TXEIE;		// Disable Tx interrupt	
 8005ca6:	6863      	ldr	r3, [r4, #4]
 8005ca8:	68da      	ldr	r2, [r3, #12]
 8005caa:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8005cae:	60da      	str	r2, [r3, #12]
 8005cb0:	bd10      	pop	{r4, pc}

08005cb2 <UART8_IRQHandler>:
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
void  UART5_IRQHandler(void) {UART_IRQHandler(&cb_uart[4]); return;}
void USART6_IRQHandler(void) {UART_IRQHandler(&cb_uart[5]); return;}
void  UART7_IRQHandler(void) {UART_IRQHandler(&cb_uart[6]); return;}
void  UART8_IRQHandler(void) {UART_IRQHandler(&cb_uart[7]); return;}
 8005cb2:	4801      	ldr	r0, [pc, #4]	; (8005cb8 <UART8_IRQHandler+0x6>)
 8005cb4:	e7d3      	b.n	8005c5e <UART_IRQHandler>
 8005cb6:	bf00      	nop
 8005cb8:	20001924 	.word	0x20001924

08005cbc <UART7_IRQHandler>:
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
void  UART5_IRQHandler(void) {UART_IRQHandler(&cb_uart[4]); return;}
void USART6_IRQHandler(void) {UART_IRQHandler(&cb_uart[5]); return;}
void  UART7_IRQHandler(void) {UART_IRQHandler(&cb_uart[6]); return;}
 8005cbc:	4800      	ldr	r0, [pc, #0]	; (8005cc0 <UART7_IRQHandler+0x4>)
 8005cbe:	e7ce      	b.n	8005c5e <UART_IRQHandler>
 8005cc0:	200018e4 	.word	0x200018e4

08005cc4 <USART6_IRQHandler>:
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
void  UART5_IRQHandler(void) {UART_IRQHandler(&cb_uart[4]); return;}
void USART6_IRQHandler(void) {UART_IRQHandler(&cb_uart[5]); return;}
 8005cc4:	4800      	ldr	r0, [pc, #0]	; (8005cc8 <USART6_IRQHandler+0x4>)
 8005cc6:	e7ca      	b.n	8005c5e <UART_IRQHandler>
 8005cc8:	200018a4 	.word	0x200018a4

08005ccc <UART5_IRQHandler>:
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
void  UART5_IRQHandler(void) {UART_IRQHandler(&cb_uart[4]); return;}
 8005ccc:	4800      	ldr	r0, [pc, #0]	; (8005cd0 <UART5_IRQHandler+0x4>)
 8005cce:	e7c6      	b.n	8005c5e <UART_IRQHandler>
 8005cd0:	20001864 	.word	0x20001864

08005cd4 <UART4_IRQHandler>:
/* USART/UART interrupts use a common IRQ handler.  Pass the control block pointer. */
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
 8005cd4:	4800      	ldr	r0, [pc, #0]	; (8005cd8 <UART4_IRQHandler+0x4>)
 8005cd6:	e7c2      	b.n	8005c5e <UART_IRQHandler>
 8005cd8:	20001824 	.word	0x20001824

08005cdc <USART3_IRQHandler>:
 *####################################################################################### */
/* USART/UART interrupts use a common IRQ handler.  Pass the control block pointer. */
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
 8005cdc:	4800      	ldr	r0, [pc, #0]	; (8005ce0 <USART3_IRQHandler+0x4>)
 8005cde:	e7be      	b.n	8005c5e <UART_IRQHandler>
 8005ce0:	200017e4 	.word	0x200017e4

08005ce4 <USART2_IRQHandler>:
 * ISR routine
 *####################################################################################### */
/* USART/UART interrupts use a common IRQ handler.  Pass the control block pointer. */
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
 8005ce4:	4800      	ldr	r0, [pc, #0]	; (8005ce8 <USART2_IRQHandler+0x4>)
 8005ce6:	e7ba      	b.n	8005c5e <UART_IRQHandler>
 8005ce8:	200017a4 	.word	0x200017a4

08005cec <USART1_IRQHandler>:
/*#######################################################################################
 * ISR routine
 *####################################################################################### */
/* USART/UART interrupts use a common IRQ handler.  Pass the control block pointer. */
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
 8005cec:	4800      	ldr	r0, [pc, #0]	; (8005cf0 <USART1_IRQHandler+0x4>)
 8005cee:	e7b6      	b.n	8005c5e <UART_IRQHandler>
 8005cf0:	20001764 	.word	0x20001764

08005cf4 <xprintf>:
#include <stdarg.h>
#include <stdio.h>
#include "bsp_uart.h"

int xprintf(int uartnumber, const char *fmt, ...)
{
 8005cf4:	b40e      	push	{r1, r2, r3}
 8005cf6:	b530      	push	{r4, r5, lr}
 8005cf8:	b0c2      	sub	sp, #264	; 0x108
 8005cfa:	aa45      	add	r2, sp, #276	; 0x114
 8005cfc:	4604      	mov	r4, r0
 8005cfe:	f852 1b04 	ldr.w	r1, [r2], #4
	va_list argp;
	char vv[256];\
	int r;
	va_start(argp, fmt);
	va_start(argp, fmt);
	r = vsprintf(vv, fmt, argp);
 8005d02:	a801      	add	r0, sp, #4
{
	va_list argp;
	char vv[256];\
	int r;
	va_start(argp, fmt);
	va_start(argp, fmt);
 8005d04:	9241      	str	r2, [sp, #260]	; 0x104
	r = vsprintf(vv, fmt, argp);
 8005d06:	f004 f9d9 	bl	800a0bc <vsprintf>
	va_end(argp);
	bsp_uart_puts_uartnum(uartnumber,vv);
 8005d0a:	a901      	add	r1, sp, #4
	va_list argp;
	char vv[256];\
	int r;
	va_start(argp, fmt);
	va_start(argp, fmt);
	r = vsprintf(vv, fmt, argp);
 8005d0c:	4605      	mov	r5, r0
	va_end(argp);
	bsp_uart_puts_uartnum(uartnumber,vv);
 8005d0e:	4620      	mov	r0, r4
 8005d10:	f7ff ff0b 	bl	8005b2a <bsp_uart_puts_uartnum>
	return r;
}
 8005d14:	4628      	mov	r0, r5
 8005d16:	b042      	add	sp, #264	; 0x108
 8005d18:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8005d1c:	b003      	add	sp, #12
 8005d1e:	4770      	bx	lr

08005d20 <uart_pins>:
 * @param	: p = pointer to register base
 * @param	: pu = pointer to struct with return values
 * @return	: Edit check--0 = OK; not OK - panic_leds(8)
******************************************************************************/	
int uart_pins(u32 iuart, struct UARTPINS* pu)
{
 8005d20:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

	struct PINCONFIG	pin_uarttx = { \
 8005d22:	4a56      	ldr	r2, [pc, #344]	; (8005e7c <uart_pins+0x15c>)
 * @param	: p = pointer to register base
 * @param	: pu = pointer to struct with return values
 * @return	: Edit check--0 = OK; not OK - panic_leds(8)
******************************************************************************/	
int uart_pins(u32 iuart, struct UARTPINS* pu)
{
 8005d24:	4603      	mov	r3, r0

	struct PINCONFIG	pin_uarttx = { \
 8005d26:	6810      	ldr	r0, [r2, #0]
 8005d28:	9002      	str	r0, [sp, #8]
 8005d2a:	7910      	ldrb	r0, [r2, #4]
 8005d2c:	f88d 000c 	strb.w	r0, [sp, #12]
		GPIO_OTYPE_PP, 		// output type: push-pull 		
		GPIO_OSPEED_100MHZ, 	// speed: highest drive level
		GPIO_PUPD_NONE, 	// pull up/down: none
		0 };			// Alternate function code: to be filled in

	struct PINCONFIG	pin_uartrx = { \
 8005d30:	f852 0f05 	ldr.w	r0, [r2, #5]!
 8005d34:	7912      	ldrb	r2, [r2, #4]
 8005d36:	9000      	str	r0, [sp, #0]
 8005d38:	f88d 2004 	strb.w	r2, [sp, #4]
	u32	txport;
	u32	rxport;

	/* THIS IS BOARD SPECIFIC */
	// Set ports, pins, alternate function code, bus clock freq, and enable peripheral clock
	switch (iuart)
 8005d3c:	4a50      	ldr	r2, [pc, #320]	; (8005e80 <uart_pins+0x160>)
 8005d3e:	4293      	cmp	r3, r2
 8005d40:	d04f      	beq.n	8005de2 <uart_pins+0xc2>
 8005d42:	d807      	bhi.n	8005d54 <uart_pins+0x34>
 8005d44:	4a4f      	ldr	r2, [pc, #316]	; (8005e84 <uart_pins+0x164>)
 8005d46:	4293      	cmp	r3, r2
 8005d48:	d023      	beq.n	8005d92 <uart_pins+0x72>
 8005d4a:	4a4f      	ldr	r2, [pc, #316]	; (8005e88 <uart_pins+0x168>)
 8005d4c:	4293      	cmp	r3, r2
 8005d4e:	f040 8091 	bne.w	8005e74 <uart_pins+0x154>
 8005d52:	e032      	b.n	8005dba <uart_pins+0x9a>
 8005d54:	4a4d      	ldr	r2, [pc, #308]	; (8005e8c <uart_pins+0x16c>)
 8005d56:	4293      	cmp	r3, r2
 8005d58:	d007      	beq.n	8005d6a <uart_pins+0x4a>
 8005d5a:	4a4d      	ldr	r2, [pc, #308]	; (8005e90 <uart_pins+0x170>)
 8005d5c:	4293      	cmp	r3, r2
 8005d5e:	d068      	beq.n	8005e32 <uart_pins+0x112>
 8005d60:	4a4c      	ldr	r2, [pc, #304]	; (8005e94 <uart_pins+0x174>)
 8005d62:	4293      	cmp	r3, r2
 8005d64:	f040 8086 	bne.w	8005e74 <uart_pins+0x154>
 8005d68:	e04f      	b.n	8005e0a <uart_pins+0xea>
	{
		case USART1:
			rxport = GPIOA; txport = GPIOA; txpin = 9; rxpin = 10; af = 7; pu->pclk = pclk2_freq;
 8005d6a:	4b4b      	ldr	r3, [pc, #300]	; (8005e98 <uart_pins+0x178>)
 8005d6c:	4c4b      	ldr	r4, [pc, #300]	; (8005e9c <uart_pins+0x17c>)
 8005d6e:	681b      	ldr	r3, [r3, #0]
 8005d70:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x01;	// Port A
 8005d72:	4b4b      	ldr	r3, [pc, #300]	; (8005ea0 <uart_pins+0x180>)
 8005d74:	681a      	ldr	r2, [r3, #0]
 8005d76:	f042 0201 	orr.w	r2, r2, #1
 8005d7a:	601a      	str	r2, [r3, #0]
//			rxport = GPIOB; txport = GPIOB; txpin = 6; rxpin =  7; af = 7; pu->pclk = pclk2_freq;
//			RCC_AHB1ENR |= 0x02;	// Port B
			RCC_APB2ENR |= (1<<4); // Enable peripheral clock
 8005d7c:	695a      	ldr	r2, [r3, #20]
 8005d7e:	f042 0210 	orr.w	r2, r2, #16
 8005d82:	615a      	str	r2, [r3, #20]
			pu->irqnumber = UART1_IRQ_NUMBER;
 8005d84:	2325      	movs	r3, #37	; 0x25
 8005d86:	604b      	str	r3, [r1, #4]
	/* THIS IS BOARD SPECIFIC */
	// Set ports, pins, alternate function code, bus clock freq, and enable peripheral clock
	switch (iuart)
	{
		case USART1:
			rxport = GPIOA; txport = GPIOA; txpin = 9; rxpin = 10; af = 7; pu->pclk = pclk2_freq;
 8005d88:	4620      	mov	r0, r4
 8005d8a:	2607      	movs	r6, #7
 8005d8c:	2109      	movs	r1, #9
 8005d8e:	250a      	movs	r5, #10
			RCC_AHB1ENR |= 0x01;	// Port A
//			rxport = GPIOB; txport = GPIOB; txpin = 6; rxpin =  7; af = 7; pu->pclk = pclk2_freq;
//			RCC_AHB1ENR |= 0x02;	// Port B
			RCC_APB2ENR |= (1<<4); // Enable peripheral clock
			pu->irqnumber = UART1_IRQ_NUMBER;
			break;
 8005d90:	e062      	b.n	8005e58 <uart_pins+0x138>

		case (u32)USART2:
			rxport = GPIOA; txport = GPIOA; txpin = 2; rxpin =  3; af = 7; pu->pclk = pclk1_freq;
 8005d92:	4b44      	ldr	r3, [pc, #272]	; (8005ea4 <uart_pins+0x184>)
 8005d94:	4c41      	ldr	r4, [pc, #260]	; (8005e9c <uart_pins+0x17c>)
 8005d96:	681b      	ldr	r3, [r3, #0]
 8005d98:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x01;	// Port A
 8005d9a:	4b41      	ldr	r3, [pc, #260]	; (8005ea0 <uart_pins+0x180>)
 8005d9c:	681a      	ldr	r2, [r3, #0]
 8005d9e:	f042 0201 	orr.w	r2, r2, #1
 8005da2:	601a      	str	r2, [r3, #0]
//			rxport = GPIOD; txport = GPIOD; txpin = 5; rxpin =  6; af = 7; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x08;	// Port D
			RCC_APB1ENR |= (1<<17); // Enable peripheral clock
 8005da4:	691a      	ldr	r2, [r3, #16]
 8005da6:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8005daa:	611a      	str	r2, [r3, #16]
			pu->irqnumber = UART2_IRQ_NUMBER;
 8005dac:	2326      	movs	r3, #38	; 0x26
 8005dae:	604b      	str	r3, [r1, #4]
			RCC_APB2ENR |= (1<<4); // Enable peripheral clock
			pu->irqnumber = UART1_IRQ_NUMBER;
			break;

		case (u32)USART2:
			rxport = GPIOA; txport = GPIOA; txpin = 2; rxpin =  3; af = 7; pu->pclk = pclk1_freq;
 8005db0:	4620      	mov	r0, r4
 8005db2:	2607      	movs	r6, #7
 8005db4:	2102      	movs	r1, #2
 8005db6:	2503      	movs	r5, #3
			RCC_AHB1ENR |= 0x01;	// Port A
//			rxport = GPIOD; txport = GPIOD; txpin = 5; rxpin =  6; af = 7; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x08;	// Port D
			RCC_APB1ENR |= (1<<17); // Enable peripheral clock
			pu->irqnumber = UART2_IRQ_NUMBER;
			break;
 8005db8:	e04e      	b.n	8005e58 <uart_pins+0x138>
			
		case (u32)USART3:
//			rxport = GPIOB; txport = GPIOB; txpin = 10; rxpin = 11; af = 7; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x02;	// Port B
			rxport = GPIOD; txport = GPIOD; txpin =  8; rxpin =  9; af = 7; pu->pclk = pclk1_freq;
 8005dba:	4b3a      	ldr	r3, [pc, #232]	; (8005ea4 <uart_pins+0x184>)
 8005dbc:	4c3a      	ldr	r4, [pc, #232]	; (8005ea8 <uart_pins+0x188>)
 8005dbe:	681b      	ldr	r3, [r3, #0]
 8005dc0:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x08;	// Port D
 8005dc2:	4b37      	ldr	r3, [pc, #220]	; (8005ea0 <uart_pins+0x180>)
 8005dc4:	681a      	ldr	r2, [r3, #0]
 8005dc6:	f042 0208 	orr.w	r2, r2, #8
 8005dca:	601a      	str	r2, [r3, #0]
			RCC_APB1ENR |= (1<<18); // Enable peripheral clock
 8005dcc:	691a      	ldr	r2, [r3, #16]
 8005dce:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8005dd2:	611a      	str	r2, [r3, #16]
			pu->irqnumber = UART3_IRQ_NUMBER;
 8005dd4:	2327      	movs	r3, #39	; 0x27
 8005dd6:	604b      	str	r3, [r1, #4]
			break;
			
		case (u32)USART3:
//			rxport = GPIOB; txport = GPIOB; txpin = 10; rxpin = 11; af = 7; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x02;	// Port B
			rxport = GPIOD; txport = GPIOD; txpin =  8; rxpin =  9; af = 7; pu->pclk = pclk1_freq;
 8005dd8:	4620      	mov	r0, r4
 8005dda:	2607      	movs	r6, #7
 8005ddc:	2108      	movs	r1, #8
 8005dde:	2509      	movs	r5, #9
			RCC_AHB1ENR |= 0x08;	// Port D
			RCC_APB1ENR |= (1<<18); // Enable peripheral clock
			pu->irqnumber = UART3_IRQ_NUMBER;
			break;
 8005de0:	e03a      	b.n	8005e58 <uart_pins+0x138>

		case (u32)UART4:
//			rxport = GPIOA; txport = GPIOA; txpin =  0; rxpin =  1; af = 8; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x01;	// Port A
			rxport = GPIOC; txport = GPIOC; txpin = 10; rxpin = 11; af = 8; pu->pclk = pclk1_freq;
 8005de2:	4b30      	ldr	r3, [pc, #192]	; (8005ea4 <uart_pins+0x184>)
 8005de4:	4c31      	ldr	r4, [pc, #196]	; (8005eac <uart_pins+0x18c>)
 8005de6:	681b      	ldr	r3, [r3, #0]
 8005de8:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x04;	// Port C
 8005dea:	4b2d      	ldr	r3, [pc, #180]	; (8005ea0 <uart_pins+0x180>)
 8005dec:	681a      	ldr	r2, [r3, #0]
 8005dee:	f042 0204 	orr.w	r2, r2, #4
 8005df2:	601a      	str	r2, [r3, #0]
			RCC_APB1ENR |= (1<<19); // Enable peripheral clock
 8005df4:	691a      	ldr	r2, [r3, #16]
 8005df6:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8005dfa:	611a      	str	r2, [r3, #16]
			pu->irqnumber = UART4_IRQ_NUMBER;
 8005dfc:	2334      	movs	r3, #52	; 0x34
 8005dfe:	604b      	str	r3, [r1, #4]
			break;

		case (u32)UART4:
//			rxport = GPIOA; txport = GPIOA; txpin =  0; rxpin =  1; af = 8; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x01;	// Port A
			rxport = GPIOC; txport = GPIOC; txpin = 10; rxpin = 11; af = 8; pu->pclk = pclk1_freq;
 8005e00:	4620      	mov	r0, r4
 8005e02:	2608      	movs	r6, #8
 8005e04:	210a      	movs	r1, #10
 8005e06:	250b      	movs	r5, #11
			RCC_AHB1ENR |= 0x04;	// Port C
			RCC_APB1ENR |= (1<<19); // Enable peripheral clock
			pu->irqnumber = UART4_IRQ_NUMBER;
			break;
 8005e08:	e026      	b.n	8005e58 <uart_pins+0x138>

		case (u32)UART5:
			txport = GPIOC; rxport = GPIOD; txpin = 12; rxpin =  2; af = 8; pu->pclk = pclk1_freq;
 8005e0a:	4b26      	ldr	r3, [pc, #152]	; (8005ea4 <uart_pins+0x184>)
 8005e0c:	4c26      	ldr	r4, [pc, #152]	; (8005ea8 <uart_pins+0x188>)
 8005e0e:	681b      	ldr	r3, [r3, #0]
 8005e10:	4826      	ldr	r0, [pc, #152]	; (8005eac <uart_pins+0x18c>)
 8005e12:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x06;	// Port C & D
 8005e14:	4b22      	ldr	r3, [pc, #136]	; (8005ea0 <uart_pins+0x180>)
 8005e16:	681a      	ldr	r2, [r3, #0]
 8005e18:	f042 0206 	orr.w	r2, r2, #6
 8005e1c:	601a      	str	r2, [r3, #0]
			RCC_APB1ENR |= (1<<20); // Enable peripheral clock
 8005e1e:	691a      	ldr	r2, [r3, #16]
 8005e20:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8005e24:	611a      	str	r2, [r3, #16]
			pu->irqnumber = UART5_IRQ_NUMBER;
 8005e26:	2335      	movs	r3, #53	; 0x35
 8005e28:	604b      	str	r3, [r1, #4]
			RCC_APB1ENR |= (1<<19); // Enable peripheral clock
			pu->irqnumber = UART4_IRQ_NUMBER;
			break;

		case (u32)UART5:
			txport = GPIOC; rxport = GPIOD; txpin = 12; rxpin =  2; af = 8; pu->pclk = pclk1_freq;
 8005e2a:	2608      	movs	r6, #8
 8005e2c:	210c      	movs	r1, #12
 8005e2e:	2502      	movs	r5, #2
			RCC_AHB1ENR |= 0x06;	// Port C & D
			RCC_APB1ENR |= (1<<20); // Enable peripheral clock
			pu->irqnumber = UART5_IRQ_NUMBER;
			break;
 8005e30:	e012      	b.n	8005e58 <uart_pins+0x138>

		case (u32)USART6:
			txport = GPIOC; rxport = GPIOC; txpin =  6; rxpin =  7; af = 8; pu->pclk = pclk2_freq;
 8005e32:	4b19      	ldr	r3, [pc, #100]	; (8005e98 <uart_pins+0x178>)
 8005e34:	4c1d      	ldr	r4, [pc, #116]	; (8005eac <uart_pins+0x18c>)
 8005e36:	681b      	ldr	r3, [r3, #0]
 8005e38:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x04;	// Port C
 8005e3a:	4b19      	ldr	r3, [pc, #100]	; (8005ea0 <uart_pins+0x180>)
 8005e3c:	681a      	ldr	r2, [r3, #0]
 8005e3e:	f042 0204 	orr.w	r2, r2, #4
 8005e42:	601a      	str	r2, [r3, #0]
			RCC_APB2ENR |= (1<<5); 	// Enable peripheral clock
 8005e44:	695a      	ldr	r2, [r3, #20]
 8005e46:	f042 0220 	orr.w	r2, r2, #32
 8005e4a:	615a      	str	r2, [r3, #20]
			pu->irqnumber = UART6_IRQ_NUMBER;			
 8005e4c:	2347      	movs	r3, #71	; 0x47
 8005e4e:	604b      	str	r3, [r1, #4]
			RCC_APB1ENR |= (1<<20); // Enable peripheral clock
			pu->irqnumber = UART5_IRQ_NUMBER;
			break;

		case (u32)USART6:
			txport = GPIOC; rxport = GPIOC; txpin =  6; rxpin =  7; af = 8; pu->pclk = pclk2_freq;
 8005e50:	4620      	mov	r0, r4
 8005e52:	2608      	movs	r6, #8
 8005e54:	2106      	movs	r1, #6
 8005e56:	2507      	movs	r5, #7
			return -1;	// Pin assignments: Shouldn't happen
	}

	/* Configure tx pin */
	pin_uarttx.afrl = af;
	f4gpiopins_Config ((volatile u32*)txport, txpin, (struct PINCONFIG*)&pin_uarttx);
 8005e58:	aa02      	add	r2, sp, #8
		default:
			return -1;	// Pin assignments: Shouldn't happen
	}

	/* Configure tx pin */
	pin_uarttx.afrl = af;
 8005e5a:	f88d 600c 	strb.w	r6, [sp, #12]
	f4gpiopins_Config ((volatile u32*)txport, txpin, (struct PINCONFIG*)&pin_uarttx);
 8005e5e:	f7fe fbb0 	bl	80045c2 <f4gpiopins_Config>

	/* Configure rx pin */
	pin_uartrx.afrl = af;
	f4gpiopins_Config ((volatile u32*)rxport, rxpin, (struct PINCONFIG*)&pin_uartrx);
 8005e62:	4620      	mov	r0, r4
 8005e64:	4629      	mov	r1, r5
 8005e66:	466a      	mov	r2, sp
	/* Configure tx pin */
	pin_uarttx.afrl = af;
	f4gpiopins_Config ((volatile u32*)txport, txpin, (struct PINCONFIG*)&pin_uarttx);

	/* Configure rx pin */
	pin_uartrx.afrl = af;
 8005e68:	f88d 6004 	strb.w	r6, [sp, #4]
	f4gpiopins_Config ((volatile u32*)rxport, rxpin, (struct PINCONFIG*)&pin_uartrx);
 8005e6c:	f7fe fba9 	bl	80045c2 <f4gpiopins_Config>

	return 0;
 8005e70:	2000      	movs	r0, #0
 8005e72:	e001      	b.n	8005e78 <uart_pins+0x158>
			RCC_APB2ENR |= (1<<5); 	// Enable peripheral clock
			pu->irqnumber = UART6_IRQ_NUMBER;			
			break;

		default:
			return -1;	// Pin assignments: Shouldn't happen
 8005e74:	f04f 30ff 	mov.w	r0, #4294967295
	/* Configure rx pin */
	pin_uartrx.afrl = af;
	f4gpiopins_Config ((volatile u32*)rxport, rxpin, (struct PINCONFIG*)&pin_uartrx);

	return 0;
}
 8005e78:	b004      	add	sp, #16
 8005e7a:	bd70      	pop	{r4, r5, r6, pc}
 8005e7c:	08010170 	.word	0x08010170
 8005e80:	40004c00 	.word	0x40004c00
 8005e84:	40004400 	.word	0x40004400
 8005e88:	40004800 	.word	0x40004800
 8005e8c:	40011000 	.word	0x40011000
 8005e90:	40011400 	.word	0x40011400
 8005e94:	40005000 	.word	0x40005000
 8005e98:	200016d0 	.word	0x200016d0
 8005e9c:	40020000 	.word	0x40020000
 8005ea0:	40023830 	.word	0x40023830
 8005ea4:	200016cc 	.word	0x200016cc
 8005ea8:	40020c00 	.word	0x40020c00
 8005eac:	40020800 	.word	0x40020800

08005eb0 <usartx_setbaud>:
	u32 tmpreg = 0x00;
	u32 fractionaldivider = 0x00;
	u32 integerdivider = 0x00;

	/* Determine the integer part */
	integerdivider = ((0x19 * pclk_freq) / (0x04 * u32BaudRate));
 8005eb0:	2319      	movs	r3, #25
 8005eb2:	434b      	muls	r3, r1
 8005eb4:	0092      	lsls	r2, r2, #2
 8005eb6:	fbb3 f3f2 	udiv	r3, r3, r2
	tmpreg = (integerdivider / 0x64) << 0x04;
 8005eba:	2164      	movs	r1, #100	; 0x64
 * void usartx_setbaud (u32 usartx, u32 pclk_freq, u32 u32BaudRate);
 * @brief	: set baudrate register (BRR)
 * @param	: u32BaudRate is the baud rate.
******************************************************************************/
void usartx_setbaud (u32 usartx, u32 pclk_freq, u32 u32BaudRate)
{
 8005ebc:	b510      	push	{r4, lr}
	u32 fractionaldivider = 0x00;
	u32 integerdivider = 0x00;

	/* Determine the integer part */
	integerdivider = ((0x19 * pclk_freq) / (0x04 * u32BaudRate));
	tmpreg = (integerdivider / 0x64) << 0x04;
 8005ebe:	fbb3 f4f1 	udiv	r4, r3, r1
 8005ec2:	0124      	lsls	r4, r4, #4

	/* Determine the fractional part */
	fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
 8005ec4:	0922      	lsrs	r2, r4, #4
 8005ec6:	fb01 3312 	mls	r3, r1, r2, r3
	tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((u8)0x0F);
 8005eca:	011b      	lsls	r3, r3, #4
 8005ecc:	3332      	adds	r3, #50	; 0x32
 8005ece:	fbb3 f1f1 	udiv	r1, r3, r1
 8005ed2:	f001 010f 	and.w	r1, r1, #15
 8005ed6:	ea41 0404 	orr.w	r4, r1, r4

	/* Set USART BRR --------------------------------------------------------------- */
	  USART_BRR(usartx) = (u16)tmpreg;
 8005eda:	b2a4      	uxth	r4, r4
 8005edc:	6084      	str	r4, [r0, #8]
	return;
}
 8005ede:	bd10      	pop	{r4, pc}

08005ee0 <__aeabi_drsub>:
 8005ee0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8005ee4:	e002      	b.n	8005eec <__adddf3>
 8005ee6:	bf00      	nop

08005ee8 <__aeabi_dsub>:
 8005ee8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08005eec <__adddf3>:
 8005eec:	b530      	push	{r4, r5, lr}
 8005eee:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8005ef2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8005ef6:	ea94 0f05 	teq	r4, r5
 8005efa:	bf08      	it	eq
 8005efc:	ea90 0f02 	teqeq	r0, r2
 8005f00:	bf1f      	itttt	ne
 8005f02:	ea54 0c00 	orrsne.w	ip, r4, r0
 8005f06:	ea55 0c02 	orrsne.w	ip, r5, r2
 8005f0a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8005f0e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8005f12:	f000 80e2 	beq.w	80060da <__adddf3+0x1ee>
 8005f16:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8005f1a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8005f1e:	bfb8      	it	lt
 8005f20:	426d      	neglt	r5, r5
 8005f22:	dd0c      	ble.n	8005f3e <__adddf3+0x52>
 8005f24:	442c      	add	r4, r5
 8005f26:	ea80 0202 	eor.w	r2, r0, r2
 8005f2a:	ea81 0303 	eor.w	r3, r1, r3
 8005f2e:	ea82 0000 	eor.w	r0, r2, r0
 8005f32:	ea83 0101 	eor.w	r1, r3, r1
 8005f36:	ea80 0202 	eor.w	r2, r0, r2
 8005f3a:	ea81 0303 	eor.w	r3, r1, r3
 8005f3e:	2d36      	cmp	r5, #54	; 0x36
 8005f40:	bf88      	it	hi
 8005f42:	bd30      	pophi	{r4, r5, pc}
 8005f44:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8005f48:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8005f4c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8005f50:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8005f54:	d002      	beq.n	8005f5c <__adddf3+0x70>
 8005f56:	4240      	negs	r0, r0
 8005f58:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8005f5c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8005f60:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8005f64:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8005f68:	d002      	beq.n	8005f70 <__adddf3+0x84>
 8005f6a:	4252      	negs	r2, r2
 8005f6c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8005f70:	ea94 0f05 	teq	r4, r5
 8005f74:	f000 80a7 	beq.w	80060c6 <__adddf3+0x1da>
 8005f78:	f1a4 0401 	sub.w	r4, r4, #1
 8005f7c:	f1d5 0e20 	rsbs	lr, r5, #32
 8005f80:	db0d      	blt.n	8005f9e <__adddf3+0xb2>
 8005f82:	fa02 fc0e 	lsl.w	ip, r2, lr
 8005f86:	fa22 f205 	lsr.w	r2, r2, r5
 8005f8a:	1880      	adds	r0, r0, r2
 8005f8c:	f141 0100 	adc.w	r1, r1, #0
 8005f90:	fa03 f20e 	lsl.w	r2, r3, lr
 8005f94:	1880      	adds	r0, r0, r2
 8005f96:	fa43 f305 	asr.w	r3, r3, r5
 8005f9a:	4159      	adcs	r1, r3
 8005f9c:	e00e      	b.n	8005fbc <__adddf3+0xd0>
 8005f9e:	f1a5 0520 	sub.w	r5, r5, #32
 8005fa2:	f10e 0e20 	add.w	lr, lr, #32
 8005fa6:	2a01      	cmp	r2, #1
 8005fa8:	fa03 fc0e 	lsl.w	ip, r3, lr
 8005fac:	bf28      	it	cs
 8005fae:	f04c 0c02 	orrcs.w	ip, ip, #2
 8005fb2:	fa43 f305 	asr.w	r3, r3, r5
 8005fb6:	18c0      	adds	r0, r0, r3
 8005fb8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8005fbc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8005fc0:	d507      	bpl.n	8005fd2 <__adddf3+0xe6>
 8005fc2:	f04f 0e00 	mov.w	lr, #0
 8005fc6:	f1dc 0c00 	rsbs	ip, ip, #0
 8005fca:	eb7e 0000 	sbcs.w	r0, lr, r0
 8005fce:	eb6e 0101 	sbc.w	r1, lr, r1
 8005fd2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8005fd6:	d31b      	bcc.n	8006010 <__adddf3+0x124>
 8005fd8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8005fdc:	d30c      	bcc.n	8005ff8 <__adddf3+0x10c>
 8005fde:	0849      	lsrs	r1, r1, #1
 8005fe0:	ea5f 0030 	movs.w	r0, r0, rrx
 8005fe4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8005fe8:	f104 0401 	add.w	r4, r4, #1
 8005fec:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8005ff0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8005ff4:	f080 809a 	bcs.w	800612c <__adddf3+0x240>
 8005ff8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8005ffc:	bf08      	it	eq
 8005ffe:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8006002:	f150 0000 	adcs.w	r0, r0, #0
 8006006:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800600a:	ea41 0105 	orr.w	r1, r1, r5
 800600e:	bd30      	pop	{r4, r5, pc}
 8006010:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8006014:	4140      	adcs	r0, r0
 8006016:	eb41 0101 	adc.w	r1, r1, r1
 800601a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800601e:	f1a4 0401 	sub.w	r4, r4, #1
 8006022:	d1e9      	bne.n	8005ff8 <__adddf3+0x10c>
 8006024:	f091 0f00 	teq	r1, #0
 8006028:	bf04      	itt	eq
 800602a:	4601      	moveq	r1, r0
 800602c:	2000      	moveq	r0, #0
 800602e:	fab1 f381 	clz	r3, r1
 8006032:	bf08      	it	eq
 8006034:	3320      	addeq	r3, #32
 8006036:	f1a3 030b 	sub.w	r3, r3, #11
 800603a:	f1b3 0220 	subs.w	r2, r3, #32
 800603e:	da0c      	bge.n	800605a <__adddf3+0x16e>
 8006040:	320c      	adds	r2, #12
 8006042:	dd08      	ble.n	8006056 <__adddf3+0x16a>
 8006044:	f102 0c14 	add.w	ip, r2, #20
 8006048:	f1c2 020c 	rsb	r2, r2, #12
 800604c:	fa01 f00c 	lsl.w	r0, r1, ip
 8006050:	fa21 f102 	lsr.w	r1, r1, r2
 8006054:	e00c      	b.n	8006070 <__adddf3+0x184>
 8006056:	f102 0214 	add.w	r2, r2, #20
 800605a:	bfd8      	it	le
 800605c:	f1c2 0c20 	rsble	ip, r2, #32
 8006060:	fa01 f102 	lsl.w	r1, r1, r2
 8006064:	fa20 fc0c 	lsr.w	ip, r0, ip
 8006068:	bfdc      	itt	le
 800606a:	ea41 010c 	orrle.w	r1, r1, ip
 800606e:	4090      	lslle	r0, r2
 8006070:	1ae4      	subs	r4, r4, r3
 8006072:	bfa2      	ittt	ge
 8006074:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8006078:	4329      	orrge	r1, r5
 800607a:	bd30      	popge	{r4, r5, pc}
 800607c:	ea6f 0404 	mvn.w	r4, r4
 8006080:	3c1f      	subs	r4, #31
 8006082:	da1c      	bge.n	80060be <__adddf3+0x1d2>
 8006084:	340c      	adds	r4, #12
 8006086:	dc0e      	bgt.n	80060a6 <__adddf3+0x1ba>
 8006088:	f104 0414 	add.w	r4, r4, #20
 800608c:	f1c4 0220 	rsb	r2, r4, #32
 8006090:	fa20 f004 	lsr.w	r0, r0, r4
 8006094:	fa01 f302 	lsl.w	r3, r1, r2
 8006098:	ea40 0003 	orr.w	r0, r0, r3
 800609c:	fa21 f304 	lsr.w	r3, r1, r4
 80060a0:	ea45 0103 	orr.w	r1, r5, r3
 80060a4:	bd30      	pop	{r4, r5, pc}
 80060a6:	f1c4 040c 	rsb	r4, r4, #12
 80060aa:	f1c4 0220 	rsb	r2, r4, #32
 80060ae:	fa20 f002 	lsr.w	r0, r0, r2
 80060b2:	fa01 f304 	lsl.w	r3, r1, r4
 80060b6:	ea40 0003 	orr.w	r0, r0, r3
 80060ba:	4629      	mov	r1, r5
 80060bc:	bd30      	pop	{r4, r5, pc}
 80060be:	fa21 f004 	lsr.w	r0, r1, r4
 80060c2:	4629      	mov	r1, r5
 80060c4:	bd30      	pop	{r4, r5, pc}
 80060c6:	f094 0f00 	teq	r4, #0
 80060ca:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80060ce:	bf06      	itte	eq
 80060d0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80060d4:	3401      	addeq	r4, #1
 80060d6:	3d01      	subne	r5, #1
 80060d8:	e74e      	b.n	8005f78 <__adddf3+0x8c>
 80060da:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80060de:	bf18      	it	ne
 80060e0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80060e4:	d029      	beq.n	800613a <__adddf3+0x24e>
 80060e6:	ea94 0f05 	teq	r4, r5
 80060ea:	bf08      	it	eq
 80060ec:	ea90 0f02 	teqeq	r0, r2
 80060f0:	d005      	beq.n	80060fe <__adddf3+0x212>
 80060f2:	ea54 0c00 	orrs.w	ip, r4, r0
 80060f6:	bf04      	itt	eq
 80060f8:	4619      	moveq	r1, r3
 80060fa:	4610      	moveq	r0, r2
 80060fc:	bd30      	pop	{r4, r5, pc}
 80060fe:	ea91 0f03 	teq	r1, r3
 8006102:	bf1e      	ittt	ne
 8006104:	2100      	movne	r1, #0
 8006106:	2000      	movne	r0, #0
 8006108:	bd30      	popne	{r4, r5, pc}
 800610a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800610e:	d105      	bne.n	800611c <__adddf3+0x230>
 8006110:	0040      	lsls	r0, r0, #1
 8006112:	4149      	adcs	r1, r1
 8006114:	bf28      	it	cs
 8006116:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800611a:	bd30      	pop	{r4, r5, pc}
 800611c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8006120:	bf3c      	itt	cc
 8006122:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8006126:	bd30      	popcc	{r4, r5, pc}
 8006128:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800612c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8006130:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8006134:	f04f 0000 	mov.w	r0, #0
 8006138:	bd30      	pop	{r4, r5, pc}
 800613a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800613e:	bf1a      	itte	ne
 8006140:	4619      	movne	r1, r3
 8006142:	4610      	movne	r0, r2
 8006144:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8006148:	bf1c      	itt	ne
 800614a:	460b      	movne	r3, r1
 800614c:	4602      	movne	r2, r0
 800614e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8006152:	bf06      	itte	eq
 8006154:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8006158:	ea91 0f03 	teqeq	r1, r3
 800615c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8006160:	bd30      	pop	{r4, r5, pc}
 8006162:	bf00      	nop

08006164 <__aeabi_ui2d>:
 8006164:	f090 0f00 	teq	r0, #0
 8006168:	bf04      	itt	eq
 800616a:	2100      	moveq	r1, #0
 800616c:	4770      	bxeq	lr
 800616e:	b530      	push	{r4, r5, lr}
 8006170:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8006174:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8006178:	f04f 0500 	mov.w	r5, #0
 800617c:	f04f 0100 	mov.w	r1, #0
 8006180:	e750      	b.n	8006024 <__adddf3+0x138>
 8006182:	bf00      	nop

08006184 <__aeabi_i2d>:
 8006184:	f090 0f00 	teq	r0, #0
 8006188:	bf04      	itt	eq
 800618a:	2100      	moveq	r1, #0
 800618c:	4770      	bxeq	lr
 800618e:	b530      	push	{r4, r5, lr}
 8006190:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8006194:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8006198:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800619c:	bf48      	it	mi
 800619e:	4240      	negmi	r0, r0
 80061a0:	f04f 0100 	mov.w	r1, #0
 80061a4:	e73e      	b.n	8006024 <__adddf3+0x138>
 80061a6:	bf00      	nop

080061a8 <__aeabi_f2d>:
 80061a8:	0042      	lsls	r2, r0, #1
 80061aa:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80061ae:	ea4f 0131 	mov.w	r1, r1, rrx
 80061b2:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80061b6:	bf1f      	itttt	ne
 80061b8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80061bc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80061c0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80061c4:	4770      	bxne	lr
 80061c6:	f092 0f00 	teq	r2, #0
 80061ca:	bf14      	ite	ne
 80061cc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80061d0:	4770      	bxeq	lr
 80061d2:	b530      	push	{r4, r5, lr}
 80061d4:	f44f 7460 	mov.w	r4, #896	; 0x380
 80061d8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80061dc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80061e0:	e720      	b.n	8006024 <__adddf3+0x138>
 80061e2:	bf00      	nop

080061e4 <__aeabi_ul2d>:
 80061e4:	ea50 0201 	orrs.w	r2, r0, r1
 80061e8:	bf08      	it	eq
 80061ea:	4770      	bxeq	lr
 80061ec:	b530      	push	{r4, r5, lr}
 80061ee:	f04f 0500 	mov.w	r5, #0
 80061f2:	e00a      	b.n	800620a <__aeabi_l2d+0x16>

080061f4 <__aeabi_l2d>:
 80061f4:	ea50 0201 	orrs.w	r2, r0, r1
 80061f8:	bf08      	it	eq
 80061fa:	4770      	bxeq	lr
 80061fc:	b530      	push	{r4, r5, lr}
 80061fe:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8006202:	d502      	bpl.n	800620a <__aeabi_l2d+0x16>
 8006204:	4240      	negs	r0, r0
 8006206:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800620a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800620e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8006212:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8006216:	f43f aedc 	beq.w	8005fd2 <__adddf3+0xe6>
 800621a:	f04f 0203 	mov.w	r2, #3
 800621e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8006222:	bf18      	it	ne
 8006224:	3203      	addne	r2, #3
 8006226:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800622a:	bf18      	it	ne
 800622c:	3203      	addne	r2, #3
 800622e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8006232:	f1c2 0320 	rsb	r3, r2, #32
 8006236:	fa00 fc03 	lsl.w	ip, r0, r3
 800623a:	fa20 f002 	lsr.w	r0, r0, r2
 800623e:	fa01 fe03 	lsl.w	lr, r1, r3
 8006242:	ea40 000e 	orr.w	r0, r0, lr
 8006246:	fa21 f102 	lsr.w	r1, r1, r2
 800624a:	4414      	add	r4, r2
 800624c:	e6c1      	b.n	8005fd2 <__adddf3+0xe6>
 800624e:	bf00      	nop

08006250 <__aeabi_fmul>:
 8006250:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8006254:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8006258:	bf1e      	ittt	ne
 800625a:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 800625e:	ea92 0f0c 	teqne	r2, ip
 8006262:	ea93 0f0c 	teqne	r3, ip
 8006266:	d06f      	beq.n	8006348 <__aeabi_fmul+0xf8>
 8006268:	441a      	add	r2, r3
 800626a:	ea80 0c01 	eor.w	ip, r0, r1
 800626e:	0240      	lsls	r0, r0, #9
 8006270:	bf18      	it	ne
 8006272:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 8006276:	d01e      	beq.n	80062b6 <__aeabi_fmul+0x66>
 8006278:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800627c:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 8006280:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 8006284:	fba0 3101 	umull	r3, r1, r0, r1
 8006288:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 800628c:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8006290:	bf3e      	ittt	cc
 8006292:	0049      	lslcc	r1, r1, #1
 8006294:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 8006298:	005b      	lslcc	r3, r3, #1
 800629a:	ea40 0001 	orr.w	r0, r0, r1
 800629e:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 80062a2:	2afd      	cmp	r2, #253	; 0xfd
 80062a4:	d81d      	bhi.n	80062e2 <__aeabi_fmul+0x92>
 80062a6:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80062aa:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80062ae:	bf08      	it	eq
 80062b0:	f020 0001 	biceq.w	r0, r0, #1
 80062b4:	4770      	bx	lr
 80062b6:	f090 0f00 	teq	r0, #0
 80062ba:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80062be:	bf08      	it	eq
 80062c0:	0249      	lsleq	r1, r1, #9
 80062c2:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80062c6:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 80062ca:	3a7f      	subs	r2, #127	; 0x7f
 80062cc:	bfc2      	ittt	gt
 80062ce:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80062d2:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80062d6:	4770      	bxgt	lr
 80062d8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80062dc:	f04f 0300 	mov.w	r3, #0
 80062e0:	3a01      	subs	r2, #1
 80062e2:	dc5d      	bgt.n	80063a0 <__aeabi_fmul+0x150>
 80062e4:	f112 0f19 	cmn.w	r2, #25
 80062e8:	bfdc      	itt	le
 80062ea:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 80062ee:	4770      	bxle	lr
 80062f0:	f1c2 0200 	rsb	r2, r2, #0
 80062f4:	0041      	lsls	r1, r0, #1
 80062f6:	fa21 f102 	lsr.w	r1, r1, r2
 80062fa:	f1c2 0220 	rsb	r2, r2, #32
 80062fe:	fa00 fc02 	lsl.w	ip, r0, r2
 8006302:	ea5f 0031 	movs.w	r0, r1, rrx
 8006306:	f140 0000 	adc.w	r0, r0, #0
 800630a:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 800630e:	bf08      	it	eq
 8006310:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8006314:	4770      	bx	lr
 8006316:	f092 0f00 	teq	r2, #0
 800631a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 800631e:	bf02      	ittt	eq
 8006320:	0040      	lsleq	r0, r0, #1
 8006322:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8006326:	3a01      	subeq	r2, #1
 8006328:	d0f9      	beq.n	800631e <__aeabi_fmul+0xce>
 800632a:	ea40 000c 	orr.w	r0, r0, ip
 800632e:	f093 0f00 	teq	r3, #0
 8006332:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8006336:	bf02      	ittt	eq
 8006338:	0049      	lsleq	r1, r1, #1
 800633a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 800633e:	3b01      	subeq	r3, #1
 8006340:	d0f9      	beq.n	8006336 <__aeabi_fmul+0xe6>
 8006342:	ea41 010c 	orr.w	r1, r1, ip
 8006346:	e78f      	b.n	8006268 <__aeabi_fmul+0x18>
 8006348:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 800634c:	ea92 0f0c 	teq	r2, ip
 8006350:	bf18      	it	ne
 8006352:	ea93 0f0c 	teqne	r3, ip
 8006356:	d00a      	beq.n	800636e <__aeabi_fmul+0x11e>
 8006358:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 800635c:	bf18      	it	ne
 800635e:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8006362:	d1d8      	bne.n	8006316 <__aeabi_fmul+0xc6>
 8006364:	ea80 0001 	eor.w	r0, r0, r1
 8006368:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 800636c:	4770      	bx	lr
 800636e:	f090 0f00 	teq	r0, #0
 8006372:	bf17      	itett	ne
 8006374:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 8006378:	4608      	moveq	r0, r1
 800637a:	f091 0f00 	teqne	r1, #0
 800637e:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 8006382:	d014      	beq.n	80063ae <__aeabi_fmul+0x15e>
 8006384:	ea92 0f0c 	teq	r2, ip
 8006388:	d101      	bne.n	800638e <__aeabi_fmul+0x13e>
 800638a:	0242      	lsls	r2, r0, #9
 800638c:	d10f      	bne.n	80063ae <__aeabi_fmul+0x15e>
 800638e:	ea93 0f0c 	teq	r3, ip
 8006392:	d103      	bne.n	800639c <__aeabi_fmul+0x14c>
 8006394:	024b      	lsls	r3, r1, #9
 8006396:	bf18      	it	ne
 8006398:	4608      	movne	r0, r1
 800639a:	d108      	bne.n	80063ae <__aeabi_fmul+0x15e>
 800639c:	ea80 0001 	eor.w	r0, r0, r1
 80063a0:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80063a4:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80063a8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80063ac:	4770      	bx	lr
 80063ae:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80063b2:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 80063b6:	4770      	bx	lr

080063b8 <__aeabi_fdiv>:
 80063b8:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80063bc:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80063c0:	bf1e      	ittt	ne
 80063c2:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80063c6:	ea92 0f0c 	teqne	r2, ip
 80063ca:	ea93 0f0c 	teqne	r3, ip
 80063ce:	d069      	beq.n	80064a4 <__aeabi_fdiv+0xec>
 80063d0:	eba2 0203 	sub.w	r2, r2, r3
 80063d4:	ea80 0c01 	eor.w	ip, r0, r1
 80063d8:	0249      	lsls	r1, r1, #9
 80063da:	ea4f 2040 	mov.w	r0, r0, lsl #9
 80063de:	d037      	beq.n	8006450 <__aeabi_fdiv+0x98>
 80063e0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80063e4:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 80063e8:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 80063ec:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80063f0:	428b      	cmp	r3, r1
 80063f2:	bf38      	it	cc
 80063f4:	005b      	lslcc	r3, r3, #1
 80063f6:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 80063fa:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 80063fe:	428b      	cmp	r3, r1
 8006400:	bf24      	itt	cs
 8006402:	1a5b      	subcs	r3, r3, r1
 8006404:	ea40 000c 	orrcs.w	r0, r0, ip
 8006408:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 800640c:	bf24      	itt	cs
 800640e:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 8006412:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8006416:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 800641a:	bf24      	itt	cs
 800641c:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 8006420:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8006424:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 8006428:	bf24      	itt	cs
 800642a:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 800642e:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8006432:	011b      	lsls	r3, r3, #4
 8006434:	bf18      	it	ne
 8006436:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 800643a:	d1e0      	bne.n	80063fe <__aeabi_fdiv+0x46>
 800643c:	2afd      	cmp	r2, #253	; 0xfd
 800643e:	f63f af50 	bhi.w	80062e2 <__aeabi_fmul+0x92>
 8006442:	428b      	cmp	r3, r1
 8006444:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8006448:	bf08      	it	eq
 800644a:	f020 0001 	biceq.w	r0, r0, #1
 800644e:	4770      	bx	lr
 8006450:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8006454:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8006458:	327f      	adds	r2, #127	; 0x7f
 800645a:	bfc2      	ittt	gt
 800645c:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8006460:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8006464:	4770      	bxgt	lr
 8006466:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 800646a:	f04f 0300 	mov.w	r3, #0
 800646e:	3a01      	subs	r2, #1
 8006470:	e737      	b.n	80062e2 <__aeabi_fmul+0x92>
 8006472:	f092 0f00 	teq	r2, #0
 8006476:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 800647a:	bf02      	ittt	eq
 800647c:	0040      	lsleq	r0, r0, #1
 800647e:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8006482:	3a01      	subeq	r2, #1
 8006484:	d0f9      	beq.n	800647a <__aeabi_fdiv+0xc2>
 8006486:	ea40 000c 	orr.w	r0, r0, ip
 800648a:	f093 0f00 	teq	r3, #0
 800648e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8006492:	bf02      	ittt	eq
 8006494:	0049      	lsleq	r1, r1, #1
 8006496:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 800649a:	3b01      	subeq	r3, #1
 800649c:	d0f9      	beq.n	8006492 <__aeabi_fdiv+0xda>
 800649e:	ea41 010c 	orr.w	r1, r1, ip
 80064a2:	e795      	b.n	80063d0 <__aeabi_fdiv+0x18>
 80064a4:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80064a8:	ea92 0f0c 	teq	r2, ip
 80064ac:	d108      	bne.n	80064c0 <__aeabi_fdiv+0x108>
 80064ae:	0242      	lsls	r2, r0, #9
 80064b0:	f47f af7d 	bne.w	80063ae <__aeabi_fmul+0x15e>
 80064b4:	ea93 0f0c 	teq	r3, ip
 80064b8:	f47f af70 	bne.w	800639c <__aeabi_fmul+0x14c>
 80064bc:	4608      	mov	r0, r1
 80064be:	e776      	b.n	80063ae <__aeabi_fmul+0x15e>
 80064c0:	ea93 0f0c 	teq	r3, ip
 80064c4:	d104      	bne.n	80064d0 <__aeabi_fdiv+0x118>
 80064c6:	024b      	lsls	r3, r1, #9
 80064c8:	f43f af4c 	beq.w	8006364 <__aeabi_fmul+0x114>
 80064cc:	4608      	mov	r0, r1
 80064ce:	e76e      	b.n	80063ae <__aeabi_fmul+0x15e>
 80064d0:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80064d4:	bf18      	it	ne
 80064d6:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80064da:	d1ca      	bne.n	8006472 <__aeabi_fdiv+0xba>
 80064dc:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 80064e0:	f47f af5c 	bne.w	800639c <__aeabi_fmul+0x14c>
 80064e4:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 80064e8:	f47f af3c 	bne.w	8006364 <__aeabi_fmul+0x114>
 80064ec:	e75f      	b.n	80063ae <__aeabi_fmul+0x15e>
 80064ee:	bf00      	nop

080064f0 <__libc_init_array>:
 80064f0:	b570      	push	{r4, r5, r6, lr}
 80064f2:	f240 46dc 	movw	r6, #1244	; 0x4dc
 80064f6:	f240 45dc 	movw	r5, #1244	; 0x4dc
 80064fa:	f6c0 0601 	movt	r6, #2049	; 0x801
 80064fe:	f6c0 0501 	movt	r5, #2049	; 0x801
 8006502:	1b76      	subs	r6, r6, r5
 8006504:	10b6      	asrs	r6, r6, #2
 8006506:	d006      	beq.n	8006516 <__libc_init_array+0x26>
 8006508:	2400      	movs	r4, #0
 800650a:	f855 3b04 	ldr.w	r3, [r5], #4
 800650e:	3401      	adds	r4, #1
 8006510:	4798      	blx	r3
 8006512:	42a6      	cmp	r6, r4
 8006514:	d1f9      	bne.n	800650a <__libc_init_array+0x1a>
 8006516:	f240 46dc 	movw	r6, #1244	; 0x4dc
 800651a:	f240 45dc 	movw	r5, #1244	; 0x4dc
 800651e:	f6c0 0601 	movt	r6, #2049	; 0x801
 8006522:	f6c0 0501 	movt	r5, #2049	; 0x801
 8006526:	1b76      	subs	r6, r6, r5
 8006528:	f7fa fd6b 	bl	8001002 <_init>
 800652c:	10b6      	asrs	r6, r6, #2
 800652e:	d006      	beq.n	800653e <__libc_init_array+0x4e>
 8006530:	2400      	movs	r4, #0
 8006532:	f855 3b04 	ldr.w	r3, [r5], #4
 8006536:	3401      	adds	r4, #1
 8006538:	4798      	blx	r3
 800653a:	42a6      	cmp	r6, r4
 800653c:	d1f9      	bne.n	8006532 <__libc_init_array+0x42>
 800653e:	bd70      	pop	{r4, r5, r6, pc}

08006540 <malloc>:
 8006540:	f240 237c 	movw	r3, #636	; 0x27c
 8006544:	4601      	mov	r1, r0
 8006546:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800654a:	6818      	ldr	r0, [r3, #0]
 800654c:	f000 b808 	b.w	8006560 <_malloc_r>

08006550 <free>:
 8006550:	f240 237c 	movw	r3, #636	; 0x27c
 8006554:	4601      	mov	r1, r0
 8006556:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800655a:	6818      	ldr	r0, [r3, #0]
 800655c:	f005 b8a2 	b.w	800b6a4 <_free_r>

08006560 <_malloc_r>:
 8006560:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006564:	f101 040b 	add.w	r4, r1, #11
 8006568:	2c16      	cmp	r4, #22
 800656a:	b083      	sub	sp, #12
 800656c:	4606      	mov	r6, r0
 800656e:	d931      	bls.n	80065d4 <_malloc_r+0x74>
 8006570:	f024 0407 	bic.w	r4, r4, #7
 8006574:	0fe3      	lsrs	r3, r4, #31
 8006576:	428c      	cmp	r4, r1
 8006578:	bf2c      	ite	cs
 800657a:	4619      	movcs	r1, r3
 800657c:	f043 0101 	orrcc.w	r1, r3, #1
 8006580:	2900      	cmp	r1, #0
 8006582:	d130      	bne.n	80065e6 <_malloc_r+0x86>
 8006584:	4630      	mov	r0, r6
 8006586:	f000 faa9 	bl	8006adc <__malloc_lock>
 800658a:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
 800658e:	d22f      	bcs.n	80065f0 <_malloc_r+0x90>
 8006590:	ea4f 0cd4 	mov.w	ip, r4, lsr #3
 8006594:	f240 3570 	movw	r5, #880	; 0x370
 8006598:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800659c:	eb05 02cc 	add.w	r2, r5, ip, lsl #3
 80065a0:	462f      	mov	r7, r5
 80065a2:	68d3      	ldr	r3, [r2, #12]
 80065a4:	4293      	cmp	r3, r2
 80065a6:	f000 822d 	beq.w	8006a04 <_malloc_r+0x4a4>
 80065aa:	685c      	ldr	r4, [r3, #4]
 80065ac:	f103 0808 	add.w	r8, r3, #8
 80065b0:	68da      	ldr	r2, [r3, #12]
 80065b2:	4630      	mov	r0, r6
 80065b4:	f024 0403 	bic.w	r4, r4, #3
 80065b8:	6899      	ldr	r1, [r3, #8]
 80065ba:	191b      	adds	r3, r3, r4
 80065bc:	685c      	ldr	r4, [r3, #4]
 80065be:	60ca      	str	r2, [r1, #12]
 80065c0:	f044 0401 	orr.w	r4, r4, #1
 80065c4:	6091      	str	r1, [r2, #8]
 80065c6:	605c      	str	r4, [r3, #4]
 80065c8:	f000 fa8a 	bl	8006ae0 <__malloc_unlock>
 80065cc:	4640      	mov	r0, r8
 80065ce:	b003      	add	sp, #12
 80065d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80065d4:	2300      	movs	r3, #0
 80065d6:	2410      	movs	r4, #16
 80065d8:	428c      	cmp	r4, r1
 80065da:	bf2c      	ite	cs
 80065dc:	4619      	movcs	r1, r3
 80065de:	f043 0101 	orrcc.w	r1, r3, #1
 80065e2:	2900      	cmp	r1, #0
 80065e4:	d0ce      	beq.n	8006584 <_malloc_r+0x24>
 80065e6:	230c      	movs	r3, #12
 80065e8:	f04f 0800 	mov.w	r8, #0
 80065ec:	6033      	str	r3, [r6, #0]
 80065ee:	e7ed      	b.n	80065cc <_malloc_r+0x6c>
 80065f0:	ea5f 2c54 	movs.w	ip, r4, lsr #9
 80065f4:	bf04      	itt	eq
 80065f6:	ea4f 0cd4 	moveq.w	ip, r4, lsr #3
 80065fa:	ea4f 00cc 	moveq.w	r0, ip, lsl #3
 80065fe:	f040 8086 	bne.w	800670e <_malloc_r+0x1ae>
 8006602:	f240 3570 	movw	r5, #880	; 0x370
 8006606:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800660a:	1828      	adds	r0, r5, r0
 800660c:	462f      	mov	r7, r5
 800660e:	68c3      	ldr	r3, [r0, #12]
 8006610:	4298      	cmp	r0, r3
 8006612:	d106      	bne.n	8006622 <_malloc_r+0xc2>
 8006614:	e00d      	b.n	8006632 <_malloc_r+0xd2>
 8006616:	2900      	cmp	r1, #0
 8006618:	f280 8179 	bge.w	800690e <_malloc_r+0x3ae>
 800661c:	68db      	ldr	r3, [r3, #12]
 800661e:	4298      	cmp	r0, r3
 8006620:	d007      	beq.n	8006632 <_malloc_r+0xd2>
 8006622:	685a      	ldr	r2, [r3, #4]
 8006624:	f022 0203 	bic.w	r2, r2, #3
 8006628:	1b11      	subs	r1, r2, r4
 800662a:	290f      	cmp	r1, #15
 800662c:	ddf3      	ble.n	8006616 <_malloc_r+0xb6>
 800662e:	f10c 3cff 	add.w	ip, ip, #4294967295
 8006632:	f10c 0c01 	add.w	ip, ip, #1
 8006636:	4abd      	ldr	r2, [pc, #756]	; (800692c <_malloc_r+0x3cc>)
 8006638:	6893      	ldr	r3, [r2, #8]
 800663a:	429a      	cmp	r2, r3
 800663c:	bf08      	it	eq
 800663e:	6878      	ldreq	r0, [r7, #4]
 8006640:	d024      	beq.n	800668c <_malloc_r+0x12c>
 8006642:	6858      	ldr	r0, [r3, #4]
 8006644:	f020 0003 	bic.w	r0, r0, #3
 8006648:	1b01      	subs	r1, r0, r4
 800664a:	290f      	cmp	r1, #15
 800664c:	f300 81c0 	bgt.w	80069d0 <_malloc_r+0x470>
 8006650:	2900      	cmp	r1, #0
 8006652:	60d2      	str	r2, [r2, #12]
 8006654:	6092      	str	r2, [r2, #8]
 8006656:	f280 8094 	bge.w	8006782 <_malloc_r+0x222>
 800665a:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 800665e:	f080 8177 	bcs.w	8006950 <_malloc_r+0x3f0>
 8006662:	08c0      	lsrs	r0, r0, #3
 8006664:	f04f 0e01 	mov.w	lr, #1
 8006668:	f8d7 8004 	ldr.w	r8, [r7, #4]
 800666c:	eb07 01c0 	add.w	r1, r7, r0, lsl #3
 8006670:	1080      	asrs	r0, r0, #2
 8006672:	fa0e f000 	lsl.w	r0, lr, r0
 8006676:	60d9      	str	r1, [r3, #12]
 8006678:	f8d1 e008 	ldr.w	lr, [r1, #8]
 800667c:	ea40 0008 	orr.w	r0, r0, r8
 8006680:	6078      	str	r0, [r7, #4]
 8006682:	f8c3 e008 	str.w	lr, [r3, #8]
 8006686:	f8ce 300c 	str.w	r3, [lr, #12]
 800668a:	608b      	str	r3, [r1, #8]
 800668c:	f04f 0e01 	mov.w	lr, #1
 8006690:	ea4f 03ac 	mov.w	r3, ip, asr #2
 8006694:	fa0e fe03 	lsl.w	lr, lr, r3
 8006698:	4586      	cmp	lr, r0
 800669a:	d87d      	bhi.n	8006798 <_malloc_r+0x238>
 800669c:	ea10 0f0e 	tst.w	r0, lr
 80066a0:	d108      	bne.n	80066b4 <_malloc_r+0x154>
 80066a2:	f02c 0c03 	bic.w	ip, ip, #3
 80066a6:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 80066aa:	f10c 0c04 	add.w	ip, ip, #4
 80066ae:	ea10 0f0e 	tst.w	r0, lr
 80066b2:	d0f8      	beq.n	80066a6 <_malloc_r+0x146>
 80066b4:	eb07 0acc 	add.w	sl, r7, ip, lsl #3
 80066b8:	46e1      	mov	r9, ip
 80066ba:	46d0      	mov	r8, sl
 80066bc:	f8d8 000c 	ldr.w	r0, [r8, #12]
 80066c0:	4580      	cmp	r8, r0
 80066c2:	d107      	bne.n	80066d4 <_malloc_r+0x174>
 80066c4:	e196      	b.n	80069f4 <_malloc_r+0x494>
 80066c6:	2b00      	cmp	r3, #0
 80066c8:	f280 81a6 	bge.w	8006a18 <_malloc_r+0x4b8>
 80066cc:	68c0      	ldr	r0, [r0, #12]
 80066ce:	4580      	cmp	r8, r0
 80066d0:	f000 8190 	beq.w	80069f4 <_malloc_r+0x494>
 80066d4:	6841      	ldr	r1, [r0, #4]
 80066d6:	f021 0103 	bic.w	r1, r1, #3
 80066da:	1b0b      	subs	r3, r1, r4
 80066dc:	2b0f      	cmp	r3, #15
 80066de:	ddf2      	ble.n	80066c6 <_malloc_r+0x166>
 80066e0:	4680      	mov	r8, r0
 80066e2:	68c5      	ldr	r5, [r0, #12]
 80066e4:	1901      	adds	r1, r0, r4
 80066e6:	f044 0e01 	orr.w	lr, r4, #1
 80066ea:	f858 7f08 	ldr.w	r7, [r8, #8]!
 80066ee:	f043 0401 	orr.w	r4, r3, #1
 80066f2:	f8c0 e004 	str.w	lr, [r0, #4]
 80066f6:	4630      	mov	r0, r6
 80066f8:	604c      	str	r4, [r1, #4]
 80066fa:	60fd      	str	r5, [r7, #12]
 80066fc:	60af      	str	r7, [r5, #8]
 80066fe:	60d1      	str	r1, [r2, #12]
 8006700:	6091      	str	r1, [r2, #8]
 8006702:	60ca      	str	r2, [r1, #12]
 8006704:	608a      	str	r2, [r1, #8]
 8006706:	50cb      	str	r3, [r1, r3]
 8006708:	f000 f9ea 	bl	8006ae0 <__malloc_unlock>
 800670c:	e75e      	b.n	80065cc <_malloc_r+0x6c>
 800670e:	f1bc 0f04 	cmp.w	ip, #4
 8006712:	bf9e      	ittt	ls
 8006714:	ea4f 1c94 	movls.w	ip, r4, lsr #6
 8006718:	f10c 0c38 	addls.w	ip, ip, #56	; 0x38
 800671c:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8006720:	f67f af6f 	bls.w	8006602 <_malloc_r+0xa2>
 8006724:	f1bc 0f14 	cmp.w	ip, #20
 8006728:	bf9c      	itt	ls
 800672a:	f10c 0c5b 	addls.w	ip, ip, #91	; 0x5b
 800672e:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8006732:	f67f af66 	bls.w	8006602 <_malloc_r+0xa2>
 8006736:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
 800673a:	bf9e      	ittt	ls
 800673c:	ea4f 3c14 	movls.w	ip, r4, lsr #12
 8006740:	f10c 0c6e 	addls.w	ip, ip, #110	; 0x6e
 8006744:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8006748:	f67f af5b 	bls.w	8006602 <_malloc_r+0xa2>
 800674c:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
 8006750:	bf9e      	ittt	ls
 8006752:	ea4f 3cd4 	movls.w	ip, r4, lsr #15
 8006756:	f10c 0c77 	addls.w	ip, ip, #119	; 0x77
 800675a:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 800675e:	f67f af50 	bls.w	8006602 <_malloc_r+0xa2>
 8006762:	f240 5354 	movw	r3, #1364	; 0x554
 8006766:	459c      	cmp	ip, r3
 8006768:	bf95      	itete	ls
 800676a:	ea4f 4c94 	movls.w	ip, r4, lsr #18
 800676e:	f44f 707c 	movhi.w	r0, #1008	; 0x3f0
 8006772:	f10c 0c7c 	addls.w	ip, ip, #124	; 0x7c
 8006776:	f04f 0c7e 	movhi.w	ip, #126	; 0x7e
 800677a:	bf98      	it	ls
 800677c:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8006780:	e73f      	b.n	8006602 <_malloc_r+0xa2>
 8006782:	181a      	adds	r2, r3, r0
 8006784:	f103 0808 	add.w	r8, r3, #8
 8006788:	4630      	mov	r0, r6
 800678a:	6853      	ldr	r3, [r2, #4]
 800678c:	f043 0301 	orr.w	r3, r3, #1
 8006790:	6053      	str	r3, [r2, #4]
 8006792:	f000 f9a5 	bl	8006ae0 <__malloc_unlock>
 8006796:	e719      	b.n	80065cc <_malloc_r+0x6c>
 8006798:	f8d7 8008 	ldr.w	r8, [r7, #8]
 800679c:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80067a0:	f023 0903 	bic.w	r9, r3, #3
 80067a4:	454c      	cmp	r4, r9
 80067a6:	ebc4 0209 	rsb	r2, r4, r9
 80067aa:	bf94      	ite	ls
 80067ac:	2300      	movls	r3, #0
 80067ae:	2301      	movhi	r3, #1
 80067b0:	2a0f      	cmp	r2, #15
 80067b2:	bfd8      	it	le
 80067b4:	f043 0301 	orrle.w	r3, r3, #1
 80067b8:	2b00      	cmp	r3, #0
 80067ba:	f000 80b9 	beq.w	8006930 <_malloc_r+0x3d0>
 80067be:	f641 1a88 	movw	sl, #6536	; 0x1988
 80067c2:	f8d5 3408 	ldr.w	r3, [r5, #1032]	; 0x408
 80067c6:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 80067ca:	4630      	mov	r0, r6
 80067cc:	f1b3 3fff 	cmp.w	r3, #4294967295
 80067d0:	f8da 2000 	ldr.w	r2, [sl]
 80067d4:	f102 0b10 	add.w	fp, r2, #16
 80067d8:	44a3      	add	fp, r4
 80067da:	bf1f      	itttt	ne
 80067dc:	f50b 6b7e 	addne.w	fp, fp, #4064	; 0xfe0
 80067e0:	f10b 0b1f 	addne.w	fp, fp, #31
 80067e4:	f42b 6b7e 	bicne.w	fp, fp, #4064	; 0xfe0
 80067e8:	f02b 0b1f 	bicne.w	fp, fp, #31
 80067ec:	4659      	mov	r1, fp
 80067ee:	f7fa fa33 	bl	8000c58 <_sbrk_r>
 80067f2:	f1b0 3fff 	cmp.w	r0, #4294967295
 80067f6:	4603      	mov	r3, r0
 80067f8:	f000 8118 	beq.w	8006a2c <_malloc_r+0x4cc>
 80067fc:	eb08 0109 	add.w	r1, r8, r9
 8006800:	4281      	cmp	r1, r0
 8006802:	f200 8110 	bhi.w	8006a26 <_malloc_r+0x4c6>
 8006806:	f8da 2004 	ldr.w	r2, [sl, #4]
 800680a:	4281      	cmp	r1, r0
 800680c:	445a      	add	r2, fp
 800680e:	f8ca 2004 	str.w	r2, [sl, #4]
 8006812:	f000 813e 	beq.w	8006a92 <_malloc_r+0x532>
 8006816:	f8d5 e408 	ldr.w	lr, [r5, #1032]	; 0x408
 800681a:	f240 3570 	movw	r5, #880	; 0x370
 800681e:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8006822:	f1be 3fff 	cmp.w	lr, #4294967295
 8006826:	bf17      	itett	ne
 8006828:	1882      	addne	r2, r0, r2
 800682a:	f8c5 0408 	streq.w	r0, [r5, #1032]	; 0x408
 800682e:	ebc1 0102 	rsbne	r1, r1, r2
 8006832:	f8ca 1004 	strne.w	r1, [sl, #4]
 8006836:	f010 0507 	ands.w	r5, r0, #7
 800683a:	bf17      	itett	ne
 800683c:	f1c5 0508 	rsbne	r5, r5, #8
 8006840:	f44f 5580 	moveq.w	r5, #4096	; 0x1000
 8006844:	1943      	addne	r3, r0, r5
 8006846:	f505 5580 	addne.w	r5, r5, #4096	; 0x1000
 800684a:	eb03 020b 	add.w	r2, r3, fp
 800684e:	4630      	mov	r0, r6
 8006850:	9301      	str	r3, [sp, #4]
 8006852:	0512      	lsls	r2, r2, #20
 8006854:	0d12      	lsrs	r2, r2, #20
 8006856:	1aad      	subs	r5, r5, r2
 8006858:	4629      	mov	r1, r5
 800685a:	f7fa f9fd 	bl	8000c58 <_sbrk_r>
 800685e:	9b01      	ldr	r3, [sp, #4]
 8006860:	f1b0 3fff 	cmp.w	r0, #4294967295
 8006864:	f000 812c 	beq.w	8006ac0 <_malloc_r+0x560>
 8006868:	1ac1      	subs	r1, r0, r3
 800686a:	1949      	adds	r1, r1, r5
 800686c:	f041 0101 	orr.w	r1, r1, #1
 8006870:	f8da 2004 	ldr.w	r2, [sl, #4]
 8006874:	45b8      	cmp	r8, r7
 8006876:	f641 1b88 	movw	fp, #6536	; 0x1988
 800687a:	60bb      	str	r3, [r7, #8]
 800687c:	442a      	add	r2, r5
 800687e:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 8006882:	6059      	str	r1, [r3, #4]
 8006884:	f8ca 2004 	str.w	r2, [sl, #4]
 8006888:	d017      	beq.n	80068ba <_malloc_r+0x35a>
 800688a:	f1b9 0f0f 	cmp.w	r9, #15
 800688e:	f240 80e1 	bls.w	8006a54 <_malloc_r+0x4f4>
 8006892:	f1a9 030c 	sub.w	r3, r9, #12
 8006896:	f8d8 5004 	ldr.w	r5, [r8, #4]
 800689a:	f023 0307 	bic.w	r3, r3, #7
 800689e:	2005      	movs	r0, #5
 80068a0:	eb08 0103 	add.w	r1, r8, r3
 80068a4:	2b0f      	cmp	r3, #15
 80068a6:	f005 0501 	and.w	r5, r5, #1
 80068aa:	ea43 0505 	orr.w	r5, r3, r5
 80068ae:	f8c8 5004 	str.w	r5, [r8, #4]
 80068b2:	6048      	str	r0, [r1, #4]
 80068b4:	6088      	str	r0, [r1, #8]
 80068b6:	f200 80fb 	bhi.w	8006ab0 <_malloc_r+0x550>
 80068ba:	f8da 102c 	ldr.w	r1, [sl, #44]	; 0x2c
 80068be:	f641 1388 	movw	r3, #6536	; 0x1988
 80068c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80068c6:	428a      	cmp	r2, r1
 80068c8:	f8da 1030 	ldr.w	r1, [sl, #48]	; 0x30
 80068cc:	bf88      	it	hi
 80068ce:	62da      	strhi	r2, [r3, #44]	; 0x2c
 80068d0:	f641 1388 	movw	r3, #6536	; 0x1988
 80068d4:	428a      	cmp	r2, r1
 80068d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80068da:	f240 80a7 	bls.w	8006a2c <_malloc_r+0x4cc>
 80068de:	f8d7 8008 	ldr.w	r8, [r7, #8]
 80068e2:	631a      	str	r2, [r3, #48]	; 0x30
 80068e4:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80068e8:	f023 0303 	bic.w	r3, r3, #3
 80068ec:	429c      	cmp	r4, r3
 80068ee:	ebc4 0203 	rsb	r2, r4, r3
 80068f2:	bf94      	ite	ls
 80068f4:	2300      	movls	r3, #0
 80068f6:	2301      	movhi	r3, #1
 80068f8:	2a0f      	cmp	r2, #15
 80068fa:	bfd8      	it	le
 80068fc:	f043 0301 	orrle.w	r3, r3, #1
 8006900:	b1b3      	cbz	r3, 8006930 <_malloc_r+0x3d0>
 8006902:	4630      	mov	r0, r6
 8006904:	f04f 0800 	mov.w	r8, #0
 8006908:	f000 f8ea 	bl	8006ae0 <__malloc_unlock>
 800690c:	e65e      	b.n	80065cc <_malloc_r+0x6c>
 800690e:	189a      	adds	r2, r3, r2
 8006910:	68d9      	ldr	r1, [r3, #12]
 8006912:	689c      	ldr	r4, [r3, #8]
 8006914:	f103 0808 	add.w	r8, r3, #8
 8006918:	6855      	ldr	r5, [r2, #4]
 800691a:	4630      	mov	r0, r6
 800691c:	f045 0301 	orr.w	r3, r5, #1
 8006920:	60e1      	str	r1, [r4, #12]
 8006922:	608c      	str	r4, [r1, #8]
 8006924:	6053      	str	r3, [r2, #4]
 8006926:	f000 f8db 	bl	8006ae0 <__malloc_unlock>
 800692a:	e64f      	b.n	80065cc <_malloc_r+0x6c>
 800692c:	20000378 	.word	0x20000378
 8006930:	eb08 0304 	add.w	r3, r8, r4
 8006934:	f042 0201 	orr.w	r2, r2, #1
 8006938:	f044 0401 	orr.w	r4, r4, #1
 800693c:	4630      	mov	r0, r6
 800693e:	f8c8 4004 	str.w	r4, [r8, #4]
 8006942:	f108 0808 	add.w	r8, r8, #8
 8006946:	605a      	str	r2, [r3, #4]
 8006948:	60bb      	str	r3, [r7, #8]
 800694a:	f000 f8c9 	bl	8006ae0 <__malloc_unlock>
 800694e:	e63d      	b.n	80065cc <_malloc_r+0x6c>
 8006950:	0a41      	lsrs	r1, r0, #9
 8006952:	2904      	cmp	r1, #4
 8006954:	bf9c      	itt	ls
 8006956:	ea4f 1e90 	movls.w	lr, r0, lsr #6
 800695a:	f10e 0e38 	addls.w	lr, lr, #56	; 0x38
 800695e:	d91d      	bls.n	800699c <_malloc_r+0x43c>
 8006960:	2914      	cmp	r1, #20
 8006962:	bf98      	it	ls
 8006964:	f101 0e5b 	addls.w	lr, r1, #91	; 0x5b
 8006968:	d918      	bls.n	800699c <_malloc_r+0x43c>
 800696a:	2954      	cmp	r1, #84	; 0x54
 800696c:	bf9c      	itt	ls
 800696e:	ea4f 3e10 	movls.w	lr, r0, lsr #12
 8006972:	f10e 0e6e 	addls.w	lr, lr, #110	; 0x6e
 8006976:	d911      	bls.n	800699c <_malloc_r+0x43c>
 8006978:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
 800697c:	bf9c      	itt	ls
 800697e:	ea4f 3ed0 	movls.w	lr, r0, lsr #15
 8006982:	f10e 0e77 	addls.w	lr, lr, #119	; 0x77
 8006986:	d909      	bls.n	800699c <_malloc_r+0x43c>
 8006988:	f240 5e54 	movw	lr, #1364	; 0x554
 800698c:	4571      	cmp	r1, lr
 800698e:	bf96      	itet	ls
 8006990:	ea4f 4e90 	movls.w	lr, r0, lsr #18
 8006994:	f04f 0e7e 	movhi.w	lr, #126	; 0x7e
 8006998:	f10e 0e7c 	addls.w	lr, lr, #124	; 0x7c
 800699c:	eb07 08ce 	add.w	r8, r7, lr, lsl #3
 80069a0:	f8d8 1008 	ldr.w	r1, [r8, #8]
 80069a4:	4541      	cmp	r1, r8
 80069a6:	d103      	bne.n	80069b0 <_malloc_r+0x450>
 80069a8:	e047      	b.n	8006a3a <_malloc_r+0x4da>
 80069aa:	6889      	ldr	r1, [r1, #8]
 80069ac:	4588      	cmp	r8, r1
 80069ae:	d005      	beq.n	80069bc <_malloc_r+0x45c>
 80069b0:	f8d1 e004 	ldr.w	lr, [r1, #4]
 80069b4:	f02e 0e03 	bic.w	lr, lr, #3
 80069b8:	4570      	cmp	r0, lr
 80069ba:	d3f6      	bcc.n	80069aa <_malloc_r+0x44a>
 80069bc:	f8d1 e00c 	ldr.w	lr, [r1, #12]
 80069c0:	f8c3 e00c 	str.w	lr, [r3, #12]
 80069c4:	6099      	str	r1, [r3, #8]
 80069c6:	6878      	ldr	r0, [r7, #4]
 80069c8:	60cb      	str	r3, [r1, #12]
 80069ca:	f8ce 3008 	str.w	r3, [lr, #8]
 80069ce:	e65d      	b.n	800668c <_malloc_r+0x12c>
 80069d0:	191d      	adds	r5, r3, r4
 80069d2:	f041 0701 	orr.w	r7, r1, #1
 80069d6:	60d5      	str	r5, [r2, #12]
 80069d8:	f044 0401 	orr.w	r4, r4, #1
 80069dc:	6095      	str	r5, [r2, #8]
 80069de:	4630      	mov	r0, r6
 80069e0:	605c      	str	r4, [r3, #4]
 80069e2:	f103 0808 	add.w	r8, r3, #8
 80069e6:	60ea      	str	r2, [r5, #12]
 80069e8:	60aa      	str	r2, [r5, #8]
 80069ea:	606f      	str	r7, [r5, #4]
 80069ec:	5069      	str	r1, [r5, r1]
 80069ee:	f000 f877 	bl	8006ae0 <__malloc_unlock>
 80069f2:	e5eb      	b.n	80065cc <_malloc_r+0x6c>
 80069f4:	f109 0901 	add.w	r9, r9, #1
 80069f8:	f019 0f03 	tst.w	r9, #3
 80069fc:	d02f      	beq.n	8006a5e <_malloc_r+0x4fe>
 80069fe:	f108 0808 	add.w	r8, r8, #8
 8006a02:	e65b      	b.n	80066bc <_malloc_r+0x15c>
 8006a04:	f103 0208 	add.w	r2, r3, #8
 8006a08:	695b      	ldr	r3, [r3, #20]
 8006a0a:	429a      	cmp	r2, r3
 8006a0c:	bf08      	it	eq
 8006a0e:	f10c 0c02 	addeq.w	ip, ip, #2
 8006a12:	f43f ae10 	beq.w	8006636 <_malloc_r+0xd6>
 8006a16:	e5c8      	b.n	80065aa <_malloc_r+0x4a>
 8006a18:	4680      	mov	r8, r0
 8006a1a:	1843      	adds	r3, r0, r1
 8006a1c:	68c2      	ldr	r2, [r0, #12]
 8006a1e:	4630      	mov	r0, r6
 8006a20:	f858 1f08 	ldr.w	r1, [r8, #8]!
 8006a24:	e5ca      	b.n	80065bc <_malloc_r+0x5c>
 8006a26:	45b8      	cmp	r8, r7
 8006a28:	f43f aeed 	beq.w	8006806 <_malloc_r+0x2a6>
 8006a2c:	f8d7 8008 	ldr.w	r8, [r7, #8]
 8006a30:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8006a34:	f023 0303 	bic.w	r3, r3, #3
 8006a38:	e758      	b.n	80068ec <_malloc_r+0x38c>
 8006a3a:	f04f 0901 	mov.w	r9, #1
 8006a3e:	f8d7 8004 	ldr.w	r8, [r7, #4]
 8006a42:	ea4f 00ae 	mov.w	r0, lr, asr #2
 8006a46:	468e      	mov	lr, r1
 8006a48:	fa09 f000 	lsl.w	r0, r9, r0
 8006a4c:	ea48 0000 	orr.w	r0, r8, r0
 8006a50:	6078      	str	r0, [r7, #4]
 8006a52:	e7b5      	b.n	80069c0 <_malloc_r+0x460>
 8006a54:	4698      	mov	r8, r3
 8006a56:	2201      	movs	r2, #1
 8006a58:	605a      	str	r2, [r3, #4]
 8006a5a:	2300      	movs	r3, #0
 8006a5c:	e746      	b.n	80068ec <_malloc_r+0x38c>
 8006a5e:	4651      	mov	r1, sl
 8006a60:	f01c 0f03 	tst.w	ip, #3
 8006a64:	460b      	mov	r3, r1
 8006a66:	f10c 3cff 	add.w	ip, ip, #4294967295
 8006a6a:	d02c      	beq.n	8006ac6 <_malloc_r+0x566>
 8006a6c:	f853 1908 	ldr.w	r1, [r3], #-8
 8006a70:	4299      	cmp	r1, r3
 8006a72:	d0f5      	beq.n	8006a60 <_malloc_r+0x500>
 8006a74:	687b      	ldr	r3, [r7, #4]
 8006a76:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 8006a7a:	459e      	cmp	lr, r3
 8006a7c:	f63f ae8c 	bhi.w	8006798 <_malloc_r+0x238>
 8006a80:	f1be 0f00 	cmp.w	lr, #0
 8006a84:	f43f ae88 	beq.w	8006798 <_malloc_r+0x238>
 8006a88:	ea1e 0f03 	tst.w	lr, r3
 8006a8c:	d020      	beq.n	8006ad0 <_malloc_r+0x570>
 8006a8e:	46cc      	mov	ip, r9
 8006a90:	e610      	b.n	80066b4 <_malloc_r+0x154>
 8006a92:	ea4f 5e01 	mov.w	lr, r1, lsl #20
 8006a96:	ea4f 5e1e 	mov.w	lr, lr, lsr #20
 8006a9a:	f1be 0f00 	cmp.w	lr, #0
 8006a9e:	f47f aeba 	bne.w	8006816 <_malloc_r+0x2b6>
 8006aa2:	68bb      	ldr	r3, [r7, #8]
 8006aa4:	eb0b 0109 	add.w	r1, fp, r9
 8006aa8:	f041 0101 	orr.w	r1, r1, #1
 8006aac:	6059      	str	r1, [r3, #4]
 8006aae:	e704      	b.n	80068ba <_malloc_r+0x35a>
 8006ab0:	4630      	mov	r0, r6
 8006ab2:	f108 0108 	add.w	r1, r8, #8
 8006ab6:	f004 fdf5 	bl	800b6a4 <_free_r>
 8006aba:	f8db 2004 	ldr.w	r2, [fp, #4]
 8006abe:	e6fc      	b.n	80068ba <_malloc_r+0x35a>
 8006ac0:	2101      	movs	r1, #1
 8006ac2:	2500      	movs	r5, #0
 8006ac4:	e6d4      	b.n	8006870 <_malloc_r+0x310>
 8006ac6:	687b      	ldr	r3, [r7, #4]
 8006ac8:	ea23 030e 	bic.w	r3, r3, lr
 8006acc:	607b      	str	r3, [r7, #4]
 8006ace:	e7d1      	b.n	8006a74 <_malloc_r+0x514>
 8006ad0:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 8006ad4:	f109 0904 	add.w	r9, r9, #4
 8006ad8:	e7d6      	b.n	8006a88 <_malloc_r+0x528>
 8006ada:	bf00      	nop

08006adc <__malloc_lock>:
 8006adc:	4770      	bx	lr
 8006ade:	bf00      	nop

08006ae0 <__malloc_unlock>:
 8006ae0:	4770      	bx	lr
 8006ae2:	bf00      	nop

08006ae4 <_printf_r>:
 8006ae4:	b40e      	push	{r1, r2, r3}
 8006ae6:	b510      	push	{r4, lr}
 8006ae8:	4604      	mov	r4, r0
 8006aea:	b083      	sub	sp, #12
 8006aec:	b118      	cbz	r0, 8006af6 <_printf_r+0x12>
 8006aee:	6983      	ldr	r3, [r0, #24]
 8006af0:	b90b      	cbnz	r3, 8006af6 <_printf_r+0x12>
 8006af2:	f004 fc9b 	bl	800b42c <__sinit>
 8006af6:	4620      	mov	r0, r4
 8006af8:	ac06      	add	r4, sp, #24
 8006afa:	9a05      	ldr	r2, [sp, #20]
 8006afc:	4623      	mov	r3, r4
 8006afe:	6881      	ldr	r1, [r0, #8]
 8006b00:	9401      	str	r4, [sp, #4]
 8006b02:	f001 fe01 	bl	8008708 <_vfprintf_r>
 8006b06:	b003      	add	sp, #12
 8006b08:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8006b0c:	b003      	add	sp, #12
 8006b0e:	4770      	bx	lr

08006b10 <printf>:
 8006b10:	b40f      	push	{r0, r1, r2, r3}
 8006b12:	f240 237c 	movw	r3, #636	; 0x27c
 8006b16:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006b1a:	b510      	push	{r4, lr}
 8006b1c:	b082      	sub	sp, #8
 8006b1e:	681c      	ldr	r4, [r3, #0]
 8006b20:	b124      	cbz	r4, 8006b2c <printf+0x1c>
 8006b22:	69a3      	ldr	r3, [r4, #24]
 8006b24:	b913      	cbnz	r3, 8006b2c <printf+0x1c>
 8006b26:	4620      	mov	r0, r4
 8006b28:	f004 fc80 	bl	800b42c <__sinit>
 8006b2c:	4620      	mov	r0, r4
 8006b2e:	ac05      	add	r4, sp, #20
 8006b30:	9a04      	ldr	r2, [sp, #16]
 8006b32:	4623      	mov	r3, r4
 8006b34:	6881      	ldr	r1, [r0, #8]
 8006b36:	9401      	str	r4, [sp, #4]
 8006b38:	f001 fde6 	bl	8008708 <_vfprintf_r>
 8006b3c:	b002      	add	sp, #8
 8006b3e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8006b42:	b004      	add	sp, #16
 8006b44:	4770      	bx	lr
 8006b46:	bf00      	nop

08006b48 <setbuf>:
 8006b48:	2900      	cmp	r1, #0
 8006b4a:	bf0c      	ite	eq
 8006b4c:	2202      	moveq	r2, #2
 8006b4e:	2200      	movne	r2, #0
 8006b50:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006b54:	f000 b800 	b.w	8006b58 <setvbuf>

08006b58 <setvbuf>:
 8006b58:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8006b5c:	f240 257c 	movw	r5, #636	; 0x27c
 8006b60:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8006b64:	4604      	mov	r4, r0
 8006b66:	460e      	mov	r6, r1
 8006b68:	4617      	mov	r7, r2
 8006b6a:	6828      	ldr	r0, [r5, #0]
 8006b6c:	4698      	mov	r8, r3
 8006b6e:	b110      	cbz	r0, 8006b76 <setvbuf+0x1e>
 8006b70:	6983      	ldr	r3, [r0, #24]
 8006b72:	2b00      	cmp	r3, #0
 8006b74:	d05a      	beq.n	8006c2c <setvbuf+0xd4>
 8006b76:	f240 13c0 	movw	r3, #448	; 0x1c0
 8006b7a:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006b7e:	429c      	cmp	r4, r3
 8006b80:	d05c      	beq.n	8006c3c <setvbuf+0xe4>
 8006b82:	f240 13e0 	movw	r3, #480	; 0x1e0
 8006b86:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006b8a:	429c      	cmp	r4, r3
 8006b8c:	d059      	beq.n	8006c42 <setvbuf+0xea>
 8006b8e:	f240 2300 	movw	r3, #512	; 0x200
 8006b92:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006b96:	429c      	cmp	r4, r3
 8006b98:	bf04      	itt	eq
 8006b9a:	682b      	ldreq	r3, [r5, #0]
 8006b9c:	68dc      	ldreq	r4, [r3, #12]
 8006b9e:	2f02      	cmp	r7, #2
 8006ba0:	bf94      	ite	ls
 8006ba2:	f04f 0900 	movls.w	r9, #0
 8006ba6:	f04f 0901 	movhi.w	r9, #1
 8006baa:	ea59 79d8 	orrs.w	r9, r9, r8, lsr #31
 8006bae:	bf18      	it	ne
 8006bb0:	f04f 30ff 	movne.w	r0, #4294967295
 8006bb4:	d001      	beq.n	8006bba <setvbuf+0x62>
 8006bb6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006bba:	6828      	ldr	r0, [r5, #0]
 8006bbc:	4621      	mov	r1, r4
 8006bbe:	f004 fb17 	bl	800b1f0 <_fflush_r>
 8006bc2:	89a2      	ldrh	r2, [r4, #12]
 8006bc4:	f240 237c 	movw	r3, #636	; 0x27c
 8006bc8:	f8c4 9004 	str.w	r9, [r4, #4]
 8006bcc:	f012 0f80 	tst.w	r2, #128	; 0x80
 8006bd0:	f8c4 9018 	str.w	r9, [r4, #24]
 8006bd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006bd8:	d136      	bne.n	8006c48 <setvbuf+0xf0>
 8006bda:	2f02      	cmp	r7, #2
 8006bdc:	f64f 737c 	movw	r3, #65404	; 0xff7c
 8006be0:	ea02 0303 	and.w	r3, r2, r3
 8006be4:	81a3      	strh	r3, [r4, #12]
 8006be6:	d035      	beq.n	8006c54 <setvbuf+0xfc>
 8006be8:	2e00      	cmp	r6, #0
 8006bea:	d041      	beq.n	8006c70 <setvbuf+0x118>
 8006bec:	2f01      	cmp	r7, #1
 8006bee:	6829      	ldr	r1, [r5, #0]
 8006bf0:	bf01      	itttt	eq
 8006bf2:	f043 0301 	orreq.w	r3, r3, #1
 8006bf6:	81a3      	strheq	r3, [r4, #12]
 8006bf8:	f1c8 0200 	rsbeq	r2, r8, #0
 8006bfc:	61a2      	streq	r2, [r4, #24]
 8006bfe:	b29b      	uxth	r3, r3
 8006c00:	f24b 32e5 	movw	r2, #46053	; 0xb3e5
 8006c04:	f013 0008 	ands.w	r0, r3, #8
 8006c08:	f6c0 0200 	movt	r2, #2048	; 0x800
 8006c0c:	628a      	str	r2, [r1, #40]	; 0x28
 8006c0e:	6026      	str	r6, [r4, #0]
 8006c10:	6126      	str	r6, [r4, #16]
 8006c12:	f8c4 8014 	str.w	r8, [r4, #20]
 8006c16:	d0ce      	beq.n	8006bb6 <setvbuf+0x5e>
 8006c18:	f013 0f03 	tst.w	r3, #3
 8006c1c:	f04f 0000 	mov.w	r0, #0
 8006c20:	bf0c      	ite	eq
 8006c22:	4643      	moveq	r3, r8
 8006c24:	4603      	movne	r3, r0
 8006c26:	60a3      	str	r3, [r4, #8]
 8006c28:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006c2c:	f004 fbfe 	bl	800b42c <__sinit>
 8006c30:	f240 13c0 	movw	r3, #448	; 0x1c0
 8006c34:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006c38:	429c      	cmp	r4, r3
 8006c3a:	d1a2      	bne.n	8006b82 <setvbuf+0x2a>
 8006c3c:	682b      	ldr	r3, [r5, #0]
 8006c3e:	685c      	ldr	r4, [r3, #4]
 8006c40:	e7ad      	b.n	8006b9e <setvbuf+0x46>
 8006c42:	682b      	ldr	r3, [r5, #0]
 8006c44:	689c      	ldr	r4, [r3, #8]
 8006c46:	e7aa      	b.n	8006b9e <setvbuf+0x46>
 8006c48:	6818      	ldr	r0, [r3, #0]
 8006c4a:	6921      	ldr	r1, [r4, #16]
 8006c4c:	f004 fd2a 	bl	800b6a4 <_free_r>
 8006c50:	89a2      	ldrh	r2, [r4, #12]
 8006c52:	e7c2      	b.n	8006bda <setvbuf+0x82>
 8006c54:	2000      	movs	r0, #0
 8006c56:	f104 0247 	add.w	r2, r4, #71	; 0x47
 8006c5a:	f043 0302 	orr.w	r3, r3, #2
 8006c5e:	6022      	str	r2, [r4, #0]
 8006c60:	81a3      	strh	r3, [r4, #12]
 8006c62:	2300      	movs	r3, #0
 8006c64:	6122      	str	r2, [r4, #16]
 8006c66:	60a3      	str	r3, [r4, #8]
 8006c68:	2301      	movs	r3, #1
 8006c6a:	6163      	str	r3, [r4, #20]
 8006c6c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006c70:	f1b8 0f00 	cmp.w	r8, #0
 8006c74:	bf08      	it	eq
 8006c76:	f44f 6880 	moveq.w	r8, #1024	; 0x400
 8006c7a:	4640      	mov	r0, r8
 8006c7c:	f7ff fc60 	bl	8006540 <malloc>
 8006c80:	4606      	mov	r6, r0
 8006c82:	b128      	cbz	r0, 8006c90 <setvbuf+0x138>
 8006c84:	89a3      	ldrh	r3, [r4, #12]
 8006c86:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006c8a:	b29b      	uxth	r3, r3
 8006c8c:	81a3      	strh	r3, [r4, #12]
 8006c8e:	e7ad      	b.n	8006bec <setvbuf+0x94>
 8006c90:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8006c94:	f7ff fc54 	bl	8006540 <malloc>
 8006c98:	4606      	mov	r6, r0
 8006c9a:	b918      	cbnz	r0, 8006ca4 <setvbuf+0x14c>
 8006c9c:	89a3      	ldrh	r3, [r4, #12]
 8006c9e:	f04f 30ff 	mov.w	r0, #4294967295
 8006ca2:	e7d8      	b.n	8006c56 <setvbuf+0xfe>
 8006ca4:	f44f 6880 	mov.w	r8, #1024	; 0x400
 8006ca8:	e7ec      	b.n	8006c84 <setvbuf+0x12c>
 8006caa:	bf00      	nop

08006cac <_snprintf_r>:
 8006cac:	b408      	push	{r3}
 8006cae:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006cb0:	1e14      	subs	r4, r2, #0
 8006cb2:	b09c      	sub	sp, #112	; 0x70
 8006cb4:	4605      	mov	r5, r0
 8006cb6:	db25      	blt.n	8006d04 <_snprintf_r+0x58>
 8006cb8:	ae22      	add	r6, sp, #136	; 0x88
 8006cba:	f44f 7302 	mov.w	r3, #520	; 0x208
 8006cbe:	9101      	str	r1, [sp, #4]
 8006cc0:	bf08      	it	eq
 8006cc2:	4627      	moveq	r7, r4
 8006cc4:	f8ad 3010 	strh.w	r3, [sp, #16]
 8006cc8:	4633      	mov	r3, r6
 8006cca:	9105      	str	r1, [sp, #20]
 8006ccc:	a901      	add	r1, sp, #4
 8006cce:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8006cd0:	bf18      	it	ne
 8006cd2:	1e67      	subne	r7, r4, #1
 8006cd4:	961b      	str	r6, [sp, #108]	; 0x6c
 8006cd6:	9703      	str	r7, [sp, #12]
 8006cd8:	9706      	str	r7, [sp, #24]
 8006cda:	f04f 37ff 	mov.w	r7, #4294967295
 8006cde:	f8ad 7012 	strh.w	r7, [sp, #18]
 8006ce2:	f000 f9bf 	bl	8007064 <_svfprintf_r>
 8006ce6:	f1b0 3fff 	cmp.w	r0, #4294967295
 8006cea:	db08      	blt.n	8006cfe <_snprintf_r+0x52>
 8006cec:	b114      	cbz	r4, 8006cf4 <_snprintf_r+0x48>
 8006cee:	9b01      	ldr	r3, [sp, #4]
 8006cf0:	2200      	movs	r2, #0
 8006cf2:	701a      	strb	r2, [r3, #0]
 8006cf4:	b01c      	add	sp, #112	; 0x70
 8006cf6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8006cfa:	b001      	add	sp, #4
 8006cfc:	4770      	bx	lr
 8006cfe:	238b      	movs	r3, #139	; 0x8b
 8006d00:	602b      	str	r3, [r5, #0]
 8006d02:	e7f3      	b.n	8006cec <_snprintf_r+0x40>
 8006d04:	238b      	movs	r3, #139	; 0x8b
 8006d06:	f04f 30ff 	mov.w	r0, #4294967295
 8006d0a:	602b      	str	r3, [r5, #0]
 8006d0c:	e7f2      	b.n	8006cf4 <_snprintf_r+0x48>
 8006d0e:	bf00      	nop

08006d10 <snprintf>:
 8006d10:	b40c      	push	{r2, r3}
 8006d12:	f240 237c 	movw	r3, #636	; 0x27c
 8006d16:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006d18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006d1c:	1e0c      	subs	r4, r1, #0
 8006d1e:	b09d      	sub	sp, #116	; 0x74
 8006d20:	681d      	ldr	r5, [r3, #0]
 8006d22:	db26      	blt.n	8006d72 <snprintf+0x62>
 8006d24:	ae23      	add	r6, sp, #140	; 0x8c
 8006d26:	f44f 7302 	mov.w	r3, #520	; 0x208
 8006d2a:	9001      	str	r0, [sp, #4]
 8006d2c:	a901      	add	r1, sp, #4
 8006d2e:	f8ad 3010 	strh.w	r3, [sp, #16]
 8006d32:	4633      	mov	r3, r6
 8006d34:	9005      	str	r0, [sp, #20]
 8006d36:	4628      	mov	r0, r5
 8006d38:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8006d3a:	bf08      	it	eq
 8006d3c:	4627      	moveq	r7, r4
 8006d3e:	961b      	str	r6, [sp, #108]	; 0x6c
 8006d40:	bf18      	it	ne
 8006d42:	1e67      	subne	r7, r4, #1
 8006d44:	9703      	str	r7, [sp, #12]
 8006d46:	9706      	str	r7, [sp, #24]
 8006d48:	f04f 37ff 	mov.w	r7, #4294967295
 8006d4c:	f8ad 7012 	strh.w	r7, [sp, #18]
 8006d50:	f000 f988 	bl	8007064 <_svfprintf_r>
 8006d54:	f1b0 3fff 	cmp.w	r0, #4294967295
 8006d58:	db08      	blt.n	8006d6c <snprintf+0x5c>
 8006d5a:	b114      	cbz	r4, 8006d62 <snprintf+0x52>
 8006d5c:	9b01      	ldr	r3, [sp, #4]
 8006d5e:	2200      	movs	r2, #0
 8006d60:	701a      	strb	r2, [r3, #0]
 8006d62:	b01d      	add	sp, #116	; 0x74
 8006d64:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8006d68:	b002      	add	sp, #8
 8006d6a:	4770      	bx	lr
 8006d6c:	238b      	movs	r3, #139	; 0x8b
 8006d6e:	602b      	str	r3, [r5, #0]
 8006d70:	e7f3      	b.n	8006d5a <snprintf+0x4a>
 8006d72:	238b      	movs	r3, #139	; 0x8b
 8006d74:	f04f 30ff 	mov.w	r0, #4294967295
 8006d78:	602b      	str	r3, [r5, #0]
 8006d7a:	e7f2      	b.n	8006d62 <snprintf+0x52>

08006d7c <_sprintf_r>:
 8006d7c:	b40c      	push	{r2, r3}
 8006d7e:	f44f 7302 	mov.w	r3, #520	; 0x208
 8006d82:	b570      	push	{r4, r5, r6, lr}
 8006d84:	b09c      	sub	sp, #112	; 0x70
 8006d86:	ac20      	add	r4, sp, #128	; 0x80
 8006d88:	460e      	mov	r6, r1
 8006d8a:	f8ad 3010 	strh.w	r3, [sp, #16]
 8006d8e:	a901      	add	r1, sp, #4
 8006d90:	f854 2b04 	ldr.w	r2, [r4], #4
 8006d94:	f04f 33ff 	mov.w	r3, #4294967295
 8006d98:	f8ad 3012 	strh.w	r3, [sp, #18]
 8006d9c:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
 8006da0:	4623      	mov	r3, r4
 8006da2:	9601      	str	r6, [sp, #4]
 8006da4:	9605      	str	r6, [sp, #20]
 8006da6:	9503      	str	r5, [sp, #12]
 8006da8:	9506      	str	r5, [sp, #24]
 8006daa:	941b      	str	r4, [sp, #108]	; 0x6c
 8006dac:	f000 f95a 	bl	8007064 <_svfprintf_r>
 8006db0:	9b01      	ldr	r3, [sp, #4]
 8006db2:	2200      	movs	r2, #0
 8006db4:	701a      	strb	r2, [r3, #0]
 8006db6:	b01c      	add	sp, #112	; 0x70
 8006db8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8006dbc:	b002      	add	sp, #8
 8006dbe:	4770      	bx	lr

08006dc0 <sprintf>:
 8006dc0:	b40e      	push	{r1, r2, r3}
 8006dc2:	f240 237c 	movw	r3, #636	; 0x27c
 8006dc6:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006dc8:	b09c      	sub	sp, #112	; 0x70
 8006dca:	ac21      	add	r4, sp, #132	; 0x84
 8006dcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006dd0:	4606      	mov	r6, r0
 8006dd2:	a901      	add	r1, sp, #4
 8006dd4:	f854 2b04 	ldr.w	r2, [r4], #4
 8006dd8:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
 8006ddc:	6818      	ldr	r0, [r3, #0]
 8006dde:	f44f 7702 	mov.w	r7, #520	; 0x208
 8006de2:	4623      	mov	r3, r4
 8006de4:	9601      	str	r6, [sp, #4]
 8006de6:	9605      	str	r6, [sp, #20]
 8006de8:	f04f 36ff 	mov.w	r6, #4294967295
 8006dec:	f8ad 7010 	strh.w	r7, [sp, #16]
 8006df0:	f8ad 6012 	strh.w	r6, [sp, #18]
 8006df4:	9503      	str	r5, [sp, #12]
 8006df6:	9506      	str	r5, [sp, #24]
 8006df8:	941b      	str	r4, [sp, #108]	; 0x6c
 8006dfa:	f000 f933 	bl	8007064 <_svfprintf_r>
 8006dfe:	9b01      	ldr	r3, [sp, #4]
 8006e00:	2200      	movs	r2, #0
 8006e02:	701a      	strb	r2, [r3, #0]
 8006e04:	b01c      	add	sp, #112	; 0x70
 8006e06:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8006e0a:	b003      	add	sp, #12
 8006e0c:	4770      	bx	lr
 8006e0e:	bf00      	nop

08006e10 <strcmp>:
 8006e10:	ea80 0201 	eor.w	r2, r0, r1
 8006e14:	f012 0f03 	tst.w	r2, #3
 8006e18:	d13a      	bne.n	8006e90 <strcmp_unaligned>
 8006e1a:	f010 0203 	ands.w	r2, r0, #3
 8006e1e:	f020 0003 	bic.w	r0, r0, #3
 8006e22:	f021 0103 	bic.w	r1, r1, #3
 8006e26:	f850 cb04 	ldr.w	ip, [r0], #4
 8006e2a:	bf08      	it	eq
 8006e2c:	f851 3b04 	ldreq.w	r3, [r1], #4
 8006e30:	d00d      	beq.n	8006e4e <strcmp+0x3e>
 8006e32:	f082 0203 	eor.w	r2, r2, #3
 8006e36:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8006e3a:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8006e3e:	fa23 f202 	lsr.w	r2, r3, r2
 8006e42:	f851 3b04 	ldr.w	r3, [r1], #4
 8006e46:	ea4c 0c02 	orr.w	ip, ip, r2
 8006e4a:	ea43 0302 	orr.w	r3, r3, r2
 8006e4e:	bf00      	nop
 8006e50:	f1ac 3201 	sub.w	r2, ip, #16843009	; 0x1010101
 8006e54:	459c      	cmp	ip, r3
 8006e56:	bf01      	itttt	eq
 8006e58:	ea22 020c 	biceq.w	r2, r2, ip
 8006e5c:	f012 3f80 	tsteq.w	r2, #2155905152	; 0x80808080
 8006e60:	f850 cb04 	ldreq.w	ip, [r0], #4
 8006e64:	f851 3b04 	ldreq.w	r3, [r1], #4
 8006e68:	d0f2      	beq.n	8006e50 <strcmp+0x40>
 8006e6a:	ea4f 600c 	mov.w	r0, ip, lsl #24
 8006e6e:	ea4f 2c1c 	mov.w	ip, ip, lsr #8
 8006e72:	2801      	cmp	r0, #1
 8006e74:	bf28      	it	cs
 8006e76:	ebb0 6f03 	cmpcs.w	r0, r3, lsl #24
 8006e7a:	bf08      	it	eq
 8006e7c:	0a1b      	lsreq	r3, r3, #8
 8006e7e:	d0f4      	beq.n	8006e6a <strcmp+0x5a>
 8006e80:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8006e84:	ea4f 6010 	mov.w	r0, r0, lsr #24
 8006e88:	eba0 0003 	sub.w	r0, r0, r3
 8006e8c:	4770      	bx	lr
 8006e8e:	bf00      	nop

08006e90 <strcmp_unaligned>:
 8006e90:	f010 0f03 	tst.w	r0, #3
 8006e94:	d00a      	beq.n	8006eac <strcmp_unaligned+0x1c>
 8006e96:	f810 2b01 	ldrb.w	r2, [r0], #1
 8006e9a:	f811 3b01 	ldrb.w	r3, [r1], #1
 8006e9e:	2a01      	cmp	r2, #1
 8006ea0:	bf28      	it	cs
 8006ea2:	429a      	cmpcs	r2, r3
 8006ea4:	d0f4      	beq.n	8006e90 <strcmp_unaligned>
 8006ea6:	eba2 0003 	sub.w	r0, r2, r3
 8006eaa:	4770      	bx	lr
 8006eac:	f84d 5d04 	str.w	r5, [sp, #-4]!
 8006eb0:	f84d 4d04 	str.w	r4, [sp, #-4]!
 8006eb4:	f04f 0201 	mov.w	r2, #1
 8006eb8:	ea42 2202 	orr.w	r2, r2, r2, lsl #8
 8006ebc:	ea42 4202 	orr.w	r2, r2, r2, lsl #16
 8006ec0:	f001 0c03 	and.w	ip, r1, #3
 8006ec4:	f021 0103 	bic.w	r1, r1, #3
 8006ec8:	f850 4b04 	ldr.w	r4, [r0], #4
 8006ecc:	f851 5b04 	ldr.w	r5, [r1], #4
 8006ed0:	f1bc 0f02 	cmp.w	ip, #2
 8006ed4:	d026      	beq.n	8006f24 <strcmp_unaligned+0x94>
 8006ed6:	d84b      	bhi.n	8006f70 <strcmp_unaligned+0xe0>
 8006ed8:	f024 4c7f 	bic.w	ip, r4, #4278190080	; 0xff000000
 8006edc:	ebbc 2f15 	cmp.w	ip, r5, lsr #8
 8006ee0:	eba4 0302 	sub.w	r3, r4, r2
 8006ee4:	ea23 0304 	bic.w	r3, r3, r4
 8006ee8:	d10d      	bne.n	8006f06 <strcmp_unaligned+0x76>
 8006eea:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 8006eee:	bf08      	it	eq
 8006ef0:	f851 5b04 	ldreq.w	r5, [r1], #4
 8006ef4:	d10a      	bne.n	8006f0c <strcmp_unaligned+0x7c>
 8006ef6:	ea8c 0c04 	eor.w	ip, ip, r4
 8006efa:	ebbc 6f05 	cmp.w	ip, r5, lsl #24
 8006efe:	d10c      	bne.n	8006f1a <strcmp_unaligned+0x8a>
 8006f00:	f850 4b04 	ldr.w	r4, [r0], #4
 8006f04:	e7e8      	b.n	8006ed8 <strcmp_unaligned+0x48>
 8006f06:	ea4f 2515 	mov.w	r5, r5, lsr #8
 8006f0a:	e05c      	b.n	8006fc6 <strcmp_unaligned+0x136>
 8006f0c:	f033 437f 	bics.w	r3, r3, #4278190080	; 0xff000000
 8006f10:	d152      	bne.n	8006fb8 <strcmp_unaligned+0x128>
 8006f12:	780d      	ldrb	r5, [r1, #0]
 8006f14:	ea4f 6c14 	mov.w	ip, r4, lsr #24
 8006f18:	e055      	b.n	8006fc6 <strcmp_unaligned+0x136>
 8006f1a:	ea4f 6c14 	mov.w	ip, r4, lsr #24
 8006f1e:	f005 05ff 	and.w	r5, r5, #255	; 0xff
 8006f22:	e050      	b.n	8006fc6 <strcmp_unaligned+0x136>
 8006f24:	ea4f 4c04 	mov.w	ip, r4, lsl #16
 8006f28:	eba4 0302 	sub.w	r3, r4, r2
 8006f2c:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 8006f30:	ea23 0304 	bic.w	r3, r3, r4
 8006f34:	ebbc 4f15 	cmp.w	ip, r5, lsr #16
 8006f38:	d117      	bne.n	8006f6a <strcmp_unaligned+0xda>
 8006f3a:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 8006f3e:	bf08      	it	eq
 8006f40:	f851 5b04 	ldreq.w	r5, [r1], #4
 8006f44:	d107      	bne.n	8006f56 <strcmp_unaligned+0xc6>
 8006f46:	ea8c 0c04 	eor.w	ip, ip, r4
 8006f4a:	ebbc 4f05 	cmp.w	ip, r5, lsl #16
 8006f4e:	d108      	bne.n	8006f62 <strcmp_unaligned+0xd2>
 8006f50:	f850 4b04 	ldr.w	r4, [r0], #4
 8006f54:	e7e6      	b.n	8006f24 <strcmp_unaligned+0x94>
 8006f56:	041b      	lsls	r3, r3, #16
 8006f58:	d12e      	bne.n	8006fb8 <strcmp_unaligned+0x128>
 8006f5a:	880d      	ldrh	r5, [r1, #0]
 8006f5c:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 8006f60:	e031      	b.n	8006fc6 <strcmp_unaligned+0x136>
 8006f62:	ea4f 4505 	mov.w	r5, r5, lsl #16
 8006f66:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 8006f6a:	ea4f 4515 	mov.w	r5, r5, lsr #16
 8006f6e:	e02a      	b.n	8006fc6 <strcmp_unaligned+0x136>
 8006f70:	f004 0cff 	and.w	ip, r4, #255	; 0xff
 8006f74:	ebbc 6f15 	cmp.w	ip, r5, lsr #24
 8006f78:	eba4 0302 	sub.w	r3, r4, r2
 8006f7c:	ea23 0304 	bic.w	r3, r3, r4
 8006f80:	d10d      	bne.n	8006f9e <strcmp_unaligned+0x10e>
 8006f82:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 8006f86:	bf08      	it	eq
 8006f88:	f851 5b04 	ldreq.w	r5, [r1], #4
 8006f8c:	d10a      	bne.n	8006fa4 <strcmp_unaligned+0x114>
 8006f8e:	ea8c 0c04 	eor.w	ip, ip, r4
 8006f92:	ebbc 2f05 	cmp.w	ip, r5, lsl #8
 8006f96:	d10a      	bne.n	8006fae <strcmp_unaligned+0x11e>
 8006f98:	f850 4b04 	ldr.w	r4, [r0], #4
 8006f9c:	e7e8      	b.n	8006f70 <strcmp_unaligned+0xe0>
 8006f9e:	ea4f 6515 	mov.w	r5, r5, lsr #24
 8006fa2:	e010      	b.n	8006fc6 <strcmp_unaligned+0x136>
 8006fa4:	f014 0fff 	tst.w	r4, #255	; 0xff
 8006fa8:	d006      	beq.n	8006fb8 <strcmp_unaligned+0x128>
 8006faa:	f851 5b04 	ldr.w	r5, [r1], #4
 8006fae:	ea4f 2c14 	mov.w	ip, r4, lsr #8
 8006fb2:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
 8006fb6:	e006      	b.n	8006fc6 <strcmp_unaligned+0x136>
 8006fb8:	f04f 0000 	mov.w	r0, #0
 8006fbc:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006fc0:	f85d 5b04 	ldr.w	r5, [sp], #4
 8006fc4:	4770      	bx	lr
 8006fc6:	f00c 02ff 	and.w	r2, ip, #255	; 0xff
 8006fca:	f005 00ff 	and.w	r0, r5, #255	; 0xff
 8006fce:	2801      	cmp	r0, #1
 8006fd0:	bf28      	it	cs
 8006fd2:	4290      	cmpcs	r0, r2
 8006fd4:	bf04      	itt	eq
 8006fd6:	ea4f 2c1c 	moveq.w	ip, ip, lsr #8
 8006fda:	0a2d      	lsreq	r5, r5, #8
 8006fdc:	d0f3      	beq.n	8006fc6 <strcmp_unaligned+0x136>
 8006fde:	eba2 0000 	sub.w	r0, r2, r0
 8006fe2:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006fe6:	f85d 5b04 	ldr.w	r5, [sp], #4
 8006fea:	4770      	bx	lr

08006fec <strncpy>:
 8006fec:	ea41 0300 	orr.w	r3, r1, r0
 8006ff0:	f013 0f03 	tst.w	r3, #3
 8006ff4:	460b      	mov	r3, r1
 8006ff6:	b470      	push	{r4, r5, r6}
 8006ff8:	bf14      	ite	ne
 8006ffa:	2400      	movne	r4, #0
 8006ffc:	2401      	moveq	r4, #1
 8006ffe:	2a03      	cmp	r2, #3
 8007000:	bf94      	ite	ls
 8007002:	2400      	movls	r4, #0
 8007004:	f004 0401 	andhi.w	r4, r4, #1
 8007008:	4605      	mov	r5, r0
 800700a:	b9d4      	cbnz	r4, 8007042 <strncpy+0x56>
 800700c:	b1ba      	cbz	r2, 800703e <strncpy+0x52>
 800700e:	780e      	ldrb	r6, [r1, #0]
 8007010:	462b      	mov	r3, r5
 8007012:	3a01      	subs	r2, #1
 8007014:	f803 6b01 	strb.w	r6, [r3], #1
 8007018:	b156      	cbz	r6, 8007030 <strncpy+0x44>
 800701a:	1cac      	adds	r4, r5, #2
 800701c:	b17a      	cbz	r2, 800703e <strncpy+0x52>
 800701e:	f811 5f01 	ldrb.w	r5, [r1, #1]!
 8007022:	4623      	mov	r3, r4
 8007024:	3a01      	subs	r2, #1
 8007026:	f804 5c01 	strb.w	r5, [r4, #-1]
 800702a:	3401      	adds	r4, #1
 800702c:	2d00      	cmp	r5, #0
 800702e:	d1f5      	bne.n	800701c <strncpy+0x30>
 8007030:	b12a      	cbz	r2, 800703e <strncpy+0x52>
 8007032:	189a      	adds	r2, r3, r2
 8007034:	2100      	movs	r1, #0
 8007036:	f803 1b01 	strb.w	r1, [r3], #1
 800703a:	4293      	cmp	r3, r2
 800703c:	d1fb      	bne.n	8007036 <strncpy+0x4a>
 800703e:	bc70      	pop	{r4, r5, r6}
 8007040:	4770      	bx	lr
 8007042:	4619      	mov	r1, r3
 8007044:	f853 4b04 	ldr.w	r4, [r3], #4
 8007048:	f1a4 3601 	sub.w	r6, r4, #16843009	; 0x1010101
 800704c:	ea26 0604 	bic.w	r6, r6, r4
 8007050:	f016 3f80 	tst.w	r6, #2155905152	; 0x80808080
 8007054:	d1da      	bne.n	800700c <strncpy+0x20>
 8007056:	3a04      	subs	r2, #4
 8007058:	f845 4b04 	str.w	r4, [r5], #4
 800705c:	2a03      	cmp	r2, #3
 800705e:	4619      	mov	r1, r3
 8007060:	d8ef      	bhi.n	8007042 <strncpy+0x56>
 8007062:	e7d3      	b.n	800700c <strncpy+0x20>

08007064 <_svfprintf_r>:
 8007064:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007068:	b0c5      	sub	sp, #276	; 0x114
 800706a:	4614      	mov	r4, r2
 800706c:	9312      	str	r3, [sp, #72]	; 0x48
 800706e:	910c      	str	r1, [sp, #48]	; 0x30
 8007070:	9011      	str	r0, [sp, #68]	; 0x44
 8007072:	f004 fc79 	bl	800b968 <_localeconv_r>
 8007076:	6800      	ldr	r0, [r0, #0]
 8007078:	9019      	str	r0, [sp, #100]	; 0x64
 800707a:	f005 fc1b 	bl	800c8b4 <strlen>
 800707e:	901c      	str	r0, [sp, #112]	; 0x70
 8007080:	980c      	ldr	r0, [sp, #48]	; 0x30
 8007082:	8983      	ldrh	r3, [r0, #12]
 8007084:	f013 0f80 	tst.w	r3, #128	; 0x80
 8007088:	d003      	beq.n	8007092 <_svfprintf_r+0x2e>
 800708a:	6903      	ldr	r3, [r0, #16]
 800708c:	2b00      	cmp	r3, #0
 800708e:	f001 816f 	beq.w	8008370 <_svfprintf_r+0x130c>
 8007092:	f10d 0a7c 	add.w	sl, sp, #124	; 0x7c
 8007096:	2300      	movs	r3, #0
 8007098:	4656      	mov	r6, sl
 800709a:	f10d 01f7 	add.w	r1, sp, #247	; 0xf7
 800709e:	930e      	str	r3, [sp, #56]	; 0x38
 80070a0:	9409      	str	r4, [sp, #36]	; 0x24
 80070a2:	931a      	str	r3, [sp, #104]	; 0x68
 80070a4:	931b      	str	r3, [sp, #108]	; 0x6c
 80070a6:	9317      	str	r3, [sp, #92]	; 0x5c
 80070a8:	931d      	str	r3, [sp, #116]	; 0x74
 80070aa:	930f      	str	r3, [sp, #60]	; 0x3c
 80070ac:	9107      	str	r1, [sp, #28]
 80070ae:	f8cd a0e4 	str.w	sl, [sp, #228]	; 0xe4
 80070b2:	933b      	str	r3, [sp, #236]	; 0xec
 80070b4:	933a      	str	r3, [sp, #232]	; 0xe8
 80070b6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80070b8:	7813      	ldrb	r3, [r2, #0]
 80070ba:	f1b3 0225 	subs.w	r2, r3, #37	; 0x25
 80070be:	bf18      	it	ne
 80070c0:	2201      	movne	r2, #1
 80070c2:	2b00      	cmp	r3, #0
 80070c4:	bf0c      	ite	eq
 80070c6:	2300      	moveq	r3, #0
 80070c8:	f002 0301 	andne.w	r3, r2, #1
 80070cc:	2b00      	cmp	r3, #0
 80070ce:	f000 80bd 	beq.w	800724c <_svfprintf_r+0x1e8>
 80070d2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80070d4:	1c5a      	adds	r2, r3, #1
 80070d6:	4617      	mov	r7, r2
 80070d8:	3201      	adds	r2, #1
 80070da:	783b      	ldrb	r3, [r7, #0]
 80070dc:	1e19      	subs	r1, r3, #0
 80070de:	bf18      	it	ne
 80070e0:	2101      	movne	r1, #1
 80070e2:	2b25      	cmp	r3, #37	; 0x25
 80070e4:	bf0c      	ite	eq
 80070e6:	2300      	moveq	r3, #0
 80070e8:	f001 0301 	andne.w	r3, r1, #1
 80070ec:	2b00      	cmp	r3, #0
 80070ee:	d1f2      	bne.n	80070d6 <_svfprintf_r+0x72>
 80070f0:	9c09      	ldr	r4, [sp, #36]	; 0x24
 80070f2:	ebb7 0804 	subs.w	r8, r7, r4
 80070f6:	d010      	beq.n	800711a <_svfprintf_r+0xb6>
 80070f8:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80070fa:	9809      	ldr	r0, [sp, #36]	; 0x24
 80070fc:	3401      	adds	r4, #1
 80070fe:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007100:	2c07      	cmp	r4, #7
 8007102:	f8c6 8004 	str.w	r8, [r6, #4]
 8007106:	6030      	str	r0, [r6, #0]
 8007108:	4445      	add	r5, r8
 800710a:	943a      	str	r4, [sp, #232]	; 0xe8
 800710c:	953b      	str	r5, [sp, #236]	; 0xec
 800710e:	f300 8081 	bgt.w	8007214 <_svfprintf_r+0x1b0>
 8007112:	3608      	adds	r6, #8
 8007114:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8007116:	4441      	add	r1, r8
 8007118:	910f      	str	r1, [sp, #60]	; 0x3c
 800711a:	783b      	ldrb	r3, [r7, #0]
 800711c:	2b00      	cmp	r3, #0
 800711e:	f000 8081 	beq.w	8007224 <_svfprintf_r+0x1c0>
 8007122:	1c7c      	adds	r4, r7, #1
 8007124:	2200      	movs	r2, #0
 8007126:	2300      	movs	r3, #0
 8007128:	920d      	str	r2, [sp, #52]	; 0x34
 800712a:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
 800712e:	2520      	movs	r5, #32
 8007130:	9409      	str	r4, [sp, #36]	; 0x24
 8007132:	212b      	movs	r1, #43	; 0x2b
 8007134:	787b      	ldrb	r3, [r7, #1]
 8007136:	f04f 37ff 	mov.w	r7, #4294967295
 800713a:	9208      	str	r2, [sp, #32]
 800713c:	4622      	mov	r2, r4
 800713e:	3201      	adds	r2, #1
 8007140:	f1a3 0020 	sub.w	r0, r3, #32
 8007144:	2858      	cmp	r0, #88	; 0x58
 8007146:	f200 831c 	bhi.w	8007782 <_svfprintf_r+0x71e>
 800714a:	e8df f010 	tbh	[pc, r0, lsl #1]
 800714e:	032d      	.short	0x032d
 8007150:	031a031a 	.word	0x031a031a
 8007154:	031a0336 	.word	0x031a0336
 8007158:	031a031a 	.word	0x031a031a
 800715c:	031a031a 	.word	0x031a031a
 8007160:	03c7031a 	.word	0x03c7031a
 8007164:	031a0081 	.word	0x031a0081
 8007168:	0085005d 	.word	0x0085005d
 800716c:	009f031a 	.word	0x009f031a
 8007170:	00a500a5 	.word	0x00a500a5
 8007174:	00a500a5 	.word	0x00a500a5
 8007178:	00a500a5 	.word	0x00a500a5
 800717c:	00a500a5 	.word	0x00a500a5
 8007180:	031a00a5 	.word	0x031a00a5
 8007184:	031a031a 	.word	0x031a031a
 8007188:	031a031a 	.word	0x031a031a
 800718c:	031a031a 	.word	0x031a031a
 8007190:	031a031a 	.word	0x031a031a
 8007194:	00b7031a 	.word	0x00b7031a
 8007198:	031a0241 	.word	0x031a0241
 800719c:	031a0241 	.word	0x031a0241
 80071a0:	031a031a 	.word	0x031a031a
 80071a4:	027f031a 	.word	0x027f031a
 80071a8:	031a031a 	.word	0x031a031a
 80071ac:	031a0285 	.word	0x031a0285
 80071b0:	031a031a 	.word	0x031a031a
 80071b4:	031a031a 	.word	0x031a031a
 80071b8:	031a02a3 	.word	0x031a02a3
 80071bc:	02b2031a 	.word	0x02b2031a
 80071c0:	031a031a 	.word	0x031a031a
 80071c4:	031a031a 	.word	0x031a031a
 80071c8:	031a031a 	.word	0x031a031a
 80071cc:	031a031a 	.word	0x031a031a
 80071d0:	031a031a 	.word	0x031a031a
 80071d4:	033c0354 	.word	0x033c0354
 80071d8:	02410241 	.word	0x02410241
 80071dc:	034e0241 	.word	0x034e0241
 80071e0:	031a033c 	.word	0x031a033c
 80071e4:	030b031a 	.word	0x030b031a
 80071e8:	039a031a 	.word	0x039a031a
 80071ec:	037e0368 	.word	0x037e0368
 80071f0:	031a02dd 	.word	0x031a02dd
 80071f4:	031a02e3 	.word	0x031a02e3
 80071f8:	031a03ab 	.word	0x031a03ab
 80071fc:	03d2031a 	.word	0x03d2031a
 8007200:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007202:	9012      	str	r0, [sp, #72]	; 0x48
 8007204:	425b      	negs	r3, r3
 8007206:	930d      	str	r3, [sp, #52]	; 0x34
 8007208:	9c08      	ldr	r4, [sp, #32]
 800720a:	f044 0404 	orr.w	r4, r4, #4
 800720e:	9408      	str	r4, [sp, #32]
 8007210:	7813      	ldrb	r3, [r2, #0]
 8007212:	e794      	b.n	800713e <_svfprintf_r+0xda>
 8007214:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007216:	aa39      	add	r2, sp, #228	; 0xe4
 8007218:	990c      	ldr	r1, [sp, #48]	; 0x30
 800721a:	f005 fb7b 	bl	800c914 <__ssprint_r>
 800721e:	b940      	cbnz	r0, 8007232 <_svfprintf_r+0x1ce>
 8007220:	4656      	mov	r6, sl
 8007222:	e777      	b.n	8007114 <_svfprintf_r+0xb0>
 8007224:	9b3b      	ldr	r3, [sp, #236]	; 0xec
 8007226:	b123      	cbz	r3, 8007232 <_svfprintf_r+0x1ce>
 8007228:	9811      	ldr	r0, [sp, #68]	; 0x44
 800722a:	aa39      	add	r2, sp, #228	; 0xe4
 800722c:	990c      	ldr	r1, [sp, #48]	; 0x30
 800722e:	f005 fb71 	bl	800c914 <__ssprint_r>
 8007232:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007234:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8007236:	898b      	ldrh	r3, [r1, #12]
 8007238:	f013 0f40 	tst.w	r3, #64	; 0x40
 800723c:	bf18      	it	ne
 800723e:	f04f 32ff 	movne.w	r2, #4294967295
 8007242:	920f      	str	r2, [sp, #60]	; 0x3c
 8007244:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007246:	b045      	add	sp, #276	; 0x114
 8007248:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800724c:	9f09      	ldr	r7, [sp, #36]	; 0x24
 800724e:	e764      	b.n	800711a <_svfprintf_r+0xb6>
 8007250:	f88d 110f 	strb.w	r1, [sp, #271]	; 0x10f
 8007254:	7813      	ldrb	r3, [r2, #0]
 8007256:	e772      	b.n	800713e <_svfprintf_r+0xda>
 8007258:	f812 3b01 	ldrb.w	r3, [r2], #1
 800725c:	2b2a      	cmp	r3, #42	; 0x2a
 800725e:	f001 81fc 	beq.w	800865a <_svfprintf_r+0x15f6>
 8007262:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 8007266:	2809      	cmp	r0, #9
 8007268:	f201 81ac 	bhi.w	80085c4 <_svfprintf_r+0x1560>
 800726c:	4614      	mov	r4, r2
 800726e:	2700      	movs	r7, #0
 8007270:	f814 3b01 	ldrb.w	r3, [r4], #1
 8007274:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 8007278:	eb00 0747 	add.w	r7, r0, r7, lsl #1
 800727c:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 8007280:	2809      	cmp	r0, #9
 8007282:	4622      	mov	r2, r4
 8007284:	d9f4      	bls.n	8007270 <_svfprintf_r+0x20c>
 8007286:	ea47 77e7 	orr.w	r7, r7, r7, asr #31
 800728a:	e759      	b.n	8007140 <_svfprintf_r+0xdc>
 800728c:	9b08      	ldr	r3, [sp, #32]
 800728e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8007292:	9308      	str	r3, [sp, #32]
 8007294:	7813      	ldrb	r3, [r2, #0]
 8007296:	e752      	b.n	800713e <_svfprintf_r+0xda>
 8007298:	4614      	mov	r4, r2
 800729a:	2000      	movs	r0, #0
 800729c:	f1a3 0830 	sub.w	r8, r3, #48	; 0x30
 80072a0:	f814 3b01 	ldrb.w	r3, [r4], #1
 80072a4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80072a8:	f1a3 0c30 	sub.w	ip, r3, #48	; 0x30
 80072ac:	4622      	mov	r2, r4
 80072ae:	f1bc 0f09 	cmp.w	ip, #9
 80072b2:	eb08 0040 	add.w	r0, r8, r0, lsl #1
 80072b6:	d9f1      	bls.n	800729c <_svfprintf_r+0x238>
 80072b8:	900d      	str	r0, [sp, #52]	; 0x34
 80072ba:	e741      	b.n	8007140 <_svfprintf_r+0xdc>
 80072bc:	9209      	str	r2, [sp, #36]	; 0x24
 80072be:	9a08      	ldr	r2, [sp, #32]
 80072c0:	9316      	str	r3, [sp, #88]	; 0x58
 80072c2:	f042 0210 	orr.w	r2, r2, #16
 80072c6:	9208      	str	r2, [sp, #32]
 80072c8:	9b08      	ldr	r3, [sp, #32]
 80072ca:	f013 0f20 	tst.w	r3, #32
 80072ce:	f000 8281 	beq.w	80077d4 <_svfprintf_r+0x770>
 80072d2:	9c12      	ldr	r4, [sp, #72]	; 0x48
 80072d4:	1de3      	adds	r3, r4, #7
 80072d6:	f023 0307 	bic.w	r3, r3, #7
 80072da:	f103 0008 	add.w	r0, r3, #8
 80072de:	9012      	str	r0, [sp, #72]	; 0x48
 80072e0:	e9d3 4500 	ldrd	r4, r5, [r3]
 80072e4:	2c00      	cmp	r4, #0
 80072e6:	f175 0200 	sbcs.w	r2, r5, #0
 80072ea:	f2c0 85cd 	blt.w	8007e88 <_svfprintf_r+0xe24>
 80072ee:	ea54 0305 	orrs.w	r3, r4, r5
 80072f2:	f04f 0301 	mov.w	r3, #1
 80072f6:	bf0c      	ite	eq
 80072f8:	2200      	moveq	r2, #0
 80072fa:	2201      	movne	r2, #1
 80072fc:	2f00      	cmp	r7, #0
 80072fe:	bfa2      	ittt	ge
 8007300:	9908      	ldrge	r1, [sp, #32]
 8007302:	f021 0180 	bicge.w	r1, r1, #128	; 0x80
 8007306:	9108      	strge	r1, [sp, #32]
 8007308:	2f00      	cmp	r7, #0
 800730a:	bf18      	it	ne
 800730c:	f042 0201 	orrne.w	r2, r2, #1
 8007310:	2a00      	cmp	r2, #0
 8007312:	f000 83ac 	beq.w	8007a6e <_svfprintf_r+0xa0a>
 8007316:	2b01      	cmp	r3, #1
 8007318:	f000 84fe 	beq.w	8007d18 <_svfprintf_r+0xcb4>
 800731c:	2b02      	cmp	r3, #2
 800731e:	f000 84de 	beq.w	8007cde <_svfprintf_r+0xc7a>
 8007322:	f10d 0bbc 	add.w	fp, sp, #188	; 0xbc
 8007326:	f10b 0327 	add.w	r3, fp, #39	; 0x27
 800732a:	08ea      	lsrs	r2, r5, #3
 800732c:	ea4f 08d4 	mov.w	r8, r4, lsr #3
 8007330:	ea48 7845 	orr.w	r8, r8, r5, lsl #29
 8007334:	f004 0407 	and.w	r4, r4, #7
 8007338:	4611      	mov	r1, r2
 800733a:	f104 0230 	add.w	r2, r4, #48	; 0x30
 800733e:	460d      	mov	r5, r1
 8007340:	4644      	mov	r4, r8
 8007342:	469c      	mov	ip, r3
 8007344:	701a      	strb	r2, [r3, #0]
 8007346:	3b01      	subs	r3, #1
 8007348:	ea54 0005 	orrs.w	r0, r4, r5
 800734c:	d1ed      	bne.n	800732a <_svfprintf_r+0x2c6>
 800734e:	9908      	ldr	r1, [sp, #32]
 8007350:	f8cd c04c 	str.w	ip, [sp, #76]	; 0x4c
 8007354:	f011 0f01 	tst.w	r1, #1
 8007358:	f040 8588 	bne.w	8007e6c <_svfprintf_r+0xe08>
 800735c:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8007360:	ebcc 020b 	rsb	r2, ip, fp
 8007364:	9210      	str	r2, [sp, #64]	; 0x40
 8007366:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 800736a:	2000      	movs	r0, #0
 800736c:	9c10      	ldr	r4, [sp, #64]	; 0x40
 800736e:	9714      	str	r7, [sp, #80]	; 0x50
 8007370:	42bc      	cmp	r4, r7
 8007372:	bfb8      	it	lt
 8007374:	463c      	movlt	r4, r7
 8007376:	9018      	str	r0, [sp, #96]	; 0x60
 8007378:	940a      	str	r4, [sp, #40]	; 0x28
 800737a:	b112      	cbz	r2, 8007382 <_svfprintf_r+0x31e>
 800737c:	980a      	ldr	r0, [sp, #40]	; 0x28
 800737e:	3001      	adds	r0, #1
 8007380:	900a      	str	r0, [sp, #40]	; 0x28
 8007382:	9908      	ldr	r1, [sp, #32]
 8007384:	f011 0b02 	ands.w	fp, r1, #2
 8007388:	d002      	beq.n	8007390 <_svfprintf_r+0x32c>
 800738a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800738c:	3302      	adds	r3, #2
 800738e:	930a      	str	r3, [sp, #40]	; 0x28
 8007390:	9c08      	ldr	r4, [sp, #32]
 8007392:	f014 0484 	ands.w	r4, r4, #132	; 0x84
 8007396:	9415      	str	r4, [sp, #84]	; 0x54
 8007398:	f040 82cd 	bne.w	8007936 <_svfprintf_r+0x8d2>
 800739c:	980d      	ldr	r0, [sp, #52]	; 0x34
 800739e:	990a      	ldr	r1, [sp, #40]	; 0x28
 80073a0:	1a47      	subs	r7, r0, r1
 80073a2:	2f00      	cmp	r7, #0
 80073a4:	f340 82c7 	ble.w	8007936 <_svfprintf_r+0x8d2>
 80073a8:	2f10      	cmp	r7, #16
 80073aa:	f341 8065 	ble.w	8008478 <_svfprintf_r+0x1414>
 80073ae:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80073b0:	f240 1880 	movw	r8, #384	; 0x180
 80073b4:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80073b6:	f6c0 0801 	movt	r8, #2049	; 0x801
 80073ba:	4629      	mov	r1, r5
 80073bc:	f04f 0910 	mov.w	r9, #16
 80073c0:	4622      	mov	r2, r4
 80073c2:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 80073c4:	4644      	mov	r4, r8
 80073c6:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 80073ca:	e002      	b.n	80073d2 <_svfprintf_r+0x36e>
 80073cc:	3f10      	subs	r7, #16
 80073ce:	2f10      	cmp	r7, #16
 80073d0:	dd1b      	ble.n	800740a <_svfprintf_r+0x3a6>
 80073d2:	3201      	adds	r2, #1
 80073d4:	6034      	str	r4, [r6, #0]
 80073d6:	f8c6 9004 	str.w	r9, [r6, #4]
 80073da:	3110      	adds	r1, #16
 80073dc:	3608      	adds	r6, #8
 80073de:	2a07      	cmp	r2, #7
 80073e0:	923a      	str	r2, [sp, #232]	; 0xe8
 80073e2:	f106 0308 	add.w	r3, r6, #8
 80073e6:	913b      	str	r1, [sp, #236]	; 0xec
 80073e8:	ddf0      	ble.n	80073cc <_svfprintf_r+0x368>
 80073ea:	4640      	mov	r0, r8
 80073ec:	4629      	mov	r1, r5
 80073ee:	aa39      	add	r2, sp, #228	; 0xe4
 80073f0:	4656      	mov	r6, sl
 80073f2:	f005 fa8f 	bl	800c914 <__ssprint_r>
 80073f6:	f10a 0308 	add.w	r3, sl, #8
 80073fa:	2800      	cmp	r0, #0
 80073fc:	f47f af19 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8007400:	3f10      	subs	r7, #16
 8007402:	993b      	ldr	r1, [sp, #236]	; 0xec
 8007404:	2f10      	cmp	r7, #16
 8007406:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 8007408:	dce3      	bgt.n	80073d2 <_svfprintf_r+0x36e>
 800740a:	46a0      	mov	r8, r4
 800740c:	460d      	mov	r5, r1
 800740e:	4614      	mov	r4, r2
 8007410:	3401      	adds	r4, #1
 8007412:	f8c6 8000 	str.w	r8, [r6]
 8007416:	2c07      	cmp	r4, #7
 8007418:	6077      	str	r7, [r6, #4]
 800741a:	443d      	add	r5, r7
 800741c:	943a      	str	r4, [sp, #232]	; 0xe8
 800741e:	953b      	str	r5, [sp, #236]	; 0xec
 8007420:	f300 827e 	bgt.w	8007920 <_svfprintf_r+0x8bc>
 8007424:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8007428:	461e      	mov	r6, r3
 800742a:	b16a      	cbz	r2, 8007448 <_svfprintf_r+0x3e4>
 800742c:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 800742e:	ab43      	add	r3, sp, #268	; 0x10c
 8007430:	3303      	adds	r3, #3
 8007432:	6033      	str	r3, [r6, #0]
 8007434:	3401      	adds	r4, #1
 8007436:	2301      	movs	r3, #1
 8007438:	2c07      	cmp	r4, #7
 800743a:	6073      	str	r3, [r6, #4]
 800743c:	441d      	add	r5, r3
 800743e:	943a      	str	r4, [sp, #232]	; 0xe8
 8007440:	953b      	str	r5, [sp, #236]	; 0xec
 8007442:	f300 83e9 	bgt.w	8007c18 <_svfprintf_r+0xbb4>
 8007446:	3608      	adds	r6, #8
 8007448:	f1bb 0f00 	cmp.w	fp, #0
 800744c:	d00c      	beq.n	8007468 <_svfprintf_r+0x404>
 800744e:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007450:	ab43      	add	r3, sp, #268	; 0x10c
 8007452:	6033      	str	r3, [r6, #0]
 8007454:	2302      	movs	r3, #2
 8007456:	3401      	adds	r4, #1
 8007458:	6073      	str	r3, [r6, #4]
 800745a:	2c07      	cmp	r4, #7
 800745c:	441d      	add	r5, r3
 800745e:	943a      	str	r4, [sp, #232]	; 0xe8
 8007460:	953b      	str	r5, [sp, #236]	; 0xec
 8007462:	f300 83ce 	bgt.w	8007c02 <_svfprintf_r+0xb9e>
 8007466:	3608      	adds	r6, #8
 8007468:	9a15      	ldr	r2, [sp, #84]	; 0x54
 800746a:	2a80      	cmp	r2, #128	; 0x80
 800746c:	f000 8310 	beq.w	8007a90 <_svfprintf_r+0xa2c>
 8007470:	9914      	ldr	r1, [sp, #80]	; 0x50
 8007472:	9810      	ldr	r0, [sp, #64]	; 0x40
 8007474:	1a0f      	subs	r7, r1, r0
 8007476:	2f00      	cmp	r7, #0
 8007478:	f340 835b 	ble.w	8007b32 <_svfprintf_r+0xace>
 800747c:	2f10      	cmp	r7, #16
 800747e:	f340 85eb 	ble.w	8008058 <_svfprintf_r+0xff4>
 8007482:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007484:	462a      	mov	r2, r5
 8007486:	f8df 8a98 	ldr.w	r8, [pc, #2712]	; 8007f20 <_svfprintf_r+0xebc>
 800748a:	f04f 0b10 	mov.w	fp, #16
 800748e:	4623      	mov	r3, r4
 8007490:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8007492:	4644      	mov	r4, r8
 8007494:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8007498:	e002      	b.n	80074a0 <_svfprintf_r+0x43c>
 800749a:	3f10      	subs	r7, #16
 800749c:	2f10      	cmp	r7, #16
 800749e:	dd1b      	ble.n	80074d8 <_svfprintf_r+0x474>
 80074a0:	3301      	adds	r3, #1
 80074a2:	6034      	str	r4, [r6, #0]
 80074a4:	f8c6 b004 	str.w	fp, [r6, #4]
 80074a8:	3210      	adds	r2, #16
 80074aa:	3608      	adds	r6, #8
 80074ac:	2b07      	cmp	r3, #7
 80074ae:	933a      	str	r3, [sp, #232]	; 0xe8
 80074b0:	f106 0908 	add.w	r9, r6, #8
 80074b4:	923b      	str	r2, [sp, #236]	; 0xec
 80074b6:	ddf0      	ble.n	800749a <_svfprintf_r+0x436>
 80074b8:	4640      	mov	r0, r8
 80074ba:	4629      	mov	r1, r5
 80074bc:	aa39      	add	r2, sp, #228	; 0xe4
 80074be:	f10a 0908 	add.w	r9, sl, #8
 80074c2:	f005 fa27 	bl	800c914 <__ssprint_r>
 80074c6:	4656      	mov	r6, sl
 80074c8:	2800      	cmp	r0, #0
 80074ca:	f47f aeb2 	bne.w	8007232 <_svfprintf_r+0x1ce>
 80074ce:	3f10      	subs	r7, #16
 80074d0:	9a3b      	ldr	r2, [sp, #236]	; 0xec
 80074d2:	2f10      	cmp	r7, #16
 80074d4:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 80074d6:	dce3      	bgt.n	80074a0 <_svfprintf_r+0x43c>
 80074d8:	46a0      	mov	r8, r4
 80074da:	4615      	mov	r5, r2
 80074dc:	461c      	mov	r4, r3
 80074de:	3401      	adds	r4, #1
 80074e0:	f8c6 8000 	str.w	r8, [r6]
 80074e4:	2c07      	cmp	r4, #7
 80074e6:	6077      	str	r7, [r6, #4]
 80074e8:	443d      	add	r5, r7
 80074ea:	943a      	str	r4, [sp, #232]	; 0xe8
 80074ec:	953b      	str	r5, [sp, #236]	; 0xec
 80074ee:	f300 837d 	bgt.w	8007bec <_svfprintf_r+0xb88>
 80074f2:	9a08      	ldr	r2, [sp, #32]
 80074f4:	f412 7f80 	tst.w	r2, #256	; 0x100
 80074f8:	f040 824e 	bne.w	8007998 <_svfprintf_r+0x934>
 80074fc:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80074fe:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007500:	3401      	adds	r4, #1
 8007502:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8007504:	2c07      	cmp	r4, #7
 8007506:	441d      	add	r5, r3
 8007508:	f8c9 3004 	str.w	r3, [r9, #4]
 800750c:	f8c9 0000 	str.w	r0, [r9]
 8007510:	953b      	str	r5, [sp, #236]	; 0xec
 8007512:	943a      	str	r4, [sp, #232]	; 0xe8
 8007514:	f300 8235 	bgt.w	8007982 <_svfprintf_r+0x91e>
 8007518:	f109 0908 	add.w	r9, r9, #8
 800751c:	9c08      	ldr	r4, [sp, #32]
 800751e:	f014 0f04 	tst.w	r4, #4
 8007522:	d046      	beq.n	80075b2 <_svfprintf_r+0x54e>
 8007524:	980d      	ldr	r0, [sp, #52]	; 0x34
 8007526:	990a      	ldr	r1, [sp, #40]	; 0x28
 8007528:	1a46      	subs	r6, r0, r1
 800752a:	2e00      	cmp	r6, #0
 800752c:	dd41      	ble.n	80075b2 <_svfprintf_r+0x54e>
 800752e:	2e10      	cmp	r6, #16
 8007530:	f340 87da 	ble.w	80084e8 <_svfprintf_r+0x1484>
 8007534:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007536:	f240 1880 	movw	r8, #384	; 0x180
 800753a:	f6c0 0801 	movt	r8, #2049	; 0x801
 800753e:	2710      	movs	r7, #16
 8007540:	4623      	mov	r3, r4
 8007542:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 8007546:	4644      	mov	r4, r8
 8007548:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 800754c:	e002      	b.n	8007554 <_svfprintf_r+0x4f0>
 800754e:	3e10      	subs	r6, #16
 8007550:	2e10      	cmp	r6, #16
 8007552:	dd19      	ble.n	8007588 <_svfprintf_r+0x524>
 8007554:	3301      	adds	r3, #1
 8007556:	3510      	adds	r5, #16
 8007558:	2b07      	cmp	r3, #7
 800755a:	f8c9 4000 	str.w	r4, [r9]
 800755e:	f8c9 7004 	str.w	r7, [r9, #4]
 8007562:	f109 0908 	add.w	r9, r9, #8
 8007566:	933a      	str	r3, [sp, #232]	; 0xe8
 8007568:	953b      	str	r5, [sp, #236]	; 0xec
 800756a:	ddf0      	ble.n	800754e <_svfprintf_r+0x4ea>
 800756c:	4640      	mov	r0, r8
 800756e:	4659      	mov	r1, fp
 8007570:	aa39      	add	r2, sp, #228	; 0xe4
 8007572:	46d1      	mov	r9, sl
 8007574:	f005 f9ce 	bl	800c914 <__ssprint_r>
 8007578:	2800      	cmp	r0, #0
 800757a:	f47f ae5a 	bne.w	8007232 <_svfprintf_r+0x1ce>
 800757e:	3e10      	subs	r6, #16
 8007580:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007582:	2e10      	cmp	r6, #16
 8007584:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 8007586:	dce5      	bgt.n	8007554 <_svfprintf_r+0x4f0>
 8007588:	46a0      	mov	r8, r4
 800758a:	461c      	mov	r4, r3
 800758c:	3401      	adds	r4, #1
 800758e:	f8c9 8000 	str.w	r8, [r9]
 8007592:	2c07      	cmp	r4, #7
 8007594:	f8c9 6004 	str.w	r6, [r9, #4]
 8007598:	4435      	add	r5, r6
 800759a:	943a      	str	r4, [sp, #232]	; 0xe8
 800759c:	953b      	str	r5, [sp, #236]	; 0xec
 800759e:	dd08      	ble.n	80075b2 <_svfprintf_r+0x54e>
 80075a0:	9811      	ldr	r0, [sp, #68]	; 0x44
 80075a2:	aa39      	add	r2, sp, #228	; 0xe4
 80075a4:	990c      	ldr	r1, [sp, #48]	; 0x30
 80075a6:	f005 f9b5 	bl	800c914 <__ssprint_r>
 80075aa:	2800      	cmp	r0, #0
 80075ac:	f47f ae41 	bne.w	8007232 <_svfprintf_r+0x1ce>
 80075b0:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80075b2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80075b4:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80075b6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80075b8:	429c      	cmp	r4, r3
 80075ba:	bfac      	ite	ge
 80075bc:	1912      	addge	r2, r2, r4
 80075be:	18d2      	addlt	r2, r2, r3
 80075c0:	920f      	str	r2, [sp, #60]	; 0x3c
 80075c2:	2d00      	cmp	r5, #0
 80075c4:	f040 8303 	bne.w	8007bce <_svfprintf_r+0xb6a>
 80075c8:	2000      	movs	r0, #0
 80075ca:	4656      	mov	r6, sl
 80075cc:	903a      	str	r0, [sp, #232]	; 0xe8
 80075ce:	e572      	b.n	80070b6 <_svfprintf_r+0x52>
 80075d0:	9908      	ldr	r1, [sp, #32]
 80075d2:	461d      	mov	r5, r3
 80075d4:	9209      	str	r2, [sp, #36]	; 0x24
 80075d6:	f011 0f08 	tst.w	r1, #8
 80075da:	9316      	str	r3, [sp, #88]	; 0x58
 80075dc:	f000 8487 	beq.w	8007eee <_svfprintf_r+0xe8a>
 80075e0:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80075e2:	1dd3      	adds	r3, r2, #7
 80075e4:	f023 0307 	bic.w	r3, r3, #7
 80075e8:	f103 0408 	add.w	r4, r3, #8
 80075ec:	9412      	str	r4, [sp, #72]	; 0x48
 80075ee:	6818      	ldr	r0, [r3, #0]
 80075f0:	901a      	str	r0, [sp, #104]	; 0x68
 80075f2:	685b      	ldr	r3, [r3, #4]
 80075f4:	931b      	str	r3, [sp, #108]	; 0x6c
 80075f6:	981a      	ldr	r0, [sp, #104]	; 0x68
 80075f8:	991b      	ldr	r1, [sp, #108]	; 0x6c
 80075fa:	f005 f8c9 	bl	800c790 <__fpclassifyd>
 80075fe:	2801      	cmp	r0, #1
 8007600:	f040 8450 	bne.w	8007ea4 <_svfprintf_r+0xe40>
 8007604:	981a      	ldr	r0, [sp, #104]	; 0x68
 8007606:	2200      	movs	r2, #0
 8007608:	2300      	movs	r3, #0
 800760a:	991b      	ldr	r1, [sp, #108]	; 0x6c
 800760c:	f008 f898 	bl	800f740 <__aeabi_dcmplt>
 8007610:	2800      	cmp	r0, #0
 8007612:	f040 871c 	bne.w	800844e <_svfprintf_r+0x13ea>
 8007616:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 800761a:	2003      	movs	r0, #3
 800761c:	f240 4378 	movw	r3, #1144	; 0x478
 8007620:	f240 4174 	movw	r1, #1140	; 0x474
 8007624:	900a      	str	r0, [sp, #40]	; 0x28
 8007626:	9816      	ldr	r0, [sp, #88]	; 0x58
 8007628:	f6c0 0101 	movt	r1, #2049	; 0x801
 800762c:	f6c0 0301 	movt	r3, #2049	; 0x801
 8007630:	2400      	movs	r4, #0
 8007632:	2847      	cmp	r0, #71	; 0x47
 8007634:	bfd8      	it	le
 8007636:	460b      	movle	r3, r1
 8007638:	9908      	ldr	r1, [sp, #32]
 800763a:	9313      	str	r3, [sp, #76]	; 0x4c
 800763c:	2303      	movs	r3, #3
 800763e:	f021 0180 	bic.w	r1, r1, #128	; 0x80
 8007642:	9414      	str	r4, [sp, #80]	; 0x50
 8007644:	9108      	str	r1, [sp, #32]
 8007646:	9310      	str	r3, [sp, #64]	; 0x40
 8007648:	9418      	str	r4, [sp, #96]	; 0x60
 800764a:	e696      	b.n	800737a <_svfprintf_r+0x316>
 800764c:	9c08      	ldr	r4, [sp, #32]
 800764e:	f044 0408 	orr.w	r4, r4, #8
 8007652:	9408      	str	r4, [sp, #32]
 8007654:	7813      	ldrb	r3, [r2, #0]
 8007656:	e572      	b.n	800713e <_svfprintf_r+0xda>
 8007658:	9908      	ldr	r1, [sp, #32]
 800765a:	9209      	str	r2, [sp, #36]	; 0x24
 800765c:	f041 0110 	orr.w	r1, r1, #16
 8007660:	9108      	str	r1, [sp, #32]
 8007662:	9a08      	ldr	r2, [sp, #32]
 8007664:	9316      	str	r3, [sp, #88]	; 0x58
 8007666:	f012 0320 	ands.w	r3, r2, #32
 800766a:	f000 80df 	beq.w	800782c <_svfprintf_r+0x7c8>
 800766e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8007670:	1dda      	adds	r2, r3, #7
 8007672:	2300      	movs	r3, #0
 8007674:	f022 0207 	bic.w	r2, r2, #7
 8007678:	f102 0408 	add.w	r4, r2, #8
 800767c:	9412      	str	r4, [sp, #72]	; 0x48
 800767e:	e9d2 4500 	ldrd	r4, r5, [r2]
 8007682:	ea54 0005 	orrs.w	r0, r4, r5
 8007686:	bf0c      	ite	eq
 8007688:	2200      	moveq	r2, #0
 800768a:	2201      	movne	r2, #1
 800768c:	2000      	movs	r0, #0
 800768e:	f88d 010f 	strb.w	r0, [sp, #271]	; 0x10f
 8007692:	e633      	b.n	80072fc <_svfprintf_r+0x298>
 8007694:	9c08      	ldr	r4, [sp, #32]
 8007696:	9209      	str	r2, [sp, #36]	; 0x24
 8007698:	f044 0410 	orr.w	r4, r4, #16
 800769c:	9408      	str	r4, [sp, #32]
 800769e:	9808      	ldr	r0, [sp, #32]
 80076a0:	9316      	str	r3, [sp, #88]	; 0x58
 80076a2:	f010 0f20 	tst.w	r0, #32
 80076a6:	f000 8104 	beq.w	80078b2 <_svfprintf_r+0x84e>
 80076aa:	9912      	ldr	r1, [sp, #72]	; 0x48
 80076ac:	2301      	movs	r3, #1
 80076ae:	1dca      	adds	r2, r1, #7
 80076b0:	e7e0      	b.n	8007674 <_svfprintf_r+0x610>
 80076b2:	9209      	str	r2, [sp, #36]	; 0x24
 80076b4:	f240 4184 	movw	r1, #1156	; 0x484
 80076b8:	9a08      	ldr	r2, [sp, #32]
 80076ba:	f6c0 0101 	movt	r1, #2049	; 0x801
 80076be:	9316      	str	r3, [sp, #88]	; 0x58
 80076c0:	f012 0f20 	tst.w	r2, #32
 80076c4:	9117      	str	r1, [sp, #92]	; 0x5c
 80076c6:	f000 8120 	beq.w	800790a <_svfprintf_r+0x8a6>
 80076ca:	9c12      	ldr	r4, [sp, #72]	; 0x48
 80076cc:	1de3      	adds	r3, r4, #7
 80076ce:	f023 0307 	bic.w	r3, r3, #7
 80076d2:	f103 0008 	add.w	r0, r3, #8
 80076d6:	9012      	str	r0, [sp, #72]	; 0x48
 80076d8:	e9d3 4500 	ldrd	r4, r5, [r3]
 80076dc:	ea54 0205 	orrs.w	r2, r4, r5
 80076e0:	9b08      	ldr	r3, [sp, #32]
 80076e2:	bf0c      	ite	eq
 80076e4:	2200      	moveq	r2, #0
 80076e6:	2201      	movne	r2, #1
 80076e8:	4213      	tst	r3, r2
 80076ea:	f000 8369 	beq.w	8007dc0 <_svfprintf_r+0xd5c>
 80076ee:	9816      	ldr	r0, [sp, #88]	; 0x58
 80076f0:	2330      	movs	r3, #48	; 0x30
 80076f2:	9908      	ldr	r1, [sp, #32]
 80076f4:	2201      	movs	r2, #1
 80076f6:	f88d 310c 	strb.w	r3, [sp, #268]	; 0x10c
 80076fa:	2302      	movs	r3, #2
 80076fc:	f041 0102 	orr.w	r1, r1, #2
 8007700:	f88d 010d 	strb.w	r0, [sp, #269]	; 0x10d
 8007704:	9108      	str	r1, [sp, #32]
 8007706:	e7c1      	b.n	800768c <_svfprintf_r+0x628>
 8007708:	9808      	ldr	r0, [sp, #32]
 800770a:	f040 0020 	orr.w	r0, r0, #32
 800770e:	9008      	str	r0, [sp, #32]
 8007710:	7813      	ldrb	r3, [r2, #0]
 8007712:	e514      	b.n	800713e <_svfprintf_r+0xda>
 8007714:	9209      	str	r2, [sp, #36]	; 0x24
 8007716:	2100      	movs	r1, #0
 8007718:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800771a:	9316      	str	r3, [sp, #88]	; 0x58
 800771c:	f88d 110f 	strb.w	r1, [sp, #271]	; 0x10f
 8007720:	1d14      	adds	r4, r2, #4
 8007722:	6813      	ldr	r3, [r2, #0]
 8007724:	9313      	str	r3, [sp, #76]	; 0x4c
 8007726:	2b00      	cmp	r3, #0
 8007728:	f000 86f0 	beq.w	800850c <_svfprintf_r+0x14a8>
 800772c:	2f00      	cmp	r7, #0
 800772e:	f2c0 8693 	blt.w	8008458 <_svfprintf_r+0x13f4>
 8007732:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8007734:	2100      	movs	r1, #0
 8007736:	463a      	mov	r2, r7
 8007738:	f004 f99c 	bl	800ba74 <memchr>
 800773c:	2800      	cmp	r0, #0
 800773e:	f000 8736 	beq.w	80085ae <_svfprintf_r+0x154a>
 8007742:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8007744:	1ac0      	subs	r0, r0, r3
 8007746:	9010      	str	r0, [sp, #64]	; 0x40
 8007748:	42b8      	cmp	r0, r7
 800774a:	f340 84f4 	ble.w	8008136 <_svfprintf_r+0x10d2>
 800774e:	2000      	movs	r0, #0
 8007750:	ea27 71e7 	bic.w	r1, r7, r7, asr #31
 8007754:	9014      	str	r0, [sp, #80]	; 0x50
 8007756:	910a      	str	r1, [sp, #40]	; 0x28
 8007758:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 800775c:	9412      	str	r4, [sp, #72]	; 0x48
 800775e:	9710      	str	r7, [sp, #64]	; 0x40
 8007760:	9018      	str	r0, [sp, #96]	; 0x60
 8007762:	e60a      	b.n	800737a <_svfprintf_r+0x316>
 8007764:	7813      	ldrb	r3, [r2, #0]
 8007766:	2b6c      	cmp	r3, #108	; 0x6c
 8007768:	bf0b      	itete	eq
 800776a:	9b08      	ldreq	r3, [sp, #32]
 800776c:	9c08      	ldrne	r4, [sp, #32]
 800776e:	f043 0320 	orreq.w	r3, r3, #32
 8007772:	f044 0410 	orrne.w	r4, r4, #16
 8007776:	bf0a      	itet	eq
 8007778:	9308      	streq	r3, [sp, #32]
 800777a:	9408      	strne	r4, [sp, #32]
 800777c:	f812 3f01 	ldrbeq.w	r3, [r2, #1]!
 8007780:	e4dd      	b.n	800713e <_svfprintf_r+0xda>
 8007782:	9209      	str	r2, [sp, #36]	; 0x24
 8007784:	9316      	str	r3, [sp, #88]	; 0x58
 8007786:	2b00      	cmp	r3, #0
 8007788:	f43f ad4c 	beq.w	8007224 <_svfprintf_r+0x1c0>
 800778c:	2200      	movs	r2, #0
 800778e:	2101      	movs	r1, #1
 8007790:	f88d 30bc 	strb.w	r3, [sp, #188]	; 0xbc
 8007794:	ac2f      	add	r4, sp, #188	; 0xbc
 8007796:	2300      	movs	r3, #0
 8007798:	910a      	str	r1, [sp, #40]	; 0x28
 800779a:	9110      	str	r1, [sp, #64]	; 0x40
 800779c:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
 80077a0:	9214      	str	r2, [sp, #80]	; 0x50
 80077a2:	9218      	str	r2, [sp, #96]	; 0x60
 80077a4:	9413      	str	r4, [sp, #76]	; 0x4c
 80077a6:	e5ec      	b.n	8007382 <_svfprintf_r+0x31e>
 80077a8:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
 80077ac:	2b00      	cmp	r3, #0
 80077ae:	f040 839b 	bne.w	8007ee8 <_svfprintf_r+0xe84>
 80077b2:	f88d 510f 	strb.w	r5, [sp, #271]	; 0x10f
 80077b6:	7813      	ldrb	r3, [r2, #0]
 80077b8:	e4c1      	b.n	800713e <_svfprintf_r+0xda>
 80077ba:	9808      	ldr	r0, [sp, #32]
 80077bc:	f040 0001 	orr.w	r0, r0, #1
 80077c0:	9008      	str	r0, [sp, #32]
 80077c2:	7813      	ldrb	r3, [r2, #0]
 80077c4:	e4bb      	b.n	800713e <_svfprintf_r+0xda>
 80077c6:	9316      	str	r3, [sp, #88]	; 0x58
 80077c8:	9b08      	ldr	r3, [sp, #32]
 80077ca:	9209      	str	r2, [sp, #36]	; 0x24
 80077cc:	f013 0f20 	tst.w	r3, #32
 80077d0:	f47f ad7f 	bne.w	80072d2 <_svfprintf_r+0x26e>
 80077d4:	9908      	ldr	r1, [sp, #32]
 80077d6:	f011 0f10 	tst.w	r1, #16
 80077da:	f000 83a3 	beq.w	8007f24 <_svfprintf_r+0xec0>
 80077de:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80077e0:	6814      	ldr	r4, [r2, #0]
 80077e2:	3204      	adds	r2, #4
 80077e4:	9212      	str	r2, [sp, #72]	; 0x48
 80077e6:	17e5      	asrs	r5, r4, #31
 80077e8:	e57c      	b.n	80072e4 <_svfprintf_r+0x280>
 80077ea:	9808      	ldr	r0, [sp, #32]
 80077ec:	f040 0040 	orr.w	r0, r0, #64	; 0x40
 80077f0:	9008      	str	r0, [sp, #32]
 80077f2:	7813      	ldrb	r3, [r2, #0]
 80077f4:	e4a3      	b.n	800713e <_svfprintf_r+0xda>
 80077f6:	9316      	str	r3, [sp, #88]	; 0x58
 80077f8:	2101      	movs	r1, #1
 80077fa:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80077fc:	2000      	movs	r0, #0
 80077fe:	9209      	str	r2, [sp, #36]	; 0x24
 8007800:	2200      	movs	r2, #0
 8007802:	1d1c      	adds	r4, r3, #4
 8007804:	910a      	str	r1, [sp, #40]	; 0x28
 8007806:	681b      	ldr	r3, [r3, #0]
 8007808:	9412      	str	r4, [sp, #72]	; 0x48
 800780a:	9110      	str	r1, [sp, #64]	; 0x40
 800780c:	a92f      	add	r1, sp, #188	; 0xbc
 800780e:	f88d 010f 	strb.w	r0, [sp, #271]	; 0x10f
 8007812:	9214      	str	r2, [sp, #80]	; 0x50
 8007814:	9218      	str	r2, [sp, #96]	; 0x60
 8007816:	9113      	str	r1, [sp, #76]	; 0x4c
 8007818:	f88d 30bc 	strb.w	r3, [sp, #188]	; 0xbc
 800781c:	e5b1      	b.n	8007382 <_svfprintf_r+0x31e>
 800781e:	9209      	str	r2, [sp, #36]	; 0x24
 8007820:	9a08      	ldr	r2, [sp, #32]
 8007822:	9316      	str	r3, [sp, #88]	; 0x58
 8007824:	f012 0320 	ands.w	r3, r2, #32
 8007828:	f47f af21 	bne.w	800766e <_svfprintf_r+0x60a>
 800782c:	9908      	ldr	r1, [sp, #32]
 800782e:	f011 0210 	ands.w	r2, r1, #16
 8007832:	f000 8391 	beq.w	8007f58 <_svfprintf_r+0xef4>
 8007836:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8007838:	6822      	ldr	r2, [r4, #0]
 800783a:	3404      	adds	r4, #4
 800783c:	2500      	movs	r5, #0
 800783e:	9412      	str	r4, [sp, #72]	; 0x48
 8007840:	4614      	mov	r4, r2
 8007842:	3a00      	subs	r2, #0
 8007844:	bf18      	it	ne
 8007846:	2201      	movne	r2, #1
 8007848:	e720      	b.n	800768c <_svfprintf_r+0x628>
 800784a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800784c:	2178      	movs	r1, #120	; 0x78
 800784e:	9c08      	ldr	r4, [sp, #32]
 8007850:	2500      	movs	r5, #0
 8007852:	9209      	str	r2, [sp, #36]	; 0x24
 8007854:	f240 4098 	movw	r0, #1176	; 0x498
 8007858:	681a      	ldr	r2, [r3, #0]
 800785a:	f044 0402 	orr.w	r4, r4, #2
 800785e:	3304      	adds	r3, #4
 8007860:	9408      	str	r4, [sp, #32]
 8007862:	9312      	str	r3, [sp, #72]	; 0x48
 8007864:	4614      	mov	r4, r2
 8007866:	2330      	movs	r3, #48	; 0x30
 8007868:	3a00      	subs	r2, #0
 800786a:	f88d 310c 	strb.w	r3, [sp, #268]	; 0x10c
 800786e:	bf18      	it	ne
 8007870:	2201      	movne	r2, #1
 8007872:	f6c0 0001 	movt	r0, #2049	; 0x801
 8007876:	f88d 110d 	strb.w	r1, [sp, #269]	; 0x10d
 800787a:	9017      	str	r0, [sp, #92]	; 0x5c
 800787c:	2302      	movs	r3, #2
 800787e:	9116      	str	r1, [sp, #88]	; 0x58
 8007880:	e704      	b.n	800768c <_svfprintf_r+0x628>
 8007882:	9209      	str	r2, [sp, #36]	; 0x24
 8007884:	9a08      	ldr	r2, [sp, #32]
 8007886:	f012 0f20 	tst.w	r2, #32
 800788a:	f000 8358 	beq.w	8007f3e <_svfprintf_r+0xeda>
 800788e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8007890:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 8007892:	9812      	ldr	r0, [sp, #72]	; 0x48
 8007894:	6819      	ldr	r1, [r3, #0]
 8007896:	4622      	mov	r2, r4
 8007898:	17e3      	asrs	r3, r4, #31
 800789a:	3004      	adds	r0, #4
 800789c:	9012      	str	r0, [sp, #72]	; 0x48
 800789e:	e9c1 2300 	strd	r2, r3, [r1]
 80078a2:	e408      	b.n	80070b6 <_svfprintf_r+0x52>
 80078a4:	9808      	ldr	r0, [sp, #32]
 80078a6:	9209      	str	r2, [sp, #36]	; 0x24
 80078a8:	f010 0f20 	tst.w	r0, #32
 80078ac:	9316      	str	r3, [sp, #88]	; 0x58
 80078ae:	f47f aefc 	bne.w	80076aa <_svfprintf_r+0x646>
 80078b2:	9908      	ldr	r1, [sp, #32]
 80078b4:	f011 0f10 	tst.w	r1, #16
 80078b8:	f040 8291 	bne.w	8007dde <_svfprintf_r+0xd7a>
 80078bc:	9808      	ldr	r0, [sp, #32]
 80078be:	f010 0f40 	tst.w	r0, #64	; 0x40
 80078c2:	f000 828c 	beq.w	8007dde <_svfprintf_r+0xd7a>
 80078c6:	9912      	ldr	r1, [sp, #72]	; 0x48
 80078c8:	2301      	movs	r3, #1
 80078ca:	2500      	movs	r5, #0
 80078cc:	880a      	ldrh	r2, [r1, #0]
 80078ce:	3104      	adds	r1, #4
 80078d0:	9112      	str	r1, [sp, #72]	; 0x48
 80078d2:	4614      	mov	r4, r2
 80078d4:	3a00      	subs	r2, #0
 80078d6:	bf18      	it	ne
 80078d8:	2201      	movne	r2, #1
 80078da:	e6d7      	b.n	800768c <_svfprintf_r+0x628>
 80078dc:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80078de:	9c12      	ldr	r4, [sp, #72]	; 0x48
 80078e0:	681b      	ldr	r3, [r3, #0]
 80078e2:	1d20      	adds	r0, r4, #4
 80078e4:	2b00      	cmp	r3, #0
 80078e6:	930d      	str	r3, [sp, #52]	; 0x34
 80078e8:	f6ff ac8a 	blt.w	8007200 <_svfprintf_r+0x19c>
 80078ec:	7813      	ldrb	r3, [r2, #0]
 80078ee:	9012      	str	r0, [sp, #72]	; 0x48
 80078f0:	e425      	b.n	800713e <_svfprintf_r+0xda>
 80078f2:	9209      	str	r2, [sp, #36]	; 0x24
 80078f4:	f240 4098 	movw	r0, #1176	; 0x498
 80078f8:	9a08      	ldr	r2, [sp, #32]
 80078fa:	f6c0 0001 	movt	r0, #2049	; 0x801
 80078fe:	9316      	str	r3, [sp, #88]	; 0x58
 8007900:	f012 0f20 	tst.w	r2, #32
 8007904:	9017      	str	r0, [sp, #92]	; 0x5c
 8007906:	f47f aee0 	bne.w	80076ca <_svfprintf_r+0x666>
 800790a:	9908      	ldr	r1, [sp, #32]
 800790c:	f011 0f10 	tst.w	r1, #16
 8007910:	f000 82fa 	beq.w	8007f08 <_svfprintf_r+0xea4>
 8007914:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8007916:	2500      	movs	r5, #0
 8007918:	6814      	ldr	r4, [r2, #0]
 800791a:	3204      	adds	r2, #4
 800791c:	9212      	str	r2, [sp, #72]	; 0x48
 800791e:	e6dd      	b.n	80076dc <_svfprintf_r+0x678>
 8007920:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007922:	aa39      	add	r2, sp, #228	; 0xe4
 8007924:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007926:	f004 fff5 	bl	800c914 <__ssprint_r>
 800792a:	2800      	cmp	r0, #0
 800792c:	f47f ac81 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8007930:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8007934:	4656      	mov	r6, sl
 8007936:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007938:	e577      	b.n	800742a <_svfprintf_r+0x3c6>
 800793a:	9a08      	ldr	r2, [sp, #32]
 800793c:	f012 0f01 	tst.w	r2, #1
 8007940:	f040 80fd 	bne.w	8007b3e <_svfprintf_r+0xada>
 8007944:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007946:	3501      	adds	r5, #1
 8007948:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800794a:	2301      	movs	r3, #1
 800794c:	3401      	adds	r4, #1
 800794e:	f8c9 3004 	str.w	r3, [r9, #4]
 8007952:	2c07      	cmp	r4, #7
 8007954:	f8c9 2000 	str.w	r2, [r9]
 8007958:	953b      	str	r5, [sp, #236]	; 0xec
 800795a:	943a      	str	r4, [sp, #232]	; 0xe8
 800795c:	f300 851f 	bgt.w	800839e <_svfprintf_r+0x133a>
 8007960:	f109 0b08 	add.w	fp, r9, #8
 8007964:	f10b 0908 	add.w	r9, fp, #8
 8007968:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 800796a:	3401      	adds	r4, #1
 800796c:	2c07      	cmp	r4, #7
 800796e:	441d      	add	r5, r3
 8007970:	f8cb 3004 	str.w	r3, [fp, #4]
 8007974:	ab3e      	add	r3, sp, #248	; 0xf8
 8007976:	f8cb 3000 	str.w	r3, [fp]
 800797a:	953b      	str	r5, [sp, #236]	; 0xec
 800797c:	943a      	str	r4, [sp, #232]	; 0xe8
 800797e:	f77f adcd 	ble.w	800751c <_svfprintf_r+0x4b8>
 8007982:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007984:	aa39      	add	r2, sp, #228	; 0xe4
 8007986:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007988:	f004 ffc4 	bl	800c914 <__ssprint_r>
 800798c:	2800      	cmp	r0, #0
 800798e:	f47f ac50 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8007992:	46d1      	mov	r9, sl
 8007994:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007996:	e5c1      	b.n	800751c <_svfprintf_r+0x4b8>
 8007998:	9916      	ldr	r1, [sp, #88]	; 0x58
 800799a:	2965      	cmp	r1, #101	; 0x65
 800799c:	f340 80cb 	ble.w	8007b36 <_svfprintf_r+0xad2>
 80079a0:	981a      	ldr	r0, [sp, #104]	; 0x68
 80079a2:	2200      	movs	r2, #0
 80079a4:	2300      	movs	r3, #0
 80079a6:	991b      	ldr	r1, [sp, #108]	; 0x6c
 80079a8:	f007 fec0 	bl	800f72c <__aeabi_dcmpeq>
 80079ac:	2800      	cmp	r0, #0
 80079ae:	f000 813e 	beq.w	8007c2e <_svfprintf_r+0xbca>
 80079b2:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80079b4:	f240 43b4 	movw	r3, #1204	; 0x4b4
 80079b8:	f6c0 0301 	movt	r3, #2049	; 0x801
 80079bc:	f8c9 3000 	str.w	r3, [r9]
 80079c0:	3401      	adds	r4, #1
 80079c2:	2301      	movs	r3, #1
 80079c4:	2c07      	cmp	r4, #7
 80079c6:	f8c9 3004 	str.w	r3, [r9, #4]
 80079ca:	441d      	add	r5, r3
 80079cc:	943a      	str	r4, [sp, #232]	; 0xe8
 80079ce:	953b      	str	r5, [sp, #236]	; 0xec
 80079d0:	bfd8      	it	le
 80079d2:	f109 0908 	addle.w	r9, r9, #8
 80079d6:	f300 8346 	bgt.w	8008066 <_svfprintf_r+0x1002>
 80079da:	9b42      	ldr	r3, [sp, #264]	; 0x108
 80079dc:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80079de:	4293      	cmp	r3, r2
 80079e0:	db04      	blt.n	80079ec <_svfprintf_r+0x988>
 80079e2:	9b08      	ldr	r3, [sp, #32]
 80079e4:	f013 0f01 	tst.w	r3, #1
 80079e8:	f43f ad98 	beq.w	800751c <_svfprintf_r+0x4b8>
 80079ec:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80079ee:	981c      	ldr	r0, [sp, #112]	; 0x70
 80079f0:	3401      	adds	r4, #1
 80079f2:	9919      	ldr	r1, [sp, #100]	; 0x64
 80079f4:	2c07      	cmp	r4, #7
 80079f6:	4405      	add	r5, r0
 80079f8:	f8c9 0004 	str.w	r0, [r9, #4]
 80079fc:	bfd8      	it	le
 80079fe:	f109 0308 	addle.w	r3, r9, #8
 8007a02:	f8c9 1000 	str.w	r1, [r9]
 8007a06:	953b      	str	r5, [sp, #236]	; 0xec
 8007a08:	943a      	str	r4, [sp, #232]	; 0xe8
 8007a0a:	f300 83bc 	bgt.w	8008186 <_svfprintf_r+0x1122>
 8007a0e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8007a10:	1e56      	subs	r6, r2, #1
 8007a12:	2e00      	cmp	r6, #0
 8007a14:	f340 831d 	ble.w	8008052 <_svfprintf_r+0xfee>
 8007a18:	2e10      	cmp	r6, #16
 8007a1a:	f340 85e8 	ble.w	80085ee <_svfprintf_r+0x158a>
 8007a1e:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007a20:	2710      	movs	r7, #16
 8007a22:	f8df 84fc 	ldr.w	r8, [pc, #1276]	; 8007f20 <_svfprintf_r+0xebc>
 8007a26:	4622      	mov	r2, r4
 8007a28:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 8007a2c:	4644      	mov	r4, r8
 8007a2e:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8007a32:	e003      	b.n	8007a3c <_svfprintf_r+0x9d8>
 8007a34:	3e10      	subs	r6, #16
 8007a36:	2e10      	cmp	r6, #16
 8007a38:	f340 81c4 	ble.w	8007dc4 <_svfprintf_r+0xd60>
 8007a3c:	3201      	adds	r2, #1
 8007a3e:	601c      	str	r4, [r3, #0]
 8007a40:	605f      	str	r7, [r3, #4]
 8007a42:	3510      	adds	r5, #16
 8007a44:	3308      	adds	r3, #8
 8007a46:	2a07      	cmp	r2, #7
 8007a48:	923a      	str	r2, [sp, #232]	; 0xe8
 8007a4a:	f103 0908 	add.w	r9, r3, #8
 8007a4e:	953b      	str	r5, [sp, #236]	; 0xec
 8007a50:	ddf0      	ble.n	8007a34 <_svfprintf_r+0x9d0>
 8007a52:	4640      	mov	r0, r8
 8007a54:	4659      	mov	r1, fp
 8007a56:	aa39      	add	r2, sp, #228	; 0xe4
 8007a58:	f10a 0908 	add.w	r9, sl, #8
 8007a5c:	f004 ff5a 	bl	800c914 <__ssprint_r>
 8007a60:	4653      	mov	r3, sl
 8007a62:	2800      	cmp	r0, #0
 8007a64:	f47f abe5 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8007a68:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007a6a:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 8007a6c:	e7e2      	b.n	8007a34 <_svfprintf_r+0x9d0>
 8007a6e:	2b00      	cmp	r3, #0
 8007a70:	f040 80b7 	bne.w	8007be2 <_svfprintf_r+0xb7e>
 8007a74:	9c08      	ldr	r4, [sp, #32]
 8007a76:	f014 0f01 	tst.w	r4, #1
 8007a7a:	f000 812b 	beq.w	8007cd4 <_svfprintf_r+0xc70>
 8007a7e:	2001      	movs	r0, #1
 8007a80:	2330      	movs	r3, #48	; 0x30
 8007a82:	f10d 01e3 	add.w	r1, sp, #227	; 0xe3
 8007a86:	9010      	str	r0, [sp, #64]	; 0x40
 8007a88:	f88d 30e3 	strb.w	r3, [sp, #227]	; 0xe3
 8007a8c:	9113      	str	r1, [sp, #76]	; 0x4c
 8007a8e:	e46a      	b.n	8007366 <_svfprintf_r+0x302>
 8007a90:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007a92:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8007a94:	1b1f      	subs	r7, r3, r4
 8007a96:	2f00      	cmp	r7, #0
 8007a98:	f77f acea 	ble.w	8007470 <_svfprintf_r+0x40c>
 8007a9c:	2f10      	cmp	r7, #16
 8007a9e:	f340 8569 	ble.w	8008574 <_svfprintf_r+0x1510>
 8007aa2:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007aa4:	4633      	mov	r3, r6
 8007aa6:	f8df 8478 	ldr.w	r8, [pc, #1144]	; 8007f20 <_svfprintf_r+0xebc>
 8007aaa:	f04f 0910 	mov.w	r9, #16
 8007aae:	4622      	mov	r2, r4
 8007ab0:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 8007ab4:	4644      	mov	r4, r8
 8007ab6:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8007aba:	e002      	b.n	8007ac2 <_svfprintf_r+0xa5e>
 8007abc:	3f10      	subs	r7, #16
 8007abe:	2f10      	cmp	r7, #16
 8007ac0:	dd1b      	ble.n	8007afa <_svfprintf_r+0xa96>
 8007ac2:	3201      	adds	r2, #1
 8007ac4:	601c      	str	r4, [r3, #0]
 8007ac6:	f8c3 9004 	str.w	r9, [r3, #4]
 8007aca:	3510      	adds	r5, #16
 8007acc:	3308      	adds	r3, #8
 8007ace:	2a07      	cmp	r2, #7
 8007ad0:	923a      	str	r2, [sp, #232]	; 0xe8
 8007ad2:	f103 0608 	add.w	r6, r3, #8
 8007ad6:	953b      	str	r5, [sp, #236]	; 0xec
 8007ad8:	ddf0      	ble.n	8007abc <_svfprintf_r+0xa58>
 8007ada:	4640      	mov	r0, r8
 8007adc:	4659      	mov	r1, fp
 8007ade:	aa39      	add	r2, sp, #228	; 0xe4
 8007ae0:	f10a 0608 	add.w	r6, sl, #8
 8007ae4:	f004 ff16 	bl	800c914 <__ssprint_r>
 8007ae8:	4653      	mov	r3, sl
 8007aea:	2800      	cmp	r0, #0
 8007aec:	f47f aba1 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8007af0:	3f10      	subs	r7, #16
 8007af2:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007af4:	2f10      	cmp	r7, #16
 8007af6:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 8007af8:	dce3      	bgt.n	8007ac2 <_svfprintf_r+0xa5e>
 8007afa:	46a0      	mov	r8, r4
 8007afc:	4614      	mov	r4, r2
 8007afe:	3401      	adds	r4, #1
 8007b00:	f8c3 8000 	str.w	r8, [r3]
 8007b04:	2c07      	cmp	r4, #7
 8007b06:	605f      	str	r7, [r3, #4]
 8007b08:	443d      	add	r5, r7
 8007b0a:	943a      	str	r4, [sp, #232]	; 0xe8
 8007b0c:	953b      	str	r5, [sp, #236]	; 0xec
 8007b0e:	f77f acaf 	ble.w	8007470 <_svfprintf_r+0x40c>
 8007b12:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007b14:	aa39      	add	r2, sp, #228	; 0xe4
 8007b16:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007b18:	f004 fefc 	bl	800c914 <__ssprint_r>
 8007b1c:	2800      	cmp	r0, #0
 8007b1e:	f47f ab88 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8007b22:	9914      	ldr	r1, [sp, #80]	; 0x50
 8007b24:	4656      	mov	r6, sl
 8007b26:	9810      	ldr	r0, [sp, #64]	; 0x40
 8007b28:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007b2a:	1a0f      	subs	r7, r1, r0
 8007b2c:	2f00      	cmp	r7, #0
 8007b2e:	f73f aca5 	bgt.w	800747c <_svfprintf_r+0x418>
 8007b32:	46b1      	mov	r9, r6
 8007b34:	e4dd      	b.n	80074f2 <_svfprintf_r+0x48e>
 8007b36:	990e      	ldr	r1, [sp, #56]	; 0x38
 8007b38:	2901      	cmp	r1, #1
 8007b3a:	f77f aefe 	ble.w	800793a <_svfprintf_r+0x8d6>
 8007b3e:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007b40:	3501      	adds	r5, #1
 8007b42:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8007b44:	3401      	adds	r4, #1
 8007b46:	f8c9 3000 	str.w	r3, [r9]
 8007b4a:	2301      	movs	r3, #1
 8007b4c:	2c07      	cmp	r4, #7
 8007b4e:	f8c9 3004 	str.w	r3, [r9, #4]
 8007b52:	bfd8      	it	le
 8007b54:	f109 0908 	addle.w	r9, r9, #8
 8007b58:	953b      	str	r5, [sp, #236]	; 0xec
 8007b5a:	943a      	str	r4, [sp, #232]	; 0xe8
 8007b5c:	bfd8      	it	le
 8007b5e:	f109 0608 	addle.w	r6, r9, #8
 8007b62:	f300 8141 	bgt.w	8007de8 <_svfprintf_r+0xd84>
 8007b66:	3401      	adds	r4, #1
 8007b68:	991c      	ldr	r1, [sp, #112]	; 0x70
 8007b6a:	9819      	ldr	r0, [sp, #100]	; 0x64
 8007b6c:	2c07      	cmp	r4, #7
 8007b6e:	440d      	add	r5, r1
 8007b70:	bfd8      	it	le
 8007b72:	f106 0b08 	addle.w	fp, r6, #8
 8007b76:	f8c9 1004 	str.w	r1, [r9, #4]
 8007b7a:	f8c9 0000 	str.w	r0, [r9]
 8007b7e:	943a      	str	r4, [sp, #232]	; 0xe8
 8007b80:	953b      	str	r5, [sp, #236]	; 0xec
 8007b82:	f300 813f 	bgt.w	8007e04 <_svfprintf_r+0xda0>
 8007b86:	981a      	ldr	r0, [sp, #104]	; 0x68
 8007b88:	2200      	movs	r2, #0
 8007b8a:	2300      	movs	r3, #0
 8007b8c:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8007b8e:	f007 fdcd 	bl	800f72c <__aeabi_dcmpeq>
 8007b92:	2800      	cmp	r0, #0
 8007b94:	f040 80ce 	bne.w	8007d34 <_svfprintf_r+0xcd0>
 8007b98:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8007b9a:	3401      	adds	r4, #1
 8007b9c:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8007b9e:	1e5a      	subs	r2, r3, #1
 8007ba0:	6072      	str	r2, [r6, #4]
 8007ba2:	1c43      	adds	r3, r0, #1
 8007ba4:	2c07      	cmp	r4, #7
 8007ba6:	6033      	str	r3, [r6, #0]
 8007ba8:	4415      	add	r5, r2
 8007baa:	943a      	str	r4, [sp, #232]	; 0xe8
 8007bac:	953b      	str	r5, [sp, #236]	; 0xec
 8007bae:	f77f aed9 	ble.w	8007964 <_svfprintf_r+0x900>
 8007bb2:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007bb4:	aa39      	add	r2, sp, #228	; 0xe4
 8007bb6:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007bb8:	f004 feac 	bl	800c914 <__ssprint_r>
 8007bbc:	2800      	cmp	r0, #0
 8007bbe:	f47f ab38 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8007bc2:	f10a 0908 	add.w	r9, sl, #8
 8007bc6:	46d3      	mov	fp, sl
 8007bc8:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007bca:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007bcc:	e6cc      	b.n	8007968 <_svfprintf_r+0x904>
 8007bce:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007bd0:	aa39      	add	r2, sp, #228	; 0xe4
 8007bd2:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007bd4:	f004 fe9e 	bl	800c914 <__ssprint_r>
 8007bd8:	2800      	cmp	r0, #0
 8007bda:	f43f acf5 	beq.w	80075c8 <_svfprintf_r+0x564>
 8007bde:	f7ff bb28 	b.w	8007232 <_svfprintf_r+0x1ce>
 8007be2:	9210      	str	r2, [sp, #64]	; 0x40
 8007be4:	aa39      	add	r2, sp, #228	; 0xe4
 8007be6:	9213      	str	r2, [sp, #76]	; 0x4c
 8007be8:	f7ff bbbd 	b.w	8007366 <_svfprintf_r+0x302>
 8007bec:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007bee:	aa39      	add	r2, sp, #228	; 0xe4
 8007bf0:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007bf2:	f004 fe8f 	bl	800c914 <__ssprint_r>
 8007bf6:	2800      	cmp	r0, #0
 8007bf8:	f47f ab1b 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8007bfc:	46d1      	mov	r9, sl
 8007bfe:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007c00:	e477      	b.n	80074f2 <_svfprintf_r+0x48e>
 8007c02:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007c04:	aa39      	add	r2, sp, #228	; 0xe4
 8007c06:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007c08:	f004 fe84 	bl	800c914 <__ssprint_r>
 8007c0c:	2800      	cmp	r0, #0
 8007c0e:	f47f ab10 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8007c12:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007c14:	4656      	mov	r6, sl
 8007c16:	e427      	b.n	8007468 <_svfprintf_r+0x404>
 8007c18:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007c1a:	aa39      	add	r2, sp, #228	; 0xe4
 8007c1c:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007c1e:	f004 fe79 	bl	800c914 <__ssprint_r>
 8007c22:	2800      	cmp	r0, #0
 8007c24:	f47f ab05 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8007c28:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007c2a:	4656      	mov	r6, sl
 8007c2c:	e40c      	b.n	8007448 <_svfprintf_r+0x3e4>
 8007c2e:	9e42      	ldr	r6, [sp, #264]	; 0x108
 8007c30:	2e00      	cmp	r6, #0
 8007c32:	f340 8223 	ble.w	800807c <_svfprintf_r+0x1018>
 8007c36:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 8007c38:	9c18      	ldr	r4, [sp, #96]	; 0x60
 8007c3a:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8007c3c:	42a6      	cmp	r6, r4
 8007c3e:	bfa8      	it	ge
 8007c40:	4626      	movge	r6, r4
 8007c42:	990e      	ldr	r1, [sp, #56]	; 0x38
 8007c44:	2e00      	cmp	r6, #0
 8007c46:	eb00 0b01 	add.w	fp, r0, r1
 8007c4a:	dd0e      	ble.n	8007c6a <_svfprintf_r+0xc06>
 8007c4c:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007c4e:	19ad      	adds	r5, r5, r6
 8007c50:	f8c9 0000 	str.w	r0, [r9]
 8007c54:	3401      	adds	r4, #1
 8007c56:	f8c9 6004 	str.w	r6, [r9, #4]
 8007c5a:	2c07      	cmp	r4, #7
 8007c5c:	953b      	str	r5, [sp, #236]	; 0xec
 8007c5e:	943a      	str	r4, [sp, #232]	; 0xe8
 8007c60:	bfd8      	it	le
 8007c62:	f109 0908 	addle.w	r9, r9, #8
 8007c66:	f300 8411 	bgt.w	800848c <_svfprintf_r+0x1428>
 8007c6a:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8007c6c:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
 8007c70:	1b96      	subs	r6, r2, r6
 8007c72:	2e00      	cmp	r6, #0
 8007c74:	f340 83e9 	ble.w	800844a <_svfprintf_r+0x13e6>
 8007c78:	2e10      	cmp	r6, #16
 8007c7a:	f340 84e1 	ble.w	8008640 <_svfprintf_r+0x15dc>
 8007c7e:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007c80:	4629      	mov	r1, r5
 8007c82:	f8df 829c 	ldr.w	r8, [pc, #668]	; 8007f20 <_svfprintf_r+0xebc>
 8007c86:	2710      	movs	r7, #16
 8007c88:	4622      	mov	r2, r4
 8007c8a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8007c8c:	4644      	mov	r4, r8
 8007c8e:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8007c92:	e003      	b.n	8007c9c <_svfprintf_r+0xc38>
 8007c94:	3e10      	subs	r6, #16
 8007c96:	2e10      	cmp	r6, #16
 8007c98:	f340 8170 	ble.w	8007f7c <_svfprintf_r+0xf18>
 8007c9c:	3201      	adds	r2, #1
 8007c9e:	3110      	adds	r1, #16
 8007ca0:	2a07      	cmp	r2, #7
 8007ca2:	f8c9 4000 	str.w	r4, [r9]
 8007ca6:	f8c9 7004 	str.w	r7, [r9, #4]
 8007caa:	f109 0908 	add.w	r9, r9, #8
 8007cae:	923a      	str	r2, [sp, #232]	; 0xe8
 8007cb0:	f109 0308 	add.w	r3, r9, #8
 8007cb4:	913b      	str	r1, [sp, #236]	; 0xec
 8007cb6:	dded      	ble.n	8007c94 <_svfprintf_r+0xc30>
 8007cb8:	4640      	mov	r0, r8
 8007cba:	4629      	mov	r1, r5
 8007cbc:	aa39      	add	r2, sp, #228	; 0xe4
 8007cbe:	46d1      	mov	r9, sl
 8007cc0:	f004 fe28 	bl	800c914 <__ssprint_r>
 8007cc4:	f10a 0308 	add.w	r3, sl, #8
 8007cc8:	2800      	cmp	r0, #0
 8007cca:	f47f aab2 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8007cce:	993b      	ldr	r1, [sp, #236]	; 0xec
 8007cd0:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 8007cd2:	e7df      	b.n	8007c94 <_svfprintf_r+0xc30>
 8007cd4:	9310      	str	r3, [sp, #64]	; 0x40
 8007cd6:	ab39      	add	r3, sp, #228	; 0xe4
 8007cd8:	9313      	str	r3, [sp, #76]	; 0x4c
 8007cda:	f7ff bb44 	b.w	8007366 <_svfprintf_r+0x302>
 8007cde:	f10d 0bbc 	add.w	fp, sp, #188	; 0xbc
 8007ce2:	9917      	ldr	r1, [sp, #92]	; 0x5c
 8007ce4:	f10b 0027 	add.w	r0, fp, #39	; 0x27
 8007ce8:	f004 020f 	and.w	r2, r4, #15
 8007cec:	0923      	lsrs	r3, r4, #4
 8007cee:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 8007cf2:	ea4f 1c15 	mov.w	ip, r5, lsr #4
 8007cf6:	5c8a      	ldrb	r2, [r1, r2]
 8007cf8:	461c      	mov	r4, r3
 8007cfa:	4603      	mov	r3, r0
 8007cfc:	4665      	mov	r5, ip
 8007cfe:	3801      	subs	r0, #1
 8007d00:	701a      	strb	r2, [r3, #0]
 8007d02:	ea54 0205 	orrs.w	r2, r4, r5
 8007d06:	d1ef      	bne.n	8007ce8 <_svfprintf_r+0xc84>
 8007d08:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8007d0c:	9313      	str	r3, [sp, #76]	; 0x4c
 8007d0e:	ebc3 030b 	rsb	r3, r3, fp
 8007d12:	9310      	str	r3, [sp, #64]	; 0x40
 8007d14:	f7ff bb27 	b.w	8007366 <_svfprintf_r+0x302>
 8007d18:	2c0a      	cmp	r4, #10
 8007d1a:	f175 0100 	sbcs.w	r1, r5, #0
 8007d1e:	d27f      	bcs.n	8007e20 <_svfprintf_r+0xdbc>
 8007d20:	3430      	adds	r4, #48	; 0x30
 8007d22:	2201      	movs	r2, #1
 8007d24:	f10d 03e3 	add.w	r3, sp, #227	; 0xe3
 8007d28:	9210      	str	r2, [sp, #64]	; 0x40
 8007d2a:	f88d 40e3 	strb.w	r4, [sp, #227]	; 0xe3
 8007d2e:	9313      	str	r3, [sp, #76]	; 0x4c
 8007d30:	f7ff bb19 	b.w	8007366 <_svfprintf_r+0x302>
 8007d34:	990e      	ldr	r1, [sp, #56]	; 0x38
 8007d36:	1e4f      	subs	r7, r1, #1
 8007d38:	2f00      	cmp	r7, #0
 8007d3a:	bfdc      	itt	le
 8007d3c:	f106 0908 	addle.w	r9, r6, #8
 8007d40:	46b3      	movle	fp, r6
 8007d42:	f77f ae11 	ble.w	8007968 <_svfprintf_r+0x904>
 8007d46:	2f10      	cmp	r7, #16
 8007d48:	bfd8      	it	le
 8007d4a:	f8df 81d4 	ldrle.w	r8, [pc, #468]	; 8007f20 <_svfprintf_r+0xebc>
 8007d4e:	dd2c      	ble.n	8007daa <_svfprintf_r+0xd46>
 8007d50:	f8df 81cc 	ldr.w	r8, [pc, #460]	; 8007f20 <_svfprintf_r+0xebc>
 8007d54:	4623      	mov	r3, r4
 8007d56:	462a      	mov	r2, r5
 8007d58:	f04f 0910 	mov.w	r9, #16
 8007d5c:	4644      	mov	r4, r8
 8007d5e:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8007d60:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8007d64:	e002      	b.n	8007d6c <_svfprintf_r+0xd08>
 8007d66:	3f10      	subs	r7, #16
 8007d68:	2f10      	cmp	r7, #16
 8007d6a:	dd1b      	ble.n	8007da4 <_svfprintf_r+0xd40>
 8007d6c:	3301      	adds	r3, #1
 8007d6e:	6034      	str	r4, [r6, #0]
 8007d70:	f8c6 9004 	str.w	r9, [r6, #4]
 8007d74:	3210      	adds	r2, #16
 8007d76:	3608      	adds	r6, #8
 8007d78:	2b07      	cmp	r3, #7
 8007d7a:	933a      	str	r3, [sp, #232]	; 0xe8
 8007d7c:	f106 0b08 	add.w	fp, r6, #8
 8007d80:	923b      	str	r2, [sp, #236]	; 0xec
 8007d82:	ddf0      	ble.n	8007d66 <_svfprintf_r+0xd02>
 8007d84:	4640      	mov	r0, r8
 8007d86:	4629      	mov	r1, r5
 8007d88:	aa39      	add	r2, sp, #228	; 0xe4
 8007d8a:	f10a 0b08 	add.w	fp, sl, #8
 8007d8e:	f004 fdc1 	bl	800c914 <__ssprint_r>
 8007d92:	4656      	mov	r6, sl
 8007d94:	2800      	cmp	r0, #0
 8007d96:	f47f aa4c 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8007d9a:	3f10      	subs	r7, #16
 8007d9c:	9a3b      	ldr	r2, [sp, #236]	; 0xec
 8007d9e:	2f10      	cmp	r7, #16
 8007da0:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 8007da2:	dce3      	bgt.n	8007d6c <_svfprintf_r+0xd08>
 8007da4:	46a0      	mov	r8, r4
 8007da6:	4615      	mov	r5, r2
 8007da8:	461c      	mov	r4, r3
 8007daa:	3401      	adds	r4, #1
 8007dac:	f8c6 8000 	str.w	r8, [r6]
 8007db0:	2c07      	cmp	r4, #7
 8007db2:	6077      	str	r7, [r6, #4]
 8007db4:	443d      	add	r5, r7
 8007db6:	943a      	str	r4, [sp, #232]	; 0xe8
 8007db8:	953b      	str	r5, [sp, #236]	; 0xec
 8007dba:	f77f add3 	ble.w	8007964 <_svfprintf_r+0x900>
 8007dbe:	e6f8      	b.n	8007bb2 <_svfprintf_r+0xb4e>
 8007dc0:	2302      	movs	r3, #2
 8007dc2:	e463      	b.n	800768c <_svfprintf_r+0x628>
 8007dc4:	46a0      	mov	r8, r4
 8007dc6:	4614      	mov	r4, r2
 8007dc8:	3401      	adds	r4, #1
 8007dca:	f8c3 8000 	str.w	r8, [r3]
 8007dce:	2c07      	cmp	r4, #7
 8007dd0:	605e      	str	r6, [r3, #4]
 8007dd2:	4435      	add	r5, r6
 8007dd4:	943a      	str	r4, [sp, #232]	; 0xe8
 8007dd6:	953b      	str	r5, [sp, #236]	; 0xec
 8007dd8:	f77f aba0 	ble.w	800751c <_svfprintf_r+0x4b8>
 8007ddc:	e5d1      	b.n	8007982 <_svfprintf_r+0x91e>
 8007dde:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8007de0:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8007de2:	681a      	ldr	r2, [r3, #0]
 8007de4:	2301      	movs	r3, #1
 8007de6:	e528      	b.n	800783a <_svfprintf_r+0x7d6>
 8007de8:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007dea:	aa39      	add	r2, sp, #228	; 0xe4
 8007dec:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007dee:	f004 fd91 	bl	800c914 <__ssprint_r>
 8007df2:	2800      	cmp	r0, #0
 8007df4:	f47f aa1d 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8007df8:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007dfa:	f10a 0608 	add.w	r6, sl, #8
 8007dfe:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007e00:	46d1      	mov	r9, sl
 8007e02:	e6b0      	b.n	8007b66 <_svfprintf_r+0xb02>
 8007e04:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007e06:	aa39      	add	r2, sp, #228	; 0xe4
 8007e08:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007e0a:	f004 fd83 	bl	800c914 <__ssprint_r>
 8007e0e:	2800      	cmp	r0, #0
 8007e10:	f47f aa0f 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8007e14:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007e16:	f10a 0b08 	add.w	fp, sl, #8
 8007e1a:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007e1c:	4656      	mov	r6, sl
 8007e1e:	e6b2      	b.n	8007b86 <_svfprintf_r+0xb22>
 8007e20:	f10d 0bbc 	add.w	fp, sp, #188	; 0xbc
 8007e24:	46b1      	mov	r9, r6
 8007e26:	f10b 0827 	add.w	r8, fp, #39	; 0x27
 8007e2a:	4620      	mov	r0, r4
 8007e2c:	4629      	mov	r1, r5
 8007e2e:	220a      	movs	r2, #10
 8007e30:	2300      	movs	r3, #0
 8007e32:	f007 fcd5 	bl	800f7e0 <__aeabi_uldivmod>
 8007e36:	4646      	mov	r6, r8
 8007e38:	4620      	mov	r0, r4
 8007e3a:	4629      	mov	r1, r5
 8007e3c:	2300      	movs	r3, #0
 8007e3e:	f108 38ff 	add.w	r8, r8, #4294967295
 8007e42:	f102 0430 	add.w	r4, r2, #48	; 0x30
 8007e46:	220a      	movs	r2, #10
 8007e48:	7034      	strb	r4, [r6, #0]
 8007e4a:	f007 fcc9 	bl	800f7e0 <__aeabi_uldivmod>
 8007e4e:	4604      	mov	r4, r0
 8007e50:	460d      	mov	r5, r1
 8007e52:	ea54 0005 	orrs.w	r0, r4, r5
 8007e56:	d1e8      	bne.n	8007e2a <_svfprintf_r+0xdc6>
 8007e58:	9613      	str	r6, [sp, #76]	; 0x4c
 8007e5a:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8007e5e:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8007e60:	464e      	mov	r6, r9
 8007e62:	ebc1 010b 	rsb	r1, r1, fp
 8007e66:	9110      	str	r1, [sp, #64]	; 0x40
 8007e68:	f7ff ba7d 	b.w	8007366 <_svfprintf_r+0x302>
 8007e6c:	2a30      	cmp	r2, #48	; 0x30
 8007e6e:	f000 8333 	beq.w	80084d8 <_svfprintf_r+0x1474>
 8007e72:	9313      	str	r3, [sp, #76]	; 0x4c
 8007e74:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8007e78:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8007e7a:	ebc3 040b 	rsb	r4, r3, fp
 8007e7e:	2330      	movs	r3, #48	; 0x30
 8007e80:	9410      	str	r4, [sp, #64]	; 0x40
 8007e82:	7003      	strb	r3, [r0, #0]
 8007e84:	f7ff ba6f 	b.w	8007366 <_svfprintf_r+0x302>
 8007e88:	4264      	negs	r4, r4
 8007e8a:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 8007e8e:	232d      	movs	r3, #45	; 0x2d
 8007e90:	ea54 0005 	orrs.w	r0, r4, r5
 8007e94:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
 8007e98:	bf0c      	ite	eq
 8007e9a:	2200      	moveq	r2, #0
 8007e9c:	2201      	movne	r2, #1
 8007e9e:	2301      	movs	r3, #1
 8007ea0:	f7ff ba2c 	b.w	80072fc <_svfprintf_r+0x298>
 8007ea4:	981a      	ldr	r0, [sp, #104]	; 0x68
 8007ea6:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8007ea8:	f004 fc72 	bl	800c790 <__fpclassifyd>
 8007eac:	2800      	cmp	r0, #0
 8007eae:	f040 8175 	bne.w	800819c <_svfprintf_r+0x1138>
 8007eb2:	9014      	str	r0, [sp, #80]	; 0x50
 8007eb4:	f240 4380 	movw	r3, #1152	; 0x480
 8007eb8:	f240 427c 	movw	r2, #1148	; 0x47c
 8007ebc:	9816      	ldr	r0, [sp, #88]	; 0x58
 8007ebe:	f6c0 0201 	movt	r2, #2049	; 0x801
 8007ec2:	f6c0 0301 	movt	r3, #2049	; 0x801
 8007ec6:	2847      	cmp	r0, #71	; 0x47
 8007ec8:	bfd8      	it	le
 8007eca:	4613      	movle	r3, r2
 8007ecc:	9313      	str	r3, [sp, #76]	; 0x4c
 8007ece:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8007ed0:	2403      	movs	r4, #3
 8007ed2:	9908      	ldr	r1, [sp, #32]
 8007ed4:	940a      	str	r4, [sp, #40]	; 0x28
 8007ed6:	f021 0180 	bic.w	r1, r1, #128	; 0x80
 8007eda:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8007ede:	9108      	str	r1, [sp, #32]
 8007ee0:	9410      	str	r4, [sp, #64]	; 0x40
 8007ee2:	9318      	str	r3, [sp, #96]	; 0x60
 8007ee4:	f7ff ba49 	b.w	800737a <_svfprintf_r+0x316>
 8007ee8:	7813      	ldrb	r3, [r2, #0]
 8007eea:	f7ff b928 	b.w	800713e <_svfprintf_r+0xda>
 8007eee:	9912      	ldr	r1, [sp, #72]	; 0x48
 8007ef0:	1dcb      	adds	r3, r1, #7
 8007ef2:	f023 0307 	bic.w	r3, r3, #7
 8007ef6:	f103 0208 	add.w	r2, r3, #8
 8007efa:	9212      	str	r2, [sp, #72]	; 0x48
 8007efc:	681c      	ldr	r4, [r3, #0]
 8007efe:	941a      	str	r4, [sp, #104]	; 0x68
 8007f00:	685b      	ldr	r3, [r3, #4]
 8007f02:	931b      	str	r3, [sp, #108]	; 0x6c
 8007f04:	f7ff bb77 	b.w	80075f6 <_svfprintf_r+0x592>
 8007f08:	9b08      	ldr	r3, [sp, #32]
 8007f0a:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007f0e:	f000 8126 	beq.w	800815e <_svfprintf_r+0x10fa>
 8007f12:	9812      	ldr	r0, [sp, #72]	; 0x48
 8007f14:	2500      	movs	r5, #0
 8007f16:	8804      	ldrh	r4, [r0, #0]
 8007f18:	3004      	adds	r0, #4
 8007f1a:	9012      	str	r0, [sp, #72]	; 0x48
 8007f1c:	f7ff bbde 	b.w	80076dc <_svfprintf_r+0x678>
 8007f20:	08010190 	.word	0x08010190
 8007f24:	9b08      	ldr	r3, [sp, #32]
 8007f26:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007f2a:	f000 8111 	beq.w	8008150 <_svfprintf_r+0x10ec>
 8007f2e:	9812      	ldr	r0, [sp, #72]	; 0x48
 8007f30:	f9b0 4000 	ldrsh.w	r4, [r0]
 8007f34:	3004      	adds	r0, #4
 8007f36:	9012      	str	r0, [sp, #72]	; 0x48
 8007f38:	17e5      	asrs	r5, r4, #31
 8007f3a:	f7ff b9d3 	b.w	80072e4 <_svfprintf_r+0x280>
 8007f3e:	9908      	ldr	r1, [sp, #32]
 8007f40:	f011 0f10 	tst.w	r1, #16
 8007f44:	f000 8112 	beq.w	800816c <_svfprintf_r+0x1108>
 8007f48:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8007f4a:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 8007f4c:	6813      	ldr	r3, [r2, #0]
 8007f4e:	3204      	adds	r2, #4
 8007f50:	9212      	str	r2, [sp, #72]	; 0x48
 8007f52:	601c      	str	r4, [r3, #0]
 8007f54:	f7ff b8af 	b.w	80070b6 <_svfprintf_r+0x52>
 8007f58:	9808      	ldr	r0, [sp, #32]
 8007f5a:	f010 0340 	ands.w	r3, r0, #64	; 0x40
 8007f5e:	f000 81fc 	beq.w	800835a <_svfprintf_r+0x12f6>
 8007f62:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8007f64:	2500      	movs	r5, #0
 8007f66:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8007f68:	8819      	ldrh	r1, [r3, #0]
 8007f6a:	3404      	adds	r4, #4
 8007f6c:	4613      	mov	r3, r2
 8007f6e:	9412      	str	r4, [sp, #72]	; 0x48
 8007f70:	1e0a      	subs	r2, r1, #0
 8007f72:	460c      	mov	r4, r1
 8007f74:	bf18      	it	ne
 8007f76:	2201      	movne	r2, #1
 8007f78:	f7ff bb88 	b.w	800768c <_svfprintf_r+0x628>
 8007f7c:	46a0      	mov	r8, r4
 8007f7e:	460d      	mov	r5, r1
 8007f80:	4614      	mov	r4, r2
 8007f82:	3401      	adds	r4, #1
 8007f84:	f8c9 8000 	str.w	r8, [r9]
 8007f88:	2c07      	cmp	r4, #7
 8007f8a:	f8c9 6004 	str.w	r6, [r9, #4]
 8007f8e:	4435      	add	r5, r6
 8007f90:	943a      	str	r4, [sp, #232]	; 0xe8
 8007f92:	953b      	str	r5, [sp, #236]	; 0xec
 8007f94:	f300 82af 	bgt.w	80084f6 <_svfprintf_r+0x1492>
 8007f98:	9a42      	ldr	r2, [sp, #264]	; 0x108
 8007f9a:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 8007f9c:	42a2      	cmp	r2, r4
 8007f9e:	db4a      	blt.n	8008036 <_svfprintf_r+0xfd2>
 8007fa0:	9808      	ldr	r0, [sp, #32]
 8007fa2:	f010 0f01 	tst.w	r0, #1
 8007fa6:	d146      	bne.n	8008036 <_svfprintf_r+0xfd2>
 8007fa8:	9c13      	ldr	r4, [sp, #76]	; 0x4c
 8007faa:	9818      	ldr	r0, [sp, #96]	; 0x60
 8007fac:	1821      	adds	r1, r4, r0
 8007fae:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 8007fb0:	ebc1 070b 	rsb	r7, r1, fp
 8007fb4:	1aa2      	subs	r2, r4, r2
 8007fb6:	42ba      	cmp	r2, r7
 8007fb8:	bfb8      	it	lt
 8007fba:	4617      	movlt	r7, r2
 8007fbc:	2f00      	cmp	r7, #0
 8007fbe:	dd0a      	ble.n	8007fd6 <_svfprintf_r+0xf72>
 8007fc0:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007fc2:	19ed      	adds	r5, r5, r7
 8007fc4:	6019      	str	r1, [r3, #0]
 8007fc6:	3401      	adds	r4, #1
 8007fc8:	605f      	str	r7, [r3, #4]
 8007fca:	2c07      	cmp	r4, #7
 8007fcc:	953b      	str	r5, [sp, #236]	; 0xec
 8007fce:	943a      	str	r4, [sp, #232]	; 0xe8
 8007fd0:	f300 8274 	bgt.w	80084bc <_svfprintf_r+0x1458>
 8007fd4:	3308      	adds	r3, #8
 8007fd6:	ea27 76e7 	bic.w	r6, r7, r7, asr #31
 8007fda:	1b96      	subs	r6, r2, r6
 8007fdc:	2e00      	cmp	r6, #0
 8007fde:	dd38      	ble.n	8008052 <_svfprintf_r+0xfee>
 8007fe0:	2e10      	cmp	r6, #16
 8007fe2:	f340 8304 	ble.w	80085ee <_svfprintf_r+0x158a>
 8007fe6:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007fe8:	2710      	movs	r7, #16
 8007fea:	f8df 86b4 	ldr.w	r8, [pc, #1716]	; 80086a0 <_svfprintf_r+0x163c>
 8007fee:	4622      	mov	r2, r4
 8007ff0:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 8007ff4:	4644      	mov	r4, r8
 8007ff6:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8007ffa:	e003      	b.n	8008004 <_svfprintf_r+0xfa0>
 8007ffc:	3e10      	subs	r6, #16
 8007ffe:	2e10      	cmp	r6, #16
 8008000:	f77f aee0 	ble.w	8007dc4 <_svfprintf_r+0xd60>
 8008004:	3201      	adds	r2, #1
 8008006:	601c      	str	r4, [r3, #0]
 8008008:	605f      	str	r7, [r3, #4]
 800800a:	3510      	adds	r5, #16
 800800c:	3308      	adds	r3, #8
 800800e:	2a07      	cmp	r2, #7
 8008010:	923a      	str	r2, [sp, #232]	; 0xe8
 8008012:	f103 0908 	add.w	r9, r3, #8
 8008016:	953b      	str	r5, [sp, #236]	; 0xec
 8008018:	ddf0      	ble.n	8007ffc <_svfprintf_r+0xf98>
 800801a:	4640      	mov	r0, r8
 800801c:	4659      	mov	r1, fp
 800801e:	aa39      	add	r2, sp, #228	; 0xe4
 8008020:	f10a 0908 	add.w	r9, sl, #8
 8008024:	f004 fc76 	bl	800c914 <__ssprint_r>
 8008028:	4653      	mov	r3, sl
 800802a:	2800      	cmp	r0, #0
 800802c:	f47f a901 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8008030:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8008032:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 8008034:	e7e2      	b.n	8007ffc <_svfprintf_r+0xf98>
 8008036:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8008038:	991c      	ldr	r1, [sp, #112]	; 0x70
 800803a:	3401      	adds	r4, #1
 800803c:	9819      	ldr	r0, [sp, #100]	; 0x64
 800803e:	2c07      	cmp	r4, #7
 8008040:	440d      	add	r5, r1
 8008042:	6059      	str	r1, [r3, #4]
 8008044:	6018      	str	r0, [r3, #0]
 8008046:	953b      	str	r5, [sp, #236]	; 0xec
 8008048:	943a      	str	r4, [sp, #232]	; 0xe8
 800804a:	f300 822b 	bgt.w	80084a4 <_svfprintf_r+0x1440>
 800804e:	3308      	adds	r3, #8
 8008050:	e7aa      	b.n	8007fa8 <_svfprintf_r+0xf44>
 8008052:	4699      	mov	r9, r3
 8008054:	f7ff ba62 	b.w	800751c <_svfprintf_r+0x4b8>
 8008058:	f106 0908 	add.w	r9, r6, #8
 800805c:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 800805e:	f8df 8640 	ldr.w	r8, [pc, #1600]	; 80086a0 <_svfprintf_r+0x163c>
 8008062:	f7ff ba3c 	b.w	80074de <_svfprintf_r+0x47a>
 8008066:	9811      	ldr	r0, [sp, #68]	; 0x44
 8008068:	aa39      	add	r2, sp, #228	; 0xe4
 800806a:	990c      	ldr	r1, [sp, #48]	; 0x30
 800806c:	f004 fc52 	bl	800c914 <__ssprint_r>
 8008070:	2800      	cmp	r0, #0
 8008072:	f47f a8de 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8008076:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8008078:	46d1      	mov	r9, sl
 800807a:	e4ae      	b.n	80079da <_svfprintf_r+0x976>
 800807c:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 800807e:	f240 43b4 	movw	r3, #1204	; 0x4b4
 8008082:	f6c0 0301 	movt	r3, #2049	; 0x801
 8008086:	f8c9 3000 	str.w	r3, [r9]
 800808a:	3401      	adds	r4, #1
 800808c:	2301      	movs	r3, #1
 800808e:	2c07      	cmp	r4, #7
 8008090:	f8c9 3004 	str.w	r3, [r9, #4]
 8008094:	441d      	add	r5, r3
 8008096:	943a      	str	r4, [sp, #232]	; 0xe8
 8008098:	953b      	str	r5, [sp, #236]	; 0xec
 800809a:	bfd8      	it	le
 800809c:	f109 0908 	addle.w	r9, r9, #8
 80080a0:	f300 818c 	bgt.w	80083bc <_svfprintf_r+0x1358>
 80080a4:	b936      	cbnz	r6, 80080b4 <_svfprintf_r+0x1050>
 80080a6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80080a8:	b923      	cbnz	r3, 80080b4 <_svfprintf_r+0x1050>
 80080aa:	9c08      	ldr	r4, [sp, #32]
 80080ac:	f014 0f01 	tst.w	r4, #1
 80080b0:	f43f aa34 	beq.w	800751c <_svfprintf_r+0x4b8>
 80080b4:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80080b6:	981c      	ldr	r0, [sp, #112]	; 0x70
 80080b8:	3401      	adds	r4, #1
 80080ba:	9919      	ldr	r1, [sp, #100]	; 0x64
 80080bc:	2c07      	cmp	r4, #7
 80080be:	4405      	add	r5, r0
 80080c0:	f8c9 0004 	str.w	r0, [r9, #4]
 80080c4:	f8c9 1000 	str.w	r1, [r9]
 80080c8:	bfd8      	it	le
 80080ca:	f109 0908 	addle.w	r9, r9, #8
 80080ce:	953b      	str	r5, [sp, #236]	; 0xec
 80080d0:	943a      	str	r4, [sp, #232]	; 0xe8
 80080d2:	f300 81ab 	bgt.w	800842c <_svfprintf_r+0x13c8>
 80080d6:	4276      	negs	r6, r6
 80080d8:	2e00      	cmp	r6, #0
 80080da:	f340 8198 	ble.w	800840e <_svfprintf_r+0x13aa>
 80080de:	2e10      	cmp	r6, #16
 80080e0:	bfd8      	it	le
 80080e2:	f8df 85bc 	ldrle.w	r8, [pc, #1468]	; 80086a0 <_svfprintf_r+0x163c>
 80080e6:	f340 817a 	ble.w	80083de <_svfprintf_r+0x137a>
 80080ea:	f8df 85b4 	ldr.w	r8, [pc, #1460]	; 80086a0 <_svfprintf_r+0x163c>
 80080ee:	4623      	mov	r3, r4
 80080f0:	2710      	movs	r7, #16
 80080f2:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 80080f6:	4644      	mov	r4, r8
 80080f8:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 80080fc:	e003      	b.n	8008106 <_svfprintf_r+0x10a2>
 80080fe:	3e10      	subs	r6, #16
 8008100:	2e10      	cmp	r6, #16
 8008102:	f340 816a 	ble.w	80083da <_svfprintf_r+0x1376>
 8008106:	3301      	adds	r3, #1
 8008108:	3510      	adds	r5, #16
 800810a:	2b07      	cmp	r3, #7
 800810c:	f8c9 4000 	str.w	r4, [r9]
 8008110:	f8c9 7004 	str.w	r7, [r9, #4]
 8008114:	f109 0908 	add.w	r9, r9, #8
 8008118:	933a      	str	r3, [sp, #232]	; 0xe8
 800811a:	953b      	str	r5, [sp, #236]	; 0xec
 800811c:	ddef      	ble.n	80080fe <_svfprintf_r+0x109a>
 800811e:	4640      	mov	r0, r8
 8008120:	4659      	mov	r1, fp
 8008122:	aa39      	add	r2, sp, #228	; 0xe4
 8008124:	46d1      	mov	r9, sl
 8008126:	f004 fbf5 	bl	800c914 <__ssprint_r>
 800812a:	2800      	cmp	r0, #0
 800812c:	f47f a881 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8008130:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8008132:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 8008134:	e7e3      	b.n	80080fe <_svfprintf_r+0x109a>
 8008136:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8008138:	2200      	movs	r2, #0
 800813a:	9412      	str	r4, [sp, #72]	; 0x48
 800813c:	2400      	movs	r4, #0
 800813e:	9214      	str	r2, [sp, #80]	; 0x50
 8008140:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8008144:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8008148:	930a      	str	r3, [sp, #40]	; 0x28
 800814a:	9418      	str	r4, [sp, #96]	; 0x60
 800814c:	f7ff b915 	b.w	800737a <_svfprintf_r+0x316>
 8008150:	9912      	ldr	r1, [sp, #72]	; 0x48
 8008152:	680c      	ldr	r4, [r1, #0]
 8008154:	3104      	adds	r1, #4
 8008156:	9112      	str	r1, [sp, #72]	; 0x48
 8008158:	17e5      	asrs	r5, r4, #31
 800815a:	f7ff b8c3 	b.w	80072e4 <_svfprintf_r+0x280>
 800815e:	9912      	ldr	r1, [sp, #72]	; 0x48
 8008160:	2500      	movs	r5, #0
 8008162:	680c      	ldr	r4, [r1, #0]
 8008164:	3104      	adds	r1, #4
 8008166:	9112      	str	r1, [sp, #72]	; 0x48
 8008168:	f7ff bab8 	b.w	80076dc <_svfprintf_r+0x678>
 800816c:	9808      	ldr	r0, [sp, #32]
 800816e:	f010 0f40 	tst.w	r0, #64	; 0x40
 8008172:	f000 810c 	beq.w	800838e <_svfprintf_r+0x132a>
 8008176:	9912      	ldr	r1, [sp, #72]	; 0x48
 8008178:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800817a:	680b      	ldr	r3, [r1, #0]
 800817c:	3104      	adds	r1, #4
 800817e:	9112      	str	r1, [sp, #72]	; 0x48
 8008180:	801a      	strh	r2, [r3, #0]
 8008182:	f7fe bf98 	b.w	80070b6 <_svfprintf_r+0x52>
 8008186:	9811      	ldr	r0, [sp, #68]	; 0x44
 8008188:	aa39      	add	r2, sp, #228	; 0xe4
 800818a:	990c      	ldr	r1, [sp, #48]	; 0x30
 800818c:	f004 fbc2 	bl	800c914 <__ssprint_r>
 8008190:	2800      	cmp	r0, #0
 8008192:	f47f a84e 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8008196:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8008198:	4653      	mov	r3, sl
 800819a:	e438      	b.n	8007a0e <_svfprintf_r+0x9aa>
 800819c:	f1b7 3fff 	cmp.w	r7, #4294967295
 80081a0:	f000 8151 	beq.w	8008446 <_svfprintf_r+0x13e2>
 80081a4:	9c16      	ldr	r4, [sp, #88]	; 0x58
 80081a6:	f1a4 0e67 	sub.w	lr, r4, #103	; 0x67
 80081aa:	f1de 0300 	rsbs	r3, lr, #0
 80081ae:	eb43 030e 	adc.w	r3, r3, lr
 80081b2:	2c47      	cmp	r4, #71	; 0x47
 80081b4:	bf08      	it	eq
 80081b6:	f043 0301 	orreq.w	r3, r3, #1
 80081ba:	b113      	cbz	r3, 80081c2 <_svfprintf_r+0x115e>
 80081bc:	2f00      	cmp	r7, #0
 80081be:	bf08      	it	eq
 80081c0:	2701      	moveq	r7, #1
 80081c2:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80081c4:	9808      	ldr	r0, [sp, #32]
 80081c6:	2b00      	cmp	r3, #0
 80081c8:	f440 7080 	orr.w	r0, r0, #256	; 0x100
 80081cc:	9008      	str	r0, [sp, #32]
 80081ce:	f2c0 8201 	blt.w	80085d4 <_svfprintf_r+0x1570>
 80081d2:	f8dd 906c 	ldr.w	r9, [sp, #108]	; 0x6c
 80081d6:	2200      	movs	r2, #0
 80081d8:	9214      	str	r2, [sp, #80]	; 0x50
 80081da:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80081dc:	f1a3 0466 	sub.w	r4, r3, #102	; 0x66
 80081e0:	f1d4 0b00 	rsbs	fp, r4, #0
 80081e4:	eb4b 0b04 	adc.w	fp, fp, r4
 80081e8:	2b46      	cmp	r3, #70	; 0x46
 80081ea:	bf08      	it	eq
 80081ec:	f04b 0b01 	orreq.w	fp, fp, #1
 80081f0:	f1bb 0f00 	cmp.w	fp, #0
 80081f4:	f040 81bb 	bne.w	800856e <_svfprintf_r+0x150a>
 80081f8:	2b45      	cmp	r3, #69	; 0x45
 80081fa:	d002      	beq.n	8008202 <_svfprintf_r+0x119e>
 80081fc:	2b65      	cmp	r3, #101	; 0x65
 80081fe:	f040 81e6 	bne.w	80085ce <_svfprintf_r+0x156a>
 8008202:	f107 0801 	add.w	r8, r7, #1
 8008206:	2302      	movs	r3, #2
 8008208:	9c1a      	ldr	r4, [sp, #104]	; 0x68
 800820a:	a942      	add	r1, sp, #264	; 0x108
 800820c:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
 8008210:	9300      	str	r3, [sp, #0]
 8008212:	940a      	str	r4, [sp, #40]	; 0x28
 8008214:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 8008218:	9811      	ldr	r0, [sp, #68]	; 0x44
 800821a:	9102      	str	r1, [sp, #8]
 800821c:	a941      	add	r1, sp, #260	; 0x104
 800821e:	f8cd 8004 	str.w	r8, [sp, #4]
 8008222:	9103      	str	r1, [sp, #12]
 8008224:	a940      	add	r1, sp, #256	; 0x100
 8008226:	9104      	str	r1, [sp, #16]
 8008228:	f002 f884 	bl	800a334 <_dtoa_r>
 800822c:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800822e:	f1b2 0367 	subs.w	r3, r2, #103	; 0x67
 8008232:	bf18      	it	ne
 8008234:	2301      	movne	r3, #1
 8008236:	2a47      	cmp	r2, #71	; 0x47
 8008238:	bf0c      	ite	eq
 800823a:	2300      	moveq	r3, #0
 800823c:	f003 0301 	andne.w	r3, r3, #1
 8008240:	9013      	str	r0, [sp, #76]	; 0x4c
 8008242:	b923      	cbnz	r3, 800824e <_svfprintf_r+0x11ea>
 8008244:	9b08      	ldr	r3, [sp, #32]
 8008246:	f013 0f01 	tst.w	r3, #1
 800824a:	f000 81e1 	beq.w	8008610 <_svfprintf_r+0x15ac>
 800824e:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8008250:	eb00 0408 	add.w	r4, r0, r8
 8008254:	f1bb 0f00 	cmp.w	fp, #0
 8008258:	d005      	beq.n	8008266 <_svfprintf_r+0x1202>
 800825a:	7803      	ldrb	r3, [r0, #0]
 800825c:	2b30      	cmp	r3, #48	; 0x30
 800825e:	f000 81e2 	beq.w	8008626 <_svfprintf_r+0x15c2>
 8008262:	9b42      	ldr	r3, [sp, #264]	; 0x108
 8008264:	18e4      	adds	r4, r4, r3
 8008266:	981a      	ldr	r0, [sp, #104]	; 0x68
 8008268:	2200      	movs	r2, #0
 800826a:	2300      	movs	r3, #0
 800826c:	4649      	mov	r1, r9
 800826e:	f007 fa5d 	bl	800f72c <__aeabi_dcmpeq>
 8008272:	2800      	cmp	r0, #0
 8008274:	f000 8185 	beq.w	8008582 <_svfprintf_r+0x151e>
 8008278:	4623      	mov	r3, r4
 800827a:	9440      	str	r4, [sp, #256]	; 0x100
 800827c:	9916      	ldr	r1, [sp, #88]	; 0x58
 800827e:	9c13      	ldr	r4, [sp, #76]	; 0x4c
 8008280:	f1a1 0067 	sub.w	r0, r1, #103	; 0x67
 8008284:	4242      	negs	r2, r0
 8008286:	ebc4 0303 	rsb	r3, r4, r3
 800828a:	eb42 0200 	adc.w	r2, r2, r0
 800828e:	930e      	str	r3, [sp, #56]	; 0x38
 8008290:	2947      	cmp	r1, #71	; 0x47
 8008292:	bf14      	ite	ne
 8008294:	4613      	movne	r3, r2
 8008296:	f042 0301 	orreq.w	r3, r2, #1
 800829a:	2b00      	cmp	r3, #0
 800829c:	f000 8148 	beq.w	8008530 <_svfprintf_r+0x14cc>
 80082a0:	9b42      	ldr	r3, [sp, #264]	; 0x108
 80082a2:	f113 0f03 	cmn.w	r3, #3
 80082a6:	9310      	str	r3, [sp, #64]	; 0x40
 80082a8:	db02      	blt.n	80082b0 <_svfprintf_r+0x124c>
 80082aa:	429f      	cmp	r7, r3
 80082ac:	f280 8174 	bge.w	8008598 <_svfprintf_r+0x1534>
 80082b0:	9816      	ldr	r0, [sp, #88]	; 0x58
 80082b2:	3802      	subs	r0, #2
 80082b4:	9016      	str	r0, [sp, #88]	; 0x58
 80082b6:	3b01      	subs	r3, #1
 80082b8:	9a16      	ldr	r2, [sp, #88]	; 0x58
 80082ba:	2b00      	cmp	r3, #0
 80082bc:	9342      	str	r3, [sp, #264]	; 0x108
 80082be:	f88d 20f8 	strb.w	r2, [sp, #248]	; 0xf8
 80082c2:	f2c0 81c3 	blt.w	800864c <_svfprintf_r+0x15e8>
 80082c6:	222b      	movs	r2, #43	; 0x2b
 80082c8:	f88d 20f9 	strb.w	r2, [sp, #249]	; 0xf9
 80082cc:	2b09      	cmp	r3, #9
 80082ce:	f340 8186 	ble.w	80085de <_svfprintf_r+0x157a>
 80082d2:	f246 6467 	movw	r4, #26215	; 0x6667
 80082d6:	f10d 00f6 	add.w	r0, sp, #246	; 0xf6
 80082da:	f2c6 6466 	movt	r4, #26214	; 0x6666
 80082de:	fb84 2103 	smull	r2, r1, r4, r3
 80082e2:	17da      	asrs	r2, r3, #31
 80082e4:	4605      	mov	r5, r0
 80082e6:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
 80082ea:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 80082ee:	eba3 0141 	sub.w	r1, r3, r1, lsl #1
 80082f2:	4613      	mov	r3, r2
 80082f4:	3130      	adds	r1, #48	; 0x30
 80082f6:	2a09      	cmp	r2, #9
 80082f8:	f800 1901 	strb.w	r1, [r0], #-1
 80082fc:	dcef      	bgt.n	80082de <_svfprintf_r+0x127a>
 80082fe:	3330      	adds	r3, #48	; 0x30
 8008300:	1e6a      	subs	r2, r5, #1
 8008302:	f805 3c01 	strb.w	r3, [r5, #-1]
 8008306:	f10d 03f7 	add.w	r3, sp, #247	; 0xf7
 800830a:	429a      	cmp	r2, r3
 800830c:	f080 81c4 	bcs.w	8008698 <_svfprintf_r+0x1634>
 8008310:	f10d 03fa 	add.w	r3, sp, #250	; 0xfa
 8008314:	f812 1b01 	ldrb.w	r1, [r2], #1
 8008318:	f803 1b01 	strb.w	r1, [r3], #1
 800831c:	4619      	mov	r1, r3
 800831e:	9c07      	ldr	r4, [sp, #28]
 8008320:	4294      	cmp	r4, r2
 8008322:	d8f7      	bhi.n	8008314 <_svfprintf_r+0x12b0>
 8008324:	ab3e      	add	r3, sp, #248	; 0xf8
 8008326:	980e      	ldr	r0, [sp, #56]	; 0x38
 8008328:	1acb      	subs	r3, r1, r3
 800832a:	990e      	ldr	r1, [sp, #56]	; 0x38
 800832c:	1818      	adds	r0, r3, r0
 800832e:	931d      	str	r3, [sp, #116]	; 0x74
 8008330:	2901      	cmp	r1, #1
 8008332:	9010      	str	r0, [sp, #64]	; 0x40
 8008334:	f340 816e 	ble.w	8008614 <_svfprintf_r+0x15b0>
 8008338:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800833a:	2400      	movs	r4, #0
 800833c:	9418      	str	r4, [sp, #96]	; 0x60
 800833e:	3301      	adds	r3, #1
 8008340:	9310      	str	r3, [sp, #64]	; 0x40
 8008342:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8008344:	2b00      	cmp	r3, #0
 8008346:	f040 8107 	bne.w	8008558 <_svfprintf_r+0x14f4>
 800834a:	9c10      	ldr	r4, [sp, #64]	; 0x40
 800834c:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8008350:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
 8008354:	940a      	str	r4, [sp, #40]	; 0x28
 8008356:	f7ff b810 	b.w	800737a <_svfprintf_r+0x316>
 800835a:	9812      	ldr	r0, [sp, #72]	; 0x48
 800835c:	2500      	movs	r5, #0
 800835e:	6802      	ldr	r2, [r0, #0]
 8008360:	3004      	adds	r0, #4
 8008362:	9012      	str	r0, [sp, #72]	; 0x48
 8008364:	4614      	mov	r4, r2
 8008366:	3a00      	subs	r2, #0
 8008368:	bf18      	it	ne
 800836a:	2201      	movne	r2, #1
 800836c:	f7ff b98e 	b.w	800768c <_svfprintf_r+0x628>
 8008370:	2140      	movs	r1, #64	; 0x40
 8008372:	9811      	ldr	r0, [sp, #68]	; 0x44
 8008374:	f7fe f8f4 	bl	8006560 <_malloc_r>
 8008378:	990c      	ldr	r1, [sp, #48]	; 0x30
 800837a:	6008      	str	r0, [r1, #0]
 800837c:	6108      	str	r0, [r1, #16]
 800837e:	2800      	cmp	r0, #0
 8008380:	f000 8182 	beq.w	8008688 <_svfprintf_r+0x1624>
 8008384:	980c      	ldr	r0, [sp, #48]	; 0x30
 8008386:	2340      	movs	r3, #64	; 0x40
 8008388:	6143      	str	r3, [r0, #20]
 800838a:	f7fe be82 	b.w	8007092 <_svfprintf_r+0x2e>
 800838e:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8008390:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8008392:	6823      	ldr	r3, [r4, #0]
 8008394:	3404      	adds	r4, #4
 8008396:	9412      	str	r4, [sp, #72]	; 0x48
 8008398:	6018      	str	r0, [r3, #0]
 800839a:	f7fe be8c 	b.w	80070b6 <_svfprintf_r+0x52>
 800839e:	9811      	ldr	r0, [sp, #68]	; 0x44
 80083a0:	aa39      	add	r2, sp, #228	; 0xe4
 80083a2:	990c      	ldr	r1, [sp, #48]	; 0x30
 80083a4:	f004 fab6 	bl	800c914 <__ssprint_r>
 80083a8:	2800      	cmp	r0, #0
 80083aa:	f47e af42 	bne.w	8007232 <_svfprintf_r+0x1ce>
 80083ae:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80083b0:	f10d 0984 	add.w	r9, sp, #132	; 0x84
 80083b4:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80083b6:	46d3      	mov	fp, sl
 80083b8:	f7ff bad6 	b.w	8007968 <_svfprintf_r+0x904>
 80083bc:	9811      	ldr	r0, [sp, #68]	; 0x44
 80083be:	aa39      	add	r2, sp, #228	; 0xe4
 80083c0:	990c      	ldr	r1, [sp, #48]	; 0x30
 80083c2:	f004 faa7 	bl	800c914 <__ssprint_r>
 80083c6:	2800      	cmp	r0, #0
 80083c8:	f47e af33 	bne.w	8007232 <_svfprintf_r+0x1ce>
 80083cc:	9e42      	ldr	r6, [sp, #264]	; 0x108
 80083ce:	46d1      	mov	r9, sl
 80083d0:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80083d2:	2e00      	cmp	r6, #0
 80083d4:	f47f ae6e 	bne.w	80080b4 <_svfprintf_r+0x1050>
 80083d8:	e665      	b.n	80080a6 <_svfprintf_r+0x1042>
 80083da:	46a0      	mov	r8, r4
 80083dc:	461c      	mov	r4, r3
 80083de:	3401      	adds	r4, #1
 80083e0:	f8c9 8000 	str.w	r8, [r9]
 80083e4:	2c07      	cmp	r4, #7
 80083e6:	f8c9 6004 	str.w	r6, [r9, #4]
 80083ea:	4435      	add	r5, r6
 80083ec:	943a      	str	r4, [sp, #232]	; 0xe8
 80083ee:	953b      	str	r5, [sp, #236]	; 0xec
 80083f0:	bfd8      	it	le
 80083f2:	f109 0908 	addle.w	r9, r9, #8
 80083f6:	dd0a      	ble.n	800840e <_svfprintf_r+0x13aa>
 80083f8:	9811      	ldr	r0, [sp, #68]	; 0x44
 80083fa:	aa39      	add	r2, sp, #228	; 0xe4
 80083fc:	990c      	ldr	r1, [sp, #48]	; 0x30
 80083fe:	f004 fa89 	bl	800c914 <__ssprint_r>
 8008402:	2800      	cmp	r0, #0
 8008404:	f47e af15 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8008408:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800840a:	46d1      	mov	r9, sl
 800840c:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 800840e:	3401      	adds	r4, #1
 8008410:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8008412:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8008414:	2c07      	cmp	r4, #7
 8008416:	441d      	add	r5, r3
 8008418:	f8c9 3004 	str.w	r3, [r9, #4]
 800841c:	f8c9 2000 	str.w	r2, [r9]
 8008420:	943a      	str	r4, [sp, #232]	; 0xe8
 8008422:	953b      	str	r5, [sp, #236]	; 0xec
 8008424:	f77f a878 	ble.w	8007518 <_svfprintf_r+0x4b4>
 8008428:	f7ff baab 	b.w	8007982 <_svfprintf_r+0x91e>
 800842c:	9811      	ldr	r0, [sp, #68]	; 0x44
 800842e:	aa39      	add	r2, sp, #228	; 0xe4
 8008430:	990c      	ldr	r1, [sp, #48]	; 0x30
 8008432:	f004 fa6f 	bl	800c914 <__ssprint_r>
 8008436:	2800      	cmp	r0, #0
 8008438:	f47e aefb 	bne.w	8007232 <_svfprintf_r+0x1ce>
 800843c:	9e42      	ldr	r6, [sp, #264]	; 0x108
 800843e:	46d1      	mov	r9, sl
 8008440:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8008442:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8008444:	e647      	b.n	80080d6 <_svfprintf_r+0x1072>
 8008446:	2706      	movs	r7, #6
 8008448:	e6bb      	b.n	80081c2 <_svfprintf_r+0x115e>
 800844a:	464b      	mov	r3, r9
 800844c:	e5a4      	b.n	8007f98 <_svfprintf_r+0xf34>
 800844e:	222d      	movs	r2, #45	; 0x2d
 8008450:	f88d 210f 	strb.w	r2, [sp, #271]	; 0x10f
 8008454:	f7ff b8e1 	b.w	800761a <_svfprintf_r+0x5b6>
 8008458:	9813      	ldr	r0, [sp, #76]	; 0x4c
 800845a:	2100      	movs	r1, #0
 800845c:	9114      	str	r1, [sp, #80]	; 0x50
 800845e:	f004 fa29 	bl	800c8b4 <strlen>
 8008462:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8008464:	9412      	str	r4, [sp, #72]	; 0x48
 8008466:	9318      	str	r3, [sp, #96]	; 0x60
 8008468:	ea20 72e0 	bic.w	r2, r0, r0, asr #31
 800846c:	9010      	str	r0, [sp, #64]	; 0x40
 800846e:	920a      	str	r2, [sp, #40]	; 0x28
 8008470:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8008474:	f7fe bf81 	b.w	800737a <_svfprintf_r+0x316>
 8008478:	f240 1880 	movw	r8, #384	; 0x180
 800847c:	f106 0308 	add.w	r3, r6, #8
 8008480:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8008482:	f6c0 0801 	movt	r8, #2049	; 0x801
 8008486:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8008488:	f7fe bfc2 	b.w	8007410 <_svfprintf_r+0x3ac>
 800848c:	9811      	ldr	r0, [sp, #68]	; 0x44
 800848e:	aa39      	add	r2, sp, #228	; 0xe4
 8008490:	990c      	ldr	r1, [sp, #48]	; 0x30
 8008492:	f004 fa3f 	bl	800c914 <__ssprint_r>
 8008496:	2800      	cmp	r0, #0
 8008498:	f47e aecb 	bne.w	8007232 <_svfprintf_r+0x1ce>
 800849c:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800849e:	46d1      	mov	r9, sl
 80084a0:	f7ff bbe3 	b.w	8007c6a <_svfprintf_r+0xc06>
 80084a4:	9811      	ldr	r0, [sp, #68]	; 0x44
 80084a6:	aa39      	add	r2, sp, #228	; 0xe4
 80084a8:	990c      	ldr	r1, [sp, #48]	; 0x30
 80084aa:	f004 fa33 	bl	800c914 <__ssprint_r>
 80084ae:	2800      	cmp	r0, #0
 80084b0:	f47e aebf 	bne.w	8007232 <_svfprintf_r+0x1ce>
 80084b4:	9a42      	ldr	r2, [sp, #264]	; 0x108
 80084b6:	4653      	mov	r3, sl
 80084b8:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80084ba:	e575      	b.n	8007fa8 <_svfprintf_r+0xf44>
 80084bc:	9811      	ldr	r0, [sp, #68]	; 0x44
 80084be:	aa39      	add	r2, sp, #228	; 0xe4
 80084c0:	990c      	ldr	r1, [sp, #48]	; 0x30
 80084c2:	f004 fa27 	bl	800c914 <__ssprint_r>
 80084c6:	2800      	cmp	r0, #0
 80084c8:	f47e aeb3 	bne.w	8007232 <_svfprintf_r+0x1ce>
 80084cc:	9a42      	ldr	r2, [sp, #264]	; 0x108
 80084ce:	4653      	mov	r3, sl
 80084d0:	980e      	ldr	r0, [sp, #56]	; 0x38
 80084d2:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80084d4:	1a82      	subs	r2, r0, r2
 80084d6:	e57e      	b.n	8007fd6 <_svfprintf_r+0xf72>
 80084d8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80084da:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 80084de:	ebc3 030b 	rsb	r3, r3, fp
 80084e2:	9310      	str	r3, [sp, #64]	; 0x40
 80084e4:	f7fe bf3f 	b.w	8007366 <_svfprintf_r+0x302>
 80084e8:	f240 1880 	movw	r8, #384	; 0x180
 80084ec:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80084ee:	f6c0 0801 	movt	r8, #2049	; 0x801
 80084f2:	f7ff b84b 	b.w	800758c <_svfprintf_r+0x528>
 80084f6:	9811      	ldr	r0, [sp, #68]	; 0x44
 80084f8:	aa39      	add	r2, sp, #228	; 0xe4
 80084fa:	990c      	ldr	r1, [sp, #48]	; 0x30
 80084fc:	f004 fa0a 	bl	800c914 <__ssprint_r>
 8008500:	2800      	cmp	r0, #0
 8008502:	f47e ae96 	bne.w	8007232 <_svfprintf_r+0x1ce>
 8008506:	4653      	mov	r3, sl
 8008508:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800850a:	e545      	b.n	8007f98 <_svfprintf_r+0xf34>
 800850c:	2f06      	cmp	r7, #6
 800850e:	bf28      	it	cs
 8008510:	2706      	movcs	r7, #6
 8008512:	f240 40ac 	movw	r0, #1196	; 0x4ac
 8008516:	ea27 71e7 	bic.w	r1, r7, r7, asr #31
 800851a:	f6c0 0001 	movt	r0, #2049	; 0x801
 800851e:	461a      	mov	r2, r3
 8008520:	9710      	str	r7, [sp, #64]	; 0x40
 8008522:	910a      	str	r1, [sp, #40]	; 0x28
 8008524:	9412      	str	r4, [sp, #72]	; 0x48
 8008526:	9314      	str	r3, [sp, #80]	; 0x50
 8008528:	9318      	str	r3, [sp, #96]	; 0x60
 800852a:	9013      	str	r0, [sp, #76]	; 0x4c
 800852c:	f7fe bf25 	b.w	800737a <_svfprintf_r+0x316>
 8008530:	9916      	ldr	r1, [sp, #88]	; 0x58
 8008532:	2966      	cmp	r1, #102	; 0x66
 8008534:	f040 808f 	bne.w	8008656 <_svfprintf_r+0x15f2>
 8008538:	9b42      	ldr	r3, [sp, #264]	; 0x108
 800853a:	2b00      	cmp	r3, #0
 800853c:	9310      	str	r3, [sp, #64]	; 0x40
 800853e:	f340 8098 	ble.w	8008672 <_svfprintf_r+0x160e>
 8008542:	b91f      	cbnz	r7, 800854c <_svfprintf_r+0x14e8>
 8008544:	9808      	ldr	r0, [sp, #32]
 8008546:	f010 0f01 	tst.w	r0, #1
 800854a:	d002      	beq.n	8008552 <_svfprintf_r+0x14ee>
 800854c:	1c5a      	adds	r2, r3, #1
 800854e:	19d2      	adds	r2, r2, r7
 8008550:	9210      	str	r2, [sp, #64]	; 0x40
 8008552:	9318      	str	r3, [sp, #96]	; 0x60
 8008554:	9516      	str	r5, [sp, #88]	; 0x58
 8008556:	e6f4      	b.n	8008342 <_svfprintf_r+0x12de>
 8008558:	9810      	ldr	r0, [sp, #64]	; 0x40
 800855a:	222d      	movs	r2, #45	; 0x2d
 800855c:	2100      	movs	r1, #0
 800855e:	f88d 210f 	strb.w	r2, [sp, #271]	; 0x10f
 8008562:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 8008566:	9114      	str	r1, [sp, #80]	; 0x50
 8008568:	900a      	str	r0, [sp, #40]	; 0x28
 800856a:	f7fe bf07 	b.w	800737c <_svfprintf_r+0x318>
 800856e:	46b8      	mov	r8, r7
 8008570:	2303      	movs	r3, #3
 8008572:	e649      	b.n	8008208 <_svfprintf_r+0x11a4>
 8008574:	4633      	mov	r3, r6
 8008576:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8008578:	3608      	adds	r6, #8
 800857a:	f8df 8124 	ldr.w	r8, [pc, #292]	; 80086a0 <_svfprintf_r+0x163c>
 800857e:	f7ff babe 	b.w	8007afe <_svfprintf_r+0xa9a>
 8008582:	9b40      	ldr	r3, [sp, #256]	; 0x100
 8008584:	429c      	cmp	r4, r3
 8008586:	f67f ae79 	bls.w	800827c <_svfprintf_r+0x1218>
 800858a:	2230      	movs	r2, #48	; 0x30
 800858c:	f803 2b01 	strb.w	r2, [r3], #1
 8008590:	42a3      	cmp	r3, r4
 8008592:	9340      	str	r3, [sp, #256]	; 0x100
 8008594:	d1fa      	bne.n	800858c <_svfprintf_r+0x1528>
 8008596:	e671      	b.n	800827c <_svfprintf_r+0x1218>
 8008598:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800859a:	4293      	cmp	r3, r2
 800859c:	db2e      	blt.n	80085fc <_svfprintf_r+0x1598>
 800859e:	9c08      	ldr	r4, [sp, #32]
 80085a0:	f014 0f01 	tst.w	r4, #1
 80085a4:	d03d      	beq.n	8008622 <_svfprintf_r+0x15be>
 80085a6:	1c58      	adds	r0, r3, #1
 80085a8:	2567      	movs	r5, #103	; 0x67
 80085aa:	9010      	str	r0, [sp, #64]	; 0x40
 80085ac:	e7d1      	b.n	8008552 <_svfprintf_r+0x14ee>
 80085ae:	ea27 72e7 	bic.w	r2, r7, r7, asr #31
 80085b2:	9014      	str	r0, [sp, #80]	; 0x50
 80085b4:	920a      	str	r2, [sp, #40]	; 0x28
 80085b6:	9412      	str	r4, [sp, #72]	; 0x48
 80085b8:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 80085bc:	9710      	str	r7, [sp, #64]	; 0x40
 80085be:	9018      	str	r0, [sp, #96]	; 0x60
 80085c0:	f7fe bedb 	b.w	800737a <_svfprintf_r+0x316>
 80085c4:	2700      	movs	r7, #0
 80085c6:	ea47 77e7 	orr.w	r7, r7, r7, asr #31
 80085ca:	f7fe bdb9 	b.w	8007140 <_svfprintf_r+0xdc>
 80085ce:	46b8      	mov	r8, r7
 80085d0:	2302      	movs	r3, #2
 80085d2:	e619      	b.n	8008208 <_svfprintf_r+0x11a4>
 80085d4:	212d      	movs	r1, #45	; 0x2d
 80085d6:	f103 4900 	add.w	r9, r3, #2147483648	; 0x80000000
 80085da:	9114      	str	r1, [sp, #80]	; 0x50
 80085dc:	e5fd      	b.n	80081da <_svfprintf_r+0x1176>
 80085de:	3330      	adds	r3, #48	; 0x30
 80085e0:	2230      	movs	r2, #48	; 0x30
 80085e2:	a93f      	add	r1, sp, #252	; 0xfc
 80085e4:	f88d 20fa 	strb.w	r2, [sp, #250]	; 0xfa
 80085e8:	f88d 30fb 	strb.w	r3, [sp, #251]	; 0xfb
 80085ec:	e69a      	b.n	8008324 <_svfprintf_r+0x12c0>
 80085ee:	f103 0908 	add.w	r9, r3, #8
 80085f2:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80085f4:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 80086a0 <_svfprintf_r+0x163c>
 80085f8:	f7ff bbe6 	b.w	8007dc8 <_svfprintf_r+0xd64>
 80085fc:	2b00      	cmp	r3, #0
 80085fe:	990e      	ldr	r1, [sp, #56]	; 0x38
 8008600:	bfd4      	ite	le
 8008602:	f1c3 0202 	rsble	r2, r3, #2
 8008606:	2201      	movgt	r2, #1
 8008608:	1852      	adds	r2, r2, r1
 800860a:	2567      	movs	r5, #103	; 0x67
 800860c:	9210      	str	r2, [sp, #64]	; 0x40
 800860e:	e7a0      	b.n	8008552 <_svfprintf_r+0x14ee>
 8008610:	9b40      	ldr	r3, [sp, #256]	; 0x100
 8008612:	e633      	b.n	800827c <_svfprintf_r+0x1218>
 8008614:	9a08      	ldr	r2, [sp, #32]
 8008616:	f012 0301 	ands.w	r3, r2, #1
 800861a:	f47f ae8d 	bne.w	8008338 <_svfprintf_r+0x12d4>
 800861e:	9318      	str	r3, [sp, #96]	; 0x60
 8008620:	e68f      	b.n	8008342 <_svfprintf_r+0x12de>
 8008622:	2567      	movs	r5, #103	; 0x67
 8008624:	e795      	b.n	8008552 <_svfprintf_r+0x14ee>
 8008626:	981a      	ldr	r0, [sp, #104]	; 0x68
 8008628:	2200      	movs	r2, #0
 800862a:	2300      	movs	r3, #0
 800862c:	4649      	mov	r1, r9
 800862e:	f007 f87d 	bl	800f72c <__aeabi_dcmpeq>
 8008632:	2800      	cmp	r0, #0
 8008634:	f47f ae15 	bne.w	8008262 <_svfprintf_r+0x11fe>
 8008638:	f1c8 0301 	rsb	r3, r8, #1
 800863c:	9342      	str	r3, [sp, #264]	; 0x108
 800863e:	e610      	b.n	8008262 <_svfprintf_r+0x11fe>
 8008640:	f109 0308 	add.w	r3, r9, #8
 8008644:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8008646:	f8df 8058 	ldr.w	r8, [pc, #88]	; 80086a0 <_svfprintf_r+0x163c>
 800864a:	e49a      	b.n	8007f82 <_svfprintf_r+0xf1e>
 800864c:	222d      	movs	r2, #45	; 0x2d
 800864e:	425b      	negs	r3, r3
 8008650:	f88d 20f9 	strb.w	r2, [sp, #249]	; 0xf9
 8008654:	e63a      	b.n	80082cc <_svfprintf_r+0x1268>
 8008656:	9b42      	ldr	r3, [sp, #264]	; 0x108
 8008658:	e62d      	b.n	80082b6 <_svfprintf_r+0x1252>
 800865a:	9812      	ldr	r0, [sp, #72]	; 0x48
 800865c:	6807      	ldr	r7, [r0, #0]
 800865e:	3004      	adds	r0, #4
 8008660:	2f00      	cmp	r7, #0
 8008662:	f6bf a943 	bge.w	80078ec <_svfprintf_r+0x888>
 8008666:	7813      	ldrb	r3, [r2, #0]
 8008668:	f04f 37ff 	mov.w	r7, #4294967295
 800866c:	9012      	str	r0, [sp, #72]	; 0x48
 800866e:	f7fe bd66 	b.w	800713e <_svfprintf_r+0xda>
 8008672:	b91f      	cbnz	r7, 800867c <_svfprintf_r+0x1618>
 8008674:	9908      	ldr	r1, [sp, #32]
 8008676:	f011 0f01 	tst.w	r1, #1
 800867a:	d002      	beq.n	8008682 <_svfprintf_r+0x161e>
 800867c:	3702      	adds	r7, #2
 800867e:	9710      	str	r7, [sp, #64]	; 0x40
 8008680:	e767      	b.n	8008552 <_svfprintf_r+0x14ee>
 8008682:	2201      	movs	r2, #1
 8008684:	9210      	str	r2, [sp, #64]	; 0x40
 8008686:	e764      	b.n	8008552 <_svfprintf_r+0x14ee>
 8008688:	9c11      	ldr	r4, [sp, #68]	; 0x44
 800868a:	f04f 32ff 	mov.w	r2, #4294967295
 800868e:	230c      	movs	r3, #12
 8008690:	920f      	str	r2, [sp, #60]	; 0x3c
 8008692:	6023      	str	r3, [r4, #0]
 8008694:	f7fe bdd6 	b.w	8007244 <_svfprintf_r+0x1e0>
 8008698:	f10d 01fa 	add.w	r1, sp, #250	; 0xfa
 800869c:	e642      	b.n	8008324 <_svfprintf_r+0x12c0>
 800869e:	bf00      	nop
 80086a0:	08010190 	.word	0x08010190

080086a4 <open>:
 80086a4:	b40e      	push	{r1, r2, r3}
 80086a6:	f240 237c 	movw	r3, #636	; 0x27c
 80086aa:	b510      	push	{r4, lr}
 80086ac:	b083      	sub	sp, #12
 80086ae:	ac05      	add	r4, sp, #20
 80086b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80086b4:	4601      	mov	r1, r0
 80086b6:	f854 2b04 	ldr.w	r2, [r4], #4
 80086ba:	6818      	ldr	r0, [r3, #0]
 80086bc:	9b06      	ldr	r3, [sp, #24]
 80086be:	3404      	adds	r4, #4
 80086c0:	9401      	str	r4, [sp, #4]
 80086c2:	f003 ffad 	bl	800c620 <_open_r>
 80086c6:	b003      	add	sp, #12
 80086c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80086cc:	b003      	add	sp, #12
 80086ce:	4770      	bx	lr

080086d0 <read>:
 80086d0:	b430      	push	{r4, r5}
 80086d2:	f240 247c 	movw	r4, #636	; 0x27c
 80086d6:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80086da:	460d      	mov	r5, r1
 80086dc:	4613      	mov	r3, r2
 80086de:	4601      	mov	r1, r0
 80086e0:	462a      	mov	r2, r5
 80086e2:	6820      	ldr	r0, [r4, #0]
 80086e4:	bc30      	pop	{r4, r5}
 80086e6:	f003 bfb1 	b.w	800c64c <_read_r>
 80086ea:	bf00      	nop

080086ec <write>:
 80086ec:	b430      	push	{r4, r5}
 80086ee:	f240 247c 	movw	r4, #636	; 0x27c
 80086f2:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80086f6:	460d      	mov	r5, r1
 80086f8:	4613      	mov	r3, r2
 80086fa:	4601      	mov	r1, r0
 80086fc:	462a      	mov	r2, r5
 80086fe:	6820      	ldr	r0, [r4, #0]
 8008700:	bc30      	pop	{r4, r5}
 8008702:	f001 bce7 	b.w	800a0d4 <_write_r>
 8008706:	bf00      	nop

08008708 <_vfprintf_r>:
 8008708:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800870c:	f5ad 6dae 	sub.w	sp, sp, #1392	; 0x570
 8008710:	b081      	sub	sp, #4
 8008712:	4615      	mov	r5, r2
 8008714:	9109      	str	r1, [sp, #36]	; 0x24
 8008716:	9312      	str	r3, [sp, #72]	; 0x48
 8008718:	900d      	str	r0, [sp, #52]	; 0x34
 800871a:	f003 f925 	bl	800b968 <_localeconv_r>
 800871e:	6800      	ldr	r0, [r0, #0]
 8008720:	9017      	str	r0, [sp, #92]	; 0x5c
 8008722:	f004 f8c7 	bl	800c8b4 <strlen>
 8008726:	901c      	str	r0, [sp, #112]	; 0x70
 8008728:	980d      	ldr	r0, [sp, #52]	; 0x34
 800872a:	b118      	cbz	r0, 8008734 <_vfprintf_r+0x2c>
 800872c:	6983      	ldr	r3, [r0, #24]
 800872e:	2b00      	cmp	r3, #0
 8008730:	f000 816a 	beq.w	8008a08 <_vfprintf_r+0x300>
 8008734:	f240 13c0 	movw	r3, #448	; 0x1c0
 8008738:	9909      	ldr	r1, [sp, #36]	; 0x24
 800873a:	f6c0 0301 	movt	r3, #2049	; 0x801
 800873e:	4299      	cmp	r1, r3
 8008740:	f000 816c 	beq.w	8008a1c <_vfprintf_r+0x314>
 8008744:	f240 13e0 	movw	r3, #480	; 0x1e0
 8008748:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800874a:	f6c0 0301 	movt	r3, #2049	; 0x801
 800874e:	429c      	cmp	r4, r3
 8008750:	f000 87b0 	beq.w	80096b4 <_vfprintf_r+0xfac>
 8008754:	9909      	ldr	r1, [sp, #36]	; 0x24
 8008756:	f240 2300 	movw	r3, #512	; 0x200
 800875a:	f6c0 0301 	movt	r3, #2049	; 0x801
 800875e:	4299      	cmp	r1, r3
 8008760:	bf02      	ittt	eq
 8008762:	9a0d      	ldreq	r2, [sp, #52]	; 0x34
 8008764:	68d2      	ldreq	r2, [r2, #12]
 8008766:	9209      	streq	r2, [sp, #36]	; 0x24
 8008768:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800876a:	899c      	ldrh	r4, [r3, #12]
 800876c:	b2a3      	uxth	r3, r4
 800876e:	f413 5f00 	tst.w	r3, #8192	; 0x2000
 8008772:	d108      	bne.n	8008786 <_vfprintf_r+0x7e>
 8008774:	9809      	ldr	r0, [sp, #36]	; 0x24
 8008776:	f444 5400 	orr.w	r4, r4, #8192	; 0x2000
 800877a:	b2a3      	uxth	r3, r4
 800877c:	6e42      	ldr	r2, [r0, #100]	; 0x64
 800877e:	8184      	strh	r4, [r0, #12]
 8008780:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8008784:	6642      	str	r2, [r0, #100]	; 0x64
 8008786:	f013 0f08 	tst.w	r3, #8
 800878a:	f001 838f 	beq.w	8009eac <_vfprintf_r+0x17a4>
 800878e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8008790:	690a      	ldr	r2, [r1, #16]
 8008792:	2a00      	cmp	r2, #0
 8008794:	f001 838a 	beq.w	8009eac <_vfprintf_r+0x17a4>
 8008798:	f003 031a 	and.w	r3, r3, #26
 800879c:	2b0a      	cmp	r3, #10
 800879e:	f000 80ec 	beq.w	800897a <_vfprintf_r+0x272>
 80087a2:	f50d 6a9c 	add.w	sl, sp, #1248	; 0x4e0
 80087a6:	f50d 6490 	add.w	r4, sp, #1152	; 0x480
 80087aa:	f10a 0a04 	add.w	sl, sl, #4
 80087ae:	2300      	movs	r3, #0
 80087b0:	4656      	mov	r6, sl
 80087b2:	3403      	adds	r4, #3
 80087b4:	9310      	str	r3, [sp, #64]	; 0x40
 80087b6:	9508      	str	r5, [sp, #32]
 80087b8:	931a      	str	r3, [sp, #104]	; 0x68
 80087ba:	931b      	str	r3, [sp, #108]	; 0x6c
 80087bc:	9318      	str	r3, [sp, #96]	; 0x60
 80087be:	931d      	str	r3, [sp, #116]	; 0x74
 80087c0:	930e      	str	r3, [sp, #56]	; 0x38
 80087c2:	9406      	str	r4, [sp, #24]
 80087c4:	f8cd a54c 	str.w	sl, [sp, #1356]	; 0x54c
 80087c8:	f8cd 3554 	str.w	r3, [sp, #1364]	; 0x554
 80087cc:	f8cd 3550 	str.w	r3, [sp, #1360]	; 0x550
 80087d0:	9808      	ldr	r0, [sp, #32]
 80087d2:	7803      	ldrb	r3, [r0, #0]
 80087d4:	f1b3 0225 	subs.w	r2, r3, #37	; 0x25
 80087d8:	bf18      	it	ne
 80087da:	2201      	movne	r2, #1
 80087dc:	2b00      	cmp	r3, #0
 80087de:	bf0c      	ite	eq
 80087e0:	2300      	moveq	r3, #0
 80087e2:	f002 0301 	andne.w	r3, r2, #1
 80087e6:	2b00      	cmp	r3, #0
 80087e8:	f000 811c 	beq.w	8008a24 <_vfprintf_r+0x31c>
 80087ec:	1c42      	adds	r2, r0, #1
 80087ee:	4617      	mov	r7, r2
 80087f0:	3201      	adds	r2, #1
 80087f2:	783b      	ldrb	r3, [r7, #0]
 80087f4:	1e19      	subs	r1, r3, #0
 80087f6:	bf18      	it	ne
 80087f8:	2101      	movne	r1, #1
 80087fa:	2b25      	cmp	r3, #37	; 0x25
 80087fc:	bf0c      	ite	eq
 80087fe:	2300      	moveq	r3, #0
 8008800:	f001 0301 	andne.w	r3, r1, #1
 8008804:	2b00      	cmp	r3, #0
 8008806:	d1f2      	bne.n	80087ee <_vfprintf_r+0xe6>
 8008808:	9908      	ldr	r1, [sp, #32]
 800880a:	ebb7 0801 	subs.w	r8, r7, r1
 800880e:	d013      	beq.n	8008838 <_vfprintf_r+0x130>
 8008810:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8008814:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8008818:	3401      	adds	r4, #1
 800881a:	6031      	str	r1, [r6, #0]
 800881c:	2c07      	cmp	r4, #7
 800881e:	f8c6 8004 	str.w	r8, [r6, #4]
 8008822:	4445      	add	r5, r8
 8008824:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8008828:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 800882c:	f300 8082 	bgt.w	8008934 <_vfprintf_r+0x22c>
 8008830:	3608      	adds	r6, #8
 8008832:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8008834:	4442      	add	r2, r8
 8008836:	920e      	str	r2, [sp, #56]	; 0x38
 8008838:	783b      	ldrb	r3, [r7, #0]
 800883a:	2b00      	cmp	r3, #0
 800883c:	f000 8084 	beq.w	8008948 <_vfprintf_r+0x240>
 8008840:	1c78      	adds	r0, r7, #1
 8008842:	2300      	movs	r3, #0
 8008844:	2100      	movs	r1, #0
 8008846:	930f      	str	r3, [sp, #60]	; 0x3c
 8008848:	2400      	movs	r4, #0
 800884a:	9008      	str	r0, [sp, #32]
 800884c:	f88d 456f 	strb.w	r4, [sp, #1391]	; 0x56f
 8008850:	2520      	movs	r5, #32
 8008852:	787b      	ldrb	r3, [r7, #1]
 8008854:	4602      	mov	r2, r0
 8008856:	9107      	str	r1, [sp, #28]
 8008858:	f04f 37ff 	mov.w	r7, #4294967295
 800885c:	212b      	movs	r1, #43	; 0x2b
 800885e:	3201      	adds	r2, #1
 8008860:	f1a3 0020 	sub.w	r0, r3, #32
 8008864:	2858      	cmp	r0, #88	; 0x58
 8008866:	f200 8419 	bhi.w	800909c <_vfprintf_r+0x994>
 800886a:	e8df f010 	tbh	[pc, r0, lsl #1]
 800886e:	042c      	.short	0x042c
 8008870:	04170417 	.word	0x04170417
 8008874:	04170436 	.word	0x04170436
 8008878:	04170417 	.word	0x04170417
 800887c:	04170417 	.word	0x04170417
 8008880:	04700417 	.word	0x04700417
 8008884:	041700dd 	.word	0x041700dd
 8008888:	00e1005d 	.word	0x00e1005d
 800888c:	00fb0417 	.word	0x00fb0417
 8008890:	03090309 	.word	0x03090309
 8008894:	03090309 	.word	0x03090309
 8008898:	03090309 	.word	0x03090309
 800889c:	03090309 	.word	0x03090309
 80088a0:	04170309 	.word	0x04170309
 80088a4:	04170417 	.word	0x04170417
 80088a8:	04170417 	.word	0x04170417
 80088ac:	04170417 	.word	0x04170417
 80088b0:	04170417 	.word	0x04170417
 80088b4:	035c0417 	.word	0x035c0417
 80088b8:	04170101 	.word	0x04170101
 80088bc:	04170101 	.word	0x04170101
 80088c0:	04170417 	.word	0x04170417
 80088c4:	02950417 	.word	0x02950417
 80088c8:	04170417 	.word	0x04170417
 80088cc:	0417029b 	.word	0x0417029b
 80088d0:	04170417 	.word	0x04170417
 80088d4:	04170417 	.word	0x04170417
 80088d8:	041702fa 	.word	0x041702fa
 80088dc:	031b0417 	.word	0x031b0417
 80088e0:	04170417 	.word	0x04170417
 80088e4:	04170417 	.word	0x04170417
 80088e8:	04170417 	.word	0x04170417
 80088ec:	04170417 	.word	0x04170417
 80088f0:	04170417 	.word	0x04170417
 80088f4:	03fe0346 	.word	0x03fe0346
 80088f8:	01010101 	.word	0x01010101
 80088fc:	04100101 	.word	0x04100101
 8008900:	041703fe 	.word	0x041703fe
 8008904:	03ab0417 	.word	0x03ab0417
 8008908:	03ba0417 	.word	0x03ba0417
 800890c:	03e203cc 	.word	0x03e203cc
 8008910:	0417037d 	.word	0x0417037d
 8008914:	04170383 	.word	0x04170383
 8008918:	0417043d 	.word	0x0417043d
 800891c:	04590417 	.word	0x04590417
 8008920:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8008922:	9012      	str	r0, [sp, #72]	; 0x48
 8008924:	425b      	negs	r3, r3
 8008926:	930f      	str	r3, [sp, #60]	; 0x3c
 8008928:	9c07      	ldr	r4, [sp, #28]
 800892a:	f044 0404 	orr.w	r4, r4, #4
 800892e:	9407      	str	r4, [sp, #28]
 8008930:	7813      	ldrb	r3, [r2, #0]
 8008932:	e794      	b.n	800885e <_vfprintf_r+0x156>
 8008934:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8008938:	980d      	ldr	r0, [sp, #52]	; 0x34
 800893a:	9909      	ldr	r1, [sp, #36]	; 0x24
 800893c:	320c      	adds	r2, #12
 800893e:	f004 fddd 	bl	800d4fc <__sprint_r>
 8008942:	b958      	cbnz	r0, 800895c <_vfprintf_r+0x254>
 8008944:	4656      	mov	r6, sl
 8008946:	e774      	b.n	8008832 <_vfprintf_r+0x12a>
 8008948:	f8dd 3554 	ldr.w	r3, [sp, #1364]	; 0x554
 800894c:	b133      	cbz	r3, 800895c <_vfprintf_r+0x254>
 800894e:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8008952:	980d      	ldr	r0, [sp, #52]	; 0x34
 8008954:	9909      	ldr	r1, [sp, #36]	; 0x24
 8008956:	320c      	adds	r2, #12
 8008958:	f004 fdd0 	bl	800d4fc <__sprint_r>
 800895c:	9909      	ldr	r1, [sp, #36]	; 0x24
 800895e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8008960:	898b      	ldrh	r3, [r1, #12]
 8008962:	f013 0f40 	tst.w	r3, #64	; 0x40
 8008966:	bf18      	it	ne
 8008968:	f04f 32ff 	movne.w	r2, #4294967295
 800896c:	920e      	str	r2, [sp, #56]	; 0x38
 800896e:	980e      	ldr	r0, [sp, #56]	; 0x38
 8008970:	b05d      	add	sp, #372	; 0x174
 8008972:	f50d 6d80 	add.w	sp, sp, #1024	; 0x400
 8008976:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800897a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800897c:	89de      	ldrh	r6, [r3, #14]
 800897e:	f416 4f00 	tst.w	r6, #32768	; 0x8000
 8008982:	f47f af0e 	bne.w	80087a2 <_vfprintf_r+0x9a>
 8008986:	6e5f      	ldr	r7, [r3, #100]	; 0x64
 8008988:	f50d 618e 	add.w	r1, sp, #1136	; 0x470
 800898c:	f8d3 e020 	ldr.w	lr, [r3, #32]
 8008990:	310c      	adds	r1, #12
 8008992:	f8d3 c028 	ldr.w	ip, [r3, #40]	; 0x28
 8008996:	462a      	mov	r2, r5
 8008998:	980d      	ldr	r0, [sp, #52]	; 0x34
 800899a:	f44f 6580 	mov.w	r5, #1024	; 0x400
 800899e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80089a0:	f024 0402 	bic.w	r4, r4, #2
 80089a4:	f8cd 74e0 	str.w	r7, [sp, #1248]	; 0x4e0
 80089a8:	f8ad 4488 	strh.w	r4, [sp, #1160]	; 0x488
 80089ac:	ac1f      	add	r4, sp, #124	; 0x7c
 80089ae:	f8ad 648a 	strh.w	r6, [sp, #1162]	; 0x48a
 80089b2:	f8cd 447c 	str.w	r4, [sp, #1148]	; 0x47c
 80089b6:	f8cd 448c 	str.w	r4, [sp, #1164]	; 0x48c
 80089ba:	2400      	movs	r4, #0
 80089bc:	f8cd e49c 	str.w	lr, [sp, #1180]	; 0x49c
 80089c0:	f8cd c4a4 	str.w	ip, [sp, #1188]	; 0x4a4
 80089c4:	f8cd 5484 	str.w	r5, [sp, #1156]	; 0x484
 80089c8:	f8cd 5490 	str.w	r5, [sp, #1168]	; 0x490
 80089cc:	f8cd 4494 	str.w	r4, [sp, #1172]	; 0x494
 80089d0:	f7ff fe9a 	bl	8008708 <_vfprintf_r>
 80089d4:	2800      	cmp	r0, #0
 80089d6:	900e      	str	r0, [sp, #56]	; 0x38
 80089d8:	db0b      	blt.n	80089f2 <_vfprintf_r+0x2ea>
 80089da:	f50d 618e 	add.w	r1, sp, #1136	; 0x470
 80089de:	980d      	ldr	r0, [sp, #52]	; 0x34
 80089e0:	310c      	adds	r1, #12
 80089e2:	f002 fc05 	bl	800b1f0 <_fflush_r>
 80089e6:	990e      	ldr	r1, [sp, #56]	; 0x38
 80089e8:	42a0      	cmp	r0, r4
 80089ea:	bf18      	it	ne
 80089ec:	f04f 31ff 	movne.w	r1, #4294967295
 80089f0:	910e      	str	r1, [sp, #56]	; 0x38
 80089f2:	f8bd 3488 	ldrh.w	r3, [sp, #1160]	; 0x488
 80089f6:	f013 0f40 	tst.w	r3, #64	; 0x40
 80089fa:	d0b8      	beq.n	800896e <_vfprintf_r+0x266>
 80089fc:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80089fe:	8993      	ldrh	r3, [r2, #12]
 8008a00:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8008a04:	8193      	strh	r3, [r2, #12]
 8008a06:	e7b2      	b.n	800896e <_vfprintf_r+0x266>
 8008a08:	f002 fd10 	bl	800b42c <__sinit>
 8008a0c:	f240 13c0 	movw	r3, #448	; 0x1c0
 8008a10:	9909      	ldr	r1, [sp, #36]	; 0x24
 8008a12:	f6c0 0301 	movt	r3, #2049	; 0x801
 8008a16:	4299      	cmp	r1, r3
 8008a18:	f47f ae94 	bne.w	8008744 <_vfprintf_r+0x3c>
 8008a1c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8008a1e:	6852      	ldr	r2, [r2, #4]
 8008a20:	9209      	str	r2, [sp, #36]	; 0x24
 8008a22:	e6a1      	b.n	8008768 <_vfprintf_r+0x60>
 8008a24:	9f08      	ldr	r7, [sp, #32]
 8008a26:	e707      	b.n	8008838 <_vfprintf_r+0x130>
 8008a28:	f88d 156f 	strb.w	r1, [sp, #1391]	; 0x56f
 8008a2c:	7813      	ldrb	r3, [r2, #0]
 8008a2e:	e716      	b.n	800885e <_vfprintf_r+0x156>
 8008a30:	f812 3b01 	ldrb.w	r3, [r2], #1
 8008a34:	2b2a      	cmp	r3, #42	; 0x2a
 8008a36:	f001 8303 	beq.w	800a040 <_vfprintf_r+0x1938>
 8008a3a:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 8008a3e:	2809      	cmp	r0, #9
 8008a40:	f201 829d 	bhi.w	8009f7e <_vfprintf_r+0x1876>
 8008a44:	4614      	mov	r4, r2
 8008a46:	2700      	movs	r7, #0
 8008a48:	f814 3b01 	ldrb.w	r3, [r4], #1
 8008a4c:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 8008a50:	eb00 0747 	add.w	r7, r0, r7, lsl #1
 8008a54:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 8008a58:	2809      	cmp	r0, #9
 8008a5a:	4622      	mov	r2, r4
 8008a5c:	d9f4      	bls.n	8008a48 <_vfprintf_r+0x340>
 8008a5e:	ea47 77e7 	orr.w	r7, r7, r7, asr #31
 8008a62:	e6fd      	b.n	8008860 <_vfprintf_r+0x158>
 8008a64:	9b07      	ldr	r3, [sp, #28]
 8008a66:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8008a6a:	9307      	str	r3, [sp, #28]
 8008a6c:	7813      	ldrb	r3, [r2, #0]
 8008a6e:	e6f6      	b.n	800885e <_vfprintf_r+0x156>
 8008a70:	9907      	ldr	r1, [sp, #28]
 8008a72:	461d      	mov	r5, r3
 8008a74:	9208      	str	r2, [sp, #32]
 8008a76:	f011 0f08 	tst.w	r1, #8
 8008a7a:	9316      	str	r3, [sp, #88]	; 0x58
 8008a7c:	f000 87cc 	beq.w	8009a18 <_vfprintf_r+0x1310>
 8008a80:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8008a82:	1dd3      	adds	r3, r2, #7
 8008a84:	f023 0307 	bic.w	r3, r3, #7
 8008a88:	f103 0408 	add.w	r4, r3, #8
 8008a8c:	9412      	str	r4, [sp, #72]	; 0x48
 8008a8e:	6818      	ldr	r0, [r3, #0]
 8008a90:	901a      	str	r0, [sp, #104]	; 0x68
 8008a92:	685b      	ldr	r3, [r3, #4]
 8008a94:	931b      	str	r3, [sp, #108]	; 0x6c
 8008a96:	981a      	ldr	r0, [sp, #104]	; 0x68
 8008a98:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8008a9a:	f003 fe79 	bl	800c790 <__fpclassifyd>
 8008a9e:	2801      	cmp	r0, #1
 8008aa0:	f040 868b 	bne.w	80097ba <_vfprintf_r+0x10b2>
 8008aa4:	981a      	ldr	r0, [sp, #104]	; 0x68
 8008aa6:	2200      	movs	r2, #0
 8008aa8:	2300      	movs	r3, #0
 8008aaa:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8008aac:	f006 fe48 	bl	800f740 <__aeabi_dcmplt>
 8008ab0:	2800      	cmp	r0, #0
 8008ab2:	f041 8105 	bne.w	8009cc0 <_vfprintf_r+0x15b8>
 8008ab6:	f89d 256f 	ldrb.w	r2, [sp, #1391]	; 0x56f
 8008aba:	2003      	movs	r0, #3
 8008abc:	f240 4378 	movw	r3, #1144	; 0x478
 8008ac0:	f240 4174 	movw	r1, #1140	; 0x474
 8008ac4:	900a      	str	r0, [sp, #40]	; 0x28
 8008ac6:	9816      	ldr	r0, [sp, #88]	; 0x58
 8008ac8:	f6c0 0101 	movt	r1, #2049	; 0x801
 8008acc:	f6c0 0301 	movt	r3, #2049	; 0x801
 8008ad0:	2400      	movs	r4, #0
 8008ad2:	2847      	cmp	r0, #71	; 0x47
 8008ad4:	bfd8      	it	le
 8008ad6:	460b      	movle	r3, r1
 8008ad8:	9907      	ldr	r1, [sp, #28]
 8008ada:	9313      	str	r3, [sp, #76]	; 0x4c
 8008adc:	2303      	movs	r3, #3
 8008ade:	f021 0180 	bic.w	r1, r1, #128	; 0x80
 8008ae2:	9414      	str	r4, [sp, #80]	; 0x50
 8008ae4:	9107      	str	r1, [sp, #28]
 8008ae6:	9311      	str	r3, [sp, #68]	; 0x44
 8008ae8:	9419      	str	r4, [sp, #100]	; 0x64
 8008aea:	b112      	cbz	r2, 8008af2 <_vfprintf_r+0x3ea>
 8008aec:	980a      	ldr	r0, [sp, #40]	; 0x28
 8008aee:	3001      	adds	r0, #1
 8008af0:	900a      	str	r0, [sp, #40]	; 0x28
 8008af2:	9907      	ldr	r1, [sp, #28]
 8008af4:	f011 0b02 	ands.w	fp, r1, #2
 8008af8:	d002      	beq.n	8008b00 <_vfprintf_r+0x3f8>
 8008afa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008afc:	3302      	adds	r3, #2
 8008afe:	930a      	str	r3, [sp, #40]	; 0x28
 8008b00:	9c07      	ldr	r4, [sp, #28]
 8008b02:	f014 0484 	ands.w	r4, r4, #132	; 0x84
 8008b06:	9415      	str	r4, [sp, #84]	; 0x54
 8008b08:	f040 833a 	bne.w	8009180 <_vfprintf_r+0xa78>
 8008b0c:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8008b0e:	990a      	ldr	r1, [sp, #40]	; 0x28
 8008b10:	1a47      	subs	r7, r0, r1
 8008b12:	2f00      	cmp	r7, #0
 8008b14:	f340 8334 	ble.w	8009180 <_vfprintf_r+0xa78>
 8008b18:	2f10      	cmp	r7, #16
 8008b1a:	f341 8162 	ble.w	8009de2 <_vfprintf_r+0x16da>
 8008b1e:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8008b22:	f240 18a0 	movw	r8, #416	; 0x1a0
 8008b26:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8008b2a:	f6c0 0801 	movt	r8, #2049	; 0x801
 8008b2e:	4629      	mov	r1, r5
 8008b30:	f04f 0910 	mov.w	r9, #16
 8008b34:	4622      	mov	r2, r4
 8008b36:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8008b38:	4644      	mov	r4, r8
 8008b3a:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
 8008b3e:	e002      	b.n	8008b46 <_vfprintf_r+0x43e>
 8008b40:	3f10      	subs	r7, #16
 8008b42:	2f10      	cmp	r7, #16
 8008b44:	dd21      	ble.n	8008b8a <_vfprintf_r+0x482>
 8008b46:	3201      	adds	r2, #1
 8008b48:	6034      	str	r4, [r6, #0]
 8008b4a:	f8c6 9004 	str.w	r9, [r6, #4]
 8008b4e:	3110      	adds	r1, #16
 8008b50:	3608      	adds	r6, #8
 8008b52:	2a07      	cmp	r2, #7
 8008b54:	f8cd 2550 	str.w	r2, [sp, #1360]	; 0x550
 8008b58:	f106 0308 	add.w	r3, r6, #8
 8008b5c:	f8cd 1554 	str.w	r1, [sp, #1364]	; 0x554
 8008b60:	ddee      	ble.n	8008b40 <_vfprintf_r+0x438>
 8008b62:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8008b66:	4640      	mov	r0, r8
 8008b68:	4629      	mov	r1, r5
 8008b6a:	320c      	adds	r2, #12
 8008b6c:	f004 fcc6 	bl	800d4fc <__sprint_r>
 8008b70:	4656      	mov	r6, sl
 8008b72:	f10a 0308 	add.w	r3, sl, #8
 8008b76:	2800      	cmp	r0, #0
 8008b78:	f47f aef0 	bne.w	800895c <_vfprintf_r+0x254>
 8008b7c:	3f10      	subs	r7, #16
 8008b7e:	f8dd 1554 	ldr.w	r1, [sp, #1364]	; 0x554
 8008b82:	2f10      	cmp	r7, #16
 8008b84:	f8dd 2550 	ldr.w	r2, [sp, #1360]	; 0x550
 8008b88:	dcdd      	bgt.n	8008b46 <_vfprintf_r+0x43e>
 8008b8a:	46a0      	mov	r8, r4
 8008b8c:	460d      	mov	r5, r1
 8008b8e:	4614      	mov	r4, r2
 8008b90:	3401      	adds	r4, #1
 8008b92:	f8c6 8000 	str.w	r8, [r6]
 8008b96:	2c07      	cmp	r4, #7
 8008b98:	6077      	str	r7, [r6, #4]
 8008b9a:	443d      	add	r5, r7
 8008b9c:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8008ba0:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8008ba4:	f300 82df 	bgt.w	8009166 <_vfprintf_r+0xa5e>
 8008ba8:	f89d 256f 	ldrb.w	r2, [sp, #1391]	; 0x56f
 8008bac:	461e      	mov	r6, r3
 8008bae:	b18a      	cbz	r2, 8008bd4 <_vfprintf_r+0x4cc>
 8008bb0:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8008bb4:	f50d 63ac 	add.w	r3, sp, #1376	; 0x560
 8008bb8:	330f      	adds	r3, #15
 8008bba:	6033      	str	r3, [r6, #0]
 8008bbc:	3401      	adds	r4, #1
 8008bbe:	2301      	movs	r3, #1
 8008bc0:	2c07      	cmp	r4, #7
 8008bc2:	6073      	str	r3, [r6, #4]
 8008bc4:	441d      	add	r5, r3
 8008bc6:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8008bca:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8008bce:	f300 847e 	bgt.w	80094ce <_vfprintf_r+0xdc6>
 8008bd2:	3608      	adds	r6, #8
 8008bd4:	f1bb 0f00 	cmp.w	fp, #0
 8008bd8:	d011      	beq.n	8008bfe <_vfprintf_r+0x4f6>
 8008bda:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8008bde:	f50d 63ac 	add.w	r3, sp, #1376	; 0x560
 8008be2:	330c      	adds	r3, #12
 8008be4:	6033      	str	r3, [r6, #0]
 8008be6:	3401      	adds	r4, #1
 8008be8:	2302      	movs	r3, #2
 8008bea:	2c07      	cmp	r4, #7
 8008bec:	6073      	str	r3, [r6, #4]
 8008bee:	441d      	add	r5, r3
 8008bf0:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8008bf4:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8008bf8:	f300 845a 	bgt.w	80094b0 <_vfprintf_r+0xda8>
 8008bfc:	3608      	adds	r6, #8
 8008bfe:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8008c00:	2a80      	cmp	r2, #128	; 0x80
 8008c02:	f000 8383 	beq.w	800930c <_vfprintf_r+0xc04>
 8008c06:	9914      	ldr	r1, [sp, #80]	; 0x50
 8008c08:	9811      	ldr	r0, [sp, #68]	; 0x44
 8008c0a:	1a0f      	subs	r7, r1, r0
 8008c0c:	2f00      	cmp	r7, #0
 8008c0e:	f340 83d5 	ble.w	80093bc <_vfprintf_r+0xcb4>
 8008c12:	2f10      	cmp	r7, #16
 8008c14:	f340 878b 	ble.w	8009b2e <_vfprintf_r+0x1426>
 8008c18:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8008c1c:	462a      	mov	r2, r5
 8008c1e:	f8df 8b74 	ldr.w	r8, [pc, #2932]	; 8009794 <_vfprintf_r+0x108c>
 8008c22:	f04f 0b10 	mov.w	fp, #16
 8008c26:	4623      	mov	r3, r4
 8008c28:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8008c2a:	4644      	mov	r4, r8
 8008c2c:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
 8008c30:	e002      	b.n	8008c38 <_vfprintf_r+0x530>
 8008c32:	3f10      	subs	r7, #16
 8008c34:	2f10      	cmp	r7, #16
 8008c36:	dd21      	ble.n	8008c7c <_vfprintf_r+0x574>
 8008c38:	3301      	adds	r3, #1
 8008c3a:	6034      	str	r4, [r6, #0]
 8008c3c:	f8c6 b004 	str.w	fp, [r6, #4]
 8008c40:	3210      	adds	r2, #16
 8008c42:	3608      	adds	r6, #8
 8008c44:	2b07      	cmp	r3, #7
 8008c46:	f8cd 3550 	str.w	r3, [sp, #1360]	; 0x550
 8008c4a:	f106 0908 	add.w	r9, r6, #8
 8008c4e:	f8cd 2554 	str.w	r2, [sp, #1364]	; 0x554
 8008c52:	ddee      	ble.n	8008c32 <_vfprintf_r+0x52a>
 8008c54:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8008c58:	4640      	mov	r0, r8
 8008c5a:	4629      	mov	r1, r5
 8008c5c:	320c      	adds	r2, #12
 8008c5e:	f004 fc4d 	bl	800d4fc <__sprint_r>
 8008c62:	f10a 0908 	add.w	r9, sl, #8
 8008c66:	4656      	mov	r6, sl
 8008c68:	2800      	cmp	r0, #0
 8008c6a:	f47f ae77 	bne.w	800895c <_vfprintf_r+0x254>
 8008c6e:	3f10      	subs	r7, #16
 8008c70:	f8dd 2554 	ldr.w	r2, [sp, #1364]	; 0x554
 8008c74:	2f10      	cmp	r7, #16
 8008c76:	f8dd 3550 	ldr.w	r3, [sp, #1360]	; 0x550
 8008c7a:	dcdd      	bgt.n	8008c38 <_vfprintf_r+0x530>
 8008c7c:	46a0      	mov	r8, r4
 8008c7e:	4615      	mov	r5, r2
 8008c80:	461c      	mov	r4, r3
 8008c82:	3401      	adds	r4, #1
 8008c84:	f8c6 8000 	str.w	r8, [r6]
 8008c88:	2c07      	cmp	r4, #7
 8008c8a:	6077      	str	r7, [r6, #4]
 8008c8c:	443d      	add	r5, r7
 8008c8e:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8008c92:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8008c96:	f300 83fc 	bgt.w	8009492 <_vfprintf_r+0xd8a>
 8008c9a:	9a07      	ldr	r2, [sp, #28]
 8008c9c:	f412 7f80 	tst.w	r2, #256	; 0x100
 8008ca0:	f040 82a9 	bne.w	80091f6 <_vfprintf_r+0xaee>
 8008ca4:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8008ca8:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8008caa:	3401      	adds	r4, #1
 8008cac:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8008cae:	2c07      	cmp	r4, #7
 8008cb0:	441d      	add	r5, r3
 8008cb2:	f8c9 3004 	str.w	r3, [r9, #4]
 8008cb6:	f8c9 0000 	str.w	r0, [r9]
 8008cba:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8008cbe:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8008cc2:	f300 828a 	bgt.w	80091da <_vfprintf_r+0xad2>
 8008cc6:	f109 0908 	add.w	r9, r9, #8
 8008cca:	9c07      	ldr	r4, [sp, #28]
 8008ccc:	f014 0f04 	tst.w	r4, #4
 8008cd0:	d052      	beq.n	8008d78 <_vfprintf_r+0x670>
 8008cd2:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8008cd4:	990a      	ldr	r1, [sp, #40]	; 0x28
 8008cd6:	1a46      	subs	r6, r0, r1
 8008cd8:	2e00      	cmp	r6, #0
 8008cda:	dd4d      	ble.n	8008d78 <_vfprintf_r+0x670>
 8008cdc:	2e10      	cmp	r6, #16
 8008cde:	f341 80f0 	ble.w	8009ec2 <_vfprintf_r+0x17ba>
 8008ce2:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8008ce6:	f240 18a0 	movw	r8, #416	; 0x1a0
 8008cea:	f6c0 0801 	movt	r8, #2049	; 0x801
 8008cee:	2710      	movs	r7, #16
 8008cf0:	4623      	mov	r3, r4
 8008cf2:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
 8008cf6:	4644      	mov	r4, r8
 8008cf8:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
 8008cfc:	e002      	b.n	8008d04 <_vfprintf_r+0x5fc>
 8008cfe:	3e10      	subs	r6, #16
 8008d00:	2e10      	cmp	r6, #16
 8008d02:	dd1f      	ble.n	8008d44 <_vfprintf_r+0x63c>
 8008d04:	3301      	adds	r3, #1
 8008d06:	3510      	adds	r5, #16
 8008d08:	2b07      	cmp	r3, #7
 8008d0a:	f8c9 4000 	str.w	r4, [r9]
 8008d0e:	f8c9 7004 	str.w	r7, [r9, #4]
 8008d12:	f109 0908 	add.w	r9, r9, #8
 8008d16:	f8cd 3550 	str.w	r3, [sp, #1360]	; 0x550
 8008d1a:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8008d1e:	ddee      	ble.n	8008cfe <_vfprintf_r+0x5f6>
 8008d20:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8008d24:	4640      	mov	r0, r8
 8008d26:	4659      	mov	r1, fp
 8008d28:	320c      	adds	r2, #12
 8008d2a:	f004 fbe7 	bl	800d4fc <__sprint_r>
 8008d2e:	46d1      	mov	r9, sl
 8008d30:	2800      	cmp	r0, #0
 8008d32:	f47f ae13 	bne.w	800895c <_vfprintf_r+0x254>
 8008d36:	3e10      	subs	r6, #16
 8008d38:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8008d3c:	2e10      	cmp	r6, #16
 8008d3e:	f8dd 3550 	ldr.w	r3, [sp, #1360]	; 0x550
 8008d42:	dcdf      	bgt.n	8008d04 <_vfprintf_r+0x5fc>
 8008d44:	46a0      	mov	r8, r4
 8008d46:	461c      	mov	r4, r3
 8008d48:	3401      	adds	r4, #1
 8008d4a:	f8c9 8000 	str.w	r8, [r9]
 8008d4e:	2c07      	cmp	r4, #7
 8008d50:	f8c9 6004 	str.w	r6, [r9, #4]
 8008d54:	4435      	add	r5, r6
 8008d56:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8008d5a:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8008d5e:	dd0b      	ble.n	8008d78 <_vfprintf_r+0x670>
 8008d60:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8008d64:	980d      	ldr	r0, [sp, #52]	; 0x34
 8008d66:	9909      	ldr	r1, [sp, #36]	; 0x24
 8008d68:	320c      	adds	r2, #12
 8008d6a:	f004 fbc7 	bl	800d4fc <__sprint_r>
 8008d6e:	2800      	cmp	r0, #0
 8008d70:	f47f adf4 	bne.w	800895c <_vfprintf_r+0x254>
 8008d74:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8008d78:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8008d7a:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8008d7c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8008d7e:	429c      	cmp	r4, r3
 8008d80:	bfac      	ite	ge
 8008d82:	1912      	addge	r2, r2, r4
 8008d84:	18d2      	addlt	r2, r2, r3
 8008d86:	920e      	str	r2, [sp, #56]	; 0x38
 8008d88:	2d00      	cmp	r5, #0
 8008d8a:	f040 8370 	bne.w	800946e <_vfprintf_r+0xd66>
 8008d8e:	2000      	movs	r0, #0
 8008d90:	4656      	mov	r6, sl
 8008d92:	f8cd 0550 	str.w	r0, [sp, #1360]	; 0x550
 8008d96:	e51b      	b.n	80087d0 <_vfprintf_r+0xc8>
 8008d98:	9c07      	ldr	r4, [sp, #28]
 8008d9a:	f044 0408 	orr.w	r4, r4, #8
 8008d9e:	9407      	str	r4, [sp, #28]
 8008da0:	7813      	ldrb	r3, [r2, #0]
 8008da2:	e55c      	b.n	800885e <_vfprintf_r+0x156>
 8008da4:	9907      	ldr	r1, [sp, #28]
 8008da6:	9208      	str	r2, [sp, #32]
 8008da8:	f041 0110 	orr.w	r1, r1, #16
 8008dac:	9107      	str	r1, [sp, #28]
 8008dae:	9a07      	ldr	r2, [sp, #28]
 8008db0:	9316      	str	r3, [sp, #88]	; 0x58
 8008db2:	f012 0320 	ands.w	r3, r2, #32
 8008db6:	f000 812d 	beq.w	8009014 <_vfprintf_r+0x90c>
 8008dba:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8008dbc:	1dda      	adds	r2, r3, #7
 8008dbe:	2300      	movs	r3, #0
 8008dc0:	f022 0207 	bic.w	r2, r2, #7
 8008dc4:	f102 0408 	add.w	r4, r2, #8
 8008dc8:	9412      	str	r4, [sp, #72]	; 0x48
 8008dca:	e9d2 4500 	ldrd	r4, r5, [r2]
 8008dce:	ea54 0005 	orrs.w	r0, r4, r5
 8008dd2:	bf0c      	ite	eq
 8008dd4:	2200      	moveq	r2, #0
 8008dd6:	2201      	movne	r2, #1
 8008dd8:	2000      	movs	r0, #0
 8008dda:	f88d 056f 	strb.w	r0, [sp, #1391]	; 0x56f
 8008dde:	2f00      	cmp	r7, #0
 8008de0:	bfa2      	ittt	ge
 8008de2:	9907      	ldrge	r1, [sp, #28]
 8008de4:	f021 0180 	bicge.w	r1, r1, #128	; 0x80
 8008de8:	9107      	strge	r1, [sp, #28]
 8008dea:	2f00      	cmp	r7, #0
 8008dec:	bf18      	it	ne
 8008dee:	f042 0201 	orrne.w	r2, r2, #1
 8008df2:	2a00      	cmp	r2, #0
 8008df4:	f000 8278 	beq.w	80092e8 <_vfprintf_r+0xbe0>
 8008df8:	2b01      	cmp	r3, #1
 8008dfa:	f000 83db 	beq.w	80095b4 <_vfprintf_r+0xeac>
 8008dfe:	2b02      	cmp	r3, #2
 8008e00:	f000 83e7 	beq.w	80095d2 <_vfprintf_r+0xeca>
 8008e04:	f50d 6ba4 	add.w	fp, sp, #1312	; 0x520
 8008e08:	f10b 0b04 	add.w	fp, fp, #4
 8008e0c:	f10b 0327 	add.w	r3, fp, #39	; 0x27
 8008e10:	08ea      	lsrs	r2, r5, #3
 8008e12:	ea4f 08d4 	mov.w	r8, r4, lsr #3
 8008e16:	ea48 7845 	orr.w	r8, r8, r5, lsl #29
 8008e1a:	f004 0407 	and.w	r4, r4, #7
 8008e1e:	4611      	mov	r1, r2
 8008e20:	f104 0230 	add.w	r2, r4, #48	; 0x30
 8008e24:	460d      	mov	r5, r1
 8008e26:	4644      	mov	r4, r8
 8008e28:	469c      	mov	ip, r3
 8008e2a:	701a      	strb	r2, [r3, #0]
 8008e2c:	3b01      	subs	r3, #1
 8008e2e:	ea54 0005 	orrs.w	r0, r4, r5
 8008e32:	d1ed      	bne.n	8008e10 <_vfprintf_r+0x708>
 8008e34:	9907      	ldr	r1, [sp, #28]
 8008e36:	f8cd c04c 	str.w	ip, [sp, #76]	; 0x4c
 8008e3a:	f011 0f01 	tst.w	r1, #1
 8008e3e:	f040 849a 	bne.w	8009776 <_vfprintf_r+0x106e>
 8008e42:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8008e46:	ebcc 020b 	rsb	r2, ip, fp
 8008e4a:	9211      	str	r2, [sp, #68]	; 0x44
 8008e4c:	9c11      	ldr	r4, [sp, #68]	; 0x44
 8008e4e:	2000      	movs	r0, #0
 8008e50:	f89d 256f 	ldrb.w	r2, [sp, #1391]	; 0x56f
 8008e54:	42bc      	cmp	r4, r7
 8008e56:	bfb8      	it	lt
 8008e58:	463c      	movlt	r4, r7
 8008e5a:	9714      	str	r7, [sp, #80]	; 0x50
 8008e5c:	940a      	str	r4, [sp, #40]	; 0x28
 8008e5e:	9019      	str	r0, [sp, #100]	; 0x64
 8008e60:	e643      	b.n	8008aea <_vfprintf_r+0x3e2>
 8008e62:	9c07      	ldr	r4, [sp, #28]
 8008e64:	9208      	str	r2, [sp, #32]
 8008e66:	f044 0410 	orr.w	r4, r4, #16
 8008e6a:	9407      	str	r4, [sp, #28]
 8008e6c:	9807      	ldr	r0, [sp, #28]
 8008e6e:	9316      	str	r3, [sp, #88]	; 0x58
 8008e70:	f010 0f20 	tst.w	r0, #32
 8008e74:	f000 813f 	beq.w	80090f6 <_vfprintf_r+0x9ee>
 8008e78:	9912      	ldr	r1, [sp, #72]	; 0x48
 8008e7a:	2301      	movs	r3, #1
 8008e7c:	1dca      	adds	r2, r1, #7
 8008e7e:	e79f      	b.n	8008dc0 <_vfprintf_r+0x6b8>
 8008e80:	4614      	mov	r4, r2
 8008e82:	2000      	movs	r0, #0
 8008e84:	f1a3 0830 	sub.w	r8, r3, #48	; 0x30
 8008e88:	f814 3b01 	ldrb.w	r3, [r4], #1
 8008e8c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8008e90:	f1a3 0c30 	sub.w	ip, r3, #48	; 0x30
 8008e94:	4622      	mov	r2, r4
 8008e96:	f1bc 0f09 	cmp.w	ip, #9
 8008e9a:	eb08 0040 	add.w	r0, r8, r0, lsl #1
 8008e9e:	d9f1      	bls.n	8008e84 <_vfprintf_r+0x77c>
 8008ea0:	900f      	str	r0, [sp, #60]	; 0x3c
 8008ea2:	e4dd      	b.n	8008860 <_vfprintf_r+0x158>
 8008ea4:	9208      	str	r2, [sp, #32]
 8008ea6:	f240 4184 	movw	r1, #1156	; 0x484
 8008eaa:	9a07      	ldr	r2, [sp, #28]
 8008eac:	f6c0 0101 	movt	r1, #2049	; 0x801
 8008eb0:	9316      	str	r3, [sp, #88]	; 0x58
 8008eb2:	f012 0f20 	tst.w	r2, #32
 8008eb6:	9118      	str	r1, [sp, #96]	; 0x60
 8008eb8:	f000 813e 	beq.w	8009138 <_vfprintf_r+0xa30>
 8008ebc:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8008ebe:	1de3      	adds	r3, r4, #7
 8008ec0:	f023 0307 	bic.w	r3, r3, #7
 8008ec4:	f103 0008 	add.w	r0, r3, #8
 8008ec8:	9012      	str	r0, [sp, #72]	; 0x48
 8008eca:	e9d3 4500 	ldrd	r4, r5, [r3]
 8008ece:	ea54 0205 	orrs.w	r2, r4, r5
 8008ed2:	9b07      	ldr	r3, [sp, #28]
 8008ed4:	bf0c      	ite	eq
 8008ed6:	2200      	moveq	r2, #0
 8008ed8:	2201      	movne	r2, #1
 8008eda:	4213      	tst	r3, r2
 8008edc:	f000 83d3 	beq.w	8009686 <_vfprintf_r+0xf7e>
 8008ee0:	9816      	ldr	r0, [sp, #88]	; 0x58
 8008ee2:	2330      	movs	r3, #48	; 0x30
 8008ee4:	9907      	ldr	r1, [sp, #28]
 8008ee6:	2201      	movs	r2, #1
 8008ee8:	f88d 356c 	strb.w	r3, [sp, #1388]	; 0x56c
 8008eec:	2302      	movs	r3, #2
 8008eee:	f041 0102 	orr.w	r1, r1, #2
 8008ef2:	f88d 056d 	strb.w	r0, [sp, #1389]	; 0x56d
 8008ef6:	9107      	str	r1, [sp, #28]
 8008ef8:	e76e      	b.n	8008dd8 <_vfprintf_r+0x6d0>
 8008efa:	9316      	str	r3, [sp, #88]	; 0x58
 8008efc:	2101      	movs	r1, #1
 8008efe:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8008f00:	2000      	movs	r0, #0
 8008f02:	910a      	str	r1, [sp, #40]	; 0x28
 8008f04:	1d1c      	adds	r4, r3, #4
 8008f06:	9208      	str	r2, [sp, #32]
 8008f08:	681b      	ldr	r3, [r3, #0]
 8008f0a:	2200      	movs	r2, #0
 8008f0c:	9111      	str	r1, [sp, #68]	; 0x44
 8008f0e:	f50d 61a4 	add.w	r1, sp, #1312	; 0x520
 8008f12:	3104      	adds	r1, #4
 8008f14:	9412      	str	r4, [sp, #72]	; 0x48
 8008f16:	f88d 056f 	strb.w	r0, [sp, #1391]	; 0x56f
 8008f1a:	9214      	str	r2, [sp, #80]	; 0x50
 8008f1c:	9219      	str	r2, [sp, #100]	; 0x64
 8008f1e:	9113      	str	r1, [sp, #76]	; 0x4c
 8008f20:	f88d 3524 	strb.w	r3, [sp, #1316]	; 0x524
 8008f24:	e5e5      	b.n	8008af2 <_vfprintf_r+0x3ea>
 8008f26:	9208      	str	r2, [sp, #32]
 8008f28:	9a07      	ldr	r2, [sp, #28]
 8008f2a:	9316      	str	r3, [sp, #88]	; 0x58
 8008f2c:	f042 0210 	orr.w	r2, r2, #16
 8008f30:	9207      	str	r2, [sp, #28]
 8008f32:	9b07      	ldr	r3, [sp, #28]
 8008f34:	f013 0f20 	tst.w	r3, #32
 8008f38:	f000 809e 	beq.w	8009078 <_vfprintf_r+0x970>
 8008f3c:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8008f3e:	1de3      	adds	r3, r4, #7
 8008f40:	f023 0307 	bic.w	r3, r3, #7
 8008f44:	f103 0008 	add.w	r0, r3, #8
 8008f48:	9012      	str	r0, [sp, #72]	; 0x48
 8008f4a:	e9d3 4500 	ldrd	r4, r5, [r3]
 8008f4e:	2c00      	cmp	r4, #0
 8008f50:	f175 0200 	sbcs.w	r2, r5, #0
 8008f54:	f2c0 8420 	blt.w	8009798 <_vfprintf_r+0x1090>
 8008f58:	ea54 0305 	orrs.w	r3, r4, r5
 8008f5c:	f04f 0301 	mov.w	r3, #1
 8008f60:	bf0c      	ite	eq
 8008f62:	2200      	moveq	r2, #0
 8008f64:	2201      	movne	r2, #1
 8008f66:	e73a      	b.n	8008dde <_vfprintf_r+0x6d6>
 8008f68:	9807      	ldr	r0, [sp, #28]
 8008f6a:	f040 0020 	orr.w	r0, r0, #32
 8008f6e:	9007      	str	r0, [sp, #28]
 8008f70:	7813      	ldrb	r3, [r2, #0]
 8008f72:	e474      	b.n	800885e <_vfprintf_r+0x156>
 8008f74:	9208      	str	r2, [sp, #32]
 8008f76:	2100      	movs	r1, #0
 8008f78:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8008f7a:	9316      	str	r3, [sp, #88]	; 0x58
 8008f7c:	f88d 156f 	strb.w	r1, [sp, #1391]	; 0x56f
 8008f80:	1d14      	adds	r4, r2, #4
 8008f82:	6813      	ldr	r3, [r2, #0]
 8008f84:	9313      	str	r3, [sp, #76]	; 0x4c
 8008f86:	2b00      	cmp	r3, #0
 8008f88:	f000 8770 	beq.w	8009e6c <_vfprintf_r+0x1764>
 8008f8c:	2f00      	cmp	r7, #0
 8008f8e:	f2c0 8718 	blt.w	8009dc2 <_vfprintf_r+0x16ba>
 8008f92:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8008f94:	2100      	movs	r1, #0
 8008f96:	463a      	mov	r2, r7
 8008f98:	f002 fd6c 	bl	800ba74 <memchr>
 8008f9c:	2800      	cmp	r0, #0
 8008f9e:	f000 87e3 	beq.w	8009f68 <_vfprintf_r+0x1860>
 8008fa2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8008fa4:	1ac0      	subs	r0, r0, r3
 8008fa6:	9011      	str	r0, [sp, #68]	; 0x44
 8008fa8:	42b8      	cmp	r0, r7
 8008faa:	f340 8640 	ble.w	8009c2e <_vfprintf_r+0x1526>
 8008fae:	2000      	movs	r0, #0
 8008fb0:	ea27 71e7 	bic.w	r1, r7, r7, asr #31
 8008fb4:	9014      	str	r0, [sp, #80]	; 0x50
 8008fb6:	910a      	str	r1, [sp, #40]	; 0x28
 8008fb8:	f89d 256f 	ldrb.w	r2, [sp, #1391]	; 0x56f
 8008fbc:	9412      	str	r4, [sp, #72]	; 0x48
 8008fbe:	9711      	str	r7, [sp, #68]	; 0x44
 8008fc0:	9019      	str	r0, [sp, #100]	; 0x64
 8008fc2:	e592      	b.n	8008aea <_vfprintf_r+0x3e2>
 8008fc4:	7813      	ldrb	r3, [r2, #0]
 8008fc6:	2b6c      	cmp	r3, #108	; 0x6c
 8008fc8:	bf0b      	itete	eq
 8008fca:	9b07      	ldreq	r3, [sp, #28]
 8008fcc:	9c07      	ldrne	r4, [sp, #28]
 8008fce:	f043 0320 	orreq.w	r3, r3, #32
 8008fd2:	f044 0410 	orrne.w	r4, r4, #16
 8008fd6:	bf0a      	itet	eq
 8008fd8:	9307      	streq	r3, [sp, #28]
 8008fda:	9407      	strne	r4, [sp, #28]
 8008fdc:	f812 3f01 	ldrbeq.w	r3, [r2, #1]!
 8008fe0:	e43d      	b.n	800885e <_vfprintf_r+0x156>
 8008fe2:	9208      	str	r2, [sp, #32]
 8008fe4:	9a07      	ldr	r2, [sp, #28]
 8008fe6:	f012 0f20 	tst.w	r2, #32
 8008fea:	f000 8503 	beq.w	80099f4 <_vfprintf_r+0x12ec>
 8008fee:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8008ff0:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 8008ff2:	9812      	ldr	r0, [sp, #72]	; 0x48
 8008ff4:	6819      	ldr	r1, [r3, #0]
 8008ff6:	4622      	mov	r2, r4
 8008ff8:	17e3      	asrs	r3, r4, #31
 8008ffa:	3004      	adds	r0, #4
 8008ffc:	9012      	str	r0, [sp, #72]	; 0x48
 8008ffe:	e9c1 2300 	strd	r2, r3, [r1]
 8009002:	f7ff bbe5 	b.w	80087d0 <_vfprintf_r+0xc8>
 8009006:	9208      	str	r2, [sp, #32]
 8009008:	9a07      	ldr	r2, [sp, #28]
 800900a:	9316      	str	r3, [sp, #88]	; 0x58
 800900c:	f012 0320 	ands.w	r3, r2, #32
 8009010:	f47f aed3 	bne.w	8008dba <_vfprintf_r+0x6b2>
 8009014:	9907      	ldr	r1, [sp, #28]
 8009016:	f011 0210 	ands.w	r2, r1, #16
 800901a:	f000 84d9 	beq.w	80099d0 <_vfprintf_r+0x12c8>
 800901e:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8009020:	6822      	ldr	r2, [r4, #0]
 8009022:	3404      	adds	r4, #4
 8009024:	2500      	movs	r5, #0
 8009026:	9412      	str	r4, [sp, #72]	; 0x48
 8009028:	4614      	mov	r4, r2
 800902a:	3a00      	subs	r2, #0
 800902c:	bf18      	it	ne
 800902e:	2201      	movne	r2, #1
 8009030:	e6d2      	b.n	8008dd8 <_vfprintf_r+0x6d0>
 8009032:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8009034:	2178      	movs	r1, #120	; 0x78
 8009036:	9c07      	ldr	r4, [sp, #28]
 8009038:	2500      	movs	r5, #0
 800903a:	9208      	str	r2, [sp, #32]
 800903c:	f240 4098 	movw	r0, #1176	; 0x498
 8009040:	681a      	ldr	r2, [r3, #0]
 8009042:	f044 0402 	orr.w	r4, r4, #2
 8009046:	3304      	adds	r3, #4
 8009048:	9407      	str	r4, [sp, #28]
 800904a:	9312      	str	r3, [sp, #72]	; 0x48
 800904c:	4614      	mov	r4, r2
 800904e:	2330      	movs	r3, #48	; 0x30
 8009050:	3a00      	subs	r2, #0
 8009052:	f88d 356c 	strb.w	r3, [sp, #1388]	; 0x56c
 8009056:	bf18      	it	ne
 8009058:	2201      	movne	r2, #1
 800905a:	f6c0 0001 	movt	r0, #2049	; 0x801
 800905e:	f88d 156d 	strb.w	r1, [sp, #1389]	; 0x56d
 8009062:	9018      	str	r0, [sp, #96]	; 0x60
 8009064:	2302      	movs	r3, #2
 8009066:	9116      	str	r1, [sp, #88]	; 0x58
 8009068:	e6b6      	b.n	8008dd8 <_vfprintf_r+0x6d0>
 800906a:	9316      	str	r3, [sp, #88]	; 0x58
 800906c:	9b07      	ldr	r3, [sp, #28]
 800906e:	9208      	str	r2, [sp, #32]
 8009070:	f013 0f20 	tst.w	r3, #32
 8009074:	f47f af62 	bne.w	8008f3c <_vfprintf_r+0x834>
 8009078:	9907      	ldr	r1, [sp, #28]
 800907a:	f011 0f10 	tst.w	r1, #16
 800907e:	f000 849a 	beq.w	80099b6 <_vfprintf_r+0x12ae>
 8009082:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8009084:	6814      	ldr	r4, [r2, #0]
 8009086:	3204      	adds	r2, #4
 8009088:	9212      	str	r2, [sp, #72]	; 0x48
 800908a:	17e5      	asrs	r5, r4, #31
 800908c:	e75f      	b.n	8008f4e <_vfprintf_r+0x846>
 800908e:	9807      	ldr	r0, [sp, #28]
 8009090:	f040 0040 	orr.w	r0, r0, #64	; 0x40
 8009094:	9007      	str	r0, [sp, #28]
 8009096:	7813      	ldrb	r3, [r2, #0]
 8009098:	f7ff bbe1 	b.w	800885e <_vfprintf_r+0x156>
 800909c:	9208      	str	r2, [sp, #32]
 800909e:	9316      	str	r3, [sp, #88]	; 0x58
 80090a0:	2b00      	cmp	r3, #0
 80090a2:	f43f ac51 	beq.w	8008948 <_vfprintf_r+0x240>
 80090a6:	f50d 64a4 	add.w	r4, sp, #1312	; 0x520
 80090aa:	2200      	movs	r2, #0
 80090ac:	2101      	movs	r1, #1
 80090ae:	f88d 3524 	strb.w	r3, [sp, #1316]	; 0x524
 80090b2:	3404      	adds	r4, #4
 80090b4:	2300      	movs	r3, #0
 80090b6:	910a      	str	r1, [sp, #40]	; 0x28
 80090b8:	9111      	str	r1, [sp, #68]	; 0x44
 80090ba:	f88d 356f 	strb.w	r3, [sp, #1391]	; 0x56f
 80090be:	9214      	str	r2, [sp, #80]	; 0x50
 80090c0:	9219      	str	r2, [sp, #100]	; 0x64
 80090c2:	9413      	str	r4, [sp, #76]	; 0x4c
 80090c4:	e515      	b.n	8008af2 <_vfprintf_r+0x3ea>
 80090c6:	f89d 356f 	ldrb.w	r3, [sp, #1391]	; 0x56f
 80090ca:	2b00      	cmp	r3, #0
 80090cc:	f040 8372 	bne.w	80097b4 <_vfprintf_r+0x10ac>
 80090d0:	f88d 556f 	strb.w	r5, [sp, #1391]	; 0x56f
 80090d4:	7813      	ldrb	r3, [r2, #0]
 80090d6:	f7ff bbc2 	b.w	800885e <_vfprintf_r+0x156>
 80090da:	9807      	ldr	r0, [sp, #28]
 80090dc:	f040 0001 	orr.w	r0, r0, #1
 80090e0:	9007      	str	r0, [sp, #28]
 80090e2:	7813      	ldrb	r3, [r2, #0]
 80090e4:	f7ff bbbb 	b.w	800885e <_vfprintf_r+0x156>
 80090e8:	9807      	ldr	r0, [sp, #28]
 80090ea:	9208      	str	r2, [sp, #32]
 80090ec:	f010 0f20 	tst.w	r0, #32
 80090f0:	9316      	str	r3, [sp, #88]	; 0x58
 80090f2:	f47f aec1 	bne.w	8008e78 <_vfprintf_r+0x770>
 80090f6:	9907      	ldr	r1, [sp, #28]
 80090f8:	f011 0f10 	tst.w	r1, #16
 80090fc:	f040 82c6 	bne.w	800968c <_vfprintf_r+0xf84>
 8009100:	9807      	ldr	r0, [sp, #28]
 8009102:	f010 0f40 	tst.w	r0, #64	; 0x40
 8009106:	f000 82c1 	beq.w	800968c <_vfprintf_r+0xf84>
 800910a:	9912      	ldr	r1, [sp, #72]	; 0x48
 800910c:	2301      	movs	r3, #1
 800910e:	2500      	movs	r5, #0
 8009110:	880a      	ldrh	r2, [r1, #0]
 8009112:	3104      	adds	r1, #4
 8009114:	9112      	str	r1, [sp, #72]	; 0x48
 8009116:	4614      	mov	r4, r2
 8009118:	3a00      	subs	r2, #0
 800911a:	bf18      	it	ne
 800911c:	2201      	movne	r2, #1
 800911e:	e65b      	b.n	8008dd8 <_vfprintf_r+0x6d0>
 8009120:	9208      	str	r2, [sp, #32]
 8009122:	f240 4098 	movw	r0, #1176	; 0x498
 8009126:	9a07      	ldr	r2, [sp, #28]
 8009128:	f6c0 0001 	movt	r0, #2049	; 0x801
 800912c:	9316      	str	r3, [sp, #88]	; 0x58
 800912e:	f012 0f20 	tst.w	r2, #32
 8009132:	9018      	str	r0, [sp, #96]	; 0x60
 8009134:	f47f aec2 	bne.w	8008ebc <_vfprintf_r+0x7b4>
 8009138:	9907      	ldr	r1, [sp, #28]
 800913a:	f011 0f10 	tst.w	r1, #16
 800913e:	f000 842e 	beq.w	800999e <_vfprintf_r+0x1296>
 8009142:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8009144:	2500      	movs	r5, #0
 8009146:	6814      	ldr	r4, [r2, #0]
 8009148:	3204      	adds	r2, #4
 800914a:	9212      	str	r2, [sp, #72]	; 0x48
 800914c:	e6bf      	b.n	8008ece <_vfprintf_r+0x7c6>
 800914e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8009150:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8009152:	681b      	ldr	r3, [r3, #0]
 8009154:	1d20      	adds	r0, r4, #4
 8009156:	2b00      	cmp	r3, #0
 8009158:	930f      	str	r3, [sp, #60]	; 0x3c
 800915a:	f6ff abe1 	blt.w	8008920 <_vfprintf_r+0x218>
 800915e:	7813      	ldrb	r3, [r2, #0]
 8009160:	9012      	str	r0, [sp, #72]	; 0x48
 8009162:	f7ff bb7c 	b.w	800885e <_vfprintf_r+0x156>
 8009166:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 800916a:	980d      	ldr	r0, [sp, #52]	; 0x34
 800916c:	9909      	ldr	r1, [sp, #36]	; 0x24
 800916e:	320c      	adds	r2, #12
 8009170:	f004 f9c4 	bl	800d4fc <__sprint_r>
 8009174:	2800      	cmp	r0, #0
 8009176:	f47f abf1 	bne.w	800895c <_vfprintf_r+0x254>
 800917a:	f89d 256f 	ldrb.w	r2, [sp, #1391]	; 0x56f
 800917e:	4656      	mov	r6, sl
 8009180:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8009184:	e513      	b.n	8008bae <_vfprintf_r+0x4a6>
 8009186:	9a07      	ldr	r2, [sp, #28]
 8009188:	f012 0f01 	tst.w	r2, #1
 800918c:	f040 811c 	bne.w	80093c8 <_vfprintf_r+0xcc0>
 8009190:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009194:	3501      	adds	r5, #1
 8009196:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8009198:	2301      	movs	r3, #1
 800919a:	3401      	adds	r4, #1
 800919c:	f8c9 3004 	str.w	r3, [r9, #4]
 80091a0:	2c07      	cmp	r4, #7
 80091a2:	f8c9 2000 	str.w	r2, [r9]
 80091a6:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 80091aa:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 80091ae:	f300 859f 	bgt.w	8009cf0 <_vfprintf_r+0x15e8>
 80091b2:	f109 0b08 	add.w	fp, r9, #8
 80091b6:	f10b 0908 	add.w	r9, fp, #8
 80091ba:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80091bc:	3401      	adds	r4, #1
 80091be:	2c07      	cmp	r4, #7
 80091c0:	441d      	add	r5, r3
 80091c2:	f8cb 3004 	str.w	r3, [fp, #4]
 80091c6:	f50d 63ab 	add.w	r3, sp, #1368	; 0x558
 80091ca:	f8cb 3000 	str.w	r3, [fp]
 80091ce:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 80091d2:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 80091d6:	f77f ad78 	ble.w	8008cca <_vfprintf_r+0x5c2>
 80091da:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 80091de:	980d      	ldr	r0, [sp, #52]	; 0x34
 80091e0:	9909      	ldr	r1, [sp, #36]	; 0x24
 80091e2:	320c      	adds	r2, #12
 80091e4:	f004 f98a 	bl	800d4fc <__sprint_r>
 80091e8:	2800      	cmp	r0, #0
 80091ea:	f47f abb7 	bne.w	800895c <_vfprintf_r+0x254>
 80091ee:	46d1      	mov	r9, sl
 80091f0:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 80091f4:	e569      	b.n	8008cca <_vfprintf_r+0x5c2>
 80091f6:	9916      	ldr	r1, [sp, #88]	; 0x58
 80091f8:	2965      	cmp	r1, #101	; 0x65
 80091fa:	f340 80e1 	ble.w	80093c0 <_vfprintf_r+0xcb8>
 80091fe:	981a      	ldr	r0, [sp, #104]	; 0x68
 8009200:	2200      	movs	r2, #0
 8009202:	2300      	movs	r3, #0
 8009204:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8009206:	f006 fa91 	bl	800f72c <__aeabi_dcmpeq>
 800920a:	2800      	cmp	r0, #0
 800920c:	f000 816e 	beq.w	80094ec <_vfprintf_r+0xde4>
 8009210:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009214:	f240 43b4 	movw	r3, #1204	; 0x4b4
 8009218:	f6c0 0301 	movt	r3, #2049	; 0x801
 800921c:	f8c9 3000 	str.w	r3, [r9]
 8009220:	3401      	adds	r4, #1
 8009222:	2301      	movs	r3, #1
 8009224:	2c07      	cmp	r4, #7
 8009226:	f8c9 3004 	str.w	r3, [r9, #4]
 800922a:	441d      	add	r5, r3
 800922c:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8009230:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8009234:	bfd8      	it	le
 8009236:	f109 0908 	addle.w	r9, r9, #8
 800923a:	f300 8480 	bgt.w	8009b3e <_vfprintf_r+0x1436>
 800923e:	f8dd 3568 	ldr.w	r3, [sp, #1384]	; 0x568
 8009242:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8009244:	4293      	cmp	r3, r2
 8009246:	db04      	blt.n	8009252 <_vfprintf_r+0xb4a>
 8009248:	9b07      	ldr	r3, [sp, #28]
 800924a:	f013 0f01 	tst.w	r3, #1
 800924e:	f43f ad3c 	beq.w	8008cca <_vfprintf_r+0x5c2>
 8009252:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009256:	981c      	ldr	r0, [sp, #112]	; 0x70
 8009258:	3401      	adds	r4, #1
 800925a:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800925c:	2c07      	cmp	r4, #7
 800925e:	4405      	add	r5, r0
 8009260:	f8c9 0004 	str.w	r0, [r9, #4]
 8009264:	bfd8      	it	le
 8009266:	f109 0308 	addle.w	r3, r9, #8
 800926a:	f8c9 1000 	str.w	r1, [r9]
 800926e:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8009272:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8009276:	f300 8562 	bgt.w	8009d3e <_vfprintf_r+0x1636>
 800927a:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800927c:	1e56      	subs	r6, r2, #1
 800927e:	2e00      	cmp	r6, #0
 8009280:	f340 8452 	ble.w	8009b28 <_vfprintf_r+0x1420>
 8009284:	2e10      	cmp	r6, #16
 8009286:	f340 86a5 	ble.w	8009fd4 <_vfprintf_r+0x18cc>
 800928a:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 800928e:	2710      	movs	r7, #16
 8009290:	f8df 8500 	ldr.w	r8, [pc, #1280]	; 8009794 <_vfprintf_r+0x108c>
 8009294:	4622      	mov	r2, r4
 8009296:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
 800929a:	4644      	mov	r4, r8
 800929c:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
 80092a0:	e003      	b.n	80092aa <_vfprintf_r+0xba2>
 80092a2:	3e10      	subs	r6, #16
 80092a4:	2e10      	cmp	r6, #16
 80092a6:	f340 81f6 	ble.w	8009696 <_vfprintf_r+0xf8e>
 80092aa:	3201      	adds	r2, #1
 80092ac:	601c      	str	r4, [r3, #0]
 80092ae:	605f      	str	r7, [r3, #4]
 80092b0:	3510      	adds	r5, #16
 80092b2:	3308      	adds	r3, #8
 80092b4:	2a07      	cmp	r2, #7
 80092b6:	f8cd 2550 	str.w	r2, [sp, #1360]	; 0x550
 80092ba:	f103 0908 	add.w	r9, r3, #8
 80092be:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 80092c2:	ddee      	ble.n	80092a2 <_vfprintf_r+0xb9a>
 80092c4:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 80092c8:	4640      	mov	r0, r8
 80092ca:	4659      	mov	r1, fp
 80092cc:	320c      	adds	r2, #12
 80092ce:	f004 f915 	bl	800d4fc <__sprint_r>
 80092d2:	f10a 0908 	add.w	r9, sl, #8
 80092d6:	4653      	mov	r3, sl
 80092d8:	2800      	cmp	r0, #0
 80092da:	f47f ab3f 	bne.w	800895c <_vfprintf_r+0x254>
 80092de:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 80092e2:	f8dd 2550 	ldr.w	r2, [sp, #1360]	; 0x550
 80092e6:	e7dc      	b.n	80092a2 <_vfprintf_r+0xb9a>
 80092e8:	2b00      	cmp	r3, #0
 80092ea:	f040 80cc 	bne.w	8009486 <_vfprintf_r+0xd7e>
 80092ee:	9c07      	ldr	r4, [sp, #28]
 80092f0:	f014 0f01 	tst.w	r4, #1
 80092f4:	f000 8158 	beq.w	80095a8 <_vfprintf_r+0xea0>
 80092f8:	f50d 61a8 	add.w	r1, sp, #1344	; 0x540
 80092fc:	2001      	movs	r0, #1
 80092fe:	2330      	movs	r3, #48	; 0x30
 8009300:	310b      	adds	r1, #11
 8009302:	9011      	str	r0, [sp, #68]	; 0x44
 8009304:	f88d 354b 	strb.w	r3, [sp, #1355]	; 0x54b
 8009308:	9113      	str	r1, [sp, #76]	; 0x4c
 800930a:	e59f      	b.n	8008e4c <_vfprintf_r+0x744>
 800930c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800930e:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8009310:	1b1f      	subs	r7, r3, r4
 8009312:	2f00      	cmp	r7, #0
 8009314:	f77f ac77 	ble.w	8008c06 <_vfprintf_r+0x4fe>
 8009318:	2f10      	cmp	r7, #16
 800931a:	f340 8612 	ble.w	8009f42 <_vfprintf_r+0x183a>
 800931e:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009322:	4633      	mov	r3, r6
 8009324:	f8df 846c 	ldr.w	r8, [pc, #1132]	; 8009794 <_vfprintf_r+0x108c>
 8009328:	f04f 0910 	mov.w	r9, #16
 800932c:	4622      	mov	r2, r4
 800932e:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
 8009332:	4644      	mov	r4, r8
 8009334:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
 8009338:	e002      	b.n	8009340 <_vfprintf_r+0xc38>
 800933a:	3f10      	subs	r7, #16
 800933c:	2f10      	cmp	r7, #16
 800933e:	dd21      	ble.n	8009384 <_vfprintf_r+0xc7c>
 8009340:	3201      	adds	r2, #1
 8009342:	601c      	str	r4, [r3, #0]
 8009344:	f8c3 9004 	str.w	r9, [r3, #4]
 8009348:	3510      	adds	r5, #16
 800934a:	3308      	adds	r3, #8
 800934c:	2a07      	cmp	r2, #7
 800934e:	f8cd 2550 	str.w	r2, [sp, #1360]	; 0x550
 8009352:	f103 0608 	add.w	r6, r3, #8
 8009356:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 800935a:	ddee      	ble.n	800933a <_vfprintf_r+0xc32>
 800935c:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8009360:	4640      	mov	r0, r8
 8009362:	4659      	mov	r1, fp
 8009364:	320c      	adds	r2, #12
 8009366:	f004 f8c9 	bl	800d4fc <__sprint_r>
 800936a:	f10a 0608 	add.w	r6, sl, #8
 800936e:	4653      	mov	r3, sl
 8009370:	2800      	cmp	r0, #0
 8009372:	f47f aaf3 	bne.w	800895c <_vfprintf_r+0x254>
 8009376:	3f10      	subs	r7, #16
 8009378:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 800937c:	2f10      	cmp	r7, #16
 800937e:	f8dd 2550 	ldr.w	r2, [sp, #1360]	; 0x550
 8009382:	dcdd      	bgt.n	8009340 <_vfprintf_r+0xc38>
 8009384:	46a0      	mov	r8, r4
 8009386:	4614      	mov	r4, r2
 8009388:	3401      	adds	r4, #1
 800938a:	f8c3 8000 	str.w	r8, [r3]
 800938e:	2c07      	cmp	r4, #7
 8009390:	605f      	str	r7, [r3, #4]
 8009392:	443d      	add	r5, r7
 8009394:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8009398:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 800939c:	f77f ac33 	ble.w	8008c06 <_vfprintf_r+0x4fe>
 80093a0:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 80093a4:	980d      	ldr	r0, [sp, #52]	; 0x34
 80093a6:	9909      	ldr	r1, [sp, #36]	; 0x24
 80093a8:	320c      	adds	r2, #12
 80093aa:	f004 f8a7 	bl	800d4fc <__sprint_r>
 80093ae:	2800      	cmp	r0, #0
 80093b0:	f47f aad4 	bne.w	800895c <_vfprintf_r+0x254>
 80093b4:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 80093b8:	4656      	mov	r6, sl
 80093ba:	e424      	b.n	8008c06 <_vfprintf_r+0x4fe>
 80093bc:	46b1      	mov	r9, r6
 80093be:	e46c      	b.n	8008c9a <_vfprintf_r+0x592>
 80093c0:	9910      	ldr	r1, [sp, #64]	; 0x40
 80093c2:	2901      	cmp	r1, #1
 80093c4:	f77f aedf 	ble.w	8009186 <_vfprintf_r+0xa7e>
 80093c8:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 80093cc:	3501      	adds	r5, #1
 80093ce:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80093d0:	3401      	adds	r4, #1
 80093d2:	f8c9 3000 	str.w	r3, [r9]
 80093d6:	2301      	movs	r3, #1
 80093d8:	2c07      	cmp	r4, #7
 80093da:	f8c9 3004 	str.w	r3, [r9, #4]
 80093de:	bfd8      	it	le
 80093e0:	f109 0908 	addle.w	r9, r9, #8
 80093e4:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 80093e8:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 80093ec:	bfd8      	it	le
 80093ee:	f109 0608 	addle.w	r6, r9, #8
 80093f2:	f300 8186 	bgt.w	8009702 <_vfprintf_r+0xffa>
 80093f6:	3401      	adds	r4, #1
 80093f8:	991c      	ldr	r1, [sp, #112]	; 0x70
 80093fa:	9817      	ldr	r0, [sp, #92]	; 0x5c
 80093fc:	2c07      	cmp	r4, #7
 80093fe:	440d      	add	r5, r1
 8009400:	bfd8      	it	le
 8009402:	f106 0b08 	addle.w	fp, r6, #8
 8009406:	f8c9 1004 	str.w	r1, [r9, #4]
 800940a:	f8c9 0000 	str.w	r0, [r9]
 800940e:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8009412:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8009416:	f300 8162 	bgt.w	80096de <_vfprintf_r+0xfd6>
 800941a:	981a      	ldr	r0, [sp, #104]	; 0x68
 800941c:	2200      	movs	r2, #0
 800941e:	2300      	movs	r3, #0
 8009420:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8009422:	f006 f983 	bl	800f72c <__aeabi_dcmpeq>
 8009426:	2800      	cmp	r0, #0
 8009428:	f040 80f1 	bne.w	800960e <_vfprintf_r+0xf06>
 800942c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800942e:	3401      	adds	r4, #1
 8009430:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8009432:	1e5a      	subs	r2, r3, #1
 8009434:	6072      	str	r2, [r6, #4]
 8009436:	1c43      	adds	r3, r0, #1
 8009438:	2c07      	cmp	r4, #7
 800943a:	6033      	str	r3, [r6, #0]
 800943c:	4415      	add	r5, r2
 800943e:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8009442:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8009446:	f77f aeb6 	ble.w	80091b6 <_vfprintf_r+0xaae>
 800944a:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 800944e:	980d      	ldr	r0, [sp, #52]	; 0x34
 8009450:	9909      	ldr	r1, [sp, #36]	; 0x24
 8009452:	320c      	adds	r2, #12
 8009454:	f004 f852 	bl	800d4fc <__sprint_r>
 8009458:	2800      	cmp	r0, #0
 800945a:	f47f aa7f 	bne.w	800895c <_vfprintf_r+0x254>
 800945e:	f10a 0908 	add.w	r9, sl, #8
 8009462:	46d3      	mov	fp, sl
 8009464:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8009468:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 800946c:	e6a5      	b.n	80091ba <_vfprintf_r+0xab2>
 800946e:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8009472:	980d      	ldr	r0, [sp, #52]	; 0x34
 8009474:	9909      	ldr	r1, [sp, #36]	; 0x24
 8009476:	320c      	adds	r2, #12
 8009478:	f004 f840 	bl	800d4fc <__sprint_r>
 800947c:	2800      	cmp	r0, #0
 800947e:	f43f ac86 	beq.w	8008d8e <_vfprintf_r+0x686>
 8009482:	f7ff ba6b 	b.w	800895c <_vfprintf_r+0x254>
 8009486:	9211      	str	r2, [sp, #68]	; 0x44
 8009488:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 800948c:	320c      	adds	r2, #12
 800948e:	9213      	str	r2, [sp, #76]	; 0x4c
 8009490:	e4dc      	b.n	8008e4c <_vfprintf_r+0x744>
 8009492:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8009496:	980d      	ldr	r0, [sp, #52]	; 0x34
 8009498:	9909      	ldr	r1, [sp, #36]	; 0x24
 800949a:	320c      	adds	r2, #12
 800949c:	f004 f82e 	bl	800d4fc <__sprint_r>
 80094a0:	2800      	cmp	r0, #0
 80094a2:	f47f aa5b 	bne.w	800895c <_vfprintf_r+0x254>
 80094a6:	46d1      	mov	r9, sl
 80094a8:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 80094ac:	f7ff bbf5 	b.w	8008c9a <_vfprintf_r+0x592>
 80094b0:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 80094b4:	980d      	ldr	r0, [sp, #52]	; 0x34
 80094b6:	9909      	ldr	r1, [sp, #36]	; 0x24
 80094b8:	320c      	adds	r2, #12
 80094ba:	f004 f81f 	bl	800d4fc <__sprint_r>
 80094be:	2800      	cmp	r0, #0
 80094c0:	f47f aa4c 	bne.w	800895c <_vfprintf_r+0x254>
 80094c4:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 80094c8:	4656      	mov	r6, sl
 80094ca:	f7ff bb98 	b.w	8008bfe <_vfprintf_r+0x4f6>
 80094ce:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 80094d2:	980d      	ldr	r0, [sp, #52]	; 0x34
 80094d4:	9909      	ldr	r1, [sp, #36]	; 0x24
 80094d6:	320c      	adds	r2, #12
 80094d8:	f004 f810 	bl	800d4fc <__sprint_r>
 80094dc:	2800      	cmp	r0, #0
 80094de:	f47f aa3d 	bne.w	800895c <_vfprintf_r+0x254>
 80094e2:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 80094e6:	4656      	mov	r6, sl
 80094e8:	f7ff bb74 	b.w	8008bd4 <_vfprintf_r+0x4cc>
 80094ec:	f8dd 6568 	ldr.w	r6, [sp, #1384]	; 0x568
 80094f0:	2e00      	cmp	r6, #0
 80094f2:	f340 8333 	ble.w	8009b5c <_vfprintf_r+0x1454>
 80094f6:	9e10      	ldr	r6, [sp, #64]	; 0x40
 80094f8:	9c19      	ldr	r4, [sp, #100]	; 0x64
 80094fa:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80094fc:	42a6      	cmp	r6, r4
 80094fe:	bfa8      	it	ge
 8009500:	4626      	movge	r6, r4
 8009502:	9910      	ldr	r1, [sp, #64]	; 0x40
 8009504:	2e00      	cmp	r6, #0
 8009506:	eb00 0b01 	add.w	fp, r0, r1
 800950a:	dd11      	ble.n	8009530 <_vfprintf_r+0xe28>
 800950c:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009510:	19ad      	adds	r5, r5, r6
 8009512:	f8c9 0000 	str.w	r0, [r9]
 8009516:	3401      	adds	r4, #1
 8009518:	f8c9 6004 	str.w	r6, [r9, #4]
 800951c:	2c07      	cmp	r4, #7
 800951e:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8009522:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8009526:	bfd8      	it	le
 8009528:	f109 0908 	addle.w	r9, r9, #8
 800952c:	f300 8465 	bgt.w	8009dfa <_vfprintf_r+0x16f2>
 8009530:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8009532:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
 8009536:	1b96      	subs	r6, r2, r6
 8009538:	2e00      	cmp	r6, #0
 800953a:	f340 840f 	ble.w	8009d5c <_vfprintf_r+0x1654>
 800953e:	2e10      	cmp	r6, #16
 8009540:	f340 8550 	ble.w	8009fe4 <_vfprintf_r+0x18dc>
 8009544:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009548:	4629      	mov	r1, r5
 800954a:	f8df 8248 	ldr.w	r8, [pc, #584]	; 8009794 <_vfprintf_r+0x108c>
 800954e:	2710      	movs	r7, #16
 8009550:	4622      	mov	r2, r4
 8009552:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8009554:	4644      	mov	r4, r8
 8009556:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
 800955a:	e003      	b.n	8009564 <_vfprintf_r+0xe5c>
 800955c:	3e10      	subs	r6, #16
 800955e:	2e10      	cmp	r6, #16
 8009560:	f340 8267 	ble.w	8009a32 <_vfprintf_r+0x132a>
 8009564:	3201      	adds	r2, #1
 8009566:	3110      	adds	r1, #16
 8009568:	2a07      	cmp	r2, #7
 800956a:	f8c9 4000 	str.w	r4, [r9]
 800956e:	f8c9 7004 	str.w	r7, [r9, #4]
 8009572:	f109 0908 	add.w	r9, r9, #8
 8009576:	f8cd 2550 	str.w	r2, [sp, #1360]	; 0x550
 800957a:	f109 0308 	add.w	r3, r9, #8
 800957e:	f8cd 1554 	str.w	r1, [sp, #1364]	; 0x554
 8009582:	ddeb      	ble.n	800955c <_vfprintf_r+0xe54>
 8009584:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8009588:	4640      	mov	r0, r8
 800958a:	4629      	mov	r1, r5
 800958c:	320c      	adds	r2, #12
 800958e:	f003 ffb5 	bl	800d4fc <__sprint_r>
 8009592:	46d1      	mov	r9, sl
 8009594:	f10a 0308 	add.w	r3, sl, #8
 8009598:	2800      	cmp	r0, #0
 800959a:	f47f a9df 	bne.w	800895c <_vfprintf_r+0x254>
 800959e:	f8dd 1554 	ldr.w	r1, [sp, #1364]	; 0x554
 80095a2:	f8dd 2550 	ldr.w	r2, [sp, #1360]	; 0x550
 80095a6:	e7d9      	b.n	800955c <_vfprintf_r+0xe54>
 80095a8:	9311      	str	r3, [sp, #68]	; 0x44
 80095aa:	f50d 63a8 	add.w	r3, sp, #1344	; 0x540
 80095ae:	330c      	adds	r3, #12
 80095b0:	9313      	str	r3, [sp, #76]	; 0x4c
 80095b2:	e44b      	b.n	8008e4c <_vfprintf_r+0x744>
 80095b4:	2c0a      	cmp	r4, #10
 80095b6:	f175 0100 	sbcs.w	r1, r5, #0
 80095ba:	f080 80b4 	bcs.w	8009726 <_vfprintf_r+0x101e>
 80095be:	f50d 63a8 	add.w	r3, sp, #1344	; 0x540
 80095c2:	3430      	adds	r4, #48	; 0x30
 80095c4:	2201      	movs	r2, #1
 80095c6:	330b      	adds	r3, #11
 80095c8:	9211      	str	r2, [sp, #68]	; 0x44
 80095ca:	f88d 454b 	strb.w	r4, [sp, #1355]	; 0x54b
 80095ce:	9313      	str	r3, [sp, #76]	; 0x4c
 80095d0:	e43c      	b.n	8008e4c <_vfprintf_r+0x744>
 80095d2:	f50d 6ba4 	add.w	fp, sp, #1312	; 0x520
 80095d6:	9918      	ldr	r1, [sp, #96]	; 0x60
 80095d8:	f10b 0b04 	add.w	fp, fp, #4
 80095dc:	f10b 0027 	add.w	r0, fp, #39	; 0x27
 80095e0:	f004 020f 	and.w	r2, r4, #15
 80095e4:	0923      	lsrs	r3, r4, #4
 80095e6:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 80095ea:	ea4f 1c15 	mov.w	ip, r5, lsr #4
 80095ee:	5c8a      	ldrb	r2, [r1, r2]
 80095f0:	461c      	mov	r4, r3
 80095f2:	4603      	mov	r3, r0
 80095f4:	4665      	mov	r5, ip
 80095f6:	3801      	subs	r0, #1
 80095f8:	701a      	strb	r2, [r3, #0]
 80095fa:	ea54 0205 	orrs.w	r2, r4, r5
 80095fe:	d1ef      	bne.n	80095e0 <_vfprintf_r+0xed8>
 8009600:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8009604:	9313      	str	r3, [sp, #76]	; 0x4c
 8009606:	ebc3 030b 	rsb	r3, r3, fp
 800960a:	9311      	str	r3, [sp, #68]	; 0x44
 800960c:	e41e      	b.n	8008e4c <_vfprintf_r+0x744>
 800960e:	9910      	ldr	r1, [sp, #64]	; 0x40
 8009610:	1e4f      	subs	r7, r1, #1
 8009612:	2f00      	cmp	r7, #0
 8009614:	bfdc      	itt	le
 8009616:	f106 0908 	addle.w	r9, r6, #8
 800961a:	46b3      	movle	fp, r6
 800961c:	f77f adcd 	ble.w	80091ba <_vfprintf_r+0xab2>
 8009620:	2f10      	cmp	r7, #16
 8009622:	bfd8      	it	le
 8009624:	f8df 816c 	ldrle.w	r8, [pc, #364]	; 8009794 <_vfprintf_r+0x108c>
 8009628:	dd4c      	ble.n	80096c4 <_vfprintf_r+0xfbc>
 800962a:	f8df 8168 	ldr.w	r8, [pc, #360]	; 8009794 <_vfprintf_r+0x108c>
 800962e:	4623      	mov	r3, r4
 8009630:	462a      	mov	r2, r5
 8009632:	f04f 0910 	mov.w	r9, #16
 8009636:	4644      	mov	r4, r8
 8009638:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800963a:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
 800963e:	e002      	b.n	8009646 <_vfprintf_r+0xf3e>
 8009640:	3f10      	subs	r7, #16
 8009642:	2f10      	cmp	r7, #16
 8009644:	dd3b      	ble.n	80096be <_vfprintf_r+0xfb6>
 8009646:	3301      	adds	r3, #1
 8009648:	6034      	str	r4, [r6, #0]
 800964a:	f8c6 9004 	str.w	r9, [r6, #4]
 800964e:	3210      	adds	r2, #16
 8009650:	3608      	adds	r6, #8
 8009652:	2b07      	cmp	r3, #7
 8009654:	f8cd 3550 	str.w	r3, [sp, #1360]	; 0x550
 8009658:	f106 0b08 	add.w	fp, r6, #8
 800965c:	f8cd 2554 	str.w	r2, [sp, #1364]	; 0x554
 8009660:	ddee      	ble.n	8009640 <_vfprintf_r+0xf38>
 8009662:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8009666:	4640      	mov	r0, r8
 8009668:	4629      	mov	r1, r5
 800966a:	320c      	adds	r2, #12
 800966c:	f003 ff46 	bl	800d4fc <__sprint_r>
 8009670:	f10a 0b08 	add.w	fp, sl, #8
 8009674:	4656      	mov	r6, sl
 8009676:	2800      	cmp	r0, #0
 8009678:	f47f a970 	bne.w	800895c <_vfprintf_r+0x254>
 800967c:	f8dd 2554 	ldr.w	r2, [sp, #1364]	; 0x554
 8009680:	f8dd 3550 	ldr.w	r3, [sp, #1360]	; 0x550
 8009684:	e7dc      	b.n	8009640 <_vfprintf_r+0xf38>
 8009686:	2302      	movs	r3, #2
 8009688:	f7ff bba6 	b.w	8008dd8 <_vfprintf_r+0x6d0>
 800968c:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800968e:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8009690:	681a      	ldr	r2, [r3, #0]
 8009692:	2301      	movs	r3, #1
 8009694:	e4c5      	b.n	8009022 <_vfprintf_r+0x91a>
 8009696:	46a0      	mov	r8, r4
 8009698:	4614      	mov	r4, r2
 800969a:	3401      	adds	r4, #1
 800969c:	f8c3 8000 	str.w	r8, [r3]
 80096a0:	2c07      	cmp	r4, #7
 80096a2:	605e      	str	r6, [r3, #4]
 80096a4:	4435      	add	r5, r6
 80096a6:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 80096aa:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 80096ae:	f77f ab0c 	ble.w	8008cca <_vfprintf_r+0x5c2>
 80096b2:	e592      	b.n	80091da <_vfprintf_r+0xad2>
 80096b4:	980d      	ldr	r0, [sp, #52]	; 0x34
 80096b6:	6880      	ldr	r0, [r0, #8]
 80096b8:	9009      	str	r0, [sp, #36]	; 0x24
 80096ba:	f7ff b855 	b.w	8008768 <_vfprintf_r+0x60>
 80096be:	46a0      	mov	r8, r4
 80096c0:	4615      	mov	r5, r2
 80096c2:	461c      	mov	r4, r3
 80096c4:	3401      	adds	r4, #1
 80096c6:	f8c6 8000 	str.w	r8, [r6]
 80096ca:	2c07      	cmp	r4, #7
 80096cc:	6077      	str	r7, [r6, #4]
 80096ce:	443d      	add	r5, r7
 80096d0:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 80096d4:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 80096d8:	f77f ad6d 	ble.w	80091b6 <_vfprintf_r+0xaae>
 80096dc:	e6b5      	b.n	800944a <_vfprintf_r+0xd42>
 80096de:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 80096e2:	980d      	ldr	r0, [sp, #52]	; 0x34
 80096e4:	9909      	ldr	r1, [sp, #36]	; 0x24
 80096e6:	320c      	adds	r2, #12
 80096e8:	f003 ff08 	bl	800d4fc <__sprint_r>
 80096ec:	2800      	cmp	r0, #0
 80096ee:	f47f a935 	bne.w	800895c <_vfprintf_r+0x254>
 80096f2:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 80096f6:	f10a 0b08 	add.w	fp, sl, #8
 80096fa:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 80096fe:	4656      	mov	r6, sl
 8009700:	e68b      	b.n	800941a <_vfprintf_r+0xd12>
 8009702:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8009706:	980d      	ldr	r0, [sp, #52]	; 0x34
 8009708:	9909      	ldr	r1, [sp, #36]	; 0x24
 800970a:	320c      	adds	r2, #12
 800970c:	f003 fef6 	bl	800d4fc <__sprint_r>
 8009710:	2800      	cmp	r0, #0
 8009712:	f47f a923 	bne.w	800895c <_vfprintf_r+0x254>
 8009716:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 800971a:	f10a 0608 	add.w	r6, sl, #8
 800971e:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009722:	46d1      	mov	r9, sl
 8009724:	e667      	b.n	80093f6 <_vfprintf_r+0xcee>
 8009726:	f50d 6ba4 	add.w	fp, sp, #1312	; 0x520
 800972a:	46b1      	mov	r9, r6
 800972c:	f10b 0b04 	add.w	fp, fp, #4
 8009730:	f10b 0827 	add.w	r8, fp, #39	; 0x27
 8009734:	4620      	mov	r0, r4
 8009736:	4629      	mov	r1, r5
 8009738:	220a      	movs	r2, #10
 800973a:	2300      	movs	r3, #0
 800973c:	f006 f850 	bl	800f7e0 <__aeabi_uldivmod>
 8009740:	4646      	mov	r6, r8
 8009742:	4620      	mov	r0, r4
 8009744:	4629      	mov	r1, r5
 8009746:	2300      	movs	r3, #0
 8009748:	f108 38ff 	add.w	r8, r8, #4294967295
 800974c:	f102 0430 	add.w	r4, r2, #48	; 0x30
 8009750:	220a      	movs	r2, #10
 8009752:	7034      	strb	r4, [r6, #0]
 8009754:	f006 f844 	bl	800f7e0 <__aeabi_uldivmod>
 8009758:	4604      	mov	r4, r0
 800975a:	460d      	mov	r5, r1
 800975c:	ea54 0005 	orrs.w	r0, r4, r5
 8009760:	d1e8      	bne.n	8009734 <_vfprintf_r+0x102c>
 8009762:	9613      	str	r6, [sp, #76]	; 0x4c
 8009764:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8009768:	9913      	ldr	r1, [sp, #76]	; 0x4c
 800976a:	464e      	mov	r6, r9
 800976c:	ebc1 010b 	rsb	r1, r1, fp
 8009770:	9111      	str	r1, [sp, #68]	; 0x44
 8009772:	f7ff bb6b 	b.w	8008e4c <_vfprintf_r+0x744>
 8009776:	2a30      	cmp	r2, #48	; 0x30
 8009778:	f000 835e 	beq.w	8009e38 <_vfprintf_r+0x1730>
 800977c:	9313      	str	r3, [sp, #76]	; 0x4c
 800977e:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8009782:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8009784:	ebc3 040b 	rsb	r4, r3, fp
 8009788:	2330      	movs	r3, #48	; 0x30
 800978a:	9411      	str	r4, [sp, #68]	; 0x44
 800978c:	7003      	strb	r3, [r0, #0]
 800978e:	f7ff bb5d 	b.w	8008e4c <_vfprintf_r+0x744>
 8009792:	bf00      	nop
 8009794:	080101b0 	.word	0x080101b0
 8009798:	4264      	negs	r4, r4
 800979a:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 800979e:	232d      	movs	r3, #45	; 0x2d
 80097a0:	ea54 0005 	orrs.w	r0, r4, r5
 80097a4:	f88d 356f 	strb.w	r3, [sp, #1391]	; 0x56f
 80097a8:	bf0c      	ite	eq
 80097aa:	2200      	moveq	r2, #0
 80097ac:	2201      	movne	r2, #1
 80097ae:	2301      	movs	r3, #1
 80097b0:	f7ff bb15 	b.w	8008dde <_vfprintf_r+0x6d6>
 80097b4:	7813      	ldrb	r3, [r2, #0]
 80097b6:	f7ff b852 	b.w	800885e <_vfprintf_r+0x156>
 80097ba:	981a      	ldr	r0, [sp, #104]	; 0x68
 80097bc:	991b      	ldr	r1, [sp, #108]	; 0x6c
 80097be:	f002 ffe7 	bl	800c790 <__fpclassifyd>
 80097c2:	2800      	cmp	r0, #0
 80097c4:	f000 8261 	beq.w	8009c8a <_vfprintf_r+0x1582>
 80097c8:	f1b7 3fff 	cmp.w	r7, #4294967295
 80097cc:	f000 83e1 	beq.w	8009f92 <_vfprintf_r+0x188a>
 80097d0:	9c16      	ldr	r4, [sp, #88]	; 0x58
 80097d2:	f1a4 0e67 	sub.w	lr, r4, #103	; 0x67
 80097d6:	f1de 0300 	rsbs	r3, lr, #0
 80097da:	eb43 030e 	adc.w	r3, r3, lr
 80097de:	2c47      	cmp	r4, #71	; 0x47
 80097e0:	bf08      	it	eq
 80097e2:	f043 0301 	orreq.w	r3, r3, #1
 80097e6:	b113      	cbz	r3, 80097ee <_vfprintf_r+0x10e6>
 80097e8:	2f00      	cmp	r7, #0
 80097ea:	bf08      	it	eq
 80097ec:	2701      	moveq	r7, #1
 80097ee:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80097f0:	9807      	ldr	r0, [sp, #28]
 80097f2:	2b00      	cmp	r3, #0
 80097f4:	f440 7080 	orr.w	r0, r0, #256	; 0x100
 80097f8:	9007      	str	r0, [sp, #28]
 80097fa:	f2c0 83c5 	blt.w	8009f88 <_vfprintf_r+0x1880>
 80097fe:	f8dd 906c 	ldr.w	r9, [sp, #108]	; 0x6c
 8009802:	2200      	movs	r2, #0
 8009804:	9214      	str	r2, [sp, #80]	; 0x50
 8009806:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8009808:	f1a3 0466 	sub.w	r4, r3, #102	; 0x66
 800980c:	f1d4 0b00 	rsbs	fp, r4, #0
 8009810:	eb4b 0b04 	adc.w	fp, fp, r4
 8009814:	2b46      	cmp	r3, #70	; 0x46
 8009816:	bf08      	it	eq
 8009818:	f04b 0b01 	orreq.w	fp, fp, #1
 800981c:	f1bb 0f00 	cmp.w	fp, #0
 8009820:	f040 8357 	bne.w	8009ed2 <_vfprintf_r+0x17ca>
 8009824:	2b45      	cmp	r3, #69	; 0x45
 8009826:	d002      	beq.n	800982e <_vfprintf_r+0x1126>
 8009828:	2b65      	cmp	r3, #101	; 0x65
 800982a:	f040 83b4 	bne.w	8009f96 <_vfprintf_r+0x188e>
 800982e:	f107 0801 	add.w	r8, r7, #1
 8009832:	2302      	movs	r3, #2
 8009834:	9c1a      	ldr	r4, [sp, #104]	; 0x68
 8009836:	f50d 61ad 	add.w	r1, sp, #1384	; 0x568
 800983a:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
 800983e:	9300      	str	r3, [sp, #0]
 8009840:	940a      	str	r4, [sp, #40]	; 0x28
 8009842:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 8009846:	9102      	str	r1, [sp, #8]
 8009848:	f50d 61ac 	add.w	r1, sp, #1376	; 0x560
 800984c:	980d      	ldr	r0, [sp, #52]	; 0x34
 800984e:	3104      	adds	r1, #4
 8009850:	f8cd 8004 	str.w	r8, [sp, #4]
 8009854:	9103      	str	r1, [sp, #12]
 8009856:	f50d 61ac 	add.w	r1, sp, #1376	; 0x560
 800985a:	9104      	str	r1, [sp, #16]
 800985c:	f000 fd6a 	bl	800a334 <_dtoa_r>
 8009860:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8009862:	f1b2 0367 	subs.w	r3, r2, #103	; 0x67
 8009866:	bf18      	it	ne
 8009868:	2301      	movne	r3, #1
 800986a:	2a47      	cmp	r2, #71	; 0x47
 800986c:	bf0c      	ite	eq
 800986e:	2300      	moveq	r3, #0
 8009870:	f003 0301 	andne.w	r3, r3, #1
 8009874:	9013      	str	r0, [sp, #76]	; 0x4c
 8009876:	b923      	cbnz	r3, 8009882 <_vfprintf_r+0x117a>
 8009878:	9b07      	ldr	r3, [sp, #28]
 800987a:	f013 0f01 	tst.w	r3, #1
 800987e:	f000 83a6 	beq.w	8009fce <_vfprintf_r+0x18c6>
 8009882:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8009884:	eb00 0408 	add.w	r4, r0, r8
 8009888:	f1bb 0f00 	cmp.w	fp, #0
 800988c:	d006      	beq.n	800989c <_vfprintf_r+0x1194>
 800988e:	7803      	ldrb	r3, [r0, #0]
 8009890:	2b30      	cmp	r3, #48	; 0x30
 8009892:	f000 83b7 	beq.w	800a004 <_vfprintf_r+0x18fc>
 8009896:	f8dd 3568 	ldr.w	r3, [sp, #1384]	; 0x568
 800989a:	18e4      	adds	r4, r4, r3
 800989c:	981a      	ldr	r0, [sp, #104]	; 0x68
 800989e:	2200      	movs	r2, #0
 80098a0:	2300      	movs	r3, #0
 80098a2:	4649      	mov	r1, r9
 80098a4:	f005 ff42 	bl	800f72c <__aeabi_dcmpeq>
 80098a8:	2800      	cmp	r0, #0
 80098aa:	f000 833d 	beq.w	8009f28 <_vfprintf_r+0x1820>
 80098ae:	4623      	mov	r3, r4
 80098b0:	f8cd 4560 	str.w	r4, [sp, #1376]	; 0x560
 80098b4:	9916      	ldr	r1, [sp, #88]	; 0x58
 80098b6:	9c13      	ldr	r4, [sp, #76]	; 0x4c
 80098b8:	f1a1 0067 	sub.w	r0, r1, #103	; 0x67
 80098bc:	4242      	negs	r2, r0
 80098be:	ebc4 0303 	rsb	r3, r4, r3
 80098c2:	eb42 0200 	adc.w	r2, r2, r0
 80098c6:	9310      	str	r3, [sp, #64]	; 0x40
 80098c8:	2947      	cmp	r1, #71	; 0x47
 80098ca:	bf14      	ite	ne
 80098cc:	4613      	movne	r3, r2
 80098ce:	f042 0301 	orreq.w	r3, r2, #1
 80098d2:	2b00      	cmp	r3, #0
 80098d4:	f000 830b 	beq.w	8009eee <_vfprintf_r+0x17e6>
 80098d8:	f8dd 3568 	ldr.w	r3, [sp, #1384]	; 0x568
 80098dc:	f113 0f03 	cmn.w	r3, #3
 80098e0:	9311      	str	r3, [sp, #68]	; 0x44
 80098e2:	db02      	blt.n	80098ea <_vfprintf_r+0x11e2>
 80098e4:	429f      	cmp	r7, r3
 80098e6:	f280 8334 	bge.w	8009f52 <_vfprintf_r+0x184a>
 80098ea:	9816      	ldr	r0, [sp, #88]	; 0x58
 80098ec:	3802      	subs	r0, #2
 80098ee:	9016      	str	r0, [sp, #88]	; 0x58
 80098f0:	3b01      	subs	r3, #1
 80098f2:	9a16      	ldr	r2, [sp, #88]	; 0x58
 80098f4:	2b00      	cmp	r3, #0
 80098f6:	f8cd 3568 	str.w	r3, [sp, #1384]	; 0x568
 80098fa:	f88d 2558 	strb.w	r2, [sp, #1368]	; 0x558
 80098fe:	f2c0 838f 	blt.w	800a020 <_vfprintf_r+0x1918>
 8009902:	222b      	movs	r2, #43	; 0x2b
 8009904:	f88d 2559 	strb.w	r2, [sp, #1369]	; 0x559
 8009908:	2b09      	cmp	r3, #9
 800990a:	f340 8347 	ble.w	8009f9c <_vfprintf_r+0x1894>
 800990e:	f246 6467 	movw	r4, #26215	; 0x6667
 8009912:	f50d 6090 	add.w	r0, sp, #1152	; 0x480
 8009916:	3002      	adds	r0, #2
 8009918:	f2c6 6466 	movt	r4, #26214	; 0x6666
 800991c:	fb84 2103 	smull	r2, r1, r4, r3
 8009920:	17da      	asrs	r2, r3, #31
 8009922:	4605      	mov	r5, r0
 8009924:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
 8009928:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 800992c:	eba3 0141 	sub.w	r1, r3, r1, lsl #1
 8009930:	4613      	mov	r3, r2
 8009932:	3130      	adds	r1, #48	; 0x30
 8009934:	2a09      	cmp	r2, #9
 8009936:	f800 1901 	strb.w	r1, [r0], #-1
 800993a:	dcef      	bgt.n	800991c <_vfprintf_r+0x1214>
 800993c:	3330      	adds	r3, #48	; 0x30
 800993e:	f805 3c01 	strb.w	r3, [r5, #-1]
 8009942:	f50d 6390 	add.w	r3, sp, #1152	; 0x480
 8009946:	1e6a      	subs	r2, r5, #1
 8009948:	3303      	adds	r3, #3
 800994a:	429a      	cmp	r2, r3
 800994c:	f080 8387 	bcs.w	800a05e <_vfprintf_r+0x1956>
 8009950:	f50d 63aa 	add.w	r3, sp, #1360	; 0x550
 8009954:	330a      	adds	r3, #10
 8009956:	f812 1b01 	ldrb.w	r1, [r2], #1
 800995a:	f803 1b01 	strb.w	r1, [r3], #1
 800995e:	4619      	mov	r1, r3
 8009960:	9c06      	ldr	r4, [sp, #24]
 8009962:	4294      	cmp	r4, r2
 8009964:	d8f7      	bhi.n	8009956 <_vfprintf_r+0x124e>
 8009966:	f50d 63ab 	add.w	r3, sp, #1368	; 0x558
 800996a:	9810      	ldr	r0, [sp, #64]	; 0x40
 800996c:	1acb      	subs	r3, r1, r3
 800996e:	9910      	ldr	r1, [sp, #64]	; 0x40
 8009970:	1818      	adds	r0, r3, r0
 8009972:	931d      	str	r3, [sp, #116]	; 0x74
 8009974:	2901      	cmp	r1, #1
 8009976:	9011      	str	r0, [sp, #68]	; 0x44
 8009978:	f340 833b 	ble.w	8009ff2 <_vfprintf_r+0x18ea>
 800997c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800997e:	2400      	movs	r4, #0
 8009980:	9419      	str	r4, [sp, #100]	; 0x64
 8009982:	3301      	adds	r3, #1
 8009984:	9311      	str	r3, [sp, #68]	; 0x44
 8009986:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8009988:	2b00      	cmp	r3, #0
 800998a:	f040 82a5 	bne.w	8009ed8 <_vfprintf_r+0x17d0>
 800998e:	9c11      	ldr	r4, [sp, #68]	; 0x44
 8009990:	f89d 256f 	ldrb.w	r2, [sp, #1391]	; 0x56f
 8009994:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
 8009998:	940a      	str	r4, [sp, #40]	; 0x28
 800999a:	f7ff b8a6 	b.w	8008aea <_vfprintf_r+0x3e2>
 800999e:	9b07      	ldr	r3, [sp, #28]
 80099a0:	f013 0f40 	tst.w	r3, #64	; 0x40
 80099a4:	f000 816a 	beq.w	8009c7c <_vfprintf_r+0x1574>
 80099a8:	9812      	ldr	r0, [sp, #72]	; 0x48
 80099aa:	2500      	movs	r5, #0
 80099ac:	8804      	ldrh	r4, [r0, #0]
 80099ae:	3004      	adds	r0, #4
 80099b0:	9012      	str	r0, [sp, #72]	; 0x48
 80099b2:	f7ff ba8c 	b.w	8008ece <_vfprintf_r+0x7c6>
 80099b6:	9b07      	ldr	r3, [sp, #28]
 80099b8:	f013 0f40 	tst.w	r3, #64	; 0x40
 80099bc:	f000 8157 	beq.w	8009c6e <_vfprintf_r+0x1566>
 80099c0:	9812      	ldr	r0, [sp, #72]	; 0x48
 80099c2:	f9b0 4000 	ldrsh.w	r4, [r0]
 80099c6:	3004      	adds	r0, #4
 80099c8:	9012      	str	r0, [sp, #72]	; 0x48
 80099ca:	17e5      	asrs	r5, r4, #31
 80099cc:	f7ff babf 	b.w	8008f4e <_vfprintf_r+0x846>
 80099d0:	9807      	ldr	r0, [sp, #28]
 80099d2:	f010 0340 	ands.w	r3, r0, #64	; 0x40
 80099d6:	f000 813f 	beq.w	8009c58 <_vfprintf_r+0x1550>
 80099da:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80099dc:	2500      	movs	r5, #0
 80099de:	9c12      	ldr	r4, [sp, #72]	; 0x48
 80099e0:	8819      	ldrh	r1, [r3, #0]
 80099e2:	3404      	adds	r4, #4
 80099e4:	4613      	mov	r3, r2
 80099e6:	9412      	str	r4, [sp, #72]	; 0x48
 80099e8:	1e0a      	subs	r2, r1, #0
 80099ea:	460c      	mov	r4, r1
 80099ec:	bf18      	it	ne
 80099ee:	2201      	movne	r2, #1
 80099f0:	f7ff b9f2 	b.w	8008dd8 <_vfprintf_r+0x6d0>
 80099f4:	9907      	ldr	r1, [sp, #28]
 80099f6:	f011 0f10 	tst.w	r1, #16
 80099fa:	f040 8125 	bne.w	8009c48 <_vfprintf_r+0x1540>
 80099fe:	9807      	ldr	r0, [sp, #28]
 8009a00:	f010 0f40 	tst.w	r0, #64	; 0x40
 8009a04:	f000 8288 	beq.w	8009f18 <_vfprintf_r+0x1810>
 8009a08:	9912      	ldr	r1, [sp, #72]	; 0x48
 8009a0a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8009a0c:	680b      	ldr	r3, [r1, #0]
 8009a0e:	3104      	adds	r1, #4
 8009a10:	9112      	str	r1, [sp, #72]	; 0x48
 8009a12:	801a      	strh	r2, [r3, #0]
 8009a14:	f7fe bedc 	b.w	80087d0 <_vfprintf_r+0xc8>
 8009a18:	9912      	ldr	r1, [sp, #72]	; 0x48
 8009a1a:	1dcb      	adds	r3, r1, #7
 8009a1c:	f023 0307 	bic.w	r3, r3, #7
 8009a20:	f103 0208 	add.w	r2, r3, #8
 8009a24:	9212      	str	r2, [sp, #72]	; 0x48
 8009a26:	681c      	ldr	r4, [r3, #0]
 8009a28:	941a      	str	r4, [sp, #104]	; 0x68
 8009a2a:	685b      	ldr	r3, [r3, #4]
 8009a2c:	931b      	str	r3, [sp, #108]	; 0x6c
 8009a2e:	f7ff b832 	b.w	8008a96 <_vfprintf_r+0x38e>
 8009a32:	46a0      	mov	r8, r4
 8009a34:	460d      	mov	r5, r1
 8009a36:	4614      	mov	r4, r2
 8009a38:	3401      	adds	r4, #1
 8009a3a:	f8c9 8000 	str.w	r8, [r9]
 8009a3e:	2c07      	cmp	r4, #7
 8009a40:	f8c9 6004 	str.w	r6, [r9, #4]
 8009a44:	4435      	add	r5, r6
 8009a46:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8009a4a:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8009a4e:	f300 821f 	bgt.w	8009e90 <_vfprintf_r+0x1788>
 8009a52:	f8dd 2568 	ldr.w	r2, [sp, #1384]	; 0x568
 8009a56:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8009a58:	42a2      	cmp	r2, r4
 8009a5a:	db54      	blt.n	8009b06 <_vfprintf_r+0x13fe>
 8009a5c:	9807      	ldr	r0, [sp, #28]
 8009a5e:	f010 0f01 	tst.w	r0, #1
 8009a62:	d150      	bne.n	8009b06 <_vfprintf_r+0x13fe>
 8009a64:	9c13      	ldr	r4, [sp, #76]	; 0x4c
 8009a66:	9819      	ldr	r0, [sp, #100]	; 0x64
 8009a68:	1821      	adds	r1, r4, r0
 8009a6a:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8009a6c:	ebc1 070b 	rsb	r7, r1, fp
 8009a70:	1aa2      	subs	r2, r4, r2
 8009a72:	42ba      	cmp	r2, r7
 8009a74:	bfb8      	it	lt
 8009a76:	4617      	movlt	r7, r2
 8009a78:	2f00      	cmp	r7, #0
 8009a7a:	dd0d      	ble.n	8009a98 <_vfprintf_r+0x1390>
 8009a7c:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009a80:	19ed      	adds	r5, r5, r7
 8009a82:	6019      	str	r1, [r3, #0]
 8009a84:	3401      	adds	r4, #1
 8009a86:	605f      	str	r7, [r3, #4]
 8009a88:	2c07      	cmp	r4, #7
 8009a8a:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8009a8e:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8009a92:	f300 81d9 	bgt.w	8009e48 <_vfprintf_r+0x1740>
 8009a96:	3308      	adds	r3, #8
 8009a98:	ea27 76e7 	bic.w	r6, r7, r7, asr #31
 8009a9c:	1b96      	subs	r6, r2, r6
 8009a9e:	2e00      	cmp	r6, #0
 8009aa0:	dd42      	ble.n	8009b28 <_vfprintf_r+0x1420>
 8009aa2:	2e10      	cmp	r6, #16
 8009aa4:	f340 8296 	ble.w	8009fd4 <_vfprintf_r+0x18cc>
 8009aa8:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009aac:	2710      	movs	r7, #16
 8009aae:	f8df 85b8 	ldr.w	r8, [pc, #1464]	; 800a068 <_vfprintf_r+0x1960>
 8009ab2:	4622      	mov	r2, r4
 8009ab4:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
 8009ab8:	4644      	mov	r4, r8
 8009aba:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
 8009abe:	e003      	b.n	8009ac8 <_vfprintf_r+0x13c0>
 8009ac0:	3e10      	subs	r6, #16
 8009ac2:	2e10      	cmp	r6, #16
 8009ac4:	f77f ade7 	ble.w	8009696 <_vfprintf_r+0xf8e>
 8009ac8:	3201      	adds	r2, #1
 8009aca:	601c      	str	r4, [r3, #0]
 8009acc:	605f      	str	r7, [r3, #4]
 8009ace:	3510      	adds	r5, #16
 8009ad0:	3308      	adds	r3, #8
 8009ad2:	2a07      	cmp	r2, #7
 8009ad4:	f8cd 2550 	str.w	r2, [sp, #1360]	; 0x550
 8009ad8:	f103 0908 	add.w	r9, r3, #8
 8009adc:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8009ae0:	ddee      	ble.n	8009ac0 <_vfprintf_r+0x13b8>
 8009ae2:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8009ae6:	4640      	mov	r0, r8
 8009ae8:	4659      	mov	r1, fp
 8009aea:	320c      	adds	r2, #12
 8009aec:	f003 fd06 	bl	800d4fc <__sprint_r>
 8009af0:	f10a 0908 	add.w	r9, sl, #8
 8009af4:	4653      	mov	r3, sl
 8009af6:	2800      	cmp	r0, #0
 8009af8:	f47e af30 	bne.w	800895c <_vfprintf_r+0x254>
 8009afc:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8009b00:	f8dd 2550 	ldr.w	r2, [sp, #1360]	; 0x550
 8009b04:	e7dc      	b.n	8009ac0 <_vfprintf_r+0x13b8>
 8009b06:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009b0a:	991c      	ldr	r1, [sp, #112]	; 0x70
 8009b0c:	3401      	adds	r4, #1
 8009b0e:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8009b10:	2c07      	cmp	r4, #7
 8009b12:	440d      	add	r5, r1
 8009b14:	6059      	str	r1, [r3, #4]
 8009b16:	6018      	str	r0, [r3, #0]
 8009b18:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8009b1c:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8009b20:	f300 817a 	bgt.w	8009e18 <_vfprintf_r+0x1710>
 8009b24:	3308      	adds	r3, #8
 8009b26:	e79d      	b.n	8009a64 <_vfprintf_r+0x135c>
 8009b28:	4699      	mov	r9, r3
 8009b2a:	f7ff b8ce 	b.w	8008cca <_vfprintf_r+0x5c2>
 8009b2e:	f106 0908 	add.w	r9, r6, #8
 8009b32:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009b36:	f8df 8530 	ldr.w	r8, [pc, #1328]	; 800a068 <_vfprintf_r+0x1960>
 8009b3a:	f7ff b8a2 	b.w	8008c82 <_vfprintf_r+0x57a>
 8009b3e:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8009b42:	980d      	ldr	r0, [sp, #52]	; 0x34
 8009b44:	9909      	ldr	r1, [sp, #36]	; 0x24
 8009b46:	320c      	adds	r2, #12
 8009b48:	f003 fcd8 	bl	800d4fc <__sprint_r>
 8009b4c:	2800      	cmp	r0, #0
 8009b4e:	f47e af05 	bne.w	800895c <_vfprintf_r+0x254>
 8009b52:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8009b56:	46d1      	mov	r9, sl
 8009b58:	f7ff bb71 	b.w	800923e <_vfprintf_r+0xb36>
 8009b5c:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009b60:	f240 43b4 	movw	r3, #1204	; 0x4b4
 8009b64:	f6c0 0301 	movt	r3, #2049	; 0x801
 8009b68:	f8c9 3000 	str.w	r3, [r9]
 8009b6c:	3401      	adds	r4, #1
 8009b6e:	2301      	movs	r3, #1
 8009b70:	2c07      	cmp	r4, #7
 8009b72:	f8c9 3004 	str.w	r3, [r9, #4]
 8009b76:	441d      	add	r5, r3
 8009b78:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8009b7c:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8009b80:	bfd8      	it	le
 8009b82:	f109 0908 	addle.w	r9, r9, #8
 8009b86:	f300 80a0 	bgt.w	8009cca <_vfprintf_r+0x15c2>
 8009b8a:	b936      	cbnz	r6, 8009b9a <_vfprintf_r+0x1492>
 8009b8c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8009b8e:	b923      	cbnz	r3, 8009b9a <_vfprintf_r+0x1492>
 8009b90:	9c07      	ldr	r4, [sp, #28]
 8009b92:	f014 0f01 	tst.w	r4, #1
 8009b96:	f43f a898 	beq.w	8008cca <_vfprintf_r+0x5c2>
 8009b9a:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009b9e:	981c      	ldr	r0, [sp, #112]	; 0x70
 8009ba0:	3401      	adds	r4, #1
 8009ba2:	9917      	ldr	r1, [sp, #92]	; 0x5c
 8009ba4:	2c07      	cmp	r4, #7
 8009ba6:	4405      	add	r5, r0
 8009ba8:	f8c9 0004 	str.w	r0, [r9, #4]
 8009bac:	f8c9 1000 	str.w	r1, [r9]
 8009bb0:	bfd8      	it	le
 8009bb2:	f109 0908 	addle.w	r9, r9, #8
 8009bb6:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8009bba:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8009bbe:	f300 80ac 	bgt.w	8009d1a <_vfprintf_r+0x1612>
 8009bc2:	4276      	negs	r6, r6
 8009bc4:	2e00      	cmp	r6, #0
 8009bc6:	f340 80eb 	ble.w	8009da0 <_vfprintf_r+0x1698>
 8009bca:	2e10      	cmp	r6, #16
 8009bcc:	bfd8      	it	le
 8009bce:	f8df 8498 	ldrle.w	r8, [pc, #1176]	; 800a068 <_vfprintf_r+0x1960>
 8009bd2:	f340 80c7 	ble.w	8009d64 <_vfprintf_r+0x165c>
 8009bd6:	f8df 8490 	ldr.w	r8, [pc, #1168]	; 800a068 <_vfprintf_r+0x1960>
 8009bda:	4623      	mov	r3, r4
 8009bdc:	2710      	movs	r7, #16
 8009bde:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
 8009be2:	4644      	mov	r4, r8
 8009be4:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
 8009be8:	e003      	b.n	8009bf2 <_vfprintf_r+0x14ea>
 8009bea:	3e10      	subs	r6, #16
 8009bec:	2e10      	cmp	r6, #16
 8009bee:	f340 80b7 	ble.w	8009d60 <_vfprintf_r+0x1658>
 8009bf2:	3301      	adds	r3, #1
 8009bf4:	3510      	adds	r5, #16
 8009bf6:	2b07      	cmp	r3, #7
 8009bf8:	f8c9 4000 	str.w	r4, [r9]
 8009bfc:	f8c9 7004 	str.w	r7, [r9, #4]
 8009c00:	f109 0908 	add.w	r9, r9, #8
 8009c04:	f8cd 3550 	str.w	r3, [sp, #1360]	; 0x550
 8009c08:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8009c0c:	dded      	ble.n	8009bea <_vfprintf_r+0x14e2>
 8009c0e:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8009c12:	4640      	mov	r0, r8
 8009c14:	4659      	mov	r1, fp
 8009c16:	320c      	adds	r2, #12
 8009c18:	f003 fc70 	bl	800d4fc <__sprint_r>
 8009c1c:	46d1      	mov	r9, sl
 8009c1e:	2800      	cmp	r0, #0
 8009c20:	f47e ae9c 	bne.w	800895c <_vfprintf_r+0x254>
 8009c24:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8009c28:	f8dd 3550 	ldr.w	r3, [sp, #1360]	; 0x550
 8009c2c:	e7dd      	b.n	8009bea <_vfprintf_r+0x14e2>
 8009c2e:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8009c30:	2200      	movs	r2, #0
 8009c32:	9412      	str	r4, [sp, #72]	; 0x48
 8009c34:	2400      	movs	r4, #0
 8009c36:	9214      	str	r2, [sp, #80]	; 0x50
 8009c38:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8009c3c:	f89d 256f 	ldrb.w	r2, [sp, #1391]	; 0x56f
 8009c40:	930a      	str	r3, [sp, #40]	; 0x28
 8009c42:	9419      	str	r4, [sp, #100]	; 0x64
 8009c44:	f7fe bf51 	b.w	8008aea <_vfprintf_r+0x3e2>
 8009c48:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8009c4a:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 8009c4c:	6813      	ldr	r3, [r2, #0]
 8009c4e:	3204      	adds	r2, #4
 8009c50:	9212      	str	r2, [sp, #72]	; 0x48
 8009c52:	601c      	str	r4, [r3, #0]
 8009c54:	f7fe bdbc 	b.w	80087d0 <_vfprintf_r+0xc8>
 8009c58:	9812      	ldr	r0, [sp, #72]	; 0x48
 8009c5a:	2500      	movs	r5, #0
 8009c5c:	6802      	ldr	r2, [r0, #0]
 8009c5e:	3004      	adds	r0, #4
 8009c60:	9012      	str	r0, [sp, #72]	; 0x48
 8009c62:	4614      	mov	r4, r2
 8009c64:	3a00      	subs	r2, #0
 8009c66:	bf18      	it	ne
 8009c68:	2201      	movne	r2, #1
 8009c6a:	f7ff b8b5 	b.w	8008dd8 <_vfprintf_r+0x6d0>
 8009c6e:	9912      	ldr	r1, [sp, #72]	; 0x48
 8009c70:	680c      	ldr	r4, [r1, #0]
 8009c72:	3104      	adds	r1, #4
 8009c74:	9112      	str	r1, [sp, #72]	; 0x48
 8009c76:	17e5      	asrs	r5, r4, #31
 8009c78:	f7ff b969 	b.w	8008f4e <_vfprintf_r+0x846>
 8009c7c:	9912      	ldr	r1, [sp, #72]	; 0x48
 8009c7e:	2500      	movs	r5, #0
 8009c80:	680c      	ldr	r4, [r1, #0]
 8009c82:	3104      	adds	r1, #4
 8009c84:	9112      	str	r1, [sp, #72]	; 0x48
 8009c86:	f7ff b922 	b.w	8008ece <_vfprintf_r+0x7c6>
 8009c8a:	9014      	str	r0, [sp, #80]	; 0x50
 8009c8c:	f240 4380 	movw	r3, #1152	; 0x480
 8009c90:	f240 427c 	movw	r2, #1148	; 0x47c
 8009c94:	9816      	ldr	r0, [sp, #88]	; 0x58
 8009c96:	f6c0 0201 	movt	r2, #2049	; 0x801
 8009c9a:	f6c0 0301 	movt	r3, #2049	; 0x801
 8009c9e:	2847      	cmp	r0, #71	; 0x47
 8009ca0:	bfd8      	it	le
 8009ca2:	4613      	movle	r3, r2
 8009ca4:	9313      	str	r3, [sp, #76]	; 0x4c
 8009ca6:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8009ca8:	2403      	movs	r4, #3
 8009caa:	9907      	ldr	r1, [sp, #28]
 8009cac:	940a      	str	r4, [sp, #40]	; 0x28
 8009cae:	f021 0180 	bic.w	r1, r1, #128	; 0x80
 8009cb2:	f89d 256f 	ldrb.w	r2, [sp, #1391]	; 0x56f
 8009cb6:	9107      	str	r1, [sp, #28]
 8009cb8:	9411      	str	r4, [sp, #68]	; 0x44
 8009cba:	9319      	str	r3, [sp, #100]	; 0x64
 8009cbc:	f7fe bf15 	b.w	8008aea <_vfprintf_r+0x3e2>
 8009cc0:	222d      	movs	r2, #45	; 0x2d
 8009cc2:	f88d 256f 	strb.w	r2, [sp, #1391]	; 0x56f
 8009cc6:	f7fe bef8 	b.w	8008aba <_vfprintf_r+0x3b2>
 8009cca:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8009cce:	980d      	ldr	r0, [sp, #52]	; 0x34
 8009cd0:	9909      	ldr	r1, [sp, #36]	; 0x24
 8009cd2:	320c      	adds	r2, #12
 8009cd4:	f003 fc12 	bl	800d4fc <__sprint_r>
 8009cd8:	2800      	cmp	r0, #0
 8009cda:	f47e ae3f 	bne.w	800895c <_vfprintf_r+0x254>
 8009cde:	f8dd 6568 	ldr.w	r6, [sp, #1384]	; 0x568
 8009ce2:	46d1      	mov	r9, sl
 8009ce4:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8009ce8:	2e00      	cmp	r6, #0
 8009cea:	f47f af56 	bne.w	8009b9a <_vfprintf_r+0x1492>
 8009cee:	e74d      	b.n	8009b8c <_vfprintf_r+0x1484>
 8009cf0:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8009cf4:	980d      	ldr	r0, [sp, #52]	; 0x34
 8009cf6:	9909      	ldr	r1, [sp, #36]	; 0x24
 8009cf8:	320c      	adds	r2, #12
 8009cfa:	f003 fbff 	bl	800d4fc <__sprint_r>
 8009cfe:	2800      	cmp	r0, #0
 8009d00:	f47e ae2c 	bne.w	800895c <_vfprintf_r+0x254>
 8009d04:	f50d 699c 	add.w	r9, sp, #1248	; 0x4e0
 8009d08:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8009d0c:	f109 090c 	add.w	r9, r9, #12
 8009d10:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009d14:	46d3      	mov	fp, sl
 8009d16:	f7ff ba50 	b.w	80091ba <_vfprintf_r+0xab2>
 8009d1a:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8009d1e:	980d      	ldr	r0, [sp, #52]	; 0x34
 8009d20:	9909      	ldr	r1, [sp, #36]	; 0x24
 8009d22:	320c      	adds	r2, #12
 8009d24:	f003 fbea 	bl	800d4fc <__sprint_r>
 8009d28:	2800      	cmp	r0, #0
 8009d2a:	f47e ae17 	bne.w	800895c <_vfprintf_r+0x254>
 8009d2e:	f8dd 6568 	ldr.w	r6, [sp, #1384]	; 0x568
 8009d32:	46d1      	mov	r9, sl
 8009d34:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8009d38:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009d3c:	e741      	b.n	8009bc2 <_vfprintf_r+0x14ba>
 8009d3e:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8009d42:	980d      	ldr	r0, [sp, #52]	; 0x34
 8009d44:	9909      	ldr	r1, [sp, #36]	; 0x24
 8009d46:	320c      	adds	r2, #12
 8009d48:	f003 fbd8 	bl	800d4fc <__sprint_r>
 8009d4c:	2800      	cmp	r0, #0
 8009d4e:	f47e ae05 	bne.w	800895c <_vfprintf_r+0x254>
 8009d52:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8009d56:	4653      	mov	r3, sl
 8009d58:	f7ff ba8f 	b.w	800927a <_vfprintf_r+0xb72>
 8009d5c:	464b      	mov	r3, r9
 8009d5e:	e678      	b.n	8009a52 <_vfprintf_r+0x134a>
 8009d60:	46a0      	mov	r8, r4
 8009d62:	461c      	mov	r4, r3
 8009d64:	3401      	adds	r4, #1
 8009d66:	f8c9 8000 	str.w	r8, [r9]
 8009d6a:	2c07      	cmp	r4, #7
 8009d6c:	f8c9 6004 	str.w	r6, [r9, #4]
 8009d70:	4435      	add	r5, r6
 8009d72:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8009d76:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8009d7a:	bfd8      	it	le
 8009d7c:	f109 0908 	addle.w	r9, r9, #8
 8009d80:	dd0e      	ble.n	8009da0 <_vfprintf_r+0x1698>
 8009d82:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8009d86:	980d      	ldr	r0, [sp, #52]	; 0x34
 8009d88:	9909      	ldr	r1, [sp, #36]	; 0x24
 8009d8a:	320c      	adds	r2, #12
 8009d8c:	f003 fbb6 	bl	800d4fc <__sprint_r>
 8009d90:	2800      	cmp	r0, #0
 8009d92:	f47e ade3 	bne.w	800895c <_vfprintf_r+0x254>
 8009d96:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8009d9a:	46d1      	mov	r9, sl
 8009d9c:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009da0:	3401      	adds	r4, #1
 8009da2:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8009da4:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8009da6:	2c07      	cmp	r4, #7
 8009da8:	441d      	add	r5, r3
 8009daa:	f8c9 3004 	str.w	r3, [r9, #4]
 8009dae:	f8c9 2000 	str.w	r2, [r9]
 8009db2:	f8cd 4550 	str.w	r4, [sp, #1360]	; 0x550
 8009db6:	f8cd 5554 	str.w	r5, [sp, #1364]	; 0x554
 8009dba:	f77e af84 	ble.w	8008cc6 <_vfprintf_r+0x5be>
 8009dbe:	f7ff ba0c 	b.w	80091da <_vfprintf_r+0xad2>
 8009dc2:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8009dc4:	2100      	movs	r1, #0
 8009dc6:	9114      	str	r1, [sp, #80]	; 0x50
 8009dc8:	f002 fd74 	bl	800c8b4 <strlen>
 8009dcc:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8009dce:	9412      	str	r4, [sp, #72]	; 0x48
 8009dd0:	9319      	str	r3, [sp, #100]	; 0x64
 8009dd2:	ea20 72e0 	bic.w	r2, r0, r0, asr #31
 8009dd6:	9011      	str	r0, [sp, #68]	; 0x44
 8009dd8:	920a      	str	r2, [sp, #40]	; 0x28
 8009dda:	f89d 256f 	ldrb.w	r2, [sp, #1391]	; 0x56f
 8009dde:	f7fe be84 	b.w	8008aea <_vfprintf_r+0x3e2>
 8009de2:	f240 18a0 	movw	r8, #416	; 0x1a0
 8009de6:	f106 0308 	add.w	r3, r6, #8
 8009dea:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8009dee:	f6c0 0801 	movt	r8, #2049	; 0x801
 8009df2:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009df6:	f7fe becb 	b.w	8008b90 <_vfprintf_r+0x488>
 8009dfa:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8009dfe:	980d      	ldr	r0, [sp, #52]	; 0x34
 8009e00:	9909      	ldr	r1, [sp, #36]	; 0x24
 8009e02:	320c      	adds	r2, #12
 8009e04:	f003 fb7a 	bl	800d4fc <__sprint_r>
 8009e08:	2800      	cmp	r0, #0
 8009e0a:	f47e ada7 	bne.w	800895c <_vfprintf_r+0x254>
 8009e0e:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8009e12:	46d1      	mov	r9, sl
 8009e14:	f7ff bb8c 	b.w	8009530 <_vfprintf_r+0xe28>
 8009e18:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8009e1c:	980d      	ldr	r0, [sp, #52]	; 0x34
 8009e1e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8009e20:	320c      	adds	r2, #12
 8009e22:	f003 fb6b 	bl	800d4fc <__sprint_r>
 8009e26:	2800      	cmp	r0, #0
 8009e28:	f47e ad98 	bne.w	800895c <_vfprintf_r+0x254>
 8009e2c:	f8dd 2568 	ldr.w	r2, [sp, #1384]	; 0x568
 8009e30:	4653      	mov	r3, sl
 8009e32:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8009e36:	e615      	b.n	8009a64 <_vfprintf_r+0x135c>
 8009e38:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8009e3a:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8009e3e:	ebc3 030b 	rsb	r3, r3, fp
 8009e42:	9311      	str	r3, [sp, #68]	; 0x44
 8009e44:	f7ff b802 	b.w	8008e4c <_vfprintf_r+0x744>
 8009e48:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8009e4c:	980d      	ldr	r0, [sp, #52]	; 0x34
 8009e4e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8009e50:	320c      	adds	r2, #12
 8009e52:	f003 fb53 	bl	800d4fc <__sprint_r>
 8009e56:	2800      	cmp	r0, #0
 8009e58:	f47e ad80 	bne.w	800895c <_vfprintf_r+0x254>
 8009e5c:	f8dd 2568 	ldr.w	r2, [sp, #1384]	; 0x568
 8009e60:	4653      	mov	r3, sl
 8009e62:	9810      	ldr	r0, [sp, #64]	; 0x40
 8009e64:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8009e68:	1a82      	subs	r2, r0, r2
 8009e6a:	e615      	b.n	8009a98 <_vfprintf_r+0x1390>
 8009e6c:	2f06      	cmp	r7, #6
 8009e6e:	bf28      	it	cs
 8009e70:	2706      	movcs	r7, #6
 8009e72:	f240 40ac 	movw	r0, #1196	; 0x4ac
 8009e76:	ea27 71e7 	bic.w	r1, r7, r7, asr #31
 8009e7a:	f6c0 0001 	movt	r0, #2049	; 0x801
 8009e7e:	461a      	mov	r2, r3
 8009e80:	9711      	str	r7, [sp, #68]	; 0x44
 8009e82:	910a      	str	r1, [sp, #40]	; 0x28
 8009e84:	9412      	str	r4, [sp, #72]	; 0x48
 8009e86:	9314      	str	r3, [sp, #80]	; 0x50
 8009e88:	9319      	str	r3, [sp, #100]	; 0x64
 8009e8a:	9013      	str	r0, [sp, #76]	; 0x4c
 8009e8c:	f7fe be2d 	b.w	8008aea <_vfprintf_r+0x3e2>
 8009e90:	f50d 62a8 	add.w	r2, sp, #1344	; 0x540
 8009e94:	980d      	ldr	r0, [sp, #52]	; 0x34
 8009e96:	9909      	ldr	r1, [sp, #36]	; 0x24
 8009e98:	320c      	adds	r2, #12
 8009e9a:	f003 fb2f 	bl	800d4fc <__sprint_r>
 8009e9e:	2800      	cmp	r0, #0
 8009ea0:	f47e ad5c 	bne.w	800895c <_vfprintf_r+0x254>
 8009ea4:	4653      	mov	r3, sl
 8009ea6:	f8dd 5554 	ldr.w	r5, [sp, #1364]	; 0x554
 8009eaa:	e5d2      	b.n	8009a52 <_vfprintf_r+0x134a>
 8009eac:	980d      	ldr	r0, [sp, #52]	; 0x34
 8009eae:	9909      	ldr	r1, [sp, #36]	; 0x24
 8009eb0:	f000 f926 	bl	800a100 <__swsetup_r>
 8009eb4:	2800      	cmp	r0, #0
 8009eb6:	d17b      	bne.n	8009fb0 <_vfprintf_r+0x18a8>
 8009eb8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8009eba:	8994      	ldrh	r4, [r2, #12]
 8009ebc:	b2a3      	uxth	r3, r4
 8009ebe:	f7fe bc6b 	b.w	8008798 <_vfprintf_r+0x90>
 8009ec2:	f240 18a0 	movw	r8, #416	; 0x1a0
 8009ec6:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009eca:	f6c0 0801 	movt	r8, #2049	; 0x801
 8009ece:	f7fe bf3b 	b.w	8008d48 <_vfprintf_r+0x640>
 8009ed2:	46b8      	mov	r8, r7
 8009ed4:	2303      	movs	r3, #3
 8009ed6:	e4ad      	b.n	8009834 <_vfprintf_r+0x112c>
 8009ed8:	9811      	ldr	r0, [sp, #68]	; 0x44
 8009eda:	222d      	movs	r2, #45	; 0x2d
 8009edc:	2100      	movs	r1, #0
 8009ede:	f88d 256f 	strb.w	r2, [sp, #1391]	; 0x56f
 8009ee2:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 8009ee6:	9114      	str	r1, [sp, #80]	; 0x50
 8009ee8:	900a      	str	r0, [sp, #40]	; 0x28
 8009eea:	f7fe bdff 	b.w	8008aec <_vfprintf_r+0x3e4>
 8009eee:	9916      	ldr	r1, [sp, #88]	; 0x58
 8009ef0:	2966      	cmp	r1, #102	; 0x66
 8009ef2:	f040 809a 	bne.w	800a02a <_vfprintf_r+0x1922>
 8009ef6:	f8dd 3568 	ldr.w	r3, [sp, #1384]	; 0x568
 8009efa:	2b00      	cmp	r3, #0
 8009efc:	9311      	str	r3, [sp, #68]	; 0x44
 8009efe:	f340 8097 	ble.w	800a030 <_vfprintf_r+0x1928>
 8009f02:	b91f      	cbnz	r7, 8009f0c <_vfprintf_r+0x1804>
 8009f04:	9807      	ldr	r0, [sp, #28]
 8009f06:	f010 0f01 	tst.w	r0, #1
 8009f0a:	d002      	beq.n	8009f12 <_vfprintf_r+0x180a>
 8009f0c:	1c5a      	adds	r2, r3, #1
 8009f0e:	19d2      	adds	r2, r2, r7
 8009f10:	9211      	str	r2, [sp, #68]	; 0x44
 8009f12:	9319      	str	r3, [sp, #100]	; 0x64
 8009f14:	9516      	str	r5, [sp, #88]	; 0x58
 8009f16:	e536      	b.n	8009986 <_vfprintf_r+0x127e>
 8009f18:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8009f1a:	980e      	ldr	r0, [sp, #56]	; 0x38
 8009f1c:	6823      	ldr	r3, [r4, #0]
 8009f1e:	3404      	adds	r4, #4
 8009f20:	9412      	str	r4, [sp, #72]	; 0x48
 8009f22:	6018      	str	r0, [r3, #0]
 8009f24:	f7fe bc54 	b.w	80087d0 <_vfprintf_r+0xc8>
 8009f28:	f8dd 3560 	ldr.w	r3, [sp, #1376]	; 0x560
 8009f2c:	429c      	cmp	r4, r3
 8009f2e:	f67f acc1 	bls.w	80098b4 <_vfprintf_r+0x11ac>
 8009f32:	2230      	movs	r2, #48	; 0x30
 8009f34:	f803 2b01 	strb.w	r2, [r3], #1
 8009f38:	42a3      	cmp	r3, r4
 8009f3a:	f8cd 3560 	str.w	r3, [sp, #1376]	; 0x560
 8009f3e:	d1f9      	bne.n	8009f34 <_vfprintf_r+0x182c>
 8009f40:	e4b8      	b.n	80098b4 <_vfprintf_r+0x11ac>
 8009f42:	4633      	mov	r3, r6
 8009f44:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009f48:	3608      	adds	r6, #8
 8009f4a:	f8df 811c 	ldr.w	r8, [pc, #284]	; 800a068 <_vfprintf_r+0x1960>
 8009f4e:	f7ff ba1b 	b.w	8009388 <_vfprintf_r+0xc80>
 8009f52:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8009f54:	4293      	cmp	r3, r2
 8009f56:	db30      	blt.n	8009fba <_vfprintf_r+0x18b2>
 8009f58:	9c07      	ldr	r4, [sp, #28]
 8009f5a:	f014 0f01 	tst.w	r4, #1
 8009f5e:	d04f      	beq.n	800a000 <_vfprintf_r+0x18f8>
 8009f60:	1c58      	adds	r0, r3, #1
 8009f62:	2567      	movs	r5, #103	; 0x67
 8009f64:	9011      	str	r0, [sp, #68]	; 0x44
 8009f66:	e7d4      	b.n	8009f12 <_vfprintf_r+0x180a>
 8009f68:	ea27 72e7 	bic.w	r2, r7, r7, asr #31
 8009f6c:	9014      	str	r0, [sp, #80]	; 0x50
 8009f6e:	920a      	str	r2, [sp, #40]	; 0x28
 8009f70:	9412      	str	r4, [sp, #72]	; 0x48
 8009f72:	f89d 256f 	ldrb.w	r2, [sp, #1391]	; 0x56f
 8009f76:	9711      	str	r7, [sp, #68]	; 0x44
 8009f78:	9019      	str	r0, [sp, #100]	; 0x64
 8009f7a:	f7fe bdb6 	b.w	8008aea <_vfprintf_r+0x3e2>
 8009f7e:	2700      	movs	r7, #0
 8009f80:	ea47 77e7 	orr.w	r7, r7, r7, asr #31
 8009f84:	f7fe bc6c 	b.w	8008860 <_vfprintf_r+0x158>
 8009f88:	212d      	movs	r1, #45	; 0x2d
 8009f8a:	f103 4900 	add.w	r9, r3, #2147483648	; 0x80000000
 8009f8e:	9114      	str	r1, [sp, #80]	; 0x50
 8009f90:	e439      	b.n	8009806 <_vfprintf_r+0x10fe>
 8009f92:	2706      	movs	r7, #6
 8009f94:	e42b      	b.n	80097ee <_vfprintf_r+0x10e6>
 8009f96:	46b8      	mov	r8, r7
 8009f98:	2302      	movs	r3, #2
 8009f9a:	e44b      	b.n	8009834 <_vfprintf_r+0x112c>
 8009f9c:	f50d 61aa 	add.w	r1, sp, #1360	; 0x550
 8009fa0:	3330      	adds	r3, #48	; 0x30
 8009fa2:	2230      	movs	r2, #48	; 0x30
 8009fa4:	310c      	adds	r1, #12
 8009fa6:	f88d 255a 	strb.w	r2, [sp, #1370]	; 0x55a
 8009faa:	f88d 355b 	strb.w	r3, [sp, #1371]	; 0x55b
 8009fae:	e4da      	b.n	8009966 <_vfprintf_r+0x125e>
 8009fb0:	f04f 33ff 	mov.w	r3, #4294967295
 8009fb4:	930e      	str	r3, [sp, #56]	; 0x38
 8009fb6:	f7fe bcda 	b.w	800896e <_vfprintf_r+0x266>
 8009fba:	2b00      	cmp	r3, #0
 8009fbc:	9910      	ldr	r1, [sp, #64]	; 0x40
 8009fbe:	bfd4      	ite	le
 8009fc0:	f1c3 0202 	rsble	r2, r3, #2
 8009fc4:	2201      	movgt	r2, #1
 8009fc6:	1852      	adds	r2, r2, r1
 8009fc8:	2567      	movs	r5, #103	; 0x67
 8009fca:	9211      	str	r2, [sp, #68]	; 0x44
 8009fcc:	e7a1      	b.n	8009f12 <_vfprintf_r+0x180a>
 8009fce:	f8dd 3560 	ldr.w	r3, [sp, #1376]	; 0x560
 8009fd2:	e46f      	b.n	80098b4 <_vfprintf_r+0x11ac>
 8009fd4:	f103 0908 	add.w	r9, r3, #8
 8009fd8:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009fdc:	f8df 8088 	ldr.w	r8, [pc, #136]	; 800a068 <_vfprintf_r+0x1960>
 8009fe0:	f7ff bb5b 	b.w	800969a <_vfprintf_r+0xf92>
 8009fe4:	f109 0308 	add.w	r3, r9, #8
 8009fe8:	f8dd 4550 	ldr.w	r4, [sp, #1360]	; 0x550
 8009fec:	f8df 8078 	ldr.w	r8, [pc, #120]	; 800a068 <_vfprintf_r+0x1960>
 8009ff0:	e522      	b.n	8009a38 <_vfprintf_r+0x1330>
 8009ff2:	9a07      	ldr	r2, [sp, #28]
 8009ff4:	f012 0301 	ands.w	r3, r2, #1
 8009ff8:	f47f acc0 	bne.w	800997c <_vfprintf_r+0x1274>
 8009ffc:	9319      	str	r3, [sp, #100]	; 0x64
 8009ffe:	e4c2      	b.n	8009986 <_vfprintf_r+0x127e>
 800a000:	2567      	movs	r5, #103	; 0x67
 800a002:	e786      	b.n	8009f12 <_vfprintf_r+0x180a>
 800a004:	981a      	ldr	r0, [sp, #104]	; 0x68
 800a006:	2200      	movs	r2, #0
 800a008:	2300      	movs	r3, #0
 800a00a:	4649      	mov	r1, r9
 800a00c:	f005 fb8e 	bl	800f72c <__aeabi_dcmpeq>
 800a010:	2800      	cmp	r0, #0
 800a012:	f47f ac40 	bne.w	8009896 <_vfprintf_r+0x118e>
 800a016:	f1c8 0301 	rsb	r3, r8, #1
 800a01a:	f8cd 3568 	str.w	r3, [sp, #1384]	; 0x568
 800a01e:	e43a      	b.n	8009896 <_vfprintf_r+0x118e>
 800a020:	222d      	movs	r2, #45	; 0x2d
 800a022:	425b      	negs	r3, r3
 800a024:	f88d 2559 	strb.w	r2, [sp, #1369]	; 0x559
 800a028:	e46e      	b.n	8009908 <_vfprintf_r+0x1200>
 800a02a:	f8dd 3568 	ldr.w	r3, [sp, #1384]	; 0x568
 800a02e:	e45f      	b.n	80098f0 <_vfprintf_r+0x11e8>
 800a030:	b91f      	cbnz	r7, 800a03a <_vfprintf_r+0x1932>
 800a032:	9907      	ldr	r1, [sp, #28]
 800a034:	f011 0f01 	tst.w	r1, #1
 800a038:	d00e      	beq.n	800a058 <_vfprintf_r+0x1950>
 800a03a:	3702      	adds	r7, #2
 800a03c:	9711      	str	r7, [sp, #68]	; 0x44
 800a03e:	e768      	b.n	8009f12 <_vfprintf_r+0x180a>
 800a040:	9812      	ldr	r0, [sp, #72]	; 0x48
 800a042:	6807      	ldr	r7, [r0, #0]
 800a044:	3004      	adds	r0, #4
 800a046:	2f00      	cmp	r7, #0
 800a048:	f6bf a889 	bge.w	800915e <_vfprintf_r+0xa56>
 800a04c:	7813      	ldrb	r3, [r2, #0]
 800a04e:	f04f 37ff 	mov.w	r7, #4294967295
 800a052:	9012      	str	r0, [sp, #72]	; 0x48
 800a054:	f7fe bc03 	b.w	800885e <_vfprintf_r+0x156>
 800a058:	2201      	movs	r2, #1
 800a05a:	9211      	str	r2, [sp, #68]	; 0x44
 800a05c:	e759      	b.n	8009f12 <_vfprintf_r+0x180a>
 800a05e:	f50d 61aa 	add.w	r1, sp, #1360	; 0x550
 800a062:	310a      	adds	r1, #10
 800a064:	e47f      	b.n	8009966 <_vfprintf_r+0x125e>
 800a066:	bf00      	nop
 800a068:	080101b0 	.word	0x080101b0

0800a06c <vfprintf>:
 800a06c:	b430      	push	{r4, r5}
 800a06e:	f240 247c 	movw	r4, #636	; 0x27c
 800a072:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800a076:	460d      	mov	r5, r1
 800a078:	4613      	mov	r3, r2
 800a07a:	4601      	mov	r1, r0
 800a07c:	462a      	mov	r2, r5
 800a07e:	6820      	ldr	r0, [r4, #0]
 800a080:	bc30      	pop	{r4, r5}
 800a082:	f7fe bb41 	b.w	8008708 <_vfprintf_r>
 800a086:	bf00      	nop

0800a088 <_vsprintf_r>:
 800a088:	b570      	push	{r4, r5, r6, lr}
 800a08a:	b09a      	sub	sp, #104	; 0x68
 800a08c:	460d      	mov	r5, r1
 800a08e:	4669      	mov	r1, sp
 800a090:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
 800a094:	f44f 7602 	mov.w	r6, #520	; 0x208
 800a098:	9500      	str	r5, [sp, #0]
 800a09a:	f8ad 600c 	strh.w	r6, [sp, #12]
 800a09e:	f04f 36ff 	mov.w	r6, #4294967295
 800a0a2:	9504      	str	r5, [sp, #16]
 800a0a4:	f8ad 600e 	strh.w	r6, [sp, #14]
 800a0a8:	9402      	str	r4, [sp, #8]
 800a0aa:	9405      	str	r4, [sp, #20]
 800a0ac:	f7fc ffda 	bl	8007064 <_svfprintf_r>
 800a0b0:	9b00      	ldr	r3, [sp, #0]
 800a0b2:	2200      	movs	r2, #0
 800a0b4:	701a      	strb	r2, [r3, #0]
 800a0b6:	b01a      	add	sp, #104	; 0x68
 800a0b8:	bd70      	pop	{r4, r5, r6, pc}
 800a0ba:	bf00      	nop

0800a0bc <vsprintf>:
 800a0bc:	b430      	push	{r4, r5}
 800a0be:	f240 247c 	movw	r4, #636	; 0x27c
 800a0c2:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800a0c6:	460d      	mov	r5, r1
 800a0c8:	4613      	mov	r3, r2
 800a0ca:	4601      	mov	r1, r0
 800a0cc:	462a      	mov	r2, r5
 800a0ce:	6820      	ldr	r0, [r4, #0]
 800a0d0:	bc30      	pop	{r4, r5}
 800a0d2:	e7d9      	b.n	800a088 <_vsprintf_r>

0800a0d4 <_write_r>:
 800a0d4:	b538      	push	{r3, r4, r5, lr}
 800a0d6:	f642 249c 	movw	r4, #10908	; 0x2a9c
 800a0da:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800a0de:	4605      	mov	r5, r0
 800a0e0:	4608      	mov	r0, r1
 800a0e2:	4611      	mov	r1, r2
 800a0e4:	461a      	mov	r2, r3
 800a0e6:	2300      	movs	r3, #0
 800a0e8:	6023      	str	r3, [r4, #0]
 800a0ea:	f7f6 fdc9 	bl	8000c80 <_write>
 800a0ee:	f1b0 3fff 	cmp.w	r0, #4294967295
 800a0f2:	d000      	beq.n	800a0f6 <_write_r+0x22>
 800a0f4:	bd38      	pop	{r3, r4, r5, pc}
 800a0f6:	6823      	ldr	r3, [r4, #0]
 800a0f8:	2b00      	cmp	r3, #0
 800a0fa:	d0fb      	beq.n	800a0f4 <_write_r+0x20>
 800a0fc:	602b      	str	r3, [r5, #0]
 800a0fe:	bd38      	pop	{r3, r4, r5, pc}

0800a100 <__swsetup_r>:
 800a100:	b570      	push	{r4, r5, r6, lr}
 800a102:	f240 257c 	movw	r5, #636	; 0x27c
 800a106:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800a10a:	4606      	mov	r6, r0
 800a10c:	460c      	mov	r4, r1
 800a10e:	6828      	ldr	r0, [r5, #0]
 800a110:	b110      	cbz	r0, 800a118 <__swsetup_r+0x18>
 800a112:	6983      	ldr	r3, [r0, #24]
 800a114:	2b00      	cmp	r3, #0
 800a116:	d036      	beq.n	800a186 <__swsetup_r+0x86>
 800a118:	f240 13c0 	movw	r3, #448	; 0x1c0
 800a11c:	f6c0 0301 	movt	r3, #2049	; 0x801
 800a120:	429c      	cmp	r4, r3
 800a122:	d038      	beq.n	800a196 <__swsetup_r+0x96>
 800a124:	f240 13e0 	movw	r3, #480	; 0x1e0
 800a128:	f6c0 0301 	movt	r3, #2049	; 0x801
 800a12c:	429c      	cmp	r4, r3
 800a12e:	d041      	beq.n	800a1b4 <__swsetup_r+0xb4>
 800a130:	f240 2300 	movw	r3, #512	; 0x200
 800a134:	f6c0 0301 	movt	r3, #2049	; 0x801
 800a138:	429c      	cmp	r4, r3
 800a13a:	bf04      	itt	eq
 800a13c:	682b      	ldreq	r3, [r5, #0]
 800a13e:	68dc      	ldreq	r4, [r3, #12]
 800a140:	89a2      	ldrh	r2, [r4, #12]
 800a142:	4610      	mov	r0, r2
 800a144:	b293      	uxth	r3, r2
 800a146:	f013 0f08 	tst.w	r3, #8
 800a14a:	bf18      	it	ne
 800a14c:	6921      	ldrne	r1, [r4, #16]
 800a14e:	d034      	beq.n	800a1ba <__swsetup_r+0xba>
 800a150:	b321      	cbz	r1, 800a19c <__swsetup_r+0x9c>
 800a152:	f013 0201 	ands.w	r2, r3, #1
 800a156:	d007      	beq.n	800a168 <__swsetup_r+0x68>
 800a158:	6963      	ldr	r3, [r4, #20]
 800a15a:	2200      	movs	r2, #0
 800a15c:	60a2      	str	r2, [r4, #8]
 800a15e:	425b      	negs	r3, r3
 800a160:	61a3      	str	r3, [r4, #24]
 800a162:	b141      	cbz	r1, 800a176 <__swsetup_r+0x76>
 800a164:	2000      	movs	r0, #0
 800a166:	bd70      	pop	{r4, r5, r6, pc}
 800a168:	f013 0f02 	tst.w	r3, #2
 800a16c:	bf08      	it	eq
 800a16e:	6962      	ldreq	r2, [r4, #20]
 800a170:	60a2      	str	r2, [r4, #8]
 800a172:	2900      	cmp	r1, #0
 800a174:	d1f6      	bne.n	800a164 <__swsetup_r+0x64>
 800a176:	89a3      	ldrh	r3, [r4, #12]
 800a178:	f013 0f80 	tst.w	r3, #128	; 0x80
 800a17c:	bf14      	ite	ne
 800a17e:	f04f 30ff 	movne.w	r0, #4294967295
 800a182:	2000      	moveq	r0, #0
 800a184:	bd70      	pop	{r4, r5, r6, pc}
 800a186:	f001 f951 	bl	800b42c <__sinit>
 800a18a:	f240 13c0 	movw	r3, #448	; 0x1c0
 800a18e:	f6c0 0301 	movt	r3, #2049	; 0x801
 800a192:	429c      	cmp	r4, r3
 800a194:	d1c6      	bne.n	800a124 <__swsetup_r+0x24>
 800a196:	682b      	ldr	r3, [r5, #0]
 800a198:	685c      	ldr	r4, [r3, #4]
 800a19a:	e7d1      	b.n	800a140 <__swsetup_r+0x40>
 800a19c:	f403 7220 	and.w	r2, r3, #640	; 0x280
 800a1a0:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 800a1a4:	d0d5      	beq.n	800a152 <__swsetup_r+0x52>
 800a1a6:	4621      	mov	r1, r4
 800a1a8:	4630      	mov	r0, r6
 800a1aa:	f001 fbed 	bl	800b988 <__smakebuf_r>
 800a1ae:	89a3      	ldrh	r3, [r4, #12]
 800a1b0:	6921      	ldr	r1, [r4, #16]
 800a1b2:	e7ce      	b.n	800a152 <__swsetup_r+0x52>
 800a1b4:	682b      	ldr	r3, [r5, #0]
 800a1b6:	689c      	ldr	r4, [r3, #8]
 800a1b8:	e7c2      	b.n	800a140 <__swsetup_r+0x40>
 800a1ba:	f013 0f10 	tst.w	r3, #16
 800a1be:	d01d      	beq.n	800a1fc <__swsetup_r+0xfc>
 800a1c0:	f013 0f04 	tst.w	r3, #4
 800a1c4:	bf08      	it	eq
 800a1c6:	6921      	ldreq	r1, [r4, #16]
 800a1c8:	d013      	beq.n	800a1f2 <__swsetup_r+0xf2>
 800a1ca:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800a1cc:	b149      	cbz	r1, 800a1e2 <__swsetup_r+0xe2>
 800a1ce:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800a1d2:	4299      	cmp	r1, r3
 800a1d4:	d003      	beq.n	800a1de <__swsetup_r+0xde>
 800a1d6:	4630      	mov	r0, r6
 800a1d8:	f001 fa64 	bl	800b6a4 <_free_r>
 800a1dc:	89a0      	ldrh	r0, [r4, #12]
 800a1de:	2300      	movs	r3, #0
 800a1e0:	6363      	str	r3, [r4, #52]	; 0x34
 800a1e2:	f64f 72db 	movw	r2, #65499	; 0xffdb
 800a1e6:	6921      	ldr	r1, [r4, #16]
 800a1e8:	ea00 0202 	and.w	r2, r0, r2
 800a1ec:	2300      	movs	r3, #0
 800a1ee:	6063      	str	r3, [r4, #4]
 800a1f0:	6021      	str	r1, [r4, #0]
 800a1f2:	f042 0308 	orr.w	r3, r2, #8
 800a1f6:	81a3      	strh	r3, [r4, #12]
 800a1f8:	b29b      	uxth	r3, r3
 800a1fa:	e7a9      	b.n	800a150 <__swsetup_r+0x50>
 800a1fc:	f04f 30ff 	mov.w	r0, #4294967295
 800a200:	bd70      	pop	{r4, r5, r6, pc}
 800a202:	bf00      	nop
 800a204:	0000      	movs	r0, r0
	...

0800a208 <quorem>:
 800a208:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a20c:	b083      	sub	sp, #12
 800a20e:	6903      	ldr	r3, [r0, #16]
 800a210:	4681      	mov	r9, r0
 800a212:	690d      	ldr	r5, [r1, #16]
 800a214:	9101      	str	r1, [sp, #4]
 800a216:	429d      	cmp	r5, r3
 800a218:	f300 8089 	bgt.w	800a32e <quorem+0x126>
 800a21c:	1cea      	adds	r2, r5, #3
 800a21e:	f101 0414 	add.w	r4, r1, #20
 800a222:	f100 0814 	add.w	r8, r0, #20
 800a226:	3d01      	subs	r5, #1
 800a228:	0092      	lsls	r2, r2, #2
 800a22a:	188b      	adds	r3, r1, r2
 800a22c:	1882      	adds	r2, r0, r2
 800a22e:	1d1f      	adds	r7, r3, #4
 800a230:	6859      	ldr	r1, [r3, #4]
 800a232:	6850      	ldr	r0, [r2, #4]
 800a234:	3101      	adds	r1, #1
 800a236:	f004 fed3 	bl	800efe0 <__aeabi_uidiv>
 800a23a:	4606      	mov	r6, r0
 800a23c:	2800      	cmp	r0, #0
 800a23e:	d03c      	beq.n	800a2ba <quorem+0xb2>
 800a240:	2000      	movs	r0, #0
 800a242:	4642      	mov	r2, r8
 800a244:	4623      	mov	r3, r4
 800a246:	4686      	mov	lr, r0
 800a248:	f853 cb04 	ldr.w	ip, [r3], #4
 800a24c:	6811      	ldr	r1, [r2, #0]
 800a24e:	fa1f fb8c 	uxth.w	fp, ip
 800a252:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 800a256:	fa1f fa81 	uxth.w	sl, r1
 800a25a:	fb0b 0b06 	mla	fp, fp, r6, r0
 800a25e:	44d6      	add	lr, sl
 800a260:	fb0c f006 	mul.w	r0, ip, r6
 800a264:	eb00 401b 	add.w	r0, r0, fp, lsr #16
 800a268:	fa1f fb8b 	uxth.w	fp, fp
 800a26c:	ebcb 0a0e 	rsb	sl, fp, lr
 800a270:	fa1f fe80 	uxth.w	lr, r0
 800a274:	0c00      	lsrs	r0, r0, #16
 800a276:	ebce 4e11 	rsb	lr, lr, r1, lsr #16
 800a27a:	429f      	cmp	r7, r3
 800a27c:	eb0e 4e2a 	add.w	lr, lr, sl, asr #16
 800a280:	fa1f fc8a 	uxth.w	ip, sl
 800a284:	ea4c 410e 	orr.w	r1, ip, lr, lsl #16
 800a288:	ea4f 4e2e 	mov.w	lr, lr, asr #16
 800a28c:	f842 1b04 	str.w	r1, [r2], #4
 800a290:	d2da      	bcs.n	800a248 <quorem+0x40>
 800a292:	1d2a      	adds	r2, r5, #4
 800a294:	eb09 0382 	add.w	r3, r9, r2, lsl #2
 800a298:	6859      	ldr	r1, [r3, #4]
 800a29a:	b971      	cbnz	r1, 800a2ba <quorem+0xb2>
 800a29c:	4598      	cmp	r8, r3
 800a29e:	d20a      	bcs.n	800a2b6 <quorem+0xae>
 800a2a0:	f859 2022 	ldr.w	r2, [r9, r2, lsl #2]
 800a2a4:	b93a      	cbnz	r2, 800a2b6 <quorem+0xae>
 800a2a6:	3b04      	subs	r3, #4
 800a2a8:	e002      	b.n	800a2b0 <quorem+0xa8>
 800a2aa:	f853 2904 	ldr.w	r2, [r3], #-4
 800a2ae:	b912      	cbnz	r2, 800a2b6 <quorem+0xae>
 800a2b0:	3d01      	subs	r5, #1
 800a2b2:	4598      	cmp	r8, r3
 800a2b4:	d3f9      	bcc.n	800a2aa <quorem+0xa2>
 800a2b6:	f8c9 5010 	str.w	r5, [r9, #16]
 800a2ba:	4648      	mov	r0, r9
 800a2bc:	9901      	ldr	r1, [sp, #4]
 800a2be:	f001 ff97 	bl	800c1f0 <__mcmp>
 800a2c2:	2800      	cmp	r0, #0
 800a2c4:	db2f      	blt.n	800a326 <quorem+0x11e>
 800a2c6:	3601      	adds	r6, #1
 800a2c8:	4643      	mov	r3, r8
 800a2ca:	f04f 0c00 	mov.w	ip, #0
 800a2ce:	f854 0b04 	ldr.w	r0, [r4], #4
 800a2d2:	6819      	ldr	r1, [r3, #0]
 800a2d4:	fa1f fa80 	uxth.w	sl, r0
 800a2d8:	0c00      	lsrs	r0, r0, #16
 800a2da:	b28a      	uxth	r2, r1
 800a2dc:	ebc0 4111 	rsb	r1, r0, r1, lsr #16
 800a2e0:	ebca 0202 	rsb	r2, sl, r2
 800a2e4:	42a7      	cmp	r7, r4
 800a2e6:	4494      	add	ip, r2
 800a2e8:	eb01 422c 	add.w	r2, r1, ip, asr #16
 800a2ec:	fa1f fc8c 	uxth.w	ip, ip
 800a2f0:	ea4c 4102 	orr.w	r1, ip, r2, lsl #16
 800a2f4:	ea4f 4c22 	mov.w	ip, r2, asr #16
 800a2f8:	f843 1b04 	str.w	r1, [r3], #4
 800a2fc:	d2e7      	bcs.n	800a2ce <quorem+0xc6>
 800a2fe:	1d2a      	adds	r2, r5, #4
 800a300:	eb09 0382 	add.w	r3, r9, r2, lsl #2
 800a304:	6859      	ldr	r1, [r3, #4]
 800a306:	b971      	cbnz	r1, 800a326 <quorem+0x11e>
 800a308:	4598      	cmp	r8, r3
 800a30a:	d20a      	bcs.n	800a322 <quorem+0x11a>
 800a30c:	f859 2022 	ldr.w	r2, [r9, r2, lsl #2]
 800a310:	b93a      	cbnz	r2, 800a322 <quorem+0x11a>
 800a312:	3b04      	subs	r3, #4
 800a314:	e002      	b.n	800a31c <quorem+0x114>
 800a316:	f853 2904 	ldr.w	r2, [r3], #-4
 800a31a:	b912      	cbnz	r2, 800a322 <quorem+0x11a>
 800a31c:	3d01      	subs	r5, #1
 800a31e:	4598      	cmp	r8, r3
 800a320:	d3f9      	bcc.n	800a316 <quorem+0x10e>
 800a322:	f8c9 5010 	str.w	r5, [r9, #16]
 800a326:	4630      	mov	r0, r6
 800a328:	b003      	add	sp, #12
 800a32a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a32e:	2000      	movs	r0, #0
 800a330:	e7fa      	b.n	800a328 <quorem+0x120>
 800a332:	bf00      	nop

0800a334 <_dtoa_r>:
 800a334:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a338:	b09f      	sub	sp, #124	; 0x7c
 800a33a:	6a45      	ldr	r5, [r0, #36]	; 0x24
 800a33c:	4604      	mov	r4, r0
 800a33e:	4690      	mov	r8, r2
 800a340:	4699      	mov	r9, r3
 800a342:	9e2b      	ldr	r6, [sp, #172]	; 0xac
 800a344:	2d00      	cmp	r5, #0
 800a346:	f000 8390 	beq.w	800aa6a <_dtoa_r+0x736>
 800a34a:	682b      	ldr	r3, [r5, #0]
 800a34c:	b153      	cbz	r3, 800a364 <_dtoa_r+0x30>
 800a34e:	686a      	ldr	r2, [r5, #4]
 800a350:	2501      	movs	r5, #1
 800a352:	4619      	mov	r1, r3
 800a354:	4095      	lsls	r5, r2
 800a356:	609d      	str	r5, [r3, #8]
 800a358:	605a      	str	r2, [r3, #4]
 800a35a:	f001 fd07 	bl	800bd6c <_Bfree>
 800a35e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a360:	2200      	movs	r2, #0
 800a362:	601a      	str	r2, [r3, #0]
 800a364:	f1b9 0500 	subs.w	r5, r9, #0
 800a368:	f2c0 80d3 	blt.w	800a512 <_dtoa_r+0x1de>
 800a36c:	2300      	movs	r3, #0
 800a36e:	6033      	str	r3, [r6, #0]
 800a370:	2300      	movs	r3, #0
 800a372:	461a      	mov	r2, r3
 800a374:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 800a378:	f6c7 72f0 	movt	r2, #32752	; 0x7ff0
 800a37c:	ea05 0303 	and.w	r3, r5, r3
 800a380:	4293      	cmp	r3, r2
 800a382:	f000 80af 	beq.w	800a4e4 <_dtoa_r+0x1b0>
 800a386:	2200      	movs	r2, #0
 800a388:	2300      	movs	r3, #0
 800a38a:	4640      	mov	r0, r8
 800a38c:	4649      	mov	r1, r9
 800a38e:	e9cd 8902 	strd	r8, r9, [sp, #8]
 800a392:	2601      	movs	r6, #1
 800a394:	f005 f9ca 	bl	800f72c <__aeabi_dcmpeq>
 800a398:	b988      	cbnz	r0, 800a3be <_dtoa_r+0x8a>
 800a39a:	f016 0fff 	tst.w	r6, #255	; 0xff
 800a39e:	d112      	bne.n	800a3c6 <_dtoa_r+0x92>
 800a3a0:	982a      	ldr	r0, [sp, #168]	; 0xa8
 800a3a2:	2301      	movs	r3, #1
 800a3a4:	992c      	ldr	r1, [sp, #176]	; 0xb0
 800a3a6:	6003      	str	r3, [r0, #0]
 800a3a8:	f240 40b4 	movw	r0, #1204	; 0x4b4
 800a3ac:	f6c0 0001 	movt	r0, #2049	; 0x801
 800a3b0:	b111      	cbz	r1, 800a3b8 <_dtoa_r+0x84>
 800a3b2:	4b7b      	ldr	r3, [pc, #492]	; (800a5a0 <_dtoa_r+0x26c>)
 800a3b4:	1e58      	subs	r0, r3, #1
 800a3b6:	600b      	str	r3, [r1, #0]
 800a3b8:	b01f      	add	sp, #124	; 0x7c
 800a3ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a3be:	2600      	movs	r6, #0
 800a3c0:	f016 0fff 	tst.w	r6, #255	; 0xff
 800a3c4:	d0ec      	beq.n	800a3a0 <_dtoa_r+0x6c>
 800a3c6:	4620      	mov	r0, r4
 800a3c8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800a3cc:	a91c      	add	r1, sp, #112	; 0x70
 800a3ce:	9100      	str	r1, [sp, #0]
 800a3d0:	a91d      	add	r1, sp, #116	; 0x74
 800a3d2:	9101      	str	r1, [sp, #4]
 800a3d4:	f002 f820 	bl	800c418 <__d2b>
 800a3d8:	f3c5 560a 	ubfx	r6, r5, #20, #11
 800a3dc:	4682      	mov	sl, r0
 800a3de:	2e00      	cmp	r6, #0
 800a3e0:	f000 80ac 	beq.w	800a53c <_dtoa_r+0x208>
 800a3e4:	9803      	ldr	r0, [sp, #12]
 800a3e6:	f5a6 767e 	sub.w	r6, r6, #1016	; 0x3f8
 800a3ea:	9f1d      	ldr	r7, [sp, #116]	; 0x74
 800a3ec:	3e07      	subs	r6, #7
 800a3ee:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
 800a3f2:	2100      	movs	r1, #0
 800a3f4:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800a3f8:	9116      	str	r1, [sp, #88]	; 0x58
 800a3fa:	f043 537e 	orr.w	r3, r3, #1065353216	; 0x3f800000
 800a3fe:	f443 03e0 	orr.w	r3, r3, #7340032	; 0x700000
 800a402:	9303      	str	r3, [sp, #12]
 800a404:	2300      	movs	r3, #0
 800a406:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800a40a:	2200      	movs	r2, #0
 800a40c:	f6c3 73f8 	movt	r3, #16376	; 0x3ff8
 800a410:	f7fb fd6a 	bl	8005ee8 <__aeabi_dsub>
 800a414:	a35c      	add	r3, pc, #368	; (adr r3, 800a588 <_dtoa_r+0x254>)
 800a416:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a41a:	f004 ff1f 	bl	800f25c <__aeabi_dmul>
 800a41e:	a35c      	add	r3, pc, #368	; (adr r3, 800a590 <_dtoa_r+0x25c>)
 800a420:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a424:	f7fb fd62 	bl	8005eec <__adddf3>
 800a428:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800a42c:	4630      	mov	r0, r6
 800a42e:	f7fb fea9 	bl	8006184 <__aeabi_i2d>
 800a432:	a359      	add	r3, pc, #356	; (adr r3, 800a598 <_dtoa_r+0x264>)
 800a434:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a438:	f004 ff10 	bl	800f25c <__aeabi_dmul>
 800a43c:	4602      	mov	r2, r0
 800a43e:	460b      	mov	r3, r1
 800a440:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800a444:	f7fb fd52 	bl	8005eec <__adddf3>
 800a448:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800a44c:	f005 f9a0 	bl	800f790 <__aeabi_d2iz>
 800a450:	2200      	movs	r2, #0
 800a452:	2300      	movs	r3, #0
 800a454:	4605      	mov	r5, r0
 800a456:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800a45a:	f005 f971 	bl	800f740 <__aeabi_dcmplt>
 800a45e:	b140      	cbz	r0, 800a472 <_dtoa_r+0x13e>
 800a460:	4628      	mov	r0, r5
 800a462:	f7fb fe8f 	bl	8006184 <__aeabi_i2d>
 800a466:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800a46a:	f005 f95f 	bl	800f72c <__aeabi_dcmpeq>
 800a46e:	b900      	cbnz	r0, 800a472 <_dtoa_r+0x13e>
 800a470:	3d01      	subs	r5, #1
 800a472:	2d16      	cmp	r5, #22
 800a474:	f200 8255 	bhi.w	800a922 <_dtoa_r+0x5ee>
 800a478:	f240 2130 	movw	r1, #560	; 0x230
 800a47c:	4642      	mov	r2, r8
 800a47e:	f6c0 0101 	movt	r1, #2049	; 0x801
 800a482:	464b      	mov	r3, r9
 800a484:	eb01 01c5 	add.w	r1, r1, r5, lsl #3
 800a488:	e9d1 0100 	ldrd	r0, r1, [r1]
 800a48c:	f005 f976 	bl	800f77c <__aeabi_dcmpgt>
 800a490:	2800      	cmp	r0, #0
 800a492:	f000 8300 	beq.w	800aa96 <_dtoa_r+0x762>
 800a496:	3d01      	subs	r5, #1
 800a498:	2000      	movs	r0, #0
 800a49a:	9015      	str	r0, [sp, #84]	; 0x54
 800a49c:	3f01      	subs	r7, #1
 800a49e:	1bbe      	subs	r6, r7, r6
 800a4a0:	f100 82f4 	bmi.w	800aa8c <_dtoa_r+0x758>
 800a4a4:	2000      	movs	r0, #0
 800a4a6:	960b      	str	r6, [sp, #44]	; 0x2c
 800a4a8:	900d      	str	r0, [sp, #52]	; 0x34
 800a4aa:	2d00      	cmp	r5, #0
 800a4ac:	f2c0 82e6 	blt.w	800aa7c <_dtoa_r+0x748>
 800a4b0:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800a4b2:	2200      	movs	r2, #0
 800a4b4:	9511      	str	r5, [sp, #68]	; 0x44
 800a4b6:	1949      	adds	r1, r1, r5
 800a4b8:	920f      	str	r2, [sp, #60]	; 0x3c
 800a4ba:	910b      	str	r1, [sp, #44]	; 0x2c
 800a4bc:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800a4be:	2a09      	cmp	r2, #9
 800a4c0:	d870      	bhi.n	800a5a4 <_dtoa_r+0x270>
 800a4c2:	2a05      	cmp	r2, #5
 800a4c4:	f340 8690 	ble.w	800b1e8 <_dtoa_r+0xeb4>
 800a4c8:	2700      	movs	r7, #0
 800a4ca:	3a04      	subs	r2, #4
 800a4cc:	9228      	str	r2, [sp, #160]	; 0xa0
 800a4ce:	9828      	ldr	r0, [sp, #160]	; 0xa0
 800a4d0:	1e83      	subs	r3, r0, #2
 800a4d2:	2b03      	cmp	r3, #3
 800a4d4:	f200 840a 	bhi.w	800acec <_dtoa_r+0x9b8>
 800a4d8:	e8df f013 	tbh	[pc, r3, lsl #1]
 800a4dc:	03ec0402 	.word	0x03ec0402
 800a4e0:	040503cc 	.word	0x040503cc
 800a4e4:	982a      	ldr	r0, [sp, #168]	; 0xa8
 800a4e6:	f242 730f 	movw	r3, #9999	; 0x270f
 800a4ea:	6003      	str	r3, [r0, #0]
 800a4ec:	f240 40c4 	movw	r0, #1220	; 0x4c4
 800a4f0:	f6c0 0001 	movt	r0, #2049	; 0x801
 800a4f4:	f1b8 0f00 	cmp.w	r8, #0
 800a4f8:	d011      	beq.n	800a51e <_dtoa_r+0x1ea>
 800a4fa:	992c      	ldr	r1, [sp, #176]	; 0xb0
 800a4fc:	2900      	cmp	r1, #0
 800a4fe:	f43f af5b 	beq.w	800a3b8 <_dtoa_r+0x84>
 800a502:	78c2      	ldrb	r2, [r0, #3]
 800a504:	1cc3      	adds	r3, r0, #3
 800a506:	b10a      	cbz	r2, 800a50c <_dtoa_r+0x1d8>
 800a508:	f100 0308 	add.w	r3, r0, #8
 800a50c:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
 800a50e:	6013      	str	r3, [r2, #0]
 800a510:	e752      	b.n	800a3b8 <_dtoa_r+0x84>
 800a512:	f025 4500 	bic.w	r5, r5, #2147483648	; 0x80000000
 800a516:	2301      	movs	r3, #1
 800a518:	46a9      	mov	r9, r5
 800a51a:	6033      	str	r3, [r6, #0]
 800a51c:	e728      	b.n	800a370 <_dtoa_r+0x3c>
 800a51e:	f240 42b8 	movw	r2, #1208	; 0x4b8
 800a522:	f240 43c4 	movw	r3, #1220	; 0x4c4
 800a526:	f3c5 0013 	ubfx	r0, r5, #0, #20
 800a52a:	f6c0 0201 	movt	r2, #2049	; 0x801
 800a52e:	f6c0 0301 	movt	r3, #2049	; 0x801
 800a532:	2800      	cmp	r0, #0
 800a534:	bf0c      	ite	eq
 800a536:	4610      	moveq	r0, r2
 800a538:	4618      	movne	r0, r3
 800a53a:	e7de      	b.n	800a4fa <_dtoa_r+0x1c6>
 800a53c:	9f1d      	ldr	r7, [sp, #116]	; 0x74
 800a53e:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 800a540:	18fb      	adds	r3, r7, r3
 800a542:	f503 6386 	add.w	r3, r3, #1072	; 0x430
 800a546:	1c9e      	adds	r6, r3, #2
 800a548:	2e20      	cmp	r6, #32
 800a54a:	bfdc      	itt	le
 800a54c:	f1c6 0020 	rsble	r0, r6, #32
 800a550:	fa08 f000 	lslle.w	r0, r8, r0
 800a554:	dd07      	ble.n	800a566 <_dtoa_r+0x232>
 800a556:	f1c6 0040 	rsb	r0, r6, #64	; 0x40
 800a55a:	3b1e      	subs	r3, #30
 800a55c:	4085      	lsls	r5, r0
 800a55e:	fa28 f303 	lsr.w	r3, r8, r3
 800a562:	ea45 0003 	orr.w	r0, r5, r3
 800a566:	2201      	movs	r2, #1
 800a568:	9216      	str	r2, [sp, #88]	; 0x58
 800a56a:	f7fb fdfb 	bl	8006164 <__aeabi_ui2d>
 800a56e:	f5a6 6686 	sub.w	r6, r6, #1072	; 0x430
 800a572:	3e03      	subs	r6, #3
 800a574:	460b      	mov	r3, r1
 800a576:	4602      	mov	r2, r0
 800a578:	e9cd 2302 	strd	r2, r3, [sp, #8]
 800a57c:	9b03      	ldr	r3, [sp, #12]
 800a57e:	f1a3 73f8 	sub.w	r3, r3, #32505856	; 0x1f00000
 800a582:	9303      	str	r3, [sp, #12]
 800a584:	e73e      	b.n	800a404 <_dtoa_r+0xd0>
 800a586:	bf00      	nop
 800a588:	636f4361 	.word	0x636f4361
 800a58c:	3fd287a7 	.word	0x3fd287a7
 800a590:	8b60c8b3 	.word	0x8b60c8b3
 800a594:	3fc68a28 	.word	0x3fc68a28
 800a598:	509f79fb 	.word	0x509f79fb
 800a59c:	3fd34413 	.word	0x3fd34413
 800a5a0:	080104b5 	.word	0x080104b5
 800a5a4:	2000      	movs	r0, #0
 800a5a6:	f04f 31ff 	mov.w	r1, #4294967295
 800a5aa:	4607      	mov	r7, r0
 800a5ac:	2201      	movs	r2, #1
 800a5ae:	9028      	str	r0, [sp, #160]	; 0xa0
 800a5b0:	910e      	str	r1, [sp, #56]	; 0x38
 800a5b2:	9210      	str	r2, [sp, #64]	; 0x40
 800a5b4:	910a      	str	r1, [sp, #40]	; 0x28
 800a5b6:	9029      	str	r0, [sp, #164]	; 0xa4
 800a5b8:	6a66      	ldr	r6, [r4, #36]	; 0x24
 800a5ba:	2300      	movs	r3, #0
 800a5bc:	6073      	str	r3, [r6, #4]
 800a5be:	4620      	mov	r0, r4
 800a5c0:	6871      	ldr	r1, [r6, #4]
 800a5c2:	f001 fb9f 	bl	800bd04 <_Balloc>
 800a5c6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a5c8:	6030      	str	r0, [r6, #0]
 800a5ca:	681b      	ldr	r3, [r3, #0]
 800a5cc:	930c      	str	r3, [sp, #48]	; 0x30
 800a5ce:	2f00      	cmp	r7, #0
 800a5d0:	f000 80de 	beq.w	800a790 <_dtoa_r+0x45c>
 800a5d4:	2d00      	cmp	r5, #0
 800a5d6:	4640      	mov	r0, r8
 800a5d8:	4649      	mov	r1, r9
 800a5da:	e9cd 8908 	strd	r8, r9, [sp, #32]
 800a5de:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800a5e2:	f340 842e 	ble.w	800ae42 <_dtoa_r+0xb0e>
 800a5e6:	f240 2330 	movw	r3, #560	; 0x230
 800a5ea:	f005 020f 	and.w	r2, r5, #15
 800a5ee:	f6c0 0301 	movt	r3, #2049	; 0x801
 800a5f2:	112e      	asrs	r6, r5, #4
 800a5f4:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800a5f8:	f016 0f10 	tst.w	r6, #16
 800a5fc:	bf08      	it	eq
 800a5fe:	f04f 0802 	moveq.w	r8, #2
 800a602:	e9d3 0100 	ldrd	r0, r1, [r3]
 800a606:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
 800a60a:	f040 8247 	bne.w	800aa9c <_dtoa_r+0x768>
 800a60e:	b1be      	cbz	r6, 800a640 <_dtoa_r+0x30c>
 800a610:	f240 27f8 	movw	r7, #760	; 0x2f8
 800a614:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 800a618:	f6c0 0701 	movt	r7, #2049	; 0x801
 800a61c:	f016 0f01 	tst.w	r6, #1
 800a620:	4610      	mov	r0, r2
 800a622:	4619      	mov	r1, r3
 800a624:	d007      	beq.n	800a636 <_dtoa_r+0x302>
 800a626:	e9d7 2300 	ldrd	r2, r3, [r7]
 800a62a:	f108 0801 	add.w	r8, r8, #1
 800a62e:	f004 fe15 	bl	800f25c <__aeabi_dmul>
 800a632:	4602      	mov	r2, r0
 800a634:	460b      	mov	r3, r1
 800a636:	3708      	adds	r7, #8
 800a638:	1076      	asrs	r6, r6, #1
 800a63a:	d1ef      	bne.n	800a61c <_dtoa_r+0x2e8>
 800a63c:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
 800a640:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800a644:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 800a648:	f004 ff32 	bl	800f4b0 <__aeabi_ddiv>
 800a64c:	e9cd 0108 	strd	r0, r1, [sp, #32]
 800a650:	9915      	ldr	r1, [sp, #84]	; 0x54
 800a652:	2900      	cmp	r1, #0
 800a654:	d038      	beq.n	800a6c8 <_dtoa_r+0x394>
 800a656:	2300      	movs	r3, #0
 800a658:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800a65c:	2200      	movs	r2, #0
 800a65e:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
 800a662:	2601      	movs	r6, #1
 800a664:	f005 f86c 	bl	800f740 <__aeabi_dcmplt>
 800a668:	2800      	cmp	r0, #0
 800a66a:	f000 8301 	beq.w	800ac70 <_dtoa_r+0x93c>
 800a66e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800a670:	2a00      	cmp	r2, #0
 800a672:	bfd4      	ite	le
 800a674:	2600      	movle	r6, #0
 800a676:	f006 0601 	andgt.w	r6, r6, #1
 800a67a:	b32e      	cbz	r6, 800a6c8 <_dtoa_r+0x394>
 800a67c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800a67e:	2b00      	cmp	r3, #0
 800a680:	f340 8082 	ble.w	800a788 <_dtoa_r+0x454>
 800a684:	2300      	movs	r3, #0
 800a686:	2200      	movs	r2, #0
 800a688:	f2c4 0324 	movt	r3, #16420	; 0x4024
 800a68c:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800a690:	f004 fde4 	bl	800f25c <__aeabi_dmul>
 800a694:	e9cd 0108 	strd	r0, r1, [sp, #32]
 800a698:	f108 0001 	add.w	r0, r8, #1
 800a69c:	1e69      	subs	r1, r5, #1
 800a69e:	9112      	str	r1, [sp, #72]	; 0x48
 800a6a0:	f7fb fd70 	bl	8006184 <__aeabi_i2d>
 800a6a4:	4602      	mov	r2, r0
 800a6a6:	460b      	mov	r3, r1
 800a6a8:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800a6ac:	f004 fdd6 	bl	800f25c <__aeabi_dmul>
 800a6b0:	2300      	movs	r3, #0
 800a6b2:	2200      	movs	r2, #0
 800a6b4:	f2c4 031c 	movt	r3, #16412	; 0x401c
 800a6b8:	f7fb fc18 	bl	8005eec <__adddf3>
 800a6bc:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
 800a6c0:	4680      	mov	r8, r0
 800a6c2:	f1a1 7950 	sub.w	r9, r1, #54525952	; 0x3400000
 800a6c6:	e23c      	b.n	800ab42 <_dtoa_r+0x80e>
 800a6c8:	4640      	mov	r0, r8
 800a6ca:	f7fb fd5b 	bl	8006184 <__aeabi_i2d>
 800a6ce:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 800a6d2:	f004 fdc3 	bl	800f25c <__aeabi_dmul>
 800a6d6:	2300      	movs	r3, #0
 800a6d8:	2200      	movs	r2, #0
 800a6da:	f2c4 031c 	movt	r3, #16412	; 0x401c
 800a6de:	f7fb fc05 	bl	8005eec <__adddf3>
 800a6e2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800a6e4:	f1a1 7650 	sub.w	r6, r1, #54525952	; 0x3400000
 800a6e8:	4680      	mov	r8, r0
 800a6ea:	46b1      	mov	r9, r6
 800a6ec:	2a00      	cmp	r2, #0
 800a6ee:	f040 8225 	bne.w	800ab3c <_dtoa_r+0x808>
 800a6f2:	2300      	movs	r3, #0
 800a6f4:	2200      	movs	r2, #0
 800a6f6:	f2c4 0314 	movt	r3, #16404	; 0x4014
 800a6fa:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800a6fe:	f7fb fbf3 	bl	8005ee8 <__aeabi_dsub>
 800a702:	4642      	mov	r2, r8
 800a704:	4633      	mov	r3, r6
 800a706:	e9cd 0108 	strd	r0, r1, [sp, #32]
 800a70a:	f005 f837 	bl	800f77c <__aeabi_dcmpgt>
 800a70e:	2800      	cmp	r0, #0
 800a710:	f040 820f 	bne.w	800ab32 <_dtoa_r+0x7fe>
 800a714:	4642      	mov	r2, r8
 800a716:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800a71a:	f106 4300 	add.w	r3, r6, #2147483648	; 0x80000000
 800a71e:	f005 f80f 	bl	800f740 <__aeabi_dcmplt>
 800a722:	2800      	cmp	r0, #0
 800a724:	d030      	beq.n	800a788 <_dtoa_r+0x454>
 800a726:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 800a72a:	f8cd b020 	str.w	fp, [sp, #32]
 800a72e:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 800a730:	2700      	movs	r7, #0
 800a732:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 800a734:	43dd      	mvns	r5, r3
 800a736:	4659      	mov	r1, fp
 800a738:	4620      	mov	r0, r4
 800a73a:	f001 fb17 	bl	800bd6c <_Bfree>
 800a73e:	9908      	ldr	r1, [sp, #32]
 800a740:	b171      	cbz	r1, 800a760 <_dtoa_r+0x42c>
 800a742:	1e3b      	subs	r3, r7, #0
 800a744:	bf18      	it	ne
 800a746:	2301      	movne	r3, #1
 800a748:	428f      	cmp	r7, r1
 800a74a:	bf0c      	ite	eq
 800a74c:	2300      	moveq	r3, #0
 800a74e:	f003 0301 	andne.w	r3, r3, #1
 800a752:	2b00      	cmp	r3, #0
 800a754:	f040 835e 	bne.w	800ae14 <_dtoa_r+0xae0>
 800a758:	4620      	mov	r0, r4
 800a75a:	9908      	ldr	r1, [sp, #32]
 800a75c:	f001 fb06 	bl	800bd6c <_Bfree>
 800a760:	4620      	mov	r0, r4
 800a762:	4651      	mov	r1, sl
 800a764:	f001 fb02 	bl	800bd6c <_Bfree>
 800a768:	2300      	movs	r3, #0
 800a76a:	7033      	strb	r3, [r6, #0]
 800a76c:	3501      	adds	r5, #1
 800a76e:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 800a770:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 800a772:	6015      	str	r5, [r2, #0]
 800a774:	2b00      	cmp	r3, #0
 800a776:	f000 8418 	beq.w	800afaa <_dtoa_r+0xc76>
 800a77a:	601e      	str	r6, [r3, #0]
 800a77c:	980c      	ldr	r0, [sp, #48]	; 0x30
 800a77e:	e61b      	b.n	800a3b8 <_dtoa_r+0x84>
 800a780:	9d18      	ldr	r5, [sp, #96]	; 0x60
 800a782:	f8dd a05c 	ldr.w	sl, [sp, #92]	; 0x5c
 800a786:	9c08      	ldr	r4, [sp, #32]
 800a788:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800a78c:	4680      	mov	r8, r0
 800a78e:	4689      	mov	r9, r1
 800a790:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 800a792:	43df      	mvns	r7, r3
 800a794:	0fff      	lsrs	r7, r7, #31
 800a796:	2d0e      	cmp	r5, #14
 800a798:	bfcc      	ite	gt
 800a79a:	2700      	movgt	r7, #0
 800a79c:	f007 0701 	andle.w	r7, r7, #1
 800a7a0:	2f00      	cmp	r7, #0
 800a7a2:	f000 80c1 	beq.w	800a928 <_dtoa_r+0x5f4>
 800a7a6:	f240 2330 	movw	r3, #560	; 0x230
 800a7aa:	9929      	ldr	r1, [sp, #164]	; 0xa4
 800a7ac:	f6c0 0301 	movt	r3, #2049	; 0x801
 800a7b0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800a7b2:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 800a7b6:	0fcf      	lsrs	r7, r1, #31
 800a7b8:	e9d3 0100 	ldrd	r0, r1, [r3]
 800a7bc:	2a00      	cmp	r2, #0
 800a7be:	bfcc      	ite	gt
 800a7c0:	2700      	movgt	r7, #0
 800a7c2:	f007 0701 	andle.w	r7, r7, #1
 800a7c6:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800a7ca:	2f00      	cmp	r7, #0
 800a7cc:	f040 819e 	bne.w	800ab0c <_dtoa_r+0x7d8>
 800a7d0:	4602      	mov	r2, r0
 800a7d2:	460b      	mov	r3, r1
 800a7d4:	4640      	mov	r0, r8
 800a7d6:	4649      	mov	r1, r9
 800a7d8:	e9cd 8904 	strd	r8, r9, [sp, #16]
 800a7dc:	f004 fe68 	bl	800f4b0 <__aeabi_ddiv>
 800a7e0:	f004 ffd6 	bl	800f790 <__aeabi_d2iz>
 800a7e4:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 800a7e6:	4681      	mov	r9, r0
 800a7e8:	f7fb fccc 	bl	8006184 <__aeabi_i2d>
 800a7ec:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800a7f0:	f004 fd34 	bl	800f25c <__aeabi_dmul>
 800a7f4:	4602      	mov	r2, r0
 800a7f6:	460b      	mov	r3, r1
 800a7f8:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 800a7fc:	f7fb fb74 	bl	8005ee8 <__aeabi_dsub>
 800a800:	f109 0330 	add.w	r3, r9, #48	; 0x30
 800a804:	e9cd 0104 	strd	r0, r1, [sp, #16]
 800a808:	f806 3b01 	strb.w	r3, [r6], #1
 800a80c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800a80e:	2a01      	cmp	r2, #1
 800a810:	d056      	beq.n	800a8c0 <_dtoa_r+0x58c>
 800a812:	2300      	movs	r3, #0
 800a814:	2200      	movs	r2, #0
 800a816:	f2c4 0324 	movt	r3, #16420	; 0x4024
 800a81a:	f04f 0801 	mov.w	r8, #1
 800a81e:	f004 fd1d 	bl	800f25c <__aeabi_dmul>
 800a822:	2200      	movs	r2, #0
 800a824:	2300      	movs	r3, #0
 800a826:	e9cd 0104 	strd	r0, r1, [sp, #16]
 800a82a:	f004 ff7f 	bl	800f72c <__aeabi_dcmpeq>
 800a82e:	b100      	cbz	r0, 800a832 <_dtoa_r+0x4fe>
 800a830:	46b8      	mov	r8, r7
 800a832:	f018 0fff 	tst.w	r8, #255	; 0xff
 800a836:	d093      	beq.n	800a760 <_dtoa_r+0x42c>
 800a838:	990a      	ldr	r1, [sp, #40]	; 0x28
 800a83a:	4637      	mov	r7, r6
 800a83c:	980c      	ldr	r0, [sp, #48]	; 0x30
 800a83e:	46a0      	mov	r8, r4
 800a840:	9507      	str	r5, [sp, #28]
 800a842:	eb00 0b01 	add.w	fp, r0, r1
 800a846:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
 800a84a:	465d      	mov	r5, fp
 800a84c:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 800a850:	e00d      	b.n	800a86e <_dtoa_r+0x53a>
 800a852:	f004 fd03 	bl	800f25c <__aeabi_dmul>
 800a856:	2200      	movs	r2, #0
 800a858:	2300      	movs	r3, #0
 800a85a:	4682      	mov	sl, r0
 800a85c:	468b      	mov	fp, r1
 800a85e:	f004 ff65 	bl	800f72c <__aeabi_dcmpeq>
 800a862:	b100      	cbz	r0, 800a866 <_dtoa_r+0x532>
 800a864:	2400      	movs	r4, #0
 800a866:	f014 0fff 	tst.w	r4, #255	; 0xff
 800a86a:	f000 840f 	beq.w	800b08c <_dtoa_r+0xd58>
 800a86e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800a872:	4650      	mov	r0, sl
 800a874:	4659      	mov	r1, fp
 800a876:	2401      	movs	r4, #1
 800a878:	f004 fe1a 	bl	800f4b0 <__aeabi_ddiv>
 800a87c:	f004 ff88 	bl	800f790 <__aeabi_d2iz>
 800a880:	4681      	mov	r9, r0
 800a882:	f7fb fc7f 	bl	8006184 <__aeabi_i2d>
 800a886:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800a88a:	f109 0630 	add.w	r6, r9, #48	; 0x30
 800a88e:	f004 fce5 	bl	800f25c <__aeabi_dmul>
 800a892:	4602      	mov	r2, r0
 800a894:	460b      	mov	r3, r1
 800a896:	4650      	mov	r0, sl
 800a898:	4659      	mov	r1, fp
 800a89a:	f7fb fb25 	bl	8005ee8 <__aeabi_dsub>
 800a89e:	2300      	movs	r3, #0
 800a8a0:	f807 6b01 	strb.w	r6, [r7], #1
 800a8a4:	2200      	movs	r2, #0
 800a8a6:	42af      	cmp	r7, r5
 800a8a8:	f2c4 0324 	movt	r3, #16420	; 0x4024
 800a8ac:	463e      	mov	r6, r7
 800a8ae:	4682      	mov	sl, r0
 800a8b0:	468b      	mov	fp, r1
 800a8b2:	d1ce      	bne.n	800a852 <_dtoa_r+0x51e>
 800a8b4:	e9cd ab04 	strd	sl, fp, [sp, #16]
 800a8b8:	4644      	mov	r4, r8
 800a8ba:	9d07      	ldr	r5, [sp, #28]
 800a8bc:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 800a8c0:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 800a8c4:	4602      	mov	r2, r0
 800a8c6:	460b      	mov	r3, r1
 800a8c8:	f7fb fb10 	bl	8005eec <__adddf3>
 800a8cc:	e9cd 0104 	strd	r0, r1, [sp, #16]
 800a8d0:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 800a8d4:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800a8d8:	f004 ff32 	bl	800f740 <__aeabi_dcmplt>
 800a8dc:	b960      	cbnz	r0, 800a8f8 <_dtoa_r+0x5c4>
 800a8de:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800a8e2:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 800a8e6:	f004 ff21 	bl	800f72c <__aeabi_dcmpeq>
 800a8ea:	2800      	cmp	r0, #0
 800a8ec:	f43f af38 	beq.w	800a760 <_dtoa_r+0x42c>
 800a8f0:	f019 0f01 	tst.w	r9, #1
 800a8f4:	f43f af34 	beq.w	800a760 <_dtoa_r+0x42c>
 800a8f8:	9512      	str	r5, [sp, #72]	; 0x48
 800a8fa:	980c      	ldr	r0, [sp, #48]	; 0x30
 800a8fc:	4633      	mov	r3, r6
 800a8fe:	f813 1c01 	ldrb.w	r1, [r3, #-1]
 800a902:	1e5a      	subs	r2, r3, #1
 800a904:	461e      	mov	r6, r3
 800a906:	4613      	mov	r3, r2
 800a908:	2939      	cmp	r1, #57	; 0x39
 800a90a:	f040 83e1 	bne.w	800b0d0 <_dtoa_r+0xd9c>
 800a90e:	4283      	cmp	r3, r0
 800a910:	d1f5      	bne.n	800a8fe <_dtoa_r+0x5ca>
 800a912:	980c      	ldr	r0, [sp, #48]	; 0x30
 800a914:	2131      	movs	r1, #49	; 0x31
 800a916:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800a918:	1c5d      	adds	r5, r3, #1
 800a91a:	2330      	movs	r3, #48	; 0x30
 800a91c:	7003      	strb	r3, [r0, #0]
 800a91e:	7011      	strb	r1, [r2, #0]
 800a920:	e71e      	b.n	800a760 <_dtoa_r+0x42c>
 800a922:	2101      	movs	r1, #1
 800a924:	9115      	str	r1, [sp, #84]	; 0x54
 800a926:	e5b9      	b.n	800a49c <_dtoa_r+0x168>
 800a928:	9910      	ldr	r1, [sp, #64]	; 0x40
 800a92a:	2900      	cmp	r1, #0
 800a92c:	f040 80c7 	bne.w	800aabe <_dtoa_r+0x78a>
 800a930:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800a932:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 800a934:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 800a936:	9308      	str	r3, [sp, #32]
 800a938:	2e00      	cmp	r6, #0
 800a93a:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800a93c:	bfd4      	ite	le
 800a93e:	2300      	movle	r3, #0
 800a940:	2301      	movgt	r3, #1
 800a942:	2800      	cmp	r0, #0
 800a944:	bfd4      	ite	le
 800a946:	2300      	movle	r3, #0
 800a948:	f003 0301 	andgt.w	r3, r3, #1
 800a94c:	b14b      	cbz	r3, 800a962 <_dtoa_r+0x62e>
 800a94e:	4603      	mov	r3, r0
 800a950:	990d      	ldr	r1, [sp, #52]	; 0x34
 800a952:	42b3      	cmp	r3, r6
 800a954:	bfa8      	it	ge
 800a956:	4633      	movge	r3, r6
 800a958:	1af6      	subs	r6, r6, r3
 800a95a:	1ac9      	subs	r1, r1, r3
 800a95c:	1ac0      	subs	r0, r0, r3
 800a95e:	910d      	str	r1, [sp, #52]	; 0x34
 800a960:	900b      	str	r0, [sp, #44]	; 0x2c
 800a962:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800a964:	2a00      	cmp	r2, #0
 800a966:	dd1a      	ble.n	800a99e <_dtoa_r+0x66a>
 800a968:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800a96a:	2b00      	cmp	r3, #0
 800a96c:	f000 8394 	beq.w	800b098 <_dtoa_r+0xd64>
 800a970:	2f00      	cmp	r7, #0
 800a972:	dd10      	ble.n	800a996 <_dtoa_r+0x662>
 800a974:	9908      	ldr	r1, [sp, #32]
 800a976:	463a      	mov	r2, r7
 800a978:	4620      	mov	r0, r4
 800a97a:	f001 fb91 	bl	800c0a0 <__pow5mult>
 800a97e:	4652      	mov	r2, sl
 800a980:	9008      	str	r0, [sp, #32]
 800a982:	4620      	mov	r0, r4
 800a984:	9908      	ldr	r1, [sp, #32]
 800a986:	f001 faf7 	bl	800bf78 <__multiply>
 800a98a:	4651      	mov	r1, sl
 800a98c:	4683      	mov	fp, r0
 800a98e:	4620      	mov	r0, r4
 800a990:	f001 f9ec 	bl	800bd6c <_Bfree>
 800a994:	46da      	mov	sl, fp
 800a996:	980f      	ldr	r0, [sp, #60]	; 0x3c
 800a998:	1bc2      	subs	r2, r0, r7
 800a99a:	f040 8384 	bne.w	800b0a6 <_dtoa_r+0xd72>
 800a99e:	2101      	movs	r1, #1
 800a9a0:	4620      	mov	r0, r4
 800a9a2:	f001 fadf 	bl	800bf64 <__i2b>
 800a9a6:	9911      	ldr	r1, [sp, #68]	; 0x44
 800a9a8:	2900      	cmp	r1, #0
 800a9aa:	4683      	mov	fp, r0
 800a9ac:	dd05      	ble.n	800a9ba <_dtoa_r+0x686>
 800a9ae:	4659      	mov	r1, fp
 800a9b0:	4620      	mov	r0, r4
 800a9b2:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800a9b4:	f001 fb74 	bl	800c0a0 <__pow5mult>
 800a9b8:	4683      	mov	fp, r0
 800a9ba:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800a9bc:	2a01      	cmp	r2, #1
 800a9be:	f340 819e 	ble.w	800acfe <_dtoa_r+0x9ca>
 800a9c2:	2700      	movs	r7, #0
 800a9c4:	9911      	ldr	r1, [sp, #68]	; 0x44
 800a9c6:	2900      	cmp	r1, #0
 800a9c8:	f040 82f2 	bne.w	800afb0 <_dtoa_r+0xc7c>
 800a9cc:	2301      	movs	r3, #1
 800a9ce:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800a9d0:	189b      	adds	r3, r3, r2
 800a9d2:	f013 031f 	ands.w	r3, r3, #31
 800a9d6:	f000 8222 	beq.w	800ae1e <_dtoa_r+0xaea>
 800a9da:	f1c3 0320 	rsb	r3, r3, #32
 800a9de:	2b04      	cmp	r3, #4
 800a9e0:	f340 83f6 	ble.w	800b1d0 <_dtoa_r+0xe9c>
 800a9e4:	3b04      	subs	r3, #4
 800a9e6:	980d      	ldr	r0, [sp, #52]	; 0x34
 800a9e8:	18f6      	adds	r6, r6, r3
 800a9ea:	18d2      	adds	r2, r2, r3
 800a9ec:	18c0      	adds	r0, r0, r3
 800a9ee:	920b      	str	r2, [sp, #44]	; 0x2c
 800a9f0:	900d      	str	r0, [sp, #52]	; 0x34
 800a9f2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800a9f4:	2b00      	cmp	r3, #0
 800a9f6:	dd05      	ble.n	800aa04 <_dtoa_r+0x6d0>
 800a9f8:	4651      	mov	r1, sl
 800a9fa:	4620      	mov	r0, r4
 800a9fc:	461a      	mov	r2, r3
 800a9fe:	f001 fba1 	bl	800c144 <__lshift>
 800aa02:	4682      	mov	sl, r0
 800aa04:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800aa06:	2800      	cmp	r0, #0
 800aa08:	dd05      	ble.n	800aa16 <_dtoa_r+0x6e2>
 800aa0a:	4659      	mov	r1, fp
 800aa0c:	4620      	mov	r0, r4
 800aa0e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800aa10:	f001 fb98 	bl	800c144 <__lshift>
 800aa14:	4683      	mov	fp, r0
 800aa16:	9915      	ldr	r1, [sp, #84]	; 0x54
 800aa18:	2900      	cmp	r1, #0
 800aa1a:	f040 82d3 	bne.w	800afc4 <_dtoa_r+0xc90>
 800aa1e:	9928      	ldr	r1, [sp, #160]	; 0xa0
 800aa20:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800aa22:	2902      	cmp	r1, #2
 800aa24:	bfd4      	ite	le
 800aa26:	2300      	movle	r3, #0
 800aa28:	2301      	movgt	r3, #1
 800aa2a:	2a00      	cmp	r2, #0
 800aa2c:	bfcc      	ite	gt
 800aa2e:	2300      	movgt	r3, #0
 800aa30:	f003 0301 	andle.w	r3, r3, #1
 800aa34:	2b00      	cmp	r3, #0
 800aa36:	f000 817c 	beq.w	800ad32 <_dtoa_r+0x9fe>
 800aa3a:	2a00      	cmp	r2, #0
 800aa3c:	f47f ae77 	bne.w	800a72e <_dtoa_r+0x3fa>
 800aa40:	4659      	mov	r1, fp
 800aa42:	2205      	movs	r2, #5
 800aa44:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800aa46:	4620      	mov	r0, r4
 800aa48:	f001 f9ac 	bl	800bda4 <__multadd>
 800aa4c:	4683      	mov	fp, r0
 800aa4e:	4650      	mov	r0, sl
 800aa50:	4659      	mov	r1, fp
 800aa52:	f001 fbcd 	bl	800c1f0 <__mcmp>
 800aa56:	2800      	cmp	r0, #0
 800aa58:	f77f ae69 	ble.w	800a72e <_dtoa_r+0x3fa>
 800aa5c:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 800aa5e:	2331      	movs	r3, #49	; 0x31
 800aa60:	3501      	adds	r5, #1
 800aa62:	2700      	movs	r7, #0
 800aa64:	f806 3b01 	strb.w	r3, [r6], #1
 800aa68:	e665      	b.n	800a736 <_dtoa_r+0x402>
 800aa6a:	2010      	movs	r0, #16
 800aa6c:	f7fb fd68 	bl	8006540 <malloc>
 800aa70:	6260      	str	r0, [r4, #36]	; 0x24
 800aa72:	6045      	str	r5, [r0, #4]
 800aa74:	6085      	str	r5, [r0, #8]
 800aa76:	6005      	str	r5, [r0, #0]
 800aa78:	60c5      	str	r5, [r0, #12]
 800aa7a:	e473      	b.n	800a364 <_dtoa_r+0x30>
 800aa7c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800aa7e:	4268      	negs	r0, r5
 800aa80:	2100      	movs	r1, #0
 800aa82:	900f      	str	r0, [sp, #60]	; 0x3c
 800aa84:	1b5b      	subs	r3, r3, r5
 800aa86:	9111      	str	r1, [sp, #68]	; 0x44
 800aa88:	930d      	str	r3, [sp, #52]	; 0x34
 800aa8a:	e517      	b.n	800a4bc <_dtoa_r+0x188>
 800aa8c:	4276      	negs	r6, r6
 800aa8e:	2300      	movs	r3, #0
 800aa90:	960d      	str	r6, [sp, #52]	; 0x34
 800aa92:	930b      	str	r3, [sp, #44]	; 0x2c
 800aa94:	e509      	b.n	800a4aa <_dtoa_r+0x176>
 800aa96:	2200      	movs	r2, #0
 800aa98:	9215      	str	r2, [sp, #84]	; 0x54
 800aa9a:	e4ff      	b.n	800a49c <_dtoa_r+0x168>
 800aa9c:	f240 23f8 	movw	r3, #760	; 0x2f8
 800aaa0:	4640      	mov	r0, r8
 800aaa2:	f6c0 0301 	movt	r3, #2049	; 0x801
 800aaa6:	4649      	mov	r1, r9
 800aaa8:	f006 060f 	and.w	r6, r6, #15
 800aaac:	f04f 0803 	mov.w	r8, #3
 800aab0:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 800aab4:	f004 fcfc 	bl	800f4b0 <__aeabi_ddiv>
 800aab8:	e9cd 0108 	strd	r0, r1, [sp, #32]
 800aabc:	e5a7      	b.n	800a60e <_dtoa_r+0x2da>
 800aabe:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800aac0:	2a01      	cmp	r2, #1
 800aac2:	f340 82f6 	ble.w	800b0b2 <_dtoa_r+0xd7e>
 800aac6:	990a      	ldr	r1, [sp, #40]	; 0x28
 800aac8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800aaca:	1e4b      	subs	r3, r1, #1
 800aacc:	429a      	cmp	r2, r3
 800aace:	bfa8      	it	ge
 800aad0:	ebc3 0702 	rsbge	r7, r3, r2
 800aad4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800aad6:	bfbf      	itttt	lt
 800aad8:	980f      	ldrlt	r0, [sp, #60]	; 0x3c
 800aada:	9911      	ldrlt	r1, [sp, #68]	; 0x44
 800aadc:	ebc0 0303 	rsblt	r3, r0, r3
 800aae0:	18c9      	addlt	r1, r1, r3
 800aae2:	bfbe      	ittt	lt
 800aae4:	18c0      	addlt	r0, r0, r3
 800aae6:	9111      	strlt	r1, [sp, #68]	; 0x44
 800aae8:	900f      	strlt	r0, [sp, #60]	; 0x3c
 800aaea:	2a00      	cmp	r2, #0
 800aaec:	f2c0 82f9 	blt.w	800b0e2 <_dtoa_r+0xdae>
 800aaf0:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 800aaf2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800aaf4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800aaf6:	4620      	mov	r0, r4
 800aaf8:	2101      	movs	r1, #1
 800aafa:	18d2      	adds	r2, r2, r3
 800aafc:	920d      	str	r2, [sp, #52]	; 0x34
 800aafe:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800ab00:	18d2      	adds	r2, r2, r3
 800ab02:	920b      	str	r2, [sp, #44]	; 0x2c
 800ab04:	f001 fa2e 	bl	800bf64 <__i2b>
 800ab08:	9008      	str	r0, [sp, #32]
 800ab0a:	e715      	b.n	800a938 <_dtoa_r+0x604>
 800ab0c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800ab0e:	2b00      	cmp	r3, #0
 800ab10:	f040 82d8 	bne.w	800b0c4 <_dtoa_r+0xd90>
 800ab14:	2300      	movs	r3, #0
 800ab16:	2200      	movs	r2, #0
 800ab18:	f2c4 0314 	movt	r3, #16404	; 0x4014
 800ab1c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800ab20:	f004 fb9c 	bl	800f25c <__aeabi_dmul>
 800ab24:	4642      	mov	r2, r8
 800ab26:	464b      	mov	r3, r9
 800ab28:	f004 fe1e 	bl	800f768 <__aeabi_dcmpge>
 800ab2c:	2800      	cmp	r0, #0
 800ab2e:	f47f adfa 	bne.w	800a726 <_dtoa_r+0x3f2>
 800ab32:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 800ab36:	f8cd b020 	str.w	fp, [sp, #32]
 800ab3a:	e78f      	b.n	800aa5c <_dtoa_r+0x728>
 800ab3c:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 800ab40:	9512      	str	r5, [sp, #72]	; 0x48
 800ab42:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800ab44:	2b00      	cmp	r3, #0
 800ab46:	f000 81af 	beq.w	800aea8 <_dtoa_r+0xb74>
 800ab4a:	f240 2330 	movw	r3, #560	; 0x230
 800ab4e:	2100      	movs	r1, #0
 800ab50:	f6c0 0301 	movt	r3, #2049	; 0x801
 800ab54:	2000      	movs	r0, #0
 800ab56:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 800ab5a:	f6c3 71e0 	movt	r1, #16352	; 0x3fe0
 800ab5e:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 800ab60:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 800ab64:	f004 fca4 	bl	800f4b0 <__aeabi_ddiv>
 800ab68:	4642      	mov	r2, r8
 800ab6a:	464b      	mov	r3, r9
 800ab6c:	f7fb f9bc 	bl	8005ee8 <__aeabi_dsub>
 800ab70:	4680      	mov	r8, r0
 800ab72:	4689      	mov	r9, r1
 800ab74:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800ab78:	f004 fe0a 	bl	800f790 <__aeabi_d2iz>
 800ab7c:	4607      	mov	r7, r0
 800ab7e:	f7fb fb01 	bl	8006184 <__aeabi_i2d>
 800ab82:	4602      	mov	r2, r0
 800ab84:	460b      	mov	r3, r1
 800ab86:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800ab8a:	f7fb f9ad 	bl	8005ee8 <__aeabi_dsub>
 800ab8e:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800ab92:	e9cd 0108 	strd	r0, r1, [sp, #32]
 800ab96:	4640      	mov	r0, r8
 800ab98:	f806 3b01 	strb.w	r3, [r6], #1
 800ab9c:	4649      	mov	r1, r9
 800ab9e:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 800aba2:	f004 fdeb 	bl	800f77c <__aeabi_dcmpgt>
 800aba6:	2800      	cmp	r0, #0
 800aba8:	f040 81fc 	bne.w	800afa4 <_dtoa_r+0xc70>
 800abac:	2100      	movs	r1, #0
 800abae:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 800abb2:	2000      	movs	r0, #0
 800abb4:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
 800abb8:	f7fb f996 	bl	8005ee8 <__aeabi_dsub>
 800abbc:	4602      	mov	r2, r0
 800abbe:	460b      	mov	r3, r1
 800abc0:	4640      	mov	r0, r8
 800abc2:	4649      	mov	r1, r9
 800abc4:	f004 fdda 	bl	800f77c <__aeabi_dcmpgt>
 800abc8:	2800      	cmp	r0, #0
 800abca:	f47f ae96 	bne.w	800a8fa <_dtoa_r+0x5c6>
 800abce:	f1bb 0f01 	cmp.w	fp, #1
 800abd2:	f77f add9 	ble.w	800a788 <_dtoa_r+0x454>
 800abd6:	980c      	ldr	r0, [sp, #48]	; 0x30
 800abd8:	4637      	mov	r7, r6
 800abda:	9518      	str	r5, [sp, #96]	; 0x60
 800abdc:	4483      	add	fp, r0
 800abde:	f8cd a05c 	str.w	sl, [sp, #92]	; 0x5c
 800abe2:	465d      	mov	r5, fp
 800abe4:	e9dd ab08 	ldrd	sl, fp, [sp, #32]
 800abe8:	9408      	str	r4, [sp, #32]
 800abea:	e00f      	b.n	800ac0c <_dtoa_r+0x8d8>
 800abec:	2100      	movs	r1, #0
 800abee:	2000      	movs	r0, #0
 800abf0:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
 800abf4:	f7fb f978 	bl	8005ee8 <__aeabi_dsub>
 800abf8:	4642      	mov	r2, r8
 800abfa:	464b      	mov	r3, r9
 800abfc:	f004 fda0 	bl	800f740 <__aeabi_dcmplt>
 800ac00:	2800      	cmp	r0, #0
 800ac02:	f040 826a 	bne.w	800b0da <_dtoa_r+0xda6>
 800ac06:	42af      	cmp	r7, r5
 800ac08:	f43f adba 	beq.w	800a780 <_dtoa_r+0x44c>
 800ac0c:	2300      	movs	r3, #0
 800ac0e:	2200      	movs	r2, #0
 800ac10:	f2c4 0324 	movt	r3, #16420	; 0x4024
 800ac14:	4640      	mov	r0, r8
 800ac16:	4649      	mov	r1, r9
 800ac18:	f004 fb20 	bl	800f25c <__aeabi_dmul>
 800ac1c:	2300      	movs	r3, #0
 800ac1e:	2200      	movs	r2, #0
 800ac20:	f2c4 0324 	movt	r3, #16420	; 0x4024
 800ac24:	4680      	mov	r8, r0
 800ac26:	4689      	mov	r9, r1
 800ac28:	4650      	mov	r0, sl
 800ac2a:	4659      	mov	r1, fp
 800ac2c:	f004 fb16 	bl	800f25c <__aeabi_dmul>
 800ac30:	468b      	mov	fp, r1
 800ac32:	4682      	mov	sl, r0
 800ac34:	f004 fdac 	bl	800f790 <__aeabi_d2iz>
 800ac38:	4604      	mov	r4, r0
 800ac3a:	f7fb faa3 	bl	8006184 <__aeabi_i2d>
 800ac3e:	3430      	adds	r4, #48	; 0x30
 800ac40:	4602      	mov	r2, r0
 800ac42:	460b      	mov	r3, r1
 800ac44:	4650      	mov	r0, sl
 800ac46:	4659      	mov	r1, fp
 800ac48:	f7fb f94e 	bl	8005ee8 <__aeabi_dsub>
 800ac4c:	4642      	mov	r2, r8
 800ac4e:	464b      	mov	r3, r9
 800ac50:	f807 4b01 	strb.w	r4, [r7], #1
 800ac54:	463e      	mov	r6, r7
 800ac56:	4682      	mov	sl, r0
 800ac58:	468b      	mov	fp, r1
 800ac5a:	f004 fd71 	bl	800f740 <__aeabi_dcmplt>
 800ac5e:	4652      	mov	r2, sl
 800ac60:	465b      	mov	r3, fp
 800ac62:	2800      	cmp	r0, #0
 800ac64:	d0c2      	beq.n	800abec <_dtoa_r+0x8b8>
 800ac66:	f8dd a05c 	ldr.w	sl, [sp, #92]	; 0x5c
 800ac6a:	9c08      	ldr	r4, [sp, #32]
 800ac6c:	9d12      	ldr	r5, [sp, #72]	; 0x48
 800ac6e:	e577      	b.n	800a760 <_dtoa_r+0x42c>
 800ac70:	2600      	movs	r6, #0
 800ac72:	e4fc      	b.n	800a66e <_dtoa_r+0x33a>
 800ac74:	2301      	movs	r3, #1
 800ac76:	9310      	str	r3, [sp, #64]	; 0x40
 800ac78:	9929      	ldr	r1, [sp, #164]	; 0xa4
 800ac7a:	2900      	cmp	r1, #0
 800ac7c:	bfc2      	ittt	gt
 800ac7e:	468b      	movgt	fp, r1
 800ac80:	910e      	strgt	r1, [sp, #56]	; 0x38
 800ac82:	910a      	strgt	r1, [sp, #40]	; 0x28
 800ac84:	f340 81b4 	ble.w	800aff0 <_dtoa_r+0xcbc>
 800ac88:	6a66      	ldr	r6, [r4, #36]	; 0x24
 800ac8a:	2200      	movs	r2, #0
 800ac8c:	f1bb 0f17 	cmp.w	fp, #23
 800ac90:	6072      	str	r2, [r6, #4]
 800ac92:	f240 82a1 	bls.w	800b1d8 <_dtoa_r+0xea4>
 800ac96:	2304      	movs	r3, #4
 800ac98:	005b      	lsls	r3, r3, #1
 800ac9a:	3201      	adds	r2, #1
 800ac9c:	f103 0114 	add.w	r1, r3, #20
 800aca0:	4559      	cmp	r1, fp
 800aca2:	d9f9      	bls.n	800ac98 <_dtoa_r+0x964>
 800aca4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800aca6:	6072      	str	r2, [r6, #4]
 800aca8:	2b0e      	cmp	r3, #14
 800acaa:	bf8c      	ite	hi
 800acac:	2700      	movhi	r7, #0
 800acae:	f007 0701 	andls.w	r7, r7, #1
 800acb2:	e484      	b.n	800a5be <_dtoa_r+0x28a>
 800acb4:	2300      	movs	r3, #0
 800acb6:	9310      	str	r3, [sp, #64]	; 0x40
 800acb8:	9829      	ldr	r0, [sp, #164]	; 0xa4
 800acba:	1828      	adds	r0, r5, r0
 800acbc:	900e      	str	r0, [sp, #56]	; 0x38
 800acbe:	f100 0b01 	add.w	fp, r0, #1
 800acc2:	f1bb 0f00 	cmp.w	fp, #0
 800acc6:	bfc8      	it	gt
 800acc8:	f8cd b028 	strgt.w	fp, [sp, #40]	; 0x28
 800accc:	dcdc      	bgt.n	800ac88 <_dtoa_r+0x954>
 800acce:	f1bb 0f0e 	cmp.w	fp, #14
 800acd2:	bf8c      	ite	hi
 800acd4:	2700      	movhi	r7, #0
 800acd6:	f007 0701 	andls.w	r7, r7, #1
 800acda:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
 800acde:	e46b      	b.n	800a5b8 <_dtoa_r+0x284>
 800ace0:	2000      	movs	r0, #0
 800ace2:	9010      	str	r0, [sp, #64]	; 0x40
 800ace4:	e7c8      	b.n	800ac78 <_dtoa_r+0x944>
 800ace6:	2201      	movs	r2, #1
 800ace8:	9210      	str	r2, [sp, #64]	; 0x40
 800acea:	e7e5      	b.n	800acb8 <_dtoa_r+0x984>
 800acec:	f04f 33ff 	mov.w	r3, #4294967295
 800acf0:	2700      	movs	r7, #0
 800acf2:	2001      	movs	r0, #1
 800acf4:	930e      	str	r3, [sp, #56]	; 0x38
 800acf6:	9010      	str	r0, [sp, #64]	; 0x40
 800acf8:	930a      	str	r3, [sp, #40]	; 0x28
 800acfa:	9729      	str	r7, [sp, #164]	; 0xa4
 800acfc:	e45c      	b.n	800a5b8 <_dtoa_r+0x284>
 800acfe:	f1b8 0f00 	cmp.w	r8, #0
 800ad02:	f47f ae5e 	bne.w	800a9c2 <_dtoa_r+0x68e>
 800ad06:	f3c9 0313 	ubfx	r3, r9, #0, #20
 800ad0a:	4647      	mov	r7, r8
 800ad0c:	2b00      	cmp	r3, #0
 800ad0e:	f47f ae59 	bne.w	800a9c4 <_dtoa_r+0x690>
 800ad12:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 800ad16:	ea09 0303 	and.w	r3, r9, r3
 800ad1a:	461f      	mov	r7, r3
 800ad1c:	2b00      	cmp	r3, #0
 800ad1e:	f43f ae51 	beq.w	800a9c4 <_dtoa_r+0x690>
 800ad22:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ad24:	2701      	movs	r7, #1
 800ad26:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800ad28:	3301      	adds	r3, #1
 800ad2a:	930d      	str	r3, [sp, #52]	; 0x34
 800ad2c:	3001      	adds	r0, #1
 800ad2e:	900b      	str	r0, [sp, #44]	; 0x2c
 800ad30:	e648      	b.n	800a9c4 <_dtoa_r+0x690>
 800ad32:	9810      	ldr	r0, [sp, #64]	; 0x40
 800ad34:	2800      	cmp	r0, #0
 800ad36:	f000 8161 	beq.w	800affc <_dtoa_r+0xcc8>
 800ad3a:	2e00      	cmp	r6, #0
 800ad3c:	dd05      	ble.n	800ad4a <_dtoa_r+0xa16>
 800ad3e:	4620      	mov	r0, r4
 800ad40:	9908      	ldr	r1, [sp, #32]
 800ad42:	4632      	mov	r2, r6
 800ad44:	f001 f9fe 	bl	800c144 <__lshift>
 800ad48:	9008      	str	r0, [sp, #32]
 800ad4a:	2f00      	cmp	r7, #0
 800ad4c:	f040 81ed 	bne.w	800b12a <_dtoa_r+0xdf6>
 800ad50:	9808      	ldr	r0, [sp, #32]
 800ad52:	9002      	str	r0, [sp, #8]
 800ad54:	990a      	ldr	r1, [sp, #40]	; 0x28
 800ad56:	f008 0201 	and.w	r2, r8, #1
 800ad5a:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 800ad5c:	9f08      	ldr	r7, [sp, #32]
 800ad5e:	1871      	adds	r1, r6, r1
 800ad60:	920a      	str	r2, [sp, #40]	; 0x28
 800ad62:	910b      	str	r1, [sp, #44]	; 0x2c
 800ad64:	9508      	str	r5, [sp, #32]
 800ad66:	4659      	mov	r1, fp
 800ad68:	4650      	mov	r0, sl
 800ad6a:	f7ff fa4d 	bl	800a208 <quorem>
 800ad6e:	4639      	mov	r1, r7
 800ad70:	f04f 0901 	mov.w	r9, #1
 800ad74:	3030      	adds	r0, #48	; 0x30
 800ad76:	9007      	str	r0, [sp, #28]
 800ad78:	4650      	mov	r0, sl
 800ad7a:	f001 fa39 	bl	800c1f0 <__mcmp>
 800ad7e:	4659      	mov	r1, fp
 800ad80:	9a02      	ldr	r2, [sp, #8]
 800ad82:	4605      	mov	r5, r0
 800ad84:	4620      	mov	r0, r4
 800ad86:	f001 fa51 	bl	800c22c <__mdiff>
 800ad8a:	68c3      	ldr	r3, [r0, #12]
 800ad8c:	4680      	mov	r8, r0
 800ad8e:	2b00      	cmp	r3, #0
 800ad90:	d03a      	beq.n	800ae08 <_dtoa_r+0xad4>
 800ad92:	4620      	mov	r0, r4
 800ad94:	4641      	mov	r1, r8
 800ad96:	f000 ffe9 	bl	800bd6c <_Bfree>
 800ad9a:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 800ad9c:	ea59 0303 	orrs.w	r3, r9, r3
 800ada0:	d103      	bne.n	800adaa <_dtoa_r+0xa76>
 800ada2:	980a      	ldr	r0, [sp, #40]	; 0x28
 800ada4:	2800      	cmp	r0, #0
 800ada6:	f000 81f3 	beq.w	800b190 <_dtoa_r+0xe5c>
 800adaa:	2d00      	cmp	r5, #0
 800adac:	f2c0 819d 	blt.w	800b0ea <_dtoa_r+0xdb6>
 800adb0:	9828      	ldr	r0, [sp, #160]	; 0xa0
 800adb2:	4328      	orrs	r0, r5
 800adb4:	d103      	bne.n	800adbe <_dtoa_r+0xa8a>
 800adb6:	990a      	ldr	r1, [sp, #40]	; 0x28
 800adb8:	2900      	cmp	r1, #0
 800adba:	f000 8196 	beq.w	800b0ea <_dtoa_r+0xdb6>
 800adbe:	f1b9 0f00 	cmp.w	r9, #0
 800adc2:	f300 81d2 	bgt.w	800b16a <_dtoa_r+0xe36>
 800adc6:	9a07      	ldr	r2, [sp, #28]
 800adc8:	f806 2b01 	strb.w	r2, [r6], #1
 800adcc:	46b0      	mov	r8, r6
 800adce:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800add0:	429e      	cmp	r6, r3
 800add2:	f000 81c6 	beq.w	800b162 <_dtoa_r+0xe2e>
 800add6:	4651      	mov	r1, sl
 800add8:	220a      	movs	r2, #10
 800adda:	2300      	movs	r3, #0
 800addc:	4620      	mov	r0, r4
 800adde:	f000 ffe1 	bl	800bda4 <__multadd>
 800ade2:	4682      	mov	sl, r0
 800ade4:	9802      	ldr	r0, [sp, #8]
 800ade6:	4287      	cmp	r7, r0
 800ade8:	d022      	beq.n	800ae30 <_dtoa_r+0xafc>
 800adea:	4639      	mov	r1, r7
 800adec:	220a      	movs	r2, #10
 800adee:	2300      	movs	r3, #0
 800adf0:	4620      	mov	r0, r4
 800adf2:	f000 ffd7 	bl	800bda4 <__multadd>
 800adf6:	9902      	ldr	r1, [sp, #8]
 800adf8:	220a      	movs	r2, #10
 800adfa:	2300      	movs	r3, #0
 800adfc:	4607      	mov	r7, r0
 800adfe:	4620      	mov	r0, r4
 800ae00:	f000 ffd0 	bl	800bda4 <__multadd>
 800ae04:	9002      	str	r0, [sp, #8]
 800ae06:	e7ae      	b.n	800ad66 <_dtoa_r+0xa32>
 800ae08:	4650      	mov	r0, sl
 800ae0a:	4641      	mov	r1, r8
 800ae0c:	f001 f9f0 	bl	800c1f0 <__mcmp>
 800ae10:	4681      	mov	r9, r0
 800ae12:	e7be      	b.n	800ad92 <_dtoa_r+0xa5e>
 800ae14:	4620      	mov	r0, r4
 800ae16:	4639      	mov	r1, r7
 800ae18:	f000 ffa8 	bl	800bd6c <_Bfree>
 800ae1c:	e49c      	b.n	800a758 <_dtoa_r+0x424>
 800ae1e:	231c      	movs	r3, #28
 800ae20:	990d      	ldr	r1, [sp, #52]	; 0x34
 800ae22:	18f6      	adds	r6, r6, r3
 800ae24:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800ae26:	18c9      	adds	r1, r1, r3
 800ae28:	910d      	str	r1, [sp, #52]	; 0x34
 800ae2a:	18d2      	adds	r2, r2, r3
 800ae2c:	920b      	str	r2, [sp, #44]	; 0x2c
 800ae2e:	e5e0      	b.n	800a9f2 <_dtoa_r+0x6be>
 800ae30:	4639      	mov	r1, r7
 800ae32:	4620      	mov	r0, r4
 800ae34:	220a      	movs	r2, #10
 800ae36:	2300      	movs	r3, #0
 800ae38:	f000 ffb4 	bl	800bda4 <__multadd>
 800ae3c:	4607      	mov	r7, r0
 800ae3e:	9002      	str	r0, [sp, #8]
 800ae40:	e791      	b.n	800ad66 <_dtoa_r+0xa32>
 800ae42:	426e      	negs	r6, r5
 800ae44:	2e00      	cmp	r6, #0
 800ae46:	f000 811d 	beq.w	800b084 <_dtoa_r+0xd50>
 800ae4a:	f006 030f 	and.w	r3, r6, #15
 800ae4e:	f240 2230 	movw	r2, #560	; 0x230
 800ae52:	f6c0 0201 	movt	r2, #2049	; 0x801
 800ae56:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800ae5a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800ae5e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ae62:	f004 f9fb 	bl	800f25c <__aeabi_dmul>
 800ae66:	1136      	asrs	r6, r6, #4
 800ae68:	e9cd 0108 	strd	r0, r1, [sp, #32]
 800ae6c:	f000 810a 	beq.w	800b084 <_dtoa_r+0xd50>
 800ae70:	f240 27f8 	movw	r7, #760	; 0x2f8
 800ae74:	f04f 0802 	mov.w	r8, #2
 800ae78:	f6c0 0701 	movt	r7, #2049	; 0x801
 800ae7c:	4602      	mov	r2, r0
 800ae7e:	460b      	mov	r3, r1
 800ae80:	f016 0f01 	tst.w	r6, #1
 800ae84:	4610      	mov	r0, r2
 800ae86:	4619      	mov	r1, r3
 800ae88:	d007      	beq.n	800ae9a <_dtoa_r+0xb66>
 800ae8a:	e9d7 2300 	ldrd	r2, r3, [r7]
 800ae8e:	f108 0801 	add.w	r8, r8, #1
 800ae92:	f004 f9e3 	bl	800f25c <__aeabi_dmul>
 800ae96:	4602      	mov	r2, r0
 800ae98:	460b      	mov	r3, r1
 800ae9a:	3708      	adds	r7, #8
 800ae9c:	1076      	asrs	r6, r6, #1
 800ae9e:	d1ef      	bne.n	800ae80 <_dtoa_r+0xb4c>
 800aea0:	e9cd 2308 	strd	r2, r3, [sp, #32]
 800aea4:	f7ff bbd4 	b.w	800a650 <_dtoa_r+0x31c>
 800aea8:	f10b 32ff 	add.w	r2, fp, #4294967295
 800aeac:	9217      	str	r2, [sp, #92]	; 0x5c
 800aeae:	9817      	ldr	r0, [sp, #92]	; 0x5c
 800aeb0:	f240 2130 	movw	r1, #560	; 0x230
 800aeb4:	f6c0 0101 	movt	r1, #2049	; 0x801
 800aeb8:	4642      	mov	r2, r8
 800aeba:	464b      	mov	r3, r9
 800aebc:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 800aebe:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 800aec2:	e9d1 0100 	ldrd	r0, r1, [r1]
 800aec6:	f004 f9c9 	bl	800f25c <__aeabi_dmul>
 800aeca:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
 800aece:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800aed2:	f004 fc5d 	bl	800f790 <__aeabi_d2iz>
 800aed6:	4607      	mov	r7, r0
 800aed8:	f7fb f954 	bl	8006184 <__aeabi_i2d>
 800aedc:	460b      	mov	r3, r1
 800aede:	4602      	mov	r2, r0
 800aee0:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800aee4:	f7fb f800 	bl	8005ee8 <__aeabi_dsub>
 800aee8:	f1bb 0f01 	cmp.w	fp, #1
 800aeec:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800aef0:	e9cd 0108 	strd	r0, r1, [sp, #32]
 800aef4:	f806 3b01 	strb.w	r3, [r6], #1
 800aef8:	d02b      	beq.n	800af52 <_dtoa_r+0xc1e>
 800aefa:	990c      	ldr	r1, [sp, #48]	; 0x30
 800aefc:	951b      	str	r5, [sp, #108]	; 0x6c
 800aefe:	f101 39ff 	add.w	r9, r1, #4294967295
 800af02:	460f      	mov	r7, r1
 800af04:	44d9      	add	r9, fp
 800af06:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800af0a:	46d3      	mov	fp, sl
 800af0c:	464d      	mov	r5, r9
 800af0e:	46b2      	mov	sl, r6
 800af10:	4626      	mov	r6, r4
 800af12:	2300      	movs	r3, #0
 800af14:	2200      	movs	r2, #0
 800af16:	f2c4 0324 	movt	r3, #16420	; 0x4024
 800af1a:	f004 f99f 	bl	800f25c <__aeabi_dmul>
 800af1e:	4689      	mov	r9, r1
 800af20:	4680      	mov	r8, r0
 800af22:	f004 fc35 	bl	800f790 <__aeabi_d2iz>
 800af26:	4604      	mov	r4, r0
 800af28:	f7fb f92c 	bl	8006184 <__aeabi_i2d>
 800af2c:	3430      	adds	r4, #48	; 0x30
 800af2e:	4602      	mov	r2, r0
 800af30:	460b      	mov	r3, r1
 800af32:	4640      	mov	r0, r8
 800af34:	4649      	mov	r1, r9
 800af36:	f7fa ffd7 	bl	8005ee8 <__aeabi_dsub>
 800af3a:	f807 4f01 	strb.w	r4, [r7, #1]!
 800af3e:	42af      	cmp	r7, r5
 800af40:	d1e7      	bne.n	800af12 <_dtoa_r+0xbde>
 800af42:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 800af44:	4634      	mov	r4, r6
 800af46:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
 800af48:	4656      	mov	r6, sl
 800af4a:	18b6      	adds	r6, r6, r2
 800af4c:	46da      	mov	sl, fp
 800af4e:	e9cd 0108 	strd	r0, r1, [sp, #32]
 800af52:	2300      	movs	r3, #0
 800af54:	2200      	movs	r2, #0
 800af56:	f6c3 73e0 	movt	r3, #16352	; 0x3fe0
 800af5a:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
 800af5e:	f7fa ffc5 	bl	8005eec <__adddf3>
 800af62:	4602      	mov	r2, r0
 800af64:	460b      	mov	r3, r1
 800af66:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800af6a:	f004 fc07 	bl	800f77c <__aeabi_dcmpgt>
 800af6e:	2800      	cmp	r0, #0
 800af70:	f47f acc3 	bne.w	800a8fa <_dtoa_r+0x5c6>
 800af74:	2100      	movs	r1, #0
 800af76:	e9dd 2318 	ldrd	r2, r3, [sp, #96]	; 0x60
 800af7a:	2000      	movs	r0, #0
 800af7c:	f6c3 71e0 	movt	r1, #16352	; 0x3fe0
 800af80:	f7fa ffb2 	bl	8005ee8 <__aeabi_dsub>
 800af84:	4602      	mov	r2, r0
 800af86:	460b      	mov	r3, r1
 800af88:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800af8c:	f004 fbd8 	bl	800f740 <__aeabi_dcmplt>
 800af90:	2800      	cmp	r0, #0
 800af92:	f43f abf9 	beq.w	800a788 <_dtoa_r+0x454>
 800af96:	4633      	mov	r3, r6
 800af98:	461e      	mov	r6, r3
 800af9a:	3b01      	subs	r3, #1
 800af9c:	f816 2c01 	ldrb.w	r2, [r6, #-1]
 800afa0:	2a30      	cmp	r2, #48	; 0x30
 800afa2:	d0f9      	beq.n	800af98 <_dtoa_r+0xc64>
 800afa4:	9d12      	ldr	r5, [sp, #72]	; 0x48
 800afa6:	f7ff bbdb 	b.w	800a760 <_dtoa_r+0x42c>
 800afaa:	980c      	ldr	r0, [sp, #48]	; 0x30
 800afac:	f7ff ba04 	b.w	800a3b8 <_dtoa_r+0x84>
 800afb0:	f8db 3010 	ldr.w	r3, [fp, #16]
 800afb4:	eb0b 0383 	add.w	r3, fp, r3, lsl #2
 800afb8:	6918      	ldr	r0, [r3, #16]
 800afba:	f000 ff81 	bl	800bec0 <__hi0bits>
 800afbe:	f1c0 0320 	rsb	r3, r0, #32
 800afc2:	e504      	b.n	800a9ce <_dtoa_r+0x69a>
 800afc4:	4650      	mov	r0, sl
 800afc6:	4659      	mov	r1, fp
 800afc8:	f001 f912 	bl	800c1f0 <__mcmp>
 800afcc:	2800      	cmp	r0, #0
 800afce:	f6bf ad26 	bge.w	800aa1e <_dtoa_r+0x6ea>
 800afd2:	4651      	mov	r1, sl
 800afd4:	220a      	movs	r2, #10
 800afd6:	4620      	mov	r0, r4
 800afd8:	2300      	movs	r3, #0
 800afda:	f000 fee3 	bl	800bda4 <__multadd>
 800afde:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800afe0:	3d01      	subs	r5, #1
 800afe2:	4682      	mov	sl, r0
 800afe4:	2a00      	cmp	r2, #0
 800afe6:	f040 80e9 	bne.w	800b1bc <_dtoa_r+0xe88>
 800afea:	980e      	ldr	r0, [sp, #56]	; 0x38
 800afec:	900a      	str	r0, [sp, #40]	; 0x28
 800afee:	e516      	b.n	800aa1e <_dtoa_r+0x6ea>
 800aff0:	2201      	movs	r2, #1
 800aff2:	920e      	str	r2, [sp, #56]	; 0x38
 800aff4:	920a      	str	r2, [sp, #40]	; 0x28
 800aff6:	9229      	str	r2, [sp, #164]	; 0xa4
 800aff8:	f7ff bade 	b.w	800a5b8 <_dtoa_r+0x284>
 800affc:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 800affe:	2701      	movs	r7, #1
 800b000:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
 800b004:	9502      	str	r5, [sp, #8]
 800b006:	e002      	b.n	800b00e <_dtoa_r+0xcda>
 800b008:	f000 fecc 	bl	800bda4 <__multadd>
 800b00c:	4682      	mov	sl, r0
 800b00e:	4659      	mov	r1, fp
 800b010:	4650      	mov	r0, sl
 800b012:	f7ff f8f9 	bl	800a208 <quorem>
 800b016:	220a      	movs	r2, #10
 800b018:	2300      	movs	r3, #0
 800b01a:	454f      	cmp	r7, r9
 800b01c:	4651      	mov	r1, sl
 800b01e:	f107 0701 	add.w	r7, r7, #1
 800b022:	f100 0530 	add.w	r5, r0, #48	; 0x30
 800b026:	4620      	mov	r0, r4
 800b028:	f806 5b01 	strb.w	r5, [r6], #1
 800b02c:	46b0      	mov	r8, r6
 800b02e:	dbeb      	blt.n	800b008 <_dtoa_r+0xcd4>
 800b030:	9507      	str	r5, [sp, #28]
 800b032:	2700      	movs	r7, #0
 800b034:	9d02      	ldr	r5, [sp, #8]
 800b036:	4651      	mov	r1, sl
 800b038:	2201      	movs	r2, #1
 800b03a:	4620      	mov	r0, r4
 800b03c:	f001 f882 	bl	800c144 <__lshift>
 800b040:	4659      	mov	r1, fp
 800b042:	4682      	mov	sl, r0
 800b044:	f001 f8d4 	bl	800c1f0 <__mcmp>
 800b048:	2800      	cmp	r0, #0
 800b04a:	dd0f      	ble.n	800b06c <_dtoa_r+0xd38>
 800b04c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800b04e:	4646      	mov	r6, r8
 800b050:	f108 38ff 	add.w	r8, r8, #4294967295
 800b054:	f816 3c01 	ldrb.w	r3, [r6, #-1]
 800b058:	2b39      	cmp	r3, #57	; 0x39
 800b05a:	d161      	bne.n	800b120 <_dtoa_r+0xdec>
 800b05c:	4590      	cmp	r8, r2
 800b05e:	d1f6      	bne.n	800b04e <_dtoa_r+0xd1a>
 800b060:	980c      	ldr	r0, [sp, #48]	; 0x30
 800b062:	2331      	movs	r3, #49	; 0x31
 800b064:	3501      	adds	r5, #1
 800b066:	7003      	strb	r3, [r0, #0]
 800b068:	f7ff bb65 	b.w	800a736 <_dtoa_r+0x402>
 800b06c:	d103      	bne.n	800b076 <_dtoa_r+0xd42>
 800b06e:	9a07      	ldr	r2, [sp, #28]
 800b070:	f012 0f01 	tst.w	r2, #1
 800b074:	d1ea      	bne.n	800b04c <_dtoa_r+0xd18>
 800b076:	4646      	mov	r6, r8
 800b078:	f818 3d01 	ldrb.w	r3, [r8, #-1]!
 800b07c:	2b30      	cmp	r3, #48	; 0x30
 800b07e:	d0fa      	beq.n	800b076 <_dtoa_r+0xd42>
 800b080:	f7ff bb59 	b.w	800a736 <_dtoa_r+0x402>
 800b084:	f04f 0802 	mov.w	r8, #2
 800b088:	f7ff bae2 	b.w	800a650 <_dtoa_r+0x31c>
 800b08c:	9d07      	ldr	r5, [sp, #28]
 800b08e:	4644      	mov	r4, r8
 800b090:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 800b094:	f7ff bb64 	b.w	800a760 <_dtoa_r+0x42c>
 800b098:	4651      	mov	r1, sl
 800b09a:	4620      	mov	r0, r4
 800b09c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800b09e:	f000 ffff 	bl	800c0a0 <__pow5mult>
 800b0a2:	4682      	mov	sl, r0
 800b0a4:	e47b      	b.n	800a99e <_dtoa_r+0x66a>
 800b0a6:	4651      	mov	r1, sl
 800b0a8:	4620      	mov	r0, r4
 800b0aa:	f000 fff9 	bl	800c0a0 <__pow5mult>
 800b0ae:	4682      	mov	sl, r0
 800b0b0:	e475      	b.n	800a99e <_dtoa_r+0x66a>
 800b0b2:	9816      	ldr	r0, [sp, #88]	; 0x58
 800b0b4:	2800      	cmp	r0, #0
 800b0b6:	d04e      	beq.n	800b156 <_dtoa_r+0xe22>
 800b0b8:	f503 6386 	add.w	r3, r3, #1072	; 0x430
 800b0bc:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 800b0be:	3303      	adds	r3, #3
 800b0c0:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 800b0c2:	e517      	b.n	800aaf4 <_dtoa_r+0x7c0>
 800b0c4:	f04f 0b00 	mov.w	fp, #0
 800b0c8:	f8cd b020 	str.w	fp, [sp, #32]
 800b0cc:	f7ff bb2f 	b.w	800a72e <_dtoa_r+0x3fa>
 800b0d0:	3101      	adds	r1, #1
 800b0d2:	9d12      	ldr	r5, [sp, #72]	; 0x48
 800b0d4:	7011      	strb	r1, [r2, #0]
 800b0d6:	f7ff bb43 	b.w	800a760 <_dtoa_r+0x42c>
 800b0da:	f8dd a05c 	ldr.w	sl, [sp, #92]	; 0x5c
 800b0de:	9c08      	ldr	r4, [sp, #32]
 800b0e0:	e40b      	b.n	800a8fa <_dtoa_r+0x5c6>
 800b0e2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800b0e4:	1a9e      	subs	r6, r3, r2
 800b0e6:	2300      	movs	r3, #0
 800b0e8:	e504      	b.n	800aaf4 <_dtoa_r+0x7c0>
 800b0ea:	f1b9 0f00 	cmp.w	r9, #0
 800b0ee:	9d08      	ldr	r5, [sp, #32]
 800b0f0:	dd0f      	ble.n	800b112 <_dtoa_r+0xdde>
 800b0f2:	4651      	mov	r1, sl
 800b0f4:	2201      	movs	r2, #1
 800b0f6:	4620      	mov	r0, r4
 800b0f8:	f001 f824 	bl	800c144 <__lshift>
 800b0fc:	4659      	mov	r1, fp
 800b0fe:	4682      	mov	sl, r0
 800b100:	f001 f876 	bl	800c1f0 <__mcmp>
 800b104:	2800      	cmp	r0, #0
 800b106:	dd53      	ble.n	800b1b0 <_dtoa_r+0xe7c>
 800b108:	9b07      	ldr	r3, [sp, #28]
 800b10a:	2b39      	cmp	r3, #57	; 0x39
 800b10c:	d039      	beq.n	800b182 <_dtoa_r+0xe4e>
 800b10e:	3301      	adds	r3, #1
 800b110:	9307      	str	r3, [sp, #28]
 800b112:	9802      	ldr	r0, [sp, #8]
 800b114:	9907      	ldr	r1, [sp, #28]
 800b116:	9008      	str	r0, [sp, #32]
 800b118:	f806 1b01 	strb.w	r1, [r6], #1
 800b11c:	f7ff bb0b 	b.w	800a736 <_dtoa_r+0x402>
 800b120:	3301      	adds	r3, #1
 800b122:	f888 3000 	strb.w	r3, [r8]
 800b126:	f7ff bb06 	b.w	800a736 <_dtoa_r+0x402>
 800b12a:	9a08      	ldr	r2, [sp, #32]
 800b12c:	4620      	mov	r0, r4
 800b12e:	6851      	ldr	r1, [r2, #4]
 800b130:	f000 fde8 	bl	800bd04 <_Balloc>
 800b134:	9b08      	ldr	r3, [sp, #32]
 800b136:	f103 010c 	add.w	r1, r3, #12
 800b13a:	691a      	ldr	r2, [r3, #16]
 800b13c:	3202      	adds	r2, #2
 800b13e:	0092      	lsls	r2, r2, #2
 800b140:	4606      	mov	r6, r0
 800b142:	300c      	adds	r0, #12
 800b144:	f000 fcdc 	bl	800bb00 <memcpy>
 800b148:	4620      	mov	r0, r4
 800b14a:	4631      	mov	r1, r6
 800b14c:	2201      	movs	r2, #1
 800b14e:	f000 fff9 	bl	800c144 <__lshift>
 800b152:	9002      	str	r0, [sp, #8]
 800b154:	e5fe      	b.n	800ad54 <_dtoa_r+0xa20>
 800b156:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 800b158:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 800b15a:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 800b15c:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 800b160:	e4c8      	b.n	800aaf4 <_dtoa_r+0x7c0>
 800b162:	9902      	ldr	r1, [sp, #8]
 800b164:	9d08      	ldr	r5, [sp, #32]
 800b166:	9108      	str	r1, [sp, #32]
 800b168:	e765      	b.n	800b036 <_dtoa_r+0xd02>
 800b16a:	9a07      	ldr	r2, [sp, #28]
 800b16c:	9d08      	ldr	r5, [sp, #32]
 800b16e:	2a39      	cmp	r2, #57	; 0x39
 800b170:	d007      	beq.n	800b182 <_dtoa_r+0xe4e>
 800b172:	9902      	ldr	r1, [sp, #8]
 800b174:	9807      	ldr	r0, [sp, #28]
 800b176:	9108      	str	r1, [sp, #32]
 800b178:	1c43      	adds	r3, r0, #1
 800b17a:	f806 3b01 	strb.w	r3, [r6], #1
 800b17e:	f7ff bada 	b.w	800a736 <_dtoa_r+0x402>
 800b182:	9b02      	ldr	r3, [sp, #8]
 800b184:	46b0      	mov	r8, r6
 800b186:	9308      	str	r3, [sp, #32]
 800b188:	2339      	movs	r3, #57	; 0x39
 800b18a:	f808 3b01 	strb.w	r3, [r8], #1
 800b18e:	e75d      	b.n	800b04c <_dtoa_r+0xd18>
 800b190:	9907      	ldr	r1, [sp, #28]
 800b192:	462b      	mov	r3, r5
 800b194:	9d08      	ldr	r5, [sp, #32]
 800b196:	2939      	cmp	r1, #57	; 0x39
 800b198:	d0f3      	beq.n	800b182 <_dtoa_r+0xe4e>
 800b19a:	2b00      	cmp	r3, #0
 800b19c:	dd01      	ble.n	800b1a2 <_dtoa_r+0xe6e>
 800b19e:	3101      	adds	r1, #1
 800b1a0:	9107      	str	r1, [sp, #28]
 800b1a2:	9a02      	ldr	r2, [sp, #8]
 800b1a4:	9b07      	ldr	r3, [sp, #28]
 800b1a6:	9208      	str	r2, [sp, #32]
 800b1a8:	f806 3b01 	strb.w	r3, [r6], #1
 800b1ac:	f7ff bac3 	b.w	800a736 <_dtoa_r+0x402>
 800b1b0:	d1af      	bne.n	800b112 <_dtoa_r+0xdde>
 800b1b2:	9a07      	ldr	r2, [sp, #28]
 800b1b4:	f012 0f01 	tst.w	r2, #1
 800b1b8:	d0ab      	beq.n	800b112 <_dtoa_r+0xdde>
 800b1ba:	e7a5      	b.n	800b108 <_dtoa_r+0xdd4>
 800b1bc:	2300      	movs	r3, #0
 800b1be:	4620      	mov	r0, r4
 800b1c0:	9908      	ldr	r1, [sp, #32]
 800b1c2:	220a      	movs	r2, #10
 800b1c4:	f000 fdee 	bl	800bda4 <__multadd>
 800b1c8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b1ca:	930a      	str	r3, [sp, #40]	; 0x28
 800b1cc:	9008      	str	r0, [sp, #32]
 800b1ce:	e426      	b.n	800aa1e <_dtoa_r+0x6ea>
 800b1d0:	f43f ac0f 	beq.w	800a9f2 <_dtoa_r+0x6be>
 800b1d4:	331c      	adds	r3, #28
 800b1d6:	e623      	b.n	800ae20 <_dtoa_r+0xaec>
 800b1d8:	990a      	ldr	r1, [sp, #40]	; 0x28
 800b1da:	290e      	cmp	r1, #14
 800b1dc:	bf8c      	ite	hi
 800b1de:	2700      	movhi	r7, #0
 800b1e0:	f007 0701 	andls.w	r7, r7, #1
 800b1e4:	f7ff b9eb 	b.w	800a5be <_dtoa_r+0x28a>
 800b1e8:	2701      	movs	r7, #1
 800b1ea:	f7ff b970 	b.w	800a4ce <_dtoa_r+0x19a>
 800b1ee:	bf00      	nop

0800b1f0 <_fflush_r>:
 800b1f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b1f4:	460c      	mov	r4, r1
 800b1f6:	690e      	ldr	r6, [r1, #16]
 800b1f8:	4680      	mov	r8, r0
 800b1fa:	2e00      	cmp	r6, #0
 800b1fc:	d04a      	beq.n	800b294 <_fflush_r+0xa4>
 800b1fe:	b118      	cbz	r0, 800b208 <_fflush_r+0x18>
 800b200:	6983      	ldr	r3, [r0, #24]
 800b202:	2b00      	cmp	r3, #0
 800b204:	f000 808e 	beq.w	800b324 <_fflush_r+0x134>
 800b208:	f240 13c0 	movw	r3, #448	; 0x1c0
 800b20c:	f6c0 0301 	movt	r3, #2049	; 0x801
 800b210:	429c      	cmp	r4, r3
 800b212:	bf08      	it	eq
 800b214:	f8d8 4004 	ldreq.w	r4, [r8, #4]
 800b218:	d010      	beq.n	800b23c <_fflush_r+0x4c>
 800b21a:	f240 13e0 	movw	r3, #480	; 0x1e0
 800b21e:	f6c0 0301 	movt	r3, #2049	; 0x801
 800b222:	429c      	cmp	r4, r3
 800b224:	bf08      	it	eq
 800b226:	f8d8 4008 	ldreq.w	r4, [r8, #8]
 800b22a:	d007      	beq.n	800b23c <_fflush_r+0x4c>
 800b22c:	f240 2300 	movw	r3, #512	; 0x200
 800b230:	f6c0 0301 	movt	r3, #2049	; 0x801
 800b234:	429c      	cmp	r4, r3
 800b236:	bf08      	it	eq
 800b238:	f8d8 400c 	ldreq.w	r4, [r8, #12]
 800b23c:	89a6      	ldrh	r6, [r4, #12]
 800b23e:	2e00      	cmp	r6, #0
 800b240:	d028      	beq.n	800b294 <_fflush_r+0xa4>
 800b242:	b233      	sxth	r3, r6
 800b244:	f013 0008 	ands.w	r0, r3, #8
 800b248:	d027      	beq.n	800b29a <_fflush_r+0xaa>
 800b24a:	6926      	ldr	r6, [r4, #16]
 800b24c:	b316      	cbz	r6, 800b294 <_fflush_r+0xa4>
 800b24e:	f013 0f03 	tst.w	r3, #3
 800b252:	6825      	ldr	r5, [r4, #0]
 800b254:	6026      	str	r6, [r4, #0]
 800b256:	bf08      	it	eq
 800b258:	6963      	ldreq	r3, [r4, #20]
 800b25a:	ebc6 0505 	rsb	r5, r6, r5
 800b25e:	bf18      	it	ne
 800b260:	2300      	movne	r3, #0
 800b262:	2d00      	cmp	r5, #0
 800b264:	60a3      	str	r3, [r4, #8]
 800b266:	dc02      	bgt.n	800b26e <_fflush_r+0x7e>
 800b268:	e09a      	b.n	800b3a0 <_fflush_r+0x1b0>
 800b26a:	2d00      	cmp	r5, #0
 800b26c:	dd74      	ble.n	800b358 <_fflush_r+0x168>
 800b26e:	4632      	mov	r2, r6
 800b270:	462b      	mov	r3, r5
 800b272:	6aa7      	ldr	r7, [r4, #40]	; 0x28
 800b274:	4640      	mov	r0, r8
 800b276:	6a21      	ldr	r1, [r4, #32]
 800b278:	47b8      	blx	r7
 800b27a:	2800      	cmp	r0, #0
 800b27c:	ebc0 0505 	rsb	r5, r0, r5
 800b280:	4406      	add	r6, r0
 800b282:	dcf2      	bgt.n	800b26a <_fflush_r+0x7a>
 800b284:	89a3      	ldrh	r3, [r4, #12]
 800b286:	f04f 30ff 	mov.w	r0, #4294967295
 800b28a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b28e:	81a3      	strh	r3, [r4, #12]
 800b290:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800b294:	4630      	mov	r0, r6
 800b296:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800b29a:	6862      	ldr	r2, [r4, #4]
 800b29c:	f446 6300 	orr.w	r3, r6, #2048	; 0x800
 800b2a0:	81a3      	strh	r3, [r4, #12]
 800b2a2:	2a00      	cmp	r2, #0
 800b2a4:	dd5b      	ble.n	800b35e <_fflush_r+0x16e>
 800b2a6:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800b2a8:	2e00      	cmp	r6, #0
 800b2aa:	d0f3      	beq.n	800b294 <_fflush_r+0xa4>
 800b2ac:	b29b      	uxth	r3, r3
 800b2ae:	2200      	movs	r2, #0
 800b2b0:	f413 5780 	ands.w	r7, r3, #4096	; 0x1000
 800b2b4:	f8d8 5000 	ldr.w	r5, [r8]
 800b2b8:	f8c8 2000 	str.w	r2, [r8]
 800b2bc:	bf18      	it	ne
 800b2be:	6d62      	ldrne	r2, [r4, #84]	; 0x54
 800b2c0:	d033      	beq.n	800b32a <_fflush_r+0x13a>
 800b2c2:	f013 0f04 	tst.w	r3, #4
 800b2c6:	d005      	beq.n	800b2d4 <_fflush_r+0xe4>
 800b2c8:	6861      	ldr	r1, [r4, #4]
 800b2ca:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800b2cc:	1a52      	subs	r2, r2, r1
 800b2ce:	b10b      	cbz	r3, 800b2d4 <_fflush_r+0xe4>
 800b2d0:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800b2d2:	1ad2      	subs	r2, r2, r3
 800b2d4:	2300      	movs	r3, #0
 800b2d6:	4640      	mov	r0, r8
 800b2d8:	6a21      	ldr	r1, [r4, #32]
 800b2da:	47b0      	blx	r6
 800b2dc:	f1b0 3fff 	cmp.w	r0, #4294967295
 800b2e0:	d02f      	beq.n	800b342 <_fflush_r+0x152>
 800b2e2:	89a3      	ldrh	r3, [r4, #12]
 800b2e4:	2100      	movs	r1, #0
 800b2e6:	6922      	ldr	r2, [r4, #16]
 800b2e8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800b2ec:	6061      	str	r1, [r4, #4]
 800b2ee:	041b      	lsls	r3, r3, #16
 800b2f0:	6022      	str	r2, [r4, #0]
 800b2f2:	0c1b      	lsrs	r3, r3, #16
 800b2f4:	81a3      	strh	r3, [r4, #12]
 800b2f6:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 800b2fa:	d003      	beq.n	800b304 <_fflush_r+0x114>
 800b2fc:	f1b0 3fff 	cmp.w	r0, #4294967295
 800b300:	d031      	beq.n	800b366 <_fflush_r+0x176>
 800b302:	6560      	str	r0, [r4, #84]	; 0x54
 800b304:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800b306:	f8c8 5000 	str.w	r5, [r8]
 800b30a:	2900      	cmp	r1, #0
 800b30c:	d031      	beq.n	800b372 <_fflush_r+0x182>
 800b30e:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800b312:	4299      	cmp	r1, r3
 800b314:	d002      	beq.n	800b31c <_fflush_r+0x12c>
 800b316:	4640      	mov	r0, r8
 800b318:	f000 f9c4 	bl	800b6a4 <_free_r>
 800b31c:	2000      	movs	r0, #0
 800b31e:	6360      	str	r0, [r4, #52]	; 0x34
 800b320:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800b324:	f000 f882 	bl	800b42c <__sinit>
 800b328:	e76e      	b.n	800b208 <_fflush_r+0x18>
 800b32a:	463a      	mov	r2, r7
 800b32c:	2301      	movs	r3, #1
 800b32e:	4640      	mov	r0, r8
 800b330:	6a21      	ldr	r1, [r4, #32]
 800b332:	47b0      	blx	r6
 800b334:	f1b0 3fff 	cmp.w	r0, #4294967295
 800b338:	4602      	mov	r2, r0
 800b33a:	d01d      	beq.n	800b378 <_fflush_r+0x188>
 800b33c:	89a3      	ldrh	r3, [r4, #12]
 800b33e:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800b340:	e7bf      	b.n	800b2c2 <_fflush_r+0xd2>
 800b342:	f8d8 3000 	ldr.w	r3, [r8]
 800b346:	2b1d      	cmp	r3, #29
 800b348:	d89c      	bhi.n	800b284 <_fflush_r+0x94>
 800b34a:	f44f 7201 	mov.w	r2, #516	; 0x204
 800b34e:	f2c8 0200 	movt	r2, #32768	; 0x8000
 800b352:	409a      	lsls	r2, r3
 800b354:	d4c5      	bmi.n	800b2e2 <_fflush_r+0xf2>
 800b356:	e795      	b.n	800b284 <_fflush_r+0x94>
 800b358:	2000      	movs	r0, #0
 800b35a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800b35e:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800b360:	2a00      	cmp	r2, #0
 800b362:	dca0      	bgt.n	800b2a6 <_fflush_r+0xb6>
 800b364:	e7f9      	b.n	800b35a <_fflush_r+0x16a>
 800b366:	f8d8 3000 	ldr.w	r3, [r8]
 800b36a:	2b00      	cmp	r3, #0
 800b36c:	d1ca      	bne.n	800b304 <_fflush_r+0x114>
 800b36e:	6560      	str	r0, [r4, #84]	; 0x54
 800b370:	e7c8      	b.n	800b304 <_fflush_r+0x114>
 800b372:	4608      	mov	r0, r1
 800b374:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800b378:	f8d8 3000 	ldr.w	r3, [r8]
 800b37c:	2b00      	cmp	r3, #0
 800b37e:	d0dd      	beq.n	800b33c <_fflush_r+0x14c>
 800b380:	f1a3 021d 	sub.w	r2, r3, #29
 800b384:	4251      	negs	r1, r2
 800b386:	eb41 0102 	adc.w	r1, r1, r2
 800b38a:	2b16      	cmp	r3, #22
 800b38c:	bf14      	ite	ne
 800b38e:	460b      	movne	r3, r1
 800b390:	f041 0301 	orreq.w	r3, r1, #1
 800b394:	b13b      	cbz	r3, 800b3a6 <_fflush_r+0x1b6>
 800b396:	f8c8 5000 	str.w	r5, [r8]
 800b39a:	4638      	mov	r0, r7
 800b39c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800b3a0:	2000      	movs	r0, #0
 800b3a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800b3a6:	89a3      	ldrh	r3, [r4, #12]
 800b3a8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b3ac:	81a3      	strh	r3, [r4, #12]
 800b3ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800b3b2:	bf00      	nop

0800b3b4 <fflush>:
 800b3b4:	b130      	cbz	r0, 800b3c4 <fflush+0x10>
 800b3b6:	f240 237c 	movw	r3, #636	; 0x27c
 800b3ba:	4601      	mov	r1, r0
 800b3bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b3c0:	6818      	ldr	r0, [r3, #0]
 800b3c2:	e715      	b.n	800b1f0 <_fflush_r>
 800b3c4:	f240 137c 	movw	r3, #380	; 0x17c
 800b3c8:	f24b 11f1 	movw	r1, #45553	; 0xb1f1
 800b3cc:	f6c0 0301 	movt	r3, #2049	; 0x801
 800b3d0:	f6c0 0100 	movt	r1, #2048	; 0x800
 800b3d4:	6818      	ldr	r0, [r3, #0]
 800b3d6:	f000 ba5b 	b.w	800b890 <_fwalk_reent>
 800b3da:	bf00      	nop

0800b3dc <__fp_lock>:
 800b3dc:	2000      	movs	r0, #0
 800b3de:	4770      	bx	lr

0800b3e0 <__fp_unlock>:
 800b3e0:	2000      	movs	r0, #0
 800b3e2:	4770      	bx	lr

0800b3e4 <_cleanup_r>:
 800b3e4:	f24e 31f1 	movw	r1, #58353	; 0xe3f1
 800b3e8:	f6c0 0100 	movt	r1, #2048	; 0x800
 800b3ec:	f000 ba26 	b.w	800b83c <_fwalk>

0800b3f0 <__sfmoreglue>:
 800b3f0:	b570      	push	{r4, r5, r6, lr}
 800b3f2:	2568      	movs	r5, #104	; 0x68
 800b3f4:	460e      	mov	r6, r1
 800b3f6:	fb05 f501 	mul.w	r5, r5, r1
 800b3fa:	f105 010c 	add.w	r1, r5, #12
 800b3fe:	f7fb f8af 	bl	8006560 <_malloc_r>
 800b402:	4604      	mov	r4, r0
 800b404:	b148      	cbz	r0, 800b41a <__sfmoreglue+0x2a>
 800b406:	f100 030c 	add.w	r3, r0, #12
 800b40a:	2100      	movs	r1, #0
 800b40c:	6046      	str	r6, [r0, #4]
 800b40e:	462a      	mov	r2, r5
 800b410:	4618      	mov	r0, r3
 800b412:	6021      	str	r1, [r4, #0]
 800b414:	60a3      	str	r3, [r4, #8]
 800b416:	f000 fc1b 	bl	800bc50 <memset>
 800b41a:	4620      	mov	r0, r4
 800b41c:	bd70      	pop	{r4, r5, r6, pc}
 800b41e:	bf00      	nop

0800b420 <_cleanup>:
 800b420:	f240 137c 	movw	r3, #380	; 0x17c
 800b424:	f6c0 0301 	movt	r3, #2049	; 0x801
 800b428:	6818      	ldr	r0, [r3, #0]
 800b42a:	e7db      	b.n	800b3e4 <_cleanup_r>

0800b42c <__sinit>:
 800b42c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b430:	4605      	mov	r5, r0
 800b432:	6984      	ldr	r4, [r0, #24]
 800b434:	b083      	sub	sp, #12
 800b436:	2c00      	cmp	r4, #0
 800b438:	d178      	bne.n	800b52c <__sinit+0x100>
 800b43a:	f24b 32e5 	movw	r2, #46053	; 0xb3e5
 800b43e:	2301      	movs	r3, #1
 800b440:	f6c0 0200 	movt	r2, #2048	; 0x800
 800b444:	6183      	str	r3, [r0, #24]
 800b446:	6282      	str	r2, [r0, #40]	; 0x28
 800b448:	f64c 0921 	movw	r9, #51233	; 0xc821
 800b44c:	f8c0 40d8 	str.w	r4, [r0, #216]	; 0xd8
 800b450:	f64c 0849 	movw	r8, #51273	; 0xc849
 800b454:	f8c0 40dc 	str.w	r4, [r0, #220]	; 0xdc
 800b458:	f64c 0a85 	movw	sl, #51333	; 0xc885
 800b45c:	f8c0 40e0 	str.w	r4, [r0, #224]	; 0xe0
 800b460:	f64c 0bad 	movw	fp, #51373	; 0xc8ad
 800b464:	9301      	str	r3, [sp, #4]
 800b466:	f000 f865 	bl	800b534 <__sfp>
 800b46a:	f6c0 0900 	movt	r9, #2048	; 0x800
 800b46e:	f6c0 0800 	movt	r8, #2048	; 0x800
 800b472:	f6c0 0a00 	movt	sl, #2048	; 0x800
 800b476:	f6c0 0b00 	movt	fp, #2048	; 0x800
 800b47a:	6068      	str	r0, [r5, #4]
 800b47c:	4628      	mov	r0, r5
 800b47e:	f000 f859 	bl	800b534 <__sfp>
 800b482:	60a8      	str	r0, [r5, #8]
 800b484:	4628      	mov	r0, r5
 800b486:	f000 f855 	bl	800b534 <__sfp>
 800b48a:	686f      	ldr	r7, [r5, #4]
 800b48c:	4621      	mov	r1, r4
 800b48e:	2208      	movs	r2, #8
 800b490:	60e8      	str	r0, [r5, #12]
 800b492:	2004      	movs	r0, #4
 800b494:	603c      	str	r4, [r7, #0]
 800b496:	81b8      	strh	r0, [r7, #12]
 800b498:	f107 005c 	add.w	r0, r7, #92	; 0x5c
 800b49c:	607c      	str	r4, [r7, #4]
 800b49e:	60bc      	str	r4, [r7, #8]
 800b4a0:	667c      	str	r4, [r7, #100]	; 0x64
 800b4a2:	81fc      	strh	r4, [r7, #14]
 800b4a4:	613c      	str	r4, [r7, #16]
 800b4a6:	617c      	str	r4, [r7, #20]
 800b4a8:	61bc      	str	r4, [r7, #24]
 800b4aa:	f000 fbd1 	bl	800bc50 <memset>
 800b4ae:	68ae      	ldr	r6, [r5, #8]
 800b4b0:	9b01      	ldr	r3, [sp, #4]
 800b4b2:	4621      	mov	r1, r4
 800b4b4:	2208      	movs	r2, #8
 800b4b6:	2009      	movs	r0, #9
 800b4b8:	623f      	str	r7, [r7, #32]
 800b4ba:	81b0      	strh	r0, [r6, #12]
 800b4bc:	f106 005c 	add.w	r0, r6, #92	; 0x5c
 800b4c0:	81f3      	strh	r3, [r6, #14]
 800b4c2:	f8c7 9024 	str.w	r9, [r7, #36]	; 0x24
 800b4c6:	f8c7 8028 	str.w	r8, [r7, #40]	; 0x28
 800b4ca:	f8c7 a02c 	str.w	sl, [r7, #44]	; 0x2c
 800b4ce:	f8c7 b030 	str.w	fp, [r7, #48]	; 0x30
 800b4d2:	6034      	str	r4, [r6, #0]
 800b4d4:	6074      	str	r4, [r6, #4]
 800b4d6:	60b4      	str	r4, [r6, #8]
 800b4d8:	6674      	str	r4, [r6, #100]	; 0x64
 800b4da:	6134      	str	r4, [r6, #16]
 800b4dc:	6174      	str	r4, [r6, #20]
 800b4de:	61b4      	str	r4, [r6, #24]
 800b4e0:	f000 fbb6 	bl	800bc50 <memset>
 800b4e4:	68ed      	ldr	r5, [r5, #12]
 800b4e6:	2312      	movs	r3, #18
 800b4e8:	2002      	movs	r0, #2
 800b4ea:	6236      	str	r6, [r6, #32]
 800b4ec:	4621      	mov	r1, r4
 800b4ee:	81e8      	strh	r0, [r5, #14]
 800b4f0:	2208      	movs	r2, #8
 800b4f2:	f8c6 9024 	str.w	r9, [r6, #36]	; 0x24
 800b4f6:	f105 005c 	add.w	r0, r5, #92	; 0x5c
 800b4fa:	81ab      	strh	r3, [r5, #12]
 800b4fc:	f8c6 8028 	str.w	r8, [r6, #40]	; 0x28
 800b500:	f8c6 a02c 	str.w	sl, [r6, #44]	; 0x2c
 800b504:	f8c6 b030 	str.w	fp, [r6, #48]	; 0x30
 800b508:	602c      	str	r4, [r5, #0]
 800b50a:	606c      	str	r4, [r5, #4]
 800b50c:	60ac      	str	r4, [r5, #8]
 800b50e:	666c      	str	r4, [r5, #100]	; 0x64
 800b510:	612c      	str	r4, [r5, #16]
 800b512:	616c      	str	r4, [r5, #20]
 800b514:	61ac      	str	r4, [r5, #24]
 800b516:	f000 fb9b 	bl	800bc50 <memset>
 800b51a:	622d      	str	r5, [r5, #32]
 800b51c:	f8c5 9024 	str.w	r9, [r5, #36]	; 0x24
 800b520:	f8c5 8028 	str.w	r8, [r5, #40]	; 0x28
 800b524:	f8c5 a02c 	str.w	sl, [r5, #44]	; 0x2c
 800b528:	f8c5 b030 	str.w	fp, [r5, #48]	; 0x30
 800b52c:	b003      	add	sp, #12
 800b52e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b532:	bf00      	nop

0800b534 <__sfp>:
 800b534:	f240 137c 	movw	r3, #380	; 0x17c
 800b538:	f6c0 0301 	movt	r3, #2049	; 0x801
 800b53c:	b570      	push	{r4, r5, r6, lr}
 800b53e:	4606      	mov	r6, r0
 800b540:	681d      	ldr	r5, [r3, #0]
 800b542:	69ab      	ldr	r3, [r5, #24]
 800b544:	2b00      	cmp	r3, #0
 800b546:	d029      	beq.n	800b59c <__sfp+0x68>
 800b548:	35d8      	adds	r5, #216	; 0xd8
 800b54a:	686b      	ldr	r3, [r5, #4]
 800b54c:	68ac      	ldr	r4, [r5, #8]
 800b54e:	3b01      	subs	r3, #1
 800b550:	d503      	bpl.n	800b55a <__sfp+0x26>
 800b552:	e01f      	b.n	800b594 <__sfp+0x60>
 800b554:	3468      	adds	r4, #104	; 0x68
 800b556:	3b01      	subs	r3, #1
 800b558:	d31c      	bcc.n	800b594 <__sfp+0x60>
 800b55a:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 800b55e:	2a00      	cmp	r2, #0
 800b560:	d1f8      	bne.n	800b554 <__sfp+0x20>
 800b562:	2500      	movs	r5, #0
 800b564:	f04f 33ff 	mov.w	r3, #4294967295
 800b568:	6665      	str	r5, [r4, #100]	; 0x64
 800b56a:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 800b56e:	81e3      	strh	r3, [r4, #14]
 800b570:	4629      	mov	r1, r5
 800b572:	2301      	movs	r3, #1
 800b574:	6025      	str	r5, [r4, #0]
 800b576:	81a3      	strh	r3, [r4, #12]
 800b578:	2208      	movs	r2, #8
 800b57a:	60a5      	str	r5, [r4, #8]
 800b57c:	6065      	str	r5, [r4, #4]
 800b57e:	6125      	str	r5, [r4, #16]
 800b580:	6165      	str	r5, [r4, #20]
 800b582:	61a5      	str	r5, [r4, #24]
 800b584:	f000 fb64 	bl	800bc50 <memset>
 800b588:	6365      	str	r5, [r4, #52]	; 0x34
 800b58a:	63a5      	str	r5, [r4, #56]	; 0x38
 800b58c:	64a5      	str	r5, [r4, #72]	; 0x48
 800b58e:	64e5      	str	r5, [r4, #76]	; 0x4c
 800b590:	4620      	mov	r0, r4
 800b592:	bd70      	pop	{r4, r5, r6, pc}
 800b594:	6828      	ldr	r0, [r5, #0]
 800b596:	b128      	cbz	r0, 800b5a4 <__sfp+0x70>
 800b598:	4605      	mov	r5, r0
 800b59a:	e7d6      	b.n	800b54a <__sfp+0x16>
 800b59c:	4628      	mov	r0, r5
 800b59e:	f7ff ff45 	bl	800b42c <__sinit>
 800b5a2:	e7d1      	b.n	800b548 <__sfp+0x14>
 800b5a4:	4630      	mov	r0, r6
 800b5a6:	2104      	movs	r1, #4
 800b5a8:	f7ff ff22 	bl	800b3f0 <__sfmoreglue>
 800b5ac:	6028      	str	r0, [r5, #0]
 800b5ae:	2800      	cmp	r0, #0
 800b5b0:	d1f2      	bne.n	800b598 <__sfp+0x64>
 800b5b2:	230c      	movs	r3, #12
 800b5b4:	4604      	mov	r4, r0
 800b5b6:	6033      	str	r3, [r6, #0]
 800b5b8:	e7ea      	b.n	800b590 <__sfp+0x5c>
 800b5ba:	bf00      	nop

0800b5bc <__sfp_lock_acquire>:
 800b5bc:	4770      	bx	lr
 800b5be:	bf00      	nop

0800b5c0 <__sfp_lock_release>:
 800b5c0:	4770      	bx	lr
 800b5c2:	bf00      	nop

0800b5c4 <__sinit_lock_acquire>:
 800b5c4:	4770      	bx	lr
 800b5c6:	bf00      	nop

0800b5c8 <__sinit_lock_release>:
 800b5c8:	4770      	bx	lr
 800b5ca:	bf00      	nop

0800b5cc <__fp_lock_all>:
 800b5cc:	f240 237c 	movw	r3, #636	; 0x27c
 800b5d0:	f24b 31dd 	movw	r1, #46045	; 0xb3dd
 800b5d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b5d8:	f6c0 0100 	movt	r1, #2048	; 0x800
 800b5dc:	6818      	ldr	r0, [r3, #0]
 800b5de:	f000 b92d 	b.w	800b83c <_fwalk>
 800b5e2:	bf00      	nop

0800b5e4 <__fp_unlock_all>:
 800b5e4:	f240 237c 	movw	r3, #636	; 0x27c
 800b5e8:	f24b 31e1 	movw	r1, #46049	; 0xb3e1
 800b5ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b5f0:	f6c0 0100 	movt	r1, #2048	; 0x800
 800b5f4:	6818      	ldr	r0, [r3, #0]
 800b5f6:	f000 b921 	b.w	800b83c <_fwalk>
 800b5fa:	bf00      	nop

0800b5fc <_malloc_trim_r>:
 800b5fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b5fe:	f240 3470 	movw	r4, #880	; 0x370
 800b602:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800b606:	460f      	mov	r7, r1
 800b608:	4605      	mov	r5, r0
 800b60a:	f7fb fa67 	bl	8006adc <__malloc_lock>
 800b60e:	68a3      	ldr	r3, [r4, #8]
 800b610:	685e      	ldr	r6, [r3, #4]
 800b612:	f026 0603 	bic.w	r6, r6, #3
 800b616:	f506 637e 	add.w	r3, r6, #4064	; 0xfe0
 800b61a:	330f      	adds	r3, #15
 800b61c:	1bdf      	subs	r7, r3, r7
 800b61e:	0b3f      	lsrs	r7, r7, #12
 800b620:	3f01      	subs	r7, #1
 800b622:	033f      	lsls	r7, r7, #12
 800b624:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
 800b628:	db07      	blt.n	800b63a <_malloc_trim_r+0x3e>
 800b62a:	2100      	movs	r1, #0
 800b62c:	4628      	mov	r0, r5
 800b62e:	f7f5 fb13 	bl	8000c58 <_sbrk_r>
 800b632:	68a3      	ldr	r3, [r4, #8]
 800b634:	199b      	adds	r3, r3, r6
 800b636:	4298      	cmp	r0, r3
 800b638:	d004      	beq.n	800b644 <_malloc_trim_r+0x48>
 800b63a:	4628      	mov	r0, r5
 800b63c:	f7fb fa50 	bl	8006ae0 <__malloc_unlock>
 800b640:	2000      	movs	r0, #0
 800b642:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800b644:	4279      	negs	r1, r7
 800b646:	4628      	mov	r0, r5
 800b648:	f7f5 fb06 	bl	8000c58 <_sbrk_r>
 800b64c:	f1b0 3fff 	cmp.w	r0, #4294967295
 800b650:	d010      	beq.n	800b674 <_malloc_trim_r+0x78>
 800b652:	f641 138c 	movw	r3, #6540	; 0x198c
 800b656:	68a1      	ldr	r1, [r4, #8]
 800b658:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b65c:	1bf6      	subs	r6, r6, r7
 800b65e:	4628      	mov	r0, r5
 800b660:	f046 0601 	orr.w	r6, r6, #1
 800b664:	681a      	ldr	r2, [r3, #0]
 800b666:	604e      	str	r6, [r1, #4]
 800b668:	1bd7      	subs	r7, r2, r7
 800b66a:	601f      	str	r7, [r3, #0]
 800b66c:	f7fb fa38 	bl	8006ae0 <__malloc_unlock>
 800b670:	2001      	movs	r0, #1
 800b672:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800b674:	2100      	movs	r1, #0
 800b676:	4628      	mov	r0, r5
 800b678:	f7f5 faee 	bl	8000c58 <_sbrk_r>
 800b67c:	68a3      	ldr	r3, [r4, #8]
 800b67e:	1ac2      	subs	r2, r0, r3
 800b680:	2a0f      	cmp	r2, #15
 800b682:	ddda      	ble.n	800b63a <_malloc_trim_r+0x3e>
 800b684:	f240 7478 	movw	r4, #1912	; 0x778
 800b688:	f641 118c 	movw	r1, #6540	; 0x198c
 800b68c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800b690:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800b694:	f042 0201 	orr.w	r2, r2, #1
 800b698:	605a      	str	r2, [r3, #4]
 800b69a:	6823      	ldr	r3, [r4, #0]
 800b69c:	1ac0      	subs	r0, r0, r3
 800b69e:	6008      	str	r0, [r1, #0]
 800b6a0:	e7cb      	b.n	800b63a <_malloc_trim_r+0x3e>
 800b6a2:	bf00      	nop

0800b6a4 <_free_r>:
 800b6a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b6a8:	460d      	mov	r5, r1
 800b6aa:	4604      	mov	r4, r0
 800b6ac:	2900      	cmp	r1, #0
 800b6ae:	d058      	beq.n	800b762 <_free_r+0xbe>
 800b6b0:	f7fb fa14 	bl	8006adc <__malloc_lock>
 800b6b4:	f1a5 0208 	sub.w	r2, r5, #8
 800b6b8:	f240 3070 	movw	r0, #880	; 0x370
 800b6bc:	6856      	ldr	r6, [r2, #4]
 800b6be:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800b6c2:	f026 0301 	bic.w	r3, r6, #1
 800b6c6:	f8d0 c008 	ldr.w	ip, [r0, #8]
 800b6ca:	18d1      	adds	r1, r2, r3
 800b6cc:	458c      	cmp	ip, r1
 800b6ce:	684f      	ldr	r7, [r1, #4]
 800b6d0:	f027 0703 	bic.w	r7, r7, #3
 800b6d4:	d065      	beq.n	800b7a2 <_free_r+0xfe>
 800b6d6:	f016 0601 	ands.w	r6, r6, #1
 800b6da:	604f      	str	r7, [r1, #4]
 800b6dc:	d031      	beq.n	800b742 <_free_r+0x9e>
 800b6de:	2600      	movs	r6, #0
 800b6e0:	19cd      	adds	r5, r1, r7
 800b6e2:	686d      	ldr	r5, [r5, #4]
 800b6e4:	f015 0f01 	tst.w	r5, #1
 800b6e8:	d106      	bne.n	800b6f8 <_free_r+0x54>
 800b6ea:	19db      	adds	r3, r3, r7
 800b6ec:	2e00      	cmp	r6, #0
 800b6ee:	d04b      	beq.n	800b788 <_free_r+0xe4>
 800b6f0:	688d      	ldr	r5, [r1, #8]
 800b6f2:	68c9      	ldr	r1, [r1, #12]
 800b6f4:	60e9      	str	r1, [r5, #12]
 800b6f6:	608d      	str	r5, [r1, #8]
 800b6f8:	f043 0101 	orr.w	r1, r3, #1
 800b6fc:	50d3      	str	r3, [r2, r3]
 800b6fe:	6051      	str	r1, [r2, #4]
 800b700:	b9d6      	cbnz	r6, 800b738 <_free_r+0x94>
 800b702:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800b706:	d32e      	bcc.n	800b766 <_free_r+0xc2>
 800b708:	0a59      	lsrs	r1, r3, #9
 800b70a:	2904      	cmp	r1, #4
 800b70c:	d86b      	bhi.n	800b7e6 <_free_r+0x142>
 800b70e:	099e      	lsrs	r6, r3, #6
 800b710:	3638      	adds	r6, #56	; 0x38
 800b712:	00f5      	lsls	r5, r6, #3
 800b714:	1945      	adds	r5, r0, r5
 800b716:	68a9      	ldr	r1, [r5, #8]
 800b718:	42a9      	cmp	r1, r5
 800b71a:	d103      	bne.n	800b724 <_free_r+0x80>
 800b71c:	e069      	b.n	800b7f2 <_free_r+0x14e>
 800b71e:	6889      	ldr	r1, [r1, #8]
 800b720:	428d      	cmp	r5, r1
 800b722:	d004      	beq.n	800b72e <_free_r+0x8a>
 800b724:	6848      	ldr	r0, [r1, #4]
 800b726:	f020 0003 	bic.w	r0, r0, #3
 800b72a:	4283      	cmp	r3, r0
 800b72c:	d3f7      	bcc.n	800b71e <_free_r+0x7a>
 800b72e:	68cb      	ldr	r3, [r1, #12]
 800b730:	60d3      	str	r3, [r2, #12]
 800b732:	6091      	str	r1, [r2, #8]
 800b734:	60ca      	str	r2, [r1, #12]
 800b736:	609a      	str	r2, [r3, #8]
 800b738:	4620      	mov	r0, r4
 800b73a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800b73e:	f7fb b9cf 	b.w	8006ae0 <__malloc_unlock>
 800b742:	f855 5c08 	ldr.w	r5, [r5, #-8]
 800b746:	f100 0c08 	add.w	ip, r0, #8
 800b74a:	1b52      	subs	r2, r2, r5
 800b74c:	195b      	adds	r3, r3, r5
 800b74e:	6895      	ldr	r5, [r2, #8]
 800b750:	4565      	cmp	r5, ip
 800b752:	d046      	beq.n	800b7e2 <_free_r+0x13e>
 800b754:	f8d2 c00c 	ldr.w	ip, [r2, #12]
 800b758:	f8c5 c00c 	str.w	ip, [r5, #12]
 800b75c:	f8cc 5008 	str.w	r5, [ip, #8]
 800b760:	e7be      	b.n	800b6e0 <_free_r+0x3c>
 800b762:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800b766:	08db      	lsrs	r3, r3, #3
 800b768:	2501      	movs	r5, #1
 800b76a:	6846      	ldr	r6, [r0, #4]
 800b76c:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
 800b770:	109b      	asrs	r3, r3, #2
 800b772:	fa15 f303 	lsls.w	r3, r5, r3
 800b776:	60d1      	str	r1, [r2, #12]
 800b778:	688d      	ldr	r5, [r1, #8]
 800b77a:	ea46 0303 	orr.w	r3, r6, r3
 800b77e:	6043      	str	r3, [r0, #4]
 800b780:	6095      	str	r5, [r2, #8]
 800b782:	60ea      	str	r2, [r5, #12]
 800b784:	608a      	str	r2, [r1, #8]
 800b786:	e7d7      	b.n	800b738 <_free_r+0x94>
 800b788:	688d      	ldr	r5, [r1, #8]
 800b78a:	4f2b      	ldr	r7, [pc, #172]	; (800b838 <_free_r+0x194>)
 800b78c:	42bd      	cmp	r5, r7
 800b78e:	d1b0      	bne.n	800b6f2 <_free_r+0x4e>
 800b790:	60ea      	str	r2, [r5, #12]
 800b792:	f043 0101 	orr.w	r1, r3, #1
 800b796:	60aa      	str	r2, [r5, #8]
 800b798:	60d5      	str	r5, [r2, #12]
 800b79a:	6095      	str	r5, [r2, #8]
 800b79c:	6051      	str	r1, [r2, #4]
 800b79e:	50d3      	str	r3, [r2, r3]
 800b7a0:	e7ca      	b.n	800b738 <_free_r+0x94>
 800b7a2:	f016 0f01 	tst.w	r6, #1
 800b7a6:	443b      	add	r3, r7
 800b7a8:	d107      	bne.n	800b7ba <_free_r+0x116>
 800b7aa:	f855 1c08 	ldr.w	r1, [r5, #-8]
 800b7ae:	1a52      	subs	r2, r2, r1
 800b7b0:	185b      	adds	r3, r3, r1
 800b7b2:	6895      	ldr	r5, [r2, #8]
 800b7b4:	68d1      	ldr	r1, [r2, #12]
 800b7b6:	60e9      	str	r1, [r5, #12]
 800b7b8:	608d      	str	r5, [r1, #8]
 800b7ba:	f240 717c 	movw	r1, #1916	; 0x77c
 800b7be:	f043 0501 	orr.w	r5, r3, #1
 800b7c2:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800b7c6:	6055      	str	r5, [r2, #4]
 800b7c8:	6082      	str	r2, [r0, #8]
 800b7ca:	680a      	ldr	r2, [r1, #0]
 800b7cc:	4293      	cmp	r3, r2
 800b7ce:	d3b3      	bcc.n	800b738 <_free_r+0x94>
 800b7d0:	f641 1388 	movw	r3, #6536	; 0x1988
 800b7d4:	4620      	mov	r0, r4
 800b7d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b7da:	6819      	ldr	r1, [r3, #0]
 800b7dc:	f7ff ff0e 	bl	800b5fc <_malloc_trim_r>
 800b7e0:	e7aa      	b.n	800b738 <_free_r+0x94>
 800b7e2:	2601      	movs	r6, #1
 800b7e4:	e77c      	b.n	800b6e0 <_free_r+0x3c>
 800b7e6:	2914      	cmp	r1, #20
 800b7e8:	d80c      	bhi.n	800b804 <_free_r+0x160>
 800b7ea:	f101 065b 	add.w	r6, r1, #91	; 0x5b
 800b7ee:	00f5      	lsls	r5, r6, #3
 800b7f0:	e790      	b.n	800b714 <_free_r+0x70>
 800b7f2:	2501      	movs	r5, #1
 800b7f4:	6847      	ldr	r7, [r0, #4]
 800b7f6:	10b6      	asrs	r6, r6, #2
 800b7f8:	460b      	mov	r3, r1
 800b7fa:	40b5      	lsls	r5, r6
 800b7fc:	ea47 0505 	orr.w	r5, r7, r5
 800b800:	6045      	str	r5, [r0, #4]
 800b802:	e795      	b.n	800b730 <_free_r+0x8c>
 800b804:	2954      	cmp	r1, #84	; 0x54
 800b806:	d803      	bhi.n	800b810 <_free_r+0x16c>
 800b808:	0b1e      	lsrs	r6, r3, #12
 800b80a:	366e      	adds	r6, #110	; 0x6e
 800b80c:	00f5      	lsls	r5, r6, #3
 800b80e:	e781      	b.n	800b714 <_free_r+0x70>
 800b810:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
 800b814:	d803      	bhi.n	800b81e <_free_r+0x17a>
 800b816:	0bde      	lsrs	r6, r3, #15
 800b818:	3677      	adds	r6, #119	; 0x77
 800b81a:	00f5      	lsls	r5, r6, #3
 800b81c:	e77a      	b.n	800b714 <_free_r+0x70>
 800b81e:	f240 5554 	movw	r5, #1364	; 0x554
 800b822:	42a9      	cmp	r1, r5
 800b824:	d803      	bhi.n	800b82e <_free_r+0x18a>
 800b826:	0c9e      	lsrs	r6, r3, #18
 800b828:	367c      	adds	r6, #124	; 0x7c
 800b82a:	00f5      	lsls	r5, r6, #3
 800b82c:	e772      	b.n	800b714 <_free_r+0x70>
 800b82e:	f44f 757c 	mov.w	r5, #1008	; 0x3f0
 800b832:	267e      	movs	r6, #126	; 0x7e
 800b834:	e76e      	b.n	800b714 <_free_r+0x70>
 800b836:	bf00      	nop
 800b838:	20000378 	.word	0x20000378

0800b83c <_fwalk>:
 800b83c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800b840:	4607      	mov	r7, r0
 800b842:	4689      	mov	r9, r1
 800b844:	f7ff feba 	bl	800b5bc <__sfp_lock_acquire>
 800b848:	37d8      	adds	r7, #216	; 0xd8
 800b84a:	bf08      	it	eq
 800b84c:	46b8      	moveq	r8, r7
 800b84e:	d01a      	beq.n	800b886 <_fwalk+0x4a>
 800b850:	f04f 0800 	mov.w	r8, #0
 800b854:	687e      	ldr	r6, [r7, #4]
 800b856:	68bc      	ldr	r4, [r7, #8]
 800b858:	2e00      	cmp	r6, #0
 800b85a:	dd11      	ble.n	800b880 <_fwalk+0x44>
 800b85c:	2500      	movs	r5, #0
 800b85e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800b862:	3501      	adds	r5, #1
 800b864:	b143      	cbz	r3, 800b878 <_fwalk+0x3c>
 800b866:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 800b86a:	4620      	mov	r0, r4
 800b86c:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b870:	d002      	beq.n	800b878 <_fwalk+0x3c>
 800b872:	47c8      	blx	r9
 800b874:	ea48 0800 	orr.w	r8, r8, r0
 800b878:	42b5      	cmp	r5, r6
 800b87a:	f104 0468 	add.w	r4, r4, #104	; 0x68
 800b87e:	d1ee      	bne.n	800b85e <_fwalk+0x22>
 800b880:	683f      	ldr	r7, [r7, #0]
 800b882:	2f00      	cmp	r7, #0
 800b884:	d1e6      	bne.n	800b854 <_fwalk+0x18>
 800b886:	f7ff fe9b 	bl	800b5c0 <__sfp_lock_release>
 800b88a:	4640      	mov	r0, r8
 800b88c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0800b890 <_fwalk_reent>:
 800b890:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800b894:	4680      	mov	r8, r0
 800b896:	468a      	mov	sl, r1
 800b898:	f7ff fe90 	bl	800b5bc <__sfp_lock_acquire>
 800b89c:	f118 07d8 	adds.w	r7, r8, #216	; 0xd8
 800b8a0:	bf08      	it	eq
 800b8a2:	46b9      	moveq	r9, r7
 800b8a4:	d01b      	beq.n	800b8de <_fwalk_reent+0x4e>
 800b8a6:	f04f 0900 	mov.w	r9, #0
 800b8aa:	687e      	ldr	r6, [r7, #4]
 800b8ac:	68bc      	ldr	r4, [r7, #8]
 800b8ae:	2e00      	cmp	r6, #0
 800b8b0:	dd12      	ble.n	800b8d8 <_fwalk_reent+0x48>
 800b8b2:	2500      	movs	r5, #0
 800b8b4:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800b8b8:	3501      	adds	r5, #1
 800b8ba:	b14b      	cbz	r3, 800b8d0 <_fwalk_reent+0x40>
 800b8bc:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 800b8c0:	4621      	mov	r1, r4
 800b8c2:	4640      	mov	r0, r8
 800b8c4:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b8c8:	d002      	beq.n	800b8d0 <_fwalk_reent+0x40>
 800b8ca:	47d0      	blx	sl
 800b8cc:	ea49 0900 	orr.w	r9, r9, r0
 800b8d0:	42b5      	cmp	r5, r6
 800b8d2:	f104 0468 	add.w	r4, r4, #104	; 0x68
 800b8d6:	d1ed      	bne.n	800b8b4 <_fwalk_reent+0x24>
 800b8d8:	683f      	ldr	r7, [r7, #0]
 800b8da:	2f00      	cmp	r7, #0
 800b8dc:	d1e5      	bne.n	800b8aa <_fwalk_reent+0x1a>
 800b8de:	f7ff fe6f 	bl	800b5c0 <__sfp_lock_release>
 800b8e2:	4648      	mov	r0, r9
 800b8e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0800b8e8 <_setlocale_r>:
 800b8e8:	b510      	push	{r4, lr}
 800b8ea:	4614      	mov	r4, r2
 800b8ec:	b13a      	cbz	r2, 800b8fe <_setlocale_r+0x16>
 800b8ee:	f240 41c8 	movw	r1, #1224	; 0x4c8
 800b8f2:	4610      	mov	r0, r2
 800b8f4:	f6c0 0101 	movt	r1, #2049	; 0x801
 800b8f8:	f7fb fa8a 	bl	8006e10 <strcmp>
 800b8fc:	b920      	cbnz	r0, 800b908 <_setlocale_r+0x20>
 800b8fe:	f240 4070 	movw	r0, #1136	; 0x470
 800b902:	f6c0 0001 	movt	r0, #2049	; 0x801
 800b906:	bd10      	pop	{r4, pc}
 800b908:	f240 4170 	movw	r1, #1136	; 0x470
 800b90c:	4620      	mov	r0, r4
 800b90e:	f6c0 0101 	movt	r1, #2049	; 0x801
 800b912:	f7fb fa7d 	bl	8006e10 <strcmp>
 800b916:	b920      	cbnz	r0, 800b922 <_setlocale_r+0x3a>
 800b918:	f240 4070 	movw	r0, #1136	; 0x470
 800b91c:	f6c0 0001 	movt	r0, #2049	; 0x801
 800b920:	bd10      	pop	{r4, pc}
 800b922:	f240 4194 	movw	r1, #1172	; 0x494
 800b926:	4620      	mov	r0, r4
 800b928:	f6c0 0101 	movt	r1, #2049	; 0x801
 800b92c:	f7fb fa70 	bl	8006e10 <strcmp>
 800b930:	f240 4370 	movw	r3, #1136	; 0x470
 800b934:	f6c0 0301 	movt	r3, #2049	; 0x801
 800b938:	2800      	cmp	r0, #0
 800b93a:	bf0c      	ite	eq
 800b93c:	4618      	moveq	r0, r3
 800b93e:	2000      	movne	r0, #0
 800b940:	bd10      	pop	{r4, pc}
 800b942:	bf00      	nop

0800b944 <__locale_charset>:
 800b944:	f240 7080 	movw	r0, #1920	; 0x780
 800b948:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800b94c:	4770      	bx	lr
 800b94e:	bf00      	nop

0800b950 <__locale_mb_cur_max>:
 800b950:	f240 7380 	movw	r3, #1920	; 0x780
 800b954:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b958:	6a18      	ldr	r0, [r3, #32]
 800b95a:	4770      	bx	lr

0800b95c <__locale_msgcharset>:
 800b95c:	4800      	ldr	r0, [pc, #0]	; (800b960 <__locale_msgcharset+0x4>)
 800b95e:	4770      	bx	lr
 800b960:	200007a4 	.word	0x200007a4

0800b964 <__locale_cjk_lang>:
 800b964:	2000      	movs	r0, #0
 800b966:	4770      	bx	lr

0800b968 <_localeconv_r>:
 800b968:	4800      	ldr	r0, [pc, #0]	; (800b96c <_localeconv_r+0x4>)
 800b96a:	4770      	bx	lr
 800b96c:	200007c4 	.word	0x200007c4

0800b970 <setlocale>:
 800b970:	f240 237c 	movw	r3, #636	; 0x27c
 800b974:	460a      	mov	r2, r1
 800b976:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b97a:	4601      	mov	r1, r0
 800b97c:	6818      	ldr	r0, [r3, #0]
 800b97e:	e7b3      	b.n	800b8e8 <_setlocale_r>

0800b980 <localeconv>:
 800b980:	4800      	ldr	r0, [pc, #0]	; (800b984 <localeconv+0x4>)
 800b982:	4770      	bx	lr
 800b984:	200007c4 	.word	0x200007c4

0800b988 <__smakebuf_r>:
 800b988:	898b      	ldrh	r3, [r1, #12]
 800b98a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b98c:	460c      	mov	r4, r1
 800b98e:	b29a      	uxth	r2, r3
 800b990:	b091      	sub	sp, #68	; 0x44
 800b992:	f012 0f02 	tst.w	r2, #2
 800b996:	4605      	mov	r5, r0
 800b998:	d13b      	bne.n	800ba12 <__smakebuf_r+0x8a>
 800b99a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800b99e:	2900      	cmp	r1, #0
 800b9a0:	db18      	blt.n	800b9d4 <__smakebuf_r+0x4c>
 800b9a2:	aa01      	add	r2, sp, #4
 800b9a4:	f002 fdcc 	bl	800e540 <_fstat_r>
 800b9a8:	2800      	cmp	r0, #0
 800b9aa:	db11      	blt.n	800b9d0 <__smakebuf_r+0x48>
 800b9ac:	9b02      	ldr	r3, [sp, #8]
 800b9ae:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
 800b9b2:	f5a3 5200 	sub.w	r2, r3, #8192	; 0x2000
 800b9b6:	4257      	negs	r7, r2
 800b9b8:	eb47 0702 	adc.w	r7, r7, r2
 800b9bc:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800b9c0:	d03a      	beq.n	800ba38 <__smakebuf_r+0xb0>
 800b9c2:	89a3      	ldrh	r3, [r4, #12]
 800b9c4:	f44f 6680 	mov.w	r6, #1024	; 0x400
 800b9c8:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800b9cc:	81a3      	strh	r3, [r4, #12]
 800b9ce:	e00b      	b.n	800b9e8 <__smakebuf_r+0x60>
 800b9d0:	89a3      	ldrh	r3, [r4, #12]
 800b9d2:	b29a      	uxth	r2, r3
 800b9d4:	f012 0f80 	tst.w	r2, #128	; 0x80
 800b9d8:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800b9dc:	bf14      	ite	ne
 800b9de:	2640      	movne	r6, #64	; 0x40
 800b9e0:	f44f 6680 	moveq.w	r6, #1024	; 0x400
 800b9e4:	2700      	movs	r7, #0
 800b9e6:	81a3      	strh	r3, [r4, #12]
 800b9e8:	4628      	mov	r0, r5
 800b9ea:	4631      	mov	r1, r6
 800b9ec:	f7fa fdb8 	bl	8006560 <_malloc_r>
 800b9f0:	2800      	cmp	r0, #0
 800b9f2:	d031      	beq.n	800ba58 <__smakebuf_r+0xd0>
 800b9f4:	89a2      	ldrh	r2, [r4, #12]
 800b9f6:	f24b 33e5 	movw	r3, #46053	; 0xb3e5
 800b9fa:	f6c0 0300 	movt	r3, #2048	; 0x800
 800b9fe:	62ab      	str	r3, [r5, #40]	; 0x28
 800ba00:	f042 0380 	orr.w	r3, r2, #128	; 0x80
 800ba04:	6020      	str	r0, [r4, #0]
 800ba06:	81a3      	strh	r3, [r4, #12]
 800ba08:	6120      	str	r0, [r4, #16]
 800ba0a:	6166      	str	r6, [r4, #20]
 800ba0c:	b947      	cbnz	r7, 800ba20 <__smakebuf_r+0x98>
 800ba0e:	b011      	add	sp, #68	; 0x44
 800ba10:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800ba12:	f101 0347 	add.w	r3, r1, #71	; 0x47
 800ba16:	600b      	str	r3, [r1, #0]
 800ba18:	610b      	str	r3, [r1, #16]
 800ba1a:	2301      	movs	r3, #1
 800ba1c:	614b      	str	r3, [r1, #20]
 800ba1e:	e7f6      	b.n	800ba0e <__smakebuf_r+0x86>
 800ba20:	4628      	mov	r0, r5
 800ba22:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800ba26:	f002 ff3d 	bl	800e8a4 <_isatty_r>
 800ba2a:	2800      	cmp	r0, #0
 800ba2c:	d0ef      	beq.n	800ba0e <__smakebuf_r+0x86>
 800ba2e:	89a3      	ldrh	r3, [r4, #12]
 800ba30:	f043 0301 	orr.w	r3, r3, #1
 800ba34:	81a3      	strh	r3, [r4, #12]
 800ba36:	e7ea      	b.n	800ba0e <__smakebuf_r+0x86>
 800ba38:	f64c 0385 	movw	r3, #51333	; 0xc885
 800ba3c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800ba3e:	f6c0 0300 	movt	r3, #2048	; 0x800
 800ba42:	429a      	cmp	r2, r3
 800ba44:	d1bd      	bne.n	800b9c2 <__smakebuf_r+0x3a>
 800ba46:	89a2      	ldrh	r2, [r4, #12]
 800ba48:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800ba4c:	461e      	mov	r6, r3
 800ba4e:	6523      	str	r3, [r4, #80]	; 0x50
 800ba50:	ea42 0303 	orr.w	r3, r2, r3
 800ba54:	81a3      	strh	r3, [r4, #12]
 800ba56:	e7c7      	b.n	800b9e8 <__smakebuf_r+0x60>
 800ba58:	89a3      	ldrh	r3, [r4, #12]
 800ba5a:	f413 7f00 	tst.w	r3, #512	; 0x200
 800ba5e:	d1d6      	bne.n	800ba0e <__smakebuf_r+0x86>
 800ba60:	f104 0247 	add.w	r2, r4, #71	; 0x47
 800ba64:	f043 0302 	orr.w	r3, r3, #2
 800ba68:	6022      	str	r2, [r4, #0]
 800ba6a:	81a3      	strh	r3, [r4, #12]
 800ba6c:	2301      	movs	r3, #1
 800ba6e:	6122      	str	r2, [r4, #16]
 800ba70:	6163      	str	r3, [r4, #20]
 800ba72:	e7cc      	b.n	800ba0e <__smakebuf_r+0x86>

0800ba74 <memchr>:
 800ba74:	f010 0f03 	tst.w	r0, #3
 800ba78:	4603      	mov	r3, r0
 800ba7a:	b470      	push	{r4, r5, r6}
 800ba7c:	b2c9      	uxtb	r1, r1
 800ba7e:	d011      	beq.n	800baa4 <memchr+0x30>
 800ba80:	2a00      	cmp	r2, #0
 800ba82:	d022      	beq.n	800baca <memchr+0x56>
 800ba84:	7803      	ldrb	r3, [r0, #0]
 800ba86:	428b      	cmp	r3, r1
 800ba88:	d01d      	beq.n	800bac6 <memchr+0x52>
 800ba8a:	3a01      	subs	r2, #1
 800ba8c:	3001      	adds	r0, #1
 800ba8e:	e005      	b.n	800ba9c <memchr+0x28>
 800ba90:	b1da      	cbz	r2, 800baca <memchr+0x56>
 800ba92:	f810 4b01 	ldrb.w	r4, [r0], #1
 800ba96:	3a01      	subs	r2, #1
 800ba98:	428c      	cmp	r4, r1
 800ba9a:	d018      	beq.n	800bace <memchr+0x5a>
 800ba9c:	f010 0f03 	tst.w	r0, #3
 800baa0:	4603      	mov	r3, r0
 800baa2:	d1f5      	bne.n	800ba90 <memchr+0x1c>
 800baa4:	2a03      	cmp	r2, #3
 800baa6:	d814      	bhi.n	800bad2 <memchr+0x5e>
 800baa8:	b17a      	cbz	r2, 800baca <memchr+0x56>
 800baaa:	7818      	ldrb	r0, [r3, #0]
 800baac:	4288      	cmp	r0, r1
 800baae:	d00e      	beq.n	800bace <memchr+0x5a>
 800bab0:	1e54      	subs	r4, r2, #1
 800bab2:	1c5d      	adds	r5, r3, #1
 800bab4:	e003      	b.n	800babe <memchr+0x4a>
 800bab6:	f815 6b01 	ldrb.w	r6, [r5], #1
 800baba:	428e      	cmp	r6, r1
 800babc:	d003      	beq.n	800bac6 <memchr+0x52>
 800babe:	3c01      	subs	r4, #1
 800bac0:	4628      	mov	r0, r5
 800bac2:	d2f8      	bcs.n	800bab6 <memchr+0x42>
 800bac4:	2000      	movs	r0, #0
 800bac6:	bc70      	pop	{r4, r5, r6}
 800bac8:	4770      	bx	lr
 800baca:	4610      	mov	r0, r2
 800bacc:	e7fb      	b.n	800bac6 <memchr+0x52>
 800bace:	4618      	mov	r0, r3
 800bad0:	e7f9      	b.n	800bac6 <memchr+0x52>
 800bad2:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 800bad6:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 800bada:	4618      	mov	r0, r3
 800badc:	f853 4b04 	ldr.w	r4, [r3], #4
 800bae0:	ea86 0404 	eor.w	r4, r6, r4
 800bae4:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 800bae8:	ea25 0404 	bic.w	r4, r5, r4
 800baec:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 800baf0:	d103      	bne.n	800bafa <memchr+0x86>
 800baf2:	3a04      	subs	r2, #4
 800baf4:	4618      	mov	r0, r3
 800baf6:	2a03      	cmp	r2, #3
 800baf8:	d8ef      	bhi.n	800bada <memchr+0x66>
 800bafa:	4603      	mov	r3, r0
 800bafc:	e7d4      	b.n	800baa8 <memchr+0x34>
 800bafe:	bf00      	nop

0800bb00 <memcpy>:
 800bb00:	2a03      	cmp	r2, #3
 800bb02:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 800bb06:	d809      	bhi.n	800bb1c <memcpy+0x1c>
 800bb08:	b12a      	cbz	r2, 800bb16 <memcpy+0x16>
 800bb0a:	2300      	movs	r3, #0
 800bb0c:	5ccc      	ldrb	r4, [r1, r3]
 800bb0e:	54c4      	strb	r4, [r0, r3]
 800bb10:	3301      	adds	r3, #1
 800bb12:	4293      	cmp	r3, r2
 800bb14:	d1fa      	bne.n	800bb0c <memcpy+0xc>
 800bb16:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 800bb1a:	4770      	bx	lr
 800bb1c:	460b      	mov	r3, r1
 800bb1e:	1882      	adds	r2, r0, r2
 800bb20:	4601      	mov	r1, r0
 800bb22:	e003      	b.n	800bb2c <memcpy+0x2c>
 800bb24:	7824      	ldrb	r4, [r4, #0]
 800bb26:	3301      	adds	r3, #1
 800bb28:	f801 4b01 	strb.w	r4, [r1], #1
 800bb2c:	f011 0f03 	tst.w	r1, #3
 800bb30:	461c      	mov	r4, r3
 800bb32:	d1f7      	bne.n	800bb24 <memcpy+0x24>
 800bb34:	f013 0503 	ands.w	r5, r3, #3
 800bb38:	d05d      	beq.n	800bbf6 <memcpy+0xf6>
 800bb3a:	426e      	negs	r6, r5
 800bb3c:	f1c5 0c04 	rsb	ip, r5, #4
 800bb40:	00ed      	lsls	r5, r5, #3
 800bb42:	599b      	ldr	r3, [r3, r6]
 800bb44:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 800bb48:	e008      	b.n	800bb5c <memcpy+0x5c>
 800bb4a:	3404      	adds	r4, #4
 800bb4c:	59a7      	ldr	r7, [r4, r6]
 800bb4e:	463b      	mov	r3, r7
 800bb50:	fa07 f70c 	lsl.w	r7, r7, ip
 800bb54:	ea48 0707 	orr.w	r7, r8, r7
 800bb58:	f841 7b04 	str.w	r7, [r1], #4
 800bb5c:	1a57      	subs	r7, r2, r1
 800bb5e:	fa23 f805 	lsr.w	r8, r3, r5
 800bb62:	2f03      	cmp	r7, #3
 800bb64:	dcf1      	bgt.n	800bb4a <memcpy+0x4a>
 800bb66:	e003      	b.n	800bb70 <memcpy+0x70>
 800bb68:	f814 3b01 	ldrb.w	r3, [r4], #1
 800bb6c:	f801 3b01 	strb.w	r3, [r1], #1
 800bb70:	428a      	cmp	r2, r1
 800bb72:	d8f9      	bhi.n	800bb68 <memcpy+0x68>
 800bb74:	e7cf      	b.n	800bb16 <memcpy+0x16>
 800bb76:	f853 4c40 	ldr.w	r4, [r3, #-64]
 800bb7a:	f841 4c40 	str.w	r4, [r1, #-64]
 800bb7e:	f853 4c3c 	ldr.w	r4, [r3, #-60]
 800bb82:	f841 4c3c 	str.w	r4, [r1, #-60]
 800bb86:	f853 4c38 	ldr.w	r4, [r3, #-56]
 800bb8a:	f841 4c38 	str.w	r4, [r1, #-56]
 800bb8e:	f853 4c34 	ldr.w	r4, [r3, #-52]
 800bb92:	f841 4c34 	str.w	r4, [r1, #-52]
 800bb96:	f853 4c30 	ldr.w	r4, [r3, #-48]
 800bb9a:	f841 4c30 	str.w	r4, [r1, #-48]
 800bb9e:	f853 4c2c 	ldr.w	r4, [r3, #-44]
 800bba2:	f841 4c2c 	str.w	r4, [r1, #-44]
 800bba6:	f853 4c28 	ldr.w	r4, [r3, #-40]
 800bbaa:	f841 4c28 	str.w	r4, [r1, #-40]
 800bbae:	f853 4c24 	ldr.w	r4, [r3, #-36]
 800bbb2:	f841 4c24 	str.w	r4, [r1, #-36]
 800bbb6:	f853 4c20 	ldr.w	r4, [r3, #-32]
 800bbba:	f841 4c20 	str.w	r4, [r1, #-32]
 800bbbe:	f853 4c1c 	ldr.w	r4, [r3, #-28]
 800bbc2:	f841 4c1c 	str.w	r4, [r1, #-28]
 800bbc6:	f853 4c18 	ldr.w	r4, [r3, #-24]
 800bbca:	f841 4c18 	str.w	r4, [r1, #-24]
 800bbce:	f853 4c14 	ldr.w	r4, [r3, #-20]
 800bbd2:	f841 4c14 	str.w	r4, [r1, #-20]
 800bbd6:	f853 4c10 	ldr.w	r4, [r3, #-16]
 800bbda:	f841 4c10 	str.w	r4, [r1, #-16]
 800bbde:	f853 4c0c 	ldr.w	r4, [r3, #-12]
 800bbe2:	f841 4c0c 	str.w	r4, [r1, #-12]
 800bbe6:	f853 4c08 	ldr.w	r4, [r3, #-8]
 800bbea:	f841 4c08 	str.w	r4, [r1, #-8]
 800bbee:	f853 4c04 	ldr.w	r4, [r3, #-4]
 800bbf2:	f841 4c04 	str.w	r4, [r1, #-4]
 800bbf6:	1a56      	subs	r6, r2, r1
 800bbf8:	461d      	mov	r5, r3
 800bbfa:	460c      	mov	r4, r1
 800bbfc:	3340      	adds	r3, #64	; 0x40
 800bbfe:	3140      	adds	r1, #64	; 0x40
 800bc00:	2e3f      	cmp	r6, #63	; 0x3f
 800bc02:	dcb8      	bgt.n	800bb76 <memcpy+0x76>
 800bc04:	462b      	mov	r3, r5
 800bc06:	e00f      	b.n	800bc28 <memcpy+0x128>
 800bc08:	f853 1c10 	ldr.w	r1, [r3, #-16]
 800bc0c:	f844 1c10 	str.w	r1, [r4, #-16]
 800bc10:	f853 1c0c 	ldr.w	r1, [r3, #-12]
 800bc14:	f844 1c0c 	str.w	r1, [r4, #-12]
 800bc18:	f853 1c08 	ldr.w	r1, [r3, #-8]
 800bc1c:	f844 1c08 	str.w	r1, [r4, #-8]
 800bc20:	f853 1c04 	ldr.w	r1, [r3, #-4]
 800bc24:	f844 1c04 	str.w	r1, [r4, #-4]
 800bc28:	1b16      	subs	r6, r2, r4
 800bc2a:	4621      	mov	r1, r4
 800bc2c:	461d      	mov	r5, r3
 800bc2e:	3410      	adds	r4, #16
 800bc30:	3310      	adds	r3, #16
 800bc32:	2e0f      	cmp	r6, #15
 800bc34:	dce8      	bgt.n	800bc08 <memcpy+0x108>
 800bc36:	462b      	mov	r3, r5
 800bc38:	e002      	b.n	800bc40 <memcpy+0x140>
 800bc3a:	6824      	ldr	r4, [r4, #0]
 800bc3c:	f841 4b04 	str.w	r4, [r1], #4
 800bc40:	1a55      	subs	r5, r2, r1
 800bc42:	461c      	mov	r4, r3
 800bc44:	2d03      	cmp	r5, #3
 800bc46:	f103 0304 	add.w	r3, r3, #4
 800bc4a:	dcf6      	bgt.n	800bc3a <memcpy+0x13a>
 800bc4c:	e790      	b.n	800bb70 <memcpy+0x70>
 800bc4e:	bf00      	nop

0800bc50 <memset>:
 800bc50:	2a03      	cmp	r2, #3
 800bc52:	b2c9      	uxtb	r1, r1
 800bc54:	b470      	push	{r4, r5, r6}
 800bc56:	d808      	bhi.n	800bc6a <memset+0x1a>
 800bc58:	b12a      	cbz	r2, 800bc66 <memset+0x16>
 800bc5a:	4603      	mov	r3, r0
 800bc5c:	1812      	adds	r2, r2, r0
 800bc5e:	f803 1b01 	strb.w	r1, [r3], #1
 800bc62:	4293      	cmp	r3, r2
 800bc64:	d1fb      	bne.n	800bc5e <memset+0xe>
 800bc66:	bc70      	pop	{r4, r5, r6}
 800bc68:	4770      	bx	lr
 800bc6a:	1882      	adds	r2, r0, r2
 800bc6c:	4604      	mov	r4, r0
 800bc6e:	e001      	b.n	800bc74 <memset+0x24>
 800bc70:	f804 1b01 	strb.w	r1, [r4], #1
 800bc74:	f014 0f03 	tst.w	r4, #3
 800bc78:	d1fa      	bne.n	800bc70 <memset+0x20>
 800bc7a:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
 800bc7e:	fb03 f301 	mul.w	r3, r3, r1
 800bc82:	e01f      	b.n	800bcc4 <memset+0x74>
 800bc84:	f844 3c40 	str.w	r3, [r4, #-64]
 800bc88:	f844 3c3c 	str.w	r3, [r4, #-60]
 800bc8c:	f844 3c38 	str.w	r3, [r4, #-56]
 800bc90:	f844 3c34 	str.w	r3, [r4, #-52]
 800bc94:	f844 3c30 	str.w	r3, [r4, #-48]
 800bc98:	f844 3c2c 	str.w	r3, [r4, #-44]
 800bc9c:	f844 3c28 	str.w	r3, [r4, #-40]
 800bca0:	f844 3c24 	str.w	r3, [r4, #-36]
 800bca4:	f844 3c20 	str.w	r3, [r4, #-32]
 800bca8:	f844 3c1c 	str.w	r3, [r4, #-28]
 800bcac:	f844 3c18 	str.w	r3, [r4, #-24]
 800bcb0:	f844 3c14 	str.w	r3, [r4, #-20]
 800bcb4:	f844 3c10 	str.w	r3, [r4, #-16]
 800bcb8:	f844 3c0c 	str.w	r3, [r4, #-12]
 800bcbc:	f844 3c08 	str.w	r3, [r4, #-8]
 800bcc0:	f844 3c04 	str.w	r3, [r4, #-4]
 800bcc4:	1b16      	subs	r6, r2, r4
 800bcc6:	4625      	mov	r5, r4
 800bcc8:	3440      	adds	r4, #64	; 0x40
 800bcca:	2e3f      	cmp	r6, #63	; 0x3f
 800bccc:	dcda      	bgt.n	800bc84 <memset+0x34>
 800bcce:	462c      	mov	r4, r5
 800bcd0:	e007      	b.n	800bce2 <memset+0x92>
 800bcd2:	f844 3c10 	str.w	r3, [r4, #-16]
 800bcd6:	f844 3c0c 	str.w	r3, [r4, #-12]
 800bcda:	f844 3c08 	str.w	r3, [r4, #-8]
 800bcde:	f844 3c04 	str.w	r3, [r4, #-4]
 800bce2:	1b16      	subs	r6, r2, r4
 800bce4:	4625      	mov	r5, r4
 800bce6:	3410      	adds	r4, #16
 800bce8:	2e0f      	cmp	r6, #15
 800bcea:	dcf2      	bgt.n	800bcd2 <memset+0x82>
 800bcec:	e001      	b.n	800bcf2 <memset+0xa2>
 800bcee:	f845 3b04 	str.w	r3, [r5], #4
 800bcf2:	1b54      	subs	r4, r2, r5
 800bcf4:	2c03      	cmp	r4, #3
 800bcf6:	dcfa      	bgt.n	800bcee <memset+0x9e>
 800bcf8:	e001      	b.n	800bcfe <memset+0xae>
 800bcfa:	f805 1b01 	strb.w	r1, [r5], #1
 800bcfe:	4295      	cmp	r5, r2
 800bd00:	d3fb      	bcc.n	800bcfa <memset+0xaa>
 800bd02:	e7b0      	b.n	800bc66 <memset+0x16>

0800bd04 <_Balloc>:
 800bd04:	b570      	push	{r4, r5, r6, lr}
 800bd06:	4606      	mov	r6, r0
 800bd08:	6a44      	ldr	r4, [r0, #36]	; 0x24
 800bd0a:	460d      	mov	r5, r1
 800bd0c:	b15c      	cbz	r4, 800bd26 <_Balloc+0x22>
 800bd0e:	68e3      	ldr	r3, [r4, #12]
 800bd10:	b19b      	cbz	r3, 800bd3a <_Balloc+0x36>
 800bd12:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 800bd16:	b1e0      	cbz	r0, 800bd52 <_Balloc+0x4e>
 800bd18:	6802      	ldr	r2, [r0, #0]
 800bd1a:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
 800bd1e:	2300      	movs	r3, #0
 800bd20:	6103      	str	r3, [r0, #16]
 800bd22:	60c3      	str	r3, [r0, #12]
 800bd24:	bd70      	pop	{r4, r5, r6, pc}
 800bd26:	2010      	movs	r0, #16
 800bd28:	f7fa fc0a 	bl	8006540 <malloc>
 800bd2c:	2300      	movs	r3, #0
 800bd2e:	4604      	mov	r4, r0
 800bd30:	6270      	str	r0, [r6, #36]	; 0x24
 800bd32:	6043      	str	r3, [r0, #4]
 800bd34:	6083      	str	r3, [r0, #8]
 800bd36:	6003      	str	r3, [r0, #0]
 800bd38:	60c3      	str	r3, [r0, #12]
 800bd3a:	4630      	mov	r0, r6
 800bd3c:	2104      	movs	r1, #4
 800bd3e:	2221      	movs	r2, #33	; 0x21
 800bd40:	f002 faba 	bl	800e2b8 <_calloc_r>
 800bd44:	6a73      	ldr	r3, [r6, #36]	; 0x24
 800bd46:	60e0      	str	r0, [r4, #12]
 800bd48:	68db      	ldr	r3, [r3, #12]
 800bd4a:	2b00      	cmp	r3, #0
 800bd4c:	d1e1      	bne.n	800bd12 <_Balloc+0xe>
 800bd4e:	4618      	mov	r0, r3
 800bd50:	bd70      	pop	{r4, r5, r6, pc}
 800bd52:	2401      	movs	r4, #1
 800bd54:	4630      	mov	r0, r6
 800bd56:	4621      	mov	r1, r4
 800bd58:	40ac      	lsls	r4, r5
 800bd5a:	1d62      	adds	r2, r4, #5
 800bd5c:	0092      	lsls	r2, r2, #2
 800bd5e:	f002 faab 	bl	800e2b8 <_calloc_r>
 800bd62:	2800      	cmp	r0, #0
 800bd64:	d0f4      	beq.n	800bd50 <_Balloc+0x4c>
 800bd66:	6045      	str	r5, [r0, #4]
 800bd68:	6084      	str	r4, [r0, #8]
 800bd6a:	e7d8      	b.n	800bd1e <_Balloc+0x1a>

0800bd6c <_Bfree>:
 800bd6c:	b530      	push	{r4, r5, lr}
 800bd6e:	4604      	mov	r4, r0
 800bd70:	6a45      	ldr	r5, [r0, #36]	; 0x24
 800bd72:	b083      	sub	sp, #12
 800bd74:	b155      	cbz	r5, 800bd8c <_Bfree+0x20>
 800bd76:	b139      	cbz	r1, 800bd88 <_Bfree+0x1c>
 800bd78:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800bd7a:	684a      	ldr	r2, [r1, #4]
 800bd7c:	68db      	ldr	r3, [r3, #12]
 800bd7e:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 800bd82:	6008      	str	r0, [r1, #0]
 800bd84:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 800bd88:	b003      	add	sp, #12
 800bd8a:	bd30      	pop	{r4, r5, pc}
 800bd8c:	2010      	movs	r0, #16
 800bd8e:	9101      	str	r1, [sp, #4]
 800bd90:	f7fa fbd6 	bl	8006540 <malloc>
 800bd94:	9901      	ldr	r1, [sp, #4]
 800bd96:	6260      	str	r0, [r4, #36]	; 0x24
 800bd98:	6045      	str	r5, [r0, #4]
 800bd9a:	6085      	str	r5, [r0, #8]
 800bd9c:	6005      	str	r5, [r0, #0]
 800bd9e:	60c5      	str	r5, [r0, #12]
 800bda0:	e7e9      	b.n	800bd76 <_Bfree+0xa>
 800bda2:	bf00      	nop

0800bda4 <__multadd>:
 800bda4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800bda8:	460c      	mov	r4, r1
 800bdaa:	4605      	mov	r5, r0
 800bdac:	690e      	ldr	r6, [r1, #16]
 800bdae:	f101 0014 	add.w	r0, r1, #20
 800bdb2:	b082      	sub	sp, #8
 800bdb4:	2100      	movs	r1, #0
 800bdb6:	6807      	ldr	r7, [r0, #0]
 800bdb8:	3101      	adds	r1, #1
 800bdba:	fa1f fc87 	uxth.w	ip, r7
 800bdbe:	0c3f      	lsrs	r7, r7, #16
 800bdc0:	fb0c 3302 	mla	r3, ip, r2, r3
 800bdc4:	fb07 f702 	mul.w	r7, r7, r2
 800bdc8:	eb07 4713 	add.w	r7, r7, r3, lsr #16
 800bdcc:	fa1f fc83 	uxth.w	ip, r3
 800bdd0:	0c3b      	lsrs	r3, r7, #16
 800bdd2:	428e      	cmp	r6, r1
 800bdd4:	ea4f 4807 	mov.w	r8, r7, lsl #16
 800bdd8:	eb08 070c 	add.w	r7, r8, ip
 800bddc:	f840 7b04 	str.w	r7, [r0], #4
 800bde0:	dce9      	bgt.n	800bdb6 <__multadd+0x12>
 800bde2:	b13b      	cbz	r3, 800bdf4 <__multadd+0x50>
 800bde4:	68a2      	ldr	r2, [r4, #8]
 800bde6:	4296      	cmp	r6, r2
 800bde8:	da08      	bge.n	800bdfc <__multadd+0x58>
 800bdea:	eb04 0286 	add.w	r2, r4, r6, lsl #2
 800bdee:	3601      	adds	r6, #1
 800bdf0:	6126      	str	r6, [r4, #16]
 800bdf2:	6153      	str	r3, [r2, #20]
 800bdf4:	4620      	mov	r0, r4
 800bdf6:	b002      	add	sp, #8
 800bdf8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bdfc:	6861      	ldr	r1, [r4, #4]
 800bdfe:	4628      	mov	r0, r5
 800be00:	9301      	str	r3, [sp, #4]
 800be02:	3101      	adds	r1, #1
 800be04:	f7ff ff7e 	bl	800bd04 <_Balloc>
 800be08:	6922      	ldr	r2, [r4, #16]
 800be0a:	f104 010c 	add.w	r1, r4, #12
 800be0e:	3202      	adds	r2, #2
 800be10:	0092      	lsls	r2, r2, #2
 800be12:	4607      	mov	r7, r0
 800be14:	300c      	adds	r0, #12
 800be16:	f7ff fe73 	bl	800bb00 <memcpy>
 800be1a:	4621      	mov	r1, r4
 800be1c:	4628      	mov	r0, r5
 800be1e:	463c      	mov	r4, r7
 800be20:	f7ff ffa4 	bl	800bd6c <_Bfree>
 800be24:	9b01      	ldr	r3, [sp, #4]
 800be26:	e7e0      	b.n	800bdea <__multadd+0x46>

0800be28 <__s2b>:
 800be28:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800be2c:	f648 6539 	movw	r5, #36409	; 0x8e39
 800be30:	461f      	mov	r7, r3
 800be32:	f6c3 05e3 	movt	r5, #14563	; 0x38e3
 800be36:	3308      	adds	r3, #8
 800be38:	460e      	mov	r6, r1
 800be3a:	4604      	mov	r4, r0
 800be3c:	4690      	mov	r8, r2
 800be3e:	fb85 1503 	smull	r1, r5, r5, r3
 800be42:	17db      	asrs	r3, r3, #31
 800be44:	ebc3 0365 	rsb	r3, r3, r5, asr #1
 800be48:	2b01      	cmp	r3, #1
 800be4a:	dd37      	ble.n	800bebc <__s2b+0x94>
 800be4c:	2201      	movs	r2, #1
 800be4e:	2100      	movs	r1, #0
 800be50:	0052      	lsls	r2, r2, #1
 800be52:	3101      	adds	r1, #1
 800be54:	4293      	cmp	r3, r2
 800be56:	dcfb      	bgt.n	800be50 <__s2b+0x28>
 800be58:	4620      	mov	r0, r4
 800be5a:	f7ff ff53 	bl	800bd04 <_Balloc>
 800be5e:	9b08      	ldr	r3, [sp, #32]
 800be60:	6143      	str	r3, [r0, #20]
 800be62:	2301      	movs	r3, #1
 800be64:	f1b8 0f09 	cmp.w	r8, #9
 800be68:	4601      	mov	r1, r0
 800be6a:	6103      	str	r3, [r0, #16]
 800be6c:	dd22      	ble.n	800beb4 <__s2b+0x8c>
 800be6e:	f106 0909 	add.w	r9, r6, #9
 800be72:	4446      	add	r6, r8
 800be74:	464d      	mov	r5, r9
 800be76:	f815 3b01 	ldrb.w	r3, [r5], #1
 800be7a:	220a      	movs	r2, #10
 800be7c:	4620      	mov	r0, r4
 800be7e:	3b30      	subs	r3, #48	; 0x30
 800be80:	f7ff ff90 	bl	800bda4 <__multadd>
 800be84:	42b5      	cmp	r5, r6
 800be86:	4601      	mov	r1, r0
 800be88:	d1f5      	bne.n	800be76 <__s2b+0x4e>
 800be8a:	eb09 0608 	add.w	r6, r9, r8
 800be8e:	3e08      	subs	r6, #8
 800be90:	4547      	cmp	r7, r8
 800be92:	dd0c      	ble.n	800beae <__s2b+0x86>
 800be94:	19f7      	adds	r7, r6, r7
 800be96:	ebc8 0707 	rsb	r7, r8, r7
 800be9a:	f816 3b01 	ldrb.w	r3, [r6], #1
 800be9e:	220a      	movs	r2, #10
 800bea0:	4620      	mov	r0, r4
 800bea2:	3b30      	subs	r3, #48	; 0x30
 800bea4:	f7ff ff7e 	bl	800bda4 <__multadd>
 800bea8:	42be      	cmp	r6, r7
 800beaa:	4601      	mov	r1, r0
 800beac:	d1f5      	bne.n	800be9a <__s2b+0x72>
 800beae:	4608      	mov	r0, r1
 800beb0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800beb4:	360a      	adds	r6, #10
 800beb6:	f04f 0809 	mov.w	r8, #9
 800beba:	e7e9      	b.n	800be90 <__s2b+0x68>
 800bebc:	2100      	movs	r1, #0
 800bebe:	e7cb      	b.n	800be58 <__s2b+0x30>

0800bec0 <__hi0bits>:
 800bec0:	0c02      	lsrs	r2, r0, #16
 800bec2:	4603      	mov	r3, r0
 800bec4:	d119      	bne.n	800befa <__hi0bits+0x3a>
 800bec6:	0403      	lsls	r3, r0, #16
 800bec8:	2010      	movs	r0, #16
 800beca:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
 800bece:	d101      	bne.n	800bed4 <__hi0bits+0x14>
 800bed0:	3008      	adds	r0, #8
 800bed2:	021b      	lsls	r3, r3, #8
 800bed4:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
 800bed8:	d101      	bne.n	800bede <__hi0bits+0x1e>
 800beda:	3004      	adds	r0, #4
 800bedc:	011b      	lsls	r3, r3, #4
 800bede:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
 800bee2:	d101      	bne.n	800bee8 <__hi0bits+0x28>
 800bee4:	3002      	adds	r0, #2
 800bee6:	009b      	lsls	r3, r3, #2
 800bee8:	2b00      	cmp	r3, #0
 800beea:	db05      	blt.n	800bef8 <__hi0bits+0x38>
 800beec:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
 800bef0:	d001      	beq.n	800bef6 <__hi0bits+0x36>
 800bef2:	3001      	adds	r0, #1
 800bef4:	4770      	bx	lr
 800bef6:	2020      	movs	r0, #32
 800bef8:	4770      	bx	lr
 800befa:	2000      	movs	r0, #0
 800befc:	e7e5      	b.n	800beca <__hi0bits+0xa>
 800befe:	bf00      	nop

0800bf00 <__lo0bits>:
 800bf00:	6803      	ldr	r3, [r0, #0]
 800bf02:	4602      	mov	r2, r0
 800bf04:	f013 0007 	ands.w	r0, r3, #7
 800bf08:	d009      	beq.n	800bf1e <__lo0bits+0x1e>
 800bf0a:	f013 0f01 	tst.w	r3, #1
 800bf0e:	d121      	bne.n	800bf54 <__lo0bits+0x54>
 800bf10:	f013 0f02 	tst.w	r3, #2
 800bf14:	d122      	bne.n	800bf5c <__lo0bits+0x5c>
 800bf16:	089b      	lsrs	r3, r3, #2
 800bf18:	2002      	movs	r0, #2
 800bf1a:	6013      	str	r3, [r2, #0]
 800bf1c:	4770      	bx	lr
 800bf1e:	b299      	uxth	r1, r3
 800bf20:	b909      	cbnz	r1, 800bf26 <__lo0bits+0x26>
 800bf22:	0c1b      	lsrs	r3, r3, #16
 800bf24:	2010      	movs	r0, #16
 800bf26:	f013 0fff 	tst.w	r3, #255	; 0xff
 800bf2a:	d101      	bne.n	800bf30 <__lo0bits+0x30>
 800bf2c:	3008      	adds	r0, #8
 800bf2e:	0a1b      	lsrs	r3, r3, #8
 800bf30:	f013 0f0f 	tst.w	r3, #15
 800bf34:	d101      	bne.n	800bf3a <__lo0bits+0x3a>
 800bf36:	3004      	adds	r0, #4
 800bf38:	091b      	lsrs	r3, r3, #4
 800bf3a:	f013 0f03 	tst.w	r3, #3
 800bf3e:	d101      	bne.n	800bf44 <__lo0bits+0x44>
 800bf40:	3002      	adds	r0, #2
 800bf42:	089b      	lsrs	r3, r3, #2
 800bf44:	f013 0f01 	tst.w	r3, #1
 800bf48:	d102      	bne.n	800bf50 <__lo0bits+0x50>
 800bf4a:	085b      	lsrs	r3, r3, #1
 800bf4c:	d004      	beq.n	800bf58 <__lo0bits+0x58>
 800bf4e:	3001      	adds	r0, #1
 800bf50:	6013      	str	r3, [r2, #0]
 800bf52:	4770      	bx	lr
 800bf54:	2000      	movs	r0, #0
 800bf56:	4770      	bx	lr
 800bf58:	2020      	movs	r0, #32
 800bf5a:	4770      	bx	lr
 800bf5c:	085b      	lsrs	r3, r3, #1
 800bf5e:	2001      	movs	r0, #1
 800bf60:	6013      	str	r3, [r2, #0]
 800bf62:	4770      	bx	lr

0800bf64 <__i2b>:
 800bf64:	b510      	push	{r4, lr}
 800bf66:	460c      	mov	r4, r1
 800bf68:	2101      	movs	r1, #1
 800bf6a:	f7ff fecb 	bl	800bd04 <_Balloc>
 800bf6e:	2201      	movs	r2, #1
 800bf70:	6144      	str	r4, [r0, #20]
 800bf72:	6102      	str	r2, [r0, #16]
 800bf74:	bd10      	pop	{r4, pc}
 800bf76:	bf00      	nop

0800bf78 <__multiply>:
 800bf78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800bf7c:	4690      	mov	r8, r2
 800bf7e:	690f      	ldr	r7, [r1, #16]
 800bf80:	460d      	mov	r5, r1
 800bf82:	6916      	ldr	r6, [r2, #16]
 800bf84:	b085      	sub	sp, #20
 800bf86:	42b7      	cmp	r7, r6
 800bf88:	bfbf      	itttt	lt
 800bf8a:	4645      	movlt	r5, r8
 800bf8c:	463a      	movlt	r2, r7
 800bf8e:	4637      	movlt	r7, r6
 800bf90:	4616      	movlt	r6, r2
 800bf92:	68ab      	ldr	r3, [r5, #8]
 800bf94:	bfb8      	it	lt
 800bf96:	4688      	movlt	r8, r1
 800bf98:	19f4      	adds	r4, r6, r7
 800bf9a:	6869      	ldr	r1, [r5, #4]
 800bf9c:	429c      	cmp	r4, r3
 800bf9e:	bfc8      	it	gt
 800bfa0:	3101      	addgt	r1, #1
 800bfa2:	f7ff feaf 	bl	800bd04 <_Balloc>
 800bfa6:	eb00 0384 	add.w	r3, r0, r4, lsl #2
 800bfaa:	f100 0c14 	add.w	ip, r0, #20
 800bfae:	3314      	adds	r3, #20
 800bfb0:	9001      	str	r0, [sp, #4]
 800bfb2:	459c      	cmp	ip, r3
 800bfb4:	9302      	str	r3, [sp, #8]
 800bfb6:	d206      	bcs.n	800bfc6 <__multiply+0x4e>
 800bfb8:	9902      	ldr	r1, [sp, #8]
 800bfba:	4663      	mov	r3, ip
 800bfbc:	2200      	movs	r2, #0
 800bfbe:	f843 2b04 	str.w	r2, [r3], #4
 800bfc2:	4299      	cmp	r1, r3
 800bfc4:	d8fb      	bhi.n	800bfbe <__multiply+0x46>
 800bfc6:	eb08 0686 	add.w	r6, r8, r6, lsl #2
 800bfca:	eb05 0787 	add.w	r7, r5, r7, lsl #2
 800bfce:	f108 0814 	add.w	r8, r8, #20
 800bfd2:	3614      	adds	r6, #20
 800bfd4:	3514      	adds	r5, #20
 800bfd6:	3714      	adds	r7, #20
 800bfd8:	45b0      	cmp	r8, r6
 800bfda:	9500      	str	r5, [sp, #0]
 800bfdc:	d24d      	bcs.n	800c07a <__multiply+0x102>
 800bfde:	9403      	str	r4, [sp, #12]
 800bfe0:	f858 4b04 	ldr.w	r4, [r8], #4
 800bfe4:	b2a0      	uxth	r0, r4
 800bfe6:	b1f0      	cbz	r0, 800c026 <__multiply+0xae>
 800bfe8:	9a00      	ldr	r2, [sp, #0]
 800bfea:	4663      	mov	r3, ip
 800bfec:	2400      	movs	r4, #0
 800bfee:	f852 5b04 	ldr.w	r5, [r2], #4
 800bff2:	6819      	ldr	r1, [r3, #0]
 800bff4:	fa1f fa85 	uxth.w	sl, r5
 800bff8:	0c2d      	lsrs	r5, r5, #16
 800bffa:	fa1f f981 	uxth.w	r9, r1
 800bffe:	0c09      	lsrs	r1, r1, #16
 800c000:	fb00 990a 	mla	r9, r0, sl, r9
 800c004:	fb00 1105 	mla	r1, r0, r5, r1
 800c008:	44a1      	add	r9, r4
 800c00a:	eb01 4119 	add.w	r1, r1, r9, lsr #16
 800c00e:	fa1f f989 	uxth.w	r9, r9
 800c012:	0c0c      	lsrs	r4, r1, #16
 800c014:	4297      	cmp	r7, r2
 800c016:	ea49 4501 	orr.w	r5, r9, r1, lsl #16
 800c01a:	f843 5b04 	str.w	r5, [r3], #4
 800c01e:	d8e6      	bhi.n	800bfee <__multiply+0x76>
 800c020:	601c      	str	r4, [r3, #0]
 800c022:	f858 4c04 	ldr.w	r4, [r8, #-4]
 800c026:	0c24      	lsrs	r4, r4, #16
 800c028:	d021      	beq.n	800c06e <__multiply+0xf6>
 800c02a:	f8dc 2000 	ldr.w	r2, [ip]
 800c02e:	4660      	mov	r0, ip
 800c030:	9b00      	ldr	r3, [sp, #0]
 800c032:	46e1      	mov	r9, ip
 800c034:	4611      	mov	r1, r2
 800c036:	2500      	movs	r5, #0
 800c038:	f8b3 a000 	ldrh.w	sl, [r3]
 800c03c:	fa1f fb82 	uxth.w	fp, r2
 800c040:	fb0a 5504 	mla	r5, sl, r4, r5
 800c044:	eb05 4511 	add.w	r5, r5, r1, lsr #16
 800c048:	ea4b 4205 	orr.w	r2, fp, r5, lsl #16
 800c04c:	f840 2b04 	str.w	r2, [r0], #4
 800c050:	f853 2b04 	ldr.w	r2, [r3], #4
 800c054:	f859 1f04 	ldr.w	r1, [r9, #4]!
 800c058:	0c12      	lsrs	r2, r2, #16
 800c05a:	fa1f fa81 	uxth.w	sl, r1
 800c05e:	fb02 a204 	mla	r2, r2, r4, sl
 800c062:	eb02 4215 	add.w	r2, r2, r5, lsr #16
 800c066:	0c15      	lsrs	r5, r2, #16
 800c068:	429f      	cmp	r7, r3
 800c06a:	d8e5      	bhi.n	800c038 <__multiply+0xc0>
 800c06c:	6002      	str	r2, [r0, #0]
 800c06e:	4546      	cmp	r6, r8
 800c070:	d902      	bls.n	800c078 <__multiply+0x100>
 800c072:	f10c 0c04 	add.w	ip, ip, #4
 800c076:	e7b3      	b.n	800bfe0 <__multiply+0x68>
 800c078:	9c03      	ldr	r4, [sp, #12]
 800c07a:	2c00      	cmp	r4, #0
 800c07c:	dd0a      	ble.n	800c094 <__multiply+0x11c>
 800c07e:	9902      	ldr	r1, [sp, #8]
 800c080:	1f0b      	subs	r3, r1, #4
 800c082:	f851 2c04 	ldr.w	r2, [r1, #-4]
 800c086:	b11a      	cbz	r2, 800c090 <__multiply+0x118>
 800c088:	e004      	b.n	800c094 <__multiply+0x11c>
 800c08a:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 800c08e:	b90a      	cbnz	r2, 800c094 <__multiply+0x11c>
 800c090:	3c01      	subs	r4, #1
 800c092:	d1fa      	bne.n	800c08a <__multiply+0x112>
 800c094:	9a01      	ldr	r2, [sp, #4]
 800c096:	4610      	mov	r0, r2
 800c098:	6114      	str	r4, [r2, #16]
 800c09a:	b005      	add	sp, #20
 800c09c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800c0a0 <__pow5mult>:
 800c0a0:	f012 0303 	ands.w	r3, r2, #3
 800c0a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c0a8:	4615      	mov	r5, r2
 800c0aa:	4604      	mov	r4, r0
 800c0ac:	4688      	mov	r8, r1
 800c0ae:	d128      	bne.n	800c102 <__pow5mult+0x62>
 800c0b0:	10ad      	asrs	r5, r5, #2
 800c0b2:	d01a      	beq.n	800c0ea <__pow5mult+0x4a>
 800c0b4:	6a66      	ldr	r6, [r4, #36]	; 0x24
 800c0b6:	2e00      	cmp	r6, #0
 800c0b8:	d02f      	beq.n	800c11a <__pow5mult+0x7a>
 800c0ba:	68b7      	ldr	r7, [r6, #8]
 800c0bc:	b92f      	cbnz	r7, 800c0ca <__pow5mult+0x2a>
 800c0be:	e036      	b.n	800c12e <__pow5mult+0x8e>
 800c0c0:	106d      	asrs	r5, r5, #1
 800c0c2:	d012      	beq.n	800c0ea <__pow5mult+0x4a>
 800c0c4:	683e      	ldr	r6, [r7, #0]
 800c0c6:	b19e      	cbz	r6, 800c0f0 <__pow5mult+0x50>
 800c0c8:	4637      	mov	r7, r6
 800c0ca:	f015 0f01 	tst.w	r5, #1
 800c0ce:	d0f7      	beq.n	800c0c0 <__pow5mult+0x20>
 800c0d0:	4641      	mov	r1, r8
 800c0d2:	463a      	mov	r2, r7
 800c0d4:	4620      	mov	r0, r4
 800c0d6:	f7ff ff4f 	bl	800bf78 <__multiply>
 800c0da:	4641      	mov	r1, r8
 800c0dc:	4606      	mov	r6, r0
 800c0de:	4620      	mov	r0, r4
 800c0e0:	f7ff fe44 	bl	800bd6c <_Bfree>
 800c0e4:	106d      	asrs	r5, r5, #1
 800c0e6:	46b0      	mov	r8, r6
 800c0e8:	d1ec      	bne.n	800c0c4 <__pow5mult+0x24>
 800c0ea:	4640      	mov	r0, r8
 800c0ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c0f0:	4639      	mov	r1, r7
 800c0f2:	463a      	mov	r2, r7
 800c0f4:	4620      	mov	r0, r4
 800c0f6:	f7ff ff3f 	bl	800bf78 <__multiply>
 800c0fa:	6038      	str	r0, [r7, #0]
 800c0fc:	4607      	mov	r7, r0
 800c0fe:	6006      	str	r6, [r0, #0]
 800c100:	e7e3      	b.n	800c0ca <__pow5mult+0x2a>
 800c102:	f240 2220 	movw	r2, #544	; 0x220
 800c106:	1e5e      	subs	r6, r3, #1
 800c108:	f6c0 0201 	movt	r2, #2049	; 0x801
 800c10c:	2300      	movs	r3, #0
 800c10e:	f852 2026 	ldr.w	r2, [r2, r6, lsl #2]
 800c112:	f7ff fe47 	bl	800bda4 <__multadd>
 800c116:	4680      	mov	r8, r0
 800c118:	e7ca      	b.n	800c0b0 <__pow5mult+0x10>
 800c11a:	2010      	movs	r0, #16
 800c11c:	f7fa fa10 	bl	8006540 <malloc>
 800c120:	2300      	movs	r3, #0
 800c122:	4606      	mov	r6, r0
 800c124:	6260      	str	r0, [r4, #36]	; 0x24
 800c126:	6043      	str	r3, [r0, #4]
 800c128:	6083      	str	r3, [r0, #8]
 800c12a:	6003      	str	r3, [r0, #0]
 800c12c:	60c3      	str	r3, [r0, #12]
 800c12e:	4620      	mov	r0, r4
 800c130:	f240 2171 	movw	r1, #625	; 0x271
 800c134:	f7ff ff16 	bl	800bf64 <__i2b>
 800c138:	2300      	movs	r3, #0
 800c13a:	60b0      	str	r0, [r6, #8]
 800c13c:	4607      	mov	r7, r0
 800c13e:	6003      	str	r3, [r0, #0]
 800c140:	e7c3      	b.n	800c0ca <__pow5mult+0x2a>
 800c142:	bf00      	nop

0800c144 <__lshift>:
 800c144:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800c148:	1156      	asrs	r6, r2, #5
 800c14a:	690d      	ldr	r5, [r1, #16]
 800c14c:	460c      	mov	r4, r1
 800c14e:	688b      	ldr	r3, [r1, #8]
 800c150:	4690      	mov	r8, r2
 800c152:	3501      	adds	r5, #1
 800c154:	4681      	mov	r9, r0
 800c156:	19ad      	adds	r5, r5, r6
 800c158:	6849      	ldr	r1, [r1, #4]
 800c15a:	429d      	cmp	r5, r3
 800c15c:	dd03      	ble.n	800c166 <__lshift+0x22>
 800c15e:	005b      	lsls	r3, r3, #1
 800c160:	3101      	adds	r1, #1
 800c162:	429d      	cmp	r5, r3
 800c164:	dcfb      	bgt.n	800c15e <__lshift+0x1a>
 800c166:	4648      	mov	r0, r9
 800c168:	f7ff fdcc 	bl	800bd04 <_Balloc>
 800c16c:	2e00      	cmp	r6, #0
 800c16e:	4607      	mov	r7, r0
 800c170:	f100 0214 	add.w	r2, r0, #20
 800c174:	dd0a      	ble.n	800c18c <__lshift+0x48>
 800c176:	2300      	movs	r3, #0
 800c178:	4619      	mov	r1, r3
 800c17a:	3301      	adds	r3, #1
 800c17c:	f842 1b04 	str.w	r1, [r2], #4
 800c180:	42b3      	cmp	r3, r6
 800c182:	d1fa      	bne.n	800c17a <__lshift+0x36>
 800c184:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 800c188:	f103 0214 	add.w	r2, r3, #20
 800c18c:	6926      	ldr	r6, [r4, #16]
 800c18e:	f104 0114 	add.w	r1, r4, #20
 800c192:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 800c196:	3614      	adds	r6, #20
 800c198:	f018 081f 	ands.w	r8, r8, #31
 800c19c:	d01a      	beq.n	800c1d4 <__lshift+0x90>
 800c19e:	f1c8 0e20 	rsb	lr, r8, #32
 800c1a2:	2000      	movs	r0, #0
 800c1a4:	680b      	ldr	r3, [r1, #0]
 800c1a6:	fa03 f308 	lsl.w	r3, r3, r8
 800c1aa:	4318      	orrs	r0, r3
 800c1ac:	f842 0b04 	str.w	r0, [r2], #4
 800c1b0:	f851 0b04 	ldr.w	r0, [r1], #4
 800c1b4:	428e      	cmp	r6, r1
 800c1b6:	fa20 f00e 	lsr.w	r0, r0, lr
 800c1ba:	d8f3      	bhi.n	800c1a4 <__lshift+0x60>
 800c1bc:	6010      	str	r0, [r2, #0]
 800c1be:	b100      	cbz	r0, 800c1c2 <__lshift+0x7e>
 800c1c0:	3501      	adds	r5, #1
 800c1c2:	4648      	mov	r0, r9
 800c1c4:	3d01      	subs	r5, #1
 800c1c6:	4621      	mov	r1, r4
 800c1c8:	613d      	str	r5, [r7, #16]
 800c1ca:	f7ff fdcf 	bl	800bd6c <_Bfree>
 800c1ce:	4638      	mov	r0, r7
 800c1d0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800c1d4:	f851 3b04 	ldr.w	r3, [r1], #4
 800c1d8:	428e      	cmp	r6, r1
 800c1da:	f842 3b04 	str.w	r3, [r2], #4
 800c1de:	d9f0      	bls.n	800c1c2 <__lshift+0x7e>
 800c1e0:	f851 3b04 	ldr.w	r3, [r1], #4
 800c1e4:	428e      	cmp	r6, r1
 800c1e6:	f842 3b04 	str.w	r3, [r2], #4
 800c1ea:	d8f3      	bhi.n	800c1d4 <__lshift+0x90>
 800c1ec:	e7e9      	b.n	800c1c2 <__lshift+0x7e>
 800c1ee:	bf00      	nop

0800c1f0 <__mcmp>:
 800c1f0:	4603      	mov	r3, r0
 800c1f2:	690a      	ldr	r2, [r1, #16]
 800c1f4:	6900      	ldr	r0, [r0, #16]
 800c1f6:	b430      	push	{r4, r5}
 800c1f8:	1a80      	subs	r0, r0, r2
 800c1fa:	d10f      	bne.n	800c21c <__mcmp+0x2c>
 800c1fc:	3204      	adds	r2, #4
 800c1fe:	f103 0514 	add.w	r5, r3, #20
 800c202:	0092      	lsls	r2, r2, #2
 800c204:	189b      	adds	r3, r3, r2
 800c206:	1889      	adds	r1, r1, r2
 800c208:	3304      	adds	r3, #4
 800c20a:	3104      	adds	r1, #4
 800c20c:	f853 4d04 	ldr.w	r4, [r3, #-4]!
 800c210:	f851 2d04 	ldr.w	r2, [r1, #-4]!
 800c214:	4294      	cmp	r4, r2
 800c216:	d103      	bne.n	800c220 <__mcmp+0x30>
 800c218:	429d      	cmp	r5, r3
 800c21a:	d3f7      	bcc.n	800c20c <__mcmp+0x1c>
 800c21c:	bc30      	pop	{r4, r5}
 800c21e:	4770      	bx	lr
 800c220:	bf38      	it	cc
 800c222:	f04f 30ff 	movcc.w	r0, #4294967295
 800c226:	d3f9      	bcc.n	800c21c <__mcmp+0x2c>
 800c228:	2001      	movs	r0, #1
 800c22a:	e7f7      	b.n	800c21c <__mcmp+0x2c>

0800c22c <__mdiff>:
 800c22c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c230:	4689      	mov	r9, r1
 800c232:	4604      	mov	r4, r0
 800c234:	4611      	mov	r1, r2
 800c236:	4648      	mov	r0, r9
 800c238:	4690      	mov	r8, r2
 800c23a:	f7ff ffd9 	bl	800c1f0 <__mcmp>
 800c23e:	1e05      	subs	r5, r0, #0
 800c240:	d064      	beq.n	800c30c <__mdiff+0xe0>
 800c242:	bfbc      	itt	lt
 800c244:	464b      	movlt	r3, r9
 800c246:	46c1      	movlt	r9, r8
 800c248:	4620      	mov	r0, r4
 800c24a:	bfb8      	it	lt
 800c24c:	4698      	movlt	r8, r3
 800c24e:	f8d9 1004 	ldr.w	r1, [r9, #4]
 800c252:	bfac      	ite	ge
 800c254:	f04f 0a00 	movge.w	sl, #0
 800c258:	f04f 0a01 	movlt.w	sl, #1
 800c25c:	f7ff fd52 	bl	800bd04 <_Balloc>
 800c260:	f8d9 6010 	ldr.w	r6, [r9, #16]
 800c264:	f109 0514 	add.w	r5, r9, #20
 800c268:	f8d8 3010 	ldr.w	r3, [r8, #16]
 800c26c:	f108 0714 	add.w	r7, r8, #20
 800c270:	2400      	movs	r4, #0
 800c272:	eb09 0986 	add.w	r9, r9, r6, lsl #2
 800c276:	f109 0914 	add.w	r9, r9, #20
 800c27a:	4683      	mov	fp, r0
 800c27c:	3014      	adds	r0, #20
 800c27e:	f8cb a00c 	str.w	sl, [fp, #12]
 800c282:	eb08 0a83 	add.w	sl, r8, r3, lsl #2
 800c286:	f10a 0a14 	add.w	sl, sl, #20
 800c28a:	f855 1b04 	ldr.w	r1, [r5], #4
 800c28e:	4603      	mov	r3, r0
 800c290:	f857 0b04 	ldr.w	r0, [r7], #4
 800c294:	462a      	mov	r2, r5
 800c296:	fa1f f881 	uxth.w	r8, r1
 800c29a:	fa1f fc80 	uxth.w	ip, r0
 800c29e:	0c00      	lsrs	r0, r0, #16
 800c2a0:	ebcc 0c08 	rsb	ip, ip, r8
 800c2a4:	ebc0 4011 	rsb	r0, r0, r1, lsr #16
 800c2a8:	4464      	add	r4, ip
 800c2aa:	eb00 4024 	add.w	r0, r0, r4, asr #16
 800c2ae:	b2a4      	uxth	r4, r4
 800c2b0:	ea44 4100 	orr.w	r1, r4, r0, lsl #16
 800c2b4:	1404      	asrs	r4, r0, #16
 800c2b6:	45ba      	cmp	sl, r7
 800c2b8:	f843 1b04 	str.w	r1, [r3], #4
 800c2bc:	4618      	mov	r0, r3
 800c2be:	d8e4      	bhi.n	800c28a <__mdiff+0x5e>
 800c2c0:	45a9      	cmp	r9, r5
 800c2c2:	461f      	mov	r7, r3
 800c2c4:	d914      	bls.n	800c2f0 <__mdiff+0xc4>
 800c2c6:	f852 1b04 	ldr.w	r1, [r2], #4
 800c2ca:	b288      	uxth	r0, r1
 800c2cc:	0c09      	lsrs	r1, r1, #16
 800c2ce:	1824      	adds	r4, r4, r0
 800c2d0:	eb01 4124 	add.w	r1, r1, r4, asr #16
 800c2d4:	b2a4      	uxth	r4, r4
 800c2d6:	ea44 4001 	orr.w	r0, r4, r1, lsl #16
 800c2da:	140c      	asrs	r4, r1, #16
 800c2dc:	4591      	cmp	r9, r2
 800c2de:	f843 0b04 	str.w	r0, [r3], #4
 800c2e2:	d8f0      	bhi.n	800c2c6 <__mdiff+0x9a>
 800c2e4:	43eb      	mvns	r3, r5
 800c2e6:	444b      	add	r3, r9
 800c2e8:	f023 0303 	bic.w	r3, r3, #3
 800c2ec:	3304      	adds	r3, #4
 800c2ee:	18fb      	adds	r3, r7, r3
 800c2f0:	f853 2c04 	ldr.w	r2, [r3, #-4]
 800c2f4:	3b04      	subs	r3, #4
 800c2f6:	b922      	cbnz	r2, 800c302 <__mdiff+0xd6>
 800c2f8:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 800c2fc:	3e01      	subs	r6, #1
 800c2fe:	2a00      	cmp	r2, #0
 800c300:	d0fa      	beq.n	800c2f8 <__mdiff+0xcc>
 800c302:	f8cb 6010 	str.w	r6, [fp, #16]
 800c306:	4658      	mov	r0, fp
 800c308:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c30c:	4620      	mov	r0, r4
 800c30e:	4629      	mov	r1, r5
 800c310:	f7ff fcf8 	bl	800bd04 <_Balloc>
 800c314:	2301      	movs	r3, #1
 800c316:	4683      	mov	fp, r0
 800c318:	6145      	str	r5, [r0, #20]
 800c31a:	6103      	str	r3, [r0, #16]
 800c31c:	4658      	mov	r0, fp
 800c31e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c322:	bf00      	nop

0800c324 <__ulp>:
 800c324:	2300      	movs	r3, #0
 800c326:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 800c32a:	ea01 0303 	and.w	r3, r1, r3
 800c32e:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
 800c332:	2b00      	cmp	r3, #0
 800c334:	dd02      	ble.n	800c33c <__ulp+0x18>
 800c336:	4619      	mov	r1, r3
 800c338:	2000      	movs	r0, #0
 800c33a:	4770      	bx	lr
 800c33c:	425b      	negs	r3, r3
 800c33e:	151b      	asrs	r3, r3, #20
 800c340:	2b13      	cmp	r3, #19
 800c342:	dd0d      	ble.n	800c360 <__ulp+0x3c>
 800c344:	3b14      	subs	r3, #20
 800c346:	2100      	movs	r1, #0
 800c348:	2b1e      	cmp	r3, #30
 800c34a:	dd02      	ble.n	800c352 <__ulp+0x2e>
 800c34c:	2301      	movs	r3, #1
 800c34e:	4618      	mov	r0, r3
 800c350:	4770      	bx	lr
 800c352:	2201      	movs	r2, #1
 800c354:	f1c3 031f 	rsb	r3, r3, #31
 800c358:	fa12 f303 	lsls.w	r3, r2, r3
 800c35c:	4618      	mov	r0, r3
 800c35e:	4770      	bx	lr
 800c360:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 800c364:	2000      	movs	r0, #0
 800c366:	fa52 f103 	asrs.w	r1, r2, r3
 800c36a:	4770      	bx	lr

0800c36c <__b2d>:
 800c36c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c370:	f100 0614 	add.w	r6, r0, #20
 800c374:	6904      	ldr	r4, [r0, #16]
 800c376:	460f      	mov	r7, r1
 800c378:	3404      	adds	r4, #4
 800c37a:	f850 5024 	ldr.w	r5, [r0, r4, lsl #2]
 800c37e:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 800c382:	46a0      	mov	r8, r4
 800c384:	4628      	mov	r0, r5
 800c386:	f7ff fd9b 	bl	800bec0 <__hi0bits>
 800c38a:	280a      	cmp	r0, #10
 800c38c:	f1c0 0320 	rsb	r3, r0, #32
 800c390:	603b      	str	r3, [r7, #0]
 800c392:	dc15      	bgt.n	800c3c0 <__b2d+0x54>
 800c394:	f1c0 010b 	rsb	r1, r0, #11
 800c398:	fa35 f701 	lsrs.w	r7, r5, r1
 800c39c:	42a6      	cmp	r6, r4
 800c39e:	f047 577e 	orr.w	r7, r7, #1065353216	; 0x3f800000
 800c3a2:	f447 03e0 	orr.w	r3, r7, #7340032	; 0x700000
 800c3a6:	d233      	bcs.n	800c410 <__b2d+0xa4>
 800c3a8:	f854 4c04 	ldr.w	r4, [r4, #-4]
 800c3ac:	fa34 f101 	lsrs.w	r1, r4, r1
 800c3b0:	3015      	adds	r0, #21
 800c3b2:	4085      	lsls	r5, r0
 800c3b4:	ea41 0205 	orr.w	r2, r1, r5
 800c3b8:	4610      	mov	r0, r2
 800c3ba:	4619      	mov	r1, r3
 800c3bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c3c0:	42a6      	cmp	r6, r4
 800c3c2:	d321      	bcc.n	800c408 <__b2d+0x9c>
 800c3c4:	2100      	movs	r1, #0
 800c3c6:	380b      	subs	r0, #11
 800c3c8:	bf02      	ittt	eq
 800c3ca:	f045 557e 	orreq.w	r5, r5, #1065353216	; 0x3f800000
 800c3ce:	460a      	moveq	r2, r1
 800c3d0:	f445 03e0 	orreq.w	r3, r5, #7340032	; 0x700000
 800c3d4:	d0f0      	beq.n	800c3b8 <__b2d+0x4c>
 800c3d6:	4085      	lsls	r5, r0
 800c3d8:	f1c0 0720 	rsb	r7, r0, #32
 800c3dc:	f045 557e 	orr.w	r5, r5, #1065353216	; 0x3f800000
 800c3e0:	42b4      	cmp	r4, r6
 800c3e2:	fa21 fc07 	lsr.w	ip, r1, r7
 800c3e6:	f445 05e0 	orr.w	r5, r5, #7340032	; 0x700000
 800c3ea:	ea45 030c 	orr.w	r3, r5, ip
 800c3ee:	d911      	bls.n	800c414 <__b2d+0xa8>
 800c3f0:	f854 4c04 	ldr.w	r4, [r4, #-4]
 800c3f4:	fa34 f707 	lsrs.w	r7, r4, r7
 800c3f8:	fa11 f000 	lsls.w	r0, r1, r0
 800c3fc:	4619      	mov	r1, r3
 800c3fe:	ea47 0200 	orr.w	r2, r7, r0
 800c402:	4610      	mov	r0, r2
 800c404:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c408:	3c04      	subs	r4, #4
 800c40a:	f858 1c04 	ldr.w	r1, [r8, #-4]
 800c40e:	e7da      	b.n	800c3c6 <__b2d+0x5a>
 800c410:	2100      	movs	r1, #0
 800c412:	e7cd      	b.n	800c3b0 <__b2d+0x44>
 800c414:	2700      	movs	r7, #0
 800c416:	e7ef      	b.n	800c3f8 <__b2d+0x8c>

0800c418 <__d2b>:
 800c418:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800c41c:	b083      	sub	sp, #12
 800c41e:	2101      	movs	r1, #1
 800c420:	461d      	mov	r5, r3
 800c422:	4614      	mov	r4, r2
 800c424:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 800c426:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800c428:	f7ff fc6c 	bl	800bd04 <_Balloc>
 800c42c:	f3c5 590a 	ubfx	r9, r5, #20, #11
 800c430:	f025 437f 	bic.w	r3, r5, #4278190080	; 0xff000000
 800c434:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800c438:	9300      	str	r3, [sp, #0]
 800c43a:	4680      	mov	r8, r0
 800c43c:	f1b9 0f00 	cmp.w	r9, #0
 800c440:	d002      	beq.n	800c448 <__d2b+0x30>
 800c442:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800c446:	9300      	str	r3, [sp, #0]
 800c448:	2c00      	cmp	r4, #0
 800c44a:	d025      	beq.n	800c498 <__d2b+0x80>
 800c44c:	a802      	add	r0, sp, #8
 800c44e:	f840 4d04 	str.w	r4, [r0, #-4]!
 800c452:	f7ff fd55 	bl	800bf00 <__lo0bits>
 800c456:	2800      	cmp	r0, #0
 800c458:	d136      	bne.n	800c4c8 <__d2b+0xb0>
 800c45a:	9a01      	ldr	r2, [sp, #4]
 800c45c:	9b00      	ldr	r3, [sp, #0]
 800c45e:	f8c8 2014 	str.w	r2, [r8, #20]
 800c462:	2b00      	cmp	r3, #0
 800c464:	bf0c      	ite	eq
 800c466:	2401      	moveq	r4, #1
 800c468:	2402      	movne	r4, #2
 800c46a:	f8c8 3018 	str.w	r3, [r8, #24]
 800c46e:	f8c8 4010 	str.w	r4, [r8, #16]
 800c472:	f1b9 0f00 	cmp.w	r9, #0
 800c476:	d11d      	bne.n	800c4b4 <__d2b+0x9c>
 800c478:	eb08 0384 	add.w	r3, r8, r4, lsl #2
 800c47c:	f5a0 6086 	sub.w	r0, r0, #1072	; 0x430
 800c480:	3802      	subs	r0, #2
 800c482:	6038      	str	r0, [r7, #0]
 800c484:	6918      	ldr	r0, [r3, #16]
 800c486:	0164      	lsls	r4, r4, #5
 800c488:	f7ff fd1a 	bl	800bec0 <__hi0bits>
 800c48c:	1a24      	subs	r4, r4, r0
 800c48e:	6034      	str	r4, [r6, #0]
 800c490:	4640      	mov	r0, r8
 800c492:	b003      	add	sp, #12
 800c494:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800c498:	4668      	mov	r0, sp
 800c49a:	f7ff fd31 	bl	800bf00 <__lo0bits>
 800c49e:	2301      	movs	r3, #1
 800c4a0:	461c      	mov	r4, r3
 800c4a2:	f8c8 3010 	str.w	r3, [r8, #16]
 800c4a6:	9b00      	ldr	r3, [sp, #0]
 800c4a8:	f8c8 3014 	str.w	r3, [r8, #20]
 800c4ac:	3020      	adds	r0, #32
 800c4ae:	f1b9 0f00 	cmp.w	r9, #0
 800c4b2:	d0e1      	beq.n	800c478 <__d2b+0x60>
 800c4b4:	f5a9 6986 	sub.w	r9, r9, #1072	; 0x430
 800c4b8:	f1c0 0335 	rsb	r3, r0, #53	; 0x35
 800c4bc:	f1a9 0903 	sub.w	r9, r9, #3
 800c4c0:	4448      	add	r0, r9
 800c4c2:	6038      	str	r0, [r7, #0]
 800c4c4:	6033      	str	r3, [r6, #0]
 800c4c6:	e7e3      	b.n	800c490 <__d2b+0x78>
 800c4c8:	9b00      	ldr	r3, [sp, #0]
 800c4ca:	f1c0 0220 	rsb	r2, r0, #32
 800c4ce:	9901      	ldr	r1, [sp, #4]
 800c4d0:	fa13 f202 	lsls.w	r2, r3, r2
 800c4d4:	40c3      	lsrs	r3, r0
 800c4d6:	430a      	orrs	r2, r1
 800c4d8:	9300      	str	r3, [sp, #0]
 800c4da:	f8c8 2014 	str.w	r2, [r8, #20]
 800c4de:	e7c0      	b.n	800c462 <__d2b+0x4a>

0800c4e0 <__ratio>:
 800c4e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c4e4:	b082      	sub	sp, #8
 800c4e6:	4688      	mov	r8, r1
 800c4e8:	a901      	add	r1, sp, #4
 800c4ea:	4606      	mov	r6, r0
 800c4ec:	f7ff ff3e 	bl	800c36c <__b2d>
 800c4f0:	460d      	mov	r5, r1
 800c4f2:	4604      	mov	r4, r0
 800c4f4:	4669      	mov	r1, sp
 800c4f6:	4640      	mov	r0, r8
 800c4f8:	f7ff ff38 	bl	800c36c <__b2d>
 800c4fc:	f8d8 e010 	ldr.w	lr, [r8, #16]
 800c500:	f8d6 c010 	ldr.w	ip, [r6, #16]
 800c504:	f8dd 8004 	ldr.w	r8, [sp, #4]
 800c508:	ebce 0c0c 	rsb	ip, lr, ip
 800c50c:	f8dd e000 	ldr.w	lr, [sp]
 800c510:	ea4f 1c4c 	mov.w	ip, ip, lsl #5
 800c514:	ebce 0e08 	rsb	lr, lr, r8
 800c518:	44e6      	add	lr, ip
 800c51a:	f1be 0f00 	cmp.w	lr, #0
 800c51e:	ea4f 5e0e 	mov.w	lr, lr, lsl #20
 800c522:	bfc4      	itt	gt
 800c524:	eb0e 0705 	addgt.w	r7, lr, r5
 800c528:	463d      	movgt	r5, r7
 800c52a:	460b      	mov	r3, r1
 800c52c:	bfd8      	it	le
 800c52e:	ebce 0101 	rsble	r1, lr, r1
 800c532:	4602      	mov	r2, r0
 800c534:	bfdc      	itt	le
 800c536:	460b      	movle	r3, r1
 800c538:	4602      	movle	r2, r0
 800c53a:	4629      	mov	r1, r5
 800c53c:	4620      	mov	r0, r4
 800c53e:	f002 ffb7 	bl	800f4b0 <__aeabi_ddiv>
 800c542:	b002      	add	sp, #8
 800c544:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800c548 <_mprec_log10>:
 800c548:	2817      	cmp	r0, #23
 800c54a:	b510      	push	{r4, lr}
 800c54c:	4604      	mov	r4, r0
 800c54e:	dd0c      	ble.n	800c56a <_mprec_log10+0x22>
 800c550:	2100      	movs	r1, #0
 800c552:	2000      	movs	r0, #0
 800c554:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
 800c558:	2300      	movs	r3, #0
 800c55a:	2200      	movs	r2, #0
 800c55c:	f2c4 0324 	movt	r3, #16420	; 0x4024
 800c560:	f002 fe7c 	bl	800f25c <__aeabi_dmul>
 800c564:	3c01      	subs	r4, #1
 800c566:	d1f7      	bne.n	800c558 <_mprec_log10+0x10>
 800c568:	bd10      	pop	{r4, pc}
 800c56a:	f240 2320 	movw	r3, #544	; 0x220
 800c56e:	f6c0 0301 	movt	r3, #2049	; 0x801
 800c572:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 800c576:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800c57a:	bd10      	pop	{r4, pc}

0800c57c <__copybits>:
 800c57c:	b470      	push	{r4, r5, r6}
 800c57e:	3901      	subs	r1, #1
 800c580:	6916      	ldr	r6, [r2, #16]
 800c582:	f102 0314 	add.w	r3, r2, #20
 800c586:	1149      	asrs	r1, r1, #5
 800c588:	3101      	adds	r1, #1
 800c58a:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 800c58e:	3614      	adds	r6, #20
 800c590:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 800c594:	42b3      	cmp	r3, r6
 800c596:	d20c      	bcs.n	800c5b2 <__copybits+0x36>
 800c598:	4604      	mov	r4, r0
 800c59a:	f853 5b04 	ldr.w	r5, [r3], #4
 800c59e:	429e      	cmp	r6, r3
 800c5a0:	f844 5b04 	str.w	r5, [r4], #4
 800c5a4:	d8f9      	bhi.n	800c59a <__copybits+0x1e>
 800c5a6:	1ab3      	subs	r3, r6, r2
 800c5a8:	3b15      	subs	r3, #21
 800c5aa:	f023 0303 	bic.w	r3, r3, #3
 800c5ae:	3304      	adds	r3, #4
 800c5b0:	18c0      	adds	r0, r0, r3
 800c5b2:	4281      	cmp	r1, r0
 800c5b4:	d904      	bls.n	800c5c0 <__copybits+0x44>
 800c5b6:	2300      	movs	r3, #0
 800c5b8:	f840 3b04 	str.w	r3, [r0], #4
 800c5bc:	4281      	cmp	r1, r0
 800c5be:	d8fb      	bhi.n	800c5b8 <__copybits+0x3c>
 800c5c0:	bc70      	pop	{r4, r5, r6}
 800c5c2:	4770      	bx	lr

0800c5c4 <__any_on>:
 800c5c4:	6902      	ldr	r2, [r0, #16]
 800c5c6:	114b      	asrs	r3, r1, #5
 800c5c8:	b410      	push	{r4}
 800c5ca:	429a      	cmp	r2, r3
 800c5cc:	db11      	blt.n	800c5f2 <__any_on+0x2e>
 800c5ce:	dd0f      	ble.n	800c5f0 <__any_on+0x2c>
 800c5d0:	f011 011f 	ands.w	r1, r1, #31
 800c5d4:	d00c      	beq.n	800c5f0 <__any_on+0x2c>
 800c5d6:	461a      	mov	r2, r3
 800c5d8:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800c5dc:	695b      	ldr	r3, [r3, #20]
 800c5de:	fa33 f401 	lsrs.w	r4, r3, r1
 800c5e2:	fa14 f101 	lsls.w	r1, r4, r1
 800c5e6:	4299      	cmp	r1, r3
 800c5e8:	d003      	beq.n	800c5f2 <__any_on+0x2e>
 800c5ea:	2001      	movs	r0, #1
 800c5ec:	bc10      	pop	{r4}
 800c5ee:	4770      	bx	lr
 800c5f0:	461a      	mov	r2, r3
 800c5f2:	3204      	adds	r2, #4
 800c5f4:	f100 0114 	add.w	r1, r0, #20
 800c5f8:	eb00 0382 	add.w	r3, r0, r2, lsl #2
 800c5fc:	1d1c      	adds	r4, r3, #4
 800c5fe:	42a1      	cmp	r1, r4
 800c600:	d20b      	bcs.n	800c61a <__any_on+0x56>
 800c602:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 800c606:	2a00      	cmp	r2, #0
 800c608:	d1ef      	bne.n	800c5ea <__any_on+0x26>
 800c60a:	4299      	cmp	r1, r3
 800c60c:	d205      	bcs.n	800c61a <__any_on+0x56>
 800c60e:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 800c612:	2a00      	cmp	r2, #0
 800c614:	d1e9      	bne.n	800c5ea <__any_on+0x26>
 800c616:	4299      	cmp	r1, r3
 800c618:	d3f9      	bcc.n	800c60e <__any_on+0x4a>
 800c61a:	2000      	movs	r0, #0
 800c61c:	e7e6      	b.n	800c5ec <__any_on+0x28>
 800c61e:	bf00      	nop

0800c620 <_open_r>:
 800c620:	b538      	push	{r3, r4, r5, lr}
 800c622:	f642 249c 	movw	r4, #10908	; 0x2a9c
 800c626:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800c62a:	4605      	mov	r5, r0
 800c62c:	4608      	mov	r0, r1
 800c62e:	4611      	mov	r1, r2
 800c630:	461a      	mov	r2, r3
 800c632:	2300      	movs	r3, #0
 800c634:	6023      	str	r3, [r4, #0]
 800c636:	f7f4 fae3 	bl	8000c00 <_open>
 800c63a:	f1b0 3fff 	cmp.w	r0, #4294967295
 800c63e:	d000      	beq.n	800c642 <_open_r+0x22>
 800c640:	bd38      	pop	{r3, r4, r5, pc}
 800c642:	6823      	ldr	r3, [r4, #0]
 800c644:	2b00      	cmp	r3, #0
 800c646:	d0fb      	beq.n	800c640 <_open_r+0x20>
 800c648:	602b      	str	r3, [r5, #0]
 800c64a:	bd38      	pop	{r3, r4, r5, pc}

0800c64c <_read_r>:
 800c64c:	b538      	push	{r3, r4, r5, lr}
 800c64e:	f642 249c 	movw	r4, #10908	; 0x2a9c
 800c652:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800c656:	4605      	mov	r5, r0
 800c658:	4608      	mov	r0, r1
 800c65a:	4611      	mov	r1, r2
 800c65c:	461a      	mov	r2, r3
 800c65e:	2300      	movs	r3, #0
 800c660:	6023      	str	r3, [r4, #0]
 800c662:	f7f4 fae9 	bl	8000c38 <_read>
 800c666:	f1b0 3fff 	cmp.w	r0, #4294967295
 800c66a:	d000      	beq.n	800c66e <_read_r+0x22>
 800c66c:	bd38      	pop	{r3, r4, r5, pc}
 800c66e:	6823      	ldr	r3, [r4, #0]
 800c670:	2b00      	cmp	r3, #0
 800c672:	d0fb      	beq.n	800c66c <_read_r+0x20>
 800c674:	602b      	str	r3, [r5, #0]
 800c676:	bd38      	pop	{r3, r4, r5, pc}

0800c678 <cleanup_glue>:
 800c678:	b570      	push	{r4, r5, r6, lr}
 800c67a:	460c      	mov	r4, r1
 800c67c:	6809      	ldr	r1, [r1, #0]
 800c67e:	4605      	mov	r5, r0
 800c680:	b109      	cbz	r1, 800c686 <cleanup_glue+0xe>
 800c682:	f7ff fff9 	bl	800c678 <cleanup_glue>
 800c686:	4628      	mov	r0, r5
 800c688:	4621      	mov	r1, r4
 800c68a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800c68e:	f7ff b809 	b.w	800b6a4 <_free_r>
 800c692:	bf00      	nop

0800c694 <_reclaim_reent>:
 800c694:	f240 237c 	movw	r3, #636	; 0x27c
 800c698:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c69c:	b570      	push	{r4, r5, r6, lr}
 800c69e:	4605      	mov	r5, r0
 800c6a0:	681b      	ldr	r3, [r3, #0]
 800c6a2:	4298      	cmp	r0, r3
 800c6a4:	d04a      	beq.n	800c73c <_reclaim_reent+0xa8>
 800c6a6:	6a42      	ldr	r2, [r0, #36]	; 0x24
 800c6a8:	b302      	cbz	r2, 800c6ec <_reclaim_reent+0x58>
 800c6aa:	68d3      	ldr	r3, [r2, #12]
 800c6ac:	b1cb      	cbz	r3, 800c6e2 <_reclaim_reent+0x4e>
 800c6ae:	2100      	movs	r1, #0
 800c6b0:	460e      	mov	r6, r1
 800c6b2:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 800c6b6:	b909      	cbnz	r1, 800c6bc <_reclaim_reent+0x28>
 800c6b8:	e008      	b.n	800c6cc <_reclaim_reent+0x38>
 800c6ba:	4621      	mov	r1, r4
 800c6bc:	680c      	ldr	r4, [r1, #0]
 800c6be:	4628      	mov	r0, r5
 800c6c0:	f7fe fff0 	bl	800b6a4 <_free_r>
 800c6c4:	2c00      	cmp	r4, #0
 800c6c6:	d1f8      	bne.n	800c6ba <_reclaim_reent+0x26>
 800c6c8:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800c6ca:	68d3      	ldr	r3, [r2, #12]
 800c6cc:	3601      	adds	r6, #1
 800c6ce:	2e20      	cmp	r6, #32
 800c6d0:	4631      	mov	r1, r6
 800c6d2:	d001      	beq.n	800c6d8 <_reclaim_reent+0x44>
 800c6d4:	68d3      	ldr	r3, [r2, #12]
 800c6d6:	e7ec      	b.n	800c6b2 <_reclaim_reent+0x1e>
 800c6d8:	4628      	mov	r0, r5
 800c6da:	4619      	mov	r1, r3
 800c6dc:	f7fe ffe2 	bl	800b6a4 <_free_r>
 800c6e0:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800c6e2:	6811      	ldr	r1, [r2, #0]
 800c6e4:	b111      	cbz	r1, 800c6ec <_reclaim_reent+0x58>
 800c6e6:	4628      	mov	r0, r5
 800c6e8:	f7fe ffdc 	bl	800b6a4 <_free_r>
 800c6ec:	6969      	ldr	r1, [r5, #20]
 800c6ee:	b111      	cbz	r1, 800c6f6 <_reclaim_reent+0x62>
 800c6f0:	4628      	mov	r0, r5
 800c6f2:	f7fe ffd7 	bl	800b6a4 <_free_r>
 800c6f6:	6a69      	ldr	r1, [r5, #36]	; 0x24
 800c6f8:	b111      	cbz	r1, 800c700 <_reclaim_reent+0x6c>
 800c6fa:	4628      	mov	r0, r5
 800c6fc:	f7fe ffd2 	bl	800b6a4 <_free_r>
 800c700:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 800c702:	b111      	cbz	r1, 800c70a <_reclaim_reent+0x76>
 800c704:	4628      	mov	r0, r5
 800c706:	f7fe ffcd 	bl	800b6a4 <_free_r>
 800c70a:	6be9      	ldr	r1, [r5, #60]	; 0x3c
 800c70c:	b111      	cbz	r1, 800c714 <_reclaim_reent+0x80>
 800c70e:	4628      	mov	r0, r5
 800c710:	f7fe ffc8 	bl	800b6a4 <_free_r>
 800c714:	6c29      	ldr	r1, [r5, #64]	; 0x40
 800c716:	b111      	cbz	r1, 800c71e <_reclaim_reent+0x8a>
 800c718:	4628      	mov	r0, r5
 800c71a:	f7fe ffc3 	bl	800b6a4 <_free_r>
 800c71e:	6cab      	ldr	r3, [r5, #72]	; 0x48
 800c720:	b12b      	cbz	r3, 800c72e <_reclaim_reent+0x9a>
 800c722:	f8d3 1088 	ldr.w	r1, [r3, #136]	; 0x88
 800c726:	b111      	cbz	r1, 800c72e <_reclaim_reent+0x9a>
 800c728:	4628      	mov	r0, r5
 800c72a:	f7fe ffbb 	bl	800b6a4 <_free_r>
 800c72e:	6b69      	ldr	r1, [r5, #52]	; 0x34
 800c730:	b111      	cbz	r1, 800c738 <_reclaim_reent+0xa4>
 800c732:	4628      	mov	r0, r5
 800c734:	f7fe ffb6 	bl	800b6a4 <_free_r>
 800c738:	69ab      	ldr	r3, [r5, #24]
 800c73a:	b903      	cbnz	r3, 800c73e <_reclaim_reent+0xaa>
 800c73c:	bd70      	pop	{r4, r5, r6, pc}
 800c73e:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800c740:	4628      	mov	r0, r5
 800c742:	4798      	blx	r3
 800c744:	f8d5 10d8 	ldr.w	r1, [r5, #216]	; 0xd8
 800c748:	2900      	cmp	r1, #0
 800c74a:	d0f7      	beq.n	800c73c <_reclaim_reent+0xa8>
 800c74c:	4628      	mov	r0, r5
 800c74e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800c752:	e791      	b.n	800c678 <cleanup_glue>

0800c754 <_wrapup_reent>:
 800c754:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c756:	4607      	mov	r7, r0
 800c758:	b198      	cbz	r0, 800c782 <_wrapup_reent+0x2e>
 800c75a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800c75c:	b163      	cbz	r3, 800c778 <_wrapup_reent+0x24>
 800c75e:	685e      	ldr	r6, [r3, #4]
 800c760:	2e00      	cmp	r6, #0
 800c762:	dd09      	ble.n	800c778 <_wrapup_reent+0x24>
 800c764:	1cb5      	adds	r5, r6, #2
 800c766:	2400      	movs	r4, #0
 800c768:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 800c76c:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 800c770:	3401      	adds	r4, #1
 800c772:	4798      	blx	r3
 800c774:	42b4      	cmp	r4, r6
 800c776:	d1f9      	bne.n	800c76c <_wrapup_reent+0x18>
 800c778:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c77a:	b10b      	cbz	r3, 800c780 <_wrapup_reent+0x2c>
 800c77c:	4638      	mov	r0, r7
 800c77e:	4798      	blx	r3
 800c780:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c782:	f240 237c 	movw	r3, #636	; 0x27c
 800c786:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c78a:	681f      	ldr	r7, [r3, #0]
 800c78c:	e7e5      	b.n	800c75a <_wrapup_reent+0x6>
 800c78e:	bf00      	nop

0800c790 <__fpclassifyd>:
 800c790:	ea50 0301 	orrs.w	r3, r0, r1
 800c794:	b410      	push	{r4}
 800c796:	d03c      	beq.n	800c812 <__fpclassifyd+0x82>
 800c798:	f1d0 0201 	rsbs	r2, r0, #1
 800c79c:	bf38      	it	cc
 800c79e:	2200      	movcc	r2, #0
 800c7a0:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 800c7a4:	bf14      	ite	ne
 800c7a6:	2300      	movne	r3, #0
 800c7a8:	f002 0301 	andeq.w	r3, r2, #1
 800c7ac:	2b00      	cmp	r3, #0
 800c7ae:	d130      	bne.n	800c812 <__fpclassifyd+0x82>
 800c7b0:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800c7b4:	f5a1 1080 	sub.w	r0, r1, #1048576	; 0x100000
 800c7b8:	f6c7 73df 	movt	r3, #32735	; 0x7fdf
 800c7bc:	f101 44fe 	add.w	r4, r1, #2130706432	; 0x7f000000
 800c7c0:	4298      	cmp	r0, r3
 800c7c2:	f504 0470 	add.w	r4, r4, #15728640	; 0xf00000
 800c7c6:	bf8c      	ite	hi
 800c7c8:	2000      	movhi	r0, #0
 800c7ca:	2001      	movls	r0, #1
 800c7cc:	429c      	cmp	r4, r3
 800c7ce:	bf8c      	ite	hi
 800c7d0:	4603      	movhi	r3, r0
 800c7d2:	f040 0301 	orrls.w	r3, r0, #1
 800c7d6:	2b00      	cmp	r3, #0
 800c7d8:	d120      	bne.n	800c81c <__fpclassifyd+0x8c>
 800c7da:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 800c7de:	f101 4000 	add.w	r0, r1, #2147483648	; 0x80000000
 800c7e2:	bf2c      	ite	cs
 800c7e4:	2300      	movcs	r3, #0
 800c7e6:	2301      	movcc	r3, #1
 800c7e8:	f5b0 1f80 	cmp.w	r0, #1048576	; 0x100000
 800c7ec:	bf38      	it	cc
 800c7ee:	f043 0301 	orrcc.w	r3, r3, #1
 800c7f2:	b98b      	cbnz	r3, 800c818 <__fpclassifyd+0x88>
 800c7f4:	f511 1f80 	cmn.w	r1, #1048576	; 0x100000
 800c7f8:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 800c7fc:	bf14      	ite	ne
 800c7fe:	2000      	movne	r0, #0
 800c800:	2001      	moveq	r0, #1
 800c802:	4299      	cmp	r1, r3
 800c804:	bf14      	ite	ne
 800c806:	4601      	movne	r1, r0
 800c808:	f040 0101 	orreq.w	r1, r0, #1
 800c80c:	ea02 0001 	and.w	r0, r2, r1
 800c810:	e000      	b.n	800c814 <__fpclassifyd+0x84>
 800c812:	2002      	movs	r0, #2
 800c814:	bc10      	pop	{r4}
 800c816:	4770      	bx	lr
 800c818:	2003      	movs	r0, #3
 800c81a:	e7fb      	b.n	800c814 <__fpclassifyd+0x84>
 800c81c:	2004      	movs	r0, #4
 800c81e:	e7f9      	b.n	800c814 <__fpclassifyd+0x84>

0800c820 <__sread>:
 800c820:	b510      	push	{r4, lr}
 800c822:	460c      	mov	r4, r1
 800c824:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800c828:	f7ff ff10 	bl	800c64c <_read_r>
 800c82c:	2800      	cmp	r0, #0
 800c82e:	bfab      	itete	ge
 800c830:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 800c832:	89a3      	ldrhlt	r3, [r4, #12]
 800c834:	181b      	addge	r3, r3, r0
 800c836:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 800c83a:	bfac      	ite	ge
 800c83c:	6563      	strge	r3, [r4, #84]	; 0x54
 800c83e:	81a3      	strhlt	r3, [r4, #12]
 800c840:	bd10      	pop	{r4, pc}
 800c842:	bf00      	nop

0800c844 <__seofread>:
 800c844:	2000      	movs	r0, #0
 800c846:	4770      	bx	lr

0800c848 <__swrite>:
 800c848:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c84c:	461d      	mov	r5, r3
 800c84e:	898b      	ldrh	r3, [r1, #12]
 800c850:	460c      	mov	r4, r1
 800c852:	4607      	mov	r7, r0
 800c854:	4616      	mov	r6, r2
 800c856:	f413 7f80 	tst.w	r3, #256	; 0x100
 800c85a:	d006      	beq.n	800c86a <__swrite+0x22>
 800c85c:	2302      	movs	r3, #2
 800c85e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800c862:	2200      	movs	r2, #0
 800c864:	f002 f832 	bl	800e8cc <_lseek_r>
 800c868:	89a3      	ldrh	r3, [r4, #12]
 800c86a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800c86e:	4638      	mov	r0, r7
 800c870:	81a3      	strh	r3, [r4, #12]
 800c872:	4632      	mov	r2, r6
 800c874:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800c878:	462b      	mov	r3, r5
 800c87a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800c87e:	f7fd bc29 	b.w	800a0d4 <_write_r>
 800c882:	bf00      	nop

0800c884 <__sseek>:
 800c884:	b510      	push	{r4, lr}
 800c886:	460c      	mov	r4, r1
 800c888:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800c88c:	f002 f81e 	bl	800e8cc <_lseek_r>
 800c890:	89a3      	ldrh	r3, [r4, #12]
 800c892:	f1b0 3fff 	cmp.w	r0, #4294967295
 800c896:	bf15      	itete	ne
 800c898:	6560      	strne	r0, [r4, #84]	; 0x54
 800c89a:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 800c89e:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 800c8a2:	81a3      	strheq	r3, [r4, #12]
 800c8a4:	bf18      	it	ne
 800c8a6:	81a3      	strhne	r3, [r4, #12]
 800c8a8:	bd10      	pop	{r4, pc}
 800c8aa:	bf00      	nop

0800c8ac <__sclose>:
 800c8ac:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800c8b0:	f001 bd30 	b.w	800e314 <_close_r>

0800c8b4 <strlen>:
 800c8b4:	f020 0103 	bic.w	r1, r0, #3
 800c8b8:	f010 0003 	ands.w	r0, r0, #3
 800c8bc:	f1c0 0000 	rsb	r0, r0, #0
 800c8c0:	f851 3b04 	ldr.w	r3, [r1], #4
 800c8c4:	f100 0c04 	add.w	ip, r0, #4
 800c8c8:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 800c8cc:	f06f 0200 	mvn.w	r2, #0
 800c8d0:	bf1c      	itt	ne
 800c8d2:	fa22 f20c 	lsrne.w	r2, r2, ip
 800c8d6:	4313      	orrne	r3, r2
 800c8d8:	f04f 0c01 	mov.w	ip, #1
 800c8dc:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 800c8e0:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 800c8e4:	eba3 020c 	sub.w	r2, r3, ip
 800c8e8:	ea22 0203 	bic.w	r2, r2, r3
 800c8ec:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 800c8f0:	bf04      	itt	eq
 800c8f2:	f851 3b04 	ldreq.w	r3, [r1], #4
 800c8f6:	3004      	addeq	r0, #4
 800c8f8:	d0f4      	beq.n	800c8e4 <strlen+0x30>
 800c8fa:	f013 0fff 	tst.w	r3, #255	; 0xff
 800c8fe:	bf1f      	itttt	ne
 800c900:	3001      	addne	r0, #1
 800c902:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
 800c906:	3001      	addne	r0, #1
 800c908:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
 800c90c:	bf18      	it	ne
 800c90e:	3001      	addne	r0, #1
 800c910:	4770      	bx	lr
 800c912:	bf00      	nop

0800c914 <__ssprint_r>:
 800c914:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c918:	b083      	sub	sp, #12
 800c91a:	4691      	mov	r9, r2
 800c91c:	460d      	mov	r5, r1
 800c91e:	9001      	str	r0, [sp, #4]
 800c920:	6890      	ldr	r0, [r2, #8]
 800c922:	6817      	ldr	r7, [r2, #0]
 800c924:	2800      	cmp	r0, #0
 800c926:	d077      	beq.n	800ca18 <__ssprint_r+0x104>
 800c928:	f04f 0a00 	mov.w	sl, #0
 800c92c:	6808      	ldr	r0, [r1, #0]
 800c92e:	688b      	ldr	r3, [r1, #8]
 800c930:	4654      	mov	r4, sl
 800c932:	2c00      	cmp	r4, #0
 800c934:	d04c      	beq.n	800c9d0 <__ssprint_r+0xbc>
 800c936:	429c      	cmp	r4, r3
 800c938:	461e      	mov	r6, r3
 800c93a:	4698      	mov	r8, r3
 800c93c:	bf3c      	itt	cc
 800c93e:	4626      	movcc	r6, r4
 800c940:	46a0      	movcc	r8, r4
 800c942:	d335      	bcc.n	800c9b0 <__ssprint_r+0x9c>
 800c944:	89ab      	ldrh	r3, [r5, #12]
 800c946:	f413 6f90 	tst.w	r3, #1152	; 0x480
 800c94a:	d031      	beq.n	800c9b0 <__ssprint_r+0x9c>
 800c94c:	696a      	ldr	r2, [r5, #20]
 800c94e:	f104 0e01 	add.w	lr, r4, #1
 800c952:	6929      	ldr	r1, [r5, #16]
 800c954:	eb02 0b42 	add.w	fp, r2, r2, lsl #1
 800c958:	1a46      	subs	r6, r0, r1
 800c95a:	eb0e 0006 	add.w	r0, lr, r6
 800c95e:	eb0b 7bdb 	add.w	fp, fp, fp, lsr #31
 800c962:	ea4f 0b6b 	mov.w	fp, fp, asr #1
 800c966:	4583      	cmp	fp, r0
 800c968:	465a      	mov	r2, fp
 800c96a:	bf3c      	itt	cc
 800c96c:	4683      	movcc	fp, r0
 800c96e:	4602      	movcc	r2, r0
 800c970:	f413 6f80 	tst.w	r3, #1024	; 0x400
 800c974:	d031      	beq.n	800c9da <__ssprint_r+0xc6>
 800c976:	9801      	ldr	r0, [sp, #4]
 800c978:	4611      	mov	r1, r2
 800c97a:	f7f9 fdf1 	bl	8006560 <_malloc_r>
 800c97e:	4680      	mov	r8, r0
 800c980:	2800      	cmp	r0, #0
 800c982:	d034      	beq.n	800c9ee <__ssprint_r+0xda>
 800c984:	6929      	ldr	r1, [r5, #16]
 800c986:	4632      	mov	r2, r6
 800c988:	f7ff f8ba 	bl	800bb00 <memcpy>
 800c98c:	89ab      	ldrh	r3, [r5, #12]
 800c98e:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 800c992:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800c996:	81ab      	strh	r3, [r5, #12]
 800c998:	eb08 0006 	add.w	r0, r8, r6
 800c99c:	ebc6 030b 	rsb	r3, r6, fp
 800c9a0:	f8c5 8010 	str.w	r8, [r5, #16]
 800c9a4:	4626      	mov	r6, r4
 800c9a6:	46a0      	mov	r8, r4
 800c9a8:	6028      	str	r0, [r5, #0]
 800c9aa:	f8c5 b014 	str.w	fp, [r5, #20]
 800c9ae:	60ab      	str	r3, [r5, #8]
 800c9b0:	4642      	mov	r2, r8
 800c9b2:	4651      	mov	r1, sl
 800c9b4:	f001 ffa0 	bl	800e8f8 <memmove>
 800c9b8:	f8d9 2008 	ldr.w	r2, [r9, #8]
 800c9bc:	68ab      	ldr	r3, [r5, #8]
 800c9be:	6828      	ldr	r0, [r5, #0]
 800c9c0:	1b14      	subs	r4, r2, r4
 800c9c2:	1b9b      	subs	r3, r3, r6
 800c9c4:	60ab      	str	r3, [r5, #8]
 800c9c6:	4440      	add	r0, r8
 800c9c8:	6028      	str	r0, [r5, #0]
 800c9ca:	f8c9 4008 	str.w	r4, [r9, #8]
 800c9ce:	b1ec      	cbz	r4, 800ca0c <__ssprint_r+0xf8>
 800c9d0:	f8d7 a000 	ldr.w	sl, [r7]
 800c9d4:	687c      	ldr	r4, [r7, #4]
 800c9d6:	3708      	adds	r7, #8
 800c9d8:	e7ab      	b.n	800c932 <__ssprint_r+0x1e>
 800c9da:	9801      	ldr	r0, [sp, #4]
 800c9dc:	f001 ffe6 	bl	800e9ac <_realloc_r>
 800c9e0:	4680      	mov	r8, r0
 800c9e2:	2800      	cmp	r0, #0
 800c9e4:	d1d8      	bne.n	800c998 <__ssprint_r+0x84>
 800c9e6:	9801      	ldr	r0, [sp, #4]
 800c9e8:	6929      	ldr	r1, [r5, #16]
 800c9ea:	f7fe fe5b 	bl	800b6a4 <_free_r>
 800c9ee:	9a01      	ldr	r2, [sp, #4]
 800c9f0:	230c      	movs	r3, #12
 800c9f2:	f04f 30ff 	mov.w	r0, #4294967295
 800c9f6:	6013      	str	r3, [r2, #0]
 800c9f8:	2300      	movs	r3, #0
 800c9fa:	89aa      	ldrh	r2, [r5, #12]
 800c9fc:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800ca00:	81aa      	strh	r2, [r5, #12]
 800ca02:	f8c9 3008 	str.w	r3, [r9, #8]
 800ca06:	f8c9 3004 	str.w	r3, [r9, #4]
 800ca0a:	e002      	b.n	800ca12 <__ssprint_r+0xfe>
 800ca0c:	4620      	mov	r0, r4
 800ca0e:	f8c9 4004 	str.w	r4, [r9, #4]
 800ca12:	b003      	add	sp, #12
 800ca14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ca18:	6050      	str	r0, [r2, #4]
 800ca1a:	e7fa      	b.n	800ca12 <__ssprint_r+0xfe>

0800ca1c <_svfiprintf_r>:
 800ca1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ca20:	b0ab      	sub	sp, #172	; 0xac
 800ca22:	4689      	mov	r9, r1
 800ca24:	4683      	mov	fp, r0
 800ca26:	9306      	str	r3, [sp, #24]
 800ca28:	898b      	ldrh	r3, [r1, #12]
 800ca2a:	f013 0f80 	tst.w	r3, #128	; 0x80
 800ca2e:	d003      	beq.n	800ca38 <_svfiprintf_r+0x1c>
 800ca30:	690b      	ldr	r3, [r1, #16]
 800ca32:	2b00      	cmp	r3, #0
 800ca34:	f000 8515 	beq.w	800d462 <_svfiprintf_r+0xa46>
 800ca38:	4617      	mov	r7, r2
 800ca3a:	2300      	movs	r3, #0
 800ca3c:	ae0c      	add	r6, sp, #48	; 0x30
 800ca3e:	9308      	str	r3, [sp, #32]
 800ca40:	9305      	str	r3, [sp, #20]
 800ca42:	9626      	str	r6, [sp, #152]	; 0x98
 800ca44:	9328      	str	r3, [sp, #160]	; 0xa0
 800ca46:	9327      	str	r3, [sp, #156]	; 0x9c
 800ca48:	783b      	ldrb	r3, [r7, #0]
 800ca4a:	f1b3 0225 	subs.w	r2, r3, #37	; 0x25
 800ca4e:	bf18      	it	ne
 800ca50:	2201      	movne	r2, #1
 800ca52:	2b00      	cmp	r3, #0
 800ca54:	bf0c      	ite	eq
 800ca56:	2300      	moveq	r3, #0
 800ca58:	f002 0301 	andne.w	r3, r2, #1
 800ca5c:	2b00      	cmp	r3, #0
 800ca5e:	f000 8360 	beq.w	800d122 <_svfiprintf_r+0x706>
 800ca62:	1c7a      	adds	r2, r7, #1
 800ca64:	4614      	mov	r4, r2
 800ca66:	3201      	adds	r2, #1
 800ca68:	7823      	ldrb	r3, [r4, #0]
 800ca6a:	1e19      	subs	r1, r3, #0
 800ca6c:	bf18      	it	ne
 800ca6e:	2101      	movne	r1, #1
 800ca70:	2b25      	cmp	r3, #37	; 0x25
 800ca72:	bf0c      	ite	eq
 800ca74:	2300      	moveq	r3, #0
 800ca76:	f001 0301 	andne.w	r3, r1, #1
 800ca7a:	2b00      	cmp	r3, #0
 800ca7c:	d1f2      	bne.n	800ca64 <_svfiprintf_r+0x48>
 800ca7e:	1be5      	subs	r5, r4, r7
 800ca80:	d00e      	beq.n	800caa0 <_svfiprintf_r+0x84>
 800ca82:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800ca84:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800ca86:	3301      	adds	r3, #1
 800ca88:	6037      	str	r7, [r6, #0]
 800ca8a:	2b07      	cmp	r3, #7
 800ca8c:	6075      	str	r5, [r6, #4]
 800ca8e:	442a      	add	r2, r5
 800ca90:	9327      	str	r3, [sp, #156]	; 0x9c
 800ca92:	9228      	str	r2, [sp, #160]	; 0xa0
 800ca94:	f300 83bc 	bgt.w	800d210 <_svfiprintf_r+0x7f4>
 800ca98:	3608      	adds	r6, #8
 800ca9a:	9905      	ldr	r1, [sp, #20]
 800ca9c:	1949      	adds	r1, r1, r5
 800ca9e:	9105      	str	r1, [sp, #20]
 800caa0:	7823      	ldrb	r3, [r4, #0]
 800caa2:	2b00      	cmp	r3, #0
 800caa4:	f000 833f 	beq.w	800d126 <_svfiprintf_r+0x70a>
 800caa8:	2200      	movs	r2, #0
 800caaa:	2300      	movs	r3, #0
 800caac:	9204      	str	r2, [sp, #16]
 800caae:	1c67      	adds	r7, r4, #1
 800cab0:	f88d 30a7 	strb.w	r3, [sp, #167]	; 0xa7
 800cab4:	f04f 38ff 	mov.w	r8, #4294967295
 800cab8:	7863      	ldrb	r3, [r4, #1]
 800caba:	4692      	mov	sl, r2
 800cabc:	f04f 0c20 	mov.w	ip, #32
 800cac0:	242b      	movs	r4, #43	; 0x2b
 800cac2:	3701      	adds	r7, #1
 800cac4:	f1a3 0220 	sub.w	r2, r3, #32
 800cac8:	2a58      	cmp	r2, #88	; 0x58
 800caca:	f200 824e 	bhi.w	800cf6a <_svfiprintf_r+0x54e>
 800cace:	e8df f012 	tbh	[pc, r2, lsl #1]
 800cad2:	025a      	.short	0x025a
 800cad4:	024c024c 	.word	0x024c024c
 800cad8:	024c01fb 	.word	0x024c01fb
 800cadc:	024c024c 	.word	0x024c024c
 800cae0:	024c024c 	.word	0x024c024c
 800cae4:	00fe024c 	.word	0x00fe024c
 800cae8:	024c0214 	.word	0x024c0214
 800caec:	0218010a 	.word	0x0218010a
 800caf0:	0210024c 	.word	0x0210024c
 800caf4:	01ff01ff 	.word	0x01ff01ff
 800caf8:	01ff01ff 	.word	0x01ff01ff
 800cafc:	01ff01ff 	.word	0x01ff01ff
 800cb00:	01ff01ff 	.word	0x01ff01ff
 800cb04:	024c01ff 	.word	0x024c01ff
 800cb08:	024c024c 	.word	0x024c024c
 800cb0c:	024c024c 	.word	0x024c024c
 800cb10:	024c024c 	.word	0x024c024c
 800cb14:	024c024c 	.word	0x024c024c
 800cb18:	00c7024c 	.word	0x00c7024c
 800cb1c:	024c024c 	.word	0x024c024c
 800cb20:	024c024c 	.word	0x024c024c
 800cb24:	024c024c 	.word	0x024c024c
 800cb28:	024c024c 	.word	0x024c024c
 800cb2c:	024c024c 	.word	0x024c024c
 800cb30:	024c00bd 	.word	0x024c00bd
 800cb34:	024c024c 	.word	0x024c024c
 800cb38:	024c024c 	.word	0x024c024c
 800cb3c:	024c0059 	.word	0x024c0059
 800cb40:	016d024c 	.word	0x016d024c
 800cb44:	024c024c 	.word	0x024c024c
 800cb48:	024c024c 	.word	0x024c024c
 800cb4c:	024c024c 	.word	0x024c024c
 800cb50:	024c024c 	.word	0x024c024c
 800cb54:	024c024c 	.word	0x024c024c
 800cb58:	00c90192 	.word	0x00c90192
 800cb5c:	024c024c 	.word	0x024c024c
 800cb60:	0169024c 	.word	0x0169024c
 800cb64:	024c00c9 	.word	0x024c00c9
 800cb68:	015f024c 	.word	0x015f024c
 800cb6c:	014c024c 	.word	0x014c024c
 800cb70:	013400bf 	.word	0x013400bf
 800cb74:	024c0130 	.word	0x024c0130
 800cb78:	024c010e 	.word	0x024c010e
 800cb7c:	024c005b 	.word	0x024c005b
 800cb80:	0235024c 	.word	0x0235024c
 800cb84:	f04a 0a10 	orr.w	sl, sl, #16
 800cb88:	f01a 0f20 	tst.w	sl, #32
 800cb8c:	f000 83bf 	beq.w	800d30e <_svfiprintf_r+0x8f2>
 800cb90:	9b06      	ldr	r3, [sp, #24]
 800cb92:	1dda      	adds	r2, r3, #7
 800cb94:	2301      	movs	r3, #1
 800cb96:	f022 0207 	bic.w	r2, r2, #7
 800cb9a:	f102 0508 	add.w	r5, r2, #8
 800cb9e:	9506      	str	r5, [sp, #24]
 800cba0:	e9d2 4500 	ldrd	r4, r5, [r2]
 800cba4:	ea54 0005 	orrs.w	r0, r4, r5
 800cba8:	bf0c      	ite	eq
 800cbaa:	2200      	moveq	r2, #0
 800cbac:	2201      	movne	r2, #1
 800cbae:	2100      	movs	r1, #0
 800cbb0:	f88d 10a7 	strb.w	r1, [sp, #167]	; 0xa7
 800cbb4:	f1b8 0f00 	cmp.w	r8, #0
 800cbb8:	bfa8      	it	ge
 800cbba:	f02a 0a80 	bicge.w	sl, sl, #128	; 0x80
 800cbbe:	f1b8 0f00 	cmp.w	r8, #0
 800cbc2:	bf18      	it	ne
 800cbc4:	f042 0201 	orrne.w	r2, r2, #1
 800cbc8:	2a00      	cmp	r2, #0
 800cbca:	d070      	beq.n	800ccae <_svfiprintf_r+0x292>
 800cbcc:	2b01      	cmp	r3, #1
 800cbce:	f000 8348 	beq.w	800d262 <_svfiprintf_r+0x846>
 800cbd2:	2b02      	cmp	r3, #2
 800cbd4:	f000 836f 	beq.w	800d2b6 <_svfiprintf_r+0x89a>
 800cbd8:	aa1c      	add	r2, sp, #112	; 0x70
 800cbda:	46b4      	mov	ip, r6
 800cbdc:	f102 0327 	add.w	r3, r2, #39	; 0x27
 800cbe0:	9202      	str	r2, [sp, #8]
 800cbe2:	9703      	str	r7, [sp, #12]
 800cbe4:	08ea      	lsrs	r2, r5, #3
 800cbe6:	08e7      	lsrs	r7, r4, #3
 800cbe8:	ea47 7745 	orr.w	r7, r7, r5, lsl #29
 800cbec:	f004 0407 	and.w	r4, r4, #7
 800cbf0:	4611      	mov	r1, r2
 800cbf2:	f104 0230 	add.w	r2, r4, #48	; 0x30
 800cbf6:	460d      	mov	r5, r1
 800cbf8:	463c      	mov	r4, r7
 800cbfa:	461e      	mov	r6, r3
 800cbfc:	701a      	strb	r2, [r3, #0]
 800cbfe:	3b01      	subs	r3, #1
 800cc00:	ea54 0005 	orrs.w	r0, r4, r5
 800cc04:	d1ee      	bne.n	800cbe4 <_svfiprintf_r+0x1c8>
 800cc06:	f01a 0f01 	tst.w	sl, #1
 800cc0a:	9609      	str	r6, [sp, #36]	; 0x24
 800cc0c:	9f03      	ldr	r7, [sp, #12]
 800cc0e:	4666      	mov	r6, ip
 800cc10:	f000 83ab 	beq.w	800d36a <_svfiprintf_r+0x94e>
 800cc14:	2a30      	cmp	r2, #48	; 0x30
 800cc16:	f000 8365 	beq.w	800d2e4 <_svfiprintf_r+0x8c8>
 800cc1a:	9309      	str	r3, [sp, #36]	; 0x24
 800cc1c:	9902      	ldr	r1, [sp, #8]
 800cc1e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800cc20:	f101 0328 	add.w	r3, r1, #40	; 0x28
 800cc24:	1a9b      	subs	r3, r3, r2
 800cc26:	9303      	str	r3, [sp, #12]
 800cc28:	2330      	movs	r3, #48	; 0x30
 800cc2a:	7013      	strb	r3, [r2, #0]
 800cc2c:	f8cd 801c 	str.w	r8, [sp, #28]
 800cc30:	9803      	ldr	r0, [sp, #12]
 800cc32:	9907      	ldr	r1, [sp, #28]
 800cc34:	f89d 30a7 	ldrb.w	r3, [sp, #167]	; 0xa7
 800cc38:	4288      	cmp	r0, r1
 800cc3a:	bfb8      	it	lt
 800cc3c:	4608      	movlt	r0, r1
 800cc3e:	9002      	str	r0, [sp, #8]
 800cc40:	2b00      	cmp	r3, #0
 800cc42:	f000 80e8 	beq.w	800ce16 <_svfiprintf_r+0x3fa>
 800cc46:	3001      	adds	r0, #1
 800cc48:	9002      	str	r0, [sp, #8]
 800cc4a:	e0e4      	b.n	800ce16 <_svfiprintf_r+0x3fa>
 800cc4c:	f04a 0a10 	orr.w	sl, sl, #16
 800cc50:	f01a 0320 	ands.w	r3, sl, #32
 800cc54:	f000 8366 	beq.w	800d324 <_svfiprintf_r+0x908>
 800cc58:	9b06      	ldr	r3, [sp, #24]
 800cc5a:	1dda      	adds	r2, r3, #7
 800cc5c:	2300      	movs	r3, #0
 800cc5e:	e79a      	b.n	800cb96 <_svfiprintf_r+0x17a>
 800cc60:	f04a 0a10 	orr.w	sl, sl, #16
 800cc64:	f01a 0f20 	tst.w	sl, #32
 800cc68:	f000 8343 	beq.w	800d2f2 <_svfiprintf_r+0x8d6>
 800cc6c:	9806      	ldr	r0, [sp, #24]
 800cc6e:	1dc3      	adds	r3, r0, #7
 800cc70:	f023 0307 	bic.w	r3, r3, #7
 800cc74:	f103 0108 	add.w	r1, r3, #8
 800cc78:	9106      	str	r1, [sp, #24]
 800cc7a:	e9d3 4500 	ldrd	r4, r5, [r3]
 800cc7e:	2c00      	cmp	r4, #0
 800cc80:	f175 0000 	sbcs.w	r0, r5, #0
 800cc84:	f2c0 83ab 	blt.w	800d3de <_svfiprintf_r+0x9c2>
 800cc88:	ea54 0105 	orrs.w	r1, r4, r5
 800cc8c:	f04f 0301 	mov.w	r3, #1
 800cc90:	bf0c      	ite	eq
 800cc92:	2200      	moveq	r2, #0
 800cc94:	2201      	movne	r2, #1
 800cc96:	f1b8 0f00 	cmp.w	r8, #0
 800cc9a:	bfa8      	it	ge
 800cc9c:	f02a 0a80 	bicge.w	sl, sl, #128	; 0x80
 800cca0:	f1b8 0f00 	cmp.w	r8, #0
 800cca4:	bf18      	it	ne
 800cca6:	f042 0201 	orrne.w	r2, r2, #1
 800ccaa:	2a00      	cmp	r2, #0
 800ccac:	d18e      	bne.n	800cbcc <_svfiprintf_r+0x1b0>
 800ccae:	2b00      	cmp	r3, #0
 800ccb0:	f040 82aa 	bne.w	800d208 <_svfiprintf_r+0x7ec>
 800ccb4:	f01a 0f01 	tst.w	sl, #1
 800ccb8:	f000 82f9 	beq.w	800d2ae <_svfiprintf_r+0x892>
 800ccbc:	2101      	movs	r1, #1
 800ccbe:	2330      	movs	r3, #48	; 0x30
 800ccc0:	f10d 0297 	add.w	r2, sp, #151	; 0x97
 800ccc4:	9103      	str	r1, [sp, #12]
 800ccc6:	f88d 3097 	strb.w	r3, [sp, #151]	; 0x97
 800ccca:	9209      	str	r2, [sp, #36]	; 0x24
 800cccc:	e7ae      	b.n	800cc2c <_svfiprintf_r+0x210>
 800ccce:	9806      	ldr	r0, [sp, #24]
 800ccd0:	9906      	ldr	r1, [sp, #24]
 800ccd2:	6800      	ldr	r0, [r0, #0]
 800ccd4:	1d0a      	adds	r2, r1, #4
 800ccd6:	2800      	cmp	r0, #0
 800ccd8:	9004      	str	r0, [sp, #16]
 800ccda:	f280 8338 	bge.w	800d34e <_svfiprintf_r+0x932>
 800ccde:	9b04      	ldr	r3, [sp, #16]
 800cce0:	9206      	str	r2, [sp, #24]
 800cce2:	425b      	negs	r3, r3
 800cce4:	9304      	str	r3, [sp, #16]
 800cce6:	f04a 0a04 	orr.w	sl, sl, #4
 800ccea:	783b      	ldrb	r3, [r7, #0]
 800ccec:	e6e9      	b.n	800cac2 <_svfiprintf_r+0xa6>
 800ccee:	9b06      	ldr	r3, [sp, #24]
 800ccf0:	2500      	movs	r5, #0
 800ccf2:	f88d 50a7 	strb.w	r5, [sp, #167]	; 0xa7
 800ccf6:	1d18      	adds	r0, r3, #4
 800ccf8:	9006      	str	r0, [sp, #24]
 800ccfa:	681b      	ldr	r3, [r3, #0]
 800ccfc:	9309      	str	r3, [sp, #36]	; 0x24
 800ccfe:	2b00      	cmp	r3, #0
 800cd00:	f000 83ce 	beq.w	800d4a0 <_svfiprintf_r+0xa84>
 800cd04:	f1b8 0f00 	cmp.w	r8, #0
 800cd08:	f2c0 837b 	blt.w	800d402 <_svfiprintf_r+0x9e6>
 800cd0c:	9809      	ldr	r0, [sp, #36]	; 0x24
 800cd0e:	2100      	movs	r1, #0
 800cd10:	4642      	mov	r2, r8
 800cd12:	f7fe feaf 	bl	800ba74 <memchr>
 800cd16:	2800      	cmp	r0, #0
 800cd18:	f000 83d4 	beq.w	800d4c4 <_svfiprintf_r+0xaa8>
 800cd1c:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800cd1e:	1b40      	subs	r0, r0, r5
 800cd20:	9003      	str	r0, [sp, #12]
 800cd22:	4540      	cmp	r0, r8
 800cd24:	f340 837f 	ble.w	800d426 <_svfiprintf_r+0xa0a>
 800cd28:	2500      	movs	r5, #0
 800cd2a:	f8cd 800c 	str.w	r8, [sp, #12]
 800cd2e:	9507      	str	r5, [sp, #28]
 800cd30:	e77e      	b.n	800cc30 <_svfiprintf_r+0x214>
 800cd32:	f04a 0a20 	orr.w	sl, sl, #32
 800cd36:	783b      	ldrb	r3, [r7, #0]
 800cd38:	e6c3      	b.n	800cac2 <_svfiprintf_r+0xa6>
 800cd3a:	9b06      	ldr	r3, [sp, #24]
 800cd3c:	f240 4198 	movw	r1, #1176	; 0x498
 800cd40:	2500      	movs	r5, #0
 800cd42:	f6c0 0101 	movt	r1, #2049	; 0x801
 800cd46:	f04a 0a02 	orr.w	sl, sl, #2
 800cd4a:	681a      	ldr	r2, [r3, #0]
 800cd4c:	3304      	adds	r3, #4
 800cd4e:	9306      	str	r3, [sp, #24]
 800cd50:	2330      	movs	r3, #48	; 0x30
 800cd52:	4614      	mov	r4, r2
 800cd54:	f88d 30a4 	strb.w	r3, [sp, #164]	; 0xa4
 800cd58:	2378      	movs	r3, #120	; 0x78
 800cd5a:	3a00      	subs	r2, #0
 800cd5c:	f88d 30a5 	strb.w	r3, [sp, #165]	; 0xa5
 800cd60:	bf18      	it	ne
 800cd62:	2201      	movne	r2, #1
 800cd64:	9108      	str	r1, [sp, #32]
 800cd66:	2302      	movs	r3, #2
 800cd68:	e721      	b.n	800cbae <_svfiprintf_r+0x192>
 800cd6a:	f01a 0f20 	tst.w	sl, #32
 800cd6e:	f040 830c 	bne.w	800d38a <_svfiprintf_r+0x96e>
 800cd72:	f01a 0f10 	tst.w	sl, #16
 800cd76:	f040 834b 	bne.w	800d410 <_svfiprintf_r+0x9f4>
 800cd7a:	f01a 0f40 	tst.w	sl, #64	; 0x40
 800cd7e:	f000 8347 	beq.w	800d410 <_svfiprintf_r+0x9f4>
 800cd82:	9d06      	ldr	r5, [sp, #24]
 800cd84:	9805      	ldr	r0, [sp, #20]
 800cd86:	682b      	ldr	r3, [r5, #0]
 800cd88:	3504      	adds	r5, #4
 800cd8a:	9506      	str	r5, [sp, #24]
 800cd8c:	8018      	strh	r0, [r3, #0]
 800cd8e:	e65b      	b.n	800ca48 <_svfiprintf_r+0x2c>
 800cd90:	783b      	ldrb	r3, [r7, #0]
 800cd92:	2b6c      	cmp	r3, #108	; 0x6c
 800cd94:	bf0a      	itet	eq
 800cd96:	f04a 0a20 	orreq.w	sl, sl, #32
 800cd9a:	f04a 0a10 	orrne.w	sl, sl, #16
 800cd9e:	f817 3f01 	ldrbeq.w	r3, [r7, #1]!
 800cda2:	e68e      	b.n	800cac2 <_svfiprintf_r+0xa6>
 800cda4:	f04a 0a40 	orr.w	sl, sl, #64	; 0x40
 800cda8:	783b      	ldrb	r3, [r7, #0]
 800cdaa:	e68a      	b.n	800cac2 <_svfiprintf_r+0xa6>
 800cdac:	f01a 0f20 	tst.w	sl, #32
 800cdb0:	f240 4284 	movw	r2, #1156	; 0x484
 800cdb4:	f6c0 0201 	movt	r2, #2049	; 0x801
 800cdb8:	9208      	str	r2, [sp, #32]
 800cdba:	f000 80c8 	beq.w	800cf4e <_svfiprintf_r+0x532>
 800cdbe:	9d06      	ldr	r5, [sp, #24]
 800cdc0:	1dea      	adds	r2, r5, #7
 800cdc2:	f022 0207 	bic.w	r2, r2, #7
 800cdc6:	f102 0008 	add.w	r0, r2, #8
 800cdca:	9006      	str	r0, [sp, #24]
 800cdcc:	e9d2 4500 	ldrd	r4, r5, [r2]
 800cdd0:	ea54 0005 	orrs.w	r0, r4, r5
 800cdd4:	bf0c      	ite	eq
 800cdd6:	2200      	moveq	r2, #0
 800cdd8:	2201      	movne	r2, #1
 800cdda:	ea1a 0f02 	tst.w	sl, r2
 800cdde:	f000 82b4 	beq.w	800d34a <_svfiprintf_r+0x92e>
 800cde2:	f88d 30a5 	strb.w	r3, [sp, #165]	; 0xa5
 800cde6:	f04a 0a02 	orr.w	sl, sl, #2
 800cdea:	2330      	movs	r3, #48	; 0x30
 800cdec:	2201      	movs	r2, #1
 800cdee:	f88d 30a4 	strb.w	r3, [sp, #164]	; 0xa4
 800cdf2:	2302      	movs	r3, #2
 800cdf4:	e6db      	b.n	800cbae <_svfiprintf_r+0x192>
 800cdf6:	9b06      	ldr	r3, [sp, #24]
 800cdf8:	2001      	movs	r0, #1
 800cdfa:	aa1c      	add	r2, sp, #112	; 0x70
 800cdfc:	2500      	movs	r5, #0
 800cdfe:	1d19      	adds	r1, r3, #4
 800ce00:	9002      	str	r0, [sp, #8]
 800ce02:	681b      	ldr	r3, [r3, #0]
 800ce04:	9106      	str	r1, [sp, #24]
 800ce06:	9003      	str	r0, [sp, #12]
 800ce08:	9209      	str	r2, [sp, #36]	; 0x24
 800ce0a:	f88d 50a7 	strb.w	r5, [sp, #167]	; 0xa7
 800ce0e:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
 800ce12:	2100      	movs	r1, #0
 800ce14:	9107      	str	r1, [sp, #28]
 800ce16:	f01a 0202 	ands.w	r2, sl, #2
 800ce1a:	920a      	str	r2, [sp, #40]	; 0x28
 800ce1c:	d002      	beq.n	800ce24 <_svfiprintf_r+0x408>
 800ce1e:	9b02      	ldr	r3, [sp, #8]
 800ce20:	3302      	adds	r3, #2
 800ce22:	9302      	str	r3, [sp, #8]
 800ce24:	f01a 0584 	ands.w	r5, sl, #132	; 0x84
 800ce28:	950b      	str	r5, [sp, #44]	; 0x2c
 800ce2a:	f040 80b5 	bne.w	800cf98 <_svfiprintf_r+0x57c>
 800ce2e:	9804      	ldr	r0, [sp, #16]
 800ce30:	9902      	ldr	r1, [sp, #8]
 800ce32:	1a44      	subs	r4, r0, r1
 800ce34:	2c00      	cmp	r4, #0
 800ce36:	f340 80af 	ble.w	800cf98 <_svfiprintf_r+0x57c>
 800ce3a:	2c10      	cmp	r4, #16
 800ce3c:	f340 8321 	ble.w	800d482 <_svfiprintf_r+0xa66>
 800ce40:	f240 3548 	movw	r5, #840	; 0x348
 800ce44:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800ce46:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800ce48:	f6c0 0501 	movt	r5, #2049	; 0x801
 800ce4c:	f04f 0810 	mov.w	r8, #16
 800ce50:	e002      	b.n	800ce58 <_svfiprintf_r+0x43c>
 800ce52:	3c10      	subs	r4, #16
 800ce54:	2c10      	cmp	r4, #16
 800ce56:	dd1c      	ble.n	800ce92 <_svfiprintf_r+0x476>
 800ce58:	3301      	adds	r3, #1
 800ce5a:	6035      	str	r5, [r6, #0]
 800ce5c:	f8c6 8004 	str.w	r8, [r6, #4]
 800ce60:	3210      	adds	r2, #16
 800ce62:	3608      	adds	r6, #8
 800ce64:	2b07      	cmp	r3, #7
 800ce66:	9327      	str	r3, [sp, #156]	; 0x9c
 800ce68:	f106 0c08 	add.w	ip, r6, #8
 800ce6c:	9228      	str	r2, [sp, #160]	; 0xa0
 800ce6e:	ddf0      	ble.n	800ce52 <_svfiprintf_r+0x436>
 800ce70:	aa26      	add	r2, sp, #152	; 0x98
 800ce72:	4658      	mov	r0, fp
 800ce74:	4649      	mov	r1, r9
 800ce76:	ae0c      	add	r6, sp, #48	; 0x30
 800ce78:	f7ff fd4c 	bl	800c914 <__ssprint_r>
 800ce7c:	aa0c      	add	r2, sp, #48	; 0x30
 800ce7e:	f102 0c08 	add.w	ip, r2, #8
 800ce82:	2800      	cmp	r0, #0
 800ce84:	f040 8156 	bne.w	800d134 <_svfiprintf_r+0x718>
 800ce88:	3c10      	subs	r4, #16
 800ce8a:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800ce8c:	2c10      	cmp	r4, #16
 800ce8e:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800ce90:	dce2      	bgt.n	800ce58 <_svfiprintf_r+0x43c>
 800ce92:	3301      	adds	r3, #1
 800ce94:	6035      	str	r5, [r6, #0]
 800ce96:	2b07      	cmp	r3, #7
 800ce98:	6074      	str	r4, [r6, #4]
 800ce9a:	4422      	add	r2, r4
 800ce9c:	9327      	str	r3, [sp, #156]	; 0x9c
 800ce9e:	9228      	str	r2, [sp, #160]	; 0xa0
 800cea0:	bfdc      	itt	le
 800cea2:	f10c 0108 	addle.w	r1, ip, #8
 800cea6:	4666      	movle	r6, ip
 800cea8:	dd7a      	ble.n	800cfa0 <_svfiprintf_r+0x584>
 800ceaa:	4658      	mov	r0, fp
 800ceac:	4649      	mov	r1, r9
 800ceae:	aa26      	add	r2, sp, #152	; 0x98
 800ceb0:	f7ff fd30 	bl	800c914 <__ssprint_r>
 800ceb4:	2800      	cmp	r0, #0
 800ceb6:	f040 813d 	bne.w	800d134 <_svfiprintf_r+0x718>
 800ceba:	ab0c      	add	r3, sp, #48	; 0x30
 800cebc:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800cebe:	f103 0108 	add.w	r1, r3, #8
 800cec2:	ae0c      	add	r6, sp, #48	; 0x30
 800cec4:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800cec6:	e06b      	b.n	800cfa0 <_svfiprintf_r+0x584>
 800cec8:	f04a 0a01 	orr.w	sl, sl, #1
 800cecc:	783b      	ldrb	r3, [r7, #0]
 800cece:	e5f8      	b.n	800cac2 <_svfiprintf_r+0xa6>
 800ced0:	4639      	mov	r1, r7
 800ced2:	2200      	movs	r2, #0
 800ced4:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
 800ced8:	f811 3b01 	ldrb.w	r3, [r1], #1
 800cedc:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800cee0:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 800cee4:	460f      	mov	r7, r1
 800cee6:	2809      	cmp	r0, #9
 800cee8:	eb05 0242 	add.w	r2, r5, r2, lsl #1
 800ceec:	d9f2      	bls.n	800ced4 <_svfiprintf_r+0x4b8>
 800ceee:	9204      	str	r2, [sp, #16]
 800cef0:	e5e8      	b.n	800cac4 <_svfiprintf_r+0xa8>
 800cef2:	f04a 0a80 	orr.w	sl, sl, #128	; 0x80
 800cef6:	783b      	ldrb	r3, [r7, #0]
 800cef8:	e5e3      	b.n	800cac2 <_svfiprintf_r+0xa6>
 800cefa:	f88d 40a7 	strb.w	r4, [sp, #167]	; 0xa7
 800cefe:	783b      	ldrb	r3, [r7, #0]
 800cf00:	e5df      	b.n	800cac2 <_svfiprintf_r+0xa6>
 800cf02:	f817 3b01 	ldrb.w	r3, [r7], #1
 800cf06:	2b2a      	cmp	r3, #42	; 0x2a
 800cf08:	f000 82e1 	beq.w	800d4ce <_svfiprintf_r+0xab2>
 800cf0c:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800cf10:	2a09      	cmp	r2, #9
 800cf12:	bf88      	it	hi
 800cf14:	f04f 0800 	movhi.w	r8, #0
 800cf18:	d80d      	bhi.n	800cf36 <_svfiprintf_r+0x51a>
 800cf1a:	4639      	mov	r1, r7
 800cf1c:	f04f 0800 	mov.w	r8, #0
 800cf20:	f811 3b01 	ldrb.w	r3, [r1], #1
 800cf24:	eb08 0888 	add.w	r8, r8, r8, lsl #2
 800cf28:	eb02 0848 	add.w	r8, r2, r8, lsl #1
 800cf2c:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800cf30:	2a09      	cmp	r2, #9
 800cf32:	460f      	mov	r7, r1
 800cf34:	d9f4      	bls.n	800cf20 <_svfiprintf_r+0x504>
 800cf36:	ea48 78e8 	orr.w	r8, r8, r8, asr #31
 800cf3a:	e5c3      	b.n	800cac4 <_svfiprintf_r+0xa8>
 800cf3c:	f01a 0f20 	tst.w	sl, #32
 800cf40:	f240 4198 	movw	r1, #1176	; 0x498
 800cf44:	f6c0 0101 	movt	r1, #2049	; 0x801
 800cf48:	9108      	str	r1, [sp, #32]
 800cf4a:	f47f af38 	bne.w	800cdbe <_svfiprintf_r+0x3a2>
 800cf4e:	f01a 0f10 	tst.w	sl, #16
 800cf52:	f040 8226 	bne.w	800d3a2 <_svfiprintf_r+0x986>
 800cf56:	f01a 0f40 	tst.w	sl, #64	; 0x40
 800cf5a:	f000 8278 	beq.w	800d44e <_svfiprintf_r+0xa32>
 800cf5e:	9a06      	ldr	r2, [sp, #24]
 800cf60:	2500      	movs	r5, #0
 800cf62:	8814      	ldrh	r4, [r2, #0]
 800cf64:	3204      	adds	r2, #4
 800cf66:	9206      	str	r2, [sp, #24]
 800cf68:	e732      	b.n	800cdd0 <_svfiprintf_r+0x3b4>
 800cf6a:	2b00      	cmp	r3, #0
 800cf6c:	f000 80db 	beq.w	800d126 <_svfiprintf_r+0x70a>
 800cf70:	2001      	movs	r0, #1
 800cf72:	2100      	movs	r1, #0
 800cf74:	aa1c      	add	r2, sp, #112	; 0x70
 800cf76:	9002      	str	r0, [sp, #8]
 800cf78:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
 800cf7c:	f88d 10a7 	strb.w	r1, [sp, #167]	; 0xa7
 800cf80:	9003      	str	r0, [sp, #12]
 800cf82:	9209      	str	r2, [sp, #36]	; 0x24
 800cf84:	e745      	b.n	800ce12 <_svfiprintf_r+0x3f6>
 800cf86:	f89d 30a7 	ldrb.w	r3, [sp, #167]	; 0xa7
 800cf8a:	2b00      	cmp	r3, #0
 800cf8c:	f040 821a 	bne.w	800d3c4 <_svfiprintf_r+0x9a8>
 800cf90:	f88d c0a7 	strb.w	ip, [sp, #167]	; 0xa7
 800cf94:	783b      	ldrb	r3, [r7, #0]
 800cf96:	e594      	b.n	800cac2 <_svfiprintf_r+0xa6>
 800cf98:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800cf9a:	f106 0108 	add.w	r1, r6, #8
 800cf9e:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800cfa0:	f89d 00a7 	ldrb.w	r0, [sp, #167]	; 0xa7
 800cfa4:	b168      	cbz	r0, 800cfc2 <_svfiprintf_r+0x5a6>
 800cfa6:	3301      	adds	r3, #1
 800cfa8:	f10d 00a7 	add.w	r0, sp, #167	; 0xa7
 800cfac:	6030      	str	r0, [r6, #0]
 800cfae:	2001      	movs	r0, #1
 800cfb0:	2b07      	cmp	r3, #7
 800cfb2:	6070      	str	r0, [r6, #4]
 800cfb4:	4402      	add	r2, r0
 800cfb6:	9327      	str	r3, [sp, #156]	; 0x9c
 800cfb8:	9228      	str	r2, [sp, #160]	; 0xa0
 800cfba:	f300 8132 	bgt.w	800d222 <_svfiprintf_r+0x806>
 800cfbe:	460e      	mov	r6, r1
 800cfc0:	3108      	adds	r1, #8
 800cfc2:	980a      	ldr	r0, [sp, #40]	; 0x28
 800cfc4:	b160      	cbz	r0, 800cfe0 <_svfiprintf_r+0x5c4>
 800cfc6:	3301      	adds	r3, #1
 800cfc8:	a829      	add	r0, sp, #164	; 0xa4
 800cfca:	6030      	str	r0, [r6, #0]
 800cfcc:	2002      	movs	r0, #2
 800cfce:	2b07      	cmp	r3, #7
 800cfd0:	6070      	str	r0, [r6, #4]
 800cfd2:	4402      	add	r2, r0
 800cfd4:	9327      	str	r3, [sp, #156]	; 0x9c
 800cfd6:	9228      	str	r2, [sp, #160]	; 0xa0
 800cfd8:	f300 8134 	bgt.w	800d244 <_svfiprintf_r+0x828>
 800cfdc:	460e      	mov	r6, r1
 800cfde:	3108      	adds	r1, #8
 800cfe0:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 800cfe2:	2d80      	cmp	r5, #128	; 0x80
 800cfe4:	f000 80b3 	beq.w	800d14e <_svfiprintf_r+0x732>
 800cfe8:	9807      	ldr	r0, [sp, #28]
 800cfea:	9d03      	ldr	r5, [sp, #12]
 800cfec:	1b44      	subs	r4, r0, r5
 800cfee:	2c00      	cmp	r4, #0
 800cff0:	dd3e      	ble.n	800d070 <_svfiprintf_r+0x654>
 800cff2:	2c10      	cmp	r4, #16
 800cff4:	f340 8214 	ble.w	800d420 <_svfiprintf_r+0xa04>
 800cff8:	4d91      	ldr	r5, [pc, #580]	; (800d240 <_svfiprintf_r+0x824>)
 800cffa:	f04f 0810 	mov.w	r8, #16
 800cffe:	e002      	b.n	800d006 <_svfiprintf_r+0x5ea>
 800d000:	3c10      	subs	r4, #16
 800d002:	2c10      	cmp	r4, #16
 800d004:	dd1b      	ble.n	800d03e <_svfiprintf_r+0x622>
 800d006:	3301      	adds	r3, #1
 800d008:	6035      	str	r5, [r6, #0]
 800d00a:	f8c6 8004 	str.w	r8, [r6, #4]
 800d00e:	3210      	adds	r2, #16
 800d010:	3608      	adds	r6, #8
 800d012:	2b07      	cmp	r3, #7
 800d014:	9327      	str	r3, [sp, #156]	; 0x9c
 800d016:	f106 0c08 	add.w	ip, r6, #8
 800d01a:	9228      	str	r2, [sp, #160]	; 0xa0
 800d01c:	ddf0      	ble.n	800d000 <_svfiprintf_r+0x5e4>
 800d01e:	4649      	mov	r1, r9
 800d020:	4658      	mov	r0, fp
 800d022:	aa26      	add	r2, sp, #152	; 0x98
 800d024:	ae0c      	add	r6, sp, #48	; 0x30
 800d026:	f7ff fc75 	bl	800c914 <__ssprint_r>
 800d02a:	a90c      	add	r1, sp, #48	; 0x30
 800d02c:	f101 0c08 	add.w	ip, r1, #8
 800d030:	2800      	cmp	r0, #0
 800d032:	d17f      	bne.n	800d134 <_svfiprintf_r+0x718>
 800d034:	3c10      	subs	r4, #16
 800d036:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800d038:	2c10      	cmp	r4, #16
 800d03a:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800d03c:	dce3      	bgt.n	800d006 <_svfiprintf_r+0x5ea>
 800d03e:	3301      	adds	r3, #1
 800d040:	6035      	str	r5, [r6, #0]
 800d042:	2b07      	cmp	r3, #7
 800d044:	6074      	str	r4, [r6, #4]
 800d046:	4422      	add	r2, r4
 800d048:	9327      	str	r3, [sp, #156]	; 0x9c
 800d04a:	9228      	str	r2, [sp, #160]	; 0xa0
 800d04c:	bfdc      	itt	le
 800d04e:	f10c 0108 	addle.w	r1, ip, #8
 800d052:	4666      	movle	r6, ip
 800d054:	dd0c      	ble.n	800d070 <_svfiprintf_r+0x654>
 800d056:	4658      	mov	r0, fp
 800d058:	4649      	mov	r1, r9
 800d05a:	aa26      	add	r2, sp, #152	; 0x98
 800d05c:	f7ff fc5a 	bl	800c914 <__ssprint_r>
 800d060:	2800      	cmp	r0, #0
 800d062:	d167      	bne.n	800d134 <_svfiprintf_r+0x718>
 800d064:	ab0c      	add	r3, sp, #48	; 0x30
 800d066:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800d068:	f103 0108 	add.w	r1, r3, #8
 800d06c:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800d06e:	ae0c      	add	r6, sp, #48	; 0x30
 800d070:	3301      	adds	r3, #1
 800d072:	9803      	ldr	r0, [sp, #12]
 800d074:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800d076:	2b07      	cmp	r3, #7
 800d078:	4402      	add	r2, r0
 800d07a:	6070      	str	r0, [r6, #4]
 800d07c:	6035      	str	r5, [r6, #0]
 800d07e:	9327      	str	r3, [sp, #156]	; 0x9c
 800d080:	9228      	str	r2, [sp, #160]	; 0xa0
 800d082:	f300 80ae 	bgt.w	800d1e2 <_svfiprintf_r+0x7c6>
 800d086:	f01a 0f04 	tst.w	sl, #4
 800d08a:	d030      	beq.n	800d0ee <_svfiprintf_r+0x6d2>
 800d08c:	9b04      	ldr	r3, [sp, #16]
 800d08e:	9d02      	ldr	r5, [sp, #8]
 800d090:	1b5c      	subs	r4, r3, r5
 800d092:	2c00      	cmp	r4, #0
 800d094:	dd2b      	ble.n	800d0ee <_svfiprintf_r+0x6d2>
 800d096:	2c10      	cmp	r4, #16
 800d098:	f340 81fc 	ble.w	800d494 <_svfiprintf_r+0xa78>
 800d09c:	f240 3548 	movw	r5, #840	; 0x348
 800d0a0:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800d0a2:	f6c0 0501 	movt	r5, #2049	; 0x801
 800d0a6:	2610      	movs	r6, #16
 800d0a8:	e002      	b.n	800d0b0 <_svfiprintf_r+0x694>
 800d0aa:	3c10      	subs	r4, #16
 800d0ac:	2c10      	cmp	r4, #16
 800d0ae:	dd15      	ble.n	800d0dc <_svfiprintf_r+0x6c0>
 800d0b0:	3301      	adds	r3, #1
 800d0b2:	600d      	str	r5, [r1, #0]
 800d0b4:	604e      	str	r6, [r1, #4]
 800d0b6:	3210      	adds	r2, #16
 800d0b8:	3108      	adds	r1, #8
 800d0ba:	2b07      	cmp	r3, #7
 800d0bc:	9327      	str	r3, [sp, #156]	; 0x9c
 800d0be:	9228      	str	r2, [sp, #160]	; 0xa0
 800d0c0:	ddf3      	ble.n	800d0aa <_svfiprintf_r+0x68e>
 800d0c2:	4649      	mov	r1, r9
 800d0c4:	4658      	mov	r0, fp
 800d0c6:	aa26      	add	r2, sp, #152	; 0x98
 800d0c8:	f7ff fc24 	bl	800c914 <__ssprint_r>
 800d0cc:	a90c      	add	r1, sp, #48	; 0x30
 800d0ce:	2800      	cmp	r0, #0
 800d0d0:	d130      	bne.n	800d134 <_svfiprintf_r+0x718>
 800d0d2:	3c10      	subs	r4, #16
 800d0d4:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800d0d6:	2c10      	cmp	r4, #16
 800d0d8:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800d0da:	dce9      	bgt.n	800d0b0 <_svfiprintf_r+0x694>
 800d0dc:	3301      	adds	r3, #1
 800d0de:	600d      	str	r5, [r1, #0]
 800d0e0:	2b07      	cmp	r3, #7
 800d0e2:	604c      	str	r4, [r1, #4]
 800d0e4:	4422      	add	r2, r4
 800d0e6:	9327      	str	r3, [sp, #156]	; 0x9c
 800d0e8:	9228      	str	r2, [sp, #160]	; 0xa0
 800d0ea:	f300 8134 	bgt.w	800d356 <_svfiprintf_r+0x93a>
 800d0ee:	9805      	ldr	r0, [sp, #20]
 800d0f0:	9b02      	ldr	r3, [sp, #8]
 800d0f2:	9904      	ldr	r1, [sp, #16]
 800d0f4:	428b      	cmp	r3, r1
 800d0f6:	bfac      	ite	ge
 800d0f8:	18c0      	addge	r0, r0, r3
 800d0fa:	1840      	addlt	r0, r0, r1
 800d0fc:	9005      	str	r0, [sp, #20]
 800d0fe:	2a00      	cmp	r2, #0
 800d100:	d179      	bne.n	800d1f6 <_svfiprintf_r+0x7da>
 800d102:	2500      	movs	r5, #0
 800d104:	9527      	str	r5, [sp, #156]	; 0x9c
 800d106:	783b      	ldrb	r3, [r7, #0]
 800d108:	ae0c      	add	r6, sp, #48	; 0x30
 800d10a:	f1b3 0225 	subs.w	r2, r3, #37	; 0x25
 800d10e:	bf18      	it	ne
 800d110:	2201      	movne	r2, #1
 800d112:	2b00      	cmp	r3, #0
 800d114:	bf0c      	ite	eq
 800d116:	2300      	moveq	r3, #0
 800d118:	f002 0301 	andne.w	r3, r2, #1
 800d11c:	2b00      	cmp	r3, #0
 800d11e:	f47f aca0 	bne.w	800ca62 <_svfiprintf_r+0x46>
 800d122:	463c      	mov	r4, r7
 800d124:	e4bc      	b.n	800caa0 <_svfiprintf_r+0x84>
 800d126:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 800d128:	b123      	cbz	r3, 800d134 <_svfiprintf_r+0x718>
 800d12a:	4658      	mov	r0, fp
 800d12c:	4649      	mov	r1, r9
 800d12e:	aa26      	add	r2, sp, #152	; 0x98
 800d130:	f7ff fbf0 	bl	800c914 <__ssprint_r>
 800d134:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 800d138:	9805      	ldr	r0, [sp, #20]
 800d13a:	f013 0f40 	tst.w	r3, #64	; 0x40
 800d13e:	bf18      	it	ne
 800d140:	f04f 30ff 	movne.w	r0, #4294967295
 800d144:	9005      	str	r0, [sp, #20]
 800d146:	9805      	ldr	r0, [sp, #20]
 800d148:	b02b      	add	sp, #172	; 0xac
 800d14a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d14e:	9804      	ldr	r0, [sp, #16]
 800d150:	9d02      	ldr	r5, [sp, #8]
 800d152:	1b44      	subs	r4, r0, r5
 800d154:	2c00      	cmp	r4, #0
 800d156:	bfd8      	it	le
 800d158:	f106 0108 	addle.w	r1, r6, #8
 800d15c:	f77f af44 	ble.w	800cfe8 <_svfiprintf_r+0x5cc>
 800d160:	2c10      	cmp	r4, #16
 800d162:	f340 81ac 	ble.w	800d4be <_svfiprintf_r+0xaa2>
 800d166:	4d36      	ldr	r5, [pc, #216]	; (800d240 <_svfiprintf_r+0x824>)
 800d168:	f04f 0810 	mov.w	r8, #16
 800d16c:	e002      	b.n	800d174 <_svfiprintf_r+0x758>
 800d16e:	3c10      	subs	r4, #16
 800d170:	2c10      	cmp	r4, #16
 800d172:	dd1b      	ble.n	800d1ac <_svfiprintf_r+0x790>
 800d174:	3301      	adds	r3, #1
 800d176:	6035      	str	r5, [r6, #0]
 800d178:	f8c6 8004 	str.w	r8, [r6, #4]
 800d17c:	3210      	adds	r2, #16
 800d17e:	3608      	adds	r6, #8
 800d180:	2b07      	cmp	r3, #7
 800d182:	9327      	str	r3, [sp, #156]	; 0x9c
 800d184:	f106 0c08 	add.w	ip, r6, #8
 800d188:	9228      	str	r2, [sp, #160]	; 0xa0
 800d18a:	ddf0      	ble.n	800d16e <_svfiprintf_r+0x752>
 800d18c:	4649      	mov	r1, r9
 800d18e:	4658      	mov	r0, fp
 800d190:	aa26      	add	r2, sp, #152	; 0x98
 800d192:	ae0c      	add	r6, sp, #48	; 0x30
 800d194:	f7ff fbbe 	bl	800c914 <__ssprint_r>
 800d198:	a90c      	add	r1, sp, #48	; 0x30
 800d19a:	f101 0c08 	add.w	ip, r1, #8
 800d19e:	2800      	cmp	r0, #0
 800d1a0:	d1c8      	bne.n	800d134 <_svfiprintf_r+0x718>
 800d1a2:	3c10      	subs	r4, #16
 800d1a4:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800d1a6:	2c10      	cmp	r4, #16
 800d1a8:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800d1aa:	dce3      	bgt.n	800d174 <_svfiprintf_r+0x758>
 800d1ac:	3301      	adds	r3, #1
 800d1ae:	6035      	str	r5, [r6, #0]
 800d1b0:	2b07      	cmp	r3, #7
 800d1b2:	6074      	str	r4, [r6, #4]
 800d1b4:	4422      	add	r2, r4
 800d1b6:	9327      	str	r3, [sp, #156]	; 0x9c
 800d1b8:	9228      	str	r2, [sp, #160]	; 0xa0
 800d1ba:	bfdc      	itt	le
 800d1bc:	f10c 0108 	addle.w	r1, ip, #8
 800d1c0:	4666      	movle	r6, ip
 800d1c2:	f77f af11 	ble.w	800cfe8 <_svfiprintf_r+0x5cc>
 800d1c6:	4658      	mov	r0, fp
 800d1c8:	4649      	mov	r1, r9
 800d1ca:	aa26      	add	r2, sp, #152	; 0x98
 800d1cc:	f7ff fba2 	bl	800c914 <__ssprint_r>
 800d1d0:	2800      	cmp	r0, #0
 800d1d2:	d1af      	bne.n	800d134 <_svfiprintf_r+0x718>
 800d1d4:	ab0c      	add	r3, sp, #48	; 0x30
 800d1d6:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800d1d8:	f103 0108 	add.w	r1, r3, #8
 800d1dc:	ae0c      	add	r6, sp, #48	; 0x30
 800d1de:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800d1e0:	e702      	b.n	800cfe8 <_svfiprintf_r+0x5cc>
 800d1e2:	4658      	mov	r0, fp
 800d1e4:	4649      	mov	r1, r9
 800d1e6:	aa26      	add	r2, sp, #152	; 0x98
 800d1e8:	f7ff fb94 	bl	800c914 <__ssprint_r>
 800d1ec:	2800      	cmp	r0, #0
 800d1ee:	d1a1      	bne.n	800d134 <_svfiprintf_r+0x718>
 800d1f0:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800d1f2:	a90c      	add	r1, sp, #48	; 0x30
 800d1f4:	e747      	b.n	800d086 <_svfiprintf_r+0x66a>
 800d1f6:	4658      	mov	r0, fp
 800d1f8:	4649      	mov	r1, r9
 800d1fa:	aa26      	add	r2, sp, #152	; 0x98
 800d1fc:	f7ff fb8a 	bl	800c914 <__ssprint_r>
 800d200:	2800      	cmp	r0, #0
 800d202:	f43f af7e 	beq.w	800d102 <_svfiprintf_r+0x6e6>
 800d206:	e795      	b.n	800d134 <_svfiprintf_r+0x718>
 800d208:	ab26      	add	r3, sp, #152	; 0x98
 800d20a:	9203      	str	r2, [sp, #12]
 800d20c:	9309      	str	r3, [sp, #36]	; 0x24
 800d20e:	e50d      	b.n	800cc2c <_svfiprintf_r+0x210>
 800d210:	4658      	mov	r0, fp
 800d212:	4649      	mov	r1, r9
 800d214:	aa26      	add	r2, sp, #152	; 0x98
 800d216:	f7ff fb7d 	bl	800c914 <__ssprint_r>
 800d21a:	2800      	cmp	r0, #0
 800d21c:	d18a      	bne.n	800d134 <_svfiprintf_r+0x718>
 800d21e:	ae0c      	add	r6, sp, #48	; 0x30
 800d220:	e43b      	b.n	800ca9a <_svfiprintf_r+0x7e>
 800d222:	4658      	mov	r0, fp
 800d224:	4649      	mov	r1, r9
 800d226:	aa26      	add	r2, sp, #152	; 0x98
 800d228:	f7ff fb74 	bl	800c914 <__ssprint_r>
 800d22c:	2800      	cmp	r0, #0
 800d22e:	d181      	bne.n	800d134 <_svfiprintf_r+0x718>
 800d230:	ad0c      	add	r5, sp, #48	; 0x30
 800d232:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800d234:	f105 0108 	add.w	r1, r5, #8
 800d238:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800d23a:	462e      	mov	r6, r5
 800d23c:	e6c1      	b.n	800cfc2 <_svfiprintf_r+0x5a6>
 800d23e:	bf00      	nop
 800d240:	08010358 	.word	0x08010358
 800d244:	4658      	mov	r0, fp
 800d246:	4649      	mov	r1, r9
 800d248:	aa26      	add	r2, sp, #152	; 0x98
 800d24a:	f7ff fb63 	bl	800c914 <__ssprint_r>
 800d24e:	2800      	cmp	r0, #0
 800d250:	f47f af70 	bne.w	800d134 <_svfiprintf_r+0x718>
 800d254:	ab0c      	add	r3, sp, #48	; 0x30
 800d256:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800d258:	f103 0108 	add.w	r1, r3, #8
 800d25c:	ae0c      	add	r6, sp, #48	; 0x30
 800d25e:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800d260:	e6be      	b.n	800cfe0 <_svfiprintf_r+0x5c4>
 800d262:	2c0a      	cmp	r4, #10
 800d264:	f175 0300 	sbcs.w	r3, r5, #0
 800d268:	f0c0 8086 	bcc.w	800d378 <_svfiprintf_r+0x95c>
 800d26c:	a91c      	add	r1, sp, #112	; 0x70
 800d26e:	9703      	str	r7, [sp, #12]
 800d270:	f101 0327 	add.w	r3, r1, #39	; 0x27
 800d274:	9102      	str	r1, [sp, #8]
 800d276:	461f      	mov	r7, r3
 800d278:	9607      	str	r6, [sp, #28]
 800d27a:	4620      	mov	r0, r4
 800d27c:	4629      	mov	r1, r5
 800d27e:	220a      	movs	r2, #10
 800d280:	2300      	movs	r3, #0
 800d282:	f002 faad 	bl	800f7e0 <__aeabi_uldivmod>
 800d286:	463e      	mov	r6, r7
 800d288:	4620      	mov	r0, r4
 800d28a:	4629      	mov	r1, r5
 800d28c:	2300      	movs	r3, #0
 800d28e:	3f01      	subs	r7, #1
 800d290:	f102 0430 	add.w	r4, r2, #48	; 0x30
 800d294:	220a      	movs	r2, #10
 800d296:	7034      	strb	r4, [r6, #0]
 800d298:	f002 faa2 	bl	800f7e0 <__aeabi_uldivmod>
 800d29c:	4604      	mov	r4, r0
 800d29e:	460d      	mov	r5, r1
 800d2a0:	ea54 0205 	orrs.w	r2, r4, r5
 800d2a4:	d1e9      	bne.n	800d27a <_svfiprintf_r+0x85e>
 800d2a6:	9609      	str	r6, [sp, #36]	; 0x24
 800d2a8:	9f03      	ldr	r7, [sp, #12]
 800d2aa:	9e07      	ldr	r6, [sp, #28]
 800d2ac:	e01a      	b.n	800d2e4 <_svfiprintf_r+0x8c8>
 800d2ae:	ad26      	add	r5, sp, #152	; 0x98
 800d2b0:	9303      	str	r3, [sp, #12]
 800d2b2:	9509      	str	r5, [sp, #36]	; 0x24
 800d2b4:	e4ba      	b.n	800cc2c <_svfiprintf_r+0x210>
 800d2b6:	a91c      	add	r1, sp, #112	; 0x70
 800d2b8:	f8dd c020 	ldr.w	ip, [sp, #32]
 800d2bc:	f101 0027 	add.w	r0, r1, #39	; 0x27
 800d2c0:	9102      	str	r1, [sp, #8]
 800d2c2:	f004 020f 	and.w	r2, r4, #15
 800d2c6:	0923      	lsrs	r3, r4, #4
 800d2c8:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 800d2cc:	0929      	lsrs	r1, r5, #4
 800d2ce:	f81c 2002 	ldrb.w	r2, [ip, r2]
 800d2d2:	461c      	mov	r4, r3
 800d2d4:	4603      	mov	r3, r0
 800d2d6:	460d      	mov	r5, r1
 800d2d8:	3801      	subs	r0, #1
 800d2da:	701a      	strb	r2, [r3, #0]
 800d2dc:	ea54 0205 	orrs.w	r2, r4, r5
 800d2e0:	d1ef      	bne.n	800d2c2 <_svfiprintf_r+0x8a6>
 800d2e2:	9309      	str	r3, [sp, #36]	; 0x24
 800d2e4:	9d02      	ldr	r5, [sp, #8]
 800d2e6:	9809      	ldr	r0, [sp, #36]	; 0x24
 800d2e8:	f105 0328 	add.w	r3, r5, #40	; 0x28
 800d2ec:	1a1b      	subs	r3, r3, r0
 800d2ee:	9303      	str	r3, [sp, #12]
 800d2f0:	e49c      	b.n	800cc2c <_svfiprintf_r+0x210>
 800d2f2:	f01a 0f10 	tst.w	sl, #16
 800d2f6:	d168      	bne.n	800d3ca <_svfiprintf_r+0x9ae>
 800d2f8:	f01a 0f40 	tst.w	sl, #64	; 0x40
 800d2fc:	f000 8096 	beq.w	800d42c <_svfiprintf_r+0xa10>
 800d300:	9b06      	ldr	r3, [sp, #24]
 800d302:	f9b3 4000 	ldrsh.w	r4, [r3]
 800d306:	3304      	adds	r3, #4
 800d308:	9306      	str	r3, [sp, #24]
 800d30a:	17e5      	asrs	r5, r4, #31
 800d30c:	e4b7      	b.n	800cc7e <_svfiprintf_r+0x262>
 800d30e:	f01a 0f10 	tst.w	sl, #16
 800d312:	d172      	bne.n	800d3fa <_svfiprintf_r+0x9de>
 800d314:	f01a 0f40 	tst.w	sl, #64	; 0x40
 800d318:	f000 809f 	beq.w	800d45a <_svfiprintf_r+0xa3e>
 800d31c:	9b06      	ldr	r3, [sp, #24]
 800d31e:	881a      	ldrh	r2, [r3, #0]
 800d320:	2301      	movs	r3, #1
 800d322:	e009      	b.n	800d338 <_svfiprintf_r+0x91c>
 800d324:	f01a 0110 	ands.w	r1, sl, #16
 800d328:	d141      	bne.n	800d3ae <_svfiprintf_r+0x992>
 800d32a:	f01a 0340 	ands.w	r3, sl, #64	; 0x40
 800d32e:	f000 8083 	beq.w	800d438 <_svfiprintf_r+0xa1c>
 800d332:	9b06      	ldr	r3, [sp, #24]
 800d334:	881a      	ldrh	r2, [r3, #0]
 800d336:	460b      	mov	r3, r1
 800d338:	9d06      	ldr	r5, [sp, #24]
 800d33a:	4614      	mov	r4, r2
 800d33c:	3504      	adds	r5, #4
 800d33e:	9506      	str	r5, [sp, #24]
 800d340:	2500      	movs	r5, #0
 800d342:	3a00      	subs	r2, #0
 800d344:	bf18      	it	ne
 800d346:	2201      	movne	r2, #1
 800d348:	e431      	b.n	800cbae <_svfiprintf_r+0x192>
 800d34a:	2302      	movs	r3, #2
 800d34c:	e42f      	b.n	800cbae <_svfiprintf_r+0x192>
 800d34e:	783b      	ldrb	r3, [r7, #0]
 800d350:	9206      	str	r2, [sp, #24]
 800d352:	f7ff bbb6 	b.w	800cac2 <_svfiprintf_r+0xa6>
 800d356:	4658      	mov	r0, fp
 800d358:	4649      	mov	r1, r9
 800d35a:	aa26      	add	r2, sp, #152	; 0x98
 800d35c:	f7ff fada 	bl	800c914 <__ssprint_r>
 800d360:	2800      	cmp	r0, #0
 800d362:	f47f aee7 	bne.w	800d134 <_svfiprintf_r+0x718>
 800d366:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800d368:	e6c1      	b.n	800d0ee <_svfiprintf_r+0x6d2>
 800d36a:	9902      	ldr	r1, [sp, #8]
 800d36c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800d36e:	f101 0328 	add.w	r3, r1, #40	; 0x28
 800d372:	1a9b      	subs	r3, r3, r2
 800d374:	9303      	str	r3, [sp, #12]
 800d376:	e459      	b.n	800cc2c <_svfiprintf_r+0x210>
 800d378:	3430      	adds	r4, #48	; 0x30
 800d37a:	2501      	movs	r5, #1
 800d37c:	f10d 0097 	add.w	r0, sp, #151	; 0x97
 800d380:	9503      	str	r5, [sp, #12]
 800d382:	f88d 4097 	strb.w	r4, [sp, #151]	; 0x97
 800d386:	9009      	str	r0, [sp, #36]	; 0x24
 800d388:	e450      	b.n	800cc2c <_svfiprintf_r+0x210>
 800d38a:	9b06      	ldr	r3, [sp, #24]
 800d38c:	9d05      	ldr	r5, [sp, #20]
 800d38e:	9806      	ldr	r0, [sp, #24]
 800d390:	6819      	ldr	r1, [r3, #0]
 800d392:	462a      	mov	r2, r5
 800d394:	17eb      	asrs	r3, r5, #31
 800d396:	3004      	adds	r0, #4
 800d398:	9006      	str	r0, [sp, #24]
 800d39a:	e9c1 2300 	strd	r2, r3, [r1]
 800d39e:	f7ff bb53 	b.w	800ca48 <_svfiprintf_r+0x2c>
 800d3a2:	9906      	ldr	r1, [sp, #24]
 800d3a4:	2500      	movs	r5, #0
 800d3a6:	680c      	ldr	r4, [r1, #0]
 800d3a8:	3104      	adds	r1, #4
 800d3aa:	9106      	str	r1, [sp, #24]
 800d3ac:	e510      	b.n	800cdd0 <_svfiprintf_r+0x3b4>
 800d3ae:	9906      	ldr	r1, [sp, #24]
 800d3b0:	680a      	ldr	r2, [r1, #0]
 800d3b2:	3104      	adds	r1, #4
 800d3b4:	4614      	mov	r4, r2
 800d3b6:	2500      	movs	r5, #0
 800d3b8:	3a00      	subs	r2, #0
 800d3ba:	9106      	str	r1, [sp, #24]
 800d3bc:	bf18      	it	ne
 800d3be:	2201      	movne	r2, #1
 800d3c0:	f7ff bbf5 	b.w	800cbae <_svfiprintf_r+0x192>
 800d3c4:	783b      	ldrb	r3, [r7, #0]
 800d3c6:	f7ff bb7c 	b.w	800cac2 <_svfiprintf_r+0xa6>
 800d3ca:	9a06      	ldr	r2, [sp, #24]
 800d3cc:	6814      	ldr	r4, [r2, #0]
 800d3ce:	3204      	adds	r2, #4
 800d3d0:	9206      	str	r2, [sp, #24]
 800d3d2:	17e5      	asrs	r5, r4, #31
 800d3d4:	2c00      	cmp	r4, #0
 800d3d6:	f175 0000 	sbcs.w	r0, r5, #0
 800d3da:	f6bf ac55 	bge.w	800cc88 <_svfiprintf_r+0x26c>
 800d3de:	4264      	negs	r4, r4
 800d3e0:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 800d3e4:	232d      	movs	r3, #45	; 0x2d
 800d3e6:	ea54 0205 	orrs.w	r2, r4, r5
 800d3ea:	f88d 30a7 	strb.w	r3, [sp, #167]	; 0xa7
 800d3ee:	bf0c      	ite	eq
 800d3f0:	2200      	moveq	r2, #0
 800d3f2:	2201      	movne	r2, #1
 800d3f4:	2301      	movs	r3, #1
 800d3f6:	f7ff bbdd 	b.w	800cbb4 <_svfiprintf_r+0x198>
 800d3fa:	9906      	ldr	r1, [sp, #24]
 800d3fc:	2301      	movs	r3, #1
 800d3fe:	680a      	ldr	r2, [r1, #0]
 800d400:	e7d7      	b.n	800d3b2 <_svfiprintf_r+0x996>
 800d402:	9809      	ldr	r0, [sp, #36]	; 0x24
 800d404:	2100      	movs	r1, #0
 800d406:	9107      	str	r1, [sp, #28]
 800d408:	f7ff fa54 	bl	800c8b4 <strlen>
 800d40c:	9003      	str	r0, [sp, #12]
 800d40e:	e40f      	b.n	800cc30 <_svfiprintf_r+0x214>
 800d410:	9906      	ldr	r1, [sp, #24]
 800d412:	9a05      	ldr	r2, [sp, #20]
 800d414:	680b      	ldr	r3, [r1, #0]
 800d416:	3104      	adds	r1, #4
 800d418:	9106      	str	r1, [sp, #24]
 800d41a:	601a      	str	r2, [r3, #0]
 800d41c:	f7ff bb14 	b.w	800ca48 <_svfiprintf_r+0x2c>
 800d420:	4d35      	ldr	r5, [pc, #212]	; (800d4f8 <_svfiprintf_r+0xadc>)
 800d422:	468c      	mov	ip, r1
 800d424:	e60b      	b.n	800d03e <_svfiprintf_r+0x622>
 800d426:	2300      	movs	r3, #0
 800d428:	9307      	str	r3, [sp, #28]
 800d42a:	e401      	b.n	800cc30 <_svfiprintf_r+0x214>
 800d42c:	9d06      	ldr	r5, [sp, #24]
 800d42e:	682c      	ldr	r4, [r5, #0]
 800d430:	3504      	adds	r5, #4
 800d432:	9506      	str	r5, [sp, #24]
 800d434:	17e5      	asrs	r5, r4, #31
 800d436:	e422      	b.n	800cc7e <_svfiprintf_r+0x262>
 800d438:	9806      	ldr	r0, [sp, #24]
 800d43a:	6802      	ldr	r2, [r0, #0]
 800d43c:	3004      	adds	r0, #4
 800d43e:	4614      	mov	r4, r2
 800d440:	2500      	movs	r5, #0
 800d442:	3a00      	subs	r2, #0
 800d444:	9006      	str	r0, [sp, #24]
 800d446:	bf18      	it	ne
 800d448:	2201      	movne	r2, #1
 800d44a:	f7ff bbb0 	b.w	800cbae <_svfiprintf_r+0x192>
 800d44e:	9d06      	ldr	r5, [sp, #24]
 800d450:	682c      	ldr	r4, [r5, #0]
 800d452:	3504      	adds	r5, #4
 800d454:	9506      	str	r5, [sp, #24]
 800d456:	2500      	movs	r5, #0
 800d458:	e4ba      	b.n	800cdd0 <_svfiprintf_r+0x3b4>
 800d45a:	9806      	ldr	r0, [sp, #24]
 800d45c:	2301      	movs	r3, #1
 800d45e:	6802      	ldr	r2, [r0, #0]
 800d460:	e7ec      	b.n	800d43c <_svfiprintf_r+0xa20>
 800d462:	2140      	movs	r1, #64	; 0x40
 800d464:	9201      	str	r2, [sp, #4]
 800d466:	f7f9 f87b 	bl	8006560 <_malloc_r>
 800d46a:	9a01      	ldr	r2, [sp, #4]
 800d46c:	f8c9 0000 	str.w	r0, [r9]
 800d470:	f8c9 0010 	str.w	r0, [r9, #16]
 800d474:	2800      	cmp	r0, #0
 800d476:	d038      	beq.n	800d4ea <_svfiprintf_r+0xace>
 800d478:	2340      	movs	r3, #64	; 0x40
 800d47a:	f8c9 3014 	str.w	r3, [r9, #20]
 800d47e:	f7ff badb 	b.w	800ca38 <_svfiprintf_r+0x1c>
 800d482:	f240 3548 	movw	r5, #840	; 0x348
 800d486:	f106 0c08 	add.w	ip, r6, #8
 800d48a:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800d48c:	f6c0 0501 	movt	r5, #2049	; 0x801
 800d490:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800d492:	e4fe      	b.n	800ce92 <_svfiprintf_r+0x476>
 800d494:	f240 3548 	movw	r5, #840	; 0x348
 800d498:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800d49a:	f6c0 0501 	movt	r5, #2049	; 0x801
 800d49e:	e61d      	b.n	800d0dc <_svfiprintf_r+0x6c0>
 800d4a0:	f1b8 0f06 	cmp.w	r8, #6
 800d4a4:	bf34      	ite	cc
 800d4a6:	4641      	movcc	r1, r8
 800d4a8:	2106      	movcs	r1, #6
 800d4aa:	f240 42ac 	movw	r2, #1196	; 0x4ac
 800d4ae:	ea21 73e1 	bic.w	r3, r1, r1, asr #31
 800d4b2:	f6c0 0201 	movt	r2, #2049	; 0x801
 800d4b6:	9103      	str	r1, [sp, #12]
 800d4b8:	9302      	str	r3, [sp, #8]
 800d4ba:	9209      	str	r2, [sp, #36]	; 0x24
 800d4bc:	e4a9      	b.n	800ce12 <_svfiprintf_r+0x3f6>
 800d4be:	4d0e      	ldr	r5, [pc, #56]	; (800d4f8 <_svfiprintf_r+0xadc>)
 800d4c0:	468c      	mov	ip, r1
 800d4c2:	e673      	b.n	800d1ac <_svfiprintf_r+0x790>
 800d4c4:	f8cd 800c 	str.w	r8, [sp, #12]
 800d4c8:	9007      	str	r0, [sp, #28]
 800d4ca:	f7ff bbb1 	b.w	800cc30 <_svfiprintf_r+0x214>
 800d4ce:	9d06      	ldr	r5, [sp, #24]
 800d4d0:	1d2a      	adds	r2, r5, #4
 800d4d2:	f8d5 8000 	ldr.w	r8, [r5]
 800d4d6:	f1b8 0f00 	cmp.w	r8, #0
 800d4da:	f6bf af38 	bge.w	800d34e <_svfiprintf_r+0x932>
 800d4de:	783b      	ldrb	r3, [r7, #0]
 800d4e0:	f04f 38ff 	mov.w	r8, #4294967295
 800d4e4:	9206      	str	r2, [sp, #24]
 800d4e6:	f7ff baec 	b.w	800cac2 <_svfiprintf_r+0xa6>
 800d4ea:	3801      	subs	r0, #1
 800d4ec:	230c      	movs	r3, #12
 800d4ee:	9005      	str	r0, [sp, #20]
 800d4f0:	f8cb 3000 	str.w	r3, [fp]
 800d4f4:	e627      	b.n	800d146 <_svfiprintf_r+0x72a>
 800d4f6:	bf00      	nop
 800d4f8:	08010358 	.word	0x08010358

0800d4fc <__sprint_r>:
 800d4fc:	6893      	ldr	r3, [r2, #8]
 800d4fe:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800d502:	4691      	mov	r9, r2
 800d504:	4680      	mov	r8, r0
 800d506:	460f      	mov	r7, r1
 800d508:	b36b      	cbz	r3, 800d566 <__sprint_r+0x6a>
 800d50a:	6e4c      	ldr	r4, [r1, #100]	; 0x64
 800d50c:	f414 5f00 	tst.w	r4, #8192	; 0x2000
 800d510:	d02d      	beq.n	800d56e <__sprint_r+0x72>
 800d512:	6812      	ldr	r2, [r2, #0]
 800d514:	f102 0a08 	add.w	sl, r2, #8
 800d518:	f85a 6c04 	ldr.w	r6, [sl, #-4]
 800d51c:	f85a 5c08 	ldr.w	r5, [sl, #-8]
 800d520:	08b6      	lsrs	r6, r6, #2
 800d522:	b1b6      	cbz	r6, 800d552 <__sprint_r+0x56>
 800d524:	2400      	movs	r4, #0
 800d526:	e001      	b.n	800d52c <__sprint_r+0x30>
 800d528:	42a6      	cmp	r6, r4
 800d52a:	d010      	beq.n	800d54e <__sprint_r+0x52>
 800d52c:	4640      	mov	r0, r8
 800d52e:	f855 1b04 	ldr.w	r1, [r5], #4
 800d532:	463a      	mov	r2, r7
 800d534:	3401      	adds	r4, #1
 800d536:	f000 ff63 	bl	800e400 <_fputwc_r>
 800d53a:	f1b0 3fff 	cmp.w	r0, #4294967295
 800d53e:	d1f3      	bne.n	800d528 <__sprint_r+0x2c>
 800d540:	2300      	movs	r3, #0
 800d542:	f8c9 3008 	str.w	r3, [r9, #8]
 800d546:	f8c9 3004 	str.w	r3, [r9, #4]
 800d54a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800d54e:	f8d9 3008 	ldr.w	r3, [r9, #8]
 800d552:	eba3 0386 	sub.w	r3, r3, r6, lsl #2
 800d556:	f10a 0a08 	add.w	sl, sl, #8
 800d55a:	f8c9 3008 	str.w	r3, [r9, #8]
 800d55e:	2b00      	cmp	r3, #0
 800d560:	d1da      	bne.n	800d518 <__sprint_r+0x1c>
 800d562:	4618      	mov	r0, r3
 800d564:	e7ec      	b.n	800d540 <__sprint_r+0x44>
 800d566:	6053      	str	r3, [r2, #4]
 800d568:	4618      	mov	r0, r3
 800d56a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800d56e:	f000 fffd 	bl	800e56c <__sfvwrite_r>
 800d572:	2300      	movs	r3, #0
 800d574:	f8c9 3008 	str.w	r3, [r9, #8]
 800d578:	f8c9 3004 	str.w	r3, [r9, #4]
 800d57c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0800d580 <_vfiprintf_r>:
 800d580:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d584:	f5ad 6da2 	sub.w	sp, sp, #1296	; 0x510
 800d588:	b081      	sub	sp, #4
 800d58a:	4689      	mov	r9, r1
 800d58c:	4692      	mov	sl, r2
 800d58e:	9306      	str	r3, [sp, #24]
 800d590:	9001      	str	r0, [sp, #4]
 800d592:	b118      	cbz	r0, 800d59c <_vfiprintf_r+0x1c>
 800d594:	6983      	ldr	r3, [r0, #24]
 800d596:	2b00      	cmp	r3, #0
 800d598:	f000 84fb 	beq.w	800df92 <_vfiprintf_r+0xa12>
 800d59c:	f240 13c0 	movw	r3, #448	; 0x1c0
 800d5a0:	f6c0 0301 	movt	r3, #2049	; 0x801
 800d5a4:	4599      	cmp	r9, r3
 800d5a6:	f000 84fd 	beq.w	800dfa4 <_vfiprintf_r+0xa24>
 800d5aa:	f240 13e0 	movw	r3, #480	; 0x1e0
 800d5ae:	f6c0 0301 	movt	r3, #2049	; 0x801
 800d5b2:	4599      	cmp	r9, r3
 800d5b4:	f000 85df 	beq.w	800e176 <_vfiprintf_r+0xbf6>
 800d5b8:	f240 2300 	movw	r3, #512	; 0x200
 800d5bc:	f6c0 0301 	movt	r3, #2049	; 0x801
 800d5c0:	4599      	cmp	r9, r3
 800d5c2:	bf04      	itt	eq
 800d5c4:	9a01      	ldreq	r2, [sp, #4]
 800d5c6:	f8d2 900c 	ldreq.w	r9, [r2, #12]
 800d5ca:	f8b9 400c 	ldrh.w	r4, [r9, #12]
 800d5ce:	b2a3      	uxth	r3, r4
 800d5d0:	f413 5f00 	tst.w	r3, #8192	; 0x2000
 800d5d4:	d10a      	bne.n	800d5ec <_vfiprintf_r+0x6c>
 800d5d6:	f444 5400 	orr.w	r4, r4, #8192	; 0x2000
 800d5da:	f8d9 2064 	ldr.w	r2, [r9, #100]	; 0x64
 800d5de:	f8a9 400c 	strh.w	r4, [r9, #12]
 800d5e2:	b2a3      	uxth	r3, r4
 800d5e4:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800d5e8:	f8c9 2064 	str.w	r2, [r9, #100]	; 0x64
 800d5ec:	f013 0f08 	tst.w	r3, #8
 800d5f0:	f000 862d 	beq.w	800e24e <_vfiprintf_r+0xcce>
 800d5f4:	f8d9 2010 	ldr.w	r2, [r9, #16]
 800d5f8:	2a00      	cmp	r2, #0
 800d5fa:	f000 8628 	beq.w	800e24e <_vfiprintf_r+0xcce>
 800d5fe:	f003 031a 	and.w	r3, r3, #26
 800d602:	2b0a      	cmp	r3, #10
 800d604:	f000 847d 	beq.w	800df02 <_vfiprintf_r+0x982>
 800d608:	f50d 6793 	add.w	r7, sp, #1176	; 0x498
 800d60c:	2300      	movs	r3, #0
 800d60e:	463e      	mov	r6, r7
 800d610:	9308      	str	r3, [sp, #32]
 800d612:	9305      	str	r3, [sp, #20]
 800d614:	f8cd 7500 	str.w	r7, [sp, #1280]	; 0x500
 800d618:	f8cd 3508 	str.w	r3, [sp, #1288]	; 0x508
 800d61c:	f8cd 3504 	str.w	r3, [sp, #1284]	; 0x504
 800d620:	f89a 3000 	ldrb.w	r3, [sl]
 800d624:	f1b3 0225 	subs.w	r2, r3, #37	; 0x25
 800d628:	bf18      	it	ne
 800d62a:	2201      	movne	r2, #1
 800d62c:	2b00      	cmp	r3, #0
 800d62e:	bf0c      	ite	eq
 800d630:	2300      	moveq	r3, #0
 800d632:	f002 0301 	andne.w	r3, r2, #1
 800d636:	2b00      	cmp	r3, #0
 800d638:	f000 83ac 	beq.w	800dd94 <_vfiprintf_r+0x814>
 800d63c:	f10a 0201 	add.w	r2, sl, #1
 800d640:	4614      	mov	r4, r2
 800d642:	3201      	adds	r2, #1
 800d644:	7823      	ldrb	r3, [r4, #0]
 800d646:	1e19      	subs	r1, r3, #0
 800d648:	bf18      	it	ne
 800d64a:	2101      	movne	r1, #1
 800d64c:	2b25      	cmp	r3, #37	; 0x25
 800d64e:	bf0c      	ite	eq
 800d650:	2300      	moveq	r3, #0
 800d652:	f001 0301 	andne.w	r3, r1, #1
 800d656:	2b00      	cmp	r3, #0
 800d658:	d1f2      	bne.n	800d640 <_vfiprintf_r+0xc0>
 800d65a:	ebb4 050a 	subs.w	r5, r4, sl
 800d65e:	d013      	beq.n	800d688 <_vfiprintf_r+0x108>
 800d660:	f8dd 2504 	ldr.w	r2, [sp, #1284]	; 0x504
 800d664:	f8dd 1508 	ldr.w	r1, [sp, #1288]	; 0x508
 800d668:	3201      	adds	r2, #1
 800d66a:	f8c6 a000 	str.w	sl, [r6]
 800d66e:	2a07      	cmp	r2, #7
 800d670:	6075      	str	r5, [r6, #4]
 800d672:	4429      	add	r1, r5
 800d674:	f8cd 2504 	str.w	r2, [sp, #1284]	; 0x504
 800d678:	f8cd 1508 	str.w	r1, [sp, #1288]	; 0x508
 800d67c:	f300 8411 	bgt.w	800dea2 <_vfiprintf_r+0x922>
 800d680:	3608      	adds	r6, #8
 800d682:	9805      	ldr	r0, [sp, #20]
 800d684:	1940      	adds	r0, r0, r5
 800d686:	9005      	str	r0, [sp, #20]
 800d688:	7823      	ldrb	r3, [r4, #0]
 800d68a:	2b00      	cmp	r3, #0
 800d68c:	f000 8384 	beq.w	800dd98 <_vfiprintf_r+0x818>
 800d690:	2100      	movs	r1, #0
 800d692:	2200      	movs	r2, #0
 800d694:	9104      	str	r1, [sp, #16]
 800d696:	f104 0a01 	add.w	sl, r4, #1
 800d69a:	f88d 250f 	strb.w	r2, [sp, #1295]	; 0x50f
 800d69e:	f04f 38ff 	mov.w	r8, #4294967295
 800d6a2:	7863      	ldrb	r3, [r4, #1]
 800d6a4:	468b      	mov	fp, r1
 800d6a6:	f04f 0c20 	mov.w	ip, #32
 800d6aa:	252b      	movs	r5, #43	; 0x2b
 800d6ac:	f10a 0a01 	add.w	sl, sl, #1
 800d6b0:	f1a3 0220 	sub.w	r2, r3, #32
 800d6b4:	2a58      	cmp	r2, #88	; 0x58
 800d6b6:	f200 8256 	bhi.w	800db66 <_vfiprintf_r+0x5e6>
 800d6ba:	e8df f012 	tbh	[pc, r2, lsl #1]
 800d6be:	024a      	.short	0x024a
 800d6c0:	02540254 	.word	0x02540254
 800d6c4:	02540245 	.word	0x02540245
 800d6c8:	02540254 	.word	0x02540254
 800d6cc:	02540254 	.word	0x02540254
 800d6d0:	01100254 	.word	0x01100254
 800d6d4:	02540263 	.word	0x02540263
 800d6d8:	0268011c 	.word	0x0268011c
 800d6dc:	01900254 	.word	0x01900254
 800d6e0:	017f017f 	.word	0x017f017f
 800d6e4:	017f017f 	.word	0x017f017f
 800d6e8:	017f017f 	.word	0x017f017f
 800d6ec:	017f017f 	.word	0x017f017f
 800d6f0:	0254017f 	.word	0x0254017f
 800d6f4:	02540254 	.word	0x02540254
 800d6f8:	02540254 	.word	0x02540254
 800d6fc:	02540254 	.word	0x02540254
 800d700:	02540254 	.word	0x02540254
 800d704:	00d70254 	.word	0x00d70254
 800d708:	02540254 	.word	0x02540254
 800d70c:	02540254 	.word	0x02540254
 800d710:	02540254 	.word	0x02540254
 800d714:	02540254 	.word	0x02540254
 800d718:	02540254 	.word	0x02540254
 800d71c:	025400c1 	.word	0x025400c1
 800d720:	02540254 	.word	0x02540254
 800d724:	02540254 	.word	0x02540254
 800d728:	02540059 	.word	0x02540059
 800d72c:	01950254 	.word	0x01950254
 800d730:	02540254 	.word	0x02540254
 800d734:	02540254 	.word	0x02540254
 800d738:	02540254 	.word	0x02540254
 800d73c:	02540254 	.word	0x02540254
 800d740:	02540254 	.word	0x02540254
 800d744:	00d901ba 	.word	0x00d901ba
 800d748:	02540254 	.word	0x02540254
 800d74c:	013b0254 	.word	0x013b0254
 800d750:	025400d9 	.word	0x025400d9
 800d754:	01300254 	.word	0x01300254
 800d758:	01210254 	.word	0x01210254
 800d75c:	016700c3 	.word	0x016700c3
 800d760:	02540162 	.word	0x02540162
 800d764:	02540140 	.word	0x02540140
 800d768:	0254005b 	.word	0x0254005b
 800d76c:	022e0254 	.word	0x022e0254
 800d770:	f04b 0b10 	orr.w	fp, fp, #16
 800d774:	f01b 0f20 	tst.w	fp, #32
 800d778:	f000 846b 	beq.w	800e052 <_vfiprintf_r+0xad2>
 800d77c:	9c06      	ldr	r4, [sp, #24]
 800d77e:	2301      	movs	r3, #1
 800d780:	1de2      	adds	r2, r4, #7
 800d782:	f022 0207 	bic.w	r2, r2, #7
 800d786:	f102 0508 	add.w	r5, r2, #8
 800d78a:	9506      	str	r5, [sp, #24]
 800d78c:	e9d2 4500 	ldrd	r4, r5, [r2]
 800d790:	ea54 0005 	orrs.w	r0, r4, r5
 800d794:	bf0c      	ite	eq
 800d796:	2200      	moveq	r2, #0
 800d798:	2201      	movne	r2, #1
 800d79a:	2100      	movs	r1, #0
 800d79c:	f88d 150f 	strb.w	r1, [sp, #1295]	; 0x50f
 800d7a0:	f1b8 0f00 	cmp.w	r8, #0
 800d7a4:	bfa8      	it	ge
 800d7a6:	f02b 0b80 	bicge.w	fp, fp, #128	; 0x80
 800d7aa:	f1b8 0f00 	cmp.w	r8, #0
 800d7ae:	bf18      	it	ne
 800d7b0:	f042 0201 	orrne.w	r2, r2, #1
 800d7b4:	2a00      	cmp	r2, #0
 800d7b6:	f000 8081 	beq.w	800d8bc <_vfiprintf_r+0x33c>
 800d7ba:	2b01      	cmp	r3, #1
 800d7bc:	f000 841a 	beq.w	800dff4 <_vfiprintf_r+0xa74>
 800d7c0:	2b02      	cmp	r3, #2
 800d7c2:	f000 83f4 	beq.w	800dfae <_vfiprintf_r+0xa2e>
 800d7c6:	f50d 629b 	add.w	r2, sp, #1240	; 0x4d8
 800d7ca:	f8cd a00c 	str.w	sl, [sp, #12]
 800d7ce:	f102 0327 	add.w	r3, r2, #39	; 0x27
 800d7d2:	9202      	str	r2, [sp, #8]
 800d7d4:	08ea      	lsrs	r2, r5, #3
 800d7d6:	ea4f 0ad4 	mov.w	sl, r4, lsr #3
 800d7da:	ea4a 7a45 	orr.w	sl, sl, r5, lsl #29
 800d7de:	f004 0407 	and.w	r4, r4, #7
 800d7e2:	4611      	mov	r1, r2
 800d7e4:	f104 0230 	add.w	r2, r4, #48	; 0x30
 800d7e8:	460d      	mov	r5, r1
 800d7ea:	4654      	mov	r4, sl
 800d7ec:	469c      	mov	ip, r3
 800d7ee:	701a      	strb	r2, [r3, #0]
 800d7f0:	3b01      	subs	r3, #1
 800d7f2:	ea54 0005 	orrs.w	r0, r4, r5
 800d7f6:	d1ed      	bne.n	800d7d4 <_vfiprintf_r+0x254>
 800d7f8:	f01b 0f01 	tst.w	fp, #1
 800d7fc:	f8dd a00c 	ldr.w	sl, [sp, #12]
 800d800:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 800d804:	f000 8472 	beq.w	800e0ec <_vfiprintf_r+0xb6c>
 800d808:	2a30      	cmp	r2, #48	; 0x30
 800d80a:	f000 8511 	beq.w	800e230 <_vfiprintf_r+0xcb0>
 800d80e:	9309      	str	r3, [sp, #36]	; 0x24
 800d810:	9802      	ldr	r0, [sp, #8]
 800d812:	9909      	ldr	r1, [sp, #36]	; 0x24
 800d814:	f100 0328 	add.w	r3, r0, #40	; 0x28
 800d818:	1a5b      	subs	r3, r3, r1
 800d81a:	9303      	str	r3, [sp, #12]
 800d81c:	2330      	movs	r3, #48	; 0x30
 800d81e:	700b      	strb	r3, [r1, #0]
 800d820:	f8cd 801c 	str.w	r8, [sp, #28]
 800d824:	9c03      	ldr	r4, [sp, #12]
 800d826:	9d07      	ldr	r5, [sp, #28]
 800d828:	f89d 350f 	ldrb.w	r3, [sp, #1295]	; 0x50f
 800d82c:	42ac      	cmp	r4, r5
 800d82e:	bfb8      	it	lt
 800d830:	462c      	movlt	r4, r5
 800d832:	9402      	str	r4, [sp, #8]
 800d834:	2b00      	cmp	r3, #0
 800d836:	f000 810d 	beq.w	800da54 <_vfiprintf_r+0x4d4>
 800d83a:	3401      	adds	r4, #1
 800d83c:	9402      	str	r4, [sp, #8]
 800d83e:	e109      	b.n	800da54 <_vfiprintf_r+0x4d4>
 800d840:	f04b 0b10 	orr.w	fp, fp, #16
 800d844:	f01b 0320 	ands.w	r3, fp, #32
 800d848:	f000 841a 	beq.w	800e080 <_vfiprintf_r+0xb00>
 800d84c:	9906      	ldr	r1, [sp, #24]
 800d84e:	2300      	movs	r3, #0
 800d850:	1dca      	adds	r2, r1, #7
 800d852:	f022 0207 	bic.w	r2, r2, #7
 800d856:	f102 0408 	add.w	r4, r2, #8
 800d85a:	9406      	str	r4, [sp, #24]
 800d85c:	e9d2 4500 	ldrd	r4, r5, [r2]
 800d860:	ea54 0005 	orrs.w	r0, r4, r5
 800d864:	bf0c      	ite	eq
 800d866:	2200      	moveq	r2, #0
 800d868:	2201      	movne	r2, #1
 800d86a:	e796      	b.n	800d79a <_vfiprintf_r+0x21a>
 800d86c:	f04b 0b10 	orr.w	fp, fp, #16
 800d870:	f01b 0f20 	tst.w	fp, #32
 800d874:	f000 840f 	beq.w	800e096 <_vfiprintf_r+0xb16>
 800d878:	9c06      	ldr	r4, [sp, #24]
 800d87a:	1de3      	adds	r3, r4, #7
 800d87c:	f023 0307 	bic.w	r3, r3, #7
 800d880:	f103 0508 	add.w	r5, r3, #8
 800d884:	9506      	str	r5, [sp, #24]
 800d886:	e9d3 4500 	ldrd	r4, r5, [r3]
 800d88a:	2c00      	cmp	r4, #0
 800d88c:	f175 0300 	sbcs.w	r3, r5, #0
 800d890:	f2c0 844a 	blt.w	800e128 <_vfiprintf_r+0xba8>
 800d894:	ea54 0005 	orrs.w	r0, r4, r5
 800d898:	f04f 0301 	mov.w	r3, #1
 800d89c:	bf0c      	ite	eq
 800d89e:	2200      	moveq	r2, #0
 800d8a0:	2201      	movne	r2, #1
 800d8a2:	f1b8 0f00 	cmp.w	r8, #0
 800d8a6:	bfa8      	it	ge
 800d8a8:	f02b 0b80 	bicge.w	fp, fp, #128	; 0x80
 800d8ac:	f1b8 0f00 	cmp.w	r8, #0
 800d8b0:	bf18      	it	ne
 800d8b2:	f042 0201 	orrne.w	r2, r2, #1
 800d8b6:	2a00      	cmp	r2, #0
 800d8b8:	f47f af7f 	bne.w	800d7ba <_vfiprintf_r+0x23a>
 800d8bc:	2b00      	cmp	r3, #0
 800d8be:	f040 82eb 	bne.w	800de98 <_vfiprintf_r+0x918>
 800d8c2:	f01b 0f01 	tst.w	fp, #1
 800d8c6:	f000 8390 	beq.w	800dfea <_vfiprintf_r+0xa6a>
 800d8ca:	f50d 609e 	add.w	r0, sp, #1264	; 0x4f0
 800d8ce:	2501      	movs	r5, #1
 800d8d0:	2330      	movs	r3, #48	; 0x30
 800d8d2:	300f      	adds	r0, #15
 800d8d4:	9503      	str	r5, [sp, #12]
 800d8d6:	f88d 34ff 	strb.w	r3, [sp, #1279]	; 0x4ff
 800d8da:	9009      	str	r0, [sp, #36]	; 0x24
 800d8dc:	e7a0      	b.n	800d820 <_vfiprintf_r+0x2a0>
 800d8de:	9806      	ldr	r0, [sp, #24]
 800d8e0:	9906      	ldr	r1, [sp, #24]
 800d8e2:	6800      	ldr	r0, [r0, #0]
 800d8e4:	1d0a      	adds	r2, r1, #4
 800d8e6:	2800      	cmp	r0, #0
 800d8e8:	9004      	str	r0, [sp, #16]
 800d8ea:	f280 83e3 	bge.w	800e0b4 <_vfiprintf_r+0xb34>
 800d8ee:	9b04      	ldr	r3, [sp, #16]
 800d8f0:	9206      	str	r2, [sp, #24]
 800d8f2:	425b      	negs	r3, r3
 800d8f4:	9304      	str	r3, [sp, #16]
 800d8f6:	f04b 0b04 	orr.w	fp, fp, #4
 800d8fa:	f89a 3000 	ldrb.w	r3, [sl]
 800d8fe:	e6d5      	b.n	800d6ac <_vfiprintf_r+0x12c>
 800d900:	f01b 0f20 	tst.w	fp, #32
 800d904:	f040 83fa 	bne.w	800e0fc <_vfiprintf_r+0xb7c>
 800d908:	f01b 0f10 	tst.w	fp, #16
 800d90c:	f000 843f 	beq.w	800e18e <_vfiprintf_r+0xc0e>
 800d910:	9806      	ldr	r0, [sp, #24]
 800d912:	9905      	ldr	r1, [sp, #20]
 800d914:	6803      	ldr	r3, [r0, #0]
 800d916:	3004      	adds	r0, #4
 800d918:	9006      	str	r0, [sp, #24]
 800d91a:	6019      	str	r1, [r3, #0]
 800d91c:	e680      	b.n	800d620 <_vfiprintf_r+0xa0>
 800d91e:	f89a 3000 	ldrb.w	r3, [sl]
 800d922:	2b6c      	cmp	r3, #108	; 0x6c
 800d924:	bf0a      	itet	eq
 800d926:	f04b 0b20 	orreq.w	fp, fp, #32
 800d92a:	f04b 0b10 	orrne.w	fp, fp, #16
 800d92e:	f81a 3f01 	ldrbeq.w	r3, [sl, #1]!
 800d932:	e6bb      	b.n	800d6ac <_vfiprintf_r+0x12c>
 800d934:	f04b 0b40 	orr.w	fp, fp, #64	; 0x40
 800d938:	f89a 3000 	ldrb.w	r3, [sl]
 800d93c:	e6b6      	b.n	800d6ac <_vfiprintf_r+0x12c>
 800d93e:	9b06      	ldr	r3, [sp, #24]
 800d940:	2200      	movs	r2, #0
 800d942:	f88d 250f 	strb.w	r2, [sp, #1295]	; 0x50f
 800d946:	1d1c      	adds	r4, r3, #4
 800d948:	9406      	str	r4, [sp, #24]
 800d94a:	681b      	ldr	r3, [r3, #0]
 800d94c:	9309      	str	r3, [sp, #36]	; 0x24
 800d94e:	2b00      	cmp	r3, #0
 800d950:	f000 844c 	beq.w	800e1ec <_vfiprintf_r+0xc6c>
 800d954:	f1b8 0f00 	cmp.w	r8, #0
 800d958:	f2c0 8440 	blt.w	800e1dc <_vfiprintf_r+0xc5c>
 800d95c:	9809      	ldr	r0, [sp, #36]	; 0x24
 800d95e:	2100      	movs	r1, #0
 800d960:	4642      	mov	r2, r8
 800d962:	f7fe f887 	bl	800ba74 <memchr>
 800d966:	2800      	cmp	r0, #0
 800d968:	f000 847e 	beq.w	800e268 <_vfiprintf_r+0xce8>
 800d96c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800d96e:	1a80      	subs	r0, r0, r2
 800d970:	9003      	str	r0, [sp, #12]
 800d972:	4540      	cmp	r0, r8
 800d974:	f340 8407 	ble.w	800e186 <_vfiprintf_r+0xc06>
 800d978:	2200      	movs	r2, #0
 800d97a:	f8cd 800c 	str.w	r8, [sp, #12]
 800d97e:	9207      	str	r2, [sp, #28]
 800d980:	e750      	b.n	800d824 <_vfiprintf_r+0x2a4>
 800d982:	f04b 0b20 	orr.w	fp, fp, #32
 800d986:	f89a 3000 	ldrb.w	r3, [sl]
 800d98a:	e68f      	b.n	800d6ac <_vfiprintf_r+0x12c>
 800d98c:	9b06      	ldr	r3, [sp, #24]
 800d98e:	f240 4098 	movw	r0, #1176	; 0x498
 800d992:	2500      	movs	r5, #0
 800d994:	f6c0 0001 	movt	r0, #2049	; 0x801
 800d998:	1d19      	adds	r1, r3, #4
 800d99a:	f04b 0b02 	orr.w	fp, fp, #2
 800d99e:	681a      	ldr	r2, [r3, #0]
 800d9a0:	2330      	movs	r3, #48	; 0x30
 800d9a2:	f88d 350c 	strb.w	r3, [sp, #1292]	; 0x50c
 800d9a6:	2378      	movs	r3, #120	; 0x78
 800d9a8:	4614      	mov	r4, r2
 800d9aa:	3a00      	subs	r2, #0
 800d9ac:	f88d 350d 	strb.w	r3, [sp, #1293]	; 0x50d
 800d9b0:	bf18      	it	ne
 800d9b2:	2201      	movne	r2, #1
 800d9b4:	9106      	str	r1, [sp, #24]
 800d9b6:	2302      	movs	r3, #2
 800d9b8:	9008      	str	r0, [sp, #32]
 800d9ba:	e6ee      	b.n	800d79a <_vfiprintf_r+0x21a>
 800d9bc:	4651      	mov	r1, sl
 800d9be:	2200      	movs	r2, #0
 800d9c0:	f1a3 0430 	sub.w	r4, r3, #48	; 0x30
 800d9c4:	f811 3b01 	ldrb.w	r3, [r1], #1
 800d9c8:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800d9cc:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 800d9d0:	468a      	mov	sl, r1
 800d9d2:	2809      	cmp	r0, #9
 800d9d4:	eb04 0242 	add.w	r2, r4, r2, lsl #1
 800d9d8:	d9f2      	bls.n	800d9c0 <_vfiprintf_r+0x440>
 800d9da:	9204      	str	r2, [sp, #16]
 800d9dc:	e668      	b.n	800d6b0 <_vfiprintf_r+0x130>
 800d9de:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
 800d9e2:	f89a 3000 	ldrb.w	r3, [sl]
 800d9e6:	e661      	b.n	800d6ac <_vfiprintf_r+0x12c>
 800d9e8:	f01b 0f20 	tst.w	fp, #32
 800d9ec:	f240 4184 	movw	r1, #1156	; 0x484
 800d9f0:	f6c0 0101 	movt	r1, #2049	; 0x801
 800d9f4:	9108      	str	r1, [sp, #32]
 800d9f6:	f000 8099 	beq.w	800db2c <_vfiprintf_r+0x5ac>
 800d9fa:	9c06      	ldr	r4, [sp, #24]
 800d9fc:	1de2      	adds	r2, r4, #7
 800d9fe:	f022 0207 	bic.w	r2, r2, #7
 800da02:	f102 0508 	add.w	r5, r2, #8
 800da06:	9506      	str	r5, [sp, #24]
 800da08:	e9d2 4500 	ldrd	r4, r5, [r2]
 800da0c:	ea54 0005 	orrs.w	r0, r4, r5
 800da10:	bf0c      	ite	eq
 800da12:	2200      	moveq	r2, #0
 800da14:	2201      	movne	r2, #1
 800da16:	ea1b 0f02 	tst.w	fp, r2
 800da1a:	f000 832e 	beq.w	800e07a <_vfiprintf_r+0xafa>
 800da1e:	f88d 350d 	strb.w	r3, [sp, #1293]	; 0x50d
 800da22:	f04b 0b02 	orr.w	fp, fp, #2
 800da26:	2330      	movs	r3, #48	; 0x30
 800da28:	2201      	movs	r2, #1
 800da2a:	f88d 350c 	strb.w	r3, [sp, #1292]	; 0x50c
 800da2e:	2302      	movs	r3, #2
 800da30:	e6b3      	b.n	800d79a <_vfiprintf_r+0x21a>
 800da32:	9b06      	ldr	r3, [sp, #24]
 800da34:	2501      	movs	r5, #1
 800da36:	f50d 619b 	add.w	r1, sp, #1240	; 0x4d8
 800da3a:	2200      	movs	r2, #0
 800da3c:	1d18      	adds	r0, r3, #4
 800da3e:	9502      	str	r5, [sp, #8]
 800da40:	681b      	ldr	r3, [r3, #0]
 800da42:	9006      	str	r0, [sp, #24]
 800da44:	9503      	str	r5, [sp, #12]
 800da46:	9109      	str	r1, [sp, #36]	; 0x24
 800da48:	f88d 250f 	strb.w	r2, [sp, #1295]	; 0x50f
 800da4c:	f88d 34d8 	strb.w	r3, [sp, #1240]	; 0x4d8
 800da50:	2300      	movs	r3, #0
 800da52:	9307      	str	r3, [sp, #28]
 800da54:	f01b 0002 	ands.w	r0, fp, #2
 800da58:	900a      	str	r0, [sp, #40]	; 0x28
 800da5a:	d002      	beq.n	800da62 <_vfiprintf_r+0x4e2>
 800da5c:	9902      	ldr	r1, [sp, #8]
 800da5e:	3102      	adds	r1, #2
 800da60:	9102      	str	r1, [sp, #8]
 800da62:	f01b 0284 	ands.w	r2, fp, #132	; 0x84
 800da66:	920b      	str	r2, [sp, #44]	; 0x2c
 800da68:	f040 80ae 	bne.w	800dbc8 <_vfiprintf_r+0x648>
 800da6c:	9b04      	ldr	r3, [sp, #16]
 800da6e:	9d02      	ldr	r5, [sp, #8]
 800da70:	1b5c      	subs	r4, r3, r5
 800da72:	2c00      	cmp	r4, #0
 800da74:	f340 80a8 	ble.w	800dbc8 <_vfiprintf_r+0x648>
 800da78:	2c10      	cmp	r4, #16
 800da7a:	f340 83ce 	ble.w	800e21a <_vfiprintf_r+0xc9a>
 800da7e:	f240 3568 	movw	r5, #872	; 0x368
 800da82:	f8dd 1508 	ldr.w	r1, [sp, #1288]	; 0x508
 800da86:	f8dd 2504 	ldr.w	r2, [sp, #1284]	; 0x504
 800da8a:	f6c0 0501 	movt	r5, #2049	; 0x801
 800da8e:	f04f 0810 	mov.w	r8, #16
 800da92:	e002      	b.n	800da9a <_vfiprintf_r+0x51a>
 800da94:	3c10      	subs	r4, #16
 800da96:	2c10      	cmp	r4, #16
 800da98:	dd20      	ble.n	800dadc <_vfiprintf_r+0x55c>
 800da9a:	3201      	adds	r2, #1
 800da9c:	6035      	str	r5, [r6, #0]
 800da9e:	f8c6 8004 	str.w	r8, [r6, #4]
 800daa2:	3110      	adds	r1, #16
 800daa4:	3608      	adds	r6, #8
 800daa6:	2a07      	cmp	r2, #7
 800daa8:	f8cd 2504 	str.w	r2, [sp, #1284]	; 0x504
 800daac:	f106 0c08 	add.w	ip, r6, #8
 800dab0:	f8cd 1508 	str.w	r1, [sp, #1288]	; 0x508
 800dab4:	ddee      	ble.n	800da94 <_vfiprintf_r+0x514>
 800dab6:	9801      	ldr	r0, [sp, #4]
 800dab8:	4649      	mov	r1, r9
 800daba:	f50d 62a0 	add.w	r2, sp, #1280	; 0x500
 800dabe:	463e      	mov	r6, r7
 800dac0:	f7ff fd1c 	bl	800d4fc <__sprint_r>
 800dac4:	f107 0c08 	add.w	ip, r7, #8
 800dac8:	2800      	cmp	r0, #0
 800daca:	f040 816e 	bne.w	800ddaa <_vfiprintf_r+0x82a>
 800dace:	3c10      	subs	r4, #16
 800dad0:	f8dd 1508 	ldr.w	r1, [sp, #1288]	; 0x508
 800dad4:	2c10      	cmp	r4, #16
 800dad6:	f8dd 2504 	ldr.w	r2, [sp, #1284]	; 0x504
 800dada:	dcde      	bgt.n	800da9a <_vfiprintf_r+0x51a>
 800dadc:	3201      	adds	r2, #1
 800dade:	6035      	str	r5, [r6, #0]
 800dae0:	2a07      	cmp	r2, #7
 800dae2:	6074      	str	r4, [r6, #4]
 800dae4:	4421      	add	r1, r4
 800dae6:	f8cd 2504 	str.w	r2, [sp, #1284]	; 0x504
 800daea:	f8cd 1508 	str.w	r1, [sp, #1288]	; 0x508
 800daee:	bfdc      	itt	le
 800daf0:	f10c 0308 	addle.w	r3, ip, #8
 800daf4:	4666      	movle	r6, ip
 800daf6:	dd6d      	ble.n	800dbd4 <_vfiprintf_r+0x654>
 800daf8:	9801      	ldr	r0, [sp, #4]
 800dafa:	4649      	mov	r1, r9
 800dafc:	f50d 62a0 	add.w	r2, sp, #1280	; 0x500
 800db00:	f7ff fcfc 	bl	800d4fc <__sprint_r>
 800db04:	2800      	cmp	r0, #0
 800db06:	f040 8150 	bne.w	800ddaa <_vfiprintf_r+0x82a>
 800db0a:	f8dd 1508 	ldr.w	r1, [sp, #1288]	; 0x508
 800db0e:	f107 0308 	add.w	r3, r7, #8
 800db12:	f8dd 2504 	ldr.w	r2, [sp, #1284]	; 0x504
 800db16:	463e      	mov	r6, r7
 800db18:	e05c      	b.n	800dbd4 <_vfiprintf_r+0x654>
 800db1a:	f01b 0f20 	tst.w	fp, #32
 800db1e:	f240 4098 	movw	r0, #1176	; 0x498
 800db22:	f6c0 0001 	movt	r0, #2049	; 0x801
 800db26:	9008      	str	r0, [sp, #32]
 800db28:	f47f af67 	bne.w	800d9fa <_vfiprintf_r+0x47a>
 800db2c:	f01b 0f10 	tst.w	fp, #16
 800db30:	f040 8308 	bne.w	800e144 <_vfiprintf_r+0xbc4>
 800db34:	f01b 0f40 	tst.w	fp, #64	; 0x40
 800db38:	f000 8346 	beq.w	800e1c8 <_vfiprintf_r+0xc48>
 800db3c:	9906      	ldr	r1, [sp, #24]
 800db3e:	2500      	movs	r5, #0
 800db40:	880c      	ldrh	r4, [r1, #0]
 800db42:	3104      	adds	r1, #4
 800db44:	9106      	str	r1, [sp, #24]
 800db46:	e761      	b.n	800da0c <_vfiprintf_r+0x48c>
 800db48:	f04b 0b01 	orr.w	fp, fp, #1
 800db4c:	f89a 3000 	ldrb.w	r3, [sl]
 800db50:	e5ac      	b.n	800d6ac <_vfiprintf_r+0x12c>
 800db52:	f89d 350f 	ldrb.w	r3, [sp, #1295]	; 0x50f
 800db56:	2b00      	cmp	r3, #0
 800db58:	f040 8309 	bne.w	800e16e <_vfiprintf_r+0xbee>
 800db5c:	f88d c50f 	strb.w	ip, [sp, #1295]	; 0x50f
 800db60:	f89a 3000 	ldrb.w	r3, [sl]
 800db64:	e5a2      	b.n	800d6ac <_vfiprintf_r+0x12c>
 800db66:	2b00      	cmp	r3, #0
 800db68:	f000 8116 	beq.w	800dd98 <_vfiprintf_r+0x818>
 800db6c:	2401      	movs	r4, #1
 800db6e:	2500      	movs	r5, #0
 800db70:	f50d 609b 	add.w	r0, sp, #1240	; 0x4d8
 800db74:	9402      	str	r4, [sp, #8]
 800db76:	f88d 34d8 	strb.w	r3, [sp, #1240]	; 0x4d8
 800db7a:	f88d 550f 	strb.w	r5, [sp, #1295]	; 0x50f
 800db7e:	9403      	str	r4, [sp, #12]
 800db80:	9009      	str	r0, [sp, #36]	; 0x24
 800db82:	e765      	b.n	800da50 <_vfiprintf_r+0x4d0>
 800db84:	f88d 550f 	strb.w	r5, [sp, #1295]	; 0x50f
 800db88:	f89a 3000 	ldrb.w	r3, [sl]
 800db8c:	e58e      	b.n	800d6ac <_vfiprintf_r+0x12c>
 800db8e:	f81a 3b01 	ldrb.w	r3, [sl], #1
 800db92:	2b2a      	cmp	r3, #42	; 0x2a
 800db94:	f000 8371 	beq.w	800e27a <_vfiprintf_r+0xcfa>
 800db98:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800db9c:	2a09      	cmp	r2, #9
 800db9e:	bf88      	it	hi
 800dba0:	f04f 0800 	movhi.w	r8, #0
 800dba4:	d80d      	bhi.n	800dbc2 <_vfiprintf_r+0x642>
 800dba6:	4651      	mov	r1, sl
 800dba8:	f04f 0800 	mov.w	r8, #0
 800dbac:	f811 3b01 	ldrb.w	r3, [r1], #1
 800dbb0:	eb08 0888 	add.w	r8, r8, r8, lsl #2
 800dbb4:	eb02 0848 	add.w	r8, r2, r8, lsl #1
 800dbb8:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800dbbc:	2a09      	cmp	r2, #9
 800dbbe:	468a      	mov	sl, r1
 800dbc0:	d9f4      	bls.n	800dbac <_vfiprintf_r+0x62c>
 800dbc2:	ea48 78e8 	orr.w	r8, r8, r8, asr #31
 800dbc6:	e573      	b.n	800d6b0 <_vfiprintf_r+0x130>
 800dbc8:	f8dd 1508 	ldr.w	r1, [sp, #1288]	; 0x508
 800dbcc:	f106 0308 	add.w	r3, r6, #8
 800dbd0:	f8dd 2504 	ldr.w	r2, [sp, #1284]	; 0x504
 800dbd4:	f89d 050f 	ldrb.w	r0, [sp, #1295]	; 0x50f
 800dbd8:	b180      	cbz	r0, 800dbfc <_vfiprintf_r+0x67c>
 800dbda:	3201      	adds	r2, #1
 800dbdc:	f50d 60a0 	add.w	r0, sp, #1280	; 0x500
 800dbe0:	300f      	adds	r0, #15
 800dbe2:	6030      	str	r0, [r6, #0]
 800dbe4:	2001      	movs	r0, #1
 800dbe6:	2a07      	cmp	r2, #7
 800dbe8:	6070      	str	r0, [r6, #4]
 800dbea:	4401      	add	r1, r0
 800dbec:	f8cd 2504 	str.w	r2, [sp, #1284]	; 0x504
 800dbf0:	f8cd 1508 	str.w	r1, [sp, #1288]	; 0x508
 800dbf4:	f300 8161 	bgt.w	800deba <_vfiprintf_r+0x93a>
 800dbf8:	461e      	mov	r6, r3
 800dbfa:	3308      	adds	r3, #8
 800dbfc:	980a      	ldr	r0, [sp, #40]	; 0x28
 800dbfe:	b180      	cbz	r0, 800dc22 <_vfiprintf_r+0x6a2>
 800dc00:	3201      	adds	r2, #1
 800dc02:	f50d 60a0 	add.w	r0, sp, #1280	; 0x500
 800dc06:	300c      	adds	r0, #12
 800dc08:	6030      	str	r0, [r6, #0]
 800dc0a:	2002      	movs	r0, #2
 800dc0c:	2a07      	cmp	r2, #7
 800dc0e:	6070      	str	r0, [r6, #4]
 800dc10:	4401      	add	r1, r0
 800dc12:	f8cd 2504 	str.w	r2, [sp, #1284]	; 0x504
 800dc16:	f8cd 1508 	str.w	r1, [sp, #1288]	; 0x508
 800dc1a:	f300 8161 	bgt.w	800dee0 <_vfiprintf_r+0x960>
 800dc1e:	461e      	mov	r6, r3
 800dc20:	3308      	adds	r3, #8
 800dc22:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 800dc24:	2c80      	cmp	r4, #128	; 0x80
 800dc26:	f000 80cf 	beq.w	800ddc8 <_vfiprintf_r+0x848>
 800dc2a:	9807      	ldr	r0, [sp, #28]
 800dc2c:	9d03      	ldr	r5, [sp, #12]
 800dc2e:	1b44      	subs	r4, r0, r5
 800dc30:	2c00      	cmp	r4, #0
 800dc32:	dd47      	ble.n	800dcc4 <_vfiprintf_r+0x744>
 800dc34:	2c10      	cmp	r4, #16
 800dc36:	f340 82a3 	ble.w	800e180 <_vfiprintf_r+0xc00>
 800dc3a:	4da8      	ldr	r5, [pc, #672]	; (800dedc <_vfiprintf_r+0x95c>)
 800dc3c:	f04f 0810 	mov.w	r8, #16
 800dc40:	e002      	b.n	800dc48 <_vfiprintf_r+0x6c8>
 800dc42:	3c10      	subs	r4, #16
 800dc44:	2c10      	cmp	r4, #16
 800dc46:	dd20      	ble.n	800dc8a <_vfiprintf_r+0x70a>
 800dc48:	3201      	adds	r2, #1
 800dc4a:	6035      	str	r5, [r6, #0]
 800dc4c:	f8c6 8004 	str.w	r8, [r6, #4]
 800dc50:	3110      	adds	r1, #16
 800dc52:	3608      	adds	r6, #8
 800dc54:	2a07      	cmp	r2, #7
 800dc56:	f8cd 2504 	str.w	r2, [sp, #1284]	; 0x504
 800dc5a:	f106 0c08 	add.w	ip, r6, #8
 800dc5e:	f8cd 1508 	str.w	r1, [sp, #1288]	; 0x508
 800dc62:	ddee      	ble.n	800dc42 <_vfiprintf_r+0x6c2>
 800dc64:	9801      	ldr	r0, [sp, #4]
 800dc66:	4649      	mov	r1, r9
 800dc68:	f50d 62a0 	add.w	r2, sp, #1280	; 0x500
 800dc6c:	463e      	mov	r6, r7
 800dc6e:	f7ff fc45 	bl	800d4fc <__sprint_r>
 800dc72:	f107 0c08 	add.w	ip, r7, #8
 800dc76:	2800      	cmp	r0, #0
 800dc78:	f040 8097 	bne.w	800ddaa <_vfiprintf_r+0x82a>
 800dc7c:	3c10      	subs	r4, #16
 800dc7e:	f8dd 1508 	ldr.w	r1, [sp, #1288]	; 0x508
 800dc82:	2c10      	cmp	r4, #16
 800dc84:	f8dd 2504 	ldr.w	r2, [sp, #1284]	; 0x504
 800dc88:	dcde      	bgt.n	800dc48 <_vfiprintf_r+0x6c8>
 800dc8a:	3201      	adds	r2, #1
 800dc8c:	6035      	str	r5, [r6, #0]
 800dc8e:	2a07      	cmp	r2, #7
 800dc90:	6074      	str	r4, [r6, #4]
 800dc92:	4421      	add	r1, r4
 800dc94:	f8cd 2504 	str.w	r2, [sp, #1284]	; 0x504
 800dc98:	f8cd 1508 	str.w	r1, [sp, #1288]	; 0x508
 800dc9c:	bfdc      	itt	le
 800dc9e:	f10c 0308 	addle.w	r3, ip, #8
 800dca2:	4666      	movle	r6, ip
 800dca4:	dd0e      	ble.n	800dcc4 <_vfiprintf_r+0x744>
 800dca6:	9801      	ldr	r0, [sp, #4]
 800dca8:	4649      	mov	r1, r9
 800dcaa:	f50d 62a0 	add.w	r2, sp, #1280	; 0x500
 800dcae:	f7ff fc25 	bl	800d4fc <__sprint_r>
 800dcb2:	2800      	cmp	r0, #0
 800dcb4:	d179      	bne.n	800ddaa <_vfiprintf_r+0x82a>
 800dcb6:	f8dd 1508 	ldr.w	r1, [sp, #1288]	; 0x508
 800dcba:	f107 0308 	add.w	r3, r7, #8
 800dcbe:	f8dd 2504 	ldr.w	r2, [sp, #1284]	; 0x504
 800dcc2:	463e      	mov	r6, r7
 800dcc4:	3201      	adds	r2, #1
 800dcc6:	9d03      	ldr	r5, [sp, #12]
 800dcc8:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800dcca:	2a07      	cmp	r2, #7
 800dccc:	4429      	add	r1, r5
 800dcce:	6075      	str	r5, [r6, #4]
 800dcd0:	6034      	str	r4, [r6, #0]
 800dcd2:	f8cd 2504 	str.w	r2, [sp, #1284]	; 0x504
 800dcd6:	f8cd 1508 	str.w	r1, [sp, #1288]	; 0x508
 800dcda:	f300 80c7 	bgt.w	800de6c <_vfiprintf_r+0x8ec>
 800dcde:	f01b 0f04 	tst.w	fp, #4
 800dce2:	d03a      	beq.n	800dd5a <_vfiprintf_r+0x7da>
 800dce4:	9804      	ldr	r0, [sp, #16]
 800dce6:	9a02      	ldr	r2, [sp, #8]
 800dce8:	1a84      	subs	r4, r0, r2
 800dcea:	2c00      	cmp	r4, #0
 800dcec:	dd35      	ble.n	800dd5a <_vfiprintf_r+0x7da>
 800dcee:	2c10      	cmp	r4, #16
 800dcf0:	f340 82a6 	ble.w	800e240 <_vfiprintf_r+0xcc0>
 800dcf4:	f240 3568 	movw	r5, #872	; 0x368
 800dcf8:	f8dd 2504 	ldr.w	r2, [sp, #1284]	; 0x504
 800dcfc:	f6c0 0501 	movt	r5, #2049	; 0x801
 800dd00:	2610      	movs	r6, #16
 800dd02:	f8dd 8004 	ldr.w	r8, [sp, #4]
 800dd06:	e002      	b.n	800dd0e <_vfiprintf_r+0x78e>
 800dd08:	3c10      	subs	r4, #16
 800dd0a:	2c10      	cmp	r4, #16
 800dd0c:	dd1a      	ble.n	800dd44 <_vfiprintf_r+0x7c4>
 800dd0e:	3201      	adds	r2, #1
 800dd10:	601d      	str	r5, [r3, #0]
 800dd12:	605e      	str	r6, [r3, #4]
 800dd14:	3110      	adds	r1, #16
 800dd16:	3308      	adds	r3, #8
 800dd18:	2a07      	cmp	r2, #7
 800dd1a:	f8cd 2504 	str.w	r2, [sp, #1284]	; 0x504
 800dd1e:	f8cd 1508 	str.w	r1, [sp, #1288]	; 0x508
 800dd22:	ddf1      	ble.n	800dd08 <_vfiprintf_r+0x788>
 800dd24:	4640      	mov	r0, r8
 800dd26:	4649      	mov	r1, r9
 800dd28:	f50d 62a0 	add.w	r2, sp, #1280	; 0x500
 800dd2c:	f7ff fbe6 	bl	800d4fc <__sprint_r>
 800dd30:	463b      	mov	r3, r7
 800dd32:	2800      	cmp	r0, #0
 800dd34:	d139      	bne.n	800ddaa <_vfiprintf_r+0x82a>
 800dd36:	3c10      	subs	r4, #16
 800dd38:	f8dd 1508 	ldr.w	r1, [sp, #1288]	; 0x508
 800dd3c:	2c10      	cmp	r4, #16
 800dd3e:	f8dd 2504 	ldr.w	r2, [sp, #1284]	; 0x504
 800dd42:	dce4      	bgt.n	800dd0e <_vfiprintf_r+0x78e>
 800dd44:	3201      	adds	r2, #1
 800dd46:	601d      	str	r5, [r3, #0]
 800dd48:	2a07      	cmp	r2, #7
 800dd4a:	605c      	str	r4, [r3, #4]
 800dd4c:	4421      	add	r1, r4
 800dd4e:	f8cd 2504 	str.w	r2, [sp, #1284]	; 0x504
 800dd52:	f8cd 1508 	str.w	r1, [sp, #1288]	; 0x508
 800dd56:	f300 81b2 	bgt.w	800e0be <_vfiprintf_r+0xb3e>
 800dd5a:	9b05      	ldr	r3, [sp, #20]
 800dd5c:	9d02      	ldr	r5, [sp, #8]
 800dd5e:	9c04      	ldr	r4, [sp, #16]
 800dd60:	42a5      	cmp	r5, r4
 800dd62:	bfac      	ite	ge
 800dd64:	195b      	addge	r3, r3, r5
 800dd66:	191b      	addlt	r3, r3, r4
 800dd68:	9305      	str	r3, [sp, #20]
 800dd6a:	2900      	cmp	r1, #0
 800dd6c:	f040 808a 	bne.w	800de84 <_vfiprintf_r+0x904>
 800dd70:	2000      	movs	r0, #0
 800dd72:	f8cd 0504 	str.w	r0, [sp, #1284]	; 0x504
 800dd76:	f89a 3000 	ldrb.w	r3, [sl]
 800dd7a:	463e      	mov	r6, r7
 800dd7c:	f1b3 0225 	subs.w	r2, r3, #37	; 0x25
 800dd80:	bf18      	it	ne
 800dd82:	2201      	movne	r2, #1
 800dd84:	2b00      	cmp	r3, #0
 800dd86:	bf0c      	ite	eq
 800dd88:	2300      	moveq	r3, #0
 800dd8a:	f002 0301 	andne.w	r3, r2, #1
 800dd8e:	2b00      	cmp	r3, #0
 800dd90:	f47f ac54 	bne.w	800d63c <_vfiprintf_r+0xbc>
 800dd94:	4654      	mov	r4, sl
 800dd96:	e477      	b.n	800d688 <_vfiprintf_r+0x108>
 800dd98:	f8dd 3508 	ldr.w	r3, [sp, #1288]	; 0x508
 800dd9c:	b12b      	cbz	r3, 800ddaa <_vfiprintf_r+0x82a>
 800dd9e:	9801      	ldr	r0, [sp, #4]
 800dda0:	4649      	mov	r1, r9
 800dda2:	f50d 62a0 	add.w	r2, sp, #1280	; 0x500
 800dda6:	f7ff fba9 	bl	800d4fc <__sprint_r>
 800ddaa:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 800ddae:	9905      	ldr	r1, [sp, #20]
 800ddb0:	f013 0f40 	tst.w	r3, #64	; 0x40
 800ddb4:	bf18      	it	ne
 800ddb6:	f04f 31ff 	movne.w	r1, #4294967295
 800ddba:	9105      	str	r1, [sp, #20]
 800ddbc:	9805      	ldr	r0, [sp, #20]
 800ddbe:	b045      	add	sp, #276	; 0x114
 800ddc0:	f50d 6d80 	add.w	sp, sp, #1024	; 0x400
 800ddc4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ddc8:	9d04      	ldr	r5, [sp, #16]
 800ddca:	9802      	ldr	r0, [sp, #8]
 800ddcc:	1a2c      	subs	r4, r5, r0
 800ddce:	2c00      	cmp	r4, #0
 800ddd0:	bfd8      	it	le
 800ddd2:	f106 0308 	addle.w	r3, r6, #8
 800ddd6:	f77f af28 	ble.w	800dc2a <_vfiprintf_r+0x6aa>
 800ddda:	2c10      	cmp	r4, #16
 800dddc:	f340 8241 	ble.w	800e262 <_vfiprintf_r+0xce2>
 800dde0:	4d3e      	ldr	r5, [pc, #248]	; (800dedc <_vfiprintf_r+0x95c>)
 800dde2:	f04f 0810 	mov.w	r8, #16
 800dde6:	e002      	b.n	800ddee <_vfiprintf_r+0x86e>
 800dde8:	3c10      	subs	r4, #16
 800ddea:	2c10      	cmp	r4, #16
 800ddec:	dd1f      	ble.n	800de2e <_vfiprintf_r+0x8ae>
 800ddee:	3201      	adds	r2, #1
 800ddf0:	6035      	str	r5, [r6, #0]
 800ddf2:	f8c6 8004 	str.w	r8, [r6, #4]
 800ddf6:	3110      	adds	r1, #16
 800ddf8:	3608      	adds	r6, #8
 800ddfa:	2a07      	cmp	r2, #7
 800ddfc:	f8cd 2504 	str.w	r2, [sp, #1284]	; 0x504
 800de00:	f106 0c08 	add.w	ip, r6, #8
 800de04:	f8cd 1508 	str.w	r1, [sp, #1288]	; 0x508
 800de08:	ddee      	ble.n	800dde8 <_vfiprintf_r+0x868>
 800de0a:	9801      	ldr	r0, [sp, #4]
 800de0c:	4649      	mov	r1, r9
 800de0e:	f50d 62a0 	add.w	r2, sp, #1280	; 0x500
 800de12:	463e      	mov	r6, r7
 800de14:	f7ff fb72 	bl	800d4fc <__sprint_r>
 800de18:	f107 0c08 	add.w	ip, r7, #8
 800de1c:	2800      	cmp	r0, #0
 800de1e:	d1c4      	bne.n	800ddaa <_vfiprintf_r+0x82a>
 800de20:	3c10      	subs	r4, #16
 800de22:	f8dd 1508 	ldr.w	r1, [sp, #1288]	; 0x508
 800de26:	2c10      	cmp	r4, #16
 800de28:	f8dd 2504 	ldr.w	r2, [sp, #1284]	; 0x504
 800de2c:	dcdf      	bgt.n	800ddee <_vfiprintf_r+0x86e>
 800de2e:	3201      	adds	r2, #1
 800de30:	6035      	str	r5, [r6, #0]
 800de32:	2a07      	cmp	r2, #7
 800de34:	6074      	str	r4, [r6, #4]
 800de36:	4421      	add	r1, r4
 800de38:	f8cd 2504 	str.w	r2, [sp, #1284]	; 0x504
 800de3c:	f8cd 1508 	str.w	r1, [sp, #1288]	; 0x508
 800de40:	bfdc      	itt	le
 800de42:	f10c 0308 	addle.w	r3, ip, #8
 800de46:	4666      	movle	r6, ip
 800de48:	f77f aeef 	ble.w	800dc2a <_vfiprintf_r+0x6aa>
 800de4c:	9801      	ldr	r0, [sp, #4]
 800de4e:	4649      	mov	r1, r9
 800de50:	f50d 62a0 	add.w	r2, sp, #1280	; 0x500
 800de54:	f7ff fb52 	bl	800d4fc <__sprint_r>
 800de58:	2800      	cmp	r0, #0
 800de5a:	d1a6      	bne.n	800ddaa <_vfiprintf_r+0x82a>
 800de5c:	f8dd 1508 	ldr.w	r1, [sp, #1288]	; 0x508
 800de60:	f107 0308 	add.w	r3, r7, #8
 800de64:	f8dd 2504 	ldr.w	r2, [sp, #1284]	; 0x504
 800de68:	463e      	mov	r6, r7
 800de6a:	e6de      	b.n	800dc2a <_vfiprintf_r+0x6aa>
 800de6c:	9801      	ldr	r0, [sp, #4]
 800de6e:	4649      	mov	r1, r9
 800de70:	f50d 62a0 	add.w	r2, sp, #1280	; 0x500
 800de74:	f7ff fb42 	bl	800d4fc <__sprint_r>
 800de78:	2800      	cmp	r0, #0
 800de7a:	d196      	bne.n	800ddaa <_vfiprintf_r+0x82a>
 800de7c:	f8dd 1508 	ldr.w	r1, [sp, #1288]	; 0x508
 800de80:	463b      	mov	r3, r7
 800de82:	e72c      	b.n	800dcde <_vfiprintf_r+0x75e>
 800de84:	9801      	ldr	r0, [sp, #4]
 800de86:	4649      	mov	r1, r9
 800de88:	f50d 62a0 	add.w	r2, sp, #1280	; 0x500
 800de8c:	f7ff fb36 	bl	800d4fc <__sprint_r>
 800de90:	2800      	cmp	r0, #0
 800de92:	f43f af6d 	beq.w	800dd70 <_vfiprintf_r+0x7f0>
 800de96:	e788      	b.n	800ddaa <_vfiprintf_r+0x82a>
 800de98:	f50d 61a0 	add.w	r1, sp, #1280	; 0x500
 800de9c:	9203      	str	r2, [sp, #12]
 800de9e:	9109      	str	r1, [sp, #36]	; 0x24
 800dea0:	e4be      	b.n	800d820 <_vfiprintf_r+0x2a0>
 800dea2:	9801      	ldr	r0, [sp, #4]
 800dea4:	4649      	mov	r1, r9
 800dea6:	f50d 62a0 	add.w	r2, sp, #1280	; 0x500
 800deaa:	f7ff fb27 	bl	800d4fc <__sprint_r>
 800deae:	2800      	cmp	r0, #0
 800deb0:	f47f af7b 	bne.w	800ddaa <_vfiprintf_r+0x82a>
 800deb4:	463e      	mov	r6, r7
 800deb6:	f7ff bbe4 	b.w	800d682 <_vfiprintf_r+0x102>
 800deba:	9801      	ldr	r0, [sp, #4]
 800debc:	4649      	mov	r1, r9
 800debe:	f50d 62a0 	add.w	r2, sp, #1280	; 0x500
 800dec2:	f7ff fb1b 	bl	800d4fc <__sprint_r>
 800dec6:	2800      	cmp	r0, #0
 800dec8:	f47f af6f 	bne.w	800ddaa <_vfiprintf_r+0x82a>
 800decc:	f8dd 1508 	ldr.w	r1, [sp, #1288]	; 0x508
 800ded0:	f107 0308 	add.w	r3, r7, #8
 800ded4:	f8dd 2504 	ldr.w	r2, [sp, #1284]	; 0x504
 800ded8:	463e      	mov	r6, r7
 800deda:	e68f      	b.n	800dbfc <_vfiprintf_r+0x67c>
 800dedc:	08010378 	.word	0x08010378
 800dee0:	9801      	ldr	r0, [sp, #4]
 800dee2:	4649      	mov	r1, r9
 800dee4:	f50d 62a0 	add.w	r2, sp, #1280	; 0x500
 800dee8:	f7ff fb08 	bl	800d4fc <__sprint_r>
 800deec:	2800      	cmp	r0, #0
 800deee:	f47f af5c 	bne.w	800ddaa <_vfiprintf_r+0x82a>
 800def2:	f8dd 1508 	ldr.w	r1, [sp, #1288]	; 0x508
 800def6:	f107 0308 	add.w	r3, r7, #8
 800defa:	f8dd 2504 	ldr.w	r2, [sp, #1284]	; 0x504
 800defe:	463e      	mov	r6, r7
 800df00:	e68f      	b.n	800dc22 <_vfiprintf_r+0x6a2>
 800df02:	f8b9 500e 	ldrh.w	r5, [r9, #14]
 800df06:	f415 4f00 	tst.w	r5, #32768	; 0x8000
 800df0a:	f47f ab7d 	bne.w	800d608 <_vfiprintf_r+0x88>
 800df0e:	f8d9 6064 	ldr.w	r6, [r9, #100]	; 0x64
 800df12:	f50d 6186 	add.w	r1, sp, #1072	; 0x430
 800df16:	f8d9 e020 	ldr.w	lr, [r9, #32]
 800df1a:	4652      	mov	r2, sl
 800df1c:	f8d9 c028 	ldr.w	ip, [r9, #40]	; 0x28
 800df20:	f44f 6780 	mov.w	r7, #1024	; 0x400
 800df24:	9801      	ldr	r0, [sp, #4]
 800df26:	f024 0402 	bic.w	r4, r4, #2
 800df2a:	9b06      	ldr	r3, [sp, #24]
 800df2c:	f8ad 443c 	strh.w	r4, [sp, #1084]	; 0x43c
 800df30:	ac0c      	add	r4, sp, #48	; 0x30
 800df32:	f8cd 6494 	str.w	r6, [sp, #1172]	; 0x494
 800df36:	f8cd 4430 	str.w	r4, [sp, #1072]	; 0x430
 800df3a:	f8cd 4440 	str.w	r4, [sp, #1088]	; 0x440
 800df3e:	2400      	movs	r4, #0
 800df40:	f8ad 543e 	strh.w	r5, [sp, #1086]	; 0x43e
 800df44:	f8cd e450 	str.w	lr, [sp, #1104]	; 0x450
 800df48:	f8cd c458 	str.w	ip, [sp, #1112]	; 0x458
 800df4c:	f8cd 7438 	str.w	r7, [sp, #1080]	; 0x438
 800df50:	f8cd 7444 	str.w	r7, [sp, #1092]	; 0x444
 800df54:	f8cd 4448 	str.w	r4, [sp, #1096]	; 0x448
 800df58:	f7ff fb12 	bl	800d580 <_vfiprintf_r>
 800df5c:	2800      	cmp	r0, #0
 800df5e:	9005      	str	r0, [sp, #20]
 800df60:	db0a      	blt.n	800df78 <_vfiprintf_r+0x9f8>
 800df62:	9801      	ldr	r0, [sp, #4]
 800df64:	f50d 6186 	add.w	r1, sp, #1072	; 0x430
 800df68:	f7fd f942 	bl	800b1f0 <_fflush_r>
 800df6c:	9d05      	ldr	r5, [sp, #20]
 800df6e:	42a0      	cmp	r0, r4
 800df70:	bf18      	it	ne
 800df72:	f04f 35ff 	movne.w	r5, #4294967295
 800df76:	9505      	str	r5, [sp, #20]
 800df78:	f8bd 343c 	ldrh.w	r3, [sp, #1084]	; 0x43c
 800df7c:	f013 0f40 	tst.w	r3, #64	; 0x40
 800df80:	f43f af1c 	beq.w	800ddbc <_vfiprintf_r+0x83c>
 800df84:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 800df88:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800df8c:	f8a9 300c 	strh.w	r3, [r9, #12]
 800df90:	e714      	b.n	800ddbc <_vfiprintf_r+0x83c>
 800df92:	f7fd fa4b 	bl	800b42c <__sinit>
 800df96:	f240 13c0 	movw	r3, #448	; 0x1c0
 800df9a:	f6c0 0301 	movt	r3, #2049	; 0x801
 800df9e:	4599      	cmp	r9, r3
 800dfa0:	f47f ab03 	bne.w	800d5aa <_vfiprintf_r+0x2a>
 800dfa4:	9801      	ldr	r0, [sp, #4]
 800dfa6:	f8d0 9004 	ldr.w	r9, [r0, #4]
 800dfaa:	f7ff bb0e 	b.w	800d5ca <_vfiprintf_r+0x4a>
 800dfae:	f50d 609b 	add.w	r0, sp, #1240	; 0x4d8
 800dfb2:	f8dd c020 	ldr.w	ip, [sp, #32]
 800dfb6:	9002      	str	r0, [sp, #8]
 800dfb8:	3027      	adds	r0, #39	; 0x27
 800dfba:	0923      	lsrs	r3, r4, #4
 800dfbc:	f004 020f 	and.w	r2, r4, #15
 800dfc0:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 800dfc4:	0929      	lsrs	r1, r5, #4
 800dfc6:	461c      	mov	r4, r3
 800dfc8:	f81c 2002 	ldrb.w	r2, [ip, r2]
 800dfcc:	460d      	mov	r5, r1
 800dfce:	4603      	mov	r3, r0
 800dfd0:	3801      	subs	r0, #1
 800dfd2:	ea54 0105 	orrs.w	r1, r4, r5
 800dfd6:	701a      	strb	r2, [r3, #0]
 800dfd8:	d1ef      	bne.n	800dfba <_vfiprintf_r+0xa3a>
 800dfda:	9309      	str	r3, [sp, #36]	; 0x24
 800dfdc:	9a02      	ldr	r2, [sp, #8]
 800dfde:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800dfe0:	f102 0328 	add.w	r3, r2, #40	; 0x28
 800dfe4:	1b1b      	subs	r3, r3, r4
 800dfe6:	9303      	str	r3, [sp, #12]
 800dfe8:	e41a      	b.n	800d820 <_vfiprintf_r+0x2a0>
 800dfea:	f50d 62a0 	add.w	r2, sp, #1280	; 0x500
 800dfee:	9303      	str	r3, [sp, #12]
 800dff0:	9209      	str	r2, [sp, #36]	; 0x24
 800dff2:	e415      	b.n	800d820 <_vfiprintf_r+0x2a0>
 800dff4:	2c0a      	cmp	r4, #10
 800dff6:	f175 0200 	sbcs.w	r2, r5, #0
 800dffa:	d36c      	bcc.n	800e0d6 <_vfiprintf_r+0xb56>
 800dffc:	f50d 609b 	add.w	r0, sp, #1240	; 0x4d8
 800e000:	f8cd a00c 	str.w	sl, [sp, #12]
 800e004:	f100 0327 	add.w	r3, r0, #39	; 0x27
 800e008:	f8cd b01c 	str.w	fp, [sp, #28]
 800e00c:	46c2      	mov	sl, r8
 800e00e:	46b3      	mov	fp, r6
 800e010:	4698      	mov	r8, r3
 800e012:	9002      	str	r0, [sp, #8]
 800e014:	4620      	mov	r0, r4
 800e016:	4629      	mov	r1, r5
 800e018:	220a      	movs	r2, #10
 800e01a:	2300      	movs	r3, #0
 800e01c:	f001 fbe0 	bl	800f7e0 <__aeabi_uldivmod>
 800e020:	4646      	mov	r6, r8
 800e022:	4620      	mov	r0, r4
 800e024:	4629      	mov	r1, r5
 800e026:	2300      	movs	r3, #0
 800e028:	f108 38ff 	add.w	r8, r8, #4294967295
 800e02c:	f102 0430 	add.w	r4, r2, #48	; 0x30
 800e030:	220a      	movs	r2, #10
 800e032:	7034      	strb	r4, [r6, #0]
 800e034:	f001 fbd4 	bl	800f7e0 <__aeabi_uldivmod>
 800e038:	4604      	mov	r4, r0
 800e03a:	460d      	mov	r5, r1
 800e03c:	ea54 0105 	orrs.w	r1, r4, r5
 800e040:	d1e8      	bne.n	800e014 <_vfiprintf_r+0xa94>
 800e042:	9609      	str	r6, [sp, #36]	; 0x24
 800e044:	46d0      	mov	r8, sl
 800e046:	465e      	mov	r6, fp
 800e048:	f8dd a00c 	ldr.w	sl, [sp, #12]
 800e04c:	f8dd b01c 	ldr.w	fp, [sp, #28]
 800e050:	e7c4      	b.n	800dfdc <_vfiprintf_r+0xa5c>
 800e052:	f01b 0f10 	tst.w	fp, #16
 800e056:	d17b      	bne.n	800e150 <_vfiprintf_r+0xbd0>
 800e058:	f01b 0f40 	tst.w	fp, #64	; 0x40
 800e05c:	f000 80ba 	beq.w	800e1d4 <_vfiprintf_r+0xc54>
 800e060:	9b06      	ldr	r3, [sp, #24]
 800e062:	881a      	ldrh	r2, [r3, #0]
 800e064:	2301      	movs	r3, #1
 800e066:	9c06      	ldr	r4, [sp, #24]
 800e068:	2500      	movs	r5, #0
 800e06a:	3404      	adds	r4, #4
 800e06c:	9406      	str	r4, [sp, #24]
 800e06e:	4614      	mov	r4, r2
 800e070:	3a00      	subs	r2, #0
 800e072:	bf18      	it	ne
 800e074:	2201      	movne	r2, #1
 800e076:	f7ff bb90 	b.w	800d79a <_vfiprintf_r+0x21a>
 800e07a:	2302      	movs	r3, #2
 800e07c:	f7ff bb8d 	b.w	800d79a <_vfiprintf_r+0x21a>
 800e080:	f01b 0110 	ands.w	r1, fp, #16
 800e084:	d170      	bne.n	800e168 <_vfiprintf_r+0xbe8>
 800e086:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
 800e08a:	f000 808b 	beq.w	800e1a4 <_vfiprintf_r+0xc24>
 800e08e:	9b06      	ldr	r3, [sp, #24]
 800e090:	881a      	ldrh	r2, [r3, #0]
 800e092:	460b      	mov	r3, r1
 800e094:	e7e7      	b.n	800e066 <_vfiprintf_r+0xae6>
 800e096:	f01b 0f10 	tst.w	fp, #16
 800e09a:	d13b      	bne.n	800e114 <_vfiprintf_r+0xb94>
 800e09c:	f01b 0f40 	tst.w	fp, #64	; 0x40
 800e0a0:	f000 808b 	beq.w	800e1ba <_vfiprintf_r+0xc3a>
 800e0a4:	9906      	ldr	r1, [sp, #24]
 800e0a6:	f9b1 4000 	ldrsh.w	r4, [r1]
 800e0aa:	3104      	adds	r1, #4
 800e0ac:	9106      	str	r1, [sp, #24]
 800e0ae:	17e5      	asrs	r5, r4, #31
 800e0b0:	f7ff bbeb 	b.w	800d88a <_vfiprintf_r+0x30a>
 800e0b4:	f89a 3000 	ldrb.w	r3, [sl]
 800e0b8:	9206      	str	r2, [sp, #24]
 800e0ba:	f7ff baf7 	b.w	800d6ac <_vfiprintf_r+0x12c>
 800e0be:	9801      	ldr	r0, [sp, #4]
 800e0c0:	4649      	mov	r1, r9
 800e0c2:	f50d 62a0 	add.w	r2, sp, #1280	; 0x500
 800e0c6:	f7ff fa19 	bl	800d4fc <__sprint_r>
 800e0ca:	2800      	cmp	r0, #0
 800e0cc:	f47f ae6d 	bne.w	800ddaa <_vfiprintf_r+0x82a>
 800e0d0:	f8dd 1508 	ldr.w	r1, [sp, #1288]	; 0x508
 800e0d4:	e641      	b.n	800dd5a <_vfiprintf_r+0x7da>
 800e0d6:	3430      	adds	r4, #48	; 0x30
 800e0d8:	f88d 44ff 	strb.w	r4, [sp, #1279]	; 0x4ff
 800e0dc:	f50d 649e 	add.w	r4, sp, #1264	; 0x4f0
 800e0e0:	2301      	movs	r3, #1
 800e0e2:	340f      	adds	r4, #15
 800e0e4:	9303      	str	r3, [sp, #12]
 800e0e6:	9409      	str	r4, [sp, #36]	; 0x24
 800e0e8:	f7ff bb9a 	b.w	800d820 <_vfiprintf_r+0x2a0>
 800e0ec:	9902      	ldr	r1, [sp, #8]
 800e0ee:	f101 0328 	add.w	r3, r1, #40	; 0x28
 800e0f2:	ebcc 0303 	rsb	r3, ip, r3
 800e0f6:	9303      	str	r3, [sp, #12]
 800e0f8:	f7ff bb92 	b.w	800d820 <_vfiprintf_r+0x2a0>
 800e0fc:	9a06      	ldr	r2, [sp, #24]
 800e0fe:	9c05      	ldr	r4, [sp, #20]
 800e100:	9d06      	ldr	r5, [sp, #24]
 800e102:	6811      	ldr	r1, [r2, #0]
 800e104:	4622      	mov	r2, r4
 800e106:	17e3      	asrs	r3, r4, #31
 800e108:	3504      	adds	r5, #4
 800e10a:	9506      	str	r5, [sp, #24]
 800e10c:	e9c1 2300 	strd	r2, r3, [r1]
 800e110:	f7ff ba86 	b.w	800d620 <_vfiprintf_r+0xa0>
 800e114:	9806      	ldr	r0, [sp, #24]
 800e116:	6804      	ldr	r4, [r0, #0]
 800e118:	3004      	adds	r0, #4
 800e11a:	9006      	str	r0, [sp, #24]
 800e11c:	17e5      	asrs	r5, r4, #31
 800e11e:	2c00      	cmp	r4, #0
 800e120:	f175 0300 	sbcs.w	r3, r5, #0
 800e124:	f6bf abb6 	bge.w	800d894 <_vfiprintf_r+0x314>
 800e128:	4264      	negs	r4, r4
 800e12a:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 800e12e:	232d      	movs	r3, #45	; 0x2d
 800e130:	ea54 0105 	orrs.w	r1, r4, r5
 800e134:	f88d 350f 	strb.w	r3, [sp, #1295]	; 0x50f
 800e138:	bf0c      	ite	eq
 800e13a:	2200      	moveq	r2, #0
 800e13c:	2201      	movne	r2, #1
 800e13e:	2301      	movs	r3, #1
 800e140:	f7ff bb2e 	b.w	800d7a0 <_vfiprintf_r+0x220>
 800e144:	9806      	ldr	r0, [sp, #24]
 800e146:	2500      	movs	r5, #0
 800e148:	6804      	ldr	r4, [r0, #0]
 800e14a:	3004      	adds	r0, #4
 800e14c:	9006      	str	r0, [sp, #24]
 800e14e:	e45d      	b.n	800da0c <_vfiprintf_r+0x48c>
 800e150:	9906      	ldr	r1, [sp, #24]
 800e152:	2301      	movs	r3, #1
 800e154:	680a      	ldr	r2, [r1, #0]
 800e156:	3104      	adds	r1, #4
 800e158:	4614      	mov	r4, r2
 800e15a:	2500      	movs	r5, #0
 800e15c:	3a00      	subs	r2, #0
 800e15e:	9106      	str	r1, [sp, #24]
 800e160:	bf18      	it	ne
 800e162:	2201      	movne	r2, #1
 800e164:	f7ff bb19 	b.w	800d79a <_vfiprintf_r+0x21a>
 800e168:	9906      	ldr	r1, [sp, #24]
 800e16a:	680a      	ldr	r2, [r1, #0]
 800e16c:	e7f3      	b.n	800e156 <_vfiprintf_r+0xbd6>
 800e16e:	f89a 3000 	ldrb.w	r3, [sl]
 800e172:	f7ff ba9b 	b.w	800d6ac <_vfiprintf_r+0x12c>
 800e176:	9901      	ldr	r1, [sp, #4]
 800e178:	f8d1 9008 	ldr.w	r9, [r1, #8]
 800e17c:	f7ff ba25 	b.w	800d5ca <_vfiprintf_r+0x4a>
 800e180:	4d45      	ldr	r5, [pc, #276]	; (800e298 <_vfiprintf_r+0xd18>)
 800e182:	469c      	mov	ip, r3
 800e184:	e581      	b.n	800dc8a <_vfiprintf_r+0x70a>
 800e186:	2100      	movs	r1, #0
 800e188:	9107      	str	r1, [sp, #28]
 800e18a:	f7ff bb4b 	b.w	800d824 <_vfiprintf_r+0x2a4>
 800e18e:	f01b 0f40 	tst.w	fp, #64	; 0x40
 800e192:	d03a      	beq.n	800e20a <_vfiprintf_r+0xc8a>
 800e194:	9a06      	ldr	r2, [sp, #24]
 800e196:	9c05      	ldr	r4, [sp, #20]
 800e198:	6813      	ldr	r3, [r2, #0]
 800e19a:	3204      	adds	r2, #4
 800e19c:	9206      	str	r2, [sp, #24]
 800e19e:	801c      	strh	r4, [r3, #0]
 800e1a0:	f7ff ba3e 	b.w	800d620 <_vfiprintf_r+0xa0>
 800e1a4:	9d06      	ldr	r5, [sp, #24]
 800e1a6:	682a      	ldr	r2, [r5, #0]
 800e1a8:	3504      	adds	r5, #4
 800e1aa:	4614      	mov	r4, r2
 800e1ac:	9506      	str	r5, [sp, #24]
 800e1ae:	2500      	movs	r5, #0
 800e1b0:	3a00      	subs	r2, #0
 800e1b2:	bf18      	it	ne
 800e1b4:	2201      	movne	r2, #1
 800e1b6:	f7ff baf0 	b.w	800d79a <_vfiprintf_r+0x21a>
 800e1ba:	9a06      	ldr	r2, [sp, #24]
 800e1bc:	6814      	ldr	r4, [r2, #0]
 800e1be:	3204      	adds	r2, #4
 800e1c0:	9206      	str	r2, [sp, #24]
 800e1c2:	17e5      	asrs	r5, r4, #31
 800e1c4:	f7ff bb61 	b.w	800d88a <_vfiprintf_r+0x30a>
 800e1c8:	9a06      	ldr	r2, [sp, #24]
 800e1ca:	2500      	movs	r5, #0
 800e1cc:	6814      	ldr	r4, [r2, #0]
 800e1ce:	3204      	adds	r2, #4
 800e1d0:	9206      	str	r2, [sp, #24]
 800e1d2:	e41b      	b.n	800da0c <_vfiprintf_r+0x48c>
 800e1d4:	9d06      	ldr	r5, [sp, #24]
 800e1d6:	2301      	movs	r3, #1
 800e1d8:	682a      	ldr	r2, [r5, #0]
 800e1da:	e7e5      	b.n	800e1a8 <_vfiprintf_r+0xc28>
 800e1dc:	9809      	ldr	r0, [sp, #36]	; 0x24
 800e1de:	2300      	movs	r3, #0
 800e1e0:	9307      	str	r3, [sp, #28]
 800e1e2:	f7fe fb67 	bl	800c8b4 <strlen>
 800e1e6:	9003      	str	r0, [sp, #12]
 800e1e8:	f7ff bb1c 	b.w	800d824 <_vfiprintf_r+0x2a4>
 800e1ec:	f1b8 0f06 	cmp.w	r8, #6
 800e1f0:	bf34      	ite	cc
 800e1f2:	4645      	movcc	r5, r8
 800e1f4:	2506      	movcs	r5, #6
 800e1f6:	f240 40ac 	movw	r0, #1196	; 0x4ac
 800e1fa:	ea25 71e5 	bic.w	r1, r5, r5, asr #31
 800e1fe:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e202:	9503      	str	r5, [sp, #12]
 800e204:	9102      	str	r1, [sp, #8]
 800e206:	9009      	str	r0, [sp, #36]	; 0x24
 800e208:	e422      	b.n	800da50 <_vfiprintf_r+0x4d0>
 800e20a:	9d06      	ldr	r5, [sp, #24]
 800e20c:	9805      	ldr	r0, [sp, #20]
 800e20e:	682b      	ldr	r3, [r5, #0]
 800e210:	3504      	adds	r5, #4
 800e212:	9506      	str	r5, [sp, #24]
 800e214:	6018      	str	r0, [r3, #0]
 800e216:	f7ff ba03 	b.w	800d620 <_vfiprintf_r+0xa0>
 800e21a:	f240 3568 	movw	r5, #872	; 0x368
 800e21e:	f106 0c08 	add.w	ip, r6, #8
 800e222:	f8dd 1508 	ldr.w	r1, [sp, #1288]	; 0x508
 800e226:	f6c0 0501 	movt	r5, #2049	; 0x801
 800e22a:	f8dd 2504 	ldr.w	r2, [sp, #1284]	; 0x504
 800e22e:	e455      	b.n	800dadc <_vfiprintf_r+0x55c>
 800e230:	9c02      	ldr	r4, [sp, #8]
 800e232:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800e234:	f104 0328 	add.w	r3, r4, #40	; 0x28
 800e238:	1b5b      	subs	r3, r3, r5
 800e23a:	9303      	str	r3, [sp, #12]
 800e23c:	f7ff baf0 	b.w	800d820 <_vfiprintf_r+0x2a0>
 800e240:	f240 3568 	movw	r5, #872	; 0x368
 800e244:	f8dd 2504 	ldr.w	r2, [sp, #1284]	; 0x504
 800e248:	f6c0 0501 	movt	r5, #2049	; 0x801
 800e24c:	e57a      	b.n	800dd44 <_vfiprintf_r+0x7c4>
 800e24e:	9801      	ldr	r0, [sp, #4]
 800e250:	4649      	mov	r1, r9
 800e252:	f7fb ff55 	bl	800a100 <__swsetup_r>
 800e256:	b960      	cbnz	r0, 800e272 <_vfiprintf_r+0xcf2>
 800e258:	f8b9 400c 	ldrh.w	r4, [r9, #12]
 800e25c:	b2a3      	uxth	r3, r4
 800e25e:	f7ff b9ce 	b.w	800d5fe <_vfiprintf_r+0x7e>
 800e262:	4d0d      	ldr	r5, [pc, #52]	; (800e298 <_vfiprintf_r+0xd18>)
 800e264:	469c      	mov	ip, r3
 800e266:	e5e2      	b.n	800de2e <_vfiprintf_r+0x8ae>
 800e268:	f8cd 800c 	str.w	r8, [sp, #12]
 800e26c:	9007      	str	r0, [sp, #28]
 800e26e:	f7ff bad9 	b.w	800d824 <_vfiprintf_r+0x2a4>
 800e272:	f04f 32ff 	mov.w	r2, #4294967295
 800e276:	9205      	str	r2, [sp, #20]
 800e278:	e5a0      	b.n	800ddbc <_vfiprintf_r+0x83c>
 800e27a:	9c06      	ldr	r4, [sp, #24]
 800e27c:	1d22      	adds	r2, r4, #4
 800e27e:	f8d4 8000 	ldr.w	r8, [r4]
 800e282:	f1b8 0f00 	cmp.w	r8, #0
 800e286:	f6bf af15 	bge.w	800e0b4 <_vfiprintf_r+0xb34>
 800e28a:	f89a 3000 	ldrb.w	r3, [sl]
 800e28e:	f04f 38ff 	mov.w	r8, #4294967295
 800e292:	9206      	str	r2, [sp, #24]
 800e294:	f7ff ba0a 	b.w	800d6ac <_vfiprintf_r+0x12c>
 800e298:	08010378 	.word	0x08010378

0800e29c <vfiprintf>:
 800e29c:	b430      	push	{r4, r5}
 800e29e:	f240 247c 	movw	r4, #636	; 0x27c
 800e2a2:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800e2a6:	460d      	mov	r5, r1
 800e2a8:	4613      	mov	r3, r2
 800e2aa:	4601      	mov	r1, r0
 800e2ac:	462a      	mov	r2, r5
 800e2ae:	6820      	ldr	r0, [r4, #0]
 800e2b0:	bc30      	pop	{r4, r5}
 800e2b2:	f7ff b965 	b.w	800d580 <_vfiprintf_r>
 800e2b6:	bf00      	nop

0800e2b8 <_calloc_r>:
 800e2b8:	b538      	push	{r3, r4, r5, lr}
 800e2ba:	fb01 f102 	mul.w	r1, r1, r2
 800e2be:	f7f8 f94f 	bl	8006560 <_malloc_r>
 800e2c2:	4604      	mov	r4, r0
 800e2c4:	b1f8      	cbz	r0, 800e306 <_calloc_r+0x4e>
 800e2c6:	f850 2c04 	ldr.w	r2, [r0, #-4]
 800e2ca:	f022 0203 	bic.w	r2, r2, #3
 800e2ce:	3a04      	subs	r2, #4
 800e2d0:	2a24      	cmp	r2, #36	; 0x24
 800e2d2:	d81a      	bhi.n	800e30a <_calloc_r+0x52>
 800e2d4:	2a13      	cmp	r2, #19
 800e2d6:	4603      	mov	r3, r0
 800e2d8:	d90f      	bls.n	800e2fa <_calloc_r+0x42>
 800e2da:	2100      	movs	r1, #0
 800e2dc:	f840 1b04 	str.w	r1, [r0], #4
 800e2e0:	1d03      	adds	r3, r0, #4
 800e2e2:	2a1b      	cmp	r2, #27
 800e2e4:	6061      	str	r1, [r4, #4]
 800e2e6:	d908      	bls.n	800e2fa <_calloc_r+0x42>
 800e2e8:	1d1d      	adds	r5, r3, #4
 800e2ea:	6041      	str	r1, [r0, #4]
 800e2ec:	6059      	str	r1, [r3, #4]
 800e2ee:	3308      	adds	r3, #8
 800e2f0:	2a24      	cmp	r2, #36	; 0x24
 800e2f2:	bf02      	ittt	eq
 800e2f4:	6069      	streq	r1, [r5, #4]
 800e2f6:	6059      	streq	r1, [r3, #4]
 800e2f8:	3308      	addeq	r3, #8
 800e2fa:	461a      	mov	r2, r3
 800e2fc:	2100      	movs	r1, #0
 800e2fe:	f842 1b04 	str.w	r1, [r2], #4
 800e302:	6059      	str	r1, [r3, #4]
 800e304:	6051      	str	r1, [r2, #4]
 800e306:	4620      	mov	r0, r4
 800e308:	bd38      	pop	{r3, r4, r5, pc}
 800e30a:	2100      	movs	r1, #0
 800e30c:	f7fd fca0 	bl	800bc50 <memset>
 800e310:	4620      	mov	r0, r4
 800e312:	bd38      	pop	{r3, r4, r5, pc}

0800e314 <_close_r>:
 800e314:	b538      	push	{r3, r4, r5, lr}
 800e316:	f642 249c 	movw	r4, #10908	; 0x2a9c
 800e31a:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800e31e:	4605      	mov	r5, r0
 800e320:	4608      	mov	r0, r1
 800e322:	2300      	movs	r3, #0
 800e324:	6023      	str	r3, [r4, #0]
 800e326:	f7f2 fc63 	bl	8000bf0 <_close>
 800e32a:	f1b0 3fff 	cmp.w	r0, #4294967295
 800e32e:	d000      	beq.n	800e332 <_close_r+0x1e>
 800e330:	bd38      	pop	{r3, r4, r5, pc}
 800e332:	6823      	ldr	r3, [r4, #0]
 800e334:	2b00      	cmp	r3, #0
 800e336:	d0fb      	beq.n	800e330 <_close_r+0x1c>
 800e338:	602b      	str	r3, [r5, #0]
 800e33a:	bd38      	pop	{r3, r4, r5, pc}

0800e33c <_fclose_r>:
 800e33c:	b570      	push	{r4, r5, r6, lr}
 800e33e:	460c      	mov	r4, r1
 800e340:	4605      	mov	r5, r0
 800e342:	460e      	mov	r6, r1
 800e344:	2900      	cmp	r1, #0
 800e346:	d048      	beq.n	800e3da <_fclose_r+0x9e>
 800e348:	f7fd f938 	bl	800b5bc <__sfp_lock_acquire>
 800e34c:	b115      	cbz	r5, 800e354 <_fclose_r+0x18>
 800e34e:	69ab      	ldr	r3, [r5, #24]
 800e350:	2b00      	cmp	r3, #0
 800e352:	d044      	beq.n	800e3de <_fclose_r+0xa2>
 800e354:	f240 13c0 	movw	r3, #448	; 0x1c0
 800e358:	f6c0 0301 	movt	r3, #2049	; 0x801
 800e35c:	429c      	cmp	r4, r3
 800e35e:	bf08      	it	eq
 800e360:	686c      	ldreq	r4, [r5, #4]
 800e362:	d00e      	beq.n	800e382 <_fclose_r+0x46>
 800e364:	f240 13e0 	movw	r3, #480	; 0x1e0
 800e368:	f6c0 0301 	movt	r3, #2049	; 0x801
 800e36c:	429c      	cmp	r4, r3
 800e36e:	bf08      	it	eq
 800e370:	68ac      	ldreq	r4, [r5, #8]
 800e372:	d006      	beq.n	800e382 <_fclose_r+0x46>
 800e374:	f240 2300 	movw	r3, #512	; 0x200
 800e378:	f6c0 0301 	movt	r3, #2049	; 0x801
 800e37c:	429c      	cmp	r4, r3
 800e37e:	bf08      	it	eq
 800e380:	68ec      	ldreq	r4, [r5, #12]
 800e382:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
 800e386:	b336      	cbz	r6, 800e3d6 <_fclose_r+0x9a>
 800e388:	4628      	mov	r0, r5
 800e38a:	4621      	mov	r1, r4
 800e38c:	f7fc ff30 	bl	800b1f0 <_fflush_r>
 800e390:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800e392:	4606      	mov	r6, r0
 800e394:	b13b      	cbz	r3, 800e3a6 <_fclose_r+0x6a>
 800e396:	4628      	mov	r0, r5
 800e398:	6a21      	ldr	r1, [r4, #32]
 800e39a:	4798      	blx	r3
 800e39c:	ea36 0620 	bics.w	r6, r6, r0, asr #32
 800e3a0:	bf28      	it	cs
 800e3a2:	f04f 36ff 	movcs.w	r6, #4294967295
 800e3a6:	89a3      	ldrh	r3, [r4, #12]
 800e3a8:	f013 0f80 	tst.w	r3, #128	; 0x80
 800e3ac:	d11b      	bne.n	800e3e6 <_fclose_r+0xaa>
 800e3ae:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800e3b0:	b141      	cbz	r1, 800e3c4 <_fclose_r+0x88>
 800e3b2:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800e3b6:	4299      	cmp	r1, r3
 800e3b8:	d002      	beq.n	800e3c0 <_fclose_r+0x84>
 800e3ba:	4628      	mov	r0, r5
 800e3bc:	f7fd f972 	bl	800b6a4 <_free_r>
 800e3c0:	2300      	movs	r3, #0
 800e3c2:	6363      	str	r3, [r4, #52]	; 0x34
 800e3c4:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800e3c6:	b121      	cbz	r1, 800e3d2 <_fclose_r+0x96>
 800e3c8:	4628      	mov	r0, r5
 800e3ca:	f7fd f96b 	bl	800b6a4 <_free_r>
 800e3ce:	2300      	movs	r3, #0
 800e3d0:	64a3      	str	r3, [r4, #72]	; 0x48
 800e3d2:	2300      	movs	r3, #0
 800e3d4:	81a3      	strh	r3, [r4, #12]
 800e3d6:	f7fd f8f3 	bl	800b5c0 <__sfp_lock_release>
 800e3da:	4630      	mov	r0, r6
 800e3dc:	bd70      	pop	{r4, r5, r6, pc}
 800e3de:	4628      	mov	r0, r5
 800e3e0:	f7fd f824 	bl	800b42c <__sinit>
 800e3e4:	e7b6      	b.n	800e354 <_fclose_r+0x18>
 800e3e6:	4628      	mov	r0, r5
 800e3e8:	6921      	ldr	r1, [r4, #16]
 800e3ea:	f7fd f95b 	bl	800b6a4 <_free_r>
 800e3ee:	e7de      	b.n	800e3ae <_fclose_r+0x72>

0800e3f0 <fclose>:
 800e3f0:	f240 237c 	movw	r3, #636	; 0x27c
 800e3f4:	4601      	mov	r1, r0
 800e3f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e3fa:	6818      	ldr	r0, [r3, #0]
 800e3fc:	e79e      	b.n	800e33c <_fclose_r>
 800e3fe:	bf00      	nop

0800e400 <_fputwc_r>:
 800e400:	8993      	ldrh	r3, [r2, #12]
 800e402:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800e406:	f413 5f00 	tst.w	r3, #8192	; 0x2000
 800e40a:	4614      	mov	r4, r2
 800e40c:	bf04      	itt	eq
 800e40e:	f443 5300 	orreq.w	r3, r3, #8192	; 0x2000
 800e412:	6e52      	ldreq	r2, [r2, #100]	; 0x64
 800e414:	b083      	sub	sp, #12
 800e416:	bf08      	it	eq
 800e418:	81a3      	strheq	r3, [r4, #12]
 800e41a:	4607      	mov	r7, r0
 800e41c:	bf04      	itt	eq
 800e41e:	f442 5300 	orreq.w	r3, r2, #8192	; 0x2000
 800e422:	6663      	streq	r3, [r4, #100]	; 0x64
 800e424:	460e      	mov	r6, r1
 800e426:	f7fd fa93 	bl	800b950 <__locale_mb_cur_max>
 800e42a:	2801      	cmp	r0, #1
 800e42c:	d04c      	beq.n	800e4c8 <_fputwc_r+0xc8>
 800e42e:	ad01      	add	r5, sp, #4
 800e430:	4638      	mov	r0, r7
 800e432:	4629      	mov	r1, r5
 800e434:	4632      	mov	r2, r6
 800e436:	f104 035c 	add.w	r3, r4, #92	; 0x5c
 800e43a:	f000 fd43 	bl	800eec4 <_wcrtomb_r>
 800e43e:	f1b0 3fff 	cmp.w	r0, #4294967295
 800e442:	4681      	mov	r9, r0
 800e444:	d029      	beq.n	800e49a <_fputwc_r+0x9a>
 800e446:	2800      	cmp	r0, #0
 800e448:	d03c      	beq.n	800e4c4 <_fputwc_r+0xc4>
 800e44a:	f04f 0800 	mov.w	r8, #0
 800e44e:	e00a      	b.n	800e466 <_fputwc_r+0x66>
 800e450:	6823      	ldr	r3, [r4, #0]
 800e452:	f815 2008 	ldrb.w	r2, [r5, r8]
 800e456:	701a      	strb	r2, [r3, #0]
 800e458:	6823      	ldr	r3, [r4, #0]
 800e45a:	3301      	adds	r3, #1
 800e45c:	6023      	str	r3, [r4, #0]
 800e45e:	f108 0801 	add.w	r8, r8, #1
 800e462:	45c8      	cmp	r8, r9
 800e464:	d22e      	bcs.n	800e4c4 <_fputwc_r+0xc4>
 800e466:	68a3      	ldr	r3, [r4, #8]
 800e468:	3b01      	subs	r3, #1
 800e46a:	60a3      	str	r3, [r4, #8]
 800e46c:	2b00      	cmp	r3, #0
 800e46e:	daef      	bge.n	800e450 <_fputwc_r+0x50>
 800e470:	69a2      	ldr	r2, [r4, #24]
 800e472:	2000      	movs	r0, #0
 800e474:	4293      	cmp	r3, r2
 800e476:	db17      	blt.n	800e4a8 <_fputwc_r+0xa8>
 800e478:	6823      	ldr	r3, [r4, #0]
 800e47a:	f815 2008 	ldrb.w	r2, [r5, r8]
 800e47e:	701a      	strb	r2, [r3, #0]
 800e480:	6823      	ldr	r3, [r4, #0]
 800e482:	1c5a      	adds	r2, r3, #1
 800e484:	7819      	ldrb	r1, [r3, #0]
 800e486:	290a      	cmp	r1, #10
 800e488:	bf14      	ite	ne
 800e48a:	6022      	strne	r2, [r4, #0]
 800e48c:	4638      	moveq	r0, r7
 800e48e:	d00e      	beq.n	800e4ae <_fputwc_r+0xae>
 800e490:	2800      	cmp	r0, #0
 800e492:	d0e4      	beq.n	800e45e <_fputwc_r+0x5e>
 800e494:	f04f 30ff 	mov.w	r0, #4294967295
 800e498:	e003      	b.n	800e4a2 <_fputwc_r+0xa2>
 800e49a:	89a3      	ldrh	r3, [r4, #12]
 800e49c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800e4a0:	81a3      	strh	r3, [r4, #12]
 800e4a2:	b003      	add	sp, #12
 800e4a4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800e4a8:	f815 1008 	ldrb.w	r1, [r5, r8]
 800e4ac:	4638      	mov	r0, r7
 800e4ae:	4622      	mov	r2, r4
 800e4b0:	f000 fc8a 	bl	800edc8 <__swbuf_r>
 800e4b4:	f1a0 33ff 	sub.w	r3, r0, #4294967295
 800e4b8:	4258      	negs	r0, r3
 800e4ba:	eb40 0003 	adc.w	r0, r0, r3
 800e4be:	2800      	cmp	r0, #0
 800e4c0:	d0cd      	beq.n	800e45e <_fputwc_r+0x5e>
 800e4c2:	e7e7      	b.n	800e494 <_fputwc_r+0x94>
 800e4c4:	4630      	mov	r0, r6
 800e4c6:	e7ec      	b.n	800e4a2 <_fputwc_r+0xa2>
 800e4c8:	1e33      	subs	r3, r6, #0
 800e4ca:	bf18      	it	ne
 800e4cc:	2301      	movne	r3, #1
 800e4ce:	2eff      	cmp	r6, #255	; 0xff
 800e4d0:	bf8c      	ite	hi
 800e4d2:	2300      	movhi	r3, #0
 800e4d4:	f003 0301 	andls.w	r3, r3, #1
 800e4d8:	2b00      	cmp	r3, #0
 800e4da:	d0a8      	beq.n	800e42e <_fputwc_r+0x2e>
 800e4dc:	ad02      	add	r5, sp, #8
 800e4de:	4681      	mov	r9, r0
 800e4e0:	f805 6d04 	strb.w	r6, [r5, #-4]!
 800e4e4:	e7b1      	b.n	800e44a <_fputwc_r+0x4a>
 800e4e6:	bf00      	nop

0800e4e8 <fputwc>:
 800e4e8:	b570      	push	{r4, r5, r6, lr}
 800e4ea:	f240 257c 	movw	r5, #636	; 0x27c
 800e4ee:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800e4f2:	4606      	mov	r6, r0
 800e4f4:	460c      	mov	r4, r1
 800e4f6:	6828      	ldr	r0, [r5, #0]
 800e4f8:	b108      	cbz	r0, 800e4fe <fputwc+0x16>
 800e4fa:	6983      	ldr	r3, [r0, #24]
 800e4fc:	b1db      	cbz	r3, 800e536 <fputwc+0x4e>
 800e4fe:	f240 13c0 	movw	r3, #448	; 0x1c0
 800e502:	f6c0 0301 	movt	r3, #2049	; 0x801
 800e506:	429c      	cmp	r4, r3
 800e508:	bf08      	it	eq
 800e50a:	6844      	ldreq	r4, [r0, #4]
 800e50c:	d00e      	beq.n	800e52c <fputwc+0x44>
 800e50e:	f240 13e0 	movw	r3, #480	; 0x1e0
 800e512:	f6c0 0301 	movt	r3, #2049	; 0x801
 800e516:	429c      	cmp	r4, r3
 800e518:	bf08      	it	eq
 800e51a:	6884      	ldreq	r4, [r0, #8]
 800e51c:	d006      	beq.n	800e52c <fputwc+0x44>
 800e51e:	f240 2300 	movw	r3, #512	; 0x200
 800e522:	f6c0 0301 	movt	r3, #2049	; 0x801
 800e526:	429c      	cmp	r4, r3
 800e528:	bf08      	it	eq
 800e52a:	68c4      	ldreq	r4, [r0, #12]
 800e52c:	4631      	mov	r1, r6
 800e52e:	4622      	mov	r2, r4
 800e530:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800e534:	e764      	b.n	800e400 <_fputwc_r>
 800e536:	f7fc ff79 	bl	800b42c <__sinit>
 800e53a:	6828      	ldr	r0, [r5, #0]
 800e53c:	e7df      	b.n	800e4fe <fputwc+0x16>
 800e53e:	bf00      	nop

0800e540 <_fstat_r>:
 800e540:	b538      	push	{r3, r4, r5, lr}
 800e542:	f642 249c 	movw	r4, #10908	; 0x2a9c
 800e546:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800e54a:	4605      	mov	r5, r0
 800e54c:	4608      	mov	r0, r1
 800e54e:	4611      	mov	r1, r2
 800e550:	2300      	movs	r3, #0
 800e552:	6023      	str	r3, [r4, #0]
 800e554:	f7f2 fb4e 	bl	8000bf4 <_fstat>
 800e558:	f1b0 3fff 	cmp.w	r0, #4294967295
 800e55c:	d000      	beq.n	800e560 <_fstat_r+0x20>
 800e55e:	bd38      	pop	{r3, r4, r5, pc}
 800e560:	6823      	ldr	r3, [r4, #0]
 800e562:	2b00      	cmp	r3, #0
 800e564:	d0fb      	beq.n	800e55e <_fstat_r+0x1e>
 800e566:	602b      	str	r3, [r5, #0]
 800e568:	bd38      	pop	{r3, r4, r5, pc}
 800e56a:	bf00      	nop

0800e56c <__sfvwrite_r>:
 800e56c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e570:	b085      	sub	sp, #20
 800e572:	4690      	mov	r8, r2
 800e574:	460c      	mov	r4, r1
 800e576:	9002      	str	r0, [sp, #8]
 800e578:	6890      	ldr	r0, [r2, #8]
 800e57a:	2800      	cmp	r0, #0
 800e57c:	f000 8089 	beq.w	800e692 <__sfvwrite_r+0x126>
 800e580:	898b      	ldrh	r3, [r1, #12]
 800e582:	fa1f f983 	uxth.w	r9, r3
 800e586:	f019 0f08 	tst.w	r9, #8
 800e58a:	f000 80a3 	beq.w	800e6d4 <__sfvwrite_r+0x168>
 800e58e:	690a      	ldr	r2, [r1, #16]
 800e590:	2a00      	cmp	r2, #0
 800e592:	f000 809f 	beq.w	800e6d4 <__sfvwrite_r+0x168>
 800e596:	f019 0b02 	ands.w	fp, r9, #2
 800e59a:	f8d8 5000 	ldr.w	r5, [r8]
 800e59e:	bf1c      	itt	ne
 800e5a0:	f04f 0900 	movne.w	r9, #0
 800e5a4:	464f      	movne	r7, r9
 800e5a6:	d17b      	bne.n	800e6a0 <__sfvwrite_r+0x134>
 800e5a8:	f019 0901 	ands.w	r9, r9, #1
 800e5ac:	bf1d      	ittte	ne
 800e5ae:	46dc      	movne	ip, fp
 800e5b0:	46da      	movne	sl, fp
 800e5b2:	465f      	movne	r7, fp
 800e5b4:	464e      	moveq	r6, r9
 800e5b6:	d136      	bne.n	800e626 <__sfvwrite_r+0xba>
 800e5b8:	b356      	cbz	r6, 800e610 <__sfvwrite_r+0xa4>
 800e5ba:	b29b      	uxth	r3, r3
 800e5bc:	68a7      	ldr	r7, [r4, #8]
 800e5be:	f413 7f00 	tst.w	r3, #512	; 0x200
 800e5c2:	f000 8092 	beq.w	800e6ea <__sfvwrite_r+0x17e>
 800e5c6:	42be      	cmp	r6, r7
 800e5c8:	46bb      	mov	fp, r7
 800e5ca:	f0c0 80b4 	bcc.w	800e736 <__sfvwrite_r+0x1ca>
 800e5ce:	f413 6f90 	tst.w	r3, #1152	; 0x480
 800e5d2:	f040 8117 	bne.w	800e804 <__sfvwrite_r+0x298>
 800e5d6:	6820      	ldr	r0, [r4, #0]
 800e5d8:	9703      	str	r7, [sp, #12]
 800e5da:	4637      	mov	r7, r6
 800e5dc:	4649      	mov	r1, r9
 800e5de:	465a      	mov	r2, fp
 800e5e0:	f000 f98a 	bl	800e8f8 <memmove>
 800e5e4:	46b2      	mov	sl, r6
 800e5e6:	68a2      	ldr	r2, [r4, #8]
 800e5e8:	6823      	ldr	r3, [r4, #0]
 800e5ea:	9903      	ldr	r1, [sp, #12]
 800e5ec:	445b      	add	r3, fp
 800e5ee:	6023      	str	r3, [r4, #0]
 800e5f0:	1a52      	subs	r2, r2, r1
 800e5f2:	60a2      	str	r2, [r4, #8]
 800e5f4:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800e5f8:	44d1      	add	r9, sl
 800e5fa:	ebca 0606 	rsb	r6, sl, r6
 800e5fe:	1bdf      	subs	r7, r3, r7
 800e600:	f8c8 7008 	str.w	r7, [r8, #8]
 800e604:	2f00      	cmp	r7, #0
 800e606:	f000 8094 	beq.w	800e732 <__sfvwrite_r+0x1c6>
 800e60a:	89a3      	ldrh	r3, [r4, #12]
 800e60c:	2e00      	cmp	r6, #0
 800e60e:	d1d4      	bne.n	800e5ba <__sfvwrite_r+0x4e>
 800e610:	f8d5 9000 	ldr.w	r9, [r5]
 800e614:	686e      	ldr	r6, [r5, #4]
 800e616:	3508      	adds	r5, #8
 800e618:	e7ce      	b.n	800e5b8 <__sfvwrite_r+0x4c>
 800e61a:	f8d5 a000 	ldr.w	sl, [r5]
 800e61e:	f04f 0c00 	mov.w	ip, #0
 800e622:	686f      	ldr	r7, [r5, #4]
 800e624:	3508      	adds	r5, #8
 800e626:	2f00      	cmp	r7, #0
 800e628:	d0f7      	beq.n	800e61a <__sfvwrite_r+0xae>
 800e62a:	f1bc 0f00 	cmp.w	ip, #0
 800e62e:	f000 80ba 	beq.w	800e7a6 <__sfvwrite_r+0x23a>
 800e632:	6922      	ldr	r2, [r4, #16]
 800e634:	45bb      	cmp	fp, r7
 800e636:	bf34      	ite	cc
 800e638:	46d9      	movcc	r9, fp
 800e63a:	46b9      	movcs	r9, r7
 800e63c:	6820      	ldr	r0, [r4, #0]
 800e63e:	6963      	ldr	r3, [r4, #20]
 800e640:	68a6      	ldr	r6, [r4, #8]
 800e642:	4290      	cmp	r0, r2
 800e644:	bf94      	ite	ls
 800e646:	2200      	movls	r2, #0
 800e648:	2201      	movhi	r2, #1
 800e64a:	199e      	adds	r6, r3, r6
 800e64c:	45b1      	cmp	r9, r6
 800e64e:	bfd4      	ite	le
 800e650:	2200      	movle	r2, #0
 800e652:	f002 0201 	andgt.w	r2, r2, #1
 800e656:	2a00      	cmp	r2, #0
 800e658:	f040 808c 	bne.w	800e774 <__sfvwrite_r+0x208>
 800e65c:	4599      	cmp	r9, r3
 800e65e:	db6f      	blt.n	800e740 <__sfvwrite_r+0x1d4>
 800e660:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 800e662:	4652      	mov	r2, sl
 800e664:	6a21      	ldr	r1, [r4, #32]
 800e666:	9802      	ldr	r0, [sp, #8]
 800e668:	f8cd c004 	str.w	ip, [sp, #4]
 800e66c:	47b0      	blx	r6
 800e66e:	f8dd c004 	ldr.w	ip, [sp, #4]
 800e672:	1e06      	subs	r6, r0, #0
 800e674:	f340 8090 	ble.w	800e798 <__sfvwrite_r+0x22c>
 800e678:	ebbb 0b06 	subs.w	fp, fp, r6
 800e67c:	d073      	beq.n	800e766 <__sfvwrite_r+0x1fa>
 800e67e:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800e682:	44b2      	add	sl, r6
 800e684:	1bbf      	subs	r7, r7, r6
 800e686:	1b9e      	subs	r6, r3, r6
 800e688:	f8c8 6008 	str.w	r6, [r8, #8]
 800e68c:	2e00      	cmp	r6, #0
 800e68e:	d1ca      	bne.n	800e626 <__sfvwrite_r+0xba>
 800e690:	4630      	mov	r0, r6
 800e692:	b005      	add	sp, #20
 800e694:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800e698:	f8d5 9000 	ldr.w	r9, [r5]
 800e69c:	686f      	ldr	r7, [r5, #4]
 800e69e:	3508      	adds	r5, #8
 800e6a0:	f5b7 6f80 	cmp.w	r7, #1024	; 0x400
 800e6a4:	bf34      	ite	cc
 800e6a6:	463b      	movcc	r3, r7
 800e6a8:	f44f 6380 	movcs.w	r3, #1024	; 0x400
 800e6ac:	464a      	mov	r2, r9
 800e6ae:	9802      	ldr	r0, [sp, #8]
 800e6b0:	2f00      	cmp	r7, #0
 800e6b2:	d0f1      	beq.n	800e698 <__sfvwrite_r+0x12c>
 800e6b4:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 800e6b6:	6a21      	ldr	r1, [r4, #32]
 800e6b8:	47b0      	blx	r6
 800e6ba:	2800      	cmp	r0, #0
 800e6bc:	4481      	add	r9, r0
 800e6be:	ebc0 0707 	rsb	r7, r0, r7
 800e6c2:	dd69      	ble.n	800e798 <__sfvwrite_r+0x22c>
 800e6c4:	f8d8 6008 	ldr.w	r6, [r8, #8]
 800e6c8:	1a30      	subs	r0, r6, r0
 800e6ca:	f8c8 0008 	str.w	r0, [r8, #8]
 800e6ce:	2800      	cmp	r0, #0
 800e6d0:	d1e6      	bne.n	800e6a0 <__sfvwrite_r+0x134>
 800e6d2:	e7de      	b.n	800e692 <__sfvwrite_r+0x126>
 800e6d4:	9802      	ldr	r0, [sp, #8]
 800e6d6:	4621      	mov	r1, r4
 800e6d8:	f7fb fd12 	bl	800a100 <__swsetup_r>
 800e6dc:	2800      	cmp	r0, #0
 800e6de:	f040 80d2 	bne.w	800e886 <__sfvwrite_r+0x31a>
 800e6e2:	89a3      	ldrh	r3, [r4, #12]
 800e6e4:	fa1f f983 	uxth.w	r9, r3
 800e6e8:	e755      	b.n	800e596 <__sfvwrite_r+0x2a>
 800e6ea:	6923      	ldr	r3, [r4, #16]
 800e6ec:	46ba      	mov	sl, r7
 800e6ee:	6820      	ldr	r0, [r4, #0]
 800e6f0:	4298      	cmp	r0, r3
 800e6f2:	bf94      	ite	ls
 800e6f4:	2300      	movls	r3, #0
 800e6f6:	2301      	movhi	r3, #1
 800e6f8:	42b7      	cmp	r7, r6
 800e6fa:	bf2c      	ite	cs
 800e6fc:	2300      	movcs	r3, #0
 800e6fe:	f003 0301 	andcc.w	r3, r3, #1
 800e702:	2b00      	cmp	r3, #0
 800e704:	d16f      	bne.n	800e7e6 <__sfvwrite_r+0x27a>
 800e706:	6963      	ldr	r3, [r4, #20]
 800e708:	429e      	cmp	r6, r3
 800e70a:	d35f      	bcc.n	800e7cc <__sfvwrite_r+0x260>
 800e70c:	6aa7      	ldr	r7, [r4, #40]	; 0x28
 800e70e:	464a      	mov	r2, r9
 800e710:	9802      	ldr	r0, [sp, #8]
 800e712:	6a21      	ldr	r1, [r4, #32]
 800e714:	47b8      	blx	r7
 800e716:	1e07      	subs	r7, r0, #0
 800e718:	dd3e      	ble.n	800e798 <__sfvwrite_r+0x22c>
 800e71a:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800e71e:	46ba      	mov	sl, r7
 800e720:	44d1      	add	r9, sl
 800e722:	ebca 0606 	rsb	r6, sl, r6
 800e726:	1bdf      	subs	r7, r3, r7
 800e728:	f8c8 7008 	str.w	r7, [r8, #8]
 800e72c:	2f00      	cmp	r7, #0
 800e72e:	f47f af6c 	bne.w	800e60a <__sfvwrite_r+0x9e>
 800e732:	4638      	mov	r0, r7
 800e734:	e7ad      	b.n	800e692 <__sfvwrite_r+0x126>
 800e736:	6820      	ldr	r0, [r4, #0]
 800e738:	46b3      	mov	fp, r6
 800e73a:	9603      	str	r6, [sp, #12]
 800e73c:	4637      	mov	r7, r6
 800e73e:	e74d      	b.n	800e5dc <__sfvwrite_r+0x70>
 800e740:	464a      	mov	r2, r9
 800e742:	4651      	mov	r1, sl
 800e744:	464e      	mov	r6, r9
 800e746:	f8cd c004 	str.w	ip, [sp, #4]
 800e74a:	f000 f8d5 	bl	800e8f8 <memmove>
 800e74e:	68a2      	ldr	r2, [r4, #8]
 800e750:	6823      	ldr	r3, [r4, #0]
 800e752:	ebbb 0b06 	subs.w	fp, fp, r6
 800e756:	ebc9 0202 	rsb	r2, r9, r2
 800e75a:	f8dd c004 	ldr.w	ip, [sp, #4]
 800e75e:	444b      	add	r3, r9
 800e760:	60a2      	str	r2, [r4, #8]
 800e762:	6023      	str	r3, [r4, #0]
 800e764:	d18b      	bne.n	800e67e <__sfvwrite_r+0x112>
 800e766:	9802      	ldr	r0, [sp, #8]
 800e768:	4621      	mov	r1, r4
 800e76a:	f7fc fd41 	bl	800b1f0 <_fflush_r>
 800e76e:	b998      	cbnz	r0, 800e798 <__sfvwrite_r+0x22c>
 800e770:	46dc      	mov	ip, fp
 800e772:	e784      	b.n	800e67e <__sfvwrite_r+0x112>
 800e774:	4651      	mov	r1, sl
 800e776:	4632      	mov	r2, r6
 800e778:	f8cd c004 	str.w	ip, [sp, #4]
 800e77c:	f000 f8bc 	bl	800e8f8 <memmove>
 800e780:	6823      	ldr	r3, [r4, #0]
 800e782:	4621      	mov	r1, r4
 800e784:	9802      	ldr	r0, [sp, #8]
 800e786:	199b      	adds	r3, r3, r6
 800e788:	6023      	str	r3, [r4, #0]
 800e78a:	f7fc fd31 	bl	800b1f0 <_fflush_r>
 800e78e:	f8dd c004 	ldr.w	ip, [sp, #4]
 800e792:	2800      	cmp	r0, #0
 800e794:	f43f af70 	beq.w	800e678 <__sfvwrite_r+0x10c>
 800e798:	89a3      	ldrh	r3, [r4, #12]
 800e79a:	f04f 30ff 	mov.w	r0, #4294967295
 800e79e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800e7a2:	81a3      	strh	r3, [r4, #12]
 800e7a4:	e775      	b.n	800e692 <__sfvwrite_r+0x126>
 800e7a6:	4650      	mov	r0, sl
 800e7a8:	210a      	movs	r1, #10
 800e7aa:	463a      	mov	r2, r7
 800e7ac:	f107 0b01 	add.w	fp, r7, #1
 800e7b0:	f7fd f960 	bl	800ba74 <memchr>
 800e7b4:	f04f 0c01 	mov.w	ip, #1
 800e7b8:	2800      	cmp	r0, #0
 800e7ba:	f43f af3a 	beq.w	800e632 <__sfvwrite_r+0xc6>
 800e7be:	f100 0b01 	add.w	fp, r0, #1
 800e7c2:	f04f 0c01 	mov.w	ip, #1
 800e7c6:	ebca 0b0b 	rsb	fp, sl, fp
 800e7ca:	e732      	b.n	800e632 <__sfvwrite_r+0xc6>
 800e7cc:	4632      	mov	r2, r6
 800e7ce:	4649      	mov	r1, r9
 800e7d0:	f000 f892 	bl	800e8f8 <memmove>
 800e7d4:	68a2      	ldr	r2, [r4, #8]
 800e7d6:	6823      	ldr	r3, [r4, #0]
 800e7d8:	4637      	mov	r7, r6
 800e7da:	1b92      	subs	r2, r2, r6
 800e7dc:	46b2      	mov	sl, r6
 800e7de:	199b      	adds	r3, r3, r6
 800e7e0:	60a2      	str	r2, [r4, #8]
 800e7e2:	6023      	str	r3, [r4, #0]
 800e7e4:	e706      	b.n	800e5f4 <__sfvwrite_r+0x88>
 800e7e6:	4649      	mov	r1, r9
 800e7e8:	463a      	mov	r2, r7
 800e7ea:	f000 f885 	bl	800e8f8 <memmove>
 800e7ee:	6823      	ldr	r3, [r4, #0]
 800e7f0:	9802      	ldr	r0, [sp, #8]
 800e7f2:	4621      	mov	r1, r4
 800e7f4:	19db      	adds	r3, r3, r7
 800e7f6:	6023      	str	r3, [r4, #0]
 800e7f8:	f7fc fcfa 	bl	800b1f0 <_fflush_r>
 800e7fc:	2800      	cmp	r0, #0
 800e7fe:	f43f aef9 	beq.w	800e5f4 <__sfvwrite_r+0x88>
 800e802:	e7c9      	b.n	800e798 <__sfvwrite_r+0x22c>
 800e804:	6967      	ldr	r7, [r4, #20]
 800e806:	6822      	ldr	r2, [r4, #0]
 800e808:	6921      	ldr	r1, [r4, #16]
 800e80a:	eb07 0747 	add.w	r7, r7, r7, lsl #1
 800e80e:	ebc1 0a02 	rsb	sl, r1, r2
 800e812:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
 800e816:	f10a 0001 	add.w	r0, sl, #1
 800e81a:	1980      	adds	r0, r0, r6
 800e81c:	107f      	asrs	r7, r7, #1
 800e81e:	4287      	cmp	r7, r0
 800e820:	463a      	mov	r2, r7
 800e822:	bf3c      	itt	cc
 800e824:	4607      	movcc	r7, r0
 800e826:	4602      	movcc	r2, r0
 800e828:	f413 6f80 	tst.w	r3, #1024	; 0x400
 800e82c:	d01d      	beq.n	800e86a <__sfvwrite_r+0x2fe>
 800e82e:	9802      	ldr	r0, [sp, #8]
 800e830:	4611      	mov	r1, r2
 800e832:	f7f7 fe95 	bl	8006560 <_malloc_r>
 800e836:	4683      	mov	fp, r0
 800e838:	2800      	cmp	r0, #0
 800e83a:	d02e      	beq.n	800e89a <__sfvwrite_r+0x32e>
 800e83c:	6921      	ldr	r1, [r4, #16]
 800e83e:	4652      	mov	r2, sl
 800e840:	f7fd f95e 	bl	800bb00 <memcpy>
 800e844:	89a3      	ldrh	r3, [r4, #12]
 800e846:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 800e84a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800e84e:	81a3      	strh	r3, [r4, #12]
 800e850:	eb0b 000a 	add.w	r0, fp, sl
 800e854:	ebca 0307 	rsb	r3, sl, r7
 800e858:	f8c4 b010 	str.w	fp, [r4, #16]
 800e85c:	46b3      	mov	fp, r6
 800e85e:	6167      	str	r7, [r4, #20]
 800e860:	4637      	mov	r7, r6
 800e862:	9603      	str	r6, [sp, #12]
 800e864:	6020      	str	r0, [r4, #0]
 800e866:	60a3      	str	r3, [r4, #8]
 800e868:	e6b8      	b.n	800e5dc <__sfvwrite_r+0x70>
 800e86a:	9802      	ldr	r0, [sp, #8]
 800e86c:	f000 f89e 	bl	800e9ac <_realloc_r>
 800e870:	4683      	mov	fp, r0
 800e872:	2800      	cmp	r0, #0
 800e874:	d1ec      	bne.n	800e850 <__sfvwrite_r+0x2e4>
 800e876:	6921      	ldr	r1, [r4, #16]
 800e878:	9802      	ldr	r0, [sp, #8]
 800e87a:	f7fc ff13 	bl	800b6a4 <_free_r>
 800e87e:	9902      	ldr	r1, [sp, #8]
 800e880:	230c      	movs	r3, #12
 800e882:	600b      	str	r3, [r1, #0]
 800e884:	e788      	b.n	800e798 <__sfvwrite_r+0x22c>
 800e886:	9902      	ldr	r1, [sp, #8]
 800e888:	f04f 30ff 	mov.w	r0, #4294967295
 800e88c:	89a3      	ldrh	r3, [r4, #12]
 800e88e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800e892:	81a3      	strh	r3, [r4, #12]
 800e894:	2309      	movs	r3, #9
 800e896:	600b      	str	r3, [r1, #0]
 800e898:	e6fb      	b.n	800e692 <__sfvwrite_r+0x126>
 800e89a:	9a02      	ldr	r2, [sp, #8]
 800e89c:	230c      	movs	r3, #12
 800e89e:	6013      	str	r3, [r2, #0]
 800e8a0:	e77a      	b.n	800e798 <__sfvwrite_r+0x22c>
 800e8a2:	bf00      	nop

0800e8a4 <_isatty_r>:
 800e8a4:	b538      	push	{r3, r4, r5, lr}
 800e8a6:	f642 249c 	movw	r4, #10908	; 0x2a9c
 800e8aa:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800e8ae:	4605      	mov	r5, r0
 800e8b0:	4608      	mov	r0, r1
 800e8b2:	2300      	movs	r3, #0
 800e8b4:	6023      	str	r3, [r4, #0]
 800e8b6:	f7f2 f99f 	bl	8000bf8 <_isatty>
 800e8ba:	f1b0 3fff 	cmp.w	r0, #4294967295
 800e8be:	d000      	beq.n	800e8c2 <_isatty_r+0x1e>
 800e8c0:	bd38      	pop	{r3, r4, r5, pc}
 800e8c2:	6823      	ldr	r3, [r4, #0]
 800e8c4:	2b00      	cmp	r3, #0
 800e8c6:	d0fb      	beq.n	800e8c0 <_isatty_r+0x1c>
 800e8c8:	602b      	str	r3, [r5, #0]
 800e8ca:	bd38      	pop	{r3, r4, r5, pc}

0800e8cc <_lseek_r>:
 800e8cc:	b538      	push	{r3, r4, r5, lr}
 800e8ce:	f642 249c 	movw	r4, #10908	; 0x2a9c
 800e8d2:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800e8d6:	4605      	mov	r5, r0
 800e8d8:	4608      	mov	r0, r1
 800e8da:	4611      	mov	r1, r2
 800e8dc:	461a      	mov	r2, r3
 800e8de:	2300      	movs	r3, #0
 800e8e0:	6023      	str	r3, [r4, #0]
 800e8e2:	f7f2 f98b 	bl	8000bfc <_lseek>
 800e8e6:	f1b0 3fff 	cmp.w	r0, #4294967295
 800e8ea:	d000      	beq.n	800e8ee <_lseek_r+0x22>
 800e8ec:	bd38      	pop	{r3, r4, r5, pc}
 800e8ee:	6823      	ldr	r3, [r4, #0]
 800e8f0:	2b00      	cmp	r3, #0
 800e8f2:	d0fb      	beq.n	800e8ec <_lseek_r+0x20>
 800e8f4:	602b      	str	r3, [r5, #0]
 800e8f6:	bd38      	pop	{r3, r4, r5, pc}

0800e8f8 <memmove>:
 800e8f8:	4288      	cmp	r0, r1
 800e8fa:	4603      	mov	r3, r0
 800e8fc:	b4f0      	push	{r4, r5, r6, r7}
 800e8fe:	460c      	mov	r4, r1
 800e900:	d90e      	bls.n	800e920 <memmove+0x28>
 800e902:	188d      	adds	r5, r1, r2
 800e904:	42a8      	cmp	r0, r5
 800e906:	d20b      	bcs.n	800e920 <memmove+0x28>
 800e908:	b142      	cbz	r2, 800e91c <memmove+0x24>
 800e90a:	1883      	adds	r3, r0, r2
 800e90c:	4629      	mov	r1, r5
 800e90e:	1a9a      	subs	r2, r3, r2
 800e910:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
 800e914:	f803 4d01 	strb.w	r4, [r3, #-1]!
 800e918:	4293      	cmp	r3, r2
 800e91a:	d1f9      	bne.n	800e910 <memmove+0x18>
 800e91c:	bcf0      	pop	{r4, r5, r6, r7}
 800e91e:	4770      	bx	lr
 800e920:	2a0f      	cmp	r2, #15
 800e922:	d938      	bls.n	800e996 <memmove+0x9e>
 800e924:	ea41 0500 	orr.w	r5, r1, r0
 800e928:	f015 0f03 	tst.w	r5, #3
 800e92c:	d135      	bne.n	800e99a <memmove+0xa2>
 800e92e:	f1a2 0610 	sub.w	r6, r2, #16
 800e932:	f101 0510 	add.w	r5, r1, #16
 800e936:	460b      	mov	r3, r1
 800e938:	4602      	mov	r2, r0
 800e93a:	0937      	lsrs	r7, r6, #4
 800e93c:	eb05 1507 	add.w	r5, r5, r7, lsl #4
 800e940:	681c      	ldr	r4, [r3, #0]
 800e942:	6014      	str	r4, [r2, #0]
 800e944:	685c      	ldr	r4, [r3, #4]
 800e946:	6054      	str	r4, [r2, #4]
 800e948:	689c      	ldr	r4, [r3, #8]
 800e94a:	6094      	str	r4, [r2, #8]
 800e94c:	68dc      	ldr	r4, [r3, #12]
 800e94e:	3310      	adds	r3, #16
 800e950:	60d4      	str	r4, [r2, #12]
 800e952:	3210      	adds	r2, #16
 800e954:	429d      	cmp	r5, r3
 800e956:	d1f3      	bne.n	800e940 <memmove+0x48>
 800e958:	1c7c      	adds	r4, r7, #1
 800e95a:	f006 020f 	and.w	r2, r6, #15
 800e95e:	0124      	lsls	r4, r4, #4
 800e960:	2a03      	cmp	r2, #3
 800e962:	eb00 0304 	add.w	r3, r0, r4
 800e966:	4421      	add	r1, r4
 800e968:	d914      	bls.n	800e994 <memmove+0x9c>
 800e96a:	3a04      	subs	r2, #4
 800e96c:	460c      	mov	r4, r1
 800e96e:	461d      	mov	r5, r3
 800e970:	ea4f 0c92 	mov.w	ip, r2, lsr #2
 800e974:	eb01 078c 	add.w	r7, r1, ip, lsl #2
 800e978:	3704      	adds	r7, #4
 800e97a:	f854 6b04 	ldr.w	r6, [r4], #4
 800e97e:	42bc      	cmp	r4, r7
 800e980:	f845 6b04 	str.w	r6, [r5], #4
 800e984:	d1f9      	bne.n	800e97a <memmove+0x82>
 800e986:	f10c 0401 	add.w	r4, ip, #1
 800e98a:	f002 0203 	and.w	r2, r2, #3
 800e98e:	00a4      	lsls	r4, r4, #2
 800e990:	191b      	adds	r3, r3, r4
 800e992:	1909      	adds	r1, r1, r4
 800e994:	460c      	mov	r4, r1
 800e996:	2a00      	cmp	r2, #0
 800e998:	d0c0      	beq.n	800e91c <memmove+0x24>
 800e99a:	4621      	mov	r1, r4
 800e99c:	18a2      	adds	r2, r4, r2
 800e99e:	f811 4b01 	ldrb.w	r4, [r1], #1
 800e9a2:	4291      	cmp	r1, r2
 800e9a4:	f803 4b01 	strb.w	r4, [r3], #1
 800e9a8:	d1f9      	bne.n	800e99e <memmove+0xa6>
 800e9aa:	e7b7      	b.n	800e91c <memmove+0x24>

0800e9ac <_realloc_r>:
 800e9ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e9b0:	460d      	mov	r5, r1
 800e9b2:	b083      	sub	sp, #12
 800e9b4:	4607      	mov	r7, r0
 800e9b6:	4690      	mov	r8, r2
 800e9b8:	2900      	cmp	r1, #0
 800e9ba:	f000 8155 	beq.w	800ec68 <_realloc_r+0x2bc>
 800e9be:	f108 040b 	add.w	r4, r8, #11
 800e9c2:	f1a1 0a08 	sub.w	sl, r1, #8
 800e9c6:	f7f8 f889 	bl	8006adc <__malloc_lock>
 800e9ca:	2c16      	cmp	r4, #22
 800e9cc:	f8da 3004 	ldr.w	r3, [sl, #4]
 800e9d0:	f200 8097 	bhi.w	800eb02 <_realloc_r+0x156>
 800e9d4:	2210      	movs	r2, #16
 800e9d6:	2000      	movs	r0, #0
 800e9d8:	4614      	mov	r4, r2
 800e9da:	4544      	cmp	r4, r8
 800e9dc:	bf38      	it	cc
 800e9de:	f040 0001 	orrcc.w	r0, r0, #1
 800e9e2:	2800      	cmp	r0, #0
 800e9e4:	f040 8146 	bne.w	800ec74 <_realloc_r+0x2c8>
 800e9e8:	f023 0b03 	bic.w	fp, r3, #3
 800e9ec:	4593      	cmp	fp, r2
 800e9ee:	bfa4      	itt	ge
 800e9f0:	f10a 0808 	addge.w	r8, sl, #8
 800e9f4:	465e      	movge	r6, fp
 800e9f6:	da6e      	bge.n	800ead6 <_realloc_r+0x12a>
 800e9f8:	f240 3970 	movw	r9, #880	; 0x370
 800e9fc:	eb0a 010b 	add.w	r1, sl, fp
 800ea00:	f2c2 0900 	movt	r9, #8192	; 0x2000
 800ea04:	f8d9 e008 	ldr.w	lr, [r9, #8]
 800ea08:	458e      	cmp	lr, r1
 800ea0a:	f000 8138 	beq.w	800ec7e <_realloc_r+0x2d2>
 800ea0e:	684e      	ldr	r6, [r1, #4]
 800ea10:	f026 0c01 	bic.w	ip, r6, #1
 800ea14:	448c      	add	ip, r1
 800ea16:	f8dc c004 	ldr.w	ip, [ip, #4]
 800ea1a:	f01c 0f01 	tst.w	ip, #1
 800ea1e:	bf18      	it	ne
 800ea20:	4601      	movne	r1, r0
 800ea22:	d073      	beq.n	800eb0c <_realloc_r+0x160>
 800ea24:	f013 0f01 	tst.w	r3, #1
 800ea28:	f040 8092 	bne.w	800eb50 <_realloc_r+0x1a4>
 800ea2c:	f855 3c08 	ldr.w	r3, [r5, #-8]
 800ea30:	ebc3 0c0a 	rsb	ip, r3, sl
 800ea34:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800ea38:	f023 0303 	bic.w	r3, r3, #3
 800ea3c:	2900      	cmp	r1, #0
 800ea3e:	f000 80d1 	beq.w	800ebe4 <_realloc_r+0x238>
 800ea42:	4571      	cmp	r1, lr
 800ea44:	f000 814f 	beq.w	800ece6 <_realloc_r+0x33a>
 800ea48:	445b      	add	r3, fp
 800ea4a:	18c6      	adds	r6, r0, r3
 800ea4c:	42b2      	cmp	r2, r6
 800ea4e:	f300 80ca 	bgt.w	800ebe6 <_realloc_r+0x23a>
 800ea52:	68cb      	ldr	r3, [r1, #12]
 800ea54:	46e0      	mov	r8, ip
 800ea56:	6889      	ldr	r1, [r1, #8]
 800ea58:	f1ab 0204 	sub.w	r2, fp, #4
 800ea5c:	2a24      	cmp	r2, #36	; 0x24
 800ea5e:	60cb      	str	r3, [r1, #12]
 800ea60:	6099      	str	r1, [r3, #8]
 800ea62:	f8dc 300c 	ldr.w	r3, [ip, #12]
 800ea66:	f858 1f08 	ldr.w	r1, [r8, #8]!
 800ea6a:	60cb      	str	r3, [r1, #12]
 800ea6c:	6099      	str	r1, [r3, #8]
 800ea6e:	f200 8196 	bhi.w	800ed9e <_realloc_r+0x3f2>
 800ea72:	2a13      	cmp	r2, #19
 800ea74:	4641      	mov	r1, r8
 800ea76:	d921      	bls.n	800eabc <_realloc_r+0x110>
 800ea78:	462b      	mov	r3, r5
 800ea7a:	f10c 0110 	add.w	r1, ip, #16
 800ea7e:	f853 0b04 	ldr.w	r0, [r3], #4
 800ea82:	f8cc 0008 	str.w	r0, [ip, #8]
 800ea86:	6868      	ldr	r0, [r5, #4]
 800ea88:	1d1d      	adds	r5, r3, #4
 800ea8a:	2a1b      	cmp	r2, #27
 800ea8c:	f8cc 000c 	str.w	r0, [ip, #12]
 800ea90:	d914      	bls.n	800eabc <_realloc_r+0x110>
 800ea92:	6858      	ldr	r0, [r3, #4]
 800ea94:	1d2b      	adds	r3, r5, #4
 800ea96:	f10c 0118 	add.w	r1, ip, #24
 800ea9a:	f8cc 0010 	str.w	r0, [ip, #16]
 800ea9e:	6868      	ldr	r0, [r5, #4]
 800eaa0:	3508      	adds	r5, #8
 800eaa2:	2a24      	cmp	r2, #36	; 0x24
 800eaa4:	f8cc 0014 	str.w	r0, [ip, #20]
 800eaa8:	d108      	bne.n	800eabc <_realloc_r+0x110>
 800eaaa:	685b      	ldr	r3, [r3, #4]
 800eaac:	f10c 0120 	add.w	r1, ip, #32
 800eab0:	f8cc 3018 	str.w	r3, [ip, #24]
 800eab4:	686b      	ldr	r3, [r5, #4]
 800eab6:	3508      	adds	r5, #8
 800eab8:	f8cc 301c 	str.w	r3, [ip, #28]
 800eabc:	462a      	mov	r2, r5
 800eabe:	460b      	mov	r3, r1
 800eac0:	46e2      	mov	sl, ip
 800eac2:	f852 0b04 	ldr.w	r0, [r2], #4
 800eac6:	f843 0b04 	str.w	r0, [r3], #4
 800eaca:	6868      	ldr	r0, [r5, #4]
 800eacc:	6048      	str	r0, [r1, #4]
 800eace:	6852      	ldr	r2, [r2, #4]
 800ead0:	605a      	str	r2, [r3, #4]
 800ead2:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800ead6:	1b30      	subs	r0, r6, r4
 800ead8:	280f      	cmp	r0, #15
 800eada:	d824      	bhi.n	800eb26 <_realloc_r+0x17a>
 800eadc:	eb0a 0206 	add.w	r2, sl, r6
 800eae0:	f003 0301 	and.w	r3, r3, #1
 800eae4:	ea43 0606 	orr.w	r6, r3, r6
 800eae8:	f8ca 6004 	str.w	r6, [sl, #4]
 800eaec:	6853      	ldr	r3, [r2, #4]
 800eaee:	f043 0301 	orr.w	r3, r3, #1
 800eaf2:	6053      	str	r3, [r2, #4]
 800eaf4:	4638      	mov	r0, r7
 800eaf6:	f7f7 fff3 	bl	8006ae0 <__malloc_unlock>
 800eafa:	4640      	mov	r0, r8
 800eafc:	b003      	add	sp, #12
 800eafe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800eb02:	f024 0407 	bic.w	r4, r4, #7
 800eb06:	4622      	mov	r2, r4
 800eb08:	0fe0      	lsrs	r0, r4, #31
 800eb0a:	e766      	b.n	800e9da <_realloc_r+0x2e>
 800eb0c:	f026 0003 	bic.w	r0, r6, #3
 800eb10:	eb00 060b 	add.w	r6, r0, fp
 800eb14:	42b2      	cmp	r2, r6
 800eb16:	dc85      	bgt.n	800ea24 <_realloc_r+0x78>
 800eb18:	68ca      	ldr	r2, [r1, #12]
 800eb1a:	f10a 0808 	add.w	r8, sl, #8
 800eb1e:	6889      	ldr	r1, [r1, #8]
 800eb20:	60ca      	str	r2, [r1, #12]
 800eb22:	6091      	str	r1, [r2, #8]
 800eb24:	e7d7      	b.n	800ead6 <_realloc_r+0x12a>
 800eb26:	eb0a 0104 	add.w	r1, sl, r4
 800eb2a:	f003 0301 	and.w	r3, r3, #1
 800eb2e:	180a      	adds	r2, r1, r0
 800eb30:	ea43 0404 	orr.w	r4, r3, r4
 800eb34:	f040 0001 	orr.w	r0, r0, #1
 800eb38:	f8ca 4004 	str.w	r4, [sl, #4]
 800eb3c:	6048      	str	r0, [r1, #4]
 800eb3e:	4638      	mov	r0, r7
 800eb40:	6853      	ldr	r3, [r2, #4]
 800eb42:	3108      	adds	r1, #8
 800eb44:	f043 0301 	orr.w	r3, r3, #1
 800eb48:	6053      	str	r3, [r2, #4]
 800eb4a:	f7fc fdab 	bl	800b6a4 <_free_r>
 800eb4e:	e7d1      	b.n	800eaf4 <_realloc_r+0x148>
 800eb50:	4641      	mov	r1, r8
 800eb52:	4638      	mov	r0, r7
 800eb54:	f7f7 fd04 	bl	8006560 <_malloc_r>
 800eb58:	4680      	mov	r8, r0
 800eb5a:	2800      	cmp	r0, #0
 800eb5c:	d0ca      	beq.n	800eaf4 <_realloc_r+0x148>
 800eb5e:	f8da 3004 	ldr.w	r3, [sl, #4]
 800eb62:	f1a0 0208 	sub.w	r2, r0, #8
 800eb66:	f023 0101 	bic.w	r1, r3, #1
 800eb6a:	4451      	add	r1, sl
 800eb6c:	428a      	cmp	r2, r1
 800eb6e:	f000 810e 	beq.w	800ed8e <_realloc_r+0x3e2>
 800eb72:	f1ab 0204 	sub.w	r2, fp, #4
 800eb76:	2a24      	cmp	r2, #36	; 0x24
 800eb78:	f200 80b1 	bhi.w	800ecde <_realloc_r+0x332>
 800eb7c:	2a13      	cmp	r2, #19
 800eb7e:	4629      	mov	r1, r5
 800eb80:	4603      	mov	r3, r0
 800eb82:	d91d      	bls.n	800ebc0 <_realloc_r+0x214>
 800eb84:	462c      	mov	r4, r5
 800eb86:	f854 3b04 	ldr.w	r3, [r4], #4
 800eb8a:	1d21      	adds	r1, r4, #4
 800eb8c:	f840 3b04 	str.w	r3, [r0], #4
 800eb90:	1d03      	adds	r3, r0, #4
 800eb92:	686e      	ldr	r6, [r5, #4]
 800eb94:	2a1b      	cmp	r2, #27
 800eb96:	f8c8 6004 	str.w	r6, [r8, #4]
 800eb9a:	d911      	bls.n	800ebc0 <_realloc_r+0x214>
 800eb9c:	f8d4 e004 	ldr.w	lr, [r4, #4]
 800eba0:	1d0e      	adds	r6, r1, #4
 800eba2:	1d1c      	adds	r4, r3, #4
 800eba4:	f8c0 e004 	str.w	lr, [r0, #4]
 800eba8:	6848      	ldr	r0, [r1, #4]
 800ebaa:	3108      	adds	r1, #8
 800ebac:	6058      	str	r0, [r3, #4]
 800ebae:	3308      	adds	r3, #8
 800ebb0:	2a24      	cmp	r2, #36	; 0x24
 800ebb2:	d105      	bne.n	800ebc0 <_realloc_r+0x214>
 800ebb4:	6872      	ldr	r2, [r6, #4]
 800ebb6:	6062      	str	r2, [r4, #4]
 800ebb8:	684a      	ldr	r2, [r1, #4]
 800ebba:	3108      	adds	r1, #8
 800ebbc:	605a      	str	r2, [r3, #4]
 800ebbe:	3308      	adds	r3, #8
 800ebc0:	4608      	mov	r0, r1
 800ebc2:	461a      	mov	r2, r3
 800ebc4:	f850 4b04 	ldr.w	r4, [r0], #4
 800ebc8:	f842 4b04 	str.w	r4, [r2], #4
 800ebcc:	6849      	ldr	r1, [r1, #4]
 800ebce:	6059      	str	r1, [r3, #4]
 800ebd0:	6843      	ldr	r3, [r0, #4]
 800ebd2:	6053      	str	r3, [r2, #4]
 800ebd4:	4638      	mov	r0, r7
 800ebd6:	4629      	mov	r1, r5
 800ebd8:	f7fc fd64 	bl	800b6a4 <_free_r>
 800ebdc:	4638      	mov	r0, r7
 800ebde:	f7f7 ff7f 	bl	8006ae0 <__malloc_unlock>
 800ebe2:	e78a      	b.n	800eafa <_realloc_r+0x14e>
 800ebe4:	445b      	add	r3, fp
 800ebe6:	429a      	cmp	r2, r3
 800ebe8:	dcb2      	bgt.n	800eb50 <_realloc_r+0x1a4>
 800ebea:	46e0      	mov	r8, ip
 800ebec:	f8dc 100c 	ldr.w	r1, [ip, #12]
 800ebf0:	f1ab 0204 	sub.w	r2, fp, #4
 800ebf4:	f858 0f08 	ldr.w	r0, [r8, #8]!
 800ebf8:	2a24      	cmp	r2, #36	; 0x24
 800ebfa:	60c1      	str	r1, [r0, #12]
 800ebfc:	6088      	str	r0, [r1, #8]
 800ebfe:	d85f      	bhi.n	800ecc0 <_realloc_r+0x314>
 800ec00:	2a13      	cmp	r2, #19
 800ec02:	4640      	mov	r0, r8
 800ec04:	d921      	bls.n	800ec4a <_realloc_r+0x29e>
 800ec06:	4629      	mov	r1, r5
 800ec08:	f10c 0010 	add.w	r0, ip, #16
 800ec0c:	f851 6b04 	ldr.w	r6, [r1], #4
 800ec10:	f8cc 6008 	str.w	r6, [ip, #8]
 800ec14:	686e      	ldr	r6, [r5, #4]
 800ec16:	1d0d      	adds	r5, r1, #4
 800ec18:	2a1b      	cmp	r2, #27
 800ec1a:	f8cc 600c 	str.w	r6, [ip, #12]
 800ec1e:	d914      	bls.n	800ec4a <_realloc_r+0x29e>
 800ec20:	684e      	ldr	r6, [r1, #4]
 800ec22:	1d29      	adds	r1, r5, #4
 800ec24:	f10c 0018 	add.w	r0, ip, #24
 800ec28:	f8cc 6010 	str.w	r6, [ip, #16]
 800ec2c:	686e      	ldr	r6, [r5, #4]
 800ec2e:	3508      	adds	r5, #8
 800ec30:	2a24      	cmp	r2, #36	; 0x24
 800ec32:	f8cc 6014 	str.w	r6, [ip, #20]
 800ec36:	d108      	bne.n	800ec4a <_realloc_r+0x29e>
 800ec38:	684a      	ldr	r2, [r1, #4]
 800ec3a:	f10c 0020 	add.w	r0, ip, #32
 800ec3e:	f8cc 2018 	str.w	r2, [ip, #24]
 800ec42:	686a      	ldr	r2, [r5, #4]
 800ec44:	3508      	adds	r5, #8
 800ec46:	f8cc 201c 	str.w	r2, [ip, #28]
 800ec4a:	4629      	mov	r1, r5
 800ec4c:	461e      	mov	r6, r3
 800ec4e:	4602      	mov	r2, r0
 800ec50:	46e2      	mov	sl, ip
 800ec52:	f851 3b04 	ldr.w	r3, [r1], #4
 800ec56:	f842 3b04 	str.w	r3, [r2], #4
 800ec5a:	686b      	ldr	r3, [r5, #4]
 800ec5c:	6043      	str	r3, [r0, #4]
 800ec5e:	684b      	ldr	r3, [r1, #4]
 800ec60:	6053      	str	r3, [r2, #4]
 800ec62:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800ec66:	e736      	b.n	800ead6 <_realloc_r+0x12a>
 800ec68:	4611      	mov	r1, r2
 800ec6a:	b003      	add	sp, #12
 800ec6c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ec70:	f7f7 bc76 	b.w	8006560 <_malloc_r>
 800ec74:	230c      	movs	r3, #12
 800ec76:	f04f 0800 	mov.w	r8, #0
 800ec7a:	603b      	str	r3, [r7, #0]
 800ec7c:	e73d      	b.n	800eafa <_realloc_r+0x14e>
 800ec7e:	f8de 0004 	ldr.w	r0, [lr, #4]
 800ec82:	f104 0c10 	add.w	ip, r4, #16
 800ec86:	f020 0003 	bic.w	r0, r0, #3
 800ec8a:	eb00 010b 	add.w	r1, r0, fp
 800ec8e:	4561      	cmp	r1, ip
 800ec90:	bfb8      	it	lt
 800ec92:	4671      	movlt	r1, lr
 800ec94:	f6ff aec6 	blt.w	800ea24 <_realloc_r+0x78>
 800ec98:	eb0a 0304 	add.w	r3, sl, r4
 800ec9c:	1b0a      	subs	r2, r1, r4
 800ec9e:	f042 0201 	orr.w	r2, r2, #1
 800eca2:	f8c9 3008 	str.w	r3, [r9, #8]
 800eca6:	605a      	str	r2, [r3, #4]
 800eca8:	4638      	mov	r0, r7
 800ecaa:	f8da 2004 	ldr.w	r2, [sl, #4]
 800ecae:	46a8      	mov	r8, r5
 800ecb0:	f002 0301 	and.w	r3, r2, #1
 800ecb4:	431c      	orrs	r4, r3
 800ecb6:	f8ca 4004 	str.w	r4, [sl, #4]
 800ecba:	f7f7 ff11 	bl	8006ae0 <__malloc_unlock>
 800ecbe:	e71c      	b.n	800eafa <_realloc_r+0x14e>
 800ecc0:	4640      	mov	r0, r8
 800ecc2:	4629      	mov	r1, r5
 800ecc4:	9301      	str	r3, [sp, #4]
 800ecc6:	f8cd c000 	str.w	ip, [sp]
 800ecca:	f7ff fe15 	bl	800e8f8 <memmove>
 800ecce:	f8dd c000 	ldr.w	ip, [sp]
 800ecd2:	9b01      	ldr	r3, [sp, #4]
 800ecd4:	46e2      	mov	sl, ip
 800ecd6:	461e      	mov	r6, r3
 800ecd8:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800ecdc:	e6fb      	b.n	800ead6 <_realloc_r+0x12a>
 800ecde:	4629      	mov	r1, r5
 800ece0:	f7ff fe0a 	bl	800e8f8 <memmove>
 800ece4:	e776      	b.n	800ebd4 <_realloc_r+0x228>
 800ece6:	445b      	add	r3, fp
 800ece8:	f104 0110 	add.w	r1, r4, #16
 800ecec:	18c6      	adds	r6, r0, r3
 800ecee:	428e      	cmp	r6, r1
 800ecf0:	f6ff af79 	blt.w	800ebe6 <_realloc_r+0x23a>
 800ecf4:	46e0      	mov	r8, ip
 800ecf6:	f8dc 300c 	ldr.w	r3, [ip, #12]
 800ecfa:	f1ab 0204 	sub.w	r2, fp, #4
 800ecfe:	f858 1f08 	ldr.w	r1, [r8, #8]!
 800ed02:	2a24      	cmp	r2, #36	; 0x24
 800ed04:	60cb      	str	r3, [r1, #12]
 800ed06:	6099      	str	r1, [r3, #8]
 800ed08:	d855      	bhi.n	800edb6 <_realloc_r+0x40a>
 800ed0a:	2a13      	cmp	r2, #19
 800ed0c:	4641      	mov	r1, r8
 800ed0e:	d921      	bls.n	800ed54 <_realloc_r+0x3a8>
 800ed10:	462b      	mov	r3, r5
 800ed12:	f10c 0110 	add.w	r1, ip, #16
 800ed16:	f853 0b04 	ldr.w	r0, [r3], #4
 800ed1a:	f8cc 0008 	str.w	r0, [ip, #8]
 800ed1e:	6868      	ldr	r0, [r5, #4]
 800ed20:	1d1d      	adds	r5, r3, #4
 800ed22:	2a1b      	cmp	r2, #27
 800ed24:	f8cc 000c 	str.w	r0, [ip, #12]
 800ed28:	d914      	bls.n	800ed54 <_realloc_r+0x3a8>
 800ed2a:	6858      	ldr	r0, [r3, #4]
 800ed2c:	1d2b      	adds	r3, r5, #4
 800ed2e:	f10c 0118 	add.w	r1, ip, #24
 800ed32:	f8cc 0010 	str.w	r0, [ip, #16]
 800ed36:	6868      	ldr	r0, [r5, #4]
 800ed38:	3508      	adds	r5, #8
 800ed3a:	2a24      	cmp	r2, #36	; 0x24
 800ed3c:	f8cc 0014 	str.w	r0, [ip, #20]
 800ed40:	d108      	bne.n	800ed54 <_realloc_r+0x3a8>
 800ed42:	685b      	ldr	r3, [r3, #4]
 800ed44:	f10c 0120 	add.w	r1, ip, #32
 800ed48:	f8cc 3018 	str.w	r3, [ip, #24]
 800ed4c:	686b      	ldr	r3, [r5, #4]
 800ed4e:	3508      	adds	r5, #8
 800ed50:	f8cc 301c 	str.w	r3, [ip, #28]
 800ed54:	462a      	mov	r2, r5
 800ed56:	460b      	mov	r3, r1
 800ed58:	f852 0b04 	ldr.w	r0, [r2], #4
 800ed5c:	f843 0b04 	str.w	r0, [r3], #4
 800ed60:	6868      	ldr	r0, [r5, #4]
 800ed62:	6048      	str	r0, [r1, #4]
 800ed64:	6852      	ldr	r2, [r2, #4]
 800ed66:	605a      	str	r2, [r3, #4]
 800ed68:	eb0c 0304 	add.w	r3, ip, r4
 800ed6c:	1b32      	subs	r2, r6, r4
 800ed6e:	f042 0201 	orr.w	r2, r2, #1
 800ed72:	f8c9 3008 	str.w	r3, [r9, #8]
 800ed76:	605a      	str	r2, [r3, #4]
 800ed78:	4638      	mov	r0, r7
 800ed7a:	f8dc 2004 	ldr.w	r2, [ip, #4]
 800ed7e:	f002 0301 	and.w	r3, r2, #1
 800ed82:	431c      	orrs	r4, r3
 800ed84:	f8cc 4004 	str.w	r4, [ip, #4]
 800ed88:	f7f7 feaa 	bl	8006ae0 <__malloc_unlock>
 800ed8c:	e6b5      	b.n	800eafa <_realloc_r+0x14e>
 800ed8e:	f850 6c04 	ldr.w	r6, [r0, #-4]
 800ed92:	f10a 0808 	add.w	r8, sl, #8
 800ed96:	f026 0603 	bic.w	r6, r6, #3
 800ed9a:	445e      	add	r6, fp
 800ed9c:	e69b      	b.n	800ead6 <_realloc_r+0x12a>
 800ed9e:	4640      	mov	r0, r8
 800eda0:	4629      	mov	r1, r5
 800eda2:	f8cd c000 	str.w	ip, [sp]
 800eda6:	f7ff fda7 	bl	800e8f8 <memmove>
 800edaa:	f8dd c000 	ldr.w	ip, [sp]
 800edae:	46e2      	mov	sl, ip
 800edb0:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800edb4:	e68f      	b.n	800ead6 <_realloc_r+0x12a>
 800edb6:	4640      	mov	r0, r8
 800edb8:	4629      	mov	r1, r5
 800edba:	f8cd c000 	str.w	ip, [sp]
 800edbe:	f7ff fd9b 	bl	800e8f8 <memmove>
 800edc2:	f8dd c000 	ldr.w	ip, [sp]
 800edc6:	e7cf      	b.n	800ed68 <_realloc_r+0x3bc>

0800edc8 <__swbuf_r>:
 800edc8:	b570      	push	{r4, r5, r6, lr}
 800edca:	460c      	mov	r4, r1
 800edcc:	4615      	mov	r5, r2
 800edce:	4606      	mov	r6, r0
 800edd0:	b110      	cbz	r0, 800edd8 <__swbuf_r+0x10>
 800edd2:	6983      	ldr	r3, [r0, #24]
 800edd4:	2b00      	cmp	r3, #0
 800edd6:	d04c      	beq.n	800ee72 <__swbuf_r+0xaa>
 800edd8:	f240 13c0 	movw	r3, #448	; 0x1c0
 800eddc:	f6c0 0301 	movt	r3, #2049	; 0x801
 800ede0:	429d      	cmp	r5, r3
 800ede2:	bf08      	it	eq
 800ede4:	6875      	ldreq	r5, [r6, #4]
 800ede6:	d00e      	beq.n	800ee06 <__swbuf_r+0x3e>
 800ede8:	f240 13e0 	movw	r3, #480	; 0x1e0
 800edec:	f6c0 0301 	movt	r3, #2049	; 0x801
 800edf0:	429d      	cmp	r5, r3
 800edf2:	bf08      	it	eq
 800edf4:	68b5      	ldreq	r5, [r6, #8]
 800edf6:	d006      	beq.n	800ee06 <__swbuf_r+0x3e>
 800edf8:	f240 2300 	movw	r3, #512	; 0x200
 800edfc:	f6c0 0301 	movt	r3, #2049	; 0x801
 800ee00:	429d      	cmp	r5, r3
 800ee02:	bf08      	it	eq
 800ee04:	68f5      	ldreq	r5, [r6, #12]
 800ee06:	89aa      	ldrh	r2, [r5, #12]
 800ee08:	69a9      	ldr	r1, [r5, #24]
 800ee0a:	b293      	uxth	r3, r2
 800ee0c:	f013 0f08 	tst.w	r3, #8
 800ee10:	60a9      	str	r1, [r5, #8]
 800ee12:	d025      	beq.n	800ee60 <__swbuf_r+0x98>
 800ee14:	6929      	ldr	r1, [r5, #16]
 800ee16:	b319      	cbz	r1, 800ee60 <__swbuf_r+0x98>
 800ee18:	f413 5f00 	tst.w	r3, #8192	; 0x2000
 800ee1c:	6968      	ldr	r0, [r5, #20]
 800ee1e:	bf01      	itttt	eq
 800ee20:	f442 5200 	orreq.w	r2, r2, #8192	; 0x2000
 800ee24:	81aa      	strheq	r2, [r5, #12]
 800ee26:	6e6b      	ldreq	r3, [r5, #100]	; 0x64
 800ee28:	f423 5300 	biceq.w	r3, r3, #8192	; 0x2000
 800ee2c:	bf08      	it	eq
 800ee2e:	666b      	streq	r3, [r5, #100]	; 0x64
 800ee30:	682b      	ldr	r3, [r5, #0]
 800ee32:	1a5a      	subs	r2, r3, r1
 800ee34:	4282      	cmp	r2, r0
 800ee36:	da28      	bge.n	800ee8a <__swbuf_r+0xc2>
 800ee38:	3201      	adds	r2, #1
 800ee3a:	68a9      	ldr	r1, [r5, #8]
 800ee3c:	b2e4      	uxtb	r4, r4
 800ee3e:	3901      	subs	r1, #1
 800ee40:	60a9      	str	r1, [r5, #8]
 800ee42:	f803 4b01 	strb.w	r4, [r3], #1
 800ee46:	6969      	ldr	r1, [r5, #20]
 800ee48:	602b      	str	r3, [r5, #0]
 800ee4a:	4291      	cmp	r1, r2
 800ee4c:	d014      	beq.n	800ee78 <__swbuf_r+0xb0>
 800ee4e:	89ab      	ldrh	r3, [r5, #12]
 800ee50:	2c0a      	cmp	r4, #10
 800ee52:	bf14      	ite	ne
 800ee54:	2300      	movne	r3, #0
 800ee56:	f003 0301 	andeq.w	r3, r3, #1
 800ee5a:	b96b      	cbnz	r3, 800ee78 <__swbuf_r+0xb0>
 800ee5c:	4620      	mov	r0, r4
 800ee5e:	bd70      	pop	{r4, r5, r6, pc}
 800ee60:	4630      	mov	r0, r6
 800ee62:	4629      	mov	r1, r5
 800ee64:	f7fb f94c 	bl	800a100 <__swsetup_r>
 800ee68:	b9b8      	cbnz	r0, 800ee9a <__swbuf_r+0xd2>
 800ee6a:	89aa      	ldrh	r2, [r5, #12]
 800ee6c:	6929      	ldr	r1, [r5, #16]
 800ee6e:	b293      	uxth	r3, r2
 800ee70:	e7d2      	b.n	800ee18 <__swbuf_r+0x50>
 800ee72:	f7fc fadb 	bl	800b42c <__sinit>
 800ee76:	e7af      	b.n	800edd8 <__swbuf_r+0x10>
 800ee78:	4630      	mov	r0, r6
 800ee7a:	4629      	mov	r1, r5
 800ee7c:	f7fc f9b8 	bl	800b1f0 <_fflush_r>
 800ee80:	2800      	cmp	r0, #0
 800ee82:	bf18      	it	ne
 800ee84:	f04f 34ff 	movne.w	r4, #4294967295
 800ee88:	e7e8      	b.n	800ee5c <__swbuf_r+0x94>
 800ee8a:	4630      	mov	r0, r6
 800ee8c:	4629      	mov	r1, r5
 800ee8e:	f7fc f9af 	bl	800b1f0 <_fflush_r>
 800ee92:	b958      	cbnz	r0, 800eeac <__swbuf_r+0xe4>
 800ee94:	682b      	ldr	r3, [r5, #0]
 800ee96:	2201      	movs	r2, #1
 800ee98:	e7cf      	b.n	800ee3a <__swbuf_r+0x72>
 800ee9a:	89ab      	ldrh	r3, [r5, #12]
 800ee9c:	f04f 34ff 	mov.w	r4, #4294967295
 800eea0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800eea4:	81ab      	strh	r3, [r5, #12]
 800eea6:	2309      	movs	r3, #9
 800eea8:	6033      	str	r3, [r6, #0]
 800eeaa:	e7d7      	b.n	800ee5c <__swbuf_r+0x94>
 800eeac:	f04f 34ff 	mov.w	r4, #4294967295
 800eeb0:	e7d4      	b.n	800ee5c <__swbuf_r+0x94>
 800eeb2:	bf00      	nop

0800eeb4 <__swbuf>:
 800eeb4:	f240 237c 	movw	r3, #636	; 0x27c
 800eeb8:	460a      	mov	r2, r1
 800eeba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800eebe:	4601      	mov	r1, r0
 800eec0:	6818      	ldr	r0, [r3, #0]
 800eec2:	e781      	b.n	800edc8 <__swbuf_r>

0800eec4 <_wcrtomb_r>:
 800eec4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800eec8:	460c      	mov	r4, r1
 800eeca:	b086      	sub	sp, #24
 800eecc:	4605      	mov	r5, r0
 800eece:	4690      	mov	r8, r2
 800eed0:	461e      	mov	r6, r3
 800eed2:	b1b1      	cbz	r1, 800ef02 <_wcrtomb_r+0x3e>
 800eed4:	f240 73fc 	movw	r3, #2044	; 0x7fc
 800eed8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800eedc:	681f      	ldr	r7, [r3, #0]
 800eede:	f7fc fd31 	bl	800b944 <__locale_charset>
 800eee2:	9600      	str	r6, [sp, #0]
 800eee4:	4621      	mov	r1, r4
 800eee6:	4642      	mov	r2, r8
 800eee8:	4603      	mov	r3, r0
 800eeea:	4628      	mov	r0, r5
 800eeec:	47b8      	blx	r7
 800eeee:	f1b0 3fff 	cmp.w	r0, #4294967295
 800eef2:	d103      	bne.n	800eefc <_wcrtomb_r+0x38>
 800eef4:	2300      	movs	r3, #0
 800eef6:	6033      	str	r3, [r6, #0]
 800eef8:	238a      	movs	r3, #138	; 0x8a
 800eefa:	602b      	str	r3, [r5, #0]
 800eefc:	b006      	add	sp, #24
 800eefe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800ef02:	f240 73fc 	movw	r3, #2044	; 0x7fc
 800ef06:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ef0a:	681f      	ldr	r7, [r3, #0]
 800ef0c:	f7fc fd1a 	bl	800b944 <__locale_charset>
 800ef10:	9600      	str	r6, [sp, #0]
 800ef12:	a903      	add	r1, sp, #12
 800ef14:	4622      	mov	r2, r4
 800ef16:	4603      	mov	r3, r0
 800ef18:	4628      	mov	r0, r5
 800ef1a:	47b8      	blx	r7
 800ef1c:	e7e7      	b.n	800eeee <_wcrtomb_r+0x2a>
 800ef1e:	bf00      	nop

0800ef20 <wcrtomb>:
 800ef20:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800ef24:	4607      	mov	r7, r0
 800ef26:	b087      	sub	sp, #28
 800ef28:	4688      	mov	r8, r1
 800ef2a:	4615      	mov	r5, r2
 800ef2c:	b1e8      	cbz	r0, 800ef6a <wcrtomb+0x4a>
 800ef2e:	f240 247c 	movw	r4, #636	; 0x27c
 800ef32:	f240 73fc 	movw	r3, #2044	; 0x7fc
 800ef36:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ef3a:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800ef3e:	681e      	ldr	r6, [r3, #0]
 800ef40:	f8d4 9000 	ldr.w	r9, [r4]
 800ef44:	f7fc fcfe 	bl	800b944 <__locale_charset>
 800ef48:	9500      	str	r5, [sp, #0]
 800ef4a:	4639      	mov	r1, r7
 800ef4c:	4642      	mov	r2, r8
 800ef4e:	4603      	mov	r3, r0
 800ef50:	4648      	mov	r0, r9
 800ef52:	47b0      	blx	r6
 800ef54:	f1b0 3fff 	cmp.w	r0, #4294967295
 800ef58:	d104      	bne.n	800ef64 <wcrtomb+0x44>
 800ef5a:	6823      	ldr	r3, [r4, #0]
 800ef5c:	2200      	movs	r2, #0
 800ef5e:	602a      	str	r2, [r5, #0]
 800ef60:	228a      	movs	r2, #138	; 0x8a
 800ef62:	601a      	str	r2, [r3, #0]
 800ef64:	b007      	add	sp, #28
 800ef66:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800ef6a:	f240 247c 	movw	r4, #636	; 0x27c
 800ef6e:	f240 73fc 	movw	r3, #2044	; 0x7fc
 800ef72:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ef76:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800ef7a:	681e      	ldr	r6, [r3, #0]
 800ef7c:	f8d4 8000 	ldr.w	r8, [r4]
 800ef80:	f7fc fce0 	bl	800b944 <__locale_charset>
 800ef84:	9500      	str	r5, [sp, #0]
 800ef86:	a903      	add	r1, sp, #12
 800ef88:	463a      	mov	r2, r7
 800ef8a:	4603      	mov	r3, r0
 800ef8c:	4640      	mov	r0, r8
 800ef8e:	47b0      	blx	r6
 800ef90:	e7e0      	b.n	800ef54 <wcrtomb+0x34>
 800ef92:	bf00      	nop

0800ef94 <__ascii_wctomb>:
 800ef94:	4603      	mov	r3, r0
 800ef96:	b121      	cbz	r1, 800efa2 <__ascii_wctomb+0xe>
 800ef98:	2aff      	cmp	r2, #255	; 0xff
 800ef9a:	d804      	bhi.n	800efa6 <__ascii_wctomb+0x12>
 800ef9c:	700a      	strb	r2, [r1, #0]
 800ef9e:	2001      	movs	r0, #1
 800efa0:	4770      	bx	lr
 800efa2:	4608      	mov	r0, r1
 800efa4:	4770      	bx	lr
 800efa6:	228a      	movs	r2, #138	; 0x8a
 800efa8:	f04f 30ff 	mov.w	r0, #4294967295
 800efac:	601a      	str	r2, [r3, #0]
 800efae:	4770      	bx	lr

0800efb0 <_wctomb_r>:
 800efb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800efb4:	f240 74fc 	movw	r4, #2044	; 0x7fc
 800efb8:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800efbc:	b082      	sub	sp, #8
 800efbe:	461e      	mov	r6, r3
 800efc0:	4605      	mov	r5, r0
 800efc2:	4688      	mov	r8, r1
 800efc4:	4617      	mov	r7, r2
 800efc6:	6824      	ldr	r4, [r4, #0]
 800efc8:	f7fc fcbc 	bl	800b944 <__locale_charset>
 800efcc:	9600      	str	r6, [sp, #0]
 800efce:	4641      	mov	r1, r8
 800efd0:	463a      	mov	r2, r7
 800efd2:	4603      	mov	r3, r0
 800efd4:	4628      	mov	r0, r5
 800efd6:	47a0      	blx	r4
 800efd8:	b002      	add	sp, #8
 800efda:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800efde:	bf00      	nop

0800efe0 <__aeabi_uidiv>:
 800efe0:	1e4a      	subs	r2, r1, #1
 800efe2:	bf08      	it	eq
 800efe4:	4770      	bxeq	lr
 800efe6:	f0c0 8124 	bcc.w	800f232 <__aeabi_uidiv+0x252>
 800efea:	4288      	cmp	r0, r1
 800efec:	f240 8116 	bls.w	800f21c <__aeabi_uidiv+0x23c>
 800eff0:	4211      	tst	r1, r2
 800eff2:	f000 8117 	beq.w	800f224 <__aeabi_uidiv+0x244>
 800eff6:	fab0 f380 	clz	r3, r0
 800effa:	fab1 f281 	clz	r2, r1
 800effe:	eba2 0303 	sub.w	r3, r2, r3
 800f002:	f1c3 031f 	rsb	r3, r3, #31
 800f006:	a204      	add	r2, pc, #16	; (adr r2, 800f018 <__aeabi_uidiv+0x38>)
 800f008:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800f00c:	f04f 0200 	mov.w	r2, #0
 800f010:	469f      	mov	pc, r3
 800f012:	bf00      	nop
 800f014:	f3af 8000 	nop.w
 800f018:	ebb0 7fc1 	cmp.w	r0, r1, lsl #31
 800f01c:	bf00      	nop
 800f01e:	eb42 0202 	adc.w	r2, r2, r2
 800f022:	bf28      	it	cs
 800f024:	eba0 70c1 	subcs.w	r0, r0, r1, lsl #31
 800f028:	ebb0 7f81 	cmp.w	r0, r1, lsl #30
 800f02c:	bf00      	nop
 800f02e:	eb42 0202 	adc.w	r2, r2, r2
 800f032:	bf28      	it	cs
 800f034:	eba0 7081 	subcs.w	r0, r0, r1, lsl #30
 800f038:	ebb0 7f41 	cmp.w	r0, r1, lsl #29
 800f03c:	bf00      	nop
 800f03e:	eb42 0202 	adc.w	r2, r2, r2
 800f042:	bf28      	it	cs
 800f044:	eba0 7041 	subcs.w	r0, r0, r1, lsl #29
 800f048:	ebb0 7f01 	cmp.w	r0, r1, lsl #28
 800f04c:	bf00      	nop
 800f04e:	eb42 0202 	adc.w	r2, r2, r2
 800f052:	bf28      	it	cs
 800f054:	eba0 7001 	subcs.w	r0, r0, r1, lsl #28
 800f058:	ebb0 6fc1 	cmp.w	r0, r1, lsl #27
 800f05c:	bf00      	nop
 800f05e:	eb42 0202 	adc.w	r2, r2, r2
 800f062:	bf28      	it	cs
 800f064:	eba0 60c1 	subcs.w	r0, r0, r1, lsl #27
 800f068:	ebb0 6f81 	cmp.w	r0, r1, lsl #26
 800f06c:	bf00      	nop
 800f06e:	eb42 0202 	adc.w	r2, r2, r2
 800f072:	bf28      	it	cs
 800f074:	eba0 6081 	subcs.w	r0, r0, r1, lsl #26
 800f078:	ebb0 6f41 	cmp.w	r0, r1, lsl #25
 800f07c:	bf00      	nop
 800f07e:	eb42 0202 	adc.w	r2, r2, r2
 800f082:	bf28      	it	cs
 800f084:	eba0 6041 	subcs.w	r0, r0, r1, lsl #25
 800f088:	ebb0 6f01 	cmp.w	r0, r1, lsl #24
 800f08c:	bf00      	nop
 800f08e:	eb42 0202 	adc.w	r2, r2, r2
 800f092:	bf28      	it	cs
 800f094:	eba0 6001 	subcs.w	r0, r0, r1, lsl #24
 800f098:	ebb0 5fc1 	cmp.w	r0, r1, lsl #23
 800f09c:	bf00      	nop
 800f09e:	eb42 0202 	adc.w	r2, r2, r2
 800f0a2:	bf28      	it	cs
 800f0a4:	eba0 50c1 	subcs.w	r0, r0, r1, lsl #23
 800f0a8:	ebb0 5f81 	cmp.w	r0, r1, lsl #22
 800f0ac:	bf00      	nop
 800f0ae:	eb42 0202 	adc.w	r2, r2, r2
 800f0b2:	bf28      	it	cs
 800f0b4:	eba0 5081 	subcs.w	r0, r0, r1, lsl #22
 800f0b8:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
 800f0bc:	bf00      	nop
 800f0be:	eb42 0202 	adc.w	r2, r2, r2
 800f0c2:	bf28      	it	cs
 800f0c4:	eba0 5041 	subcs.w	r0, r0, r1, lsl #21
 800f0c8:	ebb0 5f01 	cmp.w	r0, r1, lsl #20
 800f0cc:	bf00      	nop
 800f0ce:	eb42 0202 	adc.w	r2, r2, r2
 800f0d2:	bf28      	it	cs
 800f0d4:	eba0 5001 	subcs.w	r0, r0, r1, lsl #20
 800f0d8:	ebb0 4fc1 	cmp.w	r0, r1, lsl #19
 800f0dc:	bf00      	nop
 800f0de:	eb42 0202 	adc.w	r2, r2, r2
 800f0e2:	bf28      	it	cs
 800f0e4:	eba0 40c1 	subcs.w	r0, r0, r1, lsl #19
 800f0e8:	ebb0 4f81 	cmp.w	r0, r1, lsl #18
 800f0ec:	bf00      	nop
 800f0ee:	eb42 0202 	adc.w	r2, r2, r2
 800f0f2:	bf28      	it	cs
 800f0f4:	eba0 4081 	subcs.w	r0, r0, r1, lsl #18
 800f0f8:	ebb0 4f41 	cmp.w	r0, r1, lsl #17
 800f0fc:	bf00      	nop
 800f0fe:	eb42 0202 	adc.w	r2, r2, r2
 800f102:	bf28      	it	cs
 800f104:	eba0 4041 	subcs.w	r0, r0, r1, lsl #17
 800f108:	ebb0 4f01 	cmp.w	r0, r1, lsl #16
 800f10c:	bf00      	nop
 800f10e:	eb42 0202 	adc.w	r2, r2, r2
 800f112:	bf28      	it	cs
 800f114:	eba0 4001 	subcs.w	r0, r0, r1, lsl #16
 800f118:	ebb0 3fc1 	cmp.w	r0, r1, lsl #15
 800f11c:	bf00      	nop
 800f11e:	eb42 0202 	adc.w	r2, r2, r2
 800f122:	bf28      	it	cs
 800f124:	eba0 30c1 	subcs.w	r0, r0, r1, lsl #15
 800f128:	ebb0 3f81 	cmp.w	r0, r1, lsl #14
 800f12c:	bf00      	nop
 800f12e:	eb42 0202 	adc.w	r2, r2, r2
 800f132:	bf28      	it	cs
 800f134:	eba0 3081 	subcs.w	r0, r0, r1, lsl #14
 800f138:	ebb0 3f41 	cmp.w	r0, r1, lsl #13
 800f13c:	bf00      	nop
 800f13e:	eb42 0202 	adc.w	r2, r2, r2
 800f142:	bf28      	it	cs
 800f144:	eba0 3041 	subcs.w	r0, r0, r1, lsl #13
 800f148:	ebb0 3f01 	cmp.w	r0, r1, lsl #12
 800f14c:	bf00      	nop
 800f14e:	eb42 0202 	adc.w	r2, r2, r2
 800f152:	bf28      	it	cs
 800f154:	eba0 3001 	subcs.w	r0, r0, r1, lsl #12
 800f158:	ebb0 2fc1 	cmp.w	r0, r1, lsl #11
 800f15c:	bf00      	nop
 800f15e:	eb42 0202 	adc.w	r2, r2, r2
 800f162:	bf28      	it	cs
 800f164:	eba0 20c1 	subcs.w	r0, r0, r1, lsl #11
 800f168:	ebb0 2f81 	cmp.w	r0, r1, lsl #10
 800f16c:	bf00      	nop
 800f16e:	eb42 0202 	adc.w	r2, r2, r2
 800f172:	bf28      	it	cs
 800f174:	eba0 2081 	subcs.w	r0, r0, r1, lsl #10
 800f178:	ebb0 2f41 	cmp.w	r0, r1, lsl #9
 800f17c:	bf00      	nop
 800f17e:	eb42 0202 	adc.w	r2, r2, r2
 800f182:	bf28      	it	cs
 800f184:	eba0 2041 	subcs.w	r0, r0, r1, lsl #9
 800f188:	ebb0 2f01 	cmp.w	r0, r1, lsl #8
 800f18c:	bf00      	nop
 800f18e:	eb42 0202 	adc.w	r2, r2, r2
 800f192:	bf28      	it	cs
 800f194:	eba0 2001 	subcs.w	r0, r0, r1, lsl #8
 800f198:	ebb0 1fc1 	cmp.w	r0, r1, lsl #7
 800f19c:	bf00      	nop
 800f19e:	eb42 0202 	adc.w	r2, r2, r2
 800f1a2:	bf28      	it	cs
 800f1a4:	eba0 10c1 	subcs.w	r0, r0, r1, lsl #7
 800f1a8:	ebb0 1f81 	cmp.w	r0, r1, lsl #6
 800f1ac:	bf00      	nop
 800f1ae:	eb42 0202 	adc.w	r2, r2, r2
 800f1b2:	bf28      	it	cs
 800f1b4:	eba0 1081 	subcs.w	r0, r0, r1, lsl #6
 800f1b8:	ebb0 1f41 	cmp.w	r0, r1, lsl #5
 800f1bc:	bf00      	nop
 800f1be:	eb42 0202 	adc.w	r2, r2, r2
 800f1c2:	bf28      	it	cs
 800f1c4:	eba0 1041 	subcs.w	r0, r0, r1, lsl #5
 800f1c8:	ebb0 1f01 	cmp.w	r0, r1, lsl #4
 800f1cc:	bf00      	nop
 800f1ce:	eb42 0202 	adc.w	r2, r2, r2
 800f1d2:	bf28      	it	cs
 800f1d4:	eba0 1001 	subcs.w	r0, r0, r1, lsl #4
 800f1d8:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
 800f1dc:	bf00      	nop
 800f1de:	eb42 0202 	adc.w	r2, r2, r2
 800f1e2:	bf28      	it	cs
 800f1e4:	eba0 00c1 	subcs.w	r0, r0, r1, lsl #3
 800f1e8:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
 800f1ec:	bf00      	nop
 800f1ee:	eb42 0202 	adc.w	r2, r2, r2
 800f1f2:	bf28      	it	cs
 800f1f4:	eba0 0081 	subcs.w	r0, r0, r1, lsl #2
 800f1f8:	ebb0 0f41 	cmp.w	r0, r1, lsl #1
 800f1fc:	bf00      	nop
 800f1fe:	eb42 0202 	adc.w	r2, r2, r2
 800f202:	bf28      	it	cs
 800f204:	eba0 0041 	subcs.w	r0, r0, r1, lsl #1
 800f208:	ebb0 0f01 	cmp.w	r0, r1
 800f20c:	bf00      	nop
 800f20e:	eb42 0202 	adc.w	r2, r2, r2
 800f212:	bf28      	it	cs
 800f214:	eba0 0001 	subcs.w	r0, r0, r1
 800f218:	4610      	mov	r0, r2
 800f21a:	4770      	bx	lr
 800f21c:	bf0c      	ite	eq
 800f21e:	2001      	moveq	r0, #1
 800f220:	2000      	movne	r0, #0
 800f222:	4770      	bx	lr
 800f224:	fab1 f281 	clz	r2, r1
 800f228:	f1c2 021f 	rsb	r2, r2, #31
 800f22c:	fa20 f002 	lsr.w	r0, r0, r2
 800f230:	4770      	bx	lr
 800f232:	b108      	cbz	r0, 800f238 <__aeabi_uidiv+0x258>
 800f234:	f04f 30ff 	mov.w	r0, #4294967295
 800f238:	f000 b80e 	b.w	800f258 <__aeabi_idiv0>

0800f23c <__aeabi_uidivmod>:
 800f23c:	2900      	cmp	r1, #0
 800f23e:	d0f8      	beq.n	800f232 <__aeabi_uidiv+0x252>
 800f240:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
 800f244:	f7ff fecc 	bl	800efe0 <__aeabi_uidiv>
 800f248:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
 800f24c:	fb02 f300 	mul.w	r3, r2, r0
 800f250:	eba1 0103 	sub.w	r1, r1, r3
 800f254:	4770      	bx	lr
 800f256:	bf00      	nop

0800f258 <__aeabi_idiv0>:
 800f258:	4770      	bx	lr
 800f25a:	bf00      	nop

0800f25c <__aeabi_dmul>:
 800f25c:	b570      	push	{r4, r5, r6, lr}
 800f25e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800f262:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800f266:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800f26a:	bf1d      	ittte	ne
 800f26c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800f270:	ea94 0f0c 	teqne	r4, ip
 800f274:	ea95 0f0c 	teqne	r5, ip
 800f278:	f000 f8de 	bleq	800f438 <__aeabi_dmul+0x1dc>
 800f27c:	442c      	add	r4, r5
 800f27e:	ea81 0603 	eor.w	r6, r1, r3
 800f282:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800f286:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800f28a:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800f28e:	bf18      	it	ne
 800f290:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 800f294:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800f298:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800f29c:	d038      	beq.n	800f310 <__aeabi_dmul+0xb4>
 800f29e:	fba0 ce02 	umull	ip, lr, r0, r2
 800f2a2:	f04f 0500 	mov.w	r5, #0
 800f2a6:	fbe1 e502 	umlal	lr, r5, r1, r2
 800f2aa:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800f2ae:	fbe0 e503 	umlal	lr, r5, r0, r3
 800f2b2:	f04f 0600 	mov.w	r6, #0
 800f2b6:	fbe1 5603 	umlal	r5, r6, r1, r3
 800f2ba:	f09c 0f00 	teq	ip, #0
 800f2be:	bf18      	it	ne
 800f2c0:	f04e 0e01 	orrne.w	lr, lr, #1
 800f2c4:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800f2c8:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 800f2cc:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 800f2d0:	d204      	bcs.n	800f2dc <__aeabi_dmul+0x80>
 800f2d2:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800f2d6:	416d      	adcs	r5, r5
 800f2d8:	eb46 0606 	adc.w	r6, r6, r6
 800f2dc:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800f2e0:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 800f2e4:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800f2e8:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 800f2ec:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800f2f0:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800f2f4:	bf88      	it	hi
 800f2f6:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800f2fa:	d81e      	bhi.n	800f33a <__aeabi_dmul+0xde>
 800f2fc:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 800f300:	bf08      	it	eq
 800f302:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800f306:	f150 0000 	adcs.w	r0, r0, #0
 800f30a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800f30e:	bd70      	pop	{r4, r5, r6, pc}
 800f310:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 800f314:	ea46 0101 	orr.w	r1, r6, r1
 800f318:	ea40 0002 	orr.w	r0, r0, r2
 800f31c:	ea81 0103 	eor.w	r1, r1, r3
 800f320:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 800f324:	bfc2      	ittt	gt
 800f326:	ebd4 050c 	rsbsgt	r5, r4, ip
 800f32a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800f32e:	bd70      	popgt	{r4, r5, r6, pc}
 800f330:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800f334:	f04f 0e00 	mov.w	lr, #0
 800f338:	3c01      	subs	r4, #1
 800f33a:	f300 80ab 	bgt.w	800f494 <__aeabi_dmul+0x238>
 800f33e:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800f342:	bfde      	ittt	le
 800f344:	2000      	movle	r0, #0
 800f346:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800f34a:	bd70      	pople	{r4, r5, r6, pc}
 800f34c:	f1c4 0400 	rsb	r4, r4, #0
 800f350:	3c20      	subs	r4, #32
 800f352:	da35      	bge.n	800f3c0 <__aeabi_dmul+0x164>
 800f354:	340c      	adds	r4, #12
 800f356:	dc1b      	bgt.n	800f390 <__aeabi_dmul+0x134>
 800f358:	f104 0414 	add.w	r4, r4, #20
 800f35c:	f1c4 0520 	rsb	r5, r4, #32
 800f360:	fa00 f305 	lsl.w	r3, r0, r5
 800f364:	fa20 f004 	lsr.w	r0, r0, r4
 800f368:	fa01 f205 	lsl.w	r2, r1, r5
 800f36c:	ea40 0002 	orr.w	r0, r0, r2
 800f370:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 800f374:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800f378:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800f37c:	fa21 f604 	lsr.w	r6, r1, r4
 800f380:	eb42 0106 	adc.w	r1, r2, r6
 800f384:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800f388:	bf08      	it	eq
 800f38a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800f38e:	bd70      	pop	{r4, r5, r6, pc}
 800f390:	f1c4 040c 	rsb	r4, r4, #12
 800f394:	f1c4 0520 	rsb	r5, r4, #32
 800f398:	fa00 f304 	lsl.w	r3, r0, r4
 800f39c:	fa20 f005 	lsr.w	r0, r0, r5
 800f3a0:	fa01 f204 	lsl.w	r2, r1, r4
 800f3a4:	ea40 0002 	orr.w	r0, r0, r2
 800f3a8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800f3ac:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800f3b0:	f141 0100 	adc.w	r1, r1, #0
 800f3b4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800f3b8:	bf08      	it	eq
 800f3ba:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800f3be:	bd70      	pop	{r4, r5, r6, pc}
 800f3c0:	f1c4 0520 	rsb	r5, r4, #32
 800f3c4:	fa00 f205 	lsl.w	r2, r0, r5
 800f3c8:	ea4e 0e02 	orr.w	lr, lr, r2
 800f3cc:	fa20 f304 	lsr.w	r3, r0, r4
 800f3d0:	fa01 f205 	lsl.w	r2, r1, r5
 800f3d4:	ea43 0302 	orr.w	r3, r3, r2
 800f3d8:	fa21 f004 	lsr.w	r0, r1, r4
 800f3dc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800f3e0:	fa21 f204 	lsr.w	r2, r1, r4
 800f3e4:	ea20 0002 	bic.w	r0, r0, r2
 800f3e8:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 800f3ec:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800f3f0:	bf08      	it	eq
 800f3f2:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800f3f6:	bd70      	pop	{r4, r5, r6, pc}
 800f3f8:	f094 0f00 	teq	r4, #0
 800f3fc:	d10f      	bne.n	800f41e <__aeabi_dmul+0x1c2>
 800f3fe:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800f402:	0040      	lsls	r0, r0, #1
 800f404:	eb41 0101 	adc.w	r1, r1, r1
 800f408:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800f40c:	bf08      	it	eq
 800f40e:	3c01      	subeq	r4, #1
 800f410:	d0f7      	beq.n	800f402 <__aeabi_dmul+0x1a6>
 800f412:	ea41 0106 	orr.w	r1, r1, r6
 800f416:	f095 0f00 	teq	r5, #0
 800f41a:	bf18      	it	ne
 800f41c:	4770      	bxne	lr
 800f41e:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800f422:	0052      	lsls	r2, r2, #1
 800f424:	eb43 0303 	adc.w	r3, r3, r3
 800f428:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800f42c:	bf08      	it	eq
 800f42e:	3d01      	subeq	r5, #1
 800f430:	d0f7      	beq.n	800f422 <__aeabi_dmul+0x1c6>
 800f432:	ea43 0306 	orr.w	r3, r3, r6
 800f436:	4770      	bx	lr
 800f438:	ea94 0f0c 	teq	r4, ip
 800f43c:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800f440:	bf18      	it	ne
 800f442:	ea95 0f0c 	teqne	r5, ip
 800f446:	d00c      	beq.n	800f462 <__aeabi_dmul+0x206>
 800f448:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800f44c:	bf18      	it	ne
 800f44e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800f452:	d1d1      	bne.n	800f3f8 <__aeabi_dmul+0x19c>
 800f454:	ea81 0103 	eor.w	r1, r1, r3
 800f458:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800f45c:	f04f 0000 	mov.w	r0, #0
 800f460:	bd70      	pop	{r4, r5, r6, pc}
 800f462:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800f466:	bf06      	itte	eq
 800f468:	4610      	moveq	r0, r2
 800f46a:	4619      	moveq	r1, r3
 800f46c:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800f470:	d019      	beq.n	800f4a6 <__aeabi_dmul+0x24a>
 800f472:	ea94 0f0c 	teq	r4, ip
 800f476:	d102      	bne.n	800f47e <__aeabi_dmul+0x222>
 800f478:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 800f47c:	d113      	bne.n	800f4a6 <__aeabi_dmul+0x24a>
 800f47e:	ea95 0f0c 	teq	r5, ip
 800f482:	d105      	bne.n	800f490 <__aeabi_dmul+0x234>
 800f484:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800f488:	bf1c      	itt	ne
 800f48a:	4610      	movne	r0, r2
 800f48c:	4619      	movne	r1, r3
 800f48e:	d10a      	bne.n	800f4a6 <__aeabi_dmul+0x24a>
 800f490:	ea81 0103 	eor.w	r1, r1, r3
 800f494:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800f498:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800f49c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800f4a0:	f04f 0000 	mov.w	r0, #0
 800f4a4:	bd70      	pop	{r4, r5, r6, pc}
 800f4a6:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800f4aa:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800f4ae:	bd70      	pop	{r4, r5, r6, pc}

0800f4b0 <__aeabi_ddiv>:
 800f4b0:	b570      	push	{r4, r5, r6, lr}
 800f4b2:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800f4b6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800f4ba:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800f4be:	bf1d      	ittte	ne
 800f4c0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800f4c4:	ea94 0f0c 	teqne	r4, ip
 800f4c8:	ea95 0f0c 	teqne	r5, ip
 800f4cc:	f000 f8a7 	bleq	800f61e <__aeabi_ddiv+0x16e>
 800f4d0:	eba4 0405 	sub.w	r4, r4, r5
 800f4d4:	ea81 0e03 	eor.w	lr, r1, r3
 800f4d8:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800f4dc:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800f4e0:	f000 8088 	beq.w	800f5f4 <__aeabi_ddiv+0x144>
 800f4e4:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800f4e8:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800f4ec:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800f4f0:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800f4f4:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800f4f8:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 800f4fc:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800f500:	ea4f 2600 	mov.w	r6, r0, lsl #8
 800f504:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800f508:	429d      	cmp	r5, r3
 800f50a:	bf08      	it	eq
 800f50c:	4296      	cmpeq	r6, r2
 800f50e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 800f512:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800f516:	d202      	bcs.n	800f51e <__aeabi_ddiv+0x6e>
 800f518:	085b      	lsrs	r3, r3, #1
 800f51a:	ea4f 0232 	mov.w	r2, r2, rrx
 800f51e:	1ab6      	subs	r6, r6, r2
 800f520:	eb65 0503 	sbc.w	r5, r5, r3
 800f524:	085b      	lsrs	r3, r3, #1
 800f526:	ea4f 0232 	mov.w	r2, r2, rrx
 800f52a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800f52e:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800f532:	ebb6 0e02 	subs.w	lr, r6, r2
 800f536:	eb75 0e03 	sbcs.w	lr, r5, r3
 800f53a:	bf22      	ittt	cs
 800f53c:	1ab6      	subcs	r6, r6, r2
 800f53e:	4675      	movcs	r5, lr
 800f540:	ea40 000c 	orrcs.w	r0, r0, ip
 800f544:	085b      	lsrs	r3, r3, #1
 800f546:	ea4f 0232 	mov.w	r2, r2, rrx
 800f54a:	ebb6 0e02 	subs.w	lr, r6, r2
 800f54e:	eb75 0e03 	sbcs.w	lr, r5, r3
 800f552:	bf22      	ittt	cs
 800f554:	1ab6      	subcs	r6, r6, r2
 800f556:	4675      	movcs	r5, lr
 800f558:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 800f55c:	085b      	lsrs	r3, r3, #1
 800f55e:	ea4f 0232 	mov.w	r2, r2, rrx
 800f562:	ebb6 0e02 	subs.w	lr, r6, r2
 800f566:	eb75 0e03 	sbcs.w	lr, r5, r3
 800f56a:	bf22      	ittt	cs
 800f56c:	1ab6      	subcs	r6, r6, r2
 800f56e:	4675      	movcs	r5, lr
 800f570:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 800f574:	085b      	lsrs	r3, r3, #1
 800f576:	ea4f 0232 	mov.w	r2, r2, rrx
 800f57a:	ebb6 0e02 	subs.w	lr, r6, r2
 800f57e:	eb75 0e03 	sbcs.w	lr, r5, r3
 800f582:	bf22      	ittt	cs
 800f584:	1ab6      	subcs	r6, r6, r2
 800f586:	4675      	movcs	r5, lr
 800f588:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 800f58c:	ea55 0e06 	orrs.w	lr, r5, r6
 800f590:	d018      	beq.n	800f5c4 <__aeabi_ddiv+0x114>
 800f592:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800f596:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800f59a:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800f59e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800f5a2:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800f5a6:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800f5aa:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800f5ae:	d1c0      	bne.n	800f532 <__aeabi_ddiv+0x82>
 800f5b0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800f5b4:	d10b      	bne.n	800f5ce <__aeabi_ddiv+0x11e>
 800f5b6:	ea41 0100 	orr.w	r1, r1, r0
 800f5ba:	f04f 0000 	mov.w	r0, #0
 800f5be:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800f5c2:	e7b6      	b.n	800f532 <__aeabi_ddiv+0x82>
 800f5c4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800f5c8:	bf04      	itt	eq
 800f5ca:	4301      	orreq	r1, r0
 800f5cc:	2000      	moveq	r0, #0
 800f5ce:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800f5d2:	bf88      	it	hi
 800f5d4:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800f5d8:	f63f aeaf 	bhi.w	800f33a <__aeabi_dmul+0xde>
 800f5dc:	ebb5 0c03 	subs.w	ip, r5, r3
 800f5e0:	bf04      	itt	eq
 800f5e2:	ebb6 0c02 	subseq.w	ip, r6, r2
 800f5e6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800f5ea:	f150 0000 	adcs.w	r0, r0, #0
 800f5ee:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800f5f2:	bd70      	pop	{r4, r5, r6, pc}
 800f5f4:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800f5f8:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 800f5fc:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 800f600:	bfc2      	ittt	gt
 800f602:	ebd4 050c 	rsbsgt	r5, r4, ip
 800f606:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800f60a:	bd70      	popgt	{r4, r5, r6, pc}
 800f60c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800f610:	f04f 0e00 	mov.w	lr, #0
 800f614:	3c01      	subs	r4, #1
 800f616:	e690      	b.n	800f33a <__aeabi_dmul+0xde>
 800f618:	ea45 0e06 	orr.w	lr, r5, r6
 800f61c:	e68d      	b.n	800f33a <__aeabi_dmul+0xde>
 800f61e:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800f622:	ea94 0f0c 	teq	r4, ip
 800f626:	bf08      	it	eq
 800f628:	ea95 0f0c 	teqeq	r5, ip
 800f62c:	f43f af3b 	beq.w	800f4a6 <__aeabi_dmul+0x24a>
 800f630:	ea94 0f0c 	teq	r4, ip
 800f634:	d10a      	bne.n	800f64c <__aeabi_ddiv+0x19c>
 800f636:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800f63a:	f47f af34 	bne.w	800f4a6 <__aeabi_dmul+0x24a>
 800f63e:	ea95 0f0c 	teq	r5, ip
 800f642:	f47f af25 	bne.w	800f490 <__aeabi_dmul+0x234>
 800f646:	4610      	mov	r0, r2
 800f648:	4619      	mov	r1, r3
 800f64a:	e72c      	b.n	800f4a6 <__aeabi_dmul+0x24a>
 800f64c:	ea95 0f0c 	teq	r5, ip
 800f650:	d106      	bne.n	800f660 <__aeabi_ddiv+0x1b0>
 800f652:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800f656:	f43f aefd 	beq.w	800f454 <__aeabi_dmul+0x1f8>
 800f65a:	4610      	mov	r0, r2
 800f65c:	4619      	mov	r1, r3
 800f65e:	e722      	b.n	800f4a6 <__aeabi_dmul+0x24a>
 800f660:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800f664:	bf18      	it	ne
 800f666:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800f66a:	f47f aec5 	bne.w	800f3f8 <__aeabi_dmul+0x19c>
 800f66e:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 800f672:	f47f af0d 	bne.w	800f490 <__aeabi_dmul+0x234>
 800f676:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800f67a:	f47f aeeb 	bne.w	800f454 <__aeabi_dmul+0x1f8>
 800f67e:	e712      	b.n	800f4a6 <__aeabi_dmul+0x24a>

0800f680 <__gedf2>:
 800f680:	f04f 3cff 	mov.w	ip, #4294967295
 800f684:	e006      	b.n	800f694 <__cmpdf2+0x4>
 800f686:	bf00      	nop

0800f688 <__ledf2>:
 800f688:	f04f 0c01 	mov.w	ip, #1
 800f68c:	e002      	b.n	800f694 <__cmpdf2+0x4>
 800f68e:	bf00      	nop

0800f690 <__cmpdf2>:
 800f690:	f04f 0c01 	mov.w	ip, #1
 800f694:	f84d cd04 	str.w	ip, [sp, #-4]!
 800f698:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800f69c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800f6a0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800f6a4:	bf18      	it	ne
 800f6a6:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 800f6aa:	d01b      	beq.n	800f6e4 <__cmpdf2+0x54>
 800f6ac:	b001      	add	sp, #4
 800f6ae:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 800f6b2:	bf0c      	ite	eq
 800f6b4:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 800f6b8:	ea91 0f03 	teqne	r1, r3
 800f6bc:	bf02      	ittt	eq
 800f6be:	ea90 0f02 	teqeq	r0, r2
 800f6c2:	2000      	moveq	r0, #0
 800f6c4:	4770      	bxeq	lr
 800f6c6:	f110 0f00 	cmn.w	r0, #0
 800f6ca:	ea91 0f03 	teq	r1, r3
 800f6ce:	bf58      	it	pl
 800f6d0:	4299      	cmppl	r1, r3
 800f6d2:	bf08      	it	eq
 800f6d4:	4290      	cmpeq	r0, r2
 800f6d6:	bf2c      	ite	cs
 800f6d8:	17d8      	asrcs	r0, r3, #31
 800f6da:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 800f6de:	f040 0001 	orr.w	r0, r0, #1
 800f6e2:	4770      	bx	lr
 800f6e4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800f6e8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800f6ec:	d102      	bne.n	800f6f4 <__cmpdf2+0x64>
 800f6ee:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800f6f2:	d107      	bne.n	800f704 <__cmpdf2+0x74>
 800f6f4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800f6f8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800f6fc:	d1d6      	bne.n	800f6ac <__cmpdf2+0x1c>
 800f6fe:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800f702:	d0d3      	beq.n	800f6ac <__cmpdf2+0x1c>
 800f704:	f85d 0b04 	ldr.w	r0, [sp], #4
 800f708:	4770      	bx	lr
 800f70a:	bf00      	nop

0800f70c <__aeabi_cdrcmple>:
 800f70c:	4684      	mov	ip, r0
 800f70e:	4610      	mov	r0, r2
 800f710:	4662      	mov	r2, ip
 800f712:	468c      	mov	ip, r1
 800f714:	4619      	mov	r1, r3
 800f716:	4663      	mov	r3, ip
 800f718:	e000      	b.n	800f71c <__aeabi_cdcmpeq>
 800f71a:	bf00      	nop

0800f71c <__aeabi_cdcmpeq>:
 800f71c:	b501      	push	{r0, lr}
 800f71e:	f7ff ffb7 	bl	800f690 <__cmpdf2>
 800f722:	2800      	cmp	r0, #0
 800f724:	bf48      	it	mi
 800f726:	f110 0f00 	cmnmi.w	r0, #0
 800f72a:	bd01      	pop	{r0, pc}

0800f72c <__aeabi_dcmpeq>:
 800f72c:	f84d ed08 	str.w	lr, [sp, #-8]!
 800f730:	f7ff fff4 	bl	800f71c <__aeabi_cdcmpeq>
 800f734:	bf0c      	ite	eq
 800f736:	2001      	moveq	r0, #1
 800f738:	2000      	movne	r0, #0
 800f73a:	f85d fb08 	ldr.w	pc, [sp], #8
 800f73e:	bf00      	nop

0800f740 <__aeabi_dcmplt>:
 800f740:	f84d ed08 	str.w	lr, [sp, #-8]!
 800f744:	f7ff ffea 	bl	800f71c <__aeabi_cdcmpeq>
 800f748:	bf34      	ite	cc
 800f74a:	2001      	movcc	r0, #1
 800f74c:	2000      	movcs	r0, #0
 800f74e:	f85d fb08 	ldr.w	pc, [sp], #8
 800f752:	bf00      	nop

0800f754 <__aeabi_dcmple>:
 800f754:	f84d ed08 	str.w	lr, [sp, #-8]!
 800f758:	f7ff ffe0 	bl	800f71c <__aeabi_cdcmpeq>
 800f75c:	bf94      	ite	ls
 800f75e:	2001      	movls	r0, #1
 800f760:	2000      	movhi	r0, #0
 800f762:	f85d fb08 	ldr.w	pc, [sp], #8
 800f766:	bf00      	nop

0800f768 <__aeabi_dcmpge>:
 800f768:	f84d ed08 	str.w	lr, [sp, #-8]!
 800f76c:	f7ff ffce 	bl	800f70c <__aeabi_cdrcmple>
 800f770:	bf94      	ite	ls
 800f772:	2001      	movls	r0, #1
 800f774:	2000      	movhi	r0, #0
 800f776:	f85d fb08 	ldr.w	pc, [sp], #8
 800f77a:	bf00      	nop

0800f77c <__aeabi_dcmpgt>:
 800f77c:	f84d ed08 	str.w	lr, [sp, #-8]!
 800f780:	f7ff ffc4 	bl	800f70c <__aeabi_cdrcmple>
 800f784:	bf34      	ite	cc
 800f786:	2001      	movcc	r0, #1
 800f788:	2000      	movcs	r0, #0
 800f78a:	f85d fb08 	ldr.w	pc, [sp], #8
 800f78e:	bf00      	nop

0800f790 <__aeabi_d2iz>:
 800f790:	ea4f 0241 	mov.w	r2, r1, lsl #1
 800f794:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 800f798:	d215      	bcs.n	800f7c6 <__aeabi_d2iz+0x36>
 800f79a:	d511      	bpl.n	800f7c0 <__aeabi_d2iz+0x30>
 800f79c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 800f7a0:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 800f7a4:	d912      	bls.n	800f7cc <__aeabi_d2iz+0x3c>
 800f7a6:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800f7aa:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800f7ae:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 800f7b2:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800f7b6:	fa23 f002 	lsr.w	r0, r3, r2
 800f7ba:	bf18      	it	ne
 800f7bc:	4240      	negne	r0, r0
 800f7be:	4770      	bx	lr
 800f7c0:	f04f 0000 	mov.w	r0, #0
 800f7c4:	4770      	bx	lr
 800f7c6:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 800f7ca:	d105      	bne.n	800f7d8 <__aeabi_d2iz+0x48>
 800f7cc:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 800f7d0:	bf08      	it	eq
 800f7d2:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 800f7d6:	4770      	bx	lr
 800f7d8:	f04f 0000 	mov.w	r0, #0
 800f7dc:	4770      	bx	lr
 800f7de:	bf00      	nop

0800f7e0 <__aeabi_uldivmod>:
 800f7e0:	b94b      	cbnz	r3, 800f7f6 <__aeabi_uldivmod+0x16>
 800f7e2:	b942      	cbnz	r2, 800f7f6 <__aeabi_uldivmod+0x16>
 800f7e4:	2900      	cmp	r1, #0
 800f7e6:	bf08      	it	eq
 800f7e8:	2800      	cmpeq	r0, #0
 800f7ea:	d002      	beq.n	800f7f2 <__aeabi_uldivmod+0x12>
 800f7ec:	f04f 31ff 	mov.w	r1, #4294967295
 800f7f0:	4608      	mov	r0, r1
 800f7f2:	f7ff bd31 	b.w	800f258 <__aeabi_idiv0>
 800f7f6:	b082      	sub	sp, #8
 800f7f8:	46ec      	mov	ip, sp
 800f7fa:	e92d 5000 	stmdb	sp!, {ip, lr}
 800f7fe:	f000 f81d 	bl	800f83c <__gnu_uldivmod_helper>
 800f802:	f8dd e004 	ldr.w	lr, [sp, #4]
 800f806:	b002      	add	sp, #8
 800f808:	bc0c      	pop	{r2, r3}
 800f80a:	4770      	bx	lr

0800f80c <__gnu_ldivmod_helper>:
 800f80c:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 800f810:	4616      	mov	r6, r2
 800f812:	4680      	mov	r8, r0
 800f814:	4689      	mov	r9, r1
 800f816:	461d      	mov	r5, r3
 800f818:	f000 f828 	bl	800f86c <__divdi3>
 800f81c:	fb00 f305 	mul.w	r3, r0, r5
 800f820:	fba0 4506 	umull	r4, r5, r0, r6
 800f824:	fb06 3601 	mla	r6, r6, r1, r3
 800f828:	9b06      	ldr	r3, [sp, #24]
 800f82a:	1975      	adds	r5, r6, r5
 800f82c:	ebb8 0404 	subs.w	r4, r8, r4
 800f830:	eb69 0505 	sbc.w	r5, r9, r5
 800f834:	e9c3 4500 	strd	r4, r5, [r3]
 800f838:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

0800f83c <__gnu_uldivmod_helper>:
 800f83c:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 800f840:	4616      	mov	r6, r2
 800f842:	4680      	mov	r8, r0
 800f844:	4689      	mov	r9, r1
 800f846:	461d      	mov	r5, r3
 800f848:	f000 f9c0 	bl	800fbcc <__udivdi3>
 800f84c:	fb00 f305 	mul.w	r3, r0, r5
 800f850:	fba0 4506 	umull	r4, r5, r0, r6
 800f854:	fb06 3601 	mla	r6, r6, r1, r3
 800f858:	9b06      	ldr	r3, [sp, #24]
 800f85a:	1975      	adds	r5, r6, r5
 800f85c:	ebb8 0404 	subs.w	r4, r8, r4
 800f860:	eb69 0505 	sbc.w	r5, r9, r5
 800f864:	e9c3 4500 	strd	r4, r5, [r3]
 800f868:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

0800f86c <__divdi3>:
 800f86c:	2900      	cmp	r1, #0
 800f86e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f872:	461c      	mov	r4, r3
 800f874:	b085      	sub	sp, #20
 800f876:	f2c0 80cb 	blt.w	800fa10 <__divdi3+0x1a4>
 800f87a:	2600      	movs	r6, #0
 800f87c:	2c00      	cmp	r4, #0
 800f87e:	f2c0 80c2 	blt.w	800fa06 <__divdi3+0x19a>
 800f882:	468c      	mov	ip, r1
 800f884:	4617      	mov	r7, r2
 800f886:	4614      	mov	r4, r2
 800f888:	4605      	mov	r5, r0
 800f88a:	4688      	mov	r8, r1
 800f88c:	469a      	mov	sl, r3
 800f88e:	2b00      	cmp	r3, #0
 800f890:	d14a      	bne.n	800f928 <__divdi3+0xbc>
 800f892:	428a      	cmp	r2, r1
 800f894:	d96e      	bls.n	800f974 <__divdi3+0x108>
 800f896:	fab2 f382 	clz	r3, r2
 800f89a:	b15b      	cbz	r3, 800f8b4 <__divdi3+0x48>
 800f89c:	f1c3 0420 	rsb	r4, r3, #32
 800f8a0:	fa01 f803 	lsl.w	r8, r1, r3
 800f8a4:	fa30 f204 	lsrs.w	r2, r0, r4
 800f8a8:	fa10 f503 	lsls.w	r5, r0, r3
 800f8ac:	fa17 f403 	lsls.w	r4, r7, r3
 800f8b0:	ea42 0808 	orr.w	r8, r2, r8
 800f8b4:	ea4f 4a14 	mov.w	sl, r4, lsr #16
 800f8b8:	4640      	mov	r0, r8
 800f8ba:	4651      	mov	r1, sl
 800f8bc:	fa1f fb84 	uxth.w	fp, r4
 800f8c0:	f7ff fb8e 	bl	800efe0 <__aeabi_uidiv>
 800f8c4:	4651      	mov	r1, sl
 800f8c6:	4681      	mov	r9, r0
 800f8c8:	4640      	mov	r0, r8
 800f8ca:	f7ff fcb7 	bl	800f23c <__aeabi_uidivmod>
 800f8ce:	0c28      	lsrs	r0, r5, #16
 800f8d0:	fb0b f309 	mul.w	r3, fp, r9
 800f8d4:	ea40 4801 	orr.w	r8, r0, r1, lsl #16
 800f8d8:	4543      	cmp	r3, r8
 800f8da:	d909      	bls.n	800f8f0 <__divdi3+0x84>
 800f8dc:	eb18 0804 	adds.w	r8, r8, r4
 800f8e0:	f109 39ff 	add.w	r9, r9, #4294967295
 800f8e4:	d204      	bcs.n	800f8f0 <__divdi3+0x84>
 800f8e6:	4543      	cmp	r3, r8
 800f8e8:	bf84      	itt	hi
 800f8ea:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800f8ee:	44a0      	addhi	r8, r4
 800f8f0:	ebc3 0808 	rsb	r8, r3, r8
 800f8f4:	4651      	mov	r1, sl
 800f8f6:	4640      	mov	r0, r8
 800f8f8:	b2ad      	uxth	r5, r5
 800f8fa:	f7ff fb71 	bl	800efe0 <__aeabi_uidiv>
 800f8fe:	4651      	mov	r1, sl
 800f900:	4607      	mov	r7, r0
 800f902:	4640      	mov	r0, r8
 800f904:	f7ff fc9a 	bl	800f23c <__aeabi_uidivmod>
 800f908:	fb0b fb07 	mul.w	fp, fp, r7
 800f90c:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
 800f910:	45ab      	cmp	fp, r5
 800f912:	d905      	bls.n	800f920 <__divdi3+0xb4>
 800f914:	3f01      	subs	r7, #1
 800f916:	192d      	adds	r5, r5, r4
 800f918:	d202      	bcs.n	800f920 <__divdi3+0xb4>
 800f91a:	45ab      	cmp	fp, r5
 800f91c:	bf88      	it	hi
 800f91e:	3f01      	subhi	r7, #1
 800f920:	ea47 4909 	orr.w	r9, r7, r9, lsl #16
 800f924:	2400      	movs	r4, #0
 800f926:	e003      	b.n	800f930 <__divdi3+0xc4>
 800f928:	428b      	cmp	r3, r1
 800f92a:	d90c      	bls.n	800f946 <__divdi3+0xda>
 800f92c:	2400      	movs	r4, #0
 800f92e:	46a1      	mov	r9, r4
 800f930:	464a      	mov	r2, r9
 800f932:	4623      	mov	r3, r4
 800f934:	b116      	cbz	r6, 800f93c <__divdi3+0xd0>
 800f936:	4252      	negs	r2, r2
 800f938:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800f93c:	4610      	mov	r0, r2
 800f93e:	4619      	mov	r1, r3
 800f940:	b005      	add	sp, #20
 800f942:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800f946:	fab3 f483 	clz	r4, r3
 800f94a:	2c00      	cmp	r4, #0
 800f94c:	f040 80b3 	bne.w	800fab6 <__divdi3+0x24a>
 800f950:	428b      	cmp	r3, r1
 800f952:	f04f 0901 	mov.w	r9, #1
 800f956:	bf2c      	ite	cs
 800f958:	f04f 0c00 	movcs.w	ip, #0
 800f95c:	f04f 0c01 	movcc.w	ip, #1
 800f960:	4282      	cmp	r2, r0
 800f962:	bf8c      	ite	hi
 800f964:	4667      	movhi	r7, ip
 800f966:	f04c 0701 	orrls.w	r7, ip, #1
 800f96a:	2f00      	cmp	r7, #0
 800f96c:	d1e0      	bne.n	800f930 <__divdi3+0xc4>
 800f96e:	463c      	mov	r4, r7
 800f970:	46b9      	mov	r9, r7
 800f972:	e7dd      	b.n	800f930 <__divdi3+0xc4>
 800f974:	b922      	cbnz	r2, 800f980 <__divdi3+0x114>
 800f976:	2001      	movs	r0, #1
 800f978:	4611      	mov	r1, r2
 800f97a:	f7ff fb31 	bl	800efe0 <__aeabi_uidiv>
 800f97e:	4604      	mov	r4, r0
 800f980:	fab4 f384 	clz	r3, r4
 800f984:	2b00      	cmp	r3, #0
 800f986:	d149      	bne.n	800fa1c <__divdi3+0x1b0>
 800f988:	ebc4 0808 	rsb	r8, r4, r8
 800f98c:	0c27      	lsrs	r7, r4, #16
 800f98e:	fa1f fa84 	uxth.w	sl, r4
 800f992:	2101      	movs	r1, #1
 800f994:	9102      	str	r1, [sp, #8]
 800f996:	4639      	mov	r1, r7
 800f998:	4640      	mov	r0, r8
 800f99a:	f7ff fb21 	bl	800efe0 <__aeabi_uidiv>
 800f99e:	4639      	mov	r1, r7
 800f9a0:	4681      	mov	r9, r0
 800f9a2:	4640      	mov	r0, r8
 800f9a4:	f7ff fc4a 	bl	800f23c <__aeabi_uidivmod>
 800f9a8:	0c2a      	lsrs	r2, r5, #16
 800f9aa:	fb0a f309 	mul.w	r3, sl, r9
 800f9ae:	ea42 4b01 	orr.w	fp, r2, r1, lsl #16
 800f9b2:	455b      	cmp	r3, fp
 800f9b4:	d909      	bls.n	800f9ca <__divdi3+0x15e>
 800f9b6:	eb1b 0b04 	adds.w	fp, fp, r4
 800f9ba:	f109 39ff 	add.w	r9, r9, #4294967295
 800f9be:	d204      	bcs.n	800f9ca <__divdi3+0x15e>
 800f9c0:	455b      	cmp	r3, fp
 800f9c2:	bf84      	itt	hi
 800f9c4:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800f9c8:	44a3      	addhi	fp, r4
 800f9ca:	ebc3 0b0b 	rsb	fp, r3, fp
 800f9ce:	4639      	mov	r1, r7
 800f9d0:	4658      	mov	r0, fp
 800f9d2:	b2ad      	uxth	r5, r5
 800f9d4:	f7ff fb04 	bl	800efe0 <__aeabi_uidiv>
 800f9d8:	4639      	mov	r1, r7
 800f9da:	4680      	mov	r8, r0
 800f9dc:	4658      	mov	r0, fp
 800f9de:	f7ff fc2d 	bl	800f23c <__aeabi_uidivmod>
 800f9e2:	fb0a fa08 	mul.w	sl, sl, r8
 800f9e6:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
 800f9ea:	45aa      	cmp	sl, r5
 800f9ec:	d907      	bls.n	800f9fe <__divdi3+0x192>
 800f9ee:	192d      	adds	r5, r5, r4
 800f9f0:	f108 38ff 	add.w	r8, r8, #4294967295
 800f9f4:	d203      	bcs.n	800f9fe <__divdi3+0x192>
 800f9f6:	45aa      	cmp	sl, r5
 800f9f8:	bf88      	it	hi
 800f9fa:	f108 38ff 	addhi.w	r8, r8, #4294967295
 800f9fe:	ea48 4909 	orr.w	r9, r8, r9, lsl #16
 800fa02:	9c02      	ldr	r4, [sp, #8]
 800fa04:	e794      	b.n	800f930 <__divdi3+0xc4>
 800fa06:	43f6      	mvns	r6, r6
 800fa08:	4252      	negs	r2, r2
 800fa0a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800fa0e:	e738      	b.n	800f882 <__divdi3+0x16>
 800fa10:	4240      	negs	r0, r0
 800fa12:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800fa16:	f04f 36ff 	mov.w	r6, #4294967295
 800fa1a:	e72f      	b.n	800f87c <__divdi3+0x10>
 800fa1c:	409c      	lsls	r4, r3
 800fa1e:	f1c3 0720 	rsb	r7, r3, #32
 800fa22:	fa28 fa07 	lsr.w	sl, r8, r7
 800fa26:	fa35 f207 	lsrs.w	r2, r5, r7
 800fa2a:	0c27      	lsrs	r7, r4, #16
 800fa2c:	fa08 fb03 	lsl.w	fp, r8, r3
 800fa30:	4639      	mov	r1, r7
 800fa32:	4650      	mov	r0, sl
 800fa34:	ea42 020b 	orr.w	r2, r2, fp
 800fa38:	409d      	lsls	r5, r3
 800fa3a:	9202      	str	r2, [sp, #8]
 800fa3c:	f7ff fad0 	bl	800efe0 <__aeabi_uidiv>
 800fa40:	4639      	mov	r1, r7
 800fa42:	4683      	mov	fp, r0
 800fa44:	4650      	mov	r0, sl
 800fa46:	f7ff fbf9 	bl	800f23c <__aeabi_uidivmod>
 800fa4a:	9b02      	ldr	r3, [sp, #8]
 800fa4c:	fa1f fa84 	uxth.w	sl, r4
 800fa50:	ea4f 4913 	mov.w	r9, r3, lsr #16
 800fa54:	fb0a f30b 	mul.w	r3, sl, fp
 800fa58:	ea49 4801 	orr.w	r8, r9, r1, lsl #16
 800fa5c:	4543      	cmp	r3, r8
 800fa5e:	d905      	bls.n	800fa6c <__divdi3+0x200>
 800fa60:	eb18 0804 	adds.w	r8, r8, r4
 800fa64:	f10b 3bff 	add.w	fp, fp, #4294967295
 800fa68:	f0c0 80aa 	bcc.w	800fbc0 <__divdi3+0x354>
 800fa6c:	ebc3 0808 	rsb	r8, r3, r8
 800fa70:	4639      	mov	r1, r7
 800fa72:	4640      	mov	r0, r8
 800fa74:	f7ff fab4 	bl	800efe0 <__aeabi_uidiv>
 800fa78:	4639      	mov	r1, r7
 800fa7a:	4681      	mov	r9, r0
 800fa7c:	4640      	mov	r0, r8
 800fa7e:	f7ff fbdd 	bl	800f23c <__aeabi_uidivmod>
 800fa82:	9802      	ldr	r0, [sp, #8]
 800fa84:	fb0a f309 	mul.w	r3, sl, r9
 800fa88:	fa1f fc80 	uxth.w	ip, r0
 800fa8c:	ea4c 4801 	orr.w	r8, ip, r1, lsl #16
 800fa90:	4543      	cmp	r3, r8
 800fa92:	d909      	bls.n	800faa8 <__divdi3+0x23c>
 800fa94:	eb18 0804 	adds.w	r8, r8, r4
 800fa98:	f109 39ff 	add.w	r9, r9, #4294967295
 800fa9c:	d204      	bcs.n	800faa8 <__divdi3+0x23c>
 800fa9e:	4543      	cmp	r3, r8
 800faa0:	bf84      	itt	hi
 800faa2:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800faa6:	44a0      	addhi	r8, r4
 800faa8:	ea49 4e0b 	orr.w	lr, r9, fp, lsl #16
 800faac:	ebc3 0808 	rsb	r8, r3, r8
 800fab0:	f8cd e008 	str.w	lr, [sp, #8]
 800fab4:	e76f      	b.n	800f996 <__divdi3+0x12a>
 800fab6:	f1c4 0320 	rsb	r3, r4, #32
 800faba:	fa0a fa04 	lsl.w	sl, sl, r4
 800fabe:	40da      	lsrs	r2, r3
 800fac0:	fa21 f803 	lsr.w	r8, r1, r3
 800fac4:	ea42 0a0a 	orr.w	sl, r2, sl
 800fac8:	fa01 f904 	lsl.w	r9, r1, r4
 800facc:	fa30 f203 	lsrs.w	r2, r0, r3
 800fad0:	4640      	mov	r0, r8
 800fad2:	ea4f 4b1a 	mov.w	fp, sl, lsr #16
 800fad6:	ea42 0109 	orr.w	r1, r2, r9
 800fada:	9103      	str	r1, [sp, #12]
 800fadc:	4659      	mov	r1, fp
 800fade:	fa17 f304 	lsls.w	r3, r7, r4
 800fae2:	9302      	str	r3, [sp, #8]
 800fae4:	f7ff fa7c 	bl	800efe0 <__aeabi_uidiv>
 800fae8:	4659      	mov	r1, fp
 800faea:	4681      	mov	r9, r0
 800faec:	4640      	mov	r0, r8
 800faee:	f7ff fba5 	bl	800f23c <__aeabi_uidivmod>
 800faf2:	fa1f f38a 	uxth.w	r3, sl
 800faf6:	9803      	ldr	r0, [sp, #12]
 800faf8:	fb03 f209 	mul.w	r2, r3, r9
 800fafc:	0c07      	lsrs	r7, r0, #16
 800fafe:	ea47 4801 	orr.w	r8, r7, r1, lsl #16
 800fb02:	4542      	cmp	r2, r8
 800fb04:	d904      	bls.n	800fb10 <__divdi3+0x2a4>
 800fb06:	eb18 080a 	adds.w	r8, r8, sl
 800fb0a:	f109 39ff 	add.w	r9, r9, #4294967295
 800fb0e:	d351      	bcc.n	800fbb4 <__divdi3+0x348>
 800fb10:	ebc2 0808 	rsb	r8, r2, r8
 800fb14:	4659      	mov	r1, fp
 800fb16:	4640      	mov	r0, r8
 800fb18:	9301      	str	r3, [sp, #4]
 800fb1a:	f7ff fa61 	bl	800efe0 <__aeabi_uidiv>
 800fb1e:	4659      	mov	r1, fp
 800fb20:	4607      	mov	r7, r0
 800fb22:	4640      	mov	r0, r8
 800fb24:	f7ff fb8a 	bl	800f23c <__aeabi_uidivmod>
 800fb28:	9b01      	ldr	r3, [sp, #4]
 800fb2a:	9803      	ldr	r0, [sp, #12]
 800fb2c:	fb03 f307 	mul.w	r3, r3, r7
 800fb30:	fa1f fc80 	uxth.w	ip, r0
 800fb34:	ea4c 4c01 	orr.w	ip, ip, r1, lsl #16
 800fb38:	4563      	cmp	r3, ip
 800fb3a:	d907      	bls.n	800fb4c <__divdi3+0x2e0>
 800fb3c:	3f01      	subs	r7, #1
 800fb3e:	eb1c 0c0a 	adds.w	ip, ip, sl
 800fb42:	d203      	bcs.n	800fb4c <__divdi3+0x2e0>
 800fb44:	4563      	cmp	r3, ip
 800fb46:	d901      	bls.n	800fb4c <__divdi3+0x2e0>
 800fb48:	3f01      	subs	r7, #1
 800fb4a:	44d4      	add	ip, sl
 800fb4c:	ea47 4909 	orr.w	r9, r7, r9, lsl #16
 800fb50:	9f02      	ldr	r7, [sp, #8]
 800fb52:	ebc3 0c0c 	rsb	ip, r3, ip
 800fb56:	fa1f fe89 	uxth.w	lr, r9
 800fb5a:	ea4f 4319 	mov.w	r3, r9, lsr #16
 800fb5e:	b2b8      	uxth	r0, r7
 800fb60:	0c3f      	lsrs	r7, r7, #16
 800fb62:	fb00 f80e 	mul.w	r8, r0, lr
 800fb66:	fb00 f103 	mul.w	r1, r0, r3
 800fb6a:	fb07 120e 	mla	r2, r7, lr, r1
 800fb6e:	fb07 f003 	mul.w	r0, r7, r3
 800fb72:	eb02 4218 	add.w	r2, r2, r8, lsr #16
 800fb76:	4291      	cmp	r1, r2
 800fb78:	bf88      	it	hi
 800fb7a:	f500 3080 	addhi.w	r0, r0, #65536	; 0x10000
 800fb7e:	eb00 4e12 	add.w	lr, r0, r2, lsr #16
 800fb82:	45f4      	cmp	ip, lr
 800fb84:	d312      	bcc.n	800fbac <__divdi3+0x340>
 800fb86:	ea4f 4202 	mov.w	r2, r2, lsl #16
 800fb8a:	fa1f f888 	uxth.w	r8, r8
 800fb8e:	bf14      	ite	ne
 800fb90:	2100      	movne	r1, #0
 800fb92:	2101      	moveq	r1, #1
 800fb94:	eb02 0c08 	add.w	ip, r2, r8
 800fb98:	fa15 f404 	lsls.w	r4, r5, r4
 800fb9c:	4564      	cmp	r4, ip
 800fb9e:	bf2c      	ite	cs
 800fba0:	2400      	movcs	r4, #0
 800fba2:	f001 0401 	andcc.w	r4, r1, #1
 800fba6:	2c00      	cmp	r4, #0
 800fba8:	f43f aec2 	beq.w	800f930 <__divdi3+0xc4>
 800fbac:	f109 39ff 	add.w	r9, r9, #4294967295
 800fbb0:	2400      	movs	r4, #0
 800fbb2:	e6bd      	b.n	800f930 <__divdi3+0xc4>
 800fbb4:	4542      	cmp	r2, r8
 800fbb6:	bf84      	itt	hi
 800fbb8:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800fbbc:	44d0      	addhi	r8, sl
 800fbbe:	e7a7      	b.n	800fb10 <__divdi3+0x2a4>
 800fbc0:	4543      	cmp	r3, r8
 800fbc2:	bf84      	itt	hi
 800fbc4:	f10b 3bff 	addhi.w	fp, fp, #4294967295
 800fbc8:	44a0      	addhi	r8, r4
 800fbca:	e74f      	b.n	800fa6c <__divdi3+0x200>

0800fbcc <__udivdi3>:
 800fbcc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800fbd0:	4605      	mov	r5, r0
 800fbd2:	b083      	sub	sp, #12
 800fbd4:	460c      	mov	r4, r1
 800fbd6:	4617      	mov	r7, r2
 800fbd8:	4680      	mov	r8, r0
 800fbda:	460e      	mov	r6, r1
 800fbdc:	2b00      	cmp	r3, #0
 800fbde:	d14d      	bne.n	800fc7c <__udivdi3+0xb0>
 800fbe0:	428a      	cmp	r2, r1
 800fbe2:	d961      	bls.n	800fca8 <__udivdi3+0xdc>
 800fbe4:	fab2 f382 	clz	r3, r2
 800fbe8:	b153      	cbz	r3, 800fc00 <__udivdi3+0x34>
 800fbea:	f1c3 0420 	rsb	r4, r3, #32
 800fbee:	fa11 f603 	lsls.w	r6, r1, r3
 800fbf2:	fa30 f204 	lsrs.w	r2, r0, r4
 800fbf6:	409f      	lsls	r7, r3
 800fbf8:	ea42 0606 	orr.w	r6, r2, r6
 800fbfc:	fa00 f803 	lsl.w	r8, r0, r3
 800fc00:	0c3c      	lsrs	r4, r7, #16
 800fc02:	4630      	mov	r0, r6
 800fc04:	4621      	mov	r1, r4
 800fc06:	fa1f fa87 	uxth.w	sl, r7
 800fc0a:	f7ff f9e9 	bl	800efe0 <__aeabi_uidiv>
 800fc0e:	4621      	mov	r1, r4
 800fc10:	4681      	mov	r9, r0
 800fc12:	4630      	mov	r0, r6
 800fc14:	f7ff fb12 	bl	800f23c <__aeabi_uidivmod>
 800fc18:	ea4f 4018 	mov.w	r0, r8, lsr #16
 800fc1c:	fb0a f309 	mul.w	r3, sl, r9
 800fc20:	ea40 4601 	orr.w	r6, r0, r1, lsl #16
 800fc24:	42b3      	cmp	r3, r6
 800fc26:	d908      	bls.n	800fc3a <__udivdi3+0x6e>
 800fc28:	19f6      	adds	r6, r6, r7
 800fc2a:	f109 39ff 	add.w	r9, r9, #4294967295
 800fc2e:	d204      	bcs.n	800fc3a <__udivdi3+0x6e>
 800fc30:	42b3      	cmp	r3, r6
 800fc32:	bf84      	itt	hi
 800fc34:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800fc38:	19f6      	addhi	r6, r6, r7
 800fc3a:	1af6      	subs	r6, r6, r3
 800fc3c:	4621      	mov	r1, r4
 800fc3e:	4630      	mov	r0, r6
 800fc40:	fa1f f888 	uxth.w	r8, r8
 800fc44:	f7ff f9cc 	bl	800efe0 <__aeabi_uidiv>
 800fc48:	4621      	mov	r1, r4
 800fc4a:	4605      	mov	r5, r0
 800fc4c:	4630      	mov	r0, r6
 800fc4e:	f7ff faf5 	bl	800f23c <__aeabi_uidivmod>
 800fc52:	fb0a fa05 	mul.w	sl, sl, r5
 800fc56:	ea48 4801 	orr.w	r8, r8, r1, lsl #16
 800fc5a:	45c2      	cmp	sl, r8
 800fc5c:	d906      	bls.n	800fc6c <__udivdi3+0xa0>
 800fc5e:	3d01      	subs	r5, #1
 800fc60:	eb18 0807 	adds.w	r8, r8, r7
 800fc64:	d202      	bcs.n	800fc6c <__udivdi3+0xa0>
 800fc66:	45c2      	cmp	sl, r8
 800fc68:	bf88      	it	hi
 800fc6a:	3d01      	subhi	r5, #1
 800fc6c:	ea45 4a09 	orr.w	sl, r5, r9, lsl #16
 800fc70:	2600      	movs	r6, #0
 800fc72:	4631      	mov	r1, r6
 800fc74:	4650      	mov	r0, sl
 800fc76:	b003      	add	sp, #12
 800fc78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800fc7c:	428b      	cmp	r3, r1
 800fc7e:	d85b      	bhi.n	800fd38 <__udivdi3+0x16c>
 800fc80:	fab3 f683 	clz	r6, r3
 800fc84:	2e00      	cmp	r6, #0
 800fc86:	d15a      	bne.n	800fd3e <__udivdi3+0x172>
 800fc88:	428b      	cmp	r3, r1
 800fc8a:	f04f 0a01 	mov.w	sl, #1
 800fc8e:	bf2c      	ite	cs
 800fc90:	2400      	movcs	r4, #0
 800fc92:	2401      	movcc	r4, #1
 800fc94:	4282      	cmp	r2, r0
 800fc96:	bf8c      	ite	hi
 800fc98:	4625      	movhi	r5, r4
 800fc9a:	f044 0501 	orrls.w	r5, r4, #1
 800fc9e:	2d00      	cmp	r5, #0
 800fca0:	d1e7      	bne.n	800fc72 <__udivdi3+0xa6>
 800fca2:	462e      	mov	r6, r5
 800fca4:	46aa      	mov	sl, r5
 800fca6:	e7e4      	b.n	800fc72 <__udivdi3+0xa6>
 800fca8:	b922      	cbnz	r2, 800fcb4 <__udivdi3+0xe8>
 800fcaa:	2001      	movs	r0, #1
 800fcac:	4611      	mov	r1, r2
 800fcae:	f7ff f997 	bl	800efe0 <__aeabi_uidiv>
 800fcb2:	4607      	mov	r7, r0
 800fcb4:	fab7 f387 	clz	r3, r7
 800fcb8:	2b00      	cmp	r3, #0
 800fcba:	f040 80b6 	bne.w	800fe2a <__udivdi3+0x25e>
 800fcbe:	1be4      	subs	r4, r4, r7
 800fcc0:	ea4f 4b17 	mov.w	fp, r7, lsr #16
 800fcc4:	b2bd      	uxth	r5, r7
 800fcc6:	2601      	movs	r6, #1
 800fcc8:	4659      	mov	r1, fp
 800fcca:	4620      	mov	r0, r4
 800fccc:	f7ff f988 	bl	800efe0 <__aeabi_uidiv>
 800fcd0:	4659      	mov	r1, fp
 800fcd2:	ea4f 4918 	mov.w	r9, r8, lsr #16
 800fcd6:	4682      	mov	sl, r0
 800fcd8:	4620      	mov	r0, r4
 800fcda:	f7ff faaf 	bl	800f23c <__aeabi_uidivmod>
 800fcde:	fb05 f30a 	mul.w	r3, r5, sl
 800fce2:	ea49 4401 	orr.w	r4, r9, r1, lsl #16
 800fce6:	42a3      	cmp	r3, r4
 800fce8:	d908      	bls.n	800fcfc <__udivdi3+0x130>
 800fcea:	19e4      	adds	r4, r4, r7
 800fcec:	f10a 3aff 	add.w	sl, sl, #4294967295
 800fcf0:	d204      	bcs.n	800fcfc <__udivdi3+0x130>
 800fcf2:	42a3      	cmp	r3, r4
 800fcf4:	bf84      	itt	hi
 800fcf6:	f10a 3aff 	addhi.w	sl, sl, #4294967295
 800fcfa:	19e4      	addhi	r4, r4, r7
 800fcfc:	1ae4      	subs	r4, r4, r3
 800fcfe:	4659      	mov	r1, fp
 800fd00:	4620      	mov	r0, r4
 800fd02:	f7ff f96d 	bl	800efe0 <__aeabi_uidiv>
 800fd06:	4659      	mov	r1, fp
 800fd08:	4681      	mov	r9, r0
 800fd0a:	4620      	mov	r0, r4
 800fd0c:	f7ff fa96 	bl	800f23c <__aeabi_uidivmod>
 800fd10:	fa1f f388 	uxth.w	r3, r8
 800fd14:	fb05 f509 	mul.w	r5, r5, r9
 800fd18:	ea43 4801 	orr.w	r8, r3, r1, lsl #16
 800fd1c:	4545      	cmp	r5, r8
 800fd1e:	d908      	bls.n	800fd32 <__udivdi3+0x166>
 800fd20:	eb18 0807 	adds.w	r8, r8, r7
 800fd24:	f109 39ff 	add.w	r9, r9, #4294967295
 800fd28:	d203      	bcs.n	800fd32 <__udivdi3+0x166>
 800fd2a:	4545      	cmp	r5, r8
 800fd2c:	bf88      	it	hi
 800fd2e:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800fd32:	ea49 4a0a 	orr.w	sl, r9, sl, lsl #16
 800fd36:	e79c      	b.n	800fc72 <__udivdi3+0xa6>
 800fd38:	2600      	movs	r6, #0
 800fd3a:	46b2      	mov	sl, r6
 800fd3c:	e799      	b.n	800fc72 <__udivdi3+0xa6>
 800fd3e:	f1c6 0120 	rsb	r1, r6, #32
 800fd42:	40b3      	lsls	r3, r6
 800fd44:	fa32 f701 	lsrs.w	r7, r2, r1
 800fd48:	fa24 f901 	lsr.w	r9, r4, r1
 800fd4c:	431f      	orrs	r7, r3
 800fd4e:	40b4      	lsls	r4, r6
 800fd50:	fa30 f301 	lsrs.w	r3, r0, r1
 800fd54:	4648      	mov	r0, r9
 800fd56:	ea4f 4817 	mov.w	r8, r7, lsr #16
 800fd5a:	ea43 0104 	orr.w	r1, r3, r4
 800fd5e:	9101      	str	r1, [sp, #4]
 800fd60:	4641      	mov	r1, r8
 800fd62:	40b2      	lsls	r2, r6
 800fd64:	9200      	str	r2, [sp, #0]
 800fd66:	f7ff f93b 	bl	800efe0 <__aeabi_uidiv>
 800fd6a:	4641      	mov	r1, r8
 800fd6c:	b2bc      	uxth	r4, r7
 800fd6e:	4682      	mov	sl, r0
 800fd70:	4648      	mov	r0, r9
 800fd72:	f7ff fa63 	bl	800f23c <__aeabi_uidivmod>
 800fd76:	9801      	ldr	r0, [sp, #4]
 800fd78:	fb04 f30a 	mul.w	r3, r4, sl
 800fd7c:	ea4f 4b10 	mov.w	fp, r0, lsr #16
 800fd80:	ea4b 4b01 	orr.w	fp, fp, r1, lsl #16
 800fd84:	455b      	cmp	r3, fp
 800fd86:	d905      	bls.n	800fd94 <__udivdi3+0x1c8>
 800fd88:	eb1b 0b07 	adds.w	fp, fp, r7
 800fd8c:	f10a 3aff 	add.w	sl, sl, #4294967295
 800fd90:	f0c0 8093 	bcc.w	800feba <__udivdi3+0x2ee>
 800fd94:	ebc3 0b0b 	rsb	fp, r3, fp
 800fd98:	4641      	mov	r1, r8
 800fd9a:	4658      	mov	r0, fp
 800fd9c:	f7ff f920 	bl	800efe0 <__aeabi_uidiv>
 800fda0:	4641      	mov	r1, r8
 800fda2:	4681      	mov	r9, r0
 800fda4:	4658      	mov	r0, fp
 800fda6:	f7ff fa49 	bl	800f23c <__aeabi_uidivmod>
 800fdaa:	9801      	ldr	r0, [sp, #4]
 800fdac:	fb04 f409 	mul.w	r4, r4, r9
 800fdb0:	fa1f fc80 	uxth.w	ip, r0
 800fdb4:	ea4c 4301 	orr.w	r3, ip, r1, lsl #16
 800fdb8:	429c      	cmp	r4, r3
 800fdba:	d903      	bls.n	800fdc4 <__udivdi3+0x1f8>
 800fdbc:	19db      	adds	r3, r3, r7
 800fdbe:	f109 39ff 	add.w	r9, r9, #4294967295
 800fdc2:	d374      	bcc.n	800feae <__udivdi3+0x2e2>
 800fdc4:	9f00      	ldr	r7, [sp, #0]
 800fdc6:	ea49 4a0a 	orr.w	sl, r9, sl, lsl #16
 800fdca:	1b1c      	subs	r4, r3, r4
 800fdcc:	fa1f fe8a 	uxth.w	lr, sl
 800fdd0:	b2b8      	uxth	r0, r7
 800fdd2:	0c3a      	lsrs	r2, r7, #16
 800fdd4:	ea4f 471a 	mov.w	r7, sl, lsr #16
 800fdd8:	fb00 fc0e 	mul.w	ip, r0, lr
 800fddc:	fb00 f307 	mul.w	r3, r0, r7
 800fde0:	fb02 310e 	mla	r1, r2, lr, r3
 800fde4:	fb02 f207 	mul.w	r2, r2, r7
 800fde8:	eb01 411c 	add.w	r1, r1, ip, lsr #16
 800fdec:	428b      	cmp	r3, r1
 800fdee:	bf88      	it	hi
 800fdf0:	f502 3280 	addhi.w	r2, r2, #65536	; 0x10000
 800fdf4:	eb02 4e11 	add.w	lr, r2, r1, lsr #16
 800fdf8:	4574      	cmp	r4, lr
 800fdfa:	d312      	bcc.n	800fe22 <__udivdi3+0x256>
 800fdfc:	ea4f 4101 	mov.w	r1, r1, lsl #16
 800fe00:	fa1f f28c 	uxth.w	r2, ip
 800fe04:	bf14      	ite	ne
 800fe06:	2300      	movne	r3, #0
 800fe08:	2301      	moveq	r3, #1
 800fe0a:	eb01 0c02 	add.w	ip, r1, r2
 800fe0e:	fa15 f606 	lsls.w	r6, r5, r6
 800fe12:	4566      	cmp	r6, ip
 800fe14:	bf2c      	ite	cs
 800fe16:	2600      	movcs	r6, #0
 800fe18:	f003 0601 	andcc.w	r6, r3, #1
 800fe1c:	2e00      	cmp	r6, #0
 800fe1e:	f43f af28 	beq.w	800fc72 <__udivdi3+0xa6>
 800fe22:	f10a 3aff 	add.w	sl, sl, #4294967295
 800fe26:	2600      	movs	r6, #0
 800fe28:	e723      	b.n	800fc72 <__udivdi3+0xa6>
 800fe2a:	409f      	lsls	r7, r3
 800fe2c:	f1c3 0120 	rsb	r1, r3, #32
 800fe30:	fa34 f601 	lsrs.w	r6, r4, r1
 800fe34:	fa14 f203 	lsls.w	r2, r4, r3
 800fe38:	ea4f 4b17 	mov.w	fp, r7, lsr #16
 800fe3c:	fa25 fa01 	lsr.w	sl, r5, r1
 800fe40:	4630      	mov	r0, r6
 800fe42:	4659      	mov	r1, fp
 800fe44:	fa05 f803 	lsl.w	r8, r5, r3
 800fe48:	ea4a 0a02 	orr.w	sl, sl, r2
 800fe4c:	f7ff f8c8 	bl	800efe0 <__aeabi_uidiv>
 800fe50:	4659      	mov	r1, fp
 800fe52:	b2bd      	uxth	r5, r7
 800fe54:	4681      	mov	r9, r0
 800fe56:	4630      	mov	r0, r6
 800fe58:	f7ff f9f0 	bl	800f23c <__aeabi_uidivmod>
 800fe5c:	ea4f 4c1a 	mov.w	ip, sl, lsr #16
 800fe60:	fb05 f309 	mul.w	r3, r5, r9
 800fe64:	ea4c 4401 	orr.w	r4, ip, r1, lsl #16
 800fe68:	42a3      	cmp	r3, r4
 800fe6a:	d903      	bls.n	800fe74 <__udivdi3+0x2a8>
 800fe6c:	19e4      	adds	r4, r4, r7
 800fe6e:	f109 39ff 	add.w	r9, r9, #4294967295
 800fe72:	d328      	bcc.n	800fec6 <__udivdi3+0x2fa>
 800fe74:	1ae4      	subs	r4, r4, r3
 800fe76:	4659      	mov	r1, fp
 800fe78:	4620      	mov	r0, r4
 800fe7a:	f7ff f8b1 	bl	800efe0 <__aeabi_uidiv>
 800fe7e:	4659      	mov	r1, fp
 800fe80:	4606      	mov	r6, r0
 800fe82:	4620      	mov	r0, r4
 800fe84:	f7ff f9da 	bl	800f23c <__aeabi_uidivmod>
 800fe88:	fa1f f48a 	uxth.w	r4, sl
 800fe8c:	fb05 f306 	mul.w	r3, r5, r6
 800fe90:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 800fe94:	42a3      	cmp	r3, r4
 800fe96:	d906      	bls.n	800fea6 <__udivdi3+0x2da>
 800fe98:	3e01      	subs	r6, #1
 800fe9a:	19e4      	adds	r4, r4, r7
 800fe9c:	d203      	bcs.n	800fea6 <__udivdi3+0x2da>
 800fe9e:	42a3      	cmp	r3, r4
 800fea0:	d901      	bls.n	800fea6 <__udivdi3+0x2da>
 800fea2:	3e01      	subs	r6, #1
 800fea4:	19e4      	adds	r4, r4, r7
 800fea6:	1ae4      	subs	r4, r4, r3
 800fea8:	ea46 4609 	orr.w	r6, r6, r9, lsl #16
 800feac:	e70c      	b.n	800fcc8 <__udivdi3+0xfc>
 800feae:	429c      	cmp	r4, r3
 800feb0:	bf84      	itt	hi
 800feb2:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800feb6:	19db      	addhi	r3, r3, r7
 800feb8:	e784      	b.n	800fdc4 <__udivdi3+0x1f8>
 800feba:	455b      	cmp	r3, fp
 800febc:	bf84      	itt	hi
 800febe:	f10a 3aff 	addhi.w	sl, sl, #4294967295
 800fec2:	44bb      	addhi	fp, r7
 800fec4:	e766      	b.n	800fd94 <__udivdi3+0x1c8>
 800fec6:	42a3      	cmp	r3, r4
 800fec8:	bf84      	itt	hi
 800feca:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800fece:	19e4      	addhi	r4, r4, r7
 800fed0:	e7d0      	b.n	800fe74 <__udivdi3+0x2a8>
 800fed2:	bf00      	nop

0800fed4 <Reset_Handler>:
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
 800fed4:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800fed6:	e003      	b.n	800fee0 <LoopCopyDataInit>

0800fed8 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800fed8:	4b0b      	ldr	r3, [pc, #44]	; (800ff08 <LoopFillZerobss+0x14>)
  ldr  r3, [r3, r1]
 800feda:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800fedc:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800fede:	3104      	adds	r1, #4

0800fee0 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr  r0, =_sdata
 800fee0:	480a      	ldr	r0, [pc, #40]	; (800ff0c <LoopFillZerobss+0x18>)
  ldr  r3, =_edata
 800fee2:	4b0b      	ldr	r3, [pc, #44]	; (800ff10 <LoopFillZerobss+0x1c>)
  adds  r2, r0, r1
 800fee4:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800fee6:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800fee8:	d3f6      	bcc.n	800fed8 <CopyDataInit>
  ldr  r2, =_sbss
 800feea:	4a0a      	ldr	r2, [pc, #40]	; (800ff14 <LoopFillZerobss+0x20>)
  b  LoopFillZerobss
 800feec:	e002      	b.n	800fef4 <LoopFillZerobss>

0800feee <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs  r3, #0
 800feee:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800fef0:	f842 3b04 	str.w	r3, [r2], #4

0800fef4 <LoopFillZerobss>:

LoopFillZerobss:
  ldr  r3, = _ebss
 800fef4:	4b08      	ldr	r3, [pc, #32]	; (800ff18 <LoopFillZerobss+0x24>)
  cmp  r2, r3
 800fef6:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800fef8:	d3f9      	bcc.n	800feee <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 800fefa:	f7f0 ff81 	bl	8000e00 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 800fefe:	f7f6 faf7 	bl	80064f0 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800ff02:	f7f0 fe51 	bl	8000ba8 <main>
  bx  lr
 800ff06:	4770      	bx	lr
 800ff08:	080104dc 	.word	0x080104dc
 800ff0c:	20000000 	.word	0x20000000
 800ff10:	20000800 	.word	0x20000800
 800ff14:	20000800 	.word	0x20000800
 800ff18:	20002aa0 	.word	0x20002aa0

0800ff1c <Default_Handler2>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler2:
Infinite_Loop:
  b  Infinite_Loop
 800ff1c:	e7fe      	b.n	800ff1c <Default_Handler2>
	...

0800ff20 <clocks>:
 800ff20:	0101 0405 0000 0000 1200 007a 0007 0000     ..........z.....
 800ff30:	0054 0002 756f 7074 7475 6f54 7172 6575     T...outputTorque
 800ff40:	203a 3225 6630 0000 6954 656d 203a 3225     : %20f..Time: %2
 800ff50:	6430 0000                                   0d..

0800ff54 <can_params>:
 800ff54:	0000 03a0 a120 0007 0003 0400 0b04 0001     .... ...........
 800ff64:	0001 0000                                   ....

0800ff68 <canPC>:
 800ff68:	0000 3320 0008 0000 3210 7654 ba98 fedc     .. 3.....2Tv....
 800ff78:	0000 3340 0004 0000 ccdd aabb 0000 0000     ..@3............
 800ff88:	0000 3360 0000 0000 0000 0000 0000 0000     ..`3............
 800ff98:	333c 3333 0008 0000 2200 6644 aa88 eecc     <333....."Df....
 800ffa8:	0002 3380 0000 0000 0000 0000 0000 0000     ...3............

0800ffb8 <canCAN>:
 800ffb8:	0000 5520 0008 0000 3210 7654 ba98 fedc     .. U.....2Tv....
 800ffc8:	0000 5540 0004 0000 ccdd aabb 0000 0000     ..@U............
 800ffd8:	0000 5560 0000 0000 0000 0000 0000 0000     ..`U............
 800ffe8:	555c 5555 0008 0000 2200 6644 aa88 eecc     \UUU....."Df....

0800fff8 <CSWTCH.6>:
 800fff8:	0102 0002                                   ....

0800fffc <h>:
 800fffc:	3130 3332 3534 3736 3938 4241 4443 4645     0123456789ABCDEF

0801000c <hxbn>:
	...
 801003c:	0100 0302 0504 0706 0908 0000 0000 0000     ................
 801004c:	0a00 0c0b 0e0d 000f 0000 0000 0000 0000     ................
	...
 801006c:	0a00 0c0b 0e0d 000f 0000 0000 0000 0000     ................
	...

0801010c <outputaf>:
 801010c:	0002 0003 0209                                   .....

08010111 <inputpup>:
 8010111:	0002 0100 0109                                   .....

08010116 <outputpp>:
 8010116:	0001 0003 0100                                   .....

0801011b <outputcs>:
 801011b:	0001 0003 0200                                   .....

08010120 <outputaf>:
 8010120:	0002 0003 0205                                   .....

08010125 <inputaf>:
 8010125:	0002 0100 0105                                   .....

0801012a <ahbtbl>:
 801012a:	0001 0001 0001 0001 0001 0001 0001 0001     ................
 801013a:	0002 0004 0008 0010 0040 0080 0100 0200     ........@.......
	...

0801014c <tcif_tbl>:
 801014c:	0600 1610                                   ....

08010150 <open_name>:
 8010150:	044a 0801 0388 0801 044f 0801 0454 0801     J.......O...T...
 8010160:	0459 0801 045e 0801 0463 0801 0468 0801     Y...^...c...h...

08010170 <C.0.4985>:
 8010170:	0002 0003 0200                                   .....

08010175 <C.1.4986>:
 8010175:	0002 0100 0000 8000                              .......

0801017c <_global_impure_ptr>:
 801017c:	0280 2000                                   ... 

08010180 <blanks.6598>:
 8010180:	2020 2020 2020 2020 2020 2020 2020 2020                     

08010190 <zeroes.6599>:
 8010190:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000

080101a0 <blanks.6613>:
 80101a0:	2020 2020 2020 2020 2020 2020 2020 2020                     

080101b0 <zeroes.6614>:
 80101b0:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000

080101c0 <__sf_fake_stdin>:
	...

080101e0 <__sf_fake_stdout>:
	...

08010200 <__sf_fake_stderr>:
	...

08010220 <p05.5124>:
 8010220:	0005 0000 0019 0000 007d 0000 0000 0000     ........}.......

08010230 <__mprec_tens>:
 8010230:	0000 0000 0000 3ff0 0000 0000 0000 4024     .......?......$@
 8010240:	0000 0000 0000 4059 0000 0000 4000 408f     ......Y@.....@.@
 8010250:	0000 0000 8800 40c3 0000 0000 6a00 40f8     .......@.....j.@
 8010260:	0000 0000 8480 412e 0000 0000 12d0 4163     .......A......cA
 8010270:	0000 0000 d784 4197 0000 0000 cd65 41cd     .......A....e..A
 8010280:	0000 2000 a05f 4202 0000 e800 4876 4237     ... _..B....vH7B
 8010290:	0000 a200 1a94 426d 0000 e540 309c 42a2     ......mB..@..0.B
 80102a0:	0000 1e90 bcc4 42d6 0000 2634 6bf5 430c     .......B..4&.k.C
 80102b0:	8000 37e0 c379 4341 a000 85d8 3457 4376     ...7y.AC....W4vC
 80102c0:	c800 674e c16d 43ab 3d00 6091 58e4 43e1     ..Ngm..C.=.`.X.C
 80102d0:	8c40 78b5 af1d 4415 ef50 d6e2 1ae4 444b     @..x...DP.....KD
 80102e0:	d592 064d f0cf 4480 4af6 c7e1 2d02 44b5     ..M....D.J...-.D
 80102f0:	9db4 79d9 7843 44ea                         ...yCx.D

080102f8 <__mprec_bigtens>:
 80102f8:	8000 37e0 c379 4341 6e17 b505 b8b5 4693     ...7y.AC.n.....F
 8010308:	f9f5 e93f 4f03 4d38 1d32 f930 7748 5a82     ..?..O8M2.0.Hw.Z
 8010318:	bf3c 7f73 4fdd 7515                         <.s..O.u

08010320 <__mprec_tinytens>:
 8010320:	89bc 97d8 d2b2 3c9c a733 d5a8 f623 3949     .......<3...#.I9
 8010330:	a73d 44f4 0ffd 32a5 979d cf8c ba08 255b     =..D...2......[%
 8010340:	6f43 64ac 0628 0ac8                         Co.d(...

08010348 <blanks.6542>:
 8010348:	2020 2020 2020 2020 2020 2020 2020 2020                     

08010358 <zeroes.6543>:
 8010358:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000

08010368 <blanks.6556>:
 8010368:	2020 2020 2020 2020 2020 2020 2020 2020                     

08010378 <zeroes.6557>:
 8010378:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000
 8010388:	7474 3279 5400 7365 2074 6f43 6e75 3a74     tty2.Test Count:
 8010398:	2520 6435 3300 2520 0a73 000d 2032 7325      %5d.3 %s...2 %s
 80103a8:	0d0a 2500 3631 2573 6434 4300 7275 6572     ...%16s%4d.Curre
 80103b8:	746e 5320 6174 6574 003a 4356 2050 6e49     nt State:.VCP In
 80103c8:	6574 6672 6361 0065 4356 2050 6f43 666e     terface.VCP Conf
 80103d8:	6769 3000 3030 3030 3030 3030 3035 0042     ig.00000000050B.
 80103e8:	3030 3030 3030 3030 3530 4330 5300 4d54     00000000050C.STM
 80103f8:	6369 6f72 6c65 6365 7274 6e6f 6369 0073     icroelectronics.
 8010408:	5453 334d 2032 6956 7472 6175 206c 6f43     STM32 Virtual Co
 8010418:	506d 726f 2074 6e69 4820 2053 6f6d 6564     mPort in HS mode
 8010428:	5300 4d54 3233 5620 7269 7574 6c61 4320     .STM32 Virtual C
 8010438:	6d6f 6f50 7472 6920 206e 5346 4d20 646f     omPort in FS Mod
 8010448:	0065 7474 3179 7400 7974 0033 7474 3479     e.tty1.tty3.tty4
 8010458:	7400 7974 0035 7474 3679 7400 7974 0037     .tty5.tty6.tty7.
 8010468:	7474 3879 0000 0000 0043 0000 4e49 0046     tty8....C...INF.
 8010478:	6e69 0066 414e 004e 616e 006e 3130 3332     inf.NAN.nan.0123
 8010488:	3534 3736 3938 4241 4443 4645 0000 0000     456789ABCDEF....
 8010498:	3130 3332 3534 3736 3938 6261 6463 6665     0123456789abcdef
 80104a8:	0000 0000 6e28 6c75 296c 0000 0030 0000     ....(null)..0...
 80104b8:	6e49 6966 696e 7974 0000 0000 614e 004e     Infinity....NaN.
 80104c8:	4f50 4953 0058 0000 002e 0000               POSIX.......
