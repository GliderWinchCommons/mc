
spi2test.elf:     file format elf32-littlearm


Disassembly of section .text:

08000188 <Default_Handler08>:
int _read(int file, char *ptr, int len);

/* --------------- For debugging...(usb) ------------------------------ */
int Default_HandlerCode = 999;
u32 DH08;
void Default_Handler08(void) {DH08 += 1; return;}
 8000188:	4b02      	ldr	r3, [pc, #8]	; (8000194 <Default_Handler08+0xc>)
 800018a:	681a      	ldr	r2, [r3, #0]
 800018c:	3201      	adds	r2, #1
 800018e:	601a      	str	r2, [r3, #0]
 8000190:	4770      	bx	lr
 8000192:	bf00      	nop
 8000194:	20000b34 	.word	0x20000b34

08000198 <Default_Handler76>:

void OTG_FS_IRQHandler(void);
void Default_Handler76(void) {	OTG_FS_IRQHandler(); return; }
 8000198:	f000 bd6c 	b.w	8000c74 <OTG_FS_IRQHandler>

0800019c <Default_Handler00>:

void Default_Handler00(void) { Default_HandlerCode =  0; panic_leds(5); }
 800019c:	4b02      	ldr	r3, [pc, #8]	; (80001a8 <Default_Handler00+0xc>)
 800019e:	2200      	movs	r2, #0
 80001a0:	2005      	movs	r0, #5
 80001a2:	601a      	str	r2, [r3, #0]
 80001a4:	f003 bccd 	b.w	8003b42 <panic_leds>
 80001a8:	20000000 	.word	0x20000000

080001ac <Default_Handler01>:
void Default_Handler01(void) { Default_HandlerCode =  1; panic_leds(5); }
 80001ac:	4b02      	ldr	r3, [pc, #8]	; (80001b8 <Default_Handler01+0xc>)
 80001ae:	2201      	movs	r2, #1
 80001b0:	2005      	movs	r0, #5
 80001b2:	601a      	str	r2, [r3, #0]
 80001b4:	f003 bcc5 	b.w	8003b42 <panic_leds>
 80001b8:	20000000 	.word	0x20000000

080001bc <Default_Handler02>:
void Default_Handler02(void) { Default_HandlerCode =  2; panic_leds(5); }
 80001bc:	4b02      	ldr	r3, [pc, #8]	; (80001c8 <Default_Handler02+0xc>)
 80001be:	2202      	movs	r2, #2
 80001c0:	2005      	movs	r0, #5
 80001c2:	601a      	str	r2, [r3, #0]
 80001c4:	f003 bcbd 	b.w	8003b42 <panic_leds>
 80001c8:	20000000 	.word	0x20000000

080001cc <Default_Handler03>:
void Default_Handler03(void) { Default_HandlerCode =  3; panic_leds(5); }
 80001cc:	4b02      	ldr	r3, [pc, #8]	; (80001d8 <Default_Handler03+0xc>)
 80001ce:	2203      	movs	r2, #3
 80001d0:	2005      	movs	r0, #5
 80001d2:	601a      	str	r2, [r3, #0]
 80001d4:	f003 bcb5 	b.w	8003b42 <panic_leds>
 80001d8:	20000000 	.word	0x20000000

080001dc <Default_Handler04>:
void Default_Handler04(void) { Default_HandlerCode =  4; panic_leds(5); }
 80001dc:	4b02      	ldr	r3, [pc, #8]	; (80001e8 <Default_Handler04+0xc>)
 80001de:	2204      	movs	r2, #4
 80001e0:	2005      	movs	r0, #5
 80001e2:	601a      	str	r2, [r3, #0]
 80001e4:	f003 bcad 	b.w	8003b42 <panic_leds>
 80001e8:	20000000 	.word	0x20000000

080001ec <Default_Handler05>:
void Default_Handler05(void) { Default_HandlerCode =  5; panic_leds(5); }
 80001ec:	4b02      	ldr	r3, [pc, #8]	; (80001f8 <Default_Handler05+0xc>)
 80001ee:	2005      	movs	r0, #5
 80001f0:	6018      	str	r0, [r3, #0]
 80001f2:	f003 bca6 	b.w	8003b42 <panic_leds>
 80001f6:	bf00      	nop
 80001f8:	20000000 	.word	0x20000000

080001fc <Default_Handler06>:
void Default_Handler06(void) { Default_HandlerCode =  6; panic_leds(5); }
 80001fc:	4b02      	ldr	r3, [pc, #8]	; (8000208 <Default_Handler06+0xc>)
 80001fe:	2206      	movs	r2, #6
 8000200:	2005      	movs	r0, #5
 8000202:	601a      	str	r2, [r3, #0]
 8000204:	f003 bc9d 	b.w	8003b42 <panic_leds>
 8000208:	20000000 	.word	0x20000000

0800020c <Default_Handler07>:
void Default_Handler07(void) { Default_HandlerCode =  7; panic_leds(5); }
 800020c:	4b02      	ldr	r3, [pc, #8]	; (8000218 <Default_Handler07+0xc>)
 800020e:	2207      	movs	r2, #7
 8000210:	2005      	movs	r0, #5
 8000212:	601a      	str	r2, [r3, #0]
 8000214:	f003 bc95 	b.w	8003b42 <panic_leds>
 8000218:	20000000 	.word	0x20000000

0800021c <Default_Handler09>:
//void Default_Handler08(void) { Default_HandlerCode =  8; panic_leds(5); }
void Default_Handler09(void) { Default_HandlerCode =  9; panic_leds(5); }
 800021c:	4b02      	ldr	r3, [pc, #8]	; (8000228 <Default_Handler09+0xc>)
 800021e:	2209      	movs	r2, #9
 8000220:	2005      	movs	r0, #5
 8000222:	601a      	str	r2, [r3, #0]
 8000224:	f003 bc8d 	b.w	8003b42 <panic_leds>
 8000228:	20000000 	.word	0x20000000

0800022c <Default_Handler10>:
void Default_Handler10(void) { Default_HandlerCode = 10; panic_leds(5); }
 800022c:	4b02      	ldr	r3, [pc, #8]	; (8000238 <Default_Handler10+0xc>)
 800022e:	220a      	movs	r2, #10
 8000230:	2005      	movs	r0, #5
 8000232:	601a      	str	r2, [r3, #0]
 8000234:	f003 bc85 	b.w	8003b42 <panic_leds>
 8000238:	20000000 	.word	0x20000000

0800023c <Default_Handler11>:
void Default_Handler11(void) { Default_HandlerCode = 11; panic_leds(5); }
 800023c:	4b02      	ldr	r3, [pc, #8]	; (8000248 <Default_Handler11+0xc>)
 800023e:	220b      	movs	r2, #11
 8000240:	2005      	movs	r0, #5
 8000242:	601a      	str	r2, [r3, #0]
 8000244:	f003 bc7d 	b.w	8003b42 <panic_leds>
 8000248:	20000000 	.word	0x20000000

0800024c <Default_Handler12>:
void Default_Handler12(void) { Default_HandlerCode = 12; panic_leds(5); }
 800024c:	4b02      	ldr	r3, [pc, #8]	; (8000258 <Default_Handler12+0xc>)
 800024e:	220c      	movs	r2, #12
 8000250:	2005      	movs	r0, #5
 8000252:	601a      	str	r2, [r3, #0]
 8000254:	f003 bc75 	b.w	8003b42 <panic_leds>
 8000258:	20000000 	.word	0x20000000

0800025c <Default_Handler13>:
void Default_Handler13(void) { Default_HandlerCode = 13; panic_leds(5); }
 800025c:	4b02      	ldr	r3, [pc, #8]	; (8000268 <Default_Handler13+0xc>)
 800025e:	220d      	movs	r2, #13
 8000260:	2005      	movs	r0, #5
 8000262:	601a      	str	r2, [r3, #0]
 8000264:	f003 bc6d 	b.w	8003b42 <panic_leds>
 8000268:	20000000 	.word	0x20000000

0800026c <Default_Handler14>:
void Default_Handler14(void) { Default_HandlerCode = 14; panic_leds(5); }
 800026c:	4b02      	ldr	r3, [pc, #8]	; (8000278 <Default_Handler14+0xc>)
 800026e:	220e      	movs	r2, #14
 8000270:	2005      	movs	r0, #5
 8000272:	601a      	str	r2, [r3, #0]
 8000274:	f003 bc65 	b.w	8003b42 <panic_leds>
 8000278:	20000000 	.word	0x20000000

0800027c <Default_Handler15>:
void Default_Handler15(void) { Default_HandlerCode = 15; panic_leds(5); }
 800027c:	4b02      	ldr	r3, [pc, #8]	; (8000288 <Default_Handler15+0xc>)
 800027e:	220f      	movs	r2, #15
 8000280:	2005      	movs	r0, #5
 8000282:	601a      	str	r2, [r3, #0]
 8000284:	f003 bc5d 	b.w	8003b42 <panic_leds>
 8000288:	20000000 	.word	0x20000000

0800028c <Default_Handler16>:
void Default_Handler16(void) { Default_HandlerCode = 16; panic_leds(5); }
 800028c:	4b02      	ldr	r3, [pc, #8]	; (8000298 <Default_Handler16+0xc>)
 800028e:	2210      	movs	r2, #16
 8000290:	2005      	movs	r0, #5
 8000292:	601a      	str	r2, [r3, #0]
 8000294:	f003 bc55 	b.w	8003b42 <panic_leds>
 8000298:	20000000 	.word	0x20000000

0800029c <Default_Handler17>:
void Default_Handler17(void) { Default_HandlerCode = 17; panic_leds(5); }
 800029c:	4b02      	ldr	r3, [pc, #8]	; (80002a8 <Default_Handler17+0xc>)
 800029e:	2211      	movs	r2, #17
 80002a0:	2005      	movs	r0, #5
 80002a2:	601a      	str	r2, [r3, #0]
 80002a4:	f003 bc4d 	b.w	8003b42 <panic_leds>
 80002a8:	20000000 	.word	0x20000000

080002ac <Default_Handler18>:
void Default_Handler18(void) { Default_HandlerCode = 18; panic_leds(5); }
 80002ac:	4b02      	ldr	r3, [pc, #8]	; (80002b8 <Default_Handler18+0xc>)
 80002ae:	2212      	movs	r2, #18
 80002b0:	2005      	movs	r0, #5
 80002b2:	601a      	str	r2, [r3, #0]
 80002b4:	f003 bc45 	b.w	8003b42 <panic_leds>
 80002b8:	20000000 	.word	0x20000000

080002bc <Default_Handler19>:
void Default_Handler19(void) { Default_HandlerCode = 19; panic_leds(5); }
 80002bc:	4b02      	ldr	r3, [pc, #8]	; (80002c8 <Default_Handler19+0xc>)
 80002be:	2213      	movs	r2, #19
 80002c0:	2005      	movs	r0, #5
 80002c2:	601a      	str	r2, [r3, #0]
 80002c4:	f003 bc3d 	b.w	8003b42 <panic_leds>
 80002c8:	20000000 	.word	0x20000000

080002cc <Default_Handler20>:
void Default_Handler20(void) { Default_HandlerCode = 20; panic_leds(5); }
 80002cc:	4b02      	ldr	r3, [pc, #8]	; (80002d8 <Default_Handler20+0xc>)
 80002ce:	2214      	movs	r2, #20
 80002d0:	2005      	movs	r0, #5
 80002d2:	601a      	str	r2, [r3, #0]
 80002d4:	f003 bc35 	b.w	8003b42 <panic_leds>
 80002d8:	20000000 	.word	0x20000000

080002dc <Default_Handler21>:
void Default_Handler21(void) { Default_HandlerCode = 21; panic_leds(5); }
 80002dc:	4b02      	ldr	r3, [pc, #8]	; (80002e8 <Default_Handler21+0xc>)
 80002de:	2215      	movs	r2, #21
 80002e0:	2005      	movs	r0, #5
 80002e2:	601a      	str	r2, [r3, #0]
 80002e4:	f003 bc2d 	b.w	8003b42 <panic_leds>
 80002e8:	20000000 	.word	0x20000000

080002ec <Default_Handler22>:
void Default_Handler22(void) { Default_HandlerCode = 22; panic_leds(5); }
 80002ec:	4b02      	ldr	r3, [pc, #8]	; (80002f8 <Default_Handler22+0xc>)
 80002ee:	2216      	movs	r2, #22
 80002f0:	2005      	movs	r0, #5
 80002f2:	601a      	str	r2, [r3, #0]
 80002f4:	f003 bc25 	b.w	8003b42 <panic_leds>
 80002f8:	20000000 	.word	0x20000000

080002fc <Default_Handler23>:
void Default_Handler23(void) { Default_HandlerCode = 23; panic_leds(5); }
 80002fc:	4b02      	ldr	r3, [pc, #8]	; (8000308 <Default_Handler23+0xc>)
 80002fe:	2217      	movs	r2, #23
 8000300:	2005      	movs	r0, #5
 8000302:	601a      	str	r2, [r3, #0]
 8000304:	f003 bc1d 	b.w	8003b42 <panic_leds>
 8000308:	20000000 	.word	0x20000000

0800030c <Default_Handler24>:
void Default_Handler24(void) { Default_HandlerCode = 24; panic_leds(5); }
 800030c:	4b02      	ldr	r3, [pc, #8]	; (8000318 <Default_Handler24+0xc>)
 800030e:	2218      	movs	r2, #24
 8000310:	2005      	movs	r0, #5
 8000312:	601a      	str	r2, [r3, #0]
 8000314:	f003 bc15 	b.w	8003b42 <panic_leds>
 8000318:	20000000 	.word	0x20000000

0800031c <Default_Handler25>:
void Default_Handler25(void) { Default_HandlerCode = 25; panic_leds(5); }
 800031c:	4b02      	ldr	r3, [pc, #8]	; (8000328 <Default_Handler25+0xc>)
 800031e:	2219      	movs	r2, #25
 8000320:	2005      	movs	r0, #5
 8000322:	601a      	str	r2, [r3, #0]
 8000324:	f003 bc0d 	b.w	8003b42 <panic_leds>
 8000328:	20000000 	.word	0x20000000

0800032c <Default_Handler26>:
void Default_Handler26(void) { Default_HandlerCode = 26; panic_leds(5); }
 800032c:	4b02      	ldr	r3, [pc, #8]	; (8000338 <Default_Handler26+0xc>)
 800032e:	221a      	movs	r2, #26
 8000330:	2005      	movs	r0, #5
 8000332:	601a      	str	r2, [r3, #0]
 8000334:	f003 bc05 	b.w	8003b42 <panic_leds>
 8000338:	20000000 	.word	0x20000000

0800033c <Default_Handler27>:
void Default_Handler27(void) { Default_HandlerCode = 27; panic_leds(5); }
 800033c:	4b02      	ldr	r3, [pc, #8]	; (8000348 <Default_Handler27+0xc>)
 800033e:	221b      	movs	r2, #27
 8000340:	2005      	movs	r0, #5
 8000342:	601a      	str	r2, [r3, #0]
 8000344:	f003 bbfd 	b.w	8003b42 <panic_leds>
 8000348:	20000000 	.word	0x20000000

0800034c <Default_Handler28>:
void Default_Handler28(void) { Default_HandlerCode = 28; panic_leds(5); }
 800034c:	4b02      	ldr	r3, [pc, #8]	; (8000358 <Default_Handler28+0xc>)
 800034e:	221c      	movs	r2, #28
 8000350:	2005      	movs	r0, #5
 8000352:	601a      	str	r2, [r3, #0]
 8000354:	f003 bbf5 	b.w	8003b42 <panic_leds>
 8000358:	20000000 	.word	0x20000000

0800035c <Default_Handler29>:
void Default_Handler29(void) { Default_HandlerCode = 29; panic_leds(5); }
 800035c:	4b02      	ldr	r3, [pc, #8]	; (8000368 <Default_Handler29+0xc>)
 800035e:	221d      	movs	r2, #29
 8000360:	2005      	movs	r0, #5
 8000362:	601a      	str	r2, [r3, #0]
 8000364:	f003 bbed 	b.w	8003b42 <panic_leds>
 8000368:	20000000 	.word	0x20000000

0800036c <Default_Handler30>:
void Default_Handler30(void) { Default_HandlerCode = 30; panic_leds(5); }
 800036c:	4b02      	ldr	r3, [pc, #8]	; (8000378 <Default_Handler30+0xc>)
 800036e:	221e      	movs	r2, #30
 8000370:	2005      	movs	r0, #5
 8000372:	601a      	str	r2, [r3, #0]
 8000374:	f003 bbe5 	b.w	8003b42 <panic_leds>
 8000378:	20000000 	.word	0x20000000

0800037c <Default_Handler31>:
void Default_Handler31(void) { Default_HandlerCode = 31; panic_leds(5); }
 800037c:	4b02      	ldr	r3, [pc, #8]	; (8000388 <Default_Handler31+0xc>)
 800037e:	221f      	movs	r2, #31
 8000380:	2005      	movs	r0, #5
 8000382:	601a      	str	r2, [r3, #0]
 8000384:	f003 bbdd 	b.w	8003b42 <panic_leds>
 8000388:	20000000 	.word	0x20000000

0800038c <Default_Handler32>:
void Default_Handler32(void) { Default_HandlerCode = 32; panic_leds(5); }
 800038c:	4b02      	ldr	r3, [pc, #8]	; (8000398 <Default_Handler32+0xc>)
 800038e:	2220      	movs	r2, #32
 8000390:	2005      	movs	r0, #5
 8000392:	601a      	str	r2, [r3, #0]
 8000394:	f003 bbd5 	b.w	8003b42 <panic_leds>
 8000398:	20000000 	.word	0x20000000

0800039c <Default_Handler33>:
void Default_Handler33(void) { Default_HandlerCode = 33; panic_leds(5); }
 800039c:	4b02      	ldr	r3, [pc, #8]	; (80003a8 <Default_Handler33+0xc>)
 800039e:	2221      	movs	r2, #33	; 0x21
 80003a0:	2005      	movs	r0, #5
 80003a2:	601a      	str	r2, [r3, #0]
 80003a4:	f003 bbcd 	b.w	8003b42 <panic_leds>
 80003a8:	20000000 	.word	0x20000000

080003ac <Default_Handler34>:
void Default_Handler34(void) { Default_HandlerCode = 34; panic_leds(5); }
 80003ac:	4b02      	ldr	r3, [pc, #8]	; (80003b8 <Default_Handler34+0xc>)
 80003ae:	2222      	movs	r2, #34	; 0x22
 80003b0:	2005      	movs	r0, #5
 80003b2:	601a      	str	r2, [r3, #0]
 80003b4:	f003 bbc5 	b.w	8003b42 <panic_leds>
 80003b8:	20000000 	.word	0x20000000

080003bc <Default_Handler35>:
void Default_Handler35(void) { Default_HandlerCode = 35; panic_leds(5); }
 80003bc:	4b02      	ldr	r3, [pc, #8]	; (80003c8 <Default_Handler35+0xc>)
 80003be:	2223      	movs	r2, #35	; 0x23
 80003c0:	2005      	movs	r0, #5
 80003c2:	601a      	str	r2, [r3, #0]
 80003c4:	f003 bbbd 	b.w	8003b42 <panic_leds>
 80003c8:	20000000 	.word	0x20000000

080003cc <Default_Handler36>:
void Default_Handler36(void) { Default_HandlerCode = 36; panic_leds(5); }
 80003cc:	4b02      	ldr	r3, [pc, #8]	; (80003d8 <Default_Handler36+0xc>)
 80003ce:	2224      	movs	r2, #36	; 0x24
 80003d0:	2005      	movs	r0, #5
 80003d2:	601a      	str	r2, [r3, #0]
 80003d4:	f003 bbb5 	b.w	8003b42 <panic_leds>
 80003d8:	20000000 	.word	0x20000000

080003dc <Default_Handler37>:
void Default_Handler37(void) { Default_HandlerCode = 37; panic_leds(5); }
 80003dc:	4b02      	ldr	r3, [pc, #8]	; (80003e8 <Default_Handler37+0xc>)
 80003de:	2225      	movs	r2, #37	; 0x25
 80003e0:	2005      	movs	r0, #5
 80003e2:	601a      	str	r2, [r3, #0]
 80003e4:	f003 bbad 	b.w	8003b42 <panic_leds>
 80003e8:	20000000 	.word	0x20000000

080003ec <Default_Handler38>:
void Default_Handler38(void) { Default_HandlerCode = 38; panic_leds(5); }
 80003ec:	4b02      	ldr	r3, [pc, #8]	; (80003f8 <Default_Handler38+0xc>)
 80003ee:	2226      	movs	r2, #38	; 0x26
 80003f0:	2005      	movs	r0, #5
 80003f2:	601a      	str	r2, [r3, #0]
 80003f4:	f003 bba5 	b.w	8003b42 <panic_leds>
 80003f8:	20000000 	.word	0x20000000

080003fc <Default_Handler39>:
void Default_Handler39(void) { Default_HandlerCode = 39; panic_leds(5); }
 80003fc:	4b02      	ldr	r3, [pc, #8]	; (8000408 <Default_Handler39+0xc>)
 80003fe:	2227      	movs	r2, #39	; 0x27
 8000400:	2005      	movs	r0, #5
 8000402:	601a      	str	r2, [r3, #0]
 8000404:	f003 bb9d 	b.w	8003b42 <panic_leds>
 8000408:	20000000 	.word	0x20000000

0800040c <Default_Handler40>:
void Default_Handler40(void) { Default_HandlerCode = 40; panic_leds(5); }
 800040c:	4b02      	ldr	r3, [pc, #8]	; (8000418 <Default_Handler40+0xc>)
 800040e:	2228      	movs	r2, #40	; 0x28
 8000410:	2005      	movs	r0, #5
 8000412:	601a      	str	r2, [r3, #0]
 8000414:	f003 bb95 	b.w	8003b42 <panic_leds>
 8000418:	20000000 	.word	0x20000000

0800041c <Default_Handler41>:
void Default_Handler41(void) { Default_HandlerCode = 41; panic_leds(5); }
 800041c:	4b02      	ldr	r3, [pc, #8]	; (8000428 <Default_Handler41+0xc>)
 800041e:	2229      	movs	r2, #41	; 0x29
 8000420:	2005      	movs	r0, #5
 8000422:	601a      	str	r2, [r3, #0]
 8000424:	f003 bb8d 	b.w	8003b42 <panic_leds>
 8000428:	20000000 	.word	0x20000000

0800042c <Default_Handler42>:
void Default_Handler42(void) { Default_HandlerCode = 42; panic_leds(5); }
 800042c:	4b02      	ldr	r3, [pc, #8]	; (8000438 <Default_Handler42+0xc>)
 800042e:	222a      	movs	r2, #42	; 0x2a
 8000430:	2005      	movs	r0, #5
 8000432:	601a      	str	r2, [r3, #0]
 8000434:	f003 bb85 	b.w	8003b42 <panic_leds>
 8000438:	20000000 	.word	0x20000000

0800043c <Default_Handler43>:
void Default_Handler43(void) { Default_HandlerCode = 43; panic_leds(5); }
 800043c:	4b02      	ldr	r3, [pc, #8]	; (8000448 <Default_Handler43+0xc>)
 800043e:	222b      	movs	r2, #43	; 0x2b
 8000440:	2005      	movs	r0, #5
 8000442:	601a      	str	r2, [r3, #0]
 8000444:	f003 bb7d 	b.w	8003b42 <panic_leds>
 8000448:	20000000 	.word	0x20000000

0800044c <Default_Handler44>:
void Default_Handler44(void) { Default_HandlerCode = 44; panic_leds(5); }
 800044c:	4b02      	ldr	r3, [pc, #8]	; (8000458 <Default_Handler44+0xc>)
 800044e:	222c      	movs	r2, #44	; 0x2c
 8000450:	2005      	movs	r0, #5
 8000452:	601a      	str	r2, [r3, #0]
 8000454:	f003 bb75 	b.w	8003b42 <panic_leds>
 8000458:	20000000 	.word	0x20000000

0800045c <Default_Handler45>:
void Default_Handler45(void) { Default_HandlerCode = 45; panic_leds(5); }
 800045c:	4b02      	ldr	r3, [pc, #8]	; (8000468 <Default_Handler45+0xc>)
 800045e:	222d      	movs	r2, #45	; 0x2d
 8000460:	2005      	movs	r0, #5
 8000462:	601a      	str	r2, [r3, #0]
 8000464:	f003 bb6d 	b.w	8003b42 <panic_leds>
 8000468:	20000000 	.word	0x20000000

0800046c <Default_Handler46>:
void Default_Handler46(void) { Default_HandlerCode = 46; panic_leds(5); }
 800046c:	4b02      	ldr	r3, [pc, #8]	; (8000478 <Default_Handler46+0xc>)
 800046e:	222e      	movs	r2, #46	; 0x2e
 8000470:	2005      	movs	r0, #5
 8000472:	601a      	str	r2, [r3, #0]
 8000474:	f003 bb65 	b.w	8003b42 <panic_leds>
 8000478:	20000000 	.word	0x20000000

0800047c <Default_Handler47>:
void Default_Handler47(void) { Default_HandlerCode = 47; panic_leds(5); }
 800047c:	4b02      	ldr	r3, [pc, #8]	; (8000488 <Default_Handler47+0xc>)
 800047e:	222f      	movs	r2, #47	; 0x2f
 8000480:	2005      	movs	r0, #5
 8000482:	601a      	str	r2, [r3, #0]
 8000484:	f003 bb5d 	b.w	8003b42 <panic_leds>
 8000488:	20000000 	.word	0x20000000

0800048c <Default_Handler48>:
void Default_Handler48(void) { Default_HandlerCode = 48; panic_leds(5); }
 800048c:	4b02      	ldr	r3, [pc, #8]	; (8000498 <Default_Handler48+0xc>)
 800048e:	2230      	movs	r2, #48	; 0x30
 8000490:	2005      	movs	r0, #5
 8000492:	601a      	str	r2, [r3, #0]
 8000494:	f003 bb55 	b.w	8003b42 <panic_leds>
 8000498:	20000000 	.word	0x20000000

0800049c <Default_Handler49>:
void Default_Handler49(void) { Default_HandlerCode = 49; panic_leds(5); }
 800049c:	4b02      	ldr	r3, [pc, #8]	; (80004a8 <Default_Handler49+0xc>)
 800049e:	2231      	movs	r2, #49	; 0x31
 80004a0:	2005      	movs	r0, #5
 80004a2:	601a      	str	r2, [r3, #0]
 80004a4:	f003 bb4d 	b.w	8003b42 <panic_leds>
 80004a8:	20000000 	.word	0x20000000

080004ac <Default_Handler50>:
void Default_Handler50(void) { Default_HandlerCode = 50; panic_leds(5); }
 80004ac:	4b02      	ldr	r3, [pc, #8]	; (80004b8 <Default_Handler50+0xc>)
 80004ae:	2232      	movs	r2, #50	; 0x32
 80004b0:	2005      	movs	r0, #5
 80004b2:	601a      	str	r2, [r3, #0]
 80004b4:	f003 bb45 	b.w	8003b42 <panic_leds>
 80004b8:	20000000 	.word	0x20000000

080004bc <Default_Handler51>:
void Default_Handler51(void) { Default_HandlerCode = 51; panic_leds(5); }
 80004bc:	4b02      	ldr	r3, [pc, #8]	; (80004c8 <Default_Handler51+0xc>)
 80004be:	2233      	movs	r2, #51	; 0x33
 80004c0:	2005      	movs	r0, #5
 80004c2:	601a      	str	r2, [r3, #0]
 80004c4:	f003 bb3d 	b.w	8003b42 <panic_leds>
 80004c8:	20000000 	.word	0x20000000

080004cc <Default_Handler52>:
void Default_Handler52(void) { Default_HandlerCode = 52; panic_leds(5); }
 80004cc:	4b02      	ldr	r3, [pc, #8]	; (80004d8 <Default_Handler52+0xc>)
 80004ce:	2234      	movs	r2, #52	; 0x34
 80004d0:	2005      	movs	r0, #5
 80004d2:	601a      	str	r2, [r3, #0]
 80004d4:	f003 bb35 	b.w	8003b42 <panic_leds>
 80004d8:	20000000 	.word	0x20000000

080004dc <Default_Handler53>:
void Default_Handler53(void) { Default_HandlerCode = 53; panic_leds(5); }
 80004dc:	4b02      	ldr	r3, [pc, #8]	; (80004e8 <Default_Handler53+0xc>)
 80004de:	2235      	movs	r2, #53	; 0x35
 80004e0:	2005      	movs	r0, #5
 80004e2:	601a      	str	r2, [r3, #0]
 80004e4:	f003 bb2d 	b.w	8003b42 <panic_leds>
 80004e8:	20000000 	.word	0x20000000

080004ec <Default_Handler54>:
void Default_Handler54(void) { Default_HandlerCode = 54; panic_leds(5); }
 80004ec:	4b02      	ldr	r3, [pc, #8]	; (80004f8 <Default_Handler54+0xc>)
 80004ee:	2236      	movs	r2, #54	; 0x36
 80004f0:	2005      	movs	r0, #5
 80004f2:	601a      	str	r2, [r3, #0]
 80004f4:	f003 bb25 	b.w	8003b42 <panic_leds>
 80004f8:	20000000 	.word	0x20000000

080004fc <Default_Handler55>:
void Default_Handler55(void) { Default_HandlerCode = 55; panic_leds(5); }
 80004fc:	4b02      	ldr	r3, [pc, #8]	; (8000508 <Default_Handler55+0xc>)
 80004fe:	2237      	movs	r2, #55	; 0x37
 8000500:	2005      	movs	r0, #5
 8000502:	601a      	str	r2, [r3, #0]
 8000504:	f003 bb1d 	b.w	8003b42 <panic_leds>
 8000508:	20000000 	.word	0x20000000

0800050c <Default_Handler56>:
void Default_Handler56(void) { Default_HandlerCode = 56; panic_leds(5); }
 800050c:	4b02      	ldr	r3, [pc, #8]	; (8000518 <Default_Handler56+0xc>)
 800050e:	2238      	movs	r2, #56	; 0x38
 8000510:	2005      	movs	r0, #5
 8000512:	601a      	str	r2, [r3, #0]
 8000514:	f003 bb15 	b.w	8003b42 <panic_leds>
 8000518:	20000000 	.word	0x20000000

0800051c <Default_Handler57>:
void Default_Handler57(void) { Default_HandlerCode = 57; panic_leds(5); }
 800051c:	4b02      	ldr	r3, [pc, #8]	; (8000528 <Default_Handler57+0xc>)
 800051e:	2239      	movs	r2, #57	; 0x39
 8000520:	2005      	movs	r0, #5
 8000522:	601a      	str	r2, [r3, #0]
 8000524:	f003 bb0d 	b.w	8003b42 <panic_leds>
 8000528:	20000000 	.word	0x20000000

0800052c <Default_Handler58>:
void Default_Handler58(void) { Default_HandlerCode = 58; panic_leds(5); }
 800052c:	4b02      	ldr	r3, [pc, #8]	; (8000538 <Default_Handler58+0xc>)
 800052e:	223a      	movs	r2, #58	; 0x3a
 8000530:	2005      	movs	r0, #5
 8000532:	601a      	str	r2, [r3, #0]
 8000534:	f003 bb05 	b.w	8003b42 <panic_leds>
 8000538:	20000000 	.word	0x20000000

0800053c <Default_Handler59>:
void Default_Handler59(void) { Default_HandlerCode = 59; panic_leds(5); }
 800053c:	4b02      	ldr	r3, [pc, #8]	; (8000548 <Default_Handler59+0xc>)
 800053e:	223b      	movs	r2, #59	; 0x3b
 8000540:	2005      	movs	r0, #5
 8000542:	601a      	str	r2, [r3, #0]
 8000544:	f003 bafd 	b.w	8003b42 <panic_leds>
 8000548:	20000000 	.word	0x20000000

0800054c <Default_Handler60>:
void Default_Handler60(void) { Default_HandlerCode = 60; panic_leds(5); }
 800054c:	4b02      	ldr	r3, [pc, #8]	; (8000558 <Default_Handler60+0xc>)
 800054e:	223c      	movs	r2, #60	; 0x3c
 8000550:	2005      	movs	r0, #5
 8000552:	601a      	str	r2, [r3, #0]
 8000554:	f003 baf5 	b.w	8003b42 <panic_leds>
 8000558:	20000000 	.word	0x20000000

0800055c <Default_Handler61>:
void Default_Handler61(void) { Default_HandlerCode = 61; panic_leds(5); }
 800055c:	4b02      	ldr	r3, [pc, #8]	; (8000568 <Default_Handler61+0xc>)
 800055e:	223d      	movs	r2, #61	; 0x3d
 8000560:	2005      	movs	r0, #5
 8000562:	601a      	str	r2, [r3, #0]
 8000564:	f003 baed 	b.w	8003b42 <panic_leds>
 8000568:	20000000 	.word	0x20000000

0800056c <Default_Handler62>:
void Default_Handler62(void) { Default_HandlerCode = 62; panic_leds(5); }
 800056c:	4b02      	ldr	r3, [pc, #8]	; (8000578 <Default_Handler62+0xc>)
 800056e:	223e      	movs	r2, #62	; 0x3e
 8000570:	2005      	movs	r0, #5
 8000572:	601a      	str	r2, [r3, #0]
 8000574:	f003 bae5 	b.w	8003b42 <panic_leds>
 8000578:	20000000 	.word	0x20000000

0800057c <Default_Handler63>:
void Default_Handler63(void) { Default_HandlerCode = 63; panic_leds(5); }
 800057c:	4b02      	ldr	r3, [pc, #8]	; (8000588 <Default_Handler63+0xc>)
 800057e:	223f      	movs	r2, #63	; 0x3f
 8000580:	2005      	movs	r0, #5
 8000582:	601a      	str	r2, [r3, #0]
 8000584:	f003 badd 	b.w	8003b42 <panic_leds>
 8000588:	20000000 	.word	0x20000000

0800058c <Default_Handler64>:
void Default_Handler64(void) { Default_HandlerCode = 64; panic_leds(5); }
 800058c:	4b02      	ldr	r3, [pc, #8]	; (8000598 <Default_Handler64+0xc>)
 800058e:	2240      	movs	r2, #64	; 0x40
 8000590:	2005      	movs	r0, #5
 8000592:	601a      	str	r2, [r3, #0]
 8000594:	f003 bad5 	b.w	8003b42 <panic_leds>
 8000598:	20000000 	.word	0x20000000

0800059c <Default_Handler65>:
void Default_Handler65(void) { Default_HandlerCode = 65; panic_leds(5); }
 800059c:	4b02      	ldr	r3, [pc, #8]	; (80005a8 <Default_Handler65+0xc>)
 800059e:	2241      	movs	r2, #65	; 0x41
 80005a0:	2005      	movs	r0, #5
 80005a2:	601a      	str	r2, [r3, #0]
 80005a4:	f003 bacd 	b.w	8003b42 <panic_leds>
 80005a8:	20000000 	.word	0x20000000

080005ac <Default_Handler66>:
void Default_Handler66(void) { Default_HandlerCode = 66; panic_leds(5); }
 80005ac:	4b02      	ldr	r3, [pc, #8]	; (80005b8 <Default_Handler66+0xc>)
 80005ae:	2242      	movs	r2, #66	; 0x42
 80005b0:	2005      	movs	r0, #5
 80005b2:	601a      	str	r2, [r3, #0]
 80005b4:	f003 bac5 	b.w	8003b42 <panic_leds>
 80005b8:	20000000 	.word	0x20000000

080005bc <Default_Handler67>:
void Default_Handler67(void) { Default_HandlerCode = 67; panic_leds(5); }
 80005bc:	4b02      	ldr	r3, [pc, #8]	; (80005c8 <Default_Handler67+0xc>)
 80005be:	2243      	movs	r2, #67	; 0x43
 80005c0:	2005      	movs	r0, #5
 80005c2:	601a      	str	r2, [r3, #0]
 80005c4:	f003 babd 	b.w	8003b42 <panic_leds>
 80005c8:	20000000 	.word	0x20000000

080005cc <Default_Handler68>:
void Default_Handler68(void) { Default_HandlerCode = 68; panic_leds(5); }
 80005cc:	4b02      	ldr	r3, [pc, #8]	; (80005d8 <Default_Handler68+0xc>)
 80005ce:	2244      	movs	r2, #68	; 0x44
 80005d0:	2005      	movs	r0, #5
 80005d2:	601a      	str	r2, [r3, #0]
 80005d4:	f003 bab5 	b.w	8003b42 <panic_leds>
 80005d8:	20000000 	.word	0x20000000

080005dc <Default_Handler69>:
void Default_Handler69(void) { Default_HandlerCode = 69; panic_leds(5); }
 80005dc:	4b02      	ldr	r3, [pc, #8]	; (80005e8 <Default_Handler69+0xc>)
 80005de:	2245      	movs	r2, #69	; 0x45
 80005e0:	2005      	movs	r0, #5
 80005e2:	601a      	str	r2, [r3, #0]
 80005e4:	f003 baad 	b.w	8003b42 <panic_leds>
 80005e8:	20000000 	.word	0x20000000

080005ec <Default_Handler70>:
void Default_Handler70(void) { Default_HandlerCode = 70; panic_leds(5); }
 80005ec:	4b02      	ldr	r3, [pc, #8]	; (80005f8 <Default_Handler70+0xc>)
 80005ee:	2246      	movs	r2, #70	; 0x46
 80005f0:	2005      	movs	r0, #5
 80005f2:	601a      	str	r2, [r3, #0]
 80005f4:	f003 baa5 	b.w	8003b42 <panic_leds>
 80005f8:	20000000 	.word	0x20000000

080005fc <Default_Handler71>:
void Default_Handler71(void) { Default_HandlerCode = 71; panic_leds(5); }
 80005fc:	4b02      	ldr	r3, [pc, #8]	; (8000608 <Default_Handler71+0xc>)
 80005fe:	2247      	movs	r2, #71	; 0x47
 8000600:	2005      	movs	r0, #5
 8000602:	601a      	str	r2, [r3, #0]
 8000604:	f003 ba9d 	b.w	8003b42 <panic_leds>
 8000608:	20000000 	.word	0x20000000

0800060c <Default_Handler72>:
void Default_Handler72(void) { Default_HandlerCode = 72; panic_leds(5); }
 800060c:	4b02      	ldr	r3, [pc, #8]	; (8000618 <Default_Handler72+0xc>)
 800060e:	2248      	movs	r2, #72	; 0x48
 8000610:	2005      	movs	r0, #5
 8000612:	601a      	str	r2, [r3, #0]
 8000614:	f003 ba95 	b.w	8003b42 <panic_leds>
 8000618:	20000000 	.word	0x20000000

0800061c <Default_Handler73>:
void Default_Handler73(void) { Default_HandlerCode = 73; panic_leds(5); }
 800061c:	4b02      	ldr	r3, [pc, #8]	; (8000628 <Default_Handler73+0xc>)
 800061e:	2249      	movs	r2, #73	; 0x49
 8000620:	2005      	movs	r0, #5
 8000622:	601a      	str	r2, [r3, #0]
 8000624:	f003 ba8d 	b.w	8003b42 <panic_leds>
 8000628:	20000000 	.word	0x20000000

0800062c <Default_Handler74>:
void Default_Handler74(void) { Default_HandlerCode = 74; panic_leds(5); }
 800062c:	4b02      	ldr	r3, [pc, #8]	; (8000638 <Default_Handler74+0xc>)
 800062e:	224a      	movs	r2, #74	; 0x4a
 8000630:	2005      	movs	r0, #5
 8000632:	601a      	str	r2, [r3, #0]
 8000634:	f003 ba85 	b.w	8003b42 <panic_leds>
 8000638:	20000000 	.word	0x20000000

0800063c <Default_Handler75>:
void Default_Handler75(void) { Default_HandlerCode = 75; panic_leds(5); }
 800063c:	4b02      	ldr	r3, [pc, #8]	; (8000648 <Default_Handler75+0xc>)
 800063e:	224b      	movs	r2, #75	; 0x4b
 8000640:	2005      	movs	r0, #5
 8000642:	601a      	str	r2, [r3, #0]
 8000644:	f003 ba7d 	b.w	8003b42 <panic_leds>
 8000648:	20000000 	.word	0x20000000

0800064c <Default_Handler77>:
//void Default_Handler76(void) { Default_HandlerCode = 76; panic_leds(5); }
void Default_Handler77(void) { Default_HandlerCode = 77; panic_leds(5); }
 800064c:	4b02      	ldr	r3, [pc, #8]	; (8000658 <Default_Handler77+0xc>)
 800064e:	224d      	movs	r2, #77	; 0x4d
 8000650:	2005      	movs	r0, #5
 8000652:	601a      	str	r2, [r3, #0]
 8000654:	f003 ba75 	b.w	8003b42 <panic_leds>
 8000658:	20000000 	.word	0x20000000

0800065c <Default_Handler78>:
void Default_Handler78(void) { Default_HandlerCode = 78; panic_leds(5); }
 800065c:	4b02      	ldr	r3, [pc, #8]	; (8000668 <Default_Handler78+0xc>)
 800065e:	224e      	movs	r2, #78	; 0x4e
 8000660:	2005      	movs	r0, #5
 8000662:	601a      	str	r2, [r3, #0]
 8000664:	f003 ba6d 	b.w	8003b42 <panic_leds>
 8000668:	20000000 	.word	0x20000000

0800066c <Default_Handler79>:
void Default_Handler79(void) { Default_HandlerCode = 79; panic_leds(5); }
 800066c:	4b02      	ldr	r3, [pc, #8]	; (8000678 <Default_Handler79+0xc>)
 800066e:	224f      	movs	r2, #79	; 0x4f
 8000670:	2005      	movs	r0, #5
 8000672:	601a      	str	r2, [r3, #0]
 8000674:	f003 ba65 	b.w	8003b42 <panic_leds>
 8000678:	20000000 	.word	0x20000000

0800067c <Default_Handler80>:
void Default_Handler80(void) { Default_HandlerCode = 80; panic_leds(5); }
 800067c:	4b02      	ldr	r3, [pc, #8]	; (8000688 <Default_Handler80+0xc>)
 800067e:	2250      	movs	r2, #80	; 0x50
 8000680:	2005      	movs	r0, #5
 8000682:	601a      	str	r2, [r3, #0]
 8000684:	f003 ba5d 	b.w	8003b42 <panic_leds>
 8000688:	20000000 	.word	0x20000000

0800068c <Default_Handler81>:
void Default_Handler81(void) { Default_HandlerCode = 81; panic_leds(5); }
 800068c:	4b02      	ldr	r3, [pc, #8]	; (8000698 <Default_Handler81+0xc>)
 800068e:	2251      	movs	r2, #81	; 0x51
 8000690:	2005      	movs	r0, #5
 8000692:	601a      	str	r2, [r3, #0]
 8000694:	f003 ba55 	b.w	8003b42 <panic_leds>
 8000698:	20000000 	.word	0x20000000

0800069c <Default_Handler82>:
void Default_Handler82(void) { Default_HandlerCode = 82; panic_leds(5); }
 800069c:	4b02      	ldr	r3, [pc, #8]	; (80006a8 <Default_Handler82+0xc>)
 800069e:	2252      	movs	r2, #82	; 0x52
 80006a0:	2005      	movs	r0, #5
 80006a2:	601a      	str	r2, [r3, #0]
 80006a4:	f003 ba4d 	b.w	8003b42 <panic_leds>
 80006a8:	20000000 	.word	0x20000000

080006ac <Default_Handler83>:
void Default_Handler83(void) { Default_HandlerCode = 83; panic_leds(5); }
 80006ac:	4b02      	ldr	r3, [pc, #8]	; (80006b8 <Default_Handler83+0xc>)
 80006ae:	2253      	movs	r2, #83	; 0x53
 80006b0:	2005      	movs	r0, #5
 80006b2:	601a      	str	r2, [r3, #0]
 80006b4:	f003 ba45 	b.w	8003b42 <panic_leds>
 80006b8:	20000000 	.word	0x20000000

080006bc <Default_Handler84>:
void Default_Handler84(void) { Default_HandlerCode = 84; panic_leds(5); }
 80006bc:	4b02      	ldr	r3, [pc, #8]	; (80006c8 <Default_Handler84+0xc>)
 80006be:	2254      	movs	r2, #84	; 0x54
 80006c0:	2005      	movs	r0, #5
 80006c2:	601a      	str	r2, [r3, #0]
 80006c4:	f003 ba3d 	b.w	8003b42 <panic_leds>
 80006c8:	20000000 	.word	0x20000000

080006cc <Default_Handler85>:
void Default_Handler85(void) { Default_HandlerCode = 85; panic_leds(5); }
 80006cc:	4b02      	ldr	r3, [pc, #8]	; (80006d8 <Default_Handler85+0xc>)
 80006ce:	2255      	movs	r2, #85	; 0x55
 80006d0:	2005      	movs	r0, #5
 80006d2:	601a      	str	r2, [r3, #0]
 80006d4:	f003 ba35 	b.w	8003b42 <panic_leds>
 80006d8:	20000000 	.word	0x20000000

080006dc <Default_Handler86>:
void Default_Handler86(void) { Default_HandlerCode = 86; panic_leds(5); }
 80006dc:	4b02      	ldr	r3, [pc, #8]	; (80006e8 <Default_Handler86+0xc>)
 80006de:	2256      	movs	r2, #86	; 0x56
 80006e0:	2005      	movs	r0, #5
 80006e2:	601a      	str	r2, [r3, #0]
 80006e4:	f003 ba2d 	b.w	8003b42 <panic_leds>
 80006e8:	20000000 	.word	0x20000000

080006ec <Default_Handler87>:
void Default_Handler87(void) { Default_HandlerCode = 87; panic_leds(5); }
 80006ec:	4b02      	ldr	r3, [pc, #8]	; (80006f8 <Default_Handler87+0xc>)
 80006ee:	2257      	movs	r2, #87	; 0x57
 80006f0:	2005      	movs	r0, #5
 80006f2:	601a      	str	r2, [r3, #0]
 80006f4:	f003 ba25 	b.w	8003b42 <panic_leds>
 80006f8:	20000000 	.word	0x20000000

080006fc <Default_Handler88>:
void Default_Handler88(void) { Default_HandlerCode = 88; panic_leds(5); }
 80006fc:	4b02      	ldr	r3, [pc, #8]	; (8000708 <Default_Handler88+0xc>)
 80006fe:	2258      	movs	r2, #88	; 0x58
 8000700:	2005      	movs	r0, #5
 8000702:	601a      	str	r2, [r3, #0]
 8000704:	f003 ba1d 	b.w	8003b42 <panic_leds>
 8000708:	20000000 	.word	0x20000000

0800070c <Default_Handler89>:
void Default_Handler89(void) { Default_HandlerCode = 89; panic_leds(5); }
 800070c:	4b02      	ldr	r3, [pc, #8]	; (8000718 <Default_Handler89+0xc>)
 800070e:	2259      	movs	r2, #89	; 0x59
 8000710:	2005      	movs	r0, #5
 8000712:	601a      	str	r2, [r3, #0]
 8000714:	f003 ba15 	b.w	8003b42 <panic_leds>
 8000718:	20000000 	.word	0x20000000

0800071c <Default_Handler90>:
void Default_Handler90(void) { Default_HandlerCode = 90; panic_leds(5); }
 800071c:	4b02      	ldr	r3, [pc, #8]	; (8000728 <Default_Handler90+0xc>)
 800071e:	225a      	movs	r2, #90	; 0x5a
 8000720:	2005      	movs	r0, #5
 8000722:	601a      	str	r2, [r3, #0]
 8000724:	f003 ba0d 	b.w	8003b42 <panic_leds>
 8000728:	20000000 	.word	0x20000000

0800072c <toggle_4leds>:
Turn the LEDs on in sequence, then turn them back off 
***************************************************************/
static int lednum = 12;	// Lowest port bit numbered LED
void toggle_4leds (void)
{
	if ((GPIO_ODR(GPIOD) & (1<<lednum)) == 0)
 800072c:	4a0c      	ldr	r2, [pc, #48]	; (8000760 <toggle_4leds+0x34>)
 800072e:	4b0d      	ldr	r3, [pc, #52]	; (8000764 <toggle_4leds+0x38>)
/* ************************************************************
Turn the LEDs on in sequence, then turn them back off 
***************************************************************/
static int lednum = 12;	// Lowest port bit numbered LED
void toggle_4leds (void)
{
 8000730:	b510      	push	{r4, lr}
	if ((GPIO_ODR(GPIOD) & (1<<lednum)) == 0)
 8000732:	681c      	ldr	r4, [r3, #0]
 8000734:	6853      	ldr	r3, [r2, #4]
 8000736:	2101      	movs	r1, #1
 8000738:	fa11 f003 	lsls.w	r0, r1, r3
 800073c:	4220      	tst	r0, r4
 800073e:	4614      	mov	r4, r2
 8000740:	4a09      	ldr	r2, [pc, #36]	; (8000768 <toggle_4leds+0x3c>)
 8000742:	d101      	bne.n	8000748 <toggle_4leds+0x1c>
	{ // Here, LED bit was off
		GPIO_BSRR(GPIOD) = (1<<lednum);	// Set bit
 8000744:	6010      	str	r0, [r2, #0]
 8000746:	e003      	b.n	8000750 <toggle_4leds+0x24>
	}
	else
	{ // HEre, LED bit was on
		GPIO_BSRR(GPIOD) = (1<<(lednum+16));	// Reset bit
 8000748:	f103 0010 	add.w	r0, r3, #16
 800074c:	4081      	lsls	r1, r0
 800074e:	6011      	str	r1, [r2, #0]
	}
	lednum += 1;		// Step through all four LEDs
 8000750:	3301      	adds	r3, #1
	if (lednum > 15) lednum = 12;
 8000752:	2b0f      	cmp	r3, #15
	}
	else
	{ // HEre, LED bit was on
		GPIO_BSRR(GPIOD) = (1<<(lednum+16));	// Reset bit
	}
	lednum += 1;		// Step through all four LEDs
 8000754:	6063      	str	r3, [r4, #4]
	if (lednum > 15) lednum = 12;
 8000756:	dd02      	ble.n	800075e <toggle_4leds+0x32>
 8000758:	4b01      	ldr	r3, [pc, #4]	; (8000760 <toggle_4leds+0x34>)
 800075a:	220c      	movs	r2, #12
 800075c:	605a      	str	r2, [r3, #4]
 800075e:	bd10      	pop	{r4, pc}
 8000760:	20000000 	.word	0x20000000
 8000764:	40020c14 	.word	0x40020c14
 8000768:	40020c18 	.word	0x40020c18

0800076c <toggle_led>:
/* ************************************************************
Turn the LEDs on in sequence, then turn them back off 
***************************************************************/
void toggle_led (int lednum)
{
	if ((GPIO_ODR(GPIOD) & (1<<lednum)) == 0)
 800076c:	4b06      	ldr	r3, [pc, #24]	; (8000788 <toggle_led+0x1c>)
 800076e:	2201      	movs	r2, #1
 8000770:	681b      	ldr	r3, [r3, #0]
 8000772:	fa12 f100 	lsls.w	r1, r2, r0
 8000776:	4219      	tst	r1, r3
 8000778:	4b04      	ldr	r3, [pc, #16]	; (800078c <toggle_led+0x20>)
 800077a:	d101      	bne.n	8000780 <toggle_led+0x14>
	{ // Here, LED bit was off
		GPIO_BSRR(GPIOD) = (1<<lednum);	// Set bit
 800077c:	6019      	str	r1, [r3, #0]
 800077e:	4770      	bx	lr
	}
	else
	{ // HEre, LED bit was on
		GPIO_BSRR(GPIOD) = (1<<(lednum+16));	// Reset bit
 8000780:	3010      	adds	r0, #16
 8000782:	4082      	lsls	r2, r0
 8000784:	601a      	str	r2, [r3, #0]
 8000786:	4770      	bx	lr
 8000788:	40020c14 	.word	0x40020c14
 800078c:	40020c18 	.word	0x40020c18

08000790 <printbits>:
}
/******************************************************************************
 * Print out the bits for the array
 ******************************************************************************/
void printbits(char* p)
{
 8000790:	b570      	push	{r4, r5, r6, lr}
 8000792:	4606      	mov	r6, r0
	int i,j;
	char c;

	/* Print out the bits for the incoming bytes */
	for (j = 0; j < SPI2SIZE; j++) // For each byte in the cycle
 8000794:	2400      	movs	r4, #0
 8000796:	e011      	b.n	80007bc <printbits+0x2c>
	{
		for (i = 0; i < 8; i++) // For each bit within a byte
		{
			if ( (*p & (1<<i)) == 0) 
 8000798:	5d32      	ldrb	r2, [r6, r4]
				c = '.';	// Symbol for "zero"
			else
				c = '1';	// Symbol for "one"
			xprintf (UXPRT,"%c",c);
 800079a:	490c      	ldr	r1, [pc, #48]	; (80007cc <printbits+0x3c>)
	/* Print out the bits for the incoming bytes */
	for (j = 0; j < SPI2SIZE; j++) // For each byte in the cycle
	{
		for (i = 0; i < 8; i++) // For each bit within a byte
		{
			if ( (*p & (1<<i)) == 0) 
 800079c:	412a      	asrs	r2, r5
 800079e:	f002 0201 	and.w	r2, r2, #1
				c = '.';	// Symbol for "zero"
			else
				c = '1';	// Symbol for "one"
			xprintf (UXPRT,"%c",c);
 80007a2:	2003      	movs	r0, #3
 80007a4:	2a00      	cmp	r2, #0
 80007a6:	bf14      	ite	ne
 80007a8:	2231      	movne	r2, #49	; 0x31
 80007aa:	222e      	moveq	r2, #46	; 0x2e
	char c;

	/* Print out the bits for the incoming bytes */
	for (j = 0; j < SPI2SIZE; j++) // For each byte in the cycle
	{
		for (i = 0; i < 8; i++) // For each bit within a byte
 80007ac:	3501      	adds	r5, #1
		{
			if ( (*p & (1<<i)) == 0) 
				c = '.';	// Symbol for "zero"
			else
				c = '1';	// Symbol for "one"
			xprintf (UXPRT,"%c",c);
 80007ae:	f004 f949 	bl	8004a44 <xprintf>
	char c;

	/* Print out the bits for the incoming bytes */
	for (j = 0; j < SPI2SIZE; j++) // For each byte in the cycle
	{
		for (i = 0; i < 8; i++) // For each bit within a byte
 80007b2:	2d08      	cmp	r5, #8
 80007b4:	d1f0      	bne.n	8000798 <printbits+0x8>
{
	int i,j;
	char c;

	/* Print out the bits for the incoming bytes */
	for (j = 0; j < SPI2SIZE; j++) // For each byte in the cycle
 80007b6:	3401      	adds	r4, #1
 80007b8:	2c02      	cmp	r4, #2
 80007ba:	d001      	beq.n	80007c0 <printbits+0x30>
}
/******************************************************************************
 * Print out the bits for the array
 ******************************************************************************/
void printbits(char* p)
{
 80007bc:	2500      	movs	r5, #0
 80007be:	e7eb      	b.n	8000798 <printbits+0x8>
			xprintf (UXPRT,"%c",c);
		}
		p++;
	}

	xprintf (UXPRT,"\n\r");
 80007c0:	4903      	ldr	r1, [pc, #12]	; (80007d0 <printbits+0x40>)
 80007c2:	2003      	movs	r0, #3
	return;
}
 80007c4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			xprintf (UXPRT,"%c",c);
		}
		p++;
	}

	xprintf (UXPRT,"\n\r");
 80007c8:	f004 b93c 	b.w	8004a44 <xprintf>
 80007cc:	0800b940 	.word	0x0800b940
 80007d0:	0800b9df 	.word	0x0800b9df

080007d4 <main>:

/*#################################################################################################
  main routine 
  #################################################################################################*/
int main(void)
{
 80007d4:	b530      	push	{r4, r5, lr}
	int i;
/* --------------------- Begin setting things up -------------------------------------------------- */ 
	clockspecifysetup((struct CLOCKS*)&clocks);		// Get the system clock and bus clocks running
 80007d6:	484d      	ldr	r0, [pc, #308]	; (800090c <main+0x138>)

/* ---------------------- Let the hapless Op know it is alive ------------------------------------ */
	/* Announce who we are. ('xprintf' uses uart number to deliver the output.) */
	xprintf(UXPRT,  " \n\rDISCOVERY F4 SPI2TEST: 02-06-2014  v0\n\r");
	/* Make sure we have the correct bus frequencies */
	xprintf (UXPRT, "   hclk_freq (MHz) : %9u...............................\n\r",  hclk_freq/1000000);	
 80007d8:	4c4d      	ldr	r4, [pc, #308]	; (8000910 <main+0x13c>)

/*#################################################################################################
  main routine 
  #################################################################################################*/
int main(void)
{
 80007da:	b085      	sub	sp, #20
	int i;
/* --------------------- Begin setting things up -------------------------------------------------- */ 
	clockspecifysetup((struct CLOCKS*)&clocks);		// Get the system clock and bus clocks running
 80007dc:	f003 faa0 	bl	8003d20 <clockspecifysetup>
/* ---------------------- Set up pins ------------------------------------------------------------- */
	/* Configure pins */
	DISCgpiopins_Config();	// Configure pins
 80007e0:	f003 f928 	bl	8003a34 <DISCgpiopins_Config>
/* ---------------------- Set usb ----------------------------------------------------------------- */
//	usb1_init();	// Initialization for USB (STM32F4_USB_CDC demo package)
	setbuf(stdout, NULL);
 80007e4:	4b4b      	ldr	r3, [pc, #300]	; (8000914 <main+0x140>)
 80007e6:	681b      	ldr	r3, [r3, #0]
 80007e8:	2100      	movs	r1, #0
 80007ea:	6898      	ldr	r0, [r3, #8]
 80007ec:	f004 fd1a 	bl	8005224 <setbuf>
/*	CHAR-BY-CHAR INTERRUPT DRIVEN  */
// int bsp_uart_init_number(u32 iuart, u32 baud, u32 txbuffsize, u32 rxbuffsize,  u32 uart_int_priority);
//	bsp_uart_int_init_number(2, 460800, 256, 256, 0x30);
//	bsp_uart_int_init_number(USTDO, 230400, 256, 256, 0x40);
//	bsp_uart_int_init_number(USTDO, 115200, 256, 256, 0x10);
	bsp_uart_int_init_number(UXPRT, 115200, 256, 256, 0x30);
 80007f0:	f44f 7280 	mov.w	r2, #256	; 0x100
 80007f4:	2330      	movs	r3, #48	; 0x30
 80007f6:	9300      	str	r3, [sp, #0]
 80007f8:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
 80007fc:	4613      	mov	r3, r2
 80007fe:	2003      	movs	r0, #3
 8000800:	f004 f8c6 	bl	8004990 <bsp_uart_int_init_number>
/* ---------------------- DTW sys counter -------------------------------------------------------- */

	/* Use DTW_CYCCNT counter (driven by sysclk) for polling type timing */
/* CYCCNT counter is in the Cortex-M-series core.  See the following for details 
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html */
	*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
 8000804:	4b44      	ldr	r3, [pc, #272]	; (8000918 <main+0x144>)
	*(volatile unsigned int*)0xE0001000 |= 0x1;	// Enable DTW_CYCCNT (Data Watch cycle counter)

/* ---------------------- Let the hapless Op know it is alive ------------------------------------ */
	/* Announce who we are. ('xprintf' uses uart number to deliver the output.) */
	xprintf(UXPRT,  " \n\rDISCOVERY F4 SPI2TEST: 02-06-2014  v0\n\r");
 8000806:	4945      	ldr	r1, [pc, #276]	; (800091c <main+0x148>)
/* ---------------------- DTW sys counter -------------------------------------------------------- */

	/* Use DTW_CYCCNT counter (driven by sysclk) for polling type timing */
/* CYCCNT counter is in the Cortex-M-series core.  See the following for details 
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html */
	*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
 8000808:	681a      	ldr	r2, [r3, #0]
 800080a:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800080e:	601a      	str	r2, [r3, #0]
	*(volatile unsigned int*)0xE0001000 |= 0x1;	// Enable DTW_CYCCNT (Data Watch cycle counter)
 8000810:	4b43      	ldr	r3, [pc, #268]	; (8000920 <main+0x14c>)
 8000812:	681a      	ldr	r2, [r3, #0]
 8000814:	f042 0201 	orr.w	r2, r2, #1
 8000818:	601a      	str	r2, [r3, #0]

/* ---------------------- Let the hapless Op know it is alive ------------------------------------ */
	/* Announce who we are. ('xprintf' uses uart number to deliver the output.) */
	xprintf(UXPRT,  " \n\rDISCOVERY F4 SPI2TEST: 02-06-2014  v0\n\r");
 800081a:	2003      	movs	r0, #3
 800081c:	f004 f912 	bl	8004a44 <xprintf>
	/* Make sure we have the correct bus frequencies */
	xprintf (UXPRT, "   hclk_freq (MHz) : %9u...............................\n\r",  hclk_freq/1000000);	
 8000820:	4b40      	ldr	r3, [pc, #256]	; (8000924 <main+0x150>)
 8000822:	4941      	ldr	r1, [pc, #260]	; (8000928 <main+0x154>)
 8000824:	681a      	ldr	r2, [r3, #0]
 8000826:	2003      	movs	r0, #3
 8000828:	fbb2 f2f4 	udiv	r2, r2, r4
 800082c:	f004 f90a 	bl	8004a44 <xprintf>
	xprintf (UXPRT, "  pclk1_freq (MHz) : %9u...............................\n\r", pclk1_freq/1000000);	
 8000830:	4b3e      	ldr	r3, [pc, #248]	; (800092c <main+0x158>)
 8000832:	493f      	ldr	r1, [pc, #252]	; (8000930 <main+0x15c>)
 8000834:	681a      	ldr	r2, [r3, #0]
 8000836:	2003      	movs	r0, #3
 8000838:	fbb2 f2f4 	udiv	r2, r2, r4
 800083c:	f004 f902 	bl	8004a44 <xprintf>
	xprintf (UXPRT, "  pclk2_freq (MHz) : %9u...............................\n\r", pclk2_freq/1000000);	
 8000840:	4b3c      	ldr	r3, [pc, #240]	; (8000934 <main+0x160>)
 8000842:	493d      	ldr	r1, [pc, #244]	; (8000938 <main+0x164>)
 8000844:	681a      	ldr	r2, [r3, #0]
 8000846:	2003      	movs	r0, #3
 8000848:	fbb2 f2f4 	udiv	r2, r2, r4
 800084c:	f004 f8fa 	bl	8004a44 <xprintf>
	xprintf (UXPRT, " sysclk_freq (MHz) : %9u...............................\n\r",sysclk_freq/1000000);
 8000850:	4b3a      	ldr	r3, [pc, #232]	; (800093c <main+0x168>)
 8000852:	493b      	ldr	r1, [pc, #236]	; (8000940 <main+0x16c>)
 8000854:	681a      	ldr	r2, [r3, #0]
 8000856:	2003      	movs	r0, #3
 8000858:	fbb2 f2f4 	udiv	r2, r2, r4
 800085c:	f004 f8f2 	bl	8004a44 <xprintf>
 8000860:	240c      	movs	r4, #12

/* --------------------- Onboard LED setup ----------------------------------------------------------------------------- */
	for (i = 0; i < 4; i++)  f4gpiopins_Config ((volatile u32 *)GPIOD, (12+i), (struct PINCONFIG*)&outpp);
 8000862:	4621      	mov	r1, r4
 8000864:	3401      	adds	r4, #1
 8000866:	4837      	ldr	r0, [pc, #220]	; (8000944 <main+0x170>)
 8000868:	4a37      	ldr	r2, [pc, #220]	; (8000948 <main+0x174>)
 800086a:	b2a4      	uxth	r4, r4
 800086c:	f003 f903 	bl	8003a76 <f4gpiopins_Config>
 8000870:	2c10      	cmp	r4, #16
 8000872:	d1f6      	bne.n	8000862 <main+0x8e>
	/* Initialize the DTW_CYCCNT counter if it is used for timing.  This is a Cortex-Mx core function
           sometimes used in a debugger, and not a STM32 peripheral timer.  It is 32b and runs off the
	   system clock (168MHz in this demo). */
/* CYCCNT counter is in the Cortex-M-series core.  See the following for details 
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html */
	*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
 8000874:	4b28      	ldr	r3, [pc, #160]	; (8000918 <main+0x144>)
/* --------------------- Initialize SPI2 ------------------------------------------------------------------------------- */
	spi2rw_init();

/* --------------------- Endless loop follows -------------------------------------------------------------------------- */
#define PACECOUNT (168000000/2);	// Pace the output loop
u32	t_led = *(volatile unsigned int *)0xE0001004 + PACECOUNT;
 8000876:	4c35      	ldr	r4, [pc, #212]	; (800094c <main+0x178>)
	/* Initialize the DTW_CYCCNT counter if it is used for timing.  This is a Cortex-Mx core function
           sometimes used in a debugger, and not a STM32 peripheral timer.  It is 32b and runs off the
	   system clock (168MHz in this demo). */
/* CYCCNT counter is in the Cortex-M-series core.  See the following for details 
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html */
	*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
 8000878:	681a      	ldr	r2, [r3, #0]
 800087a:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800087e:	601a      	str	r2, [r3, #0]
	*(volatile unsigned int*)0xE0001000 |= 0x1;	// Enable DTW_CYCCNT (Data Watch cycle counter)
 8000880:	4b27      	ldr	r3, [pc, #156]	; (8000920 <main+0x14c>)
 8000882:	681a      	ldr	r2, [r3, #0]
 8000884:	f042 0201 	orr.w	r2, r2, #1
 8000888:	601a      	str	r2, [r3, #0]

/* --------------------- Initialize SPI2 ------------------------------------------------------------------------------- */
	spi2rw_init();
 800088a:	f003 f9a3 	bl	8003bd4 <spi2rw_init>

/* --------------------- Endless loop follows -------------------------------------------------------------------------- */
#define PACECOUNT (168000000/2);	// Pace the output loop
u32	t_led = *(volatile unsigned int *)0xE0001004 + PACECOUNT;
 800088e:	4b30      	ldr	r3, [pc, #192]	; (8000950 <main+0x17c>)
   that the bits that are not changing appear stationary.  Changing the "switches" for the input its will
   show up in the print out.  The speed of the printout update is primarily limited by the speed of the
   printf and loop overhead.  The SPI update is approximately 50 us per byte. */


	xprintf (UXPRT,"\n\rOutput pattern bits\n\r");
 8000890:	4930      	ldr	r1, [pc, #192]	; (8000954 <main+0x180>)
/* --------------------- Initialize SPI2 ------------------------------------------------------------------------------- */
	spi2rw_init();

/* --------------------- Endless loop follows -------------------------------------------------------------------------- */
#define PACECOUNT (168000000/2);	// Pace the output loop
u32	t_led = *(volatile unsigned int *)0xE0001004 + PACECOUNT;
 8000892:	681b      	ldr	r3, [r3, #0]
 8000894:	191c      	adds	r4, r3, r4
#define SPI2SIZE 2 	// Number of bytes in the transfer	
char bout[SPI2SIZE] = {0x55,0xAA};	// Initial outgoing pattern {0x00, 0x00}
 8000896:	4b30      	ldr	r3, [pc, #192]	; (8000958 <main+0x184>)
 8000898:	881b      	ldrh	r3, [r3, #0]
   that the bits that are not changing appear stationary.  Changing the "switches" for the input its will
   show up in the print out.  The speed of the printout update is primarily limited by the speed of the
   printf and loop overhead.  The SPI update is approximately 50 us per byte. */


	xprintf (UXPRT,"\n\rOutput pattern bits\n\r");
 800089a:	2003      	movs	r0, #3

/* --------------------- Endless loop follows -------------------------------------------------------------------------- */
#define PACECOUNT (168000000/2);	// Pace the output loop
u32	t_led = *(volatile unsigned int *)0xE0001004 + PACECOUNT;
#define SPI2SIZE 2 	// Number of bytes in the transfer	
char bout[SPI2SIZE] = {0x55,0xAA};	// Initial outgoing pattern {0x00, 0x00}
 800089c:	f8ad 300c 	strh.w	r3, [sp, #12]
   that the bits that are not changing appear stationary.  Changing the "switches" for the input its will
   show up in the print out.  The speed of the printout update is primarily limited by the speed of the
   printf and loop overhead.  The SPI update is approximately 50 us per byte. */


	xprintf (UXPRT,"\n\rOutput pattern bits\n\r");
 80008a0:	f004 f8d0 	bl	8004a44 <xprintf>
	printbits(bout); // Print output line
 80008a4:	a803      	add	r0, sp, #12
 80008a6:	f7ff ff73 	bl	8000790 <printbits>
	xprintf (UXPRT,"\n\rIncoming bit pattern\n\r");
 80008aa:	2003      	movs	r0, #3
 80008ac:	492b      	ldr	r1, [pc, #172]	; (800095c <main+0x188>)
 80008ae:	f004 f8c9 	bl	8004a44 <xprintf>


void printbits(char* p);


int x = 0;
 80008b2:	2500      	movs	r5, #0
	xprintf (UXPRT,"\n\rIncoming bit pattern\n\r");

	while(1==1)
	{
		/* Flash the LED's to amuse the hapless Op */
		if ( ( (int)(*(volatile unsigned int *)0xE0001004 - t_led) ) > 0)
 80008b4:	4b26      	ldr	r3, [pc, #152]	; (8000950 <main+0x17c>)
 80008b6:	681b      	ldr	r3, [r3, #0]
 80008b8:	1b1b      	subs	r3, r3, r4
 80008ba:	2b00      	cmp	r3, #0
 80008bc:	ddfa      	ble.n	80008b4 <main+0xe0>
		{
			t_led += PACECOUNT;
				toggle_led(12);
 80008be:	200c      	movs	r0, #12
 80008c0:	f7ff ff54 	bl	800076c <toggle_led>
				bout[0] = bout[0] ^ 0xff;
 80008c4:	f89d 300c 	ldrb.w	r3, [sp, #12]
 80008c8:	43db      	mvns	r3, r3
 80008ca:	f88d 300c 	strb.w	r3, [sp, #12]
				bout[1] = bout[1] ^ 0xff;
 80008ce:	f89d 300d 	ldrb.w	r3, [sp, #13]
	while(1==1)
	{
		/* Flash the LED's to amuse the hapless Op */
		if ( ( (int)(*(volatile unsigned int *)0xE0001004 - t_led) ) > 0)
		{
			t_led += PACECOUNT;
 80008d2:	f104 64a0 	add.w	r4, r4, #83886080	; 0x5000000
 80008d6:	f504 34de 	add.w	r4, r4, #113664	; 0x1bc00
				toggle_led(12);
				bout[0] = bout[0] ^ 0xff;
				bout[1] = bout[1] ^ 0xff;
 80008da:	43db      	mvns	r3, r3
	while(1==1)
	{
		/* Flash the LED's to amuse the hapless Op */
		if ( ( (int)(*(volatile unsigned int *)0xE0001004 - t_led) ) > 0)
		{
			t_led += PACECOUNT;
 80008dc:	f504 7480 	add.w	r4, r4, #256	; 0x100
				toggle_led(12);
				bout[0] = bout[0] ^ 0xff;
				bout[1] = bout[1] ^ 0xff;
 80008e0:	f88d 300d 	strb.w	r3, [sp, #13]
y += 1;
			if (spi2_busy() != 0) // Is SPI2 busy?
 80008e4:	f003 f9b4 	bl	8003c50 <spi2_busy>
 80008e8:	b128      	cbz	r0, 80008f6 <main+0x122>
			{ // Here, no.  
				spi2_rw(bout, bin, SPI2SIZE); // Send/rcv SPI2SIZE bytes
 80008ea:	a803      	add	r0, sp, #12
 80008ec:	a902      	add	r1, sp, #8
 80008ee:	2202      	movs	r2, #2
 80008f0:	f003 f9b6 	bl	8003c60 <spi2_rw>
x += 1; // Debugging counter
 80008f4:	3501      	adds	r5, #1
			}
			xprintf(UXPRT,"%5u %5u ",x, spidebug1);
 80008f6:	4b1a      	ldr	r3, [pc, #104]	; (8000960 <main+0x18c>)
 80008f8:	491a      	ldr	r1, [pc, #104]	; (8000964 <main+0x190>)
 80008fa:	681b      	ldr	r3, [r3, #0]
 80008fc:	2003      	movs	r0, #3
 80008fe:	462a      	mov	r2, r5
 8000900:	f004 f8a0 	bl	8004a44 <xprintf>
			printbits(bin); // Print the bits
 8000904:	a802      	add	r0, sp, #8
 8000906:	f7ff ff43 	bl	8000790 <printbits>
 800090a:	e7d3      	b.n	80008b4 <main+0xe0>
 800090c:	0800b6f0 	.word	0x0800b6f0
 8000910:	000f4240 	.word	0x000f4240
 8000914:	2000026c 	.word	0x2000026c
 8000918:	e000edfc 	.word	0xe000edfc
 800091c:	0800b943 	.word	0x0800b943
 8000920:	e0001000 	.word	0xe0001000
 8000924:	20000834 	.word	0x20000834
 8000928:	0800b96e 	.word	0x0800b96e
 800092c:	20000838 	.word	0x20000838
 8000930:	0800b9a8 	.word	0x0800b9a8
 8000934:	2000083c 	.word	0x2000083c
 8000938:	0800b9e2 	.word	0x0800b9e2
 800093c:	20000840 	.word	0x20000840
 8000940:	0800ba1c 	.word	0x0800ba1c
 8000944:	40020c00 	.word	0x40020c00
 8000948:	0800b704 	.word	0x0800b704
 800094c:	0501bd00 	.word	0x0501bd00
 8000950:	e0001004 	.word	0xe0001004
 8000954:	0800ba56 	.word	0x0800ba56
 8000958:	0800b709 	.word	0x0800b709
 800095c:	0800ba6e 	.word	0x0800ba6e
 8000960:	20000830 	.word	0x20000830
 8000964:	0800ba87 	.word	0x0800ba87
 8000968:	0800bbac 	.word	0x0800bbac
 800096c:	20000000 	.word	0x20000000
 8000970:	200007ec 	.word	0x200007ec
 8000974:	200007ec 	.word	0x200007ec
 8000978:	20001ae8 	.word	0x20001ae8

0800097c <_close>:

int __errno;

int _close(int file) {
	return 0;
}
 800097c:	2000      	movs	r0, #0
 800097e:	4770      	bx	lr

08000980 <_fstat>:

int _fstat(int file, struct stat *st) {
	return 0;
}
 8000980:	2000      	movs	r0, #0
 8000982:	4770      	bx	lr

08000984 <_isatty>:

int _isatty(int file) {
	return 1;
}
 8000984:	2001      	movs	r0, #1
 8000986:	4770      	bx	lr

08000988 <_lseek>:

int _lseek(int file, int ptr, int dir) {
	return 0;
}
 8000988:	2000      	movs	r0, #0
 800098a:	4770      	bx	lr

0800098c <_open>:



int _open(const char *name, int flags, int mode) {
 800098c:	b538      	push	{r3, r4, r5, lr}
	void* pret;
	int i;

	if (i_cur >= FD_OPNMAX) return -1;// No free slots check
 800098e:	4d0b      	ldr	r5, [pc, #44]	; (80009bc <_open+0x30>)
 8000990:	682c      	ldr	r4, [r5, #0]
 8000992:	2c0b      	cmp	r4, #11
 8000994:	dc0d      	bgt.n	80009b2 <_open+0x26>

	i = i_cur;

	/* Check if there is someone out there with this name */
	pret = (struct CB_UART*)bsp_uart_open(name); // Check USART/UARTs
 8000996:	f003 fd1d 	bl	80043d4 <bsp_uart_open>
	if (pret != 0) 
 800099a:	b150      	cbz	r0, 80009b2 <_open+0x26>
	{ // Here, bsp_uart found the name and returned a control blk ptr
		fd_opn[i].pv = pret;
 800099c:	4b08      	ldr	r3, [pc, #32]	; (80009c0 <_open+0x34>)
 800099e:	f843 0034 	str.w	r0, [r3, r4, lsl #3]
		fd_opn[i].dev = 0;	// USART/UART group
 80009a2:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 80009a6:	2200      	movs	r2, #0
 80009a8:	605a      	str	r2, [r3, #4]
		i_cur += 1;
 80009aa:	682b      	ldr	r3, [r5, #0]
 80009ac:	3301      	adds	r3, #1
 80009ae:	602b      	str	r3, [r5, #0]
		return (i);
 80009b0:	e001      	b.n	80009b6 <_open+0x2a>
	}
	// Place calls for others here, e.g. usb (device code 0)
	return -1;		// Nobody recognizes this name
 80009b2:	f04f 34ff 	mov.w	r4, #4294967295
}
 80009b6:	4620      	mov	r0, r4
 80009b8:	bd38      	pop	{r3, r4, r5, pc}
 80009ba:	bf00      	nop
 80009bc:	20000008 	.word	0x20000008
 80009c0:	20000b38 	.word	0x20000b38

080009c4 <_read>:

int _read(int fd, char *ptr, int len) {
	char* p = ptr;
	if (fd > FD_OPNMAX) return -1;
 80009c4:	280c      	cmp	r0, #12
	}
	// Place calls for others here, e.g. usb (device code 0)
	return -1;		// Nobody recognizes this name
}

int _read(int fd, char *ptr, int len) {
 80009c6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80009ca:	460c      	mov	r4, r1
 80009cc:	4615      	mov	r5, r2
	char* p = ptr;
	if (fd > FD_OPNMAX) return -1;
 80009ce:	dc23      	bgt.n	8000a18 <_read+0x54>
	if (fd < 0) return -1;
 80009d0:	2800      	cmp	r0, #0
 80009d2:	db25      	blt.n	8000a20 <_read+0x5c>

	if (fd_opn[fd].dev == 0) // Is it a USART/UART?
 80009d4:	4e14      	ldr	r6, [pc, #80]	; (8000a28 <_read+0x64>)
 80009d6:	eb06 03c0 	add.w	r3, r6, r0, lsl #3
 80009da:	685b      	ldr	r3, [r3, #4]
 80009dc:	b92b      	cbnz	r3, 80009ea <_read+0x26>
		return bsp_uart_getn_ptr((struct CB_UART*)fd_opn[fd].pv, ptr, len);
 80009de:	f856 0030 	ldr.w	r0, [r6, r0, lsl #3]
		while(VCP_get_char_test()  &&  len > 0) 
		{VCP_get_char((u8*)p++); len -= 1;}
	}
	
	return p - ptr;
}
 80009e2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	char* p = ptr;
	if (fd > FD_OPNMAX) return -1;
	if (fd < 0) return -1;

	if (fd_opn[fd].dev == 0) // Is it a USART/UART?
		return bsp_uart_getn_ptr((struct CB_UART*)fd_opn[fd].pv, ptr, len);
 80009e6:	f003 bec5 	b.w	8004774 <bsp_uart_getn_ptr>
	if (fd_opn[fd].dev == 1) // Is it a USB?
 80009ea:	2b01      	cmp	r3, #1
 80009ec:	d110      	bne.n	8000a10 <_read+0x4c>
	{	
		/* Assumes the USB is on STDIN, STDOUT */
		if (!VCP_get_char_test()) {
 80009ee:	f000 f8ac 	bl	8000b4a <VCP_get_char_test>
 80009f2:	b1b8      	cbz	r0, 8000a24 <_read+0x60>
 80009f4:	4626      	mov	r6, r4
 80009f6:	e005      	b.n	8000a04 <_read+0x40>
			return 0;
		}
	
		while(VCP_get_char_test()  &&  len > 0) 
		{VCP_get_char((u8*)p++); len -= 1;}
 80009f8:	4630      	mov	r0, r6
 80009fa:	f000 f8b3 	bl	8000b64 <VCP_get_char>
 80009fe:	1c77      	adds	r7, r6, #1
 8000a00:	3d01      	subs	r5, #1
 8000a02:	463e      	mov	r6, r7
		/* Assumes the USB is on STDIN, STDOUT */
		if (!VCP_get_char_test()) {
			return 0;
		}
	
		while(VCP_get_char_test()  &&  len > 0) 
 8000a04:	f000 f8a1 	bl	8000b4a <VCP_get_char_test>
 8000a08:	b118      	cbz	r0, 8000a12 <_read+0x4e>
 8000a0a:	2d00      	cmp	r5, #0
 8000a0c:	dcf4      	bgt.n	80009f8 <_read+0x34>
 8000a0e:	e000      	b.n	8000a12 <_read+0x4e>
	// Place calls for others here, e.g. usb (device code 0)
	return -1;		// Nobody recognizes this name
}

int _read(int fd, char *ptr, int len) {
	char* p = ptr;
 8000a10:	460e      	mov	r6, r1
	
		while(VCP_get_char_test()  &&  len > 0) 
		{VCP_get_char((u8*)p++); len -= 1;}
	}
	
	return p - ptr;
 8000a12:	1b30      	subs	r0, r6, r4
 8000a14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return -1;		// Nobody recognizes this name
}

int _read(int fd, char *ptr, int len) {
	char* p = ptr;
	if (fd > FD_OPNMAX) return -1;
 8000a18:	f04f 30ff 	mov.w	r0, #4294967295
 8000a1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fd < 0) return -1;
 8000a20:	f04f 30ff 	mov.w	r0, #4294967295
		while(VCP_get_char_test()  &&  len > 0) 
		{VCP_get_char((u8*)p++); len -= 1;}
	}
	
	return p - ptr;
}
 8000a24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000a28:	20000b38 	.word	0x20000b38

08000a2c <_sbrk_r>:
caddr_t _sbrk_r (struct _reent *r, int incr) {
	extern char   end asm ("end"); /* Defined by the linker.  */
	static char * heap_end;
	char *        prev_heap_end;

	if (heap_end == NULL)
 8000a2c:	4b07      	ldr	r3, [pc, #28]	; (8000a4c <_sbrk_r+0x20>)
 8000a2e:	681a      	ldr	r2, [r3, #0]
 8000a30:	b90a      	cbnz	r2, 8000a36 <_sbrk_r+0xa>
		heap_end = & end;
 8000a32:	4a07      	ldr	r2, [pc, #28]	; (8000a50 <_sbrk_r+0x24>)
 8000a34:	601a      	str	r2, [r3, #0]

	prev_heap_end = heap_end;
 8000a36:	6818      	ldr	r0, [r3, #0]

	if (heap_end + incr > stack_ptr) {
 8000a38:	466b      	mov	r3, sp
 8000a3a:	1841      	adds	r1, r0, r1
 8000a3c:	4299      	cmp	r1, r3
		//errno = ENOMEM;
		return (caddr_t) -1;
	}

	heap_end += incr;
 8000a3e:	bf96      	itet	ls
 8000a40:	4b02      	ldrls	r3, [pc, #8]	; (8000a4c <_sbrk_r+0x20>)

	prev_heap_end = heap_end;

	if (heap_end + incr > stack_ptr) {
		//errno = ENOMEM;
		return (caddr_t) -1;
 8000a42:	f04f 30ff 	movhi.w	r0, #4294967295
	}

	heap_end += incr;
 8000a46:	6019      	strls	r1, [r3, #0]

	return (caddr_t) prev_heap_end;
}
 8000a48:	4770      	bx	lr
 8000a4a:	bf00      	nop
 8000a4c:	200007ec 	.word	0x200007ec
 8000a50:	20001ae8 	.word	0x20001ae8

08000a54 <_write>:

int _write(int fd, char *ptr, int len) 
{
 8000a54:	4603      	mov	r3, r0
	if (fd > 2)
 8000a56:	2b02      	cmp	r3, #2

	return (caddr_t) prev_heap_end;
}

int _write(int fd, char *ptr, int len) 
{
 8000a58:	b570      	push	{r4, r5, r6, lr}
 8000a5a:	4608      	mov	r0, r1
 8000a5c:	4614      	mov	r4, r2
	if (fd > 2)
 8000a5e:	dd0a      	ble.n	8000a76 <_write+0x22>
	{

		if (fd_opn[fd].dev == 0) // Is it a USART/UART?
 8000a60:	4d07      	ldr	r5, [pc, #28]	; (8000a80 <_write+0x2c>)
 8000a62:	eb05 06c3 	add.w	r6, r5, r3, lsl #3
 8000a66:	6876      	ldr	r6, [r6, #4]
 8000a68:	b92e      	cbnz	r6, 8000a76 <_write+0x22>
		{return bsp_uart_putn_ptr((struct CB_UART*)fd_opn[fd].pv, ptr, len);}
 8000a6a:	f855 0033 	ldr.w	r0, [r5, r3, lsl #3]
	}	
		// USB equivalent goes here-----
	VCP_send_buffer((u8*)ptr, len); 
	return len;
}
 8000a6e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
{
	if (fd > 2)
	{

		if (fd_opn[fd].dev == 0) // Is it a USART/UART?
		{return bsp_uart_putn_ptr((struct CB_UART*)fd_opn[fd].pv, ptr, len);}
 8000a72:	f003 bf0d 	b.w	8004890 <bsp_uart_putn_ptr>
	}	
		// USB equivalent goes here-----
	VCP_send_buffer((u8*)ptr, len); 
 8000a76:	4621      	mov	r1, r4
 8000a78:	f000 f866 	bl	8000b48 <VCP_send_buffer>
	return len;
}
 8000a7c:	4620      	mov	r0, r4
 8000a7e:	bd70      	pop	{r4, r5, r6, pc}
 8000a80:	20000b38 	.word	0x20000b38

08000a84 <VCP_Init>:
 * @param  None
 * @retval Result of the opeartion (USBD_OK in all cases)
 */
static uint16_t VCP_Init(void) {
	return USBD_OK;
}
 8000a84:	2000      	movs	r0, #0
 8000a86:	4770      	bx	lr

08000a88 <VCP_DeInit>:
 * @param  None
 * @retval Result of the opeartion (USBD_OK in all cases)
 */
static uint16_t VCP_DeInit(void) {
	return USBD_OK;
}
 8000a88:	2000      	movs	r0, #0
 8000a8a:	4770      	bx	lr

08000a8c <VCP_Ctrl>:
 * @param  Buf: Buffer containing command data (request parameters)
 * @param  Len: Number of data to be sent (in bytes)
 * @retval Result of the opeartion (USBD_OK in all cases)
 */
static uint16_t VCP_Ctrl(uint32_t Cmd, uint8_t* Buf, uint32_t Len) {
	switch (Cmd) {
 8000a8c:	2821      	cmp	r0, #33	; 0x21
 8000a8e:	d10f      	bne.n	8000ab0 <VCP_Ctrl+0x24>
	case SET_LINE_CODING:
		/* Not  needed for this driver */
		break;

	case GET_LINE_CODING:
		Buf[0] = (uint8_t) (linecoding.bitrate);
 8000a90:	4b08      	ldr	r3, [pc, #32]	; (8000ab4 <VCP_Ctrl+0x28>)
 8000a92:	681a      	ldr	r2, [r3, #0]
 8000a94:	700a      	strb	r2, [r1, #0]
		Buf[1] = (uint8_t) (linecoding.bitrate >> 8);
 8000a96:	681a      	ldr	r2, [r3, #0]
 8000a98:	0a12      	lsrs	r2, r2, #8
 8000a9a:	704a      	strb	r2, [r1, #1]
		Buf[2] = (uint8_t) (linecoding.bitrate >> 16);
 8000a9c:	885a      	ldrh	r2, [r3, #2]
 8000a9e:	708a      	strb	r2, [r1, #2]
		Buf[3] = (uint8_t) (linecoding.bitrate >> 24);
 8000aa0:	78da      	ldrb	r2, [r3, #3]
 8000aa2:	70ca      	strb	r2, [r1, #3]
		Buf[4] = linecoding.format;
 8000aa4:	791a      	ldrb	r2, [r3, #4]
 8000aa6:	710a      	strb	r2, [r1, #4]
		Buf[5] = linecoding.paritytype;
 8000aa8:	795a      	ldrb	r2, [r3, #5]
 8000aaa:	714a      	strb	r2, [r1, #5]
		Buf[6] = linecoding.datatype;
 8000aac:	799b      	ldrb	r3, [r3, #6]
 8000aae:	718b      	strb	r3, [r1, #6]
	default:
		break;
	}

	return USBD_OK;
}
 8000ab0:	2000      	movs	r0, #0
 8000ab2:	4770      	bx	lr
 8000ab4:	2000000c 	.word	0x2000000c

08000ab8 <VCP_DataTx>:
 *         this function.
 * @param  Buf: Buffer of data to be sent
 * @param  Len: Number of data to be sent (in bytes)
 * @retval Result of the opeartion: USBD_OK if all operations are OK else VCP_FAIL
 */
static uint16_t VCP_DataTx(uint8_t* Buf, uint32_t Len) {
 8000ab8:	b570      	push	{r4, r5, r6, lr}
	uint32_t i = 0;
 8000aba:	2300      	movs	r3, #0
	while (i < Len) {
 8000abc:	e00c      	b.n	8000ad8 <VCP_DataTx+0x20>
		APP_Rx_Buffer[APP_Rx_ptr_in] = *(Buf + i);
 8000abe:	4a08      	ldr	r2, [pc, #32]	; (8000ae0 <VCP_DataTx+0x28>)
 8000ac0:	5cc6      	ldrb	r6, [r0, r3]
 8000ac2:	6814      	ldr	r4, [r2, #0]
 8000ac4:	4d07      	ldr	r5, [pc, #28]	; (8000ae4 <VCP_DataTx+0x2c>)
 8000ac6:	552e      	strb	r6, [r5, r4]
		APP_Rx_ptr_in++;
 8000ac8:	3401      	adds	r4, #1
		i++;
 8000aca:	3301      	adds	r3, #1
		/* To avoid buffer overflow */
		if (APP_Rx_ptr_in == APP_RX_DATA_SIZE) {
 8000acc:	f5b4 6f00 	cmp.w	r4, #2048	; 0x800
 */
static uint16_t VCP_DataTx(uint8_t* Buf, uint32_t Len) {
	uint32_t i = 0;
	while (i < Len) {
		APP_Rx_Buffer[APP_Rx_ptr_in] = *(Buf + i);
		APP_Rx_ptr_in++;
 8000ad0:	6014      	str	r4, [r2, #0]
		i++;
		/* To avoid buffer overflow */
		if (APP_Rx_ptr_in == APP_RX_DATA_SIZE) {
 8000ad2:	d101      	bne.n	8000ad8 <VCP_DataTx+0x20>
			APP_Rx_ptr_in = 0;
 8000ad4:	2400      	movs	r4, #0
 8000ad6:	6014      	str	r4, [r2, #0]
 * @param  Len: Number of data to be sent (in bytes)
 * @retval Result of the opeartion: USBD_OK if all operations are OK else VCP_FAIL
 */
static uint16_t VCP_DataTx(uint8_t* Buf, uint32_t Len) {
	uint32_t i = 0;
	while (i < Len) {
 8000ad8:	428b      	cmp	r3, r1
 8000ada:	d1f0      	bne.n	8000abe <VCP_DataTx+0x6>
			APP_Rx_ptr_in = 0;
		}
	}

	return USBD_OK;
}
 8000adc:	2000      	movs	r0, #0
 8000ade:	bd70      	pop	{r4, r5, r6, pc}
 8000ae0:	20000800 	.word	0x20000800
 8000ae4:	200012b0 	.word	0x200012b0

08000ae8 <VCP_DataRx>:
		APP_Tx_Buffer[APP_tx_ptr_head] = *(Buf + i);
		APP_tx_ptr_head++;
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
			APP_tx_ptr_head = 0;

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8000ae8:	4b0c      	ldr	r3, [pc, #48]	; (8000b1c <VCP_DataRx+0x34>)
#define APP_TX_BUF_SIZE 128
uint8_t APP_Tx_Buffer[APP_TX_BUF_SIZE];
uint32_t APP_tx_ptr_head;
uint32_t APP_tx_ptr_tail;

static uint16_t VCP_DataRx(uint8_t* Buf, uint32_t Len) {
 8000aea:	b5f0      	push	{r4, r5, r6, r7, lr}
		APP_Tx_Buffer[APP_tx_ptr_head] = *(Buf + i);
		APP_tx_ptr_head++;
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
			APP_tx_ptr_head = 0;

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8000aec:	681d      	ldr	r5, [r3, #0]
uint32_t APP_tx_ptr_tail;

static uint16_t VCP_DataRx(uint8_t* Buf, uint32_t Len) {
	uint32_t i;

	for (i = 0; i < Len; i++) {
 8000aee:	2300      	movs	r3, #0
 8000af0:	e00e      	b.n	8000b10 <VCP_DataRx+0x28>
		APP_Tx_Buffer[APP_tx_ptr_head] = *(Buf + i);
 8000af2:	4a0b      	ldr	r2, [pc, #44]	; (8000b20 <VCP_DataRx+0x38>)
 8000af4:	5cc7      	ldrb	r7, [r0, r3]
 8000af6:	6814      	ldr	r4, [r2, #0]
 8000af8:	4e0a      	ldr	r6, [pc, #40]	; (8000b24 <VCP_DataRx+0x3c>)
 8000afa:	5537      	strb	r7, [r6, r4]
		APP_tx_ptr_head++;
 8000afc:	3401      	adds	r4, #1
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
 8000afe:	2c80      	cmp	r4, #128	; 0x80
static uint16_t VCP_DataRx(uint8_t* Buf, uint32_t Len) {
	uint32_t i;

	for (i = 0; i < Len; i++) {
		APP_Tx_Buffer[APP_tx_ptr_head] = *(Buf + i);
		APP_tx_ptr_head++;
 8000b00:	6014      	str	r4, [r2, #0]
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
 8000b02:	d101      	bne.n	8000b08 <VCP_DataRx+0x20>
			APP_tx_ptr_head = 0;
 8000b04:	3c80      	subs	r4, #128	; 0x80
 8000b06:	6014      	str	r4, [r2, #0]

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8000b08:	6812      	ldr	r2, [r2, #0]
 8000b0a:	42aa      	cmp	r2, r5
 8000b0c:	d004      	beq.n	8000b18 <VCP_DataRx+0x30>
uint32_t APP_tx_ptr_tail;

static uint16_t VCP_DataRx(uint8_t* Buf, uint32_t Len) {
	uint32_t i;

	for (i = 0; i < Len; i++) {
 8000b0e:	3301      	adds	r3, #1
 8000b10:	428b      	cmp	r3, r1
 8000b12:	d1ee      	bne.n	8000af2 <VCP_DataRx+0xa>

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
			return USBD_FAIL;
	}

	return USBD_OK;
 8000b14:	2000      	movs	r0, #0
 8000b16:	bdf0      	pop	{r4, r5, r6, r7, pc}
		APP_tx_ptr_head++;
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
			APP_tx_ptr_head = 0;

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
			return USBD_FAIL;
 8000b18:	2002      	movs	r0, #2
	}

	return USBD_OK;
}
 8000b1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000b1c:	20000c1c 	.word	0x20000c1c
 8000b20:	20000c30 	.word	0x20000c30
 8000b24:	20000b9c 	.word	0x20000b9c

08000b28 <VCP_put_char>:
 *         Sends one char over the USB serial link.
 * @param  buf: char to be sent
 * @retval none
 */

void VCP_put_char(uint8_t buf) {
 8000b28:	b507      	push	{r0, r1, r2, lr}
 8000b2a:	ab02      	add	r3, sp, #8
	VCP_DataTx(&buf, 1);
 8000b2c:	2101      	movs	r1, #1
 *         Sends one char over the USB serial link.
 * @param  buf: char to be sent
 * @retval none
 */

void VCP_put_char(uint8_t buf) {
 8000b2e:	f803 0d01 	strb.w	r0, [r3, #-1]!
	VCP_DataTx(&buf, 1);
 8000b32:	4618      	mov	r0, r3
 8000b34:	f7ff ffc0 	bl	8000ab8 <VCP_DataTx>
}
 8000b38:	bd0e      	pop	{r1, r2, r3, pc}

08000b3a <VCP_send_str>:

void VCP_send_str(uint8_t* buf) {
	uint32_t i = 0;
 8000b3a:	2100      	movs	r1, #0
	while (*(buf + i)) {
 8000b3c:	e000      	b.n	8000b40 <VCP_send_str+0x6>
		i++;
 8000b3e:	3101      	adds	r1, #1
	VCP_DataTx(&buf, 1);
}

void VCP_send_str(uint8_t* buf) {
	uint32_t i = 0;
	while (*(buf + i)) {
 8000b40:	5c43      	ldrb	r3, [r0, r1]
 8000b42:	2b00      	cmp	r3, #0
 8000b44:	d1fb      	bne.n	8000b3e <VCP_send_str+0x4>
		i++;
	}
	VCP_DataTx(buf, i);
 8000b46:	e7b7      	b.n	8000ab8 <VCP_DataTx>

08000b48 <VCP_send_buffer>:
}

void VCP_send_buffer(uint8_t* buf, int len) {
	VCP_DataTx(buf, len);
 8000b48:	e7b6      	b.n	8000ab8 <VCP_DataTx>

08000b4a <VCP_get_char_test>:

	return USBD_OK;
}

int VCP_get_char_test(void) {
	return APP_tx_ptr_head != APP_tx_ptr_tail;
 8000b4a:	4b04      	ldr	r3, [pc, #16]	; (8000b5c <VCP_get_char_test+0x12>)
 8000b4c:	6818      	ldr	r0, [r3, #0]
 8000b4e:	4b04      	ldr	r3, [pc, #16]	; (8000b60 <VCP_get_char_test+0x16>)
 8000b50:	681b      	ldr	r3, [r3, #0]
}
 8000b52:	1ac0      	subs	r0, r0, r3
 8000b54:	bf18      	it	ne
 8000b56:	2001      	movne	r0, #1
 8000b58:	4770      	bx	lr
 8000b5a:	bf00      	nop
 8000b5c:	20000c30 	.word	0x20000c30
 8000b60:	20000c1c 	.word	0x20000c1c

08000b64 <VCP_get_char>:

int VCP_get_char(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8000b64:	4b0a      	ldr	r3, [pc, #40]	; (8000b90 <VCP_get_char+0x2c>)
 8000b66:	490b      	ldr	r1, [pc, #44]	; (8000b94 <VCP_get_char+0x30>)
 8000b68:	681a      	ldr	r2, [r3, #0]
 8000b6a:	6809      	ldr	r1, [r1, #0]
 8000b6c:	4291      	cmp	r1, r2
 8000b6e:	d00b      	beq.n	8000b88 <VCP_get_char+0x24>
		return 0;

	*buf = APP_Tx_Buffer[APP_tx_ptr_tail];
 8000b70:	4909      	ldr	r1, [pc, #36]	; (8000b98 <VCP_get_char+0x34>)
 8000b72:	5c8a      	ldrb	r2, [r1, r2]
 8000b74:	7002      	strb	r2, [r0, #0]
	APP_tx_ptr_tail++;
 8000b76:	681a      	ldr	r2, [r3, #0]
 8000b78:	3201      	adds	r2, #1
	if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
 8000b7a:	2a80      	cmp	r2, #128	; 0x80
int VCP_get_char(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
		return 0;

	*buf = APP_Tx_Buffer[APP_tx_ptr_tail];
	APP_tx_ptr_tail++;
 8000b7c:	601a      	str	r2, [r3, #0]
	if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
 8000b7e:	d105      	bne.n	8000b8c <VCP_get_char+0x28>
		APP_tx_ptr_tail = 0;
 8000b80:	3a80      	subs	r2, #128	; 0x80
 8000b82:	601a      	str	r2, [r3, #0]

	return 1;
 8000b84:	2001      	movs	r0, #1
 8000b86:	4770      	bx	lr
	return APP_tx_ptr_head != APP_tx_ptr_tail;
}

int VCP_get_char(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
		return 0;
 8000b88:	2000      	movs	r0, #0
 8000b8a:	4770      	bx	lr
	*buf = APP_Tx_Buffer[APP_tx_ptr_tail];
	APP_tx_ptr_tail++;
	if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
		APP_tx_ptr_tail = 0;

	return 1;
 8000b8c:	2001      	movs	r0, #1
}
 8000b8e:	4770      	bx	lr
 8000b90:	20000c1c 	.word	0x20000c1c
 8000b94:	20000c30 	.word	0x20000c30
 8000b98:	20000b9c 	.word	0x20000b9c

08000b9c <VCP_get_string>:

int VCP_get_string(uint8_t *buf) {
 8000b9c:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8000b9e:	4a1f      	ldr	r2, [pc, #124]	; (8000c1c <VCP_get_string+0x80>)
 8000ba0:	4c1f      	ldr	r4, [pc, #124]	; (8000c20 <VCP_get_string+0x84>)
 8000ba2:	6813      	ldr	r3, [r2, #0]
 8000ba4:	6821      	ldr	r1, [r4, #0]
 8000ba6:	4299      	cmp	r1, r3
 8000ba8:	4626      	mov	r6, r4
 8000baa:	d108      	bne.n	8000bbe <VCP_get_string+0x22>
 8000bac:	e033      	b.n	8000c16 <VCP_get_string+0x7a>
		return 0;

	while (!APP_Tx_Buffer[APP_tx_ptr_tail]
			|| APP_Tx_Buffer[APP_tx_ptr_tail] == '\n'
			|| APP_Tx_Buffer[APP_tx_ptr_tail] == '\r') {
		APP_tx_ptr_tail++;
 8000bae:	3301      	adds	r3, #1
		if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
			APP_tx_ptr_tail = 0;
 8000bb0:	2b80      	cmp	r3, #128	; 0x80
 8000bb2:	bf08      	it	eq
 8000bb4:	2300      	moveq	r3, #0
		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8000bb6:	4299      	cmp	r1, r3
 8000bb8:	d101      	bne.n	8000bbe <VCP_get_string+0x22>
 8000bba:	6011      	str	r1, [r2, #0]
 8000bbc:	e02b      	b.n	8000c16 <VCP_get_string+0x7a>

int VCP_get_string(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
		return 0;

	while (!APP_Tx_Buffer[APP_tx_ptr_tail]
 8000bbe:	4c19      	ldr	r4, [pc, #100]	; (8000c24 <VCP_get_string+0x88>)
			|| APP_Tx_Buffer[APP_tx_ptr_tail] == '\n'
			|| APP_Tx_Buffer[APP_tx_ptr_tail] == '\r') {
		APP_tx_ptr_tail++;
		if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
			APP_tx_ptr_tail = 0;
		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8000bc0:	5ce5      	ldrb	r5, [r4, r3]
 8000bc2:	2d0d      	cmp	r5, #13
 8000bc4:	4625      	mov	r5, r4
 8000bc6:	d803      	bhi.n	8000bd0 <VCP_get_string+0x34>
 8000bc8:	56e4      	ldrsb	r4, [r4, r3]
 8000bca:	4f17      	ldr	r7, [pc, #92]	; (8000c28 <VCP_get_string+0x8c>)
 8000bcc:	40a7      	lsls	r7, r4
 8000bce:	d4ee      	bmi.n	8000bae <VCP_get_string+0x12>
 8000bd0:	6013      	str	r3, [r2, #0]

int VCP_get_string(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
		return 0;

	while (!APP_Tx_Buffer[APP_tx_ptr_tail]
 8000bd2:	2300      	movs	r3, #0
			return 0;
	}

	int i = 0;
	do {
		*(buf + i) = APP_Tx_Buffer[i + APP_tx_ptr_tail];
 8000bd4:	18ec      	adds	r4, r5, r3
 8000bd6:	6811      	ldr	r1, [r2, #0]
 8000bd8:	5c61      	ldrb	r1, [r4, r1]
 8000bda:	54c1      	strb	r1, [r0, r3]
		i++;

		if ((APP_tx_ptr_tail + i) == APP_TX_BUF_SIZE)
 8000bdc:	6811      	ldr	r1, [r2, #0]
	}

	int i = 0;
	do {
		*(buf + i) = APP_Tx_Buffer[i + APP_tx_ptr_tail];
		i++;
 8000bde:	3301      	adds	r3, #1

		if ((APP_tx_ptr_tail + i) == APP_TX_BUF_SIZE)
 8000be0:	185c      	adds	r4, r3, r1
 8000be2:	2c80      	cmp	r4, #128	; 0x80
			i = -APP_tx_ptr_tail;
 8000be4:	bf08      	it	eq
 8000be6:	424b      	negeq	r3, r1
		if (APP_tx_ptr_head == (APP_tx_ptr_tail + i))
 8000be8:	6834      	ldr	r4, [r6, #0]
 8000bea:	1859      	adds	r1, r3, r1
 8000bec:	428c      	cmp	r4, r1
 8000bee:	d012      	beq.n	8000c16 <VCP_get_string+0x7a>
 8000bf0:	5c6c      	ldrb	r4, [r5, r1]
 8000bf2:	2c0d      	cmp	r4, #13
 8000bf4:	d8ee      	bhi.n	8000bd4 <VCP_get_string+0x38>
 8000bf6:	4c0b      	ldr	r4, [pc, #44]	; (8000c24 <VCP_get_string+0x88>)
 8000bf8:	5661      	ldrsb	r1, [r4, r1]
 8000bfa:	4c0b      	ldr	r4, [pc, #44]	; (8000c28 <VCP_get_string+0x8c>)
 8000bfc:	408c      	lsls	r4, r1
 8000bfe:	d5e9      	bpl.n	8000bd4 <VCP_get_string+0x38>

	} while (APP_Tx_Buffer[APP_tx_ptr_tail + i]
			&& APP_Tx_Buffer[APP_tx_ptr_tail + i] != '\n'
			&& APP_Tx_Buffer[APP_tx_ptr_tail + i] != '\r');

	*(buf + i) = 0;
 8000c00:	2100      	movs	r1, #0
 8000c02:	54c1      	strb	r1, [r0, r3]
	APP_tx_ptr_tail += i;
 8000c04:	6811      	ldr	r1, [r2, #0]
 8000c06:	1859      	adds	r1, r3, r1
	if (APP_tx_ptr_tail >= APP_TX_BUF_SIZE)
 8000c08:	297f      	cmp	r1, #127	; 0x7f
	} while (APP_Tx_Buffer[APP_tx_ptr_tail + i]
			&& APP_Tx_Buffer[APP_tx_ptr_tail + i] != '\n'
			&& APP_Tx_Buffer[APP_tx_ptr_tail + i] != '\r');

	*(buf + i) = 0;
	APP_tx_ptr_tail += i;
 8000c0a:	6011      	str	r1, [r2, #0]
	if (APP_tx_ptr_tail >= APP_TX_BUF_SIZE)
 8000c0c:	d904      	bls.n	8000c18 <VCP_get_string+0x7c>
		APP_tx_ptr_tail -= APP_TX_BUF_SIZE;
 8000c0e:	4a03      	ldr	r2, [pc, #12]	; (8000c1c <VCP_get_string+0x80>)
 8000c10:	3980      	subs	r1, #128	; 0x80
 8000c12:	6011      	str	r1, [r2, #0]
 8000c14:	e000      	b.n	8000c18 <VCP_get_string+0x7c>
		i++;

		if ((APP_tx_ptr_tail + i) == APP_TX_BUF_SIZE)
			i = -APP_tx_ptr_tail;
		if (APP_tx_ptr_head == (APP_tx_ptr_tail + i))
			return 0;
 8000c16:	2300      	movs	r3, #0
	*(buf + i) = 0;
	APP_tx_ptr_tail += i;
	if (APP_tx_ptr_tail >= APP_TX_BUF_SIZE)
		APP_tx_ptr_tail -= APP_TX_BUF_SIZE;
	return i;
}
 8000c18:	4618      	mov	r0, r3
 8000c1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000c1c:	20000c1c 	.word	0x20000c1c
 8000c20:	20000c30 	.word	0x20000c30
 8000c24:	20000b9c 	.word	0x20000b9c
 8000c28:	80240000 	.word	0x80240000

08000c2c <EVAL_COM_IRQHandler>:
 * @param  None.
 * @retval None.
 */
void EVAL_COM_IRQHandler(void) {

}
 8000c2c:	4770      	bx	lr
 8000c2e:	bf00      	nop

08000c30 <NMI_Handler>:
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}
 8000c30:	4770      	bx	lr

08000c32 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8000c32:	e7fe      	b.n	8000c32 <HardFault_Handler>

08000c34 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8000c34:	e7fe      	b.n	8000c34 <MemManage_Handler>

08000c36 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 8000c36:	e7fe      	b.n	8000c36 <BusFault_Handler>

08000c38 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8000c38:	e7fe      	b.n	8000c38 <UsageFault_Handler>

08000c3a <SVC_Handler>:
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
}
 8000c3a:	4770      	bx	lr

08000c3c <DebugMon_Handler>:
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
}
 8000c3c:	4770      	bx	lr

08000c3e <PendSV_Handler>:
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
}
 8000c3e:	4770      	bx	lr

08000c40 <SysTick_Handler>:
  * @retval None
  */
void SysTick_Handler(void)
{

	timing_handler();
 8000c40:	f000 b91e 	b.w	8000e80 <timing_handler>

08000c44 <OTG_FS_WKUP_IRQHandler>:
/*  file (startup_stm32f4xx.s).                                               */
/******************************************************************************/

#ifdef USE_USB_OTG_FS
void OTG_FS_WKUP_IRQHandler(void)
{
 8000c44:	b510      	push	{r4, lr}
  if(USB_OTG_dev.cfg.low_power)
 8000c46:	4c09      	ldr	r4, [pc, #36]	; (8000c6c <OTG_FS_WKUP_IRQHandler+0x28>)
 8000c48:	7aa3      	ldrb	r3, [r4, #10]
 8000c4a:	b14b      	cbz	r3, 8000c60 <OTG_FS_WKUP_IRQHandler+0x1c>
  {
    *(uint32_t *)(0xE000ED10) &= 0xFFFFFFF9 ;
 8000c4c:	4b08      	ldr	r3, [pc, #32]	; (8000c70 <OTG_FS_WKUP_IRQHandler+0x2c>)
 8000c4e:	681a      	ldr	r2, [r3, #0]
 8000c50:	f022 0206 	bic.w	r2, r2, #6
 8000c54:	601a      	str	r2, [r3, #0]
    SystemInit();
 8000c56:	f000 f813 	bl	8000c80 <SystemInit>
    USB_OTG_UngateClock(&USB_OTG_dev);
 8000c5a:	4620      	mov	r0, r4
 8000c5c:	f001 fcee 	bl	800263c <USB_OTG_UngateClock>
  }
  EXTI_ClearITPendingBit(EXTI_Line18);
 8000c60:	f44f 2080 	mov.w	r0, #262144	; 0x40000
}
 8000c64:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  {
    *(uint32_t *)(0xE000ED10) &= 0xFFFFFFF9 ;
    SystemInit();
    USB_OTG_UngateClock(&USB_OTG_dev);
  }
  EXTI_ClearITPendingBit(EXTI_Line18);
 8000c68:	f000 bc48 	b.w	80014fc <EXTI_ClearITPendingBit>
 8000c6c:	20000c34 	.word	0x20000c34
 8000c70:	e000ed10 	.word	0xe000ed10

08000c74 <OTG_FS_IRQHandler>:
void OTG_HS_IRQHandler(void)
#else
void OTG_FS_IRQHandler(void)
#endif
{
  USBD_OTG_ISR_Handler (&USB_OTG_dev);
 8000c74:	4801      	ldr	r0, [pc, #4]	; (8000c7c <OTG_FS_IRQHandler+0x8>)
 8000c76:	f001 bf55 	b.w	8002b24 <USBD_OTG_ISR_Handler>
 8000c7a:	bf00      	nop
 8000c7c:	20000c34 	.word	0x20000c34

08000c80 <SystemInit>:
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
	SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
#endif
	/* Reset the RCC clock configuration to the default reset state ------------*/
	/* Set HSION bit */
	RCC->CR |= (uint32_t)0x00000001;
 8000c80:	4b34      	ldr	r3, [pc, #208]	; (8000d54 <SystemInit+0xd4>)
 8000c82:	681a      	ldr	r2, [r3, #0]
 8000c84:	f042 0201 	orr.w	r2, r2, #1
 8000c88:	601a      	str	r2, [r3, #0]

	/* Reset CFGR register */
	RCC->CFGR = 0x00000000;
 8000c8a:	2200      	movs	r2, #0
 8000c8c:	609a      	str	r2, [r3, #8]

	/* Reset HSEON, CSSON and PLLON bits */
	RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000c8e:	6819      	ldr	r1, [r3, #0]
 8000c90:	f021 7184 	bic.w	r1, r1, #17301504	; 0x1080000
 8000c94:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 8000c98:	6019      	str	r1, [r3, #0]

	/* Reset PLLCFGR register */
	RCC->PLLCFGR = 0x24003010;
 8000c9a:	492f      	ldr	r1, [pc, #188]	; (8000d58 <SystemInit+0xd8>)
 8000c9c:	6059      	str	r1, [r3, #4]

	/* Reset HSEBYP bit */
	RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000c9e:	6819      	ldr	r1, [r3, #0]
 *         SystemFrequency variable.
 * @param  None
 * @retval None
 */
void SystemInit(void)
{
 8000ca0:	b082      	sub	sp, #8

	/* Reset PLLCFGR register */
	RCC->PLLCFGR = 0x24003010;

	/* Reset HSEBYP bit */
	RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000ca2:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 8000ca6:	6019      	str	r1, [r3, #0]

	/* Disable all interrupts */
	RCC->CIR = 0x00000000;
 8000ca8:	60da      	str	r2, [r3, #12]
static void SetSysClock(void)
{
	/******************************************************************************/
	/*            PLL (clocked by HSE) used as System clock source                */
	/******************************************************************************/
	__IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 8000caa:	9201      	str	r2, [sp, #4]
 8000cac:	9200      	str	r2, [sp, #0]

	/* Enable HSE */
	RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8000cae:	681a      	ldr	r2, [r3, #0]
 8000cb0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8000cb4:	601a      	str	r2, [r3, #0]

	/* Wait till HSE is ready and if Time out is reached exit */
	do
	{
		HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8000cb6:	4b27      	ldr	r3, [pc, #156]	; (8000d54 <SystemInit+0xd4>)
 8000cb8:	681a      	ldr	r2, [r3, #0]
 8000cba:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 8000cbe:	9200      	str	r2, [sp, #0]
		StartUpCounter++;
 8000cc0:	9a01      	ldr	r2, [sp, #4]
 8000cc2:	3201      	adds	r2, #1
 8000cc4:	9201      	str	r2, [sp, #4]
	} while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8000cc6:	9a00      	ldr	r2, [sp, #0]
 8000cc8:	b91a      	cbnz	r2, 8000cd2 <SystemInit+0x52>
 8000cca:	9a01      	ldr	r2, [sp, #4]
 8000ccc:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 8000cd0:	d1f1      	bne.n	8000cb6 <SystemInit+0x36>

	if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8000cd2:	681b      	ldr	r3, [r3, #0]
 8000cd4:	f413 3300 	ands.w	r3, r3, #131072	; 0x20000
	{
		HSEStatus = (uint32_t)0x01;
 8000cd8:	bf18      	it	ne
 8000cda:	2301      	movne	r3, #1
	}
	else
	{
		HSEStatus = (uint32_t)0x00;
 8000cdc:	9300      	str	r3, [sp, #0]
	}

	if (HSEStatus == (uint32_t)0x01)
 8000cde:	9b00      	ldr	r3, [sp, #0]
 8000ce0:	2b01      	cmp	r3, #1
 8000ce2:	d130      	bne.n	8000d46 <SystemInit+0xc6>
	{
		/* Select regulator voltage output Scale 1 mode, System frequency up to 168 MHz */
		RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 8000ce4:	4b1b      	ldr	r3, [pc, #108]	; (8000d54 <SystemInit+0xd4>)
 8000ce6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000ce8:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000cec:	641a      	str	r2, [r3, #64]	; 0x40
		PWR->CR |= PWR_CR_VOS;
 8000cee:	4a1b      	ldr	r2, [pc, #108]	; (8000d5c <SystemInit+0xdc>)
 8000cf0:	6811      	ldr	r1, [r2, #0]
 8000cf2:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 8000cf6:	6011      	str	r1, [r2, #0]

		/* HCLK = SYSCLK / 1*/
		RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 8000cf8:	689a      	ldr	r2, [r3, #8]
 8000cfa:	609a      	str	r2, [r3, #8]

		/* PCLK2 = HCLK / 2*/
		RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 8000cfc:	689a      	ldr	r2, [r3, #8]
 8000cfe:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8000d02:	609a      	str	r2, [r3, #8]

		/* PCLK1 = HCLK / 4*/
		RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 8000d04:	689a      	ldr	r2, [r3, #8]
 8000d06:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 8000d0a:	609a      	str	r2, [r3, #8]

		/* Configure the main PLL */
		RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8000d0c:	4a14      	ldr	r2, [pc, #80]	; (8000d60 <SystemInit+0xe0>)
 8000d0e:	605a      	str	r2, [r3, #4]
				(RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

		/* Enable the main PLL */
		RCC->CR |= RCC_CR_PLLON;
 8000d10:	681a      	ldr	r2, [r3, #0]
 8000d12:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000d16:	601a      	str	r2, [r3, #0]

		/* Wait till the main PLL is ready */
		while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8000d18:	4b0e      	ldr	r3, [pc, #56]	; (8000d54 <SystemInit+0xd4>)
 8000d1a:	681a      	ldr	r2, [r3, #0]
 8000d1c:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8000d20:	d0fa      	beq.n	8000d18 <SystemInit+0x98>
		{
		}

		/* Configure Flash prefetch, Instruction cache, Data cache and wait state */
		FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 8000d22:	4a10      	ldr	r2, [pc, #64]	; (8000d64 <SystemInit+0xe4>)
 8000d24:	f240 6105 	movw	r1, #1541	; 0x605
 8000d28:	6011      	str	r1, [r2, #0]

		/* Select the main PLL as system clock source */
		RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8000d2a:	689a      	ldr	r2, [r3, #8]
 8000d2c:	f022 0203 	bic.w	r2, r2, #3
 8000d30:	609a      	str	r2, [r3, #8]
		RCC->CFGR |= RCC_CFGR_SW_PLL;
 8000d32:	689a      	ldr	r2, [r3, #8]
 8000d34:	f042 0202 	orr.w	r2, r2, #2
 8000d38:	609a      	str	r2, [r3, #8]

		/* Wait till the main PLL is used as system clock source */
		while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 8000d3a:	4b06      	ldr	r3, [pc, #24]	; (8000d54 <SystemInit+0xd4>)
 8000d3c:	689b      	ldr	r3, [r3, #8]
 8000d3e:	f003 030c 	and.w	r3, r3, #12
 8000d42:	2b08      	cmp	r3, #8
 8000d44:	d1f9      	bne.n	8000d3a <SystemInit+0xba>

	/* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
	SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
	SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8000d46:	4b08      	ldr	r3, [pc, #32]	; (8000d68 <SystemInit+0xe8>)
 8000d48:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8000d4c:	609a      	str	r2, [r3, #8]
#endif
}
 8000d4e:	b002      	add	sp, #8
 8000d50:	4770      	bx	lr
 8000d52:	bf00      	nop
 8000d54:	40023800 	.word	0x40023800
 8000d58:	24003010 	.word	0x24003010
 8000d5c:	40007000 	.word	0x40007000
 8000d60:	07405408 	.word	0x07405408
 8000d64:	40023c00 	.word	0x40023c00
 8000d68:	e000ed00 	.word	0xe000ed00

08000d6c <SystemCoreClockUpdate>:
void SystemCoreClockUpdate(void)
{
	uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

	/* Get SYSCLK source -------------------------------------------------------*/
	tmp = RCC->CFGR & RCC_CFGR_SWS;
 8000d6c:	4a1e      	ldr	r2, [pc, #120]	; (8000de8 <SystemCoreClockUpdate+0x7c>)
 8000d6e:	4b1f      	ldr	r3, [pc, #124]	; (8000dec <SystemCoreClockUpdate+0x80>)
 8000d70:	6891      	ldr	r1, [r2, #8]
 8000d72:	f001 010c 	and.w	r1, r1, #12

	switch (tmp)
 8000d76:	2904      	cmp	r1, #4
 8000d78:	d003      	beq.n	8000d82 <SystemCoreClockUpdate+0x16>
 8000d7a:	2908      	cmp	r1, #8
 8000d7c:	d003      	beq.n	8000d86 <SystemCoreClockUpdate+0x1a>
 8000d7e:	4a1c      	ldr	r2, [pc, #112]	; (8000df0 <SystemCoreClockUpdate+0x84>)
 8000d80:	e025      	b.n	8000dce <SystemCoreClockUpdate+0x62>
	{
	case 0x00:  /* HSI used as system clock source */
		SystemCoreClock = HSI_VALUE;
		break;
	case 0x04:  /* HSE used as system clock source */
		SystemCoreClock = HSE_VALUE;
 8000d82:	4a1c      	ldr	r2, [pc, #112]	; (8000df4 <SystemCoreClockUpdate+0x88>)
 8000d84:	e023      	b.n	8000dce <SystemCoreClockUpdate+0x62>
	case 0x08:  /* PLL used as system clock source */

		/* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
		 */
		pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8000d86:	6851      	ldr	r1, [r2, #4]
		pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8000d88:	6850      	ldr	r0, [r2, #4]

		if (pllsource != 0)
 8000d8a:	f411 0f80 	tst.w	r1, #4194304	; 0x400000

		/* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
		 */
		pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
		pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8000d8e:	f000 003f 	and.w	r0, r0, #63	; 0x3f

		if (pllsource != 0)
 8000d92:	d00a      	beq.n	8000daa <SystemCoreClockUpdate+0x3e>
		{
			/* HSE used as PLL clock source */
			pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8000d94:	6852      	ldr	r2, [r2, #4]
 8000d96:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 8000d9a:	ea02 0101 	and.w	r1, r2, r1
 8000d9e:	4a15      	ldr	r2, [pc, #84]	; (8000df4 <SystemCoreClockUpdate+0x88>)
 8000da0:	0989      	lsrs	r1, r1, #6
 8000da2:	fbb2 f2f0 	udiv	r2, r2, r0
 8000da6:	434a      	muls	r2, r1
 8000da8:	e009      	b.n	8000dbe <SystemCoreClockUpdate+0x52>
		}
		else
		{
			/* HSI used as PLL clock source */
			pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8000daa:	6851      	ldr	r1, [r2, #4]
 8000dac:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 8000db0:	ea01 0202 	and.w	r2, r1, r2
 8000db4:	490e      	ldr	r1, [pc, #56]	; (8000df0 <SystemCoreClockUpdate+0x84>)
 8000db6:	0992      	lsrs	r2, r2, #6
 8000db8:	fbb1 f0f0 	udiv	r0, r1, r0
 8000dbc:	4342      	muls	r2, r0
		}

		pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8000dbe:	490a      	ldr	r1, [pc, #40]	; (8000de8 <SystemCoreClockUpdate+0x7c>)
 8000dc0:	6849      	ldr	r1, [r1, #4]
 8000dc2:	f401 3140 	and.w	r1, r1, #196608	; 0x30000
 8000dc6:	0bc9      	lsrs	r1, r1, #15
 8000dc8:	3102      	adds	r1, #2
		SystemCoreClock = pllvco/pllp;
 8000dca:	fbb2 f2f1 	udiv	r2, r2, r1
 8000dce:	601a      	str	r2, [r3, #0]
		SystemCoreClock = HSI_VALUE;
		break;
	}
	/* Compute HCLK frequency --------------------------------------------------*/
	/* Get HCLK prescaler */
	tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8000dd0:	4a05      	ldr	r2, [pc, #20]	; (8000de8 <SystemCoreClockUpdate+0x7c>)
	/* HCLK frequency */
	SystemCoreClock >>= tmp;
 8000dd2:	6819      	ldr	r1, [r3, #0]
		SystemCoreClock = HSI_VALUE;
		break;
	}
	/* Compute HCLK frequency --------------------------------------------------*/
	/* Get HCLK prescaler */
	tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8000dd4:	6892      	ldr	r2, [r2, #8]
 8000dd6:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8000dda:	eb03 1212 	add.w	r2, r3, r2, lsr #4
 8000dde:	7912      	ldrb	r2, [r2, #4]
	/* HCLK frequency */
	SystemCoreClock >>= tmp;
 8000de0:	fa31 f202 	lsrs.w	r2, r1, r2
 8000de4:	601a      	str	r2, [r3, #0]
}
 8000de6:	4770      	bx	lr
 8000de8:	40023800 	.word	0x40023800
 8000dec:	20000028 	.word	0x20000028
 8000df0:	00f42400 	.word	0x00f42400
 8000df4:	017d7840 	.word	0x017d7840

08000df8 <usb1_init>:
void usb1_init(void)
{
	GPIO_InitTypeDef  GPIO_InitStructure;

	// ---------- SysTick timer -------- //
	if (SysTick_Config(SystemCoreClock / 1000)) {
 8000df8:	4b19      	ldr	r3, [pc, #100]	; (8000e60 <usb1_init+0x68>)
 8000dfa:	681a      	ldr	r2, [r3, #0]
 8000dfc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000e00:	fbb2 f2f3 	udiv	r2, r2, r3
__ALIGN_BEGIN USB_OTG_CORE_HANDLE  USB_OTG_dev __ALIGN_END;

// Private function prototypes

void usb1_init(void)
{
 8000e04:	b530      	push	{r4, r5, lr}
 */
static __INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
 8000e06:	4b17      	ldr	r3, [pc, #92]	; (8000e64 <usb1_init+0x6c>)
 8000e08:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8000e0c:	3a01      	subs	r2, #1
 8000e0e:	605a      	str	r2, [r3, #4]
    \param [in]  priority  Priority to set
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8000e10:	4a15      	ldr	r2, [pc, #84]	; (8000e68 <usb1_init+0x70>)
 8000e12:	21f0      	movs	r1, #240	; 0xf0
 8000e14:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 8000e18:	2400      	movs	r4, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000e1a:	2207      	movs	r2, #7
 8000e1c:	b085      	sub	sp, #20
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 8000e1e:	609c      	str	r4, [r3, #8]
		while (1){};
	}

	// ---------- GPIO -------- //
	// GPIOD Periph clock enable
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 8000e20:	2008      	movs	r0, #8
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000e22:	601a      	str	r2, [r3, #0]
 8000e24:	39ef      	subs	r1, #239	; 0xef
 8000e26:	f000 f9bb 	bl	80011a0 <RCC_AHB1PeriphClockCmd>

	// Configure PD12, PD13, PD14 and PD15 in output pushpull mode
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15;
 8000e2a:	f44f 4370 	mov.w	r3, #61440	; 0xf000
 8000e2e:	9302      	str	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8000e30:	2501      	movs	r5, #1
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8000e32:	2303      	movs	r3, #3
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 8000e34:	a902      	add	r1, sp, #8
 8000e36:	480d      	ldr	r0, [pc, #52]	; (8000e6c <usb1_init+0x74>)

	// Configure PD12, PD13, PD14 and PD15 in output pushpull mode
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8000e38:	f88d 300d 	strb.w	r3, [sp, #13]
	// GPIOD Periph clock enable
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);

	// Configure PD12, PD13, PD14 and PD15 in output pushpull mode
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8000e3c:	f88d 500c 	strb.w	r5, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000e40:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8000e44:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 8000e48:	f000 fbea 	bl	8001620 <GPIO_Init>

	// ------------- USB -------------- //
	USBD_Init(&USB_OTG_dev,
 8000e4c:	4b08      	ldr	r3, [pc, #32]	; (8000e70 <usb1_init+0x78>)
 8000e4e:	4809      	ldr	r0, [pc, #36]	; (8000e74 <usb1_init+0x7c>)
 8000e50:	9300      	str	r3, [sp, #0]
 8000e52:	4629      	mov	r1, r5
 8000e54:	4a08      	ldr	r2, [pc, #32]	; (8000e78 <usb1_init+0x80>)
 8000e56:	4b09      	ldr	r3, [pc, #36]	; (8000e7c <usb1_init+0x84>)
 8000e58:	f002 fa06 	bl	8003268 <USBD_Init>
	            &USR_desc,
	            &USBD_CDC_cb,
	            &USR_cb);

	return;
}
 8000e5c:	b005      	add	sp, #20
 8000e5e:	bd30      	pop	{r4, r5, pc}
 8000e60:	20000028 	.word	0x20000028
 8000e64:	e000e010 	.word	0xe000e010
 8000e68:	e000ed00 	.word	0xe000ed00
 8000e6c:	40020c00 	.word	0x40020c00
 8000e70:	2000003c 	.word	0x2000003c
 8000e74:	20000c34 	.word	0x20000c34
 8000e78:	20000070 	.word	0x20000070
 8000e7c:	200000f0 	.word	0x200000f0

08000e80 <timing_handler>:
/*
 * Called from systick handler.  Call his ticker.
 */
void timing_handler()
{
}
 8000e80:	4770      	bx	lr

08000e82 <_init>:

/*
 * Dummy function to avoid compiler error
 */
void _init() {}
 8000e82:	4770      	bx	lr

08000e84 <USBD_USR_Init>:
* @retval None
*/
void USBD_USR_Init(void)
{   

}
 8000e84:	4770      	bx	lr

08000e86 <USBD_USR_DeviceReset>:
     break;
 default:
     break;
     
 }
}
 8000e86:	4770      	bx	lr

08000e88 <USBD_USR_DeviceConfigured>:
* @param  None
* @retval Staus
*/
void USBD_USR_DeviceConfigured (void)
{
}
 8000e88:	4770      	bx	lr

08000e8a <USBD_USR_DeviceConnected>:
* @param  None
* @retval Staus
*/
void USBD_USR_DeviceConnected (void)
{
}
 8000e8a:	4770      	bx	lr

08000e8c <USBD_USR_DeviceDisconnected>:
* @param  None
* @retval Staus
*/
void USBD_USR_DeviceDisconnected (void)
{
}
 8000e8c:	4770      	bx	lr

08000e8e <USBD_USR_DeviceSuspended>:
* @retval None
*/
void USBD_USR_DeviceSuspended(void)
{
  /* Users can do their application actions here for the USB-Reset */
}
 8000e8e:	4770      	bx	lr

08000e90 <USBD_USR_DeviceResumed>:
* @retval None
*/
void USBD_USR_DeviceResumed(void)
{
  /* Users can do their application actions here for the USB-Reset */
}
 8000e90:	4770      	bx	lr
	...

08000e94 <USBD_USR_DeviceDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_DeviceDescriptor( uint8_t speed , uint16_t *length)
{
  *length = sizeof(USBD_DeviceDesc);
 8000e94:	2312      	movs	r3, #18
 8000e96:	800b      	strh	r3, [r1, #0]
  return USBD_DeviceDesc;
}
 8000e98:	4800      	ldr	r0, [pc, #0]	; (8000e9c <USBD_USR_DeviceDescriptor+0x8>)
 8000e9a:	4770      	bx	lr
 8000e9c:	20000058 	.word	0x20000058

08000ea0 <USBD_USR_LangIDStrDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_LangIDStrDescriptor( uint8_t speed , uint16_t *length)
{
  *length =  sizeof(USBD_LangIDDesc);  
 8000ea0:	2304      	movs	r3, #4
 8000ea2:	800b      	strh	r3, [r1, #0]
  return USBD_LangIDDesc;
}
 8000ea4:	4800      	ldr	r0, [pc, #0]	; (8000ea8 <USBD_USR_LangIDStrDescriptor+0x8>)
 8000ea6:	4770      	bx	lr
 8000ea8:	2000006a 	.word	0x2000006a

08000eac <USBD_USR_InterfaceStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_InterfaceStrDescriptor( uint8_t speed , uint16_t *length)
{
 8000eac:	460a      	mov	r2, r1
 8000eae:	b508      	push	{r3, lr}
  {
    USBD_GetString ((uint8_t*)USBD_INTERFACE_HS_STRING, USBD_StrDesc, length);
  }
  else
  {
    USBD_GetString ((uint8_t*)USBD_INTERFACE_FS_STRING, USBD_StrDesc, length);
 8000eb0:	4802      	ldr	r0, [pc, #8]	; (8000ebc <USBD_USR_InterfaceStrDescriptor+0x10>)
 8000eb2:	4903      	ldr	r1, [pc, #12]	; (8000ec0 <USBD_USR_InterfaceStrDescriptor+0x14>)
 8000eb4:	f002 fcb2 	bl	800381c <USBD_GetString>
  }
  return USBD_StrDesc;  
}
 8000eb8:	4801      	ldr	r0, [pc, #4]	; (8000ec0 <USBD_USR_InterfaceStrDescriptor+0x14>)
 8000eba:	bd08      	pop	{r3, pc}
 8000ebc:	0800ba90 	.word	0x0800ba90
 8000ec0:	20001ab0 	.word	0x20001ab0

08000ec4 <USBD_USR_ConfigStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_ConfigStrDescriptor( uint8_t speed , uint16_t *length)
{
 8000ec4:	460a      	mov	r2, r1
 8000ec6:	b508      	push	{r3, lr}
  {  
    USBD_GetString ((uint8_t*)USBD_CONFIGURATION_HS_STRING, USBD_StrDesc, length);
  }
  else
  {
    USBD_GetString ((uint8_t*)USBD_CONFIGURATION_FS_STRING, USBD_StrDesc, length);
 8000ec8:	4802      	ldr	r0, [pc, #8]	; (8000ed4 <USBD_USR_ConfigStrDescriptor+0x10>)
 8000eca:	4903      	ldr	r1, [pc, #12]	; (8000ed8 <USBD_USR_ConfigStrDescriptor+0x14>)
 8000ecc:	f002 fca6 	bl	800381c <USBD_GetString>
  }
  return USBD_StrDesc;  
}
 8000ed0:	4801      	ldr	r0, [pc, #4]	; (8000ed8 <USBD_USR_ConfigStrDescriptor+0x14>)
 8000ed2:	bd08      	pop	{r3, pc}
 8000ed4:	0800ba9e 	.word	0x0800ba9e
 8000ed8:	20001ab0 	.word	0x20001ab0

08000edc <USBD_USR_SerialStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_SerialStrDescriptor( uint8_t speed , uint16_t *length)
{
 8000edc:	b508      	push	{r3, lr}
 8000ede:	460a      	mov	r2, r1
  if(speed  == USB_OTG_SPEED_HIGH)
 8000ee0:	b908      	cbnz	r0, 8000ee6 <USBD_USR_SerialStrDescriptor+0xa>
  {    
    USBD_GetString ((uint8_t*)USBD_SERIALNUMBER_HS_STRING, USBD_StrDesc, length);
 8000ee2:	4804      	ldr	r0, [pc, #16]	; (8000ef4 <USBD_USR_SerialStrDescriptor+0x18>)
 8000ee4:	e000      	b.n	8000ee8 <USBD_USR_SerialStrDescriptor+0xc>
  }
  else
  {
    USBD_GetString ((uint8_t*)USBD_SERIALNUMBER_FS_STRING, USBD_StrDesc, length);
 8000ee6:	4804      	ldr	r0, [pc, #16]	; (8000ef8 <USBD_USR_SerialStrDescriptor+0x1c>)
 8000ee8:	4904      	ldr	r1, [pc, #16]	; (8000efc <USBD_USR_SerialStrDescriptor+0x20>)
 8000eea:	f002 fc97 	bl	800381c <USBD_GetString>
  }
  return USBD_StrDesc;
}
 8000eee:	4803      	ldr	r0, [pc, #12]	; (8000efc <USBD_USR_SerialStrDescriptor+0x20>)
 8000ef0:	bd08      	pop	{r3, pc}
 8000ef2:	bf00      	nop
 8000ef4:	0800baa9 	.word	0x0800baa9
 8000ef8:	0800bab6 	.word	0x0800bab6
 8000efc:	20001ab0 	.word	0x20001ab0

08000f00 <USBD_USR_ManufacturerStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_ManufacturerStrDescriptor( uint8_t speed , uint16_t *length)
{
 8000f00:	460a      	mov	r2, r1
 8000f02:	b508      	push	{r3, lr}
  USBD_GetString ((uint8_t*)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8000f04:	4802      	ldr	r0, [pc, #8]	; (8000f10 <USBD_USR_ManufacturerStrDescriptor+0x10>)
 8000f06:	4903      	ldr	r1, [pc, #12]	; (8000f14 <USBD_USR_ManufacturerStrDescriptor+0x14>)
 8000f08:	f002 fc88 	bl	800381c <USBD_GetString>
  return USBD_StrDesc;
}
 8000f0c:	4801      	ldr	r0, [pc, #4]	; (8000f14 <USBD_USR_ManufacturerStrDescriptor+0x14>)
 8000f0e:	bd08      	pop	{r3, pc}
 8000f10:	0800bac3 	.word	0x0800bac3
 8000f14:	20001ab0 	.word	0x20001ab0

08000f18 <USBD_USR_ProductStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_ProductStrDescriptor( uint8_t speed , uint16_t *length)
{
 8000f18:	b508      	push	{r3, lr}
 8000f1a:	460a      	mov	r2, r1
 
  
  if(speed == 0)
 8000f1c:	b908      	cbnz	r0, 8000f22 <USBD_USR_ProductStrDescriptor+0xa>
  {   
    USBD_GetString ((uint8_t*)USBD_PRODUCT_HS_STRING, USBD_StrDesc, length);
 8000f1e:	4804      	ldr	r0, [pc, #16]	; (8000f30 <USBD_USR_ProductStrDescriptor+0x18>)
 8000f20:	e000      	b.n	8000f24 <USBD_USR_ProductStrDescriptor+0xc>
  }
  else
  {
    USBD_GetString ((uint8_t*)USBD_PRODUCT_FS_STRING, USBD_StrDesc, length);
 8000f22:	4804      	ldr	r0, [pc, #16]	; (8000f34 <USBD_USR_ProductStrDescriptor+0x1c>)
 8000f24:	4904      	ldr	r1, [pc, #16]	; (8000f38 <USBD_USR_ProductStrDescriptor+0x20>)
 8000f26:	f002 fc79 	bl	800381c <USBD_GetString>
  }
  return USBD_StrDesc;
}
 8000f2a:	4803      	ldr	r0, [pc, #12]	; (8000f38 <USBD_USR_ProductStrDescriptor+0x20>)
 8000f2c:	bd08      	pop	{r3, pc}
 8000f2e:	bf00      	nop
 8000f30:	0800bad6 	.word	0x0800bad6
 8000f34:	0800baf7 	.word	0x0800baf7
 8000f38:	20001ab0 	.word	0x20001ab0

08000f3c <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000f3c:	4b0a      	ldr	r3, [pc, #40]	; (8000f68 <RCC_DeInit+0x2c>)
 8000f3e:	6819      	ldr	r1, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000f40:	2200      	movs	r2, #0
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000f42:	f041 0001 	orr.w	r0, r1, #1
 8000f46:	6018      	str	r0, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000f48:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000f4a:	6819      	ldr	r1, [r3, #0]
 8000f4c:	f021 7c84 	bic.w	ip, r1, #17301504	; 0x1080000

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8000f50:	4906      	ldr	r1, [pc, #24]	; (8000f6c <RCC_DeInit+0x30>)

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000f52:	f42c 3080 	bic.w	r0, ip, #65536	; 0x10000
 8000f56:	6018      	str	r0, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8000f58:	6059      	str	r1, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000f5a:	6818      	ldr	r0, [r3, #0]
 8000f5c:	f420 2180 	bic.w	r1, r0, #262144	; 0x40000
 8000f60:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8000f62:	60da      	str	r2, [r3, #12]
}
 8000f64:	4770      	bx	lr
 8000f66:	bf00      	nop
 8000f68:	40023800 	.word	0x40023800
 8000f6c:	24003010 	.word	0x24003010

08000f70 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
 8000f70:	4b02      	ldr	r3, [pc, #8]	; (8000f7c <RCC_HSEConfig+0xc>)
 8000f72:	2200      	movs	r2, #0
 8000f74:	701a      	strb	r2, [r3, #0]

  /* Set the new HSE configuration -------------------------------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
 8000f76:	7018      	strb	r0, [r3, #0]
}
 8000f78:	4770      	bx	lr
 8000f7a:	bf00      	nop
 8000f7c:	40023802 	.word	0x40023802

08000f80 <RCC_AdjustHSICalibrationValue>:
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));

  tmpreg = RCC->CR;
 8000f80:	4b03      	ldr	r3, [pc, #12]	; (8000f90 <RCC_AdjustHSICalibrationValue+0x10>)
 8000f82:	681a      	ldr	r2, [r3, #0]

  /* Clear HSITRIM[4:0] bits */
  tmpreg &= ~RCC_CR_HSITRIM;
 8000f84:	f022 01f8 	bic.w	r1, r2, #248	; 0xf8

  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 8000f88:	ea41 02c0 	orr.w	r2, r1, r0, lsl #3

  /* Store the new value */
  RCC->CR = tmpreg;
 8000f8c:	601a      	str	r2, [r3, #0]
}
 8000f8e:	4770      	bx	lr
 8000f90:	40023800 	.word	0x40023800

08000f94 <RCC_HSICmd>:
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 8000f94:	4b01      	ldr	r3, [pc, #4]	; (8000f9c <RCC_HSICmd+0x8>)
 8000f96:	6018      	str	r0, [r3, #0]
}
 8000f98:	4770      	bx	lr
 8000f9a:	bf00      	nop
 8000f9c:	42470000 	.word	0x42470000

08000fa0 <RCC_LSEConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8000fa0:	4b06      	ldr	r3, [pc, #24]	; (8000fbc <RCC_LSEConfig+0x1c>)
 8000fa2:	2200      	movs	r2, #0

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
 8000fa4:	2801      	cmp	r0, #1
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8000fa6:	701a      	strb	r2, [r3, #0]

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8000fa8:	701a      	strb	r2, [r3, #0]

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
 8000faa:	d004      	beq.n	8000fb6 <RCC_LSEConfig+0x16>
 8000fac:	2804      	cmp	r0, #4
 8000fae:	d101      	bne.n	8000fb4 <RCC_LSEConfig+0x14>
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
      break;
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 8000fb0:	2005      	movs	r0, #5
 8000fb2:	7018      	strb	r0, [r3, #0]
 8000fb4:	4770      	bx	lr
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 8000fb6:	7018      	strb	r0, [r3, #0]
      break;
 8000fb8:	4770      	bx	lr
 8000fba:	bf00      	nop
 8000fbc:	40023870 	.word	0x40023870

08000fc0 <RCC_LSICmd>:
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 8000fc0:	4b01      	ldr	r3, [pc, #4]	; (8000fc8 <RCC_LSICmd+0x8>)
 8000fc2:	6018      	str	r0, [r3, #0]
}
 8000fc4:	4770      	bx	lr
 8000fc6:	bf00      	nop
 8000fc8:	42470e80 	.word	0x42470e80

08000fcc <RCC_PLLConfig>:
  assert_param(IS_RCC_PLLM_VALUE(PLLM));
  assert_param(IS_RCC_PLLN_VALUE(PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLP));
  assert_param(IS_RCC_PLLQ_VALUE(PLLQ));

  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
 8000fcc:	ea41 0000 	orr.w	r0, r1, r0
 8000fd0:	ea40 1c82 	orr.w	ip, r0, r2, lsl #6
 8000fd4:	9a00      	ldr	r2, [sp, #0]
 8000fd6:	085b      	lsrs	r3, r3, #1
 8000fd8:	1e59      	subs	r1, r3, #1
 8000fda:	ea4c 6002 	orr.w	r0, ip, r2, lsl #24
 8000fde:	4b02      	ldr	r3, [pc, #8]	; (8000fe8 <RCC_PLLConfig+0x1c>)
 8000fe0:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
 8000fe4:	605a      	str	r2, [r3, #4]
                 (PLLQ << 24);
}
 8000fe6:	4770      	bx	lr
 8000fe8:	40023800 	.word	0x40023800

08000fec <RCC_PLLCmd>:
  */
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8000fec:	4b01      	ldr	r3, [pc, #4]	; (8000ff4 <RCC_PLLCmd+0x8>)
 8000fee:	6018      	str	r0, [r3, #0]
}
 8000ff0:	4770      	bx	lr
 8000ff2:	bf00      	nop
 8000ff4:	42470060 	.word	0x42470060

08000ff8 <RCC_PLLI2SConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
  assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));

  RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
 8000ff8:	0180      	lsls	r0, r0, #6
 8000ffa:	4b03      	ldr	r3, [pc, #12]	; (8001008 <RCC_PLLI2SConfig+0x10>)
 8000ffc:	ea40 7101 	orr.w	r1, r0, r1, lsl #28
 8001000:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
}
 8001004:	4770      	bx	lr
 8001006:	bf00      	nop
 8001008:	40023800 	.word	0x40023800

0800100c <RCC_PLLI2SCmd>:
  */
void RCC_PLLI2SCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
 800100c:	4b01      	ldr	r3, [pc, #4]	; (8001014 <RCC_PLLI2SCmd+0x8>)
 800100e:	6018      	str	r0, [r3, #0]
}
 8001010:	4770      	bx	lr
 8001012:	bf00      	nop
 8001014:	42470068 	.word	0x42470068

08001018 <RCC_ClockSecuritySystemCmd>:
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 8001018:	4b01      	ldr	r3, [pc, #4]	; (8001020 <RCC_ClockSecuritySystemCmd+0x8>)
 800101a:	6018      	str	r0, [r3, #0]
}
 800101c:	4770      	bx	lr
 800101e:	bf00      	nop
 8001020:	4247004c 	.word	0x4247004c

08001024 <RCC_MCO1Config>:
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
  assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  

  tmpreg = RCC->CFGR;
 8001024:	4b04      	ldr	r3, [pc, #16]	; (8001038 <RCC_MCO1Config+0x14>)
 8001026:	689a      	ldr	r2, [r3, #8]

  /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
  tmpreg &= CFGR_MCO1_RESET_MASK;
 8001028:	f022 6cec 	bic.w	ip, r2, #123731968	; 0x7600000

  /* Select MCO1 clock source and prescaler */
  tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
 800102c:	ea40 000c 	orr.w	r0, r0, ip
 8001030:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 8001034:	609a      	str	r2, [r3, #8]
}
 8001036:	4770      	bx	lr
 8001038:	40023800 	.word	0x40023800

0800103c <RCC_MCO2Config>:
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
  assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
  
  tmpreg = RCC->CFGR;
 800103c:	4b04      	ldr	r3, [pc, #16]	; (8001050 <RCC_MCO2Config+0x14>)
 800103e:	689a      	ldr	r2, [r3, #8]
  
  /* Clear MCO2 and MCO2PRE[2:0] bits */
  tmpreg &= CFGR_MCO2_RESET_MASK;
 8001040:	f022 4c78 	bic.w	ip, r2, #4160749568	; 0xf8000000

  /* Select MCO2 clock source and prescaler */
  tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
 8001044:	ea40 000c 	orr.w	r0, r0, ip
 8001048:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 800104c:	609a      	str	r2, [r3, #8]
}
 800104e:	4770      	bx	lr
 8001050:	40023800 	.word	0x40023800

08001054 <RCC_SYSCLKConfig>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));

  tmpreg = RCC->CFGR;
 8001054:	4b03      	ldr	r3, [pc, #12]	; (8001064 <RCC_SYSCLKConfig+0x10>)
 8001056:	689a      	ldr	r2, [r3, #8]

  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
 8001058:	f022 0103 	bic.w	r1, r2, #3

  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 800105c:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8001060:	609a      	str	r2, [r3, #8]
}
 8001062:	4770      	bx	lr
 8001064:	40023800 	.word	0x40023800

08001068 <RCC_GetSYSCLKSource>:
  *              - 0x04: HSE used as system clock
  *              - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 8001068:	4b02      	ldr	r3, [pc, #8]	; (8001074 <RCC_GetSYSCLKSource+0xc>)
 800106a:	6898      	ldr	r0, [r3, #8]
}
 800106c:	f000 000c 	and.w	r0, r0, #12
 8001070:	4770      	bx	lr
 8001072:	bf00      	nop
 8001074:	40023800 	.word	0x40023800

08001078 <RCC_HCLKConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));

  tmpreg = RCC->CFGR;
 8001078:	4b03      	ldr	r3, [pc, #12]	; (8001088 <RCC_HCLKConfig+0x10>)
 800107a:	689a      	ldr	r2, [r3, #8]

  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 800107c:	f022 01f0 	bic.w	r1, r2, #240	; 0xf0

  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8001080:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8001084:	609a      	str	r2, [r3, #8]
}
 8001086:	4770      	bx	lr
 8001088:	40023800 	.word	0x40023800

0800108c <RCC_PCLK1Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 800108c:	4b03      	ldr	r3, [pc, #12]	; (800109c <RCC_PCLK1Config+0x10>)
 800108e:	689a      	ldr	r2, [r3, #8]

  /* Clear PPRE1[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE1;
 8001090:	f422 51e0 	bic.w	r1, r2, #7168	; 0x1c00

  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 8001094:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8001098:	609a      	str	r2, [r3, #8]
}
 800109a:	4770      	bx	lr
 800109c:	40023800 	.word	0x40023800

080010a0 <RCC_PCLK2Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 80010a0:	4b03      	ldr	r3, [pc, #12]	; (80010b0 <RCC_PCLK2Config+0x10>)
 80010a2:	689a      	ldr	r2, [r3, #8]

  /* Clear PPRE2[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE2;
 80010a4:	f422 4160 	bic.w	r1, r2, #57344	; 0xe000

  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 80010a8:	ea41 02c0 	orr.w	r2, r1, r0, lsl #3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80010ac:	609a      	str	r2, [r3, #8]
}
 80010ae:	4770      	bx	lr
 80010b0:	40023800 	.word	0x40023800

080010b4 <RCC_GetClocksFreq>:
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 80010b4:	4a20      	ldr	r2, [pc, #128]	; (8001138 <RCC_GetClocksFreq+0x84>)
 80010b6:	6893      	ldr	r3, [r2, #8]
 80010b8:	f003 030c 	and.w	r3, r3, #12

  switch (tmp)
 80010bc:	2b04      	cmp	r3, #4
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 80010be:	b410      	push	{r4}
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;

  switch (tmp)
 80010c0:	d01d      	beq.n	80010fe <RCC_GetClocksFreq+0x4a>
 80010c2:	2b08      	cmp	r3, #8
 80010c4:	d01e      	beq.n	8001104 <RCC_GetClocksFreq+0x50>

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
      break;
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 80010c6:	4b1d      	ldr	r3, [pc, #116]	; (800113c <RCC_GetClocksFreq+0x88>)
 80010c8:	6003      	str	r3, [r0, #0]
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 80010ca:	491b      	ldr	r1, [pc, #108]	; (8001138 <RCC_GetClocksFreq+0x84>)
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 80010cc:	4a1c      	ldr	r2, [pc, #112]	; (8001140 <RCC_GetClocksFreq+0x8c>)
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 80010ce:	688c      	ldr	r4, [r1, #8]
  tmp = tmp >> 4;
 80010d0:	f3c4 1c03 	ubfx	ip, r4, #4, #4
  presc = APBAHBPrescTable[tmp];
 80010d4:	f812 400c 	ldrb.w	r4, [r2, ip]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 80010d8:	40e3      	lsrs	r3, r4
 80010da:	6043      	str	r3, [r0, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 80010dc:	688c      	ldr	r4, [r1, #8]
  tmp = tmp >> 10;
 80010de:	f3c4 2c82 	ubfx	ip, r4, #10, #3
  presc = APBAHBPrescTable[tmp];
 80010e2:	f812 400c 	ldrb.w	r4, [r2, ip]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 80010e6:	fa33 f404 	lsrs.w	r4, r3, r4
 80010ea:	6084      	str	r4, [r0, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 80010ec:	6889      	ldr	r1, [r1, #8]
  tmp = tmp >> 13;
 80010ee:	f3c1 3c42 	ubfx	ip, r1, #13, #3
  presc = APBAHBPrescTable[tmp];
 80010f2:	f812 200c 	ldrb.w	r2, [r2, ip]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 80010f6:	40d3      	lsrs	r3, r2
 80010f8:	60c3      	str	r3, [r0, #12]
}
 80010fa:	bc10      	pop	{r4}
 80010fc:	4770      	bx	lr
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 80010fe:	4b11      	ldr	r3, [pc, #68]	; (8001144 <RCC_GetClocksFreq+0x90>)
 8001100:	6003      	str	r3, [r0, #0]
      break;
 8001102:	e7e2      	b.n	80010ca <RCC_GetClocksFreq+0x16>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8001104:	6854      	ldr	r4, [r2, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001106:	6851      	ldr	r1, [r2, #4]
      
      if (pllsource != 0)
 8001108:	f414 0f80 	tst.w	r4, #4194304	; 0x400000
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 800110c:	6854      	ldr	r4, [r2, #4]
 800110e:	bf14      	ite	ne
 8001110:	4b0c      	ldrne	r3, [pc, #48]	; (8001144 <RCC_GetClocksFreq+0x90>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8001112:	4b0a      	ldreq	r3, [pc, #40]	; (800113c <RCC_GetClocksFreq+0x88>)
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
      
      if (pllsource != 0)
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8001114:	f3c4 1288 	ubfx	r2, r4, #6, #9

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001118:	f001 013f 	and.w	r1, r1, #63	; 0x3f
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 800111c:	4c06      	ldr	r4, [pc, #24]	; (8001138 <RCC_GetClocksFreq+0x84>)
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 800111e:	fbb3 fcf1 	udiv	ip, r3, r1
 8001122:	fb0c f102 	mul.w	r1, ip, r2
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8001126:	6862      	ldr	r2, [r4, #4]
 8001128:	f3c2 4301 	ubfx	r3, r2, #16, #2
 800112c:	1c5c      	adds	r4, r3, #1
 800112e:	0062      	lsls	r2, r4, #1
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 8001130:	fbb1 f3f2 	udiv	r3, r1, r2
 8001134:	6003      	str	r3, [r0, #0]
      break;
 8001136:	e7c8      	b.n	80010ca <RCC_GetClocksFreq+0x16>
 8001138:	40023800 	.word	0x40023800
 800113c:	00f42400 	.word	0x00f42400
 8001140:	20000098 	.word	0x20000098
 8001144:	017d7840 	.word	0x017d7840

08001148 <RCC_RTCCLKConfig>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
 8001148:	f400 7340 	and.w	r3, r0, #768	; 0x300
 800114c:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8001150:	d10a      	bne.n	8001168 <RCC_RTCCLKConfig+0x20>
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;
 8001152:	4b09      	ldr	r3, [pc, #36]	; (8001178 <RCC_RTCCLKConfig+0x30>)
 8001154:	6899      	ldr	r1, [r3, #8]

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 8001156:	f020 4270 	bic.w	r2, r0, #4026531840	; 0xf0000000
  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;
 800115a:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 800115e:	f422 7c40 	bic.w	ip, r2, #768	; 0x300
 8001162:	ea4c 0201 	orr.w	r2, ip, r1

    /* Store the new value */
    RCC->CFGR = tmpreg;
 8001166:	609a      	str	r2, [r3, #8]
  }
    
  /* Select the RTC clock source */
  RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
 8001168:	4b03      	ldr	r3, [pc, #12]	; (8001178 <RCC_RTCCLKConfig+0x30>)
 800116a:	0500      	lsls	r0, r0, #20
 800116c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800116e:	0d01      	lsrs	r1, r0, #20
 8001170:	ea41 0002 	orr.w	r0, r1, r2
 8001174:	6718      	str	r0, [r3, #112]	; 0x70
}
 8001176:	4770      	bx	lr
 8001178:	40023800 	.word	0x40023800

0800117c <RCC_RTCCLKCmd>:
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 800117c:	4b01      	ldr	r3, [pc, #4]	; (8001184 <RCC_RTCCLKCmd+0x8>)
 800117e:	6018      	str	r0, [r3, #0]
}
 8001180:	4770      	bx	lr
 8001182:	bf00      	nop
 8001184:	42470e3c 	.word	0x42470e3c

08001188 <RCC_BackupResetCmd>:
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 8001188:	4b01      	ldr	r3, [pc, #4]	; (8001190 <RCC_BackupResetCmd+0x8>)
 800118a:	6018      	str	r0, [r3, #0]
}
 800118c:	4770      	bx	lr
 800118e:	bf00      	nop
 8001190:	42470e40 	.word	0x42470e40

08001194 <RCC_I2SCLKConfig>:
void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));

  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
 8001194:	4b01      	ldr	r3, [pc, #4]	; (800119c <RCC_I2SCLKConfig+0x8>)
 8001196:	6018      	str	r0, [r3, #0]
}
 8001198:	4770      	bx	lr
 800119a:	bf00      	nop
 800119c:	4247015c 	.word	0x4247015c

080011a0 <RCC_AHB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80011a0:	b929      	cbnz	r1, 80011ae <RCC_AHB1PeriphClockCmd+0xe>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 80011a2:	4b05      	ldr	r3, [pc, #20]	; (80011b8 <RCC_AHB1PeriphClockCmd+0x18>)
 80011a4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80011a6:	ea22 0100 	bic.w	r1, r2, r0
 80011aa:	6319      	str	r1, [r3, #48]	; 0x30
 80011ac:	4770      	bx	lr
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 80011ae:	4b02      	ldr	r3, [pc, #8]	; (80011b8 <RCC_AHB1PeriphClockCmd+0x18>)
 80011b0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80011b2:	4310      	orrs	r0, r2
 80011b4:	6318      	str	r0, [r3, #48]	; 0x30
 80011b6:	4770      	bx	lr
 80011b8:	40023800 	.word	0x40023800

080011bc <RCC_AHB2PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80011bc:	b929      	cbnz	r1, 80011ca <RCC_AHB2PeriphClockCmd+0xe>
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2ENR &= ~RCC_AHB2Periph;
 80011be:	4b05      	ldr	r3, [pc, #20]	; (80011d4 <RCC_AHB2PeriphClockCmd+0x18>)
 80011c0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80011c2:	ea22 0100 	bic.w	r1, r2, r0
 80011c6:	6359      	str	r1, [r3, #52]	; 0x34
 80011c8:	4770      	bx	lr
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
 80011ca:	4b02      	ldr	r3, [pc, #8]	; (80011d4 <RCC_AHB2PeriphClockCmd+0x18>)
 80011cc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80011ce:	4310      	orrs	r0, r2
 80011d0:	6358      	str	r0, [r3, #52]	; 0x34
 80011d2:	4770      	bx	lr
 80011d4:	40023800 	.word	0x40023800

080011d8 <RCC_AHB3PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80011d8:	b929      	cbnz	r1, 80011e6 <RCC_AHB3PeriphClockCmd+0xe>
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3ENR &= ~RCC_AHB3Periph;
 80011da:	4b05      	ldr	r3, [pc, #20]	; (80011f0 <RCC_AHB3PeriphClockCmd+0x18>)
 80011dc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80011de:	ea22 0100 	bic.w	r1, r2, r0
 80011e2:	6399      	str	r1, [r3, #56]	; 0x38
 80011e4:	4770      	bx	lr
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
 80011e6:	4b02      	ldr	r3, [pc, #8]	; (80011f0 <RCC_AHB3PeriphClockCmd+0x18>)
 80011e8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80011ea:	4310      	orrs	r0, r2
 80011ec:	6398      	str	r0, [r3, #56]	; 0x38
 80011ee:	4770      	bx	lr
 80011f0:	40023800 	.word	0x40023800

080011f4 <RCC_APB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80011f4:	b929      	cbnz	r1, 8001202 <RCC_APB1PeriphClockCmd+0xe>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 80011f6:	4b05      	ldr	r3, [pc, #20]	; (800120c <RCC_APB1PeriphClockCmd+0x18>)
 80011f8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80011fa:	ea22 0100 	bic.w	r1, r2, r0
 80011fe:	6419      	str	r1, [r3, #64]	; 0x40
 8001200:	4770      	bx	lr
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8001202:	4b02      	ldr	r3, [pc, #8]	; (800120c <RCC_APB1PeriphClockCmd+0x18>)
 8001204:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001206:	4310      	orrs	r0, r2
 8001208:	6418      	str	r0, [r3, #64]	; 0x40
 800120a:	4770      	bx	lr
 800120c:	40023800 	.word	0x40023800

08001210 <RCC_APB2PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001210:	b929      	cbnz	r1, 800121e <RCC_APB2PeriphClockCmd+0xe>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8001212:	4b05      	ldr	r3, [pc, #20]	; (8001228 <RCC_APB2PeriphClockCmd+0x18>)
 8001214:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001216:	ea22 0100 	bic.w	r1, r2, r0
 800121a:	6459      	str	r1, [r3, #68]	; 0x44
 800121c:	4770      	bx	lr
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 800121e:	4b02      	ldr	r3, [pc, #8]	; (8001228 <RCC_APB2PeriphClockCmd+0x18>)
 8001220:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001222:	4310      	orrs	r0, r2
 8001224:	6458      	str	r0, [r3, #68]	; 0x44
 8001226:	4770      	bx	lr
 8001228:	40023800 	.word	0x40023800

0800122c <RCC_AHB1PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800122c:	b929      	cbnz	r1, 800123a <RCC_AHB1PeriphResetCmd+0xe>
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
 800122e:	4b05      	ldr	r3, [pc, #20]	; (8001244 <RCC_AHB1PeriphResetCmd+0x18>)
 8001230:	691a      	ldr	r2, [r3, #16]
 8001232:	ea22 0100 	bic.w	r1, r2, r0
 8001236:	6119      	str	r1, [r3, #16]
 8001238:	4770      	bx	lr
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 800123a:	4b02      	ldr	r3, [pc, #8]	; (8001244 <RCC_AHB1PeriphResetCmd+0x18>)
 800123c:	691a      	ldr	r2, [r3, #16]
 800123e:	4310      	orrs	r0, r2
 8001240:	6118      	str	r0, [r3, #16]
 8001242:	4770      	bx	lr
 8001244:	40023800 	.word	0x40023800

08001248 <RCC_AHB2PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001248:	b929      	cbnz	r1, 8001256 <RCC_AHB2PeriphResetCmd+0xe>
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2RSTR &= ~RCC_AHB2Periph;
 800124a:	4b05      	ldr	r3, [pc, #20]	; (8001260 <RCC_AHB2PeriphResetCmd+0x18>)
 800124c:	695a      	ldr	r2, [r3, #20]
 800124e:	ea22 0100 	bic.w	r1, r2, r0
 8001252:	6159      	str	r1, [r3, #20]
 8001254:	4770      	bx	lr
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
 8001256:	4b02      	ldr	r3, [pc, #8]	; (8001260 <RCC_AHB2PeriphResetCmd+0x18>)
 8001258:	695a      	ldr	r2, [r3, #20]
 800125a:	4310      	orrs	r0, r2
 800125c:	6158      	str	r0, [r3, #20]
 800125e:	4770      	bx	lr
 8001260:	40023800 	.word	0x40023800

08001264 <RCC_AHB3PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001264:	b929      	cbnz	r1, 8001272 <RCC_AHB3PeriphResetCmd+0xe>
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3RSTR &= ~RCC_AHB3Periph;
 8001266:	4b05      	ldr	r3, [pc, #20]	; (800127c <RCC_AHB3PeriphResetCmd+0x18>)
 8001268:	699a      	ldr	r2, [r3, #24]
 800126a:	ea22 0100 	bic.w	r1, r2, r0
 800126e:	6199      	str	r1, [r3, #24]
 8001270:	4770      	bx	lr
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
 8001272:	4b02      	ldr	r3, [pc, #8]	; (800127c <RCC_AHB3PeriphResetCmd+0x18>)
 8001274:	699a      	ldr	r2, [r3, #24]
 8001276:	4310      	orrs	r0, r2
 8001278:	6198      	str	r0, [r3, #24]
 800127a:	4770      	bx	lr
 800127c:	40023800 	.word	0x40023800

08001280 <RCC_APB1PeriphResetCmd>:
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001280:	b929      	cbnz	r1, 800128e <RCC_APB1PeriphResetCmd+0xe>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 8001282:	4b05      	ldr	r3, [pc, #20]	; (8001298 <RCC_APB1PeriphResetCmd+0x18>)
 8001284:	6a1a      	ldr	r2, [r3, #32]
 8001286:	ea22 0100 	bic.w	r1, r2, r0
 800128a:	6219      	str	r1, [r3, #32]
 800128c:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 800128e:	4b02      	ldr	r3, [pc, #8]	; (8001298 <RCC_APB1PeriphResetCmd+0x18>)
 8001290:	6a1a      	ldr	r2, [r3, #32]
 8001292:	4310      	orrs	r0, r2
 8001294:	6218      	str	r0, [r3, #32]
 8001296:	4770      	bx	lr
 8001298:	40023800 	.word	0x40023800

0800129c <RCC_APB2PeriphResetCmd>:
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800129c:	b929      	cbnz	r1, 80012aa <RCC_APB2PeriphResetCmd+0xe>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 800129e:	4b05      	ldr	r3, [pc, #20]	; (80012b4 <RCC_APB2PeriphResetCmd+0x18>)
 80012a0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80012a2:	ea22 0100 	bic.w	r1, r2, r0
 80012a6:	6259      	str	r1, [r3, #36]	; 0x24
 80012a8:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 80012aa:	4b02      	ldr	r3, [pc, #8]	; (80012b4 <RCC_APB2PeriphResetCmd+0x18>)
 80012ac:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80012ae:	4310      	orrs	r0, r2
 80012b0:	6258      	str	r0, [r3, #36]	; 0x24
 80012b2:	4770      	bx	lr
 80012b4:	40023800 	.word	0x40023800

080012b8 <RCC_AHB1PeriphClockLPModeCmd>:
void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80012b8:	b929      	cbnz	r1, 80012c6 <RCC_AHB1PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1LPENR &= ~RCC_AHB1Periph;
 80012ba:	4b05      	ldr	r3, [pc, #20]	; (80012d0 <RCC_AHB1PeriphClockLPModeCmd+0x18>)
 80012bc:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80012be:	ea22 0100 	bic.w	r1, r2, r0
 80012c2:	6519      	str	r1, [r3, #80]	; 0x50
 80012c4:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
 80012c6:	4b02      	ldr	r3, [pc, #8]	; (80012d0 <RCC_AHB1PeriphClockLPModeCmd+0x18>)
 80012c8:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80012ca:	4310      	orrs	r0, r2
 80012cc:	6518      	str	r0, [r3, #80]	; 0x50
 80012ce:	4770      	bx	lr
 80012d0:	40023800 	.word	0x40023800

080012d4 <RCC_AHB2PeriphClockLPModeCmd>:
void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80012d4:	b929      	cbnz	r1, 80012e2 <RCC_AHB2PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2LPENR &= ~RCC_AHB2Periph;
 80012d6:	4b05      	ldr	r3, [pc, #20]	; (80012ec <RCC_AHB2PeriphClockLPModeCmd+0x18>)
 80012d8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80012da:	ea22 0100 	bic.w	r1, r2, r0
 80012de:	6559      	str	r1, [r3, #84]	; 0x54
 80012e0:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
 80012e2:	4b02      	ldr	r3, [pc, #8]	; (80012ec <RCC_AHB2PeriphClockLPModeCmd+0x18>)
 80012e4:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80012e6:	4310      	orrs	r0, r2
 80012e8:	6558      	str	r0, [r3, #84]	; 0x54
 80012ea:	4770      	bx	lr
 80012ec:	40023800 	.word	0x40023800

080012f0 <RCC_AHB3PeriphClockLPModeCmd>:
void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80012f0:	b929      	cbnz	r1, 80012fe <RCC_AHB3PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3LPENR &= ~RCC_AHB3Periph;
 80012f2:	4b05      	ldr	r3, [pc, #20]	; (8001308 <RCC_AHB3PeriphClockLPModeCmd+0x18>)
 80012f4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80012f6:	ea22 0100 	bic.w	r1, r2, r0
 80012fa:	6599      	str	r1, [r3, #88]	; 0x58
 80012fc:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
 80012fe:	4b02      	ldr	r3, [pc, #8]	; (8001308 <RCC_AHB3PeriphClockLPModeCmd+0x18>)
 8001300:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001302:	4310      	orrs	r0, r2
 8001304:	6598      	str	r0, [r3, #88]	; 0x58
 8001306:	4770      	bx	lr
 8001308:	40023800 	.word	0x40023800

0800130c <RCC_APB1PeriphClockLPModeCmd>:
void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800130c:	b929      	cbnz	r1, 800131a <RCC_APB1PeriphClockLPModeCmd+0xe>
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1LPENR &= ~RCC_APB1Periph;
 800130e:	4b05      	ldr	r3, [pc, #20]	; (8001324 <RCC_APB1PeriphClockLPModeCmd+0x18>)
 8001310:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001312:	ea22 0100 	bic.w	r1, r2, r0
 8001316:	6619      	str	r1, [r3, #96]	; 0x60
 8001318:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
 800131a:	4b02      	ldr	r3, [pc, #8]	; (8001324 <RCC_APB1PeriphClockLPModeCmd+0x18>)
 800131c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800131e:	4310      	orrs	r0, r2
 8001320:	6618      	str	r0, [r3, #96]	; 0x60
 8001322:	4770      	bx	lr
 8001324:	40023800 	.word	0x40023800

08001328 <RCC_APB2PeriphClockLPModeCmd>:
void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001328:	b929      	cbnz	r1, 8001336 <RCC_APB2PeriphClockLPModeCmd+0xe>
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2LPENR &= ~RCC_APB2Periph;
 800132a:	4b05      	ldr	r3, [pc, #20]	; (8001340 <RCC_APB2PeriphClockLPModeCmd+0x18>)
 800132c:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800132e:	ea22 0100 	bic.w	r1, r2, r0
 8001332:	6659      	str	r1, [r3, #100]	; 0x64
 8001334:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
 8001336:	4b02      	ldr	r3, [pc, #8]	; (8001340 <RCC_APB2PeriphClockLPModeCmd+0x18>)
 8001338:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800133a:	4310      	orrs	r0, r2
 800133c:	6658      	str	r0, [r3, #100]	; 0x64
 800133e:	4770      	bx	lr
 8001340:	40023800 	.word	0x40023800

08001344 <RCC_ITConfig>:
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001344:	b931      	cbnz	r1, 8001354 <RCC_ITConfig+0x10>
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
  }
  else
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 8001346:	4b06      	ldr	r3, [pc, #24]	; (8001360 <RCC_ITConfig+0x1c>)
 8001348:	f893 c000 	ldrb.w	ip, [r3]
 800134c:	ea2c 0100 	bic.w	r1, ip, r0
 8001350:	7019      	strb	r1, [r3, #0]
 8001352:	4770      	bx	lr
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 8001354:	4b02      	ldr	r3, [pc, #8]	; (8001360 <RCC_ITConfig+0x1c>)
 8001356:	781a      	ldrb	r2, [r3, #0]
 8001358:	4310      	orrs	r0, r2
 800135a:	7018      	strb	r0, [r3, #0]
 800135c:	4770      	bx	lr
 800135e:	bf00      	nop
 8001360:	4002380d 	.word	0x4002380d

08001364 <RCC_GetFlagStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 8001364:	0943      	lsrs	r3, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 8001366:	2b01      	cmp	r3, #1
 8001368:	d00b      	beq.n	8001382 <RCC_GetFlagStatus+0x1e>
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 800136a:	2b02      	cmp	r3, #2
  {
    statusreg = RCC->BDCR;
 800136c:	4b09      	ldr	r3, [pc, #36]	; (8001394 <RCC_GetFlagStatus+0x30>)
 800136e:	bf0c      	ite	eq
 8001370:	6f1b      	ldreq	r3, [r3, #112]	; 0x70
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8001372:	6f5b      	ldrne	r3, [r3, #116]	; 0x74
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
 8001374:	f000 011f 	and.w	r1, r0, #31
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8001378:	fa33 f001 	lsrs.w	r0, r3, r1
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 800137c:	f000 0001 	and.w	r0, r0, #1
 8001380:	4770      	bx	lr

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 8001382:	4b04      	ldr	r3, [pc, #16]	; (8001394 <RCC_GetFlagStatus+0x30>)
 8001384:	681b      	ldr	r3, [r3, #0]
  {
    statusreg = RCC->CSR;
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
 8001386:	f000 011f 	and.w	r1, r0, #31
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 800138a:	fa33 f001 	lsrs.w	r0, r3, r1
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 800138e:	f000 0001 	and.w	r0, r0, #1
 8001392:	4770      	bx	lr
 8001394:	40023800 	.word	0x40023800

08001398 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 8001398:	b500      	push	{lr}
 800139a:	b083      	sub	sp, #12
  __IO uint32_t startupcounter = 0;
 800139c:	2300      	movs	r3, #0
 800139e:	9301      	str	r3, [sp, #4]
 80013a0:	e000      	b.n	80013a4 <RCC_WaitForHSEStartUp+0xc>
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    startupcounter++;
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 80013a2:	b948      	cbnz	r0, 80013b8 <RCC_WaitForHSEStartUp+0x20>
  ErrorStatus status = ERROR;
  FlagStatus hsestatus = RESET;
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 80013a4:	2031      	movs	r0, #49	; 0x31
 80013a6:	f7ff ffdd 	bl	8001364 <RCC_GetFlagStatus>
    startupcounter++;
 80013aa:	9b01      	ldr	r3, [sp, #4]
 80013ac:	1c5a      	adds	r2, r3, #1
 80013ae:	9201      	str	r2, [sp, #4]
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 80013b0:	9901      	ldr	r1, [sp, #4]
 80013b2:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
 80013b6:	d1f4      	bne.n	80013a2 <RCC_WaitForHSEStartUp+0xa>

  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 80013b8:	2031      	movs	r0, #49	; 0x31
 80013ba:	f7ff ffd3 	bl	8001364 <RCC_GetFlagStatus>
  else
  {
    status = ERROR;
  }
  return (status);
}
 80013be:	3800      	subs	r0, #0
 80013c0:	bf18      	it	ne
 80013c2:	2001      	movne	r0, #1
 80013c4:	b003      	add	sp, #12
 80013c6:	bd00      	pop	{pc}

080013c8 <RCC_ClearFlag>:
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= RCC_CSR_RMVF;
 80013c8:	4b02      	ldr	r3, [pc, #8]	; (80013d4 <RCC_ClearFlag+0xc>)
 80013ca:	6f58      	ldr	r0, [r3, #116]	; 0x74
 80013cc:	f040 7280 	orr.w	r2, r0, #16777216	; 0x1000000
 80013d0:	675a      	str	r2, [r3, #116]	; 0x74
}
 80013d2:	4770      	bx	lr
 80013d4:	40023800 	.word	0x40023800

080013d8 <RCC_GetITStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 80013d8:	4903      	ldr	r1, [pc, #12]	; (80013e8 <RCC_GetITStatus+0x10>)
 80013da:	68cb      	ldr	r3, [r1, #12]
  {
    bitstatus = SET;
 80013dc:	4218      	tst	r0, r3
  {
    bitstatus = RESET;
  }
  /* Return the RCC_IT status */
  return  bitstatus;
}
 80013de:	bf0c      	ite	eq
 80013e0:	2000      	moveq	r0, #0
 80013e2:	2001      	movne	r0, #1
 80013e4:	4770      	bx	lr
 80013e6:	bf00      	nop
 80013e8:	40023800 	.word	0x40023800

080013ec <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 80013ec:	4b01      	ldr	r3, [pc, #4]	; (80013f4 <RCC_ClearITPendingBit+0x8>)
 80013ee:	7018      	strb	r0, [r3, #0]
}
 80013f0:	4770      	bx	lr
 80013f2:	bf00      	nop
 80013f4:	4002380e 	.word	0x4002380e

080013f8 <EXTI_DeInit>:
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR = 0x00000000;
 80013f8:	4b04      	ldr	r3, [pc, #16]	; (800140c <EXTI_DeInit+0x14>)
  EXTI->EMR = 0x00000000;
  EXTI->RTSR = 0x00000000;
  EXTI->FTSR = 0x00000000;
  EXTI->PR = 0x007FFFFF;
 80013fa:	4a05      	ldr	r2, [pc, #20]	; (8001410 <EXTI_DeInit+0x18>)
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR = 0x00000000;
 80013fc:	2000      	movs	r0, #0
 80013fe:	6018      	str	r0, [r3, #0]
  EXTI->EMR = 0x00000000;
 8001400:	6058      	str	r0, [r3, #4]
  EXTI->RTSR = 0x00000000;
 8001402:	6098      	str	r0, [r3, #8]
  EXTI->FTSR = 0x00000000;
 8001404:	60d8      	str	r0, [r3, #12]
  EXTI->PR = 0x007FFFFF;
 8001406:	615a      	str	r2, [r3, #20]
}
 8001408:	4770      	bx	lr
 800140a:	bf00      	nop
 800140c:	40013c00 	.word	0x40013c00
 8001410:	007fffff 	.word	0x007fffff

08001414 <EXTI_Init>:
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8001414:	7983      	ldrb	r3, [r0, #6]
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
  *         that contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 8001416:	b470      	push	{r4, r5, r6}
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8001418:	b343      	cbz	r3, 800146c <EXTI_Init+0x58>
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 800141a:	4b20      	ldr	r3, [pc, #128]	; (800149c <EXTI_Init+0x88>)
 800141c:	6801      	ldr	r1, [r0, #0]
 800141e:	681e      	ldr	r6, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 8001420:	7902      	ldrb	r2, [r0, #4]
    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 8001422:	7945      	ldrb	r5, [r0, #5]
  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 8001424:	43cc      	mvns	r4, r1
 8001426:	ea04 0606 	and.w	r6, r4, r6
 800142a:	601e      	str	r6, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 800142c:	685e      	ldr	r6, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 800142e:	f102 4c80 	add.w	ip, r2, #1073741824	; 0x40000000
 8001432:	f50c 329e 	add.w	r2, ip, #80896	; 0x13c00
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 8001436:	4034      	ands	r4, r6
 8001438:	605c      	str	r4, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 800143a:	6814      	ldr	r4, [r2, #0]
 800143c:	ea44 0101 	orr.w	r1, r4, r1
 8001440:	6011      	str	r1, [r2, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 8001442:	6802      	ldr	r2, [r0, #0]
 8001444:	6898      	ldr	r0, [r3, #8]
 8001446:	43d1      	mvns	r1, r2
 8001448:	ea01 0000 	and.w	r0, r1, r0
 800144c:	6098      	str	r0, [r3, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 800144e:	68d8      	ldr	r0, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 8001450:	2d10      	cmp	r5, #16

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 8001452:	ea01 0100 	and.w	r1, r1, r0
 8001456:	60d9      	str	r1, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 8001458:	d016      	beq.n	8001488 <EXTI_Init+0x74>
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
    }
    else
    {
      tmp = (uint32_t)EXTI_BASE;
      tmp += EXTI_InitStruct->EXTI_Trigger;
 800145a:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 800145e:	f505 359e 	add.w	r5, r5, #80896	; 0x13c00

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8001462:	6828      	ldr	r0, [r5, #0]
 8001464:	ea40 0302 	orr.w	r3, r0, r2
 8001468:	602b      	str	r3, [r5, #0]
 800146a:	e00b      	b.n	8001484 <EXTI_Init+0x70>
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 800146c:	7902      	ldrb	r2, [r0, #4]

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 800146e:	6801      	ldr	r1, [r0, #0]
      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 8001470:	f102 4080 	add.w	r0, r2, #1073741824	; 0x40000000
 8001474:	f500 3c9e 	add.w	ip, r0, #80896	; 0x13c00

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 8001478:	f8dc 3000 	ldr.w	r3, [ip]
 800147c:	ea23 0201 	bic.w	r2, r3, r1
 8001480:	f8cc 2000 	str.w	r2, [ip]
  }
}
 8001484:	bc70      	pop	{r4, r5, r6}
 8001486:	4770      	bx	lr
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 8001488:	6899      	ldr	r1, [r3, #8]
 800148a:	ea41 0002 	orr.w	r0, r1, r2
 800148e:	6098      	str	r0, [r3, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 8001490:	68d9      	ldr	r1, [r3, #12]
 8001492:	ea41 0002 	orr.w	r0, r1, r2
 8001496:	60d8      	str	r0, [r3, #12]
 8001498:	e7f4      	b.n	8001484 <EXTI_Init+0x70>
 800149a:	bf00      	nop
 800149c:	40013c00 	.word	0x40013c00

080014a0 <EXTI_StructInit>:
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 80014a0:	2300      	movs	r3, #0
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 80014a2:	220c      	movs	r2, #12
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 80014a4:	6003      	str	r3, [r0, #0]
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
 80014a6:	7103      	strb	r3, [r0, #4]
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 80014a8:	7142      	strb	r2, [r0, #5]
  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
 80014aa:	7183      	strb	r3, [r0, #6]
}
 80014ac:	4770      	bx	lr
 80014ae:	bf00      	nop

080014b0 <EXTI_GenerateSWInterrupt>:
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->SWIER |= EXTI_Line;
 80014b0:	4b02      	ldr	r3, [pc, #8]	; (80014bc <EXTI_GenerateSWInterrupt+0xc>)
 80014b2:	6919      	ldr	r1, [r3, #16]
 80014b4:	ea40 0201 	orr.w	r2, r0, r1
 80014b8:	611a      	str	r2, [r3, #16]
}
 80014ba:	4770      	bx	lr
 80014bc:	40013c00 	.word	0x40013c00

080014c0 <EXTI_GetFlagStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
 80014c0:	4903      	ldr	r1, [pc, #12]	; (80014d0 <EXTI_GetFlagStatus+0x10>)
 80014c2:	694b      	ldr	r3, [r1, #20]
  {
    bitstatus = SET;
 80014c4:	4218      	tst	r0, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80014c6:	bf0c      	ite	eq
 80014c8:	2000      	moveq	r0, #0
 80014ca:	2001      	movne	r0, #1
 80014cc:	4770      	bx	lr
 80014ce:	bf00      	nop
 80014d0:	40013c00 	.word	0x40013c00

080014d4 <EXTI_ClearFlag>:
void EXTI_ClearFlag(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 80014d4:	4b01      	ldr	r3, [pc, #4]	; (80014dc <EXTI_ClearFlag+0x8>)
 80014d6:	6158      	str	r0, [r3, #20]
}
 80014d8:	4770      	bx	lr
 80014da:	bf00      	nop
 80014dc:	40013c00 	.word	0x40013c00

080014e0 <EXTI_GetITStatus>:
  ITStatus bitstatus = RESET;
  uint32_t enablestatus = 0;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  EXTI->IMR & EXTI_Line;
 80014e0:	4905      	ldr	r1, [pc, #20]	; (80014f8 <EXTI_GetITStatus+0x18>)
 80014e2:	680a      	ldr	r2, [r1, #0]
  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 80014e4:	694b      	ldr	r3, [r1, #20]
 80014e6:	4003      	ands	r3, r0
 80014e8:	d004      	beq.n	80014f4 <EXTI_GetITStatus+0x14>
  {
    bitstatus = SET;
 80014ea:	4210      	tst	r0, r2
 80014ec:	bf0c      	ite	eq
 80014ee:	2000      	moveq	r0, #0
 80014f0:	2001      	movne	r0, #1
 80014f2:	4770      	bx	lr
  }
  else
  {
    bitstatus = RESET;
 80014f4:	4618      	mov	r0, r3
  }
  return bitstatus;
}
 80014f6:	4770      	bx	lr
 80014f8:	40013c00 	.word	0x40013c00

080014fc <EXTI_ClearITPendingBit>:
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 80014fc:	4b01      	ldr	r3, [pc, #4]	; (8001504 <EXTI_ClearITPendingBit+0x8>)
 80014fe:	6158      	str	r0, [r3, #20]
}
 8001500:	4770      	bx	lr
 8001502:	bf00      	nop
 8001504:	40013c00 	.word	0x40013c00

08001508 <GPIO_DeInit>:
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
 8001508:	4b3c      	ldr	r3, [pc, #240]	; (80015fc <GPIO_DeInit+0xf4>)
 800150a:	4298      	cmp	r0, r3
  * @note   By default, The GPIO pins are configured in input floating mode (except JTAG pins).
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 800150c:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
 800150e:	d024      	beq.n	800155a <GPIO_DeInit+0x52>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
 8001510:	493b      	ldr	r1, [pc, #236]	; (8001600 <GPIO_DeInit+0xf8>)
 8001512:	4288      	cmp	r0, r1
 8001514:	d02b      	beq.n	800156e <GPIO_DeInit+0x66>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
 8001516:	4a3b      	ldr	r2, [pc, #236]	; (8001604 <GPIO_DeInit+0xfc>)
 8001518:	4290      	cmp	r0, r2
 800151a:	d032      	beq.n	8001582 <GPIO_DeInit+0x7a>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
 800151c:	4b3a      	ldr	r3, [pc, #232]	; (8001608 <GPIO_DeInit+0x100>)
 800151e:	4298      	cmp	r0, r3
 8001520:	d039      	beq.n	8001596 <GPIO_DeInit+0x8e>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
  }
  else if (GPIOx == GPIOE)
 8001522:	493a      	ldr	r1, [pc, #232]	; (800160c <GPIO_DeInit+0x104>)
 8001524:	4288      	cmp	r0, r1
 8001526:	d040      	beq.n	80015aa <GPIO_DeInit+0xa2>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
  }
  else if (GPIOx == GPIOF)
 8001528:	4a39      	ldr	r2, [pc, #228]	; (8001610 <GPIO_DeInit+0x108>)
 800152a:	4290      	cmp	r0, r2
 800152c:	d047      	beq.n	80015be <GPIO_DeInit+0xb6>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
  }
  else if (GPIOx == GPIOG)
 800152e:	4b39      	ldr	r3, [pc, #228]	; (8001614 <GPIO_DeInit+0x10c>)
 8001530:	4298      	cmp	r0, r3
 8001532:	d04e      	beq.n	80015d2 <GPIO_DeInit+0xca>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
  }
  else if (GPIOx == GPIOH)
 8001534:	4938      	ldr	r1, [pc, #224]	; (8001618 <GPIO_DeInit+0x110>)
 8001536:	4288      	cmp	r0, r1
 8001538:	d055      	beq.n	80015e6 <GPIO_DeInit+0xde>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
  }
  else
  {
    if (GPIOx == GPIOI)
 800153a:	4a38      	ldr	r2, [pc, #224]	; (800161c <GPIO_DeInit+0x114>)
 800153c:	4290      	cmp	r0, r2
 800153e:	d000      	beq.n	8001542 <GPIO_DeInit+0x3a>
 8001540:	bd10      	pop	{r4, pc}
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
 8001542:	2101      	movs	r1, #1
 8001544:	f44f 7080 	mov.w	r0, #256	; 0x100
 8001548:	f7ff fe70 	bl	800122c <RCC_AHB1PeriphResetCmd>
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 800154c:	f44f 7080 	mov.w	r0, #256	; 0x100
 8001550:	2100      	movs	r1, #0
    }
  }
}
 8001552:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  else
  {
    if (GPIOx == GPIOI)
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 8001556:	f7ff be69 	b.w	800122c <RCC_AHB1PeriphResetCmd>
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 800155a:	2001      	movs	r0, #1
 800155c:	4601      	mov	r1, r0
 800155e:	f7ff fe65 	bl	800122c <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
 8001562:	2001      	movs	r0, #1
 8001564:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 8001566:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
 800156a:	f7ff be5f 	b.w	800122c <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOB)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 800156e:	2002      	movs	r0, #2
 8001570:	2101      	movs	r1, #1
 8001572:	f7ff fe5b 	bl	800122c <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
 8001576:	2002      	movs	r0, #2
 8001578:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 800157a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
 800157e:	f7ff be55 	b.w	800122c <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOC)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 8001582:	2004      	movs	r0, #4
 8001584:	2101      	movs	r1, #1
 8001586:	f7ff fe51 	bl	800122c <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
 800158a:	2004      	movs	r0, #4
 800158c:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 800158e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
 8001592:	f7ff be4b 	b.w	800122c <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOD)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 8001596:	2008      	movs	r0, #8
 8001598:	2101      	movs	r1, #1
 800159a:	f7ff fe47 	bl	800122c <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
 800159e:	2008      	movs	r0, #8
 80015a0:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80015a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
 80015a6:	f7ff be41 	b.w	800122c <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOE)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
 80015aa:	2010      	movs	r0, #16
 80015ac:	2101      	movs	r1, #1
 80015ae:	f7ff fe3d 	bl	800122c <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
 80015b2:	2010      	movs	r0, #16
 80015b4:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80015b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
  }
  else if (GPIOx == GPIOE)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
 80015ba:	f7ff be37 	b.w	800122c <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOF)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
 80015be:	2020      	movs	r0, #32
 80015c0:	2101      	movs	r1, #1
 80015c2:	f7ff fe33 	bl	800122c <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
 80015c6:	2020      	movs	r0, #32
 80015c8:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80015ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
  }
  else if (GPIOx == GPIOF)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
 80015ce:	f7ff be2d 	b.w	800122c <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOG)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
 80015d2:	2040      	movs	r0, #64	; 0x40
 80015d4:	2101      	movs	r1, #1
 80015d6:	f7ff fe29 	bl	800122c <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
 80015da:	2040      	movs	r0, #64	; 0x40
 80015dc:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80015de:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
  }
  else if (GPIOx == GPIOG)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
 80015e2:	f7ff be23 	b.w	800122c <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOH)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
 80015e6:	2080      	movs	r0, #128	; 0x80
 80015e8:	2101      	movs	r1, #1
 80015ea:	f7ff fe1f 	bl	800122c <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
 80015ee:	2080      	movs	r0, #128	; 0x80
 80015f0:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80015f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
  }
  else if (GPIOx == GPIOH)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
 80015f6:	f7ff be19 	b.w	800122c <RCC_AHB1PeriphResetCmd>
 80015fa:	bf00      	nop
 80015fc:	40020000 	.word	0x40020000
 8001600:	40020400 	.word	0x40020400
 8001604:	40020800 	.word	0x40020800
 8001608:	40020c00 	.word	0x40020c00
 800160c:	40021000 	.word	0x40021000
 8001610:	40021400 	.word	0x40021400
 8001614:	40021800 	.word	0x40021800
 8001618:	40021c00 	.word	0x40021c00
 800161c:	40022000 	.word	0x40022000

08001620 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8001620:	2300      	movs	r3, #0
 8001622:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8001626:	680a      	ldr	r2, [r1, #0]
 8001628:	461c      	mov	r4, r3
  {
    pos = ((uint32_t)0x01) << pinpos;
 800162a:	2601      	movs	r6, #1
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 800162c:	f04f 0c03 	mov.w	ip, #3
 8001630:	e00b      	b.n	800164a <GPIO_Init+0x2a>
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8001632:	3401      	adds	r4, #1
  {
    pos = ((uint32_t)0x01) << pinpos;
 8001634:	fa16 f504 	lsls.w	r5, r6, r4
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8001638:	ea05 0702 	and.w	r7, r5, r2
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800163c:	3302      	adds	r3, #2
  {
    pos = ((uint32_t)0x01) << pinpos;
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
 800163e:	42af      	cmp	r7, r5
 8001640:	d035      	beq.n	80016ae <GPIO_Init+0x8e>
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8001642:	3401      	adds	r4, #1
 8001644:	3302      	adds	r3, #2
 8001646:	2c10      	cmp	r4, #16
 8001648:	d05a      	beq.n	8001700 <GPIO_Init+0xe0>
  {
    pos = ((uint32_t)0x01) << pinpos;
 800164a:	fa16 f504 	lsls.w	r5, r6, r4
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 800164e:	ea05 0702 	and.w	r7, r5, r2

    if (currentpin == pos)
 8001652:	42af      	cmp	r7, r5
 8001654:	d1ed      	bne.n	8001632 <GPIO_Init+0x12>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8001656:	f8d0 9000 	ldr.w	r9, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 800165a:	f891 8004 	ldrb.w	r8, [r1, #4]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 800165e:	fa0c f503 	lsl.w	r5, ip, r3
 8001662:	43ed      	mvns	r5, r5
 8001664:	ea05 0a09 	and.w	sl, r5, r9
 8001668:	f8c0 a000 	str.w	sl, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 800166c:	f8d0 9000 	ldr.w	r9, [r0]
 8001670:	fa08 fa03 	lsl.w	sl, r8, r3

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8001674:	f108 38ff 	add.w	r8, r8, #4294967295
 8001678:	fa5f f888 	uxtb.w	r8, r8
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 800167c:	ea4a 0909 	orr.w	r9, sl, r9

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8001680:	f1b8 0f01 	cmp.w	r8, #1
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8001684:	f8c0 9000 	str.w	r9, [r0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8001688:	d93d      	bls.n	8001706 <GPIO_Init+0xe6>
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 800168a:	68c7      	ldr	r7, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 800168c:	f891 8007 	ldrb.w	r8, [r1, #7]
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8001690:	403d      	ands	r5, r7
 8001692:	60c5      	str	r5, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8001694:	68c7      	ldr	r7, [r0, #12]
 8001696:	fa08 f503 	lsl.w	r5, r8, r3
 800169a:	433d      	orrs	r5, r7
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800169c:	3401      	adds	r4, #1
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 800169e:	60c5      	str	r5, [r0, #12]

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
  {
    pos = ((uint32_t)0x01) << pinpos;
 80016a0:	fa16 f504 	lsls.w	r5, r6, r4
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80016a4:	ea05 0702 	and.w	r7, r5, r2
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80016a8:	3302      	adds	r3, #2
  {
    pos = ((uint32_t)0x01) << pinpos;
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
 80016aa:	42af      	cmp	r7, r5
 80016ac:	d1c9      	bne.n	8001642 <GPIO_Init+0x22>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80016ae:	f8d0 9000 	ldr.w	r9, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80016b2:	f891 8004 	ldrb.w	r8, [r1, #4]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80016b6:	fa0c f503 	lsl.w	r5, ip, r3
 80016ba:	43ed      	mvns	r5, r5
 80016bc:	ea05 0a09 	and.w	sl, r5, r9
 80016c0:	f8c0 a000 	str.w	sl, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80016c4:	f8d0 9000 	ldr.w	r9, [r0]
 80016c8:	fa08 fa03 	lsl.w	sl, r8, r3

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80016cc:	f108 38ff 	add.w	r8, r8, #4294967295
 80016d0:	fa5f f888 	uxtb.w	r8, r8
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80016d4:	ea4a 0909 	orr.w	r9, sl, r9

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80016d8:	f1b8 0f01 	cmp.w	r8, #1
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80016dc:	f8c0 9000 	str.w	r9, [r0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80016e0:	d931      	bls.n	8001746 <GPIO_Init+0x126>
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 80016e2:	68c7      	ldr	r7, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80016e4:	f891 8007 	ldrb.w	r8, [r1, #7]
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 80016e8:	ea05 0707 	and.w	r7, r5, r7
 80016ec:	60c7      	str	r7, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80016ee:	68c7      	ldr	r7, [r0, #12]
 80016f0:	fa08 f503 	lsl.w	r5, r8, r3
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80016f4:	3401      	adds	r4, #1
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80016f6:	433d      	orrs	r5, r7
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80016f8:	3302      	adds	r3, #2
 80016fa:	2c10      	cmp	r4, #16
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80016fc:	60c5      	str	r5, [r0, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80016fe:	d1a4      	bne.n	800164a <GPIO_Init+0x2a>
      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 8001700:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8001704:	4770      	bx	lr
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8001706:	f8d0 a008 	ldr.w	sl, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 800170a:	f891 9005 	ldrb.w	r9, [r1, #5]
        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 800170e:	f891 8006 	ldrb.w	r8, [r1, #6]
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8001712:	ea05 0a0a 	and.w	sl, r5, sl
 8001716:	f8c0 a008 	str.w	sl, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 800171a:	f8d0 a008 	ldr.w	sl, [r0, #8]
 800171e:	fa09 f903 	lsl.w	r9, r9, r3
 8001722:	ea49 090a 	orr.w	r9, r9, sl
 8001726:	f8c0 9008 	str.w	r9, [r0, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 800172a:	f8d0 9004 	ldr.w	r9, [r0, #4]
 800172e:	ea29 0707 	bic.w	r7, r9, r7
 8001732:	6047      	str	r7, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8001734:	6847      	ldr	r7, [r0, #4]
 8001736:	fa08 f804 	lsl.w	r8, r8, r4
 800173a:	fa1f f888 	uxth.w	r8, r8
 800173e:	ea48 0707 	orr.w	r7, r8, r7
 8001742:	6047      	str	r7, [r0, #4]
 8001744:	e7a1      	b.n	800168a <GPIO_Init+0x6a>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8001746:	f8d0 a008 	ldr.w	sl, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 800174a:	f891 9005 	ldrb.w	r9, [r1, #5]
        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 800174e:	f891 8006 	ldrb.w	r8, [r1, #6]
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8001752:	ea05 0a0a 	and.w	sl, r5, sl
 8001756:	f8c0 a008 	str.w	sl, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 800175a:	f8d0 a008 	ldr.w	sl, [r0, #8]
 800175e:	fa09 f903 	lsl.w	r9, r9, r3
 8001762:	ea49 090a 	orr.w	r9, r9, sl
 8001766:	f8c0 9008 	str.w	r9, [r0, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 800176a:	f8d0 9004 	ldr.w	r9, [r0, #4]
 800176e:	ea29 0707 	bic.w	r7, r9, r7
 8001772:	6047      	str	r7, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8001774:	6847      	ldr	r7, [r0, #4]
 8001776:	fa08 f804 	lsl.w	r8, r8, r4
 800177a:	fa1f f888 	uxth.w	r8, r8
 800177e:	ea48 0707 	orr.w	r7, r8, r7
 8001782:	6047      	str	r7, [r0, #4]
 8001784:	e7ad      	b.n	80016e2 <GPIO_Init+0xc2>
 8001786:	bf00      	nop

08001788 <GPIO_StructInit>:
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 8001788:	2300      	movs	r3, #0
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 800178a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800178e:	6002      	str	r2, [r0, #0]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 8001790:	7103      	strb	r3, [r0, #4]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8001792:	7143      	strb	r3, [r0, #5]
  GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
 8001794:	7183      	strb	r3, [r0, #6]
  GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
 8001796:	71c3      	strb	r3, [r0, #7]
}
 8001798:	4770      	bx	lr
 800179a:	bf00      	nop

0800179c <GPIO_PinLockConfig>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800179c:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0x00010000;
 800179e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80017a2:	9201      	str	r2, [sp, #4]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  tmp |= GPIO_Pin;
 80017a4:	9b01      	ldr	r3, [sp, #4]
 80017a6:	ea41 0203 	orr.w	r2, r1, r3
 80017aa:	9201      	str	r2, [sp, #4]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 80017ac:	9b01      	ldr	r3, [sp, #4]
 80017ae:	61c3      	str	r3, [r0, #28]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 80017b0:	61c1      	str	r1, [r0, #28]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 80017b2:	9a01      	ldr	r2, [sp, #4]
 80017b4:	61c2      	str	r2, [r0, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 80017b6:	69c1      	ldr	r1, [r0, #28]
 80017b8:	9101      	str	r1, [sp, #4]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 80017ba:	69c3      	ldr	r3, [r0, #28]
 80017bc:	9301      	str	r3, [sp, #4]
}
 80017be:	b002      	add	sp, #8
 80017c0:	4770      	bx	lr
 80017c2:	bf00      	nop

080017c4 <GPIO_ReadInputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 80017c4:	6903      	ldr	r3, [r0, #16]
  {
    bitstatus = (uint8_t)Bit_SET;
 80017c6:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 80017c8:	bf0c      	ite	eq
 80017ca:	2000      	moveq	r0, #0
 80017cc:	2001      	movne	r0, #1
 80017ce:	4770      	bx	lr

080017d0 <GPIO_ReadInputData>:
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->IDR);
 80017d0:	6900      	ldr	r0, [r0, #16]
}
 80017d2:	b280      	uxth	r0, r0
 80017d4:	4770      	bx	lr
 80017d6:	bf00      	nop

080017d8 <GPIO_ReadOutputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 80017d8:	6943      	ldr	r3, [r0, #20]
  {
    bitstatus = (uint8_t)Bit_SET;
 80017da:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 80017dc:	bf0c      	ite	eq
 80017de:	2000      	moveq	r0, #0
 80017e0:	2001      	movne	r0, #1
 80017e2:	4770      	bx	lr

080017e4 <GPIO_ReadOutputData>:
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->ODR);
 80017e4:	6940      	ldr	r0, [r0, #20]
}
 80017e6:	b280      	uxth	r0, r0
 80017e8:	4770      	bx	lr
 80017ea:	bf00      	nop

080017ec <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRL = GPIO_Pin;
 80017ec:	8301      	strh	r1, [r0, #24]
}
 80017ee:	4770      	bx	lr

080017f0 <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRH = GPIO_Pin;
 80017f0:	8341      	strh	r1, [r0, #26]
}
 80017f2:	4770      	bx	lr

080017f4 <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
 80017f4:	b90a      	cbnz	r2, 80017fa <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRRL = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRRH = GPIO_Pin ;
 80017f6:	8341      	strh	r1, [r0, #26]
 80017f8:	4770      	bx	lr
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
  {
    GPIOx->BSRRL = GPIO_Pin;
 80017fa:	8301      	strh	r1, [r0, #24]
 80017fc:	4770      	bx	lr
 80017fe:	bf00      	nop

08001800 <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR = PortVal;
 8001800:	6141      	str	r1, [r0, #20]
}
 8001802:	4770      	bx	lr

08001804 <GPIO_ToggleBits>:
void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR ^= GPIO_Pin;
 8001804:	6942      	ldr	r2, [r0, #20]
 8001806:	ea81 0302 	eor.w	r3, r1, r2
 800180a:	6143      	str	r3, [r0, #20]
}
 800180c:	4770      	bx	lr
 800180e:	bf00      	nop

08001810 <GPIO_PinAFConfig>:
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8001810:	08cb      	lsrs	r3, r1, #3
 8001812:	3308      	adds	r3, #8
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8001814:	f001 0107 	and.w	r1, r1, #7
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8001818:	b430      	push	{r4, r5}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 800181a:	0089      	lsls	r1, r1, #2
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 800181c:	f850 5023 	ldr.w	r5, [r0, r3, lsl #2]
 8001820:	240f      	movs	r4, #15
 8001822:	408c      	lsls	r4, r1
 8001824:	ea25 0404 	bic.w	r4, r5, r4
 8001828:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 800182c:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8001830:	fa12 f101 	lsls.w	r1, r2, r1
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8001834:	ea41 0404 	orr.w	r4, r1, r4
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 8001838:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
}
 800183c:	bc30      	pop	{r4, r5}
 800183e:	4770      	bx	lr

08001840 <usbd_cdc_EP0_RxReady>:
  *         Data received on control endpoint
  * @param  pdev: device device instance
  * @retval status
  */
static uint8_t  usbd_cdc_EP0_RxReady (void  *pdev)
{ 
 8001840:	b510      	push	{r4, lr}
  if (cdcCmd != NO_CMD)
 8001842:	4c07      	ldr	r4, [pc, #28]	; (8001860 <usbd_cdc_EP0_RxReady+0x20>)
 8001844:	6820      	ldr	r0, [r4, #0]
 8001846:	28ff      	cmp	r0, #255	; 0xff
 8001848:	d007      	beq.n	800185a <usbd_cdc_EP0_RxReady+0x1a>
  {
    /* Process the data */
    APP_FOPS.pIf_Ctrl(cdcCmd, CmdBuff, cdcLen);
 800184a:	4906      	ldr	r1, [pc, #24]	; (8001864 <usbd_cdc_EP0_RxReady+0x24>)
 800184c:	4a06      	ldr	r2, [pc, #24]	; (8001868 <usbd_cdc_EP0_RxReady+0x28>)
 800184e:	688b      	ldr	r3, [r1, #8]
 8001850:	6812      	ldr	r2, [r2, #0]
 8001852:	4906      	ldr	r1, [pc, #24]	; (800186c <usbd_cdc_EP0_RxReady+0x2c>)
 8001854:	4798      	blx	r3
    
    /* Reset the command variable to default value */
    cdcCmd = NO_CMD;
 8001856:	23ff      	movs	r3, #255	; 0xff
 8001858:	6023      	str	r3, [r4, #0]
  }
  
  return USBD_OK;
}
 800185a:	2000      	movs	r0, #0
 800185c:	bd10      	pop	{r4, pc}
 800185e:	bf00      	nop
 8001860:	200000a8 	.word	0x200000a8
 8001864:	20000014 	.word	0x20000014
 8001868:	200007f0 	.word	0x200007f0
 800186c:	200012a8 	.word	0x200012a8

08001870 <USBD_cdc_GetCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_cdc_GetCfgDesc (uint8_t speed, uint16_t *length)
{
  *length = sizeof (usbd_cdc_CfgDesc);
 8001870:	2343      	movs	r3, #67	; 0x43
 8001872:	800b      	strh	r3, [r1, #0]
  return usbd_cdc_CfgDesc;
}
 8001874:	4800      	ldr	r0, [pc, #0]	; (8001878 <USBD_cdc_GetCfgDesc+0x8>)
 8001876:	4770      	bx	lr
 8001878:	200000ac 	.word	0x200000ac

0800187c <usbd_cdc_SOF>:
  * @param  pdev: instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  usbd_cdc_SOF (void *pdev)
{      
 800187c:	b538      	push	{r3, r4, r5, lr}
  static uint32_t FrameCount = 0;
  
  if (FrameCount++ == CDC_IN_FRAME_INTERVAL)
 800187e:	4c1f      	ldr	r4, [pc, #124]	; (80018fc <usbd_cdc_SOF+0x80>)
 8001880:	6863      	ldr	r3, [r4, #4]
 8001882:	1c5a      	adds	r2, r3, #1
 8001884:	2b05      	cmp	r3, #5
 8001886:	6062      	str	r2, [r4, #4]
 8001888:	d001      	beq.n	800188e <usbd_cdc_SOF+0x12>
    /* Check the data to be sent through IN pipe */
    Handle_USBAsynchXfer(pdev);
  }
  
  return USBD_OK;
}
 800188a:	2000      	movs	r0, #0
 800188c:	bd38      	pop	{r3, r4, r5, pc}
static void Handle_USBAsynchXfer (void *pdev)
{
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;
  
  if(USB_Tx_State != 1)
 800188e:	f894 c008 	ldrb.w	ip, [r4, #8]
  static uint32_t FrameCount = 0;
  
  if (FrameCount++ == CDC_IN_FRAME_INTERVAL)
  {
    /* Reset the frame counter */
    FrameCount = 0;
 8001892:	2300      	movs	r3, #0
static void Handle_USBAsynchXfer (void *pdev)
{
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;
  
  if(USB_Tx_State != 1)
 8001894:	f1bc 0f01 	cmp.w	ip, #1
  static uint32_t FrameCount = 0;
  
  if (FrameCount++ == CDC_IN_FRAME_INTERVAL)
  {
    /* Reset the frame counter */
    FrameCount = 0;
 8001898:	6063      	str	r3, [r4, #4]
static void Handle_USBAsynchXfer (void *pdev)
{
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;
  
  if(USB_Tx_State != 1)
 800189a:	d0f6      	beq.n	800188a <usbd_cdc_SOF+0xe>
  {
    if (APP_Rx_ptr_out == APP_RX_DATA_SIZE)
 800189c:	68e5      	ldr	r5, [r4, #12]
    {
      APP_Rx_ptr_out = 0;
    }
    
    if(APP_Rx_ptr_out == APP_Rx_ptr_in) 
 800189e:	4a17      	ldr	r2, [pc, #92]	; (80018fc <usbd_cdc_SOF+0x80>)
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;
  
  if(USB_Tx_State != 1)
  {
    if (APP_Rx_ptr_out == APP_RX_DATA_SIZE)
 80018a0:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
    {
      APP_Rx_ptr_out = 0;
 80018a4:	bf04      	itt	eq
 80018a6:	60e3      	streq	r3, [r4, #12]
 80018a8:	461d      	moveq	r5, r3
    }
    
    if(APP_Rx_ptr_out == APP_Rx_ptr_in) 
 80018aa:	6923      	ldr	r3, [r4, #16]
 80018ac:	42ab      	cmp	r3, r5
 80018ae:	d021      	beq.n	80018f4 <usbd_cdc_SOF+0x78>
      APP_Rx_length = APP_RX_DATA_SIZE - APP_Rx_ptr_out;
    
    }
    else 
    {
      APP_Rx_length = APP_Rx_ptr_in - APP_Rx_ptr_out;
 80018b0:	bf28      	it	cs
 80018b2:	ebc5 0103 	rsbcs	r1, r5, r3
    }
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     APP_Rx_length &= ~0x03;
#endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    
    if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE)
 80018b6:	f8d0 35ec 	ldr.w	r3, [r0, #1516]	; 0x5ec
 80018ba:	f8b3 3039 	ldrh.w	r3, [r3, #57]	; 0x39
      return;
    }
    
    if(APP_Rx_ptr_out > APP_Rx_ptr_in) /* rollback */
    { 
      APP_Rx_length = APP_RX_DATA_SIZE - APP_Rx_ptr_out;
 80018be:	bf38      	it	cc
 80018c0:	f5c5 6100 	rsbcc	r1, r5, #2048	; 0x800
    }
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     APP_Rx_length &= ~0x03;
#endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    
    if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE)
 80018c4:	428b      	cmp	r3, r1
      APP_Rx_length = APP_RX_DATA_SIZE - APP_Rx_ptr_out;
    
    }
    else 
    {
      APP_Rx_length = APP_Rx_ptr_in - APP_Rx_ptr_out;
 80018c6:	6151      	str	r1, [r2, #20]
    }
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     APP_Rx_length &= ~0x03;
#endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    
    if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE)
 80018c8:	d20d      	bcs.n	80018e6 <usbd_cdc_SOF+0x6a>
    {
      USB_Tx_ptr = APP_Rx_ptr_out;
      USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
      
      APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;	
 80018ca:	18ea      	adds	r2, r5, r3
      APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;
 80018cc:	1ac9      	subs	r1, r1, r3
     APP_Rx_length &= ~0x03;
#endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    
    if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE)
    {
      USB_Tx_ptr = APP_Rx_ptr_out;
 80018ce:	b2ad      	uxth	r5, r5
      USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
      
      APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;	
 80018d0:	60e2      	str	r2, [r4, #12]
      APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;
 80018d2:	6161      	str	r1, [r4, #20]
      APP_Rx_ptr_out += APP_Rx_length;
      APP_Rx_length = 0;
    }
    USB_Tx_State = 1; 

    DCD_EP_Tx (pdev,
 80018d4:	4a0a      	ldr	r2, [pc, #40]	; (8001900 <usbd_cdc_SOF+0x84>)
 80018d6:	2181      	movs	r1, #129	; 0x81
 80018d8:	1952      	adds	r2, r2, r5
      USB_Tx_length = APP_Rx_length;
      
      APP_Rx_ptr_out += APP_Rx_length;
      APP_Rx_length = 0;
    }
    USB_Tx_State = 1; 
 80018da:	2501      	movs	r5, #1
 80018dc:	7225      	strb	r5, [r4, #8]

    DCD_EP_Tx (pdev,
 80018de:	f001 f871 	bl	80029c4 <DCD_EP_Tx>
    /* Check the data to be sent through IN pipe */
    Handle_USBAsynchXfer(pdev);
  }
  
  return USBD_OK;
}
 80018e2:	2000      	movs	r0, #0
 80018e4:	bd38      	pop	{r3, r4, r5, pc}
    else
    {
      USB_Tx_ptr = APP_Rx_ptr_out;
      USB_Tx_length = APP_Rx_length;
      
      APP_Rx_ptr_out += APP_Rx_length;
 80018e6:	194a      	adds	r2, r1, r5
      APP_Rx_length = 0;
 80018e8:	2300      	movs	r3, #0
 80018ea:	6163      	str	r3, [r4, #20]
      APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;	
      APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;
    }
    else
    {
      USB_Tx_ptr = APP_Rx_ptr_out;
 80018ec:	b2ad      	uxth	r5, r5
      USB_Tx_length = APP_Rx_length;
      
      APP_Rx_ptr_out += APP_Rx_length;
 80018ee:	60e2      	str	r2, [r4, #12]
      APP_Rx_length = 0;
 80018f0:	b28b      	uxth	r3, r1
 80018f2:	e7ef      	b.n	80018d4 <usbd_cdc_SOF+0x58>
      APP_Rx_ptr_out = 0;
    }
    
    if(APP_Rx_ptr_out == APP_Rx_ptr_in) 
    {
      USB_Tx_State = 0; 
 80018f4:	2000      	movs	r0, #0
 80018f6:	7210      	strb	r0, [r2, #8]
 80018f8:	e7c7      	b.n	800188a <usbd_cdc_SOF+0xe>
 80018fa:	bf00      	nop
 80018fc:	200007f0 	.word	0x200007f0
 8001900:	200012b0 	.word	0x200012b0

08001904 <usbd_cdc_DataIn>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  usbd_cdc_DataIn (void *pdev, uint8_t epnum)
{
 8001904:	b538      	push	{r3, r4, r5, lr}
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;

  if (USB_Tx_State == 1)
 8001906:	4913      	ldr	r1, [pc, #76]	; (8001954 <usbd_cdc_DataIn+0x50>)
 8001908:	7a0b      	ldrb	r3, [r1, #8]
 800190a:	2b01      	cmp	r3, #1
 800190c:	d001      	beq.n	8001912 <usbd_cdc_DataIn+0xe>
                 USB_Tx_length);
    }
  }  
  
  return USBD_OK;
}
 800190e:	2000      	movs	r0, #0
 8001910:	bd38      	pop	{r3, r4, r5, pc}
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;

  if (USB_Tx_State == 1)
  {
    if (APP_Rx_length == 0) 
 8001912:	694c      	ldr	r4, [r1, #20]
 8001914:	b1d4      	cbz	r4, 800194c <usbd_cdc_DataIn+0x48>
    {
      USB_Tx_State = 0;
    }
    else 
    {
      if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE){
 8001916:	f8d0 25ec 	ldr.w	r2, [r0, #1516]	; 0x5ec
 800191a:	f8b2 3039 	ldrh.w	r3, [r2, #57]	; 0x39
 800191e:	429c      	cmp	r4, r3
 8001920:	d80d      	bhi.n	800193e <usbd_cdc_DataIn+0x3a>
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
        APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;    
      }
      else 
      {
        USB_Tx_ptr = APP_Rx_ptr_out;
 8001922:	68ca      	ldr	r2, [r1, #12]
        USB_Tx_length = APP_Rx_length;
        
        APP_Rx_ptr_out += APP_Rx_length;
 8001924:	1913      	adds	r3, r2, r4
 8001926:	60cb      	str	r3, [r1, #12]
        APP_Rx_length = 0;
 8001928:	2300      	movs	r3, #0
 800192a:	614b      	str	r3, [r1, #20]
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
        APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;    
      }
      else 
      {
        USB_Tx_ptr = APP_Rx_ptr_out;
 800192c:	b292      	uxth	r2, r2
        USB_Tx_length = APP_Rx_length;
        
        APP_Rx_ptr_out += APP_Rx_length;
        APP_Rx_length = 0;
 800192e:	b2a3      	uxth	r3, r4
      }
      
      /* Prepare the available data buffer to be sent on IN endpoint */
      DCD_EP_Tx (pdev,
 8001930:	4c09      	ldr	r4, [pc, #36]	; (8001958 <usbd_cdc_DataIn+0x54>)
 8001932:	2181      	movs	r1, #129	; 0x81
 8001934:	18a2      	adds	r2, r4, r2
 8001936:	f001 f845 	bl	80029c4 <DCD_EP_Tx>
                 USB_Tx_length);
    }
  }  
  
  return USBD_OK;
}
 800193a:	2000      	movs	r0, #0
 800193c:	bd38      	pop	{r3, r4, r5, pc}
      USB_Tx_State = 0;
    }
    else 
    {
      if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE){
        USB_Tx_ptr = APP_Rx_ptr_out;
 800193e:	68ca      	ldr	r2, [r1, #12]
        USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
        
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
        APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;    
 8001940:	1ae4      	subs	r4, r4, r3
    {
      if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE){
        USB_Tx_ptr = APP_Rx_ptr_out;
        USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
        
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
 8001942:	189d      	adds	r5, r3, r2
 8001944:	60cd      	str	r5, [r1, #12]
      USB_Tx_State = 0;
    }
    else 
    {
      if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE){
        USB_Tx_ptr = APP_Rx_ptr_out;
 8001946:	b292      	uxth	r2, r2
        USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
        
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
        APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;    
 8001948:	614c      	str	r4, [r1, #20]
 800194a:	e7f1      	b.n	8001930 <usbd_cdc_DataIn+0x2c>

  if (USB_Tx_State == 1)
  {
    if (APP_Rx_length == 0) 
    {
      USB_Tx_State = 0;
 800194c:	720c      	strb	r4, [r1, #8]
                 USB_Tx_length);
    }
  }  
  
  return USBD_OK;
}
 800194e:	2000      	movs	r0, #0
 8001950:	bd38      	pop	{r3, r4, r5, pc}
 8001952:	bf00      	nop
 8001954:	200007f0 	.word	0x200007f0
 8001958:	200012b0 	.word	0x200012b0

0800195c <usbd_cdc_DataOut>:
static uint8_t  usbd_cdc_DataOut (void *pdev, uint8_t epnum)
{      
  uint16_t USB_Rx_Cnt;
  
  /* Get the received data buffer and update the counter */
  USB_Rx_Cnt = ((USB_OTG_CORE_HANDLE*)pdev)->dev.out_ep[epnum].xfer_count;
 800195c:	eb01 0c81 	add.w	ip, r1, r1, lsl #2
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  usbd_cdc_DataOut (void *pdev, uint8_t epnum)
{      
 8001960:	b538      	push	{r3, r4, r5, lr}
  uint16_t USB_Rx_Cnt;
  
  /* Get the received data buffer and update the counter */
  USB_Rx_Cnt = ((USB_OTG_CORE_HANDLE*)pdev)->dev.out_ep[epnum].xfer_count;
 8001962:	eb00 01cc 	add.w	r1, r0, ip, lsl #3
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  usbd_cdc_DataOut (void *pdev, uint8_t epnum)
{      
 8001966:	4604      	mov	r4, r0
  /* Get the received data buffer and update the counter */
  USB_Rx_Cnt = ((USB_OTG_CORE_HANDLE*)pdev)->dev.out_ep[epnum].xfer_count;
  
  /* USB data will be immediately processed, this allow next USB traffic being 
     NAKed till the end of the application Xfer */
  APP_FOPS.pIf_DataRx(USB_Rx_Buffer, USB_Rx_Cnt);
 8001968:	4d08      	ldr	r5, [pc, #32]	; (800198c <usbd_cdc_DataOut+0x30>)
 800196a:	4809      	ldr	r0, [pc, #36]	; (8001990 <usbd_cdc_DataOut+0x34>)
 800196c:	f8b1 1388 	ldrh.w	r1, [r1, #904]	; 0x388
 8001970:	6902      	ldr	r2, [r0, #16]
 8001972:	4628      	mov	r0, r5
 8001974:	4790      	blx	r2
  
  /* Prepare Out endpoint to receive next packet */
  DCD_EP_PrepareRx(pdev,
 8001976:	f8d4 35ec 	ldr.w	r3, [r4, #1516]	; 0x5ec
 800197a:	4620      	mov	r0, r4
 800197c:	2101      	movs	r1, #1
 800197e:	462a      	mov	r2, r5
 8001980:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8001984:	f000 fff4 	bl	8002970 <DCD_EP_PrepareRx>
                   CDC_OUT_EP,
                   (uint8_t*)(USB_Rx_Buffer),
                   CDC_DATA_OUT_PACKET_SIZE);

  return USBD_OK;
}
 8001988:	2000      	movs	r0, #0
 800198a:	bd38      	pop	{r3, r4, r5, pc}
 800198c:	20001268 	.word	0x20001268
 8001990:	20000014 	.word	0x20000014

08001994 <usbd_cdc_Setup>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t  usbd_cdc_Setup (void  *pdev, 
                                USB_SETUP_REQ *req)
{
 8001994:	b570      	push	{r4, r5, r6, lr}
  uint16_t len;
  uint8_t  *pbuf;
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8001996:	780b      	ldrb	r3, [r1, #0]
 8001998:	f013 0560 	ands.w	r5, r3, #96	; 0x60
  * @param  req: usb requests
  * @retval status
  */
static uint8_t  usbd_cdc_Setup (void  *pdev, 
                                USB_SETUP_REQ *req)
{
 800199c:	460c      	mov	r4, r1
 800199e:	4606      	mov	r6, r0
  uint16_t len;
  uint8_t  *pbuf;
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80019a0:	d108      	bne.n	80019b4 <usbd_cdc_Setup+0x20>
    
      
      
    /* Standard Requests -------------------------------*/
  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
 80019a2:	784b      	ldrb	r3, [r1, #1]
 80019a4:	2b0a      	cmp	r3, #10
 80019a6:	d01c      	beq.n	80019e2 <usbd_cdc_Setup+0x4e>
 80019a8:	2b0b      	cmp	r3, #11
 80019aa:	d02d      	beq.n	8001a08 <usbd_cdc_Setup+0x74>
 80019ac:	2b06      	cmp	r3, #6
 80019ae:	d031      	beq.n	8001a14 <usbd_cdc_Setup+0x80>
        USBD_CtlError (pdev, req);
      }
      break;
    }
  }
  return USBD_OK;
 80019b0:	4628      	mov	r0, r5
}
 80019b2:	bd70      	pop	{r4, r5, r6, pc}
                                USB_SETUP_REQ *req)
{
  uint16_t len;
  uint8_t  *pbuf;
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80019b4:	2d20      	cmp	r5, #32
 80019b6:	d003      	beq.n	80019c0 <usbd_cdc_Setup+0x2c>
      }
      
      return USBD_OK;
      
    default:
      USBD_CtlError (pdev, req);
 80019b8:	f001 fd0e 	bl	80033d8 <USBD_CtlError>
      return USBD_FAIL;
 80019bc:	2002      	movs	r0, #2
 80019be:	bd70      	pop	{r4, r5, r6, pc}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
  {
    /* CDC Class Requests -------------------------------*/
  case USB_REQ_TYPE_CLASS :
      /* Check if the request is a data setup packet */
      if (req->wLength)
 80019c0:	88cd      	ldrh	r5, [r1, #6]
 80019c2:	2d00      	cmp	r5, #0
 80019c4:	d034      	beq.n	8001a30 <usbd_cdc_Setup+0x9c>
      {
        /* Check if the request is Device-to-Host */
        if (req->bmRequest & 0x80)
 80019c6:	f013 0f80 	tst.w	r3, #128	; 0x80
 80019ca:	d110      	bne.n	80019ee <usbd_cdc_Setup+0x5a>
                            req->wLength);          
        }
        else /* Host-to-Device requeset */
        {
          /* Set the value of the current command to be processed */
          cdcCmd = req->bRequest;
 80019cc:	784a      	ldrb	r2, [r1, #1]
 80019ce:	4b1e      	ldr	r3, [pc, #120]	; (8001a48 <usbd_cdc_Setup+0xb4>)
          cdcLen = req->wLength;
          
          /* Prepare the reception of the buffer over EP0
          Next step: the received data will be managed in usbd_cdc_EP0_TxSent() 
          function. */
          USBD_CtlPrepareRx (pdev,
 80019d0:	491e      	ldr	r1, [pc, #120]	; (8001a4c <usbd_cdc_Setup+0xb8>)
                            req->wLength);          
        }
        else /* Host-to-Device requeset */
        {
          /* Set the value of the current command to be processed */
          cdcCmd = req->bRequest;
 80019d2:	601a      	str	r2, [r3, #0]
          cdcLen = req->wLength;
 80019d4:	4b1e      	ldr	r3, [pc, #120]	; (8001a50 <usbd_cdc_Setup+0xbc>)
          
          /* Prepare the reception of the buffer over EP0
          Next step: the received data will be managed in usbd_cdc_EP0_TxSent() 
          function. */
          USBD_CtlPrepareRx (pdev,
 80019d6:	462a      	mov	r2, r5
        }
        else /* Host-to-Device requeset */
        {
          /* Set the value of the current command to be processed */
          cdcCmd = req->bRequest;
          cdcLen = req->wLength;
 80019d8:	601d      	str	r5, [r3, #0]
          
          /* Prepare the reception of the buffer over EP0
          Next step: the received data will be managed in usbd_cdc_EP0_TxSent() 
          function. */
          USBD_CtlPrepareRx (pdev,
 80019da:	f001 fc91 	bl	8003300 <USBD_CtlPrepareRx>
      {
        /* Transfer the command to the interface layer */
        APP_FOPS.pIf_Ctrl(req->bRequest, NULL, 0);
      }
      
      return USBD_OK;
 80019de:	2000      	movs	r0, #0
 80019e0:	bd70      	pop	{r4, r5, r6, pc}
                        pbuf,
                        len);
      break;
      
    case USB_REQ_GET_INTERFACE :
      USBD_CtlSendData (pdev,
 80019e2:	491c      	ldr	r1, [pc, #112]	; (8001a54 <usbd_cdc_Setup+0xc0>)
 80019e4:	2201      	movs	r2, #1
 80019e6:	f001 fc71 	bl	80032cc <USBD_CtlSendData>
        USBD_CtlError (pdev, req);
      }
      break;
    }
  }
  return USBD_OK;
 80019ea:	4628      	mov	r0, r5
      
    case USB_REQ_GET_INTERFACE :
      USBD_CtlSendData (pdev,
                        (uint8_t *)&usbd_cdc_AltSet,
                        1);
      break;
 80019ec:	bd70      	pop	{r4, r5, r6, pc}
      {
        /* Check if the request is Device-to-Host */
        if (req->bmRequest & 0x80)
        {
          /* Get the data to be sent to Host from interface layer */
          APP_FOPS.pIf_Ctrl(req->bRequest, CmdBuff, req->wLength);
 80019ee:	481a      	ldr	r0, [pc, #104]	; (8001a58 <usbd_cdc_Setup+0xc4>)
 80019f0:	4916      	ldr	r1, [pc, #88]	; (8001a4c <usbd_cdc_Setup+0xb8>)
 80019f2:	6883      	ldr	r3, [r0, #8]
 80019f4:	7860      	ldrb	r0, [r4, #1]
 80019f6:	462a      	mov	r2, r5
 80019f8:	4798      	blx	r3
          
          /* Send the data to the host */
          USBD_CtlSendData (pdev, 
 80019fa:	4630      	mov	r0, r6
 80019fc:	4913      	ldr	r1, [pc, #76]	; (8001a4c <usbd_cdc_Setup+0xb8>)
 80019fe:	88e2      	ldrh	r2, [r4, #6]
 8001a00:	f001 fc64 	bl	80032cc <USBD_CtlSendData>
      {
        /* Transfer the command to the interface layer */
        APP_FOPS.pIf_Ctrl(req->bRequest, NULL, 0);
      }
      
      return USBD_OK;
 8001a04:	2000      	movs	r0, #0
 8001a06:	bd70      	pop	{r4, r5, r6, pc}
                        (uint8_t *)&usbd_cdc_AltSet,
                        1);
      break;
      
    case USB_REQ_SET_INTERFACE :
      if ((uint8_t)(req->wValue) < USBD_ITF_MAX_NUM)
 8001a08:	788b      	ldrb	r3, [r1, #2]
 8001a0a:	b9cb      	cbnz	r3, 8001a40 <usbd_cdc_Setup+0xac>
      {
        usbd_cdc_AltSet = (uint8_t)(req->wValue);
 8001a0c:	4a10      	ldr	r2, [pc, #64]	; (8001a50 <usbd_cdc_Setup+0xbc>)
        USBD_CtlError (pdev, req);
      }
      break;
    }
  }
  return USBD_OK;
 8001a0e:	4618      	mov	r0, r3
      break;
      
    case USB_REQ_SET_INTERFACE :
      if ((uint8_t)(req->wValue) < USBD_ITF_MAX_NUM)
      {
        usbd_cdc_AltSet = (uint8_t)(req->wValue);
 8001a10:	6193      	str	r3, [r2, #24]
 8001a12:	bd70      	pop	{r4, r5, r6, pc}
    /* Standard Requests -------------------------------*/
  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
    {
    case USB_REQ_GET_DESCRIPTOR: 
      if( (req->wValue >> 8) == CDC_DESCRIPTOR_TYPE)
 8001a14:	884b      	ldrh	r3, [r1, #2]
 8001a16:	0a18      	lsrs	r0, r3, #8
 8001a18:	2821      	cmp	r0, #33	; 0x21
 8001a1a:	d103      	bne.n	8001a24 <usbd_cdc_Setup+0x90>
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
        pbuf = usbd_cdc_Desc;   
#else
        pbuf = usbd_cdc_CfgDesc + 9 + (9 * USBD_ITF_MAX_NUM);
#endif 
        len = MIN(USB_CDC_DESC_SIZ , req->wLength);
 8001a1c:	88ca      	ldrh	r2, [r1, #6]
 8001a1e:	2a3a      	cmp	r2, #58	; 0x3a
 8001a20:	bf28      	it	cs
 8001a22:	223a      	movcs	r2, #58	; 0x3a
      }
      
      USBD_CtlSendData (pdev, 
 8001a24:	4630      	mov	r0, r6
 8001a26:	490d      	ldr	r1, [pc, #52]	; (8001a5c <usbd_cdc_Setup+0xc8>)
 8001a28:	f001 fc50 	bl	80032cc <USBD_CtlSendData>
        USBD_CtlError (pdev, req);
      }
      break;
    }
  }
  return USBD_OK;
 8001a2c:	2000      	movs	r0, #0
      }
      
      USBD_CtlSendData (pdev, 
                        pbuf,
                        len);
      break;
 8001a2e:	bd70      	pop	{r4, r5, r6, pc}
        }
      }
      else /* No Data request */
      {
        /* Transfer the command to the interface layer */
        APP_FOPS.pIf_Ctrl(req->bRequest, NULL, 0);
 8001a30:	7848      	ldrb	r0, [r1, #1]
 8001a32:	4909      	ldr	r1, [pc, #36]	; (8001a58 <usbd_cdc_Setup+0xc4>)
 8001a34:	462a      	mov	r2, r5
 8001a36:	688b      	ldr	r3, [r1, #8]
 8001a38:	4629      	mov	r1, r5
 8001a3a:	4798      	blx	r3
      }
      
      return USBD_OK;
 8001a3c:	4628      	mov	r0, r5
 8001a3e:	bd70      	pop	{r4, r5, r6, pc}
        usbd_cdc_AltSet = (uint8_t)(req->wValue);
      }
      else
      {
        /* Call the error management function (command will be nacked */
        USBD_CtlError (pdev, req);
 8001a40:	f001 fcca 	bl	80033d8 <USBD_CtlError>
      }
      break;
    }
  }
  return USBD_OK;
 8001a44:	4628      	mov	r0, r5
 8001a46:	bd70      	pop	{r4, r5, r6, pc}
 8001a48:	200000a8 	.word	0x200000a8
 8001a4c:	200012a8 	.word	0x200012a8
 8001a50:	200007f0 	.word	0x200007f0
 8001a54:	20000808 	.word	0x20000808
 8001a58:	20000014 	.word	0x20000014
 8001a5c:	200000be 	.word	0x200000be

08001a60 <usbd_cdc_DeInit>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  usbd_cdc_DeInit (void  *pdev, 
                                 uint8_t cfgidx)
{
 8001a60:	b510      	push	{r4, lr}
  /* Open EP IN */
  DCD_EP_Close(pdev,
 8001a62:	2181      	movs	r1, #129	; 0x81
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  usbd_cdc_DeInit (void  *pdev, 
                                 uint8_t cfgidx)
{
 8001a64:	4604      	mov	r4, r0
  /* Open EP IN */
  DCD_EP_Close(pdev,
 8001a66:	f000 ff6d 	bl	8002944 <DCD_EP_Close>
              CDC_IN_EP);
  
  /* Open EP OUT */
  DCD_EP_Close(pdev,
 8001a6a:	2101      	movs	r1, #1
 8001a6c:	4620      	mov	r0, r4
 8001a6e:	f000 ff69 	bl	8002944 <DCD_EP_Close>
              CDC_OUT_EP);
  
  /* Open Command IN EP */
  DCD_EP_Close(pdev,
 8001a72:	2182      	movs	r1, #130	; 0x82
 8001a74:	4620      	mov	r0, r4
 8001a76:	f000 ff65 	bl	8002944 <DCD_EP_Close>
              CDC_CMD_EP);

  /* Restore default state of the Interface physical components */
  APP_FOPS.pIf_DeInit();
 8001a7a:	4802      	ldr	r0, [pc, #8]	; (8001a84 <usbd_cdc_DeInit+0x24>)
 8001a7c:	6843      	ldr	r3, [r0, #4]
 8001a7e:	4798      	blx	r3
  
  return USBD_OK;
}
 8001a80:	2000      	movs	r0, #0
 8001a82:	bd10      	pop	{r4, pc}
 8001a84:	20000014 	.word	0x20000014

08001a88 <usbd_cdc_Init>:
                               uint8_t cfgidx)
{
  uint8_t *pbuf;

  /* Open EP IN */
  DCD_EP_Open(pdev,
 8001a88:	f8d0 25ec 	ldr.w	r2, [r0, #1516]	; 0x5ec
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  usbd_cdc_Init (void  *pdev, 
                               uint8_t cfgidx)
{
 8001a8c:	b538      	push	{r3, r4, r5, lr}
 8001a8e:	4604      	mov	r4, r0
  uint8_t *pbuf;

  /* Open EP IN */
  DCD_EP_Open(pdev,
 8001a90:	2181      	movs	r1, #129	; 0x81
 8001a92:	2302      	movs	r3, #2
 8001a94:	f8b2 2039 	ldrh.w	r2, [r2, #57]	; 0x39
 8001a98:	f000 ff34 	bl	8002904 <DCD_EP_Open>
              CDC_IN_EP,
              CDC_DATA_IN_PACKET_SIZE,
              USB_OTG_EP_BULK);
  
  /* Open EP OUT */
  DCD_EP_Open(pdev,
 8001a9c:	f8d4 55ec 	ldr.w	r5, [r4, #1516]	; 0x5ec
 8001aa0:	2101      	movs	r1, #1
 8001aa2:	f8b5 2040 	ldrh.w	r2, [r5, #64]	; 0x40
 8001aa6:	2302      	movs	r3, #2
 8001aa8:	4620      	mov	r0, r4
 8001aaa:	f000 ff2b 	bl	8002904 <DCD_EP_Open>
              CDC_OUT_EP,
              CDC_DATA_OUT_PACKET_SIZE,
              USB_OTG_EP_BULK);
  
  /* Open Command IN EP */
  DCD_EP_Open(pdev,
 8001aae:	2182      	movs	r1, #130	; 0x82
 8001ab0:	2208      	movs	r2, #8
 8001ab2:	2303      	movs	r3, #3
 8001ab4:	4620      	mov	r0, r4
 8001ab6:	f000 ff25 	bl	8002904 <DCD_EP_Open>
              CDC_CMD_EP,
              CDC_CMD_PACKET_SZE,
              USB_OTG_EP_INT);
  
  pbuf = (uint8_t *)USBD_DeviceDesc;
  pbuf[4] = DEVICE_CLASS_CDC;
 8001aba:	4b09      	ldr	r3, [pc, #36]	; (8001ae0 <usbd_cdc_Init+0x58>)
  pbuf[5] = DEVICE_SUBCLASS_CDC;
  
  /* Initialize the Interface physical components */
  APP_FOPS.pIf_Init();
 8001abc:	4909      	ldr	r1, [pc, #36]	; (8001ae4 <usbd_cdc_Init+0x5c>)
              CDC_CMD_EP,
              CDC_CMD_PACKET_SZE,
              USB_OTG_EP_INT);
  
  pbuf = (uint8_t *)USBD_DeviceDesc;
  pbuf[4] = DEVICE_CLASS_CDC;
 8001abe:	2202      	movs	r2, #2
  pbuf[5] = DEVICE_SUBCLASS_CDC;
 8001ac0:	2500      	movs	r5, #0
              CDC_CMD_EP,
              CDC_CMD_PACKET_SZE,
              USB_OTG_EP_INT);
  
  pbuf = (uint8_t *)USBD_DeviceDesc;
  pbuf[4] = DEVICE_CLASS_CDC;
 8001ac2:	711a      	strb	r2, [r3, #4]
  pbuf[5] = DEVICE_SUBCLASS_CDC;
 8001ac4:	715d      	strb	r5, [r3, #5]
  
  /* Initialize the Interface physical components */
  APP_FOPS.pIf_Init();
 8001ac6:	6808      	ldr	r0, [r1, #0]
 8001ac8:	4780      	blx	r0

  /* Prepare Out endpoint to receive next packet */
  DCD_EP_PrepareRx(pdev,
 8001aca:	f8d4 35ec 	ldr.w	r3, [r4, #1516]	; 0x5ec
 8001ace:	4a06      	ldr	r2, [pc, #24]	; (8001ae8 <usbd_cdc_Init+0x60>)
 8001ad0:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8001ad4:	4620      	mov	r0, r4
 8001ad6:	2101      	movs	r1, #1
 8001ad8:	f000 ff4a 	bl	8002970 <DCD_EP_PrepareRx>
                   CDC_OUT_EP,
                   (uint8_t*)(USB_Rx_Buffer),
                   CDC_DATA_OUT_PACKET_SIZE);
  
  return USBD_OK;
}
 8001adc:	4628      	mov	r0, r5
 8001ade:	bd38      	pop	{r3, r4, r5, pc}
 8001ae0:	20000058 	.word	0x20000058
 8001ae4:	20000014 	.word	0x20000014
 8001ae8:	20001268 	.word	0x20001268

08001aec <USB_OTG_CoreReset.clone.1>:
/**
* @brief  USB_OTG_CoreReset : Soft reset of the core
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
 8001aec:	b530      	push	{r4, r5, lr}
 8001aee:	4605      	mov	r5, r0
 8001af0:	b083      	sub	sp, #12
{
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 8001af2:	2300      	movs	r3, #0
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 8001af4:	2003      	movs	r0, #3
{
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 8001af6:	9301      	str	r3, [sp, #4]
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 8001af8:	f001 ff21 	bl	800393e <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001afc:	682b      	ldr	r3, [r5, #0]
 8001afe:	4c1b      	ldr	r4, [pc, #108]	; (8001b6c <USB_OTG_CoreReset.clone.1+0x80>)
 8001b00:	691a      	ldr	r2, [r3, #16]
 8001b02:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
    {
      return USB_OTG_OK;
    }
  }
  while (greset.b.ahbidle == 0);
 8001b04:	9a01      	ldr	r2, [sp, #4]
 8001b06:	2a00      	cmp	r2, #0
 8001b08:	db14      	blt.n	8001b34 <USB_OTG_CoreReset.clone.1+0x48>
  
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 8001b0a:	2003      	movs	r0, #3
 8001b0c:	f001 ff17 	bl	800393e <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b10:	682b      	ldr	r3, [r5, #0]
 8001b12:	6919      	ldr	r1, [r3, #16]
 8001b14:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
    {
      return USB_OTG_OK;
    }
  }
  while (greset.b.ahbidle == 0);
 8001b16:	9801      	ldr	r0, [sp, #4]
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b18:	3c01      	subs	r4, #1
    if (++count > 200000)
    {
      return USB_OTG_OK;
    }
  }
  while (greset.b.ahbidle == 0);
 8001b1a:	2800      	cmp	r0, #0
 8001b1c:	db0a      	blt.n	8001b34 <USB_OTG_CoreReset.clone.1+0x48>
  
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 8001b1e:	2003      	movs	r0, #3
 8001b20:	f001 ff0d 	bl	800393e <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b24:	682b      	ldr	r3, [r5, #0]
 8001b26:	691a      	ldr	r2, [r3, #16]
    if (++count > 200000)
 8001b28:	3c01      	subs	r4, #1
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b2a:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 8001b2c:	d1ea      	bne.n	8001b04 <USB_OTG_CoreReset.clone.1+0x18>
  }
  while (greset.b.csftrst == 1);
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
  return status;
}
 8001b2e:	2000      	movs	r0, #0
 8001b30:	b003      	add	sp, #12
 8001b32:	bd30      	pop	{r4, r5, pc}
    }
  }
  while (greset.b.ahbidle == 0);
  /* Core Soft Reset */
  count = 0;
  greset.b.csftrst = 1;
 8001b34:	9901      	ldr	r1, [sp, #4]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b36:	4a0d      	ldr	r2, [pc, #52]	; (8001b6c <USB_OTG_CoreReset.clone.1+0x80>)
    }
  }
  while (greset.b.ahbidle == 0);
  /* Core Soft Reset */
  count = 0;
  greset.b.csftrst = 1;
 8001b38:	f041 0001 	orr.w	r0, r1, #1
 8001b3c:	9001      	str	r0, [sp, #4]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8001b3e:	9901      	ldr	r1, [sp, #4]
 8001b40:	6119      	str	r1, [r3, #16]
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b42:	6918      	ldr	r0, [r3, #16]
 8001b44:	9001      	str	r0, [sp, #4]
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.csftrst == 1);
 8001b46:	9801      	ldr	r0, [sp, #4]
 8001b48:	f010 0f01 	tst.w	r0, #1
 8001b4c:	d00a      	beq.n	8001b64 <USB_OTG_CoreReset.clone.1+0x78>
  count = 0;
  greset.b.csftrst = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b4e:	6919      	ldr	r1, [r3, #16]
 8001b50:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.csftrst == 1);
 8001b52:	9801      	ldr	r0, [sp, #4]
  count = 0;
  greset.b.csftrst = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b54:	3a01      	subs	r2, #1
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.csftrst == 1);
 8001b56:	f010 0f01 	tst.w	r0, #1
 8001b5a:	d003      	beq.n	8001b64 <USB_OTG_CoreReset.clone.1+0x78>
  count = 0;
  greset.b.csftrst = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b5c:	6919      	ldr	r1, [r3, #16]
    if (++count > 200000)
 8001b5e:	3a01      	subs	r2, #1
  count = 0;
  greset.b.csftrst = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b60:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
 8001b62:	d1f0      	bne.n	8001b46 <USB_OTG_CoreReset.clone.1+0x5a>
      break;
    }
  }
  while (greset.b.csftrst == 1);
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 8001b64:	2003      	movs	r0, #3
 8001b66:	f001 feea 	bl	800393e <USB_OTG_BSP_uDelay>
 8001b6a:	e7e0      	b.n	8001b2e <USB_OTG_CoreReset.clone.1+0x42>
 8001b6c:	00030d40 	.word	0x00030d40

08001b70 <USB_OTG_WritePacket>:
*/
USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t             *src, 
                                uint8_t             ch_ep_num, 
                                uint16_t            len)
{
 8001b70:	b430      	push	{r4, r5}
  USB_OTG_STS status = USB_OTG_OK;
  if (pdev->cfg.dma_enable == 0)
 8001b72:	78c4      	ldrb	r4, [r0, #3]
 8001b74:	bb04      	cbnz	r4, 8001bb8 <USB_OTG_WritePacket+0x48>
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
 8001b76:	eb00 0082 	add.w	r0, r0, r2, lsl #2
  if (pdev->cfg.dma_enable == 0)
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
 8001b7a:	3303      	adds	r3, #3
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001b7c:	109b      	asrs	r3, r3, #2
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
 8001b7e:	f8d0 40d0 	ldr.w	r4, [r0, #208]	; 0xd0
    for (i = 0; i < count32b; i++, src+=4)
 8001b82:	d019      	beq.n	8001bb8 <USB_OTG_WritePacket+0x48>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001b84:	f851 2b04 	ldr.w	r2, [r1], #4
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001b88:	2001      	movs	r0, #1
 8001b8a:	1e5d      	subs	r5, r3, #1
 8001b8c:	4283      	cmp	r3, r0
 8001b8e:	f005 0501 	and.w	r5, r5, #1
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001b92:	6022      	str	r2, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001b94:	d010      	beq.n	8001bb8 <USB_OTG_WritePacket+0x48>
 8001b96:	b12d      	cbz	r5, 8001ba4 <USB_OTG_WritePacket+0x34>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001b98:	f851 2b04 	ldr.w	r2, [r1], #4
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001b9c:	2002      	movs	r0, #2
 8001b9e:	4283      	cmp	r3, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001ba0:	6022      	str	r2, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001ba2:	d009      	beq.n	8001bb8 <USB_OTG_WritePacket+0x48>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001ba4:	460a      	mov	r2, r1
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001ba6:	3002      	adds	r0, #2
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001ba8:	f852 5b04 	ldr.w	r5, [r2], #4
 8001bac:	6025      	str	r5, [r4, #0]
 8001bae:	684d      	ldr	r5, [r1, #4]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001bb0:	1d11      	adds	r1, r2, #4
 8001bb2:	4283      	cmp	r3, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001bb4:	6025      	str	r5, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001bb6:	d1f5      	bne.n	8001ba4 <USB_OTG_WritePacket+0x34>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
    }
  }
  return status;
}
 8001bb8:	2000      	movs	r0, #0
 8001bba:	bc30      	pop	{r4, r5}
 8001bbc:	4770      	bx	lr
 8001bbe:	bf00      	nop

08001bc0 <USB_OTG_ReadPacket>:
void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
                         uint8_t *dest, 
                         uint16_t len)
{
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
 8001bc0:	3203      	adds	r2, #3
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001bc2:	1092      	asrs	r2, r2, #2
* @retval None
*/
void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
                         uint8_t *dest, 
                         uint16_t len)
{
 8001bc4:	b470      	push	{r4, r5, r6}
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
 8001bc6:	f8d0 50d0 	ldr.w	r5, [r0, #208]	; 0xd0
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001bca:	d01c      	beq.n	8001c06 <USB_OTG_ReadPacket+0x46>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001bcc:	682c      	ldr	r4, [r5, #0]
 8001bce:	460b      	mov	r3, r1
 8001bd0:	1e50      	subs	r0, r2, #1
 8001bd2:	f843 4b04 	str.w	r4, [r3], #4
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001bd6:	2401      	movs	r4, #1
 8001bd8:	42a2      	cmp	r2, r4
 8001bda:	f000 0001 	and.w	r0, r0, #1
 8001bde:	d010      	beq.n	8001c02 <USB_OTG_ReadPacket+0x42>
 8001be0:	b128      	cbz	r0, 8001bee <USB_OTG_ReadPacket+0x2e>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001be2:	6828      	ldr	r0, [r5, #0]
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001be4:	2402      	movs	r4, #2
 8001be6:	42a2      	cmp	r2, r4
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001be8:	f843 0b04 	str.w	r0, [r3], #4
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001bec:	d009      	beq.n	8001c02 <USB_OTG_ReadPacket+0x42>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001bee:	682e      	ldr	r6, [r5, #0]
 8001bf0:	4618      	mov	r0, r3
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001bf2:	3402      	adds	r4, #2
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001bf4:	f840 6b04 	str.w	r6, [r0], #4
 8001bf8:	682e      	ldr	r6, [r5, #0]
 8001bfa:	605e      	str	r6, [r3, #4]
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001bfc:	1d03      	adds	r3, r0, #4
 8001bfe:	42a2      	cmp	r2, r4
 8001c00:	d1f5      	bne.n	8001bee <USB_OTG_ReadPacket+0x2e>
 8001c02:	eb01 0182 	add.w	r1, r1, r2, lsl #2
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
    
  }
  return ((void *)dest);
}
 8001c06:	4608      	mov	r0, r1
 8001c08:	bc70      	pop	{r4, r5, r6}
 8001c0a:	4770      	bx	lr

08001c0c <USB_OTG_SelectCore>:
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
                               USB_OTG_CORE_ID_TypeDef coreID)
{
 8001c0c:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  uint32_t i , baseAddress = 0;
  USB_OTG_STS status = USB_OTG_OK;
  
  pdev->cfg.dma_enable       = 0;
 8001c10:	2300      	movs	r3, #0
  
  /* at startup the core is in FS mode */
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8001c12:	2701      	movs	r7, #1
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
 8001c14:	2240      	movs	r2, #64	; 0x40
    
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
 8001c16:	2901      	cmp	r1, #1
                               USB_OTG_CORE_ID_TypeDef coreID)
{
  uint32_t i , baseAddress = 0;
  USB_OTG_STS status = USB_OTG_OK;
  
  pdev->cfg.dma_enable       = 0;
 8001c18:	70c3      	strb	r3, [r0, #3]
  
  /* at startup the core is in FS mode */
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8001c1a:	7087      	strb	r7, [r0, #2]
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
 8001c1c:	8082      	strh	r2, [r0, #4]
    
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
 8001c1e:	f000 80a6 	beq.w	8001d6e <USB_OTG_SelectCore+0x162>
    
#ifdef USB_OTG_FS_LOW_PWR_MGMT_SUPPORT    
    pdev->cfg.low_power        = 1;    
#endif     
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
 8001c22:	2900      	cmp	r1, #0
 8001c24:	f000 808c 	beq.w	8001d40 <USB_OTG_SelectCore+0x134>
 8001c28:	7847      	ldrb	r7, [r0, #1]
 8001c2a:	f890 8000 	ldrb.w	r8, [r0]
    pdev->cfg.low_power        = 1;    
#endif 
    
  }
  
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
 8001c2e:	60c3      	str	r3, [r0, #12]
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
 8001c30:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8001c34:	6102      	str	r2, [r0, #16]
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c36:	2f00      	cmp	r7, #0
 8001c38:	f000 80b0 	beq.w	8001d9c <USB_OTG_SelectCore+0x190>
 8001c3c:	f44f 6a60 	mov.w	sl, #3584	; 0xe00
 8001c40:	f44f 6988 	mov.w	r9, #1088	; 0x440
 8001c44:	f44f 6b80 	mov.w	fp, #1024	; 0x400
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
                               USB_OTG_CORE_ID_TypeDef coreID)
{
  uint32_t i , baseAddress = 0;
 8001c48:	469c      	mov	ip, r3
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001c4a:	4602      	mov	r2, r0
 8001c4c:	f50c 6410 	add.w	r4, ip, #2304	; 0x900
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8001c50:	f842 4f18 	str.w	r4, [r2, #24]!
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c54:	2401      	movs	r4, #1
 8001c56:	1e7b      	subs	r3, r7, #1
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001c58:	f50c 6130 	add.w	r1, ip, #2816	; 0xb00
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c5c:	42bc      	cmp	r4, r7
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8001c5e:	63d1      	str	r1, [r2, #60]	; 0x3c
 8001c60:	ea03 0104 	and.w	r1, r3, r4
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c64:	f50c 6312 	add.w	r3, ip, #2336	; 0x920
 8001c68:	d21c      	bcs.n	8001ca4 <USB_OTG_SelectCore+0x98>
 8001c6a:	b151      	cbz	r1, 8001c82 <USB_OTG_SelectCore+0x76>
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001c6c:	4602      	mov	r2, r0
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c6e:	2402      	movs	r4, #2
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8001c70:	f842 3f1c 	str.w	r3, [r2, #28]!
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001c74:	f50c 6132 	add.w	r1, ip, #2848	; 0xb20
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c78:	42bc      	cmp	r4, r7
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8001c7a:	63d1      	str	r1, [r2, #60]	; 0x3c
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c7c:	f50c 6314 	add.w	r3, ip, #2368	; 0x940
 8001c80:	d210      	bcs.n	8001ca4 <USB_OTG_SelectCore+0x98>
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001c82:	1d11      	adds	r1, r2, #4
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8001c84:	6053      	str	r3, [r2, #4]
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c86:	3402      	adds	r4, #2
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001c88:	3208      	adds	r2, #8
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c8a:	f103 0520 	add.w	r5, r3, #32
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001c8e:	f503 7600 	add.w	r6, r3, #512	; 0x200
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c92:	42bc      	cmp	r4, r7
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001c94:	f503 7308 	add.w	r3, r3, #544	; 0x220
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8001c98:	63ce      	str	r6, [r1, #60]	; 0x3c
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8001c9a:	604d      	str	r5, [r1, #4]
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8001c9c:	63d3      	str	r3, [r2, #60]	; 0x3c
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c9e:	f105 0320 	add.w	r3, r5, #32
 8001ca2:	d3ee      	bcc.n	8001c82 <USB_OTG_SelectCore+0x76>
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
 8001ca4:	f8c0 b014 	str.w	fp, [r0, #20]
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
 8001ca8:	f8c0 90cc 	str.w	r9, [r0, #204]	; 0xcc
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001cac:	f1b8 0f00 	cmp.w	r8, #0
 8001cb0:	d040      	beq.n	8001d34 <USB_OTG_SelectCore+0x128>
 8001cb2:	f50c 61a0 	add.w	r1, ip, #1280	; 0x500
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001cb6:	ea4f 1548 	mov.w	r5, r8, lsl #5
 8001cba:	f1a5 0420 	sub.w	r4, r5, #32
 8001cbe:	4602      	mov	r2, r0
 8001cc0:	186d      	adds	r5, r5, r1
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8001cc2:	f50c 63a4 	add.w	r3, ip, #1312	; 0x520
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001cc6:	42ab      	cmp	r3, r5
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8001cc8:	f842 1f90 	str.w	r1, [r2, #144]!
 8001ccc:	f3c4 1440 	ubfx	r4, r4, #5, #1
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001cd0:	d00f      	beq.n	8001cf2 <USB_OTG_SelectCore+0xe6>
 8001cd2:	b134      	cbz	r4, 8001ce2 <USB_OTG_SelectCore+0xd6>
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001cd4:	4602      	mov	r2, r0
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8001cd6:	f842 3f94 	str.w	r3, [r2, #148]!
 8001cda:	f50c 63a8 	add.w	r3, ip, #1344	; 0x540
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001cde:	42ab      	cmp	r3, r5
 8001ce0:	d007      	beq.n	8001cf2 <USB_OTG_SelectCore+0xe6>
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8001ce2:	f103 0420 	add.w	r4, r3, #32
 8001ce6:	6053      	str	r3, [r2, #4]
 8001ce8:	3340      	adds	r3, #64	; 0x40
 8001cea:	6094      	str	r4, [r2, #8]
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001cec:	3208      	adds	r2, #8
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001cee:	42ab      	cmp	r3, r5
 8001cf0:	d1f7      	bne.n	8001ce2 <USB_OTG_SelectCore+0xd6>
 8001cf2:	f50c 5180 	add.w	r1, ip, #4096	; 0x1000
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001cf6:	ea4f 3808 	mov.w	r8, r8, lsl #12
 8001cfa:	f5a8 5480 	sub.w	r4, r8, #4096	; 0x1000
 8001cfe:	4602      	mov	r2, r0
 8001d00:	4488      	add	r8, r1
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8001d02:	f50c 5300 	add.w	r3, ip, #8192	; 0x2000
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001d06:	4543      	cmp	r3, r8
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8001d08:	f842 1fd0 	str.w	r1, [r2, #208]!
 8001d0c:	f3c4 3400 	ubfx	r4, r4, #12, #1
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001d10:	d010      	beq.n	8001d34 <USB_OTG_SelectCore+0x128>
 8001d12:	b134      	cbz	r4, 8001d22 <USB_OTG_SelectCore+0x116>
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001d14:	4602      	mov	r2, r0
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8001d16:	f842 3fd4 	str.w	r3, [r2, #212]!
 8001d1a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001d1e:	4543      	cmp	r3, r8
 8001d20:	d008      	beq.n	8001d34 <USB_OTG_SelectCore+0x128>
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8001d22:	f503 5480 	add.w	r4, r3, #4096	; 0x1000
 8001d26:	6053      	str	r3, [r2, #4]
 8001d28:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8001d2c:	6094      	str	r4, [r2, #8]
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001d2e:	3208      	adds	r2, #8
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001d30:	4543      	cmp	r3, r8
 8001d32:	d1f6      	bne.n	8001d22 <USB_OTG_SelectCore+0x116>
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
      (i * USB_OTG_DATA_FIFO_SIZE));
  }
  pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
 8001d34:	f8c0 a10c 	str.w	sl, [r0, #268]	; 0x10c
  
  return status;
}
 8001d38:	2000      	movs	r0, #0
 8001d3a:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001d3e:	4770      	bx	lr
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001d40:	f44f 69a0 	mov.w	r9, #1280	; 0x500
 8001d44:	4b19      	ldr	r3, [pc, #100]	; (8001dac <USB_OTG_SelectCore+0x1a0>)
 8001d46:	f8a0 9006 	strh.w	r9, [r0, #6]
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
 8001d4a:	f04f 080c 	mov.w	r8, #12
    pdev->cfg.dev_endpoints    = 6 ;
 8001d4e:	2706      	movs	r7, #6
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001d50:	f8df a064 	ldr.w	sl, [pc, #100]	; 8001db8 <USB_OTG_SelectCore+0x1ac>
 8001d54:	f8df 9064 	ldr.w	r9, [pc, #100]	; 8001dbc <USB_OTG_SelectCore+0x1b0>
 8001d58:	f8df b064 	ldr.w	fp, [pc, #100]	; 8001dc0 <USB_OTG_SelectCore+0x1b4>
 8001d5c:	4a14      	ldr	r2, [pc, #80]	; (8001db0 <USB_OTG_SelectCore+0x1a4>)
#endif     
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
 8001d5e:	72c1      	strb	r1, [r0, #11]
    pdev->cfg.host_channels    = 12 ;
 8001d60:	f880 8000 	strb.w	r8, [r0]
    pdev->cfg.dev_endpoints    = 6 ;
 8001d64:	7047      	strb	r7, [r0, #1]
    pdev->cfg.low_power        = 1;    
#endif     
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
 8001d66:	469c      	mov	ip, r3
    pdev->cfg.low_power        = 1;    
#endif 
    
  }
  
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
 8001d68:	60c3      	str	r3, [r0, #12]
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
 8001d6a:	6102      	str	r2, [r0, #16]
 8001d6c:	e76d      	b.n	8001c4a <USB_OTG_SelectCore+0x3e>
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
    pdev->cfg.host_channels    = 8 ;
 8001d6e:	f04f 0808 	mov.w	r8, #8
    pdev->cfg.dev_endpoints    = 4 ;
 8001d72:	2704      	movs	r7, #4
    pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
 8001d74:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
 8001d78:	72c1      	strb	r1, [r0, #11]
    pdev->cfg.host_channels    = 8 ;
    pdev->cfg.dev_endpoints    = 4 ;
    pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
 8001d7a:	f44f 74a0 	mov.w	r4, #320	; 0x140
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
 8001d7e:	2102      	movs	r1, #2
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
    pdev->cfg.host_channels    = 8 ;
 8001d80:	f880 8000 	strb.w	r8, [r0]
    pdev->cfg.dev_endpoints    = 4 ;
 8001d84:	7047      	strb	r7, [r0, #1]
    pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
 8001d86:	80c4      	strh	r4, [r0, #6]
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
 8001d88:	7201      	strb	r1, [r0, #8]
 8001d8a:	f8df a038 	ldr.w	sl, [pc, #56]	; 8001dc4 <USB_OTG_SelectCore+0x1b8>
 8001d8e:	f8df 9038 	ldr.w	r9, [pc, #56]	; 8001dc8 <USB_OTG_SelectCore+0x1bc>
 8001d92:	f8df b038 	ldr.w	fp, [pc, #56]	; 8001dcc <USB_OTG_SelectCore+0x1c0>
 8001d96:	4a07      	ldr	r2, [pc, #28]	; (8001db4 <USB_OTG_SelectCore+0x1a8>)
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
    
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
 8001d98:	469c      	mov	ip, r3
 8001d9a:	e7e5      	b.n	8001d68 <USB_OTG_SelectCore+0x15c>
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001d9c:	f44f 6a60 	mov.w	sl, #3584	; 0xe00
 8001da0:	f44f 6988 	mov.w	r9, #1088	; 0x440
 8001da4:	f44f 6b80 	mov.w	fp, #1024	; 0x400
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
                               USB_OTG_CORE_ID_TypeDef coreID)
{
  uint32_t i , baseAddress = 0;
 8001da8:	46bc      	mov	ip, r7
 8001daa:	e77b      	b.n	8001ca4 <USB_OTG_SelectCore+0x98>
 8001dac:	40040000 	.word	0x40040000
 8001db0:	40040800 	.word	0x40040800
 8001db4:	50000800 	.word	0x50000800
 8001db8:	40040e00 	.word	0x40040e00
 8001dbc:	40040440 	.word	0x40040440
 8001dc0:	40040400 	.word	0x40040400
 8001dc4:	50000e00 	.word	0x50000e00
 8001dc8:	50000440 	.word	0x50000440
 8001dcc:	50000400 	.word	0x50000400

08001dd0 <USB_OTG_CoreInit>:
*         device mode or host mode operation.
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
{
 8001dd0:	b538      	push	{r3, r4, r5, lr}
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8001dd2:	7a03      	ldrb	r3, [r0, #8]
  USB_OTG_GI2CCTL_TypeDef  i2cctl;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  
  usbcfg.d32 = 0;
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
 8001dd4:	2500      	movs	r5, #0
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8001dd6:	2b01      	cmp	r3, #1
*         device mode or host mode operation.
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
{
 8001dd8:	4604      	mov	r4, r0
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8001dda:	d037      	beq.n	8001e4c <USB_OTG_CoreInit+0x7c>
    }    
  }
  else /* FS interface (embedded Phy or I2C Phy) */
  {
    
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
 8001ddc:	f850 3f0c 	ldr.w	r3, [r0, #12]!
 8001de0:	68d9      	ldr	r1, [r3, #12]
    usbcfg.b.physel  = 1; /* FS Interface */
 8001de2:	f041 0240 	orr.w	r2, r1, #64	; 0x40
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8001de6:	60da      	str	r2, [r3, #12]
    /* Reset after a PHY select and set Host mode */
    USB_OTG_CoreReset(pdev);
 8001de8:	f7ff fe80 	bl	8001aec <USB_OTG_CoreReset.clone.1>
    /* Enable the I2C interface and deactivate the power down*/
    gccfg.d32 = 0;
    gccfg.b.pwdn = 1;
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 8001dec:	f894 c008 	ldrb.w	ip, [r4, #8]
    gccfg.b.vbussensingB = 1 ;     
#ifndef VBUS_SENSING_ENABLED
    gccfg.b.disablevbussensing = 1; 
#endif    
    
    if(pdev->cfg.Sof_output)
 8001df0:	7a61      	ldrb	r1, [r4, #9]
    gccfg.d32 = 0;
    gccfg.b.pwdn = 1;
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
    {
      gccfg.b.i2cifen = 1;
 8001df2:	f1bc 0f03 	cmp.w	ip, #3
 8001df6:	bf14      	ite	ne
 8001df8:	f44f 3280 	movne.w	r2, #65536	; 0x10000
 8001dfc:	f44f 3240 	moveq.w	r2, #196608	; 0x30000
    }   
    gccfg.b.vbussensingA = 1 ;
    gccfg.b.vbussensingB = 1 ;     
#ifndef VBUS_SENSING_ENABLED
    gccfg.b.disablevbussensing = 1; 
 8001e00:	f442 1330 	orr.w	r3, r2, #2883584	; 0x2c0000
#endif    
    
    if(pdev->cfg.Sof_output)
 8001e04:	b109      	cbz	r1, 8001e0a <USB_OTG_CoreInit+0x3a>
    {
      gccfg.b.sofouten = 1;  
 8001e06:	f442 1370 	orr.w	r3, r2, #3932160	; 0x3c0000
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 8001e0a:	68e1      	ldr	r1, [r4, #12]
    USB_OTG_BSP_mDelay(20);
 8001e0c:	2014      	movs	r0, #20
    if(pdev->cfg.Sof_output)
    {
      gccfg.b.sofouten = 1;  
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 8001e0e:	638b      	str	r3, [r1, #56]	; 0x38
    USB_OTG_BSP_mDelay(20);
 8001e10:	f001 fd9f 	bl	8003952 <USB_OTG_BSP_mDelay>
    /* Program GUSBCFG.OtgUtmifsSel to I2C*/
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8001e14:	68e3      	ldr	r3, [r4, #12]
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 8001e16:	f894 c008 	ldrb.w	ip, [r4, #8]
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
    USB_OTG_BSP_mDelay(20);
    /* Program GUSBCFG.OtgUtmifsSel to I2C*/
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8001e1a:	68da      	ldr	r2, [r3, #12]
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 8001e1c:	f1bc 0f03 	cmp.w	ip, #3
    {
      usbcfg.b.otgutmifssel = 1;
 8001e20:	bf08      	it	eq
 8001e22:	f442 3280 	orreq.w	r2, r2, #65536	; 0x10000
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8001e26:	60da      	str	r2, [r3, #12]
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 8001e28:	7a20      	ldrb	r0, [r4, #8]
 8001e2a:	2803      	cmp	r0, #3
 8001e2c:	d03b      	beq.n	8001ea6 <USB_OTG_CoreInit+0xd6>
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
      USB_OTG_BSP_mDelay(200);
    }
  }
  /* case the HS core is working in FS mode */
  if(pdev->cfg.dma_enable == 1)
 8001e2e:	f894 e003 	ldrb.w	lr, [r4, #3]
 8001e32:	f1be 0f01 	cmp.w	lr, #1
 8001e36:	d107      	bne.n	8001e48 <USB_OTG_CoreInit+0x78>
  {
    
    ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
 8001e38:	68e3      	ldr	r3, [r4, #12]
 8001e3a:	689a      	ldr	r2, [r3, #8]
    ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 8001e3c:	2105      	movs	r1, #5
 8001e3e:	f361 0244 	bfi	r2, r1, #1, #4
    ahbcfg.b.dmaenable = 1;
 8001e42:	f042 0020 	orr.w	r0, r2, #32
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8001e46:	6098      	str	r0, [r3, #8]
  usbcfg.b.srpcap = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
  USB_OTG_EnableCommonInt(pdev);
#endif
  return status;
}
 8001e48:	2000      	movs	r0, #0
 8001e4a:	bd38      	pop	{r3, r4, r5, pc}
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
 8001e4c:	68c2      	ldr	r2, [r0, #12]
    gccfg.b.pwdn = 0;
    
    if (pdev->cfg.Sof_output)
 8001e4e:	7a41      	ldrb	r1, [r0, #9]
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
 8001e50:	6b93      	ldr	r3, [r2, #56]	; 0x38
    gccfg.b.pwdn = 0;
 8001e52:	f365 4310 	bfi	r3, r5, #16, #1
    
    if (pdev->cfg.Sof_output)
 8001e56:	b109      	cbz	r1, 8001e5c <USB_OTG_CoreInit+0x8c>
    {
      gccfg.b.sofouten = 1;   
 8001e58:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    }
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 8001e5c:	6393      	str	r3, [r2, #56]	; 0x38
    
    /* Init The ULPI Interface */
    usbcfg.d32 = 0;
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8001e5e:	68d1      	ldr	r1, [r2, #12]
    
    usbcfg.b.physel            = 0; /* HS Interface */
 8001e60:	f36f 1186 	bfc	r1, #6, #1
#else
 #ifdef USB_OTG_EXTERNAL_VBUS_ENABLED    
    usbcfg.b.ulpi_ext_vbus_drv = 1; /* Use external VBUS */
 #endif
#endif 
    usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
 8001e64:	f36f 5196 	bfc	r1, #22, #1
    usbcfg.b.ulpi_utmi_sel     = 1; /* ULPI seleInterfacect */
 8001e68:	f041 0310 	orr.w	r3, r1, #16
    
    usbcfg.b.phyif             = 0; /* 8 bits */
 8001e6c:	f36f 03c3 	bfc	r3, #3, #1
    usbcfg.b.ddrsel            = 0; /* single data rate */
 8001e70:	f36f 13c7 	bfc	r3, #7, #1
    
    usbcfg.b.ulpi_fsls = 0;
 8001e74:	f36f 4351 	bfc	r3, #17, #1
    usbcfg.b.ulpi_clk_sus_m = 0;
 8001e78:	f36f 43d3 	bfc	r3, #19, #1
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8001e7c:	60d3      	str	r3, [r2, #12]
    
    /* Reset after a PHY select  */
    USB_OTG_CoreReset(pdev);
 8001e7e:	f104 000c 	add.w	r0, r4, #12
 8001e82:	f7ff fe33 	bl	8001aec <USB_OTG_CoreReset.clone.1>
    
    if(pdev->cfg.dma_enable == 1)
 8001e86:	78e0      	ldrb	r0, [r4, #3]
 8001e88:	2801      	cmp	r0, #1
 8001e8a:	d1dd      	bne.n	8001e48 <USB_OTG_CoreInit+0x78>
    {
      
      ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 8001e8c:	2005      	movs	r0, #5
 8001e8e:	f360 0544 	bfi	r5, r0, #1, #4
      ahbcfg.b.dmaenable = 1;
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8001e92:	68e2      	ldr	r2, [r4, #12]
    
    if(pdev->cfg.dma_enable == 1)
    {
      
      ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
      ahbcfg.b.dmaenable = 1;
 8001e94:	f045 0520 	orr.w	r5, r5, #32
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8001e98:	6095      	str	r5, [r2, #8]
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
      USB_OTG_BSP_mDelay(200);
    }
  }
  /* case the HS core is working in FS mode */
  if(pdev->cfg.dma_enable == 1)
 8001e9a:	f894 e003 	ldrb.w	lr, [r4, #3]
 8001e9e:	f1be 0f01 	cmp.w	lr, #1
 8001ea2:	d0c9      	beq.n	8001e38 <USB_OTG_CoreInit+0x68>
 8001ea4:	e7d0      	b.n	8001e48 <USB_OTG_CoreInit+0x78>
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
    {
      /*Program GI2CCTL.I2CEn*/
      i2cctl.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GI2CCTL);
 8001ea6:	6b19      	ldr	r1, [r3, #48]	; 0x30
      i2cctl.b.i2cdevaddr = 1;
 8001ea8:	2201      	movs	r2, #1
 8001eaa:	f362 619b 	bfi	r1, r2, #26, #2
      i2cctl.b.i2cen = 0;
 8001eae:	f36f 51d7 	bfc	r1, #23, #1
      i2cctl.b.dat_se0 = 1;
 8001eb2:	f041 5580 	orr.w	r5, r1, #268435456	; 0x10000000
      i2cctl.b.addr = 0x2D;
 8001eb6:	202d      	movs	r0, #45	; 0x2d
 8001eb8:	f360 4516 	bfi	r5, r0, #16, #7
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
 8001ebc:	631d      	str	r5, [r3, #48]	; 0x30
      
      USB_OTG_BSP_mDelay(200);
 8001ebe:	20c8      	movs	r0, #200	; 0xc8
 8001ec0:	f001 fd47 	bl	8003952 <USB_OTG_BSP_mDelay>
      
      i2cctl.b.i2cen = 1;
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
 8001ec4:	68e3      	ldr	r3, [r4, #12]
      i2cctl.b.addr = 0x2D;
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
      
      USB_OTG_BSP_mDelay(200);
      
      i2cctl.b.i2cen = 1;
 8001ec6:	f445 0500 	orr.w	r5, r5, #8388608	; 0x800000
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
 8001eca:	631d      	str	r5, [r3, #48]	; 0x30
      USB_OTG_BSP_mDelay(200);
 8001ecc:	20c8      	movs	r0, #200	; 0xc8
 8001ece:	f001 fd40 	bl	8003952 <USB_OTG_BSP_mDelay>
 8001ed2:	e7ac      	b.n	8001e2e <USB_OTG_CoreInit+0x5e>

08001ed4 <USB_OTG_EnableGlobalInt>:
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  
  ahbcfg.d32 = 0;
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
 8001ed4:	68c3      	ldr	r3, [r0, #12]
 8001ed6:	6898      	ldr	r0, [r3, #8]
 8001ed8:	f040 0201 	orr.w	r2, r0, #1
 8001edc:	609a      	str	r2, [r3, #8]
  return status;
}
 8001ede:	2000      	movs	r0, #0
 8001ee0:	4770      	bx	lr
 8001ee2:	bf00      	nop

08001ee4 <USB_OTG_DisableGlobalInt>:
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  ahbcfg.d32 = 0;
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
 8001ee4:	68c3      	ldr	r3, [r0, #12]
 8001ee6:	6898      	ldr	r0, [r3, #8]
 8001ee8:	f020 0201 	bic.w	r2, r0, #1
 8001eec:	609a      	str	r2, [r3, #8]
  return status;
}
 8001eee:	2000      	movs	r0, #0
 8001ef0:	4770      	bx	lr
 8001ef2:	bf00      	nop

08001ef4 <USB_OTG_FlushTxFifo>:
* @param  pdev : Selected device
* @param  num : FO num
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
{
 8001ef4:	b500      	push	{lr}
 8001ef6:	b083      	sub	sp, #12
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  
  uint32_t count = 0;
  greset.d32 = 0;
 8001ef8:	2300      	movs	r3, #0
 8001efa:	9301      	str	r3, [sp, #4]
  greset.b.txfflsh = 1;
 8001efc:	9a01      	ldr	r2, [sp, #4]
  greset.b.txfnum  = num;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001efe:	4b11      	ldr	r3, [pc, #68]	; (8001f44 <USB_OTG_FlushTxFifo+0x50>)
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  
  uint32_t count = 0;
  greset.d32 = 0;
  greset.b.txfflsh = 1;
 8001f00:	f042 0220 	orr.w	r2, r2, #32
 8001f04:	9201      	str	r2, [sp, #4]
  greset.b.txfnum  = num;
 8001f06:	9a01      	ldr	r2, [sp, #4]
 8001f08:	f361 128a 	bfi	r2, r1, #6, #5
 8001f0c:	9201      	str	r2, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8001f0e:	9a01      	ldr	r2, [sp, #4]
 8001f10:	68c1      	ldr	r1, [r0, #12]
 8001f12:	610a      	str	r2, [r1, #16]
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001f14:	690a      	ldr	r2, [r1, #16]
 8001f16:	9201      	str	r2, [sp, #4]
 8001f18:	e00a      	b.n	8001f30 <USB_OTG_FlushTxFifo+0x3c>
 8001f1a:	690a      	ldr	r2, [r1, #16]
 8001f1c:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.txfflsh == 1);
 8001f1e:	9801      	ldr	r0, [sp, #4]
  greset.b.txfflsh = 1;
  greset.b.txfnum  = num;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001f20:	3b01      	subs	r3, #1
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.txfflsh == 1);
 8001f22:	f010 0f20 	tst.w	r0, #32
 8001f26:	d007      	beq.n	8001f38 <USB_OTG_FlushTxFifo+0x44>
  greset.b.txfflsh = 1;
  greset.b.txfnum  = num;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001f28:	690a      	ldr	r2, [r1, #16]
    if (++count > 200000)
 8001f2a:	3b01      	subs	r3, #1
  greset.b.txfflsh = 1;
  greset.b.txfnum  = num;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001f2c:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 8001f2e:	d003      	beq.n	8001f38 <USB_OTG_FlushTxFifo+0x44>
    {
      break;
    }
  }
  while (greset.b.txfflsh == 1);
 8001f30:	9801      	ldr	r0, [sp, #4]
 8001f32:	f010 0f20 	tst.w	r0, #32
 8001f36:	d1f0      	bne.n	8001f1a <USB_OTG_FlushTxFifo+0x26>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 8001f38:	2003      	movs	r0, #3
 8001f3a:	f001 fd00 	bl	800393e <USB_OTG_BSP_uDelay>
  return status;
}
 8001f3e:	2000      	movs	r0, #0
 8001f40:	b003      	add	sp, #12
 8001f42:	bd00      	pop	{pc}
 8001f44:	00030d40 	.word	0x00030d40

08001f48 <USB_OTG_FlushRxFifo>:
* @brief  USB_OTG_FlushRxFifo : Flush a Rx FIFO
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
{
 8001f48:	b500      	push	{lr}
 8001f4a:	b083      	sub	sp, #12
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 8001f4c:	2300      	movs	r3, #0
 8001f4e:	9301      	str	r3, [sp, #4]
  greset.b.rxfflsh = 1;
 8001f50:	9a01      	ldr	r2, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001f52:	4b0f      	ldr	r3, [pc, #60]	; (8001f90 <USB_OTG_FlushRxFifo+0x48>)
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
  greset.b.rxfflsh = 1;
 8001f54:	f042 0110 	orr.w	r1, r2, #16
 8001f58:	9101      	str	r1, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8001f5a:	9a01      	ldr	r2, [sp, #4]
 8001f5c:	68c1      	ldr	r1, [r0, #12]
 8001f5e:	610a      	str	r2, [r1, #16]
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001f60:	690a      	ldr	r2, [r1, #16]
 8001f62:	9201      	str	r2, [sp, #4]
 8001f64:	e00a      	b.n	8001f7c <USB_OTG_FlushRxFifo+0x34>
 8001f66:	690a      	ldr	r2, [r1, #16]
 8001f68:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.rxfflsh == 1);
 8001f6a:	9801      	ldr	r0, [sp, #4]
  greset.d32 = 0;
  greset.b.rxfflsh = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001f6c:	3b01      	subs	r3, #1
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.rxfflsh == 1);
 8001f6e:	f010 0f10 	tst.w	r0, #16
 8001f72:	d007      	beq.n	8001f84 <USB_OTG_FlushRxFifo+0x3c>
  greset.d32 = 0;
  greset.b.rxfflsh = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001f74:	690a      	ldr	r2, [r1, #16]
    if (++count > 200000)
 8001f76:	3b01      	subs	r3, #1
  greset.d32 = 0;
  greset.b.rxfflsh = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001f78:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 8001f7a:	d003      	beq.n	8001f84 <USB_OTG_FlushRxFifo+0x3c>
    {
      break;
    }
  }
  while (greset.b.rxfflsh == 1);
 8001f7c:	9801      	ldr	r0, [sp, #4]
 8001f7e:	f010 0f10 	tst.w	r0, #16
 8001f82:	d1f0      	bne.n	8001f66 <USB_OTG_FlushRxFifo+0x1e>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 8001f84:	2003      	movs	r0, #3
 8001f86:	f001 fcda 	bl	800393e <USB_OTG_BSP_uDelay>
  return status;
}
 8001f8a:	2000      	movs	r0, #0
 8001f8c:	b003      	add	sp, #12
 8001f8e:	bd00      	pop	{pc}
 8001f90:	00030d40 	.word	0x00030d40

08001f94 <USB_OTG_SetCurrentMode>:
USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8001f94:	68c2      	ldr	r2, [r0, #12]
* @param  pdev : Selected device
* @param  mode :  (Host/device)
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
{
 8001f96:	b508      	push	{r3, lr}
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8001f98:	68d3      	ldr	r3, [r2, #12]
  
  usbcfg.b.force_host = 0;
  usbcfg.b.force_dev = 0;
  
  if ( mode == HOST_MODE)
 8001f9a:	2901      	cmp	r1, #1
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
  
  usbcfg.b.force_host = 0;
 8001f9c:	f36f 735d 	bfc	r3, #29, #1
  usbcfg.b.force_dev = 0;
 8001fa0:	f36f 739e 	bfc	r3, #30, #1
  
  if ( mode == HOST_MODE)
 8001fa4:	d008      	beq.n	8001fb8 <USB_OTG_SetCurrentMode+0x24>
  {
    usbcfg.b.force_host = 1;
  }
  else if ( mode == DEVICE_MODE)
 8001fa6:	b909      	cbnz	r1, 8001fac <USB_OTG_SetCurrentMode+0x18>
  {
    usbcfg.b.force_dev = 1;
 8001fa8:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
  USB_OTG_BSP_mDelay(50);
 8001fac:	2032      	movs	r0, #50	; 0x32
  else if ( mode == DEVICE_MODE)
  {
    usbcfg.b.force_dev = 1;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8001fae:	60d3      	str	r3, [r2, #12]
  USB_OTG_BSP_mDelay(50);
 8001fb0:	f001 fccf 	bl	8003952 <USB_OTG_BSP_mDelay>
  return status;
}
 8001fb4:	2000      	movs	r0, #0
 8001fb6:	bd08      	pop	{r3, pc}
  usbcfg.b.force_host = 0;
  usbcfg.b.force_dev = 0;
  
  if ( mode == HOST_MODE)
  {
    usbcfg.b.force_host = 1;
 8001fb8:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  {
    usbcfg.b.force_dev = 1;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
  USB_OTG_BSP_mDelay(50);
 8001fbc:	2032      	movs	r0, #50	; 0x32
  else if ( mode == DEVICE_MODE)
  {
    usbcfg.b.force_dev = 1;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8001fbe:	60d3      	str	r3, [r2, #12]
  USB_OTG_BSP_mDelay(50);
 8001fc0:	f001 fcc7 	bl	8003952 <USB_OTG_BSP_mDelay>
  return status;
}
 8001fc4:	2000      	movs	r0, #0
 8001fc6:	bd08      	pop	{r3, pc}

08001fc8 <USB_OTG_GetMode>:
* @param  pdev : Selected device
* @retval current mode
*/
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 8001fc8:	68c3      	ldr	r3, [r0, #12]
 8001fca:	6958      	ldr	r0, [r3, #20]
}
 8001fcc:	f000 0001 	and.w	r0, r0, #1
 8001fd0:	4770      	bx	lr
 8001fd2:	bf00      	nop

08001fd4 <USB_OTG_IsDeviceMode>:
* @param  pdev : Selected device
* @retval current mode
*/
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 8001fd4:	68c0      	ldr	r0, [r0, #12]
 8001fd6:	6943      	ldr	r3, [r0, #20]
* @param  pdev : Selected device
* @retval num_in_ep
*/
uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_GetMode(pdev) != HOST_MODE);
 8001fd8:	f013 0f01 	tst.w	r3, #1
}
 8001fdc:	bf14      	ite	ne
 8001fde:	2000      	movne	r0, #0
 8001fe0:	2001      	moveq	r0, #1
 8001fe2:	4770      	bx	lr

08001fe4 <USB_OTG_IsHostMode>:
* @param  pdev : Selected device
* @retval current mode
*/
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 8001fe4:	68c3      	ldr	r3, [r0, #12]
 8001fe6:	6958      	ldr	r0, [r3, #20]
* @retval num_in_ep
*/
uint8_t USB_OTG_IsHostMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_GetMode(pdev) == HOST_MODE);
}
 8001fe8:	f000 0001 	and.w	r0, r0, #1
 8001fec:	4770      	bx	lr
 8001fee:	bf00      	nop

08001ff0 <USB_OTG_ReadCoreItr>:
* @retval Status
*/
uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v = 0;
  v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
 8001ff0:	68c3      	ldr	r3, [r0, #12]
 8001ff2:	695a      	ldr	r2, [r3, #20]
  v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
 8001ff4:	6998      	ldr	r0, [r3, #24]
  return v;
}
 8001ff6:	4010      	ands	r0, r2
 8001ff8:	4770      	bx	lr
 8001ffa:	bf00      	nop

08001ffc <USB_OTG_ReadOtgItr>:
* @param  pdev : Selected device
* @retval Status
*/
uint32_t USB_OTG_ReadOtgItr (USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32 (&pdev->regs.GREGS->GOTGINT));
 8001ffc:	68c3      	ldr	r3, [r0, #12]
 8001ffe:	6858      	ldr	r0, [r3, #4]
}
 8002000:	4770      	bx	lr
 8002002:	bf00      	nop

08002004 <USB_OTG_InitDevSpeed>:
*/
void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
{
  USB_OTG_DCFG_TypeDef   dcfg;
  
  dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
 8002004:	6903      	ldr	r3, [r0, #16]
 8002006:	681a      	ldr	r2, [r3, #0]
  dcfg.b.devspd = speed;
 8002008:	f361 0201 	bfi	r2, r1, #0, #2
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCFG, dcfg.d32);
 800200c:	601a      	str	r2, [r3, #0]
}
 800200e:	4770      	bx	lr

08002010 <USB_OTG_EnableDevInt>:
  USB_OTG_GINTMSK_TypeDef  intmsk;
  
  intmsk.d32 = 0;
  
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
 8002010:	68c3      	ldr	r3, [r0, #12]
USB_OTG_STS USB_OTG_EnableDevInt(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GINTMSK_TypeDef  intmsk;
  
  intmsk.d32 = 0;
 8002012:	2200      	movs	r2, #0
  
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 8002014:	f04f 31ff 	mov.w	r1, #4294967295
  USB_OTG_GINTMSK_TypeDef  intmsk;
  
  intmsk.d32 = 0;
  
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
 8002018:	619a      	str	r2, [r3, #24]
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 800201a:	6159      	str	r1, [r3, #20]
  USB_OTG_GINTMSK_TypeDef  int_mask;
  
  int_mask.d32 = 0;
  /* Clear any pending USB_OTG Interrupts */
#ifndef USE_OTG_MODE
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GOTGINT, 0xFFFFFFFF);
 800201c:	6059      	str	r1, [r3, #4]
#endif
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 800201e:	6159      	str	r1, [r3, #20]
#ifdef USE_OTG_MODE
  int_mask.b.otgintr = 1;
  int_mask.b.sessreqintr = 1;
  int_mask.b.conidstschng = 1;
#endif
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
 8002020:	490a      	ldr	r1, [pc, #40]	; (800204c <USB_OTG_EnableDevInt+0x3c>)
 8002022:	6199      	str	r1, [r3, #24]
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
  /* Enable the common interrupts */
  USB_OTG_EnableCommonInt(pdev);
  
  if (pdev->cfg.dma_enable == 0)
 8002024:	f890 c003 	ldrb.w	ip, [r0, #3]
  intmsk.b.incomplisoout    = 1;   
#ifdef VBUS_SENSING_ENABLED
  intmsk.b.sessreqintr    = 1; 
  intmsk.b.otgintr    = 1;    
#endif  
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 8002028:	6998      	ldr	r0, [r3, #24]
  /* Enable the common interrupts */
  USB_OTG_EnableCommonInt(pdev);
  
  if (pdev->cfg.dma_enable == 0)
  {
    intmsk.b.rxstsqlvl = 1;
 800202a:	4594      	cmp	ip, r2
 800202c:	bf14      	ite	ne
 800202e:	4611      	movne	r1, r2
 8002030:	2110      	moveq	r1, #16
  
  /* Enable interrupts matching to the Device mode ONLY */
  intmsk.b.usbsuspend = 1;
  intmsk.b.usbreset   = 1;
  intmsk.b.enumdone   = 1;
  intmsk.b.inepintr   = 1;
 8002032:	f441 2c87 	orr.w	ip, r1, #276480	; 0x43800
  intmsk.b.outepintr  = 1;
  intmsk.b.sofintr    = 1; 
 8002036:	f04c 1108 	orr.w	r1, ip, #524296	; 0x80008

  intmsk.b.incomplisoin    = 1; 
  intmsk.b.incomplisoout    = 1;   
 800203a:	f441 1c40 	orr.w	ip, r1, #3145728	; 0x300000
#ifdef VBUS_SENSING_ENABLED
  intmsk.b.sessreqintr    = 1; 
  intmsk.b.otgintr    = 1;    
#endif  
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 800203e:	ea20 000c 	bic.w	r0, r0, ip
 8002042:	ea40 010c 	orr.w	r1, r0, ip
 8002046:	6199      	str	r1, [r3, #24]
  return status;
}
 8002048:	4610      	mov	r0, r2
 800204a:	4770      	bx	lr
 800204c:	80000800 	.word	0x80000800

08002050 <USB_OTG_CoreInitDev>:
*         for device mode
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
{
 8002050:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  nptxfifosize.d32 = 0;
  txfifosize.d32 = 0;
  msk.d32 = 0;
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
 8002052:	f8d0 510c 	ldr.w	r5, [r0, #268]	; 0x10c
  /* Device configuration register */
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
 8002056:	6902      	ldr	r2, [r0, #16]
  USB_OTG_DIEPMSK_TypeDef msk;
  USB_OTG_DTHRCTL_TypeDef dthrctl;  
  
  depctl.d32 = 0;
  dcfg.d32 = 0;
  nptxfifosize.d32 = 0;
 8002058:	2100      	movs	r1, #0
  txfifosize.d32 = 0;
  msk.d32 = 0;
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
 800205a:	6029      	str	r1, [r5, #0]
*         for device mode
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
{
 800205c:	4604      	mov	r4, r0
  msk.d32 = 0;
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
  /* Device configuration register */
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
 800205e:	6810      	ldr	r0, [r2, #0]
  dcfg.b.perfrint = DCFG_FRAME_INTERVAL_80;
 8002060:	f361 20cc 	bfi	r0, r1, #11, #2
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32 );
 8002064:	6010      	str	r0, [r2, #0]
  USB_OTG_DTHRCTL_TypeDef dthrctl;  
  
  depctl.d32 = 0;
  dcfg.d32 = 0;
  nptxfifosize.d32 = 0;
  txfifosize.d32 = 0;
 8002066:	460b      	mov	r3, r1
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
  dcfg.b.perfrint = DCFG_FRAME_INTERVAL_80;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32 );
  
#ifdef USB_OTG_FS_CORE
  if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID  )
 8002068:	7ae1      	ldrb	r1, [r4, #11]
 800206a:	2901      	cmp	r1, #1
 800206c:	d058      	beq.n	8002120 <USB_OTG_CoreInitDev+0xd0>
    txfifosize.b.depth = TX5_FIFO_HS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[4], txfifosize.d32 );
  }
#endif  
  /* Flush the FIFOs */
  USB_OTG_FlushTxFifo(pdev , 0x10); /* all Tx FIFOs */
 800206e:	2110      	movs	r1, #16
 8002070:	4620      	mov	r0, r4
 8002072:	f7ff ff3f 	bl	8001ef4 <USB_OTG_FlushTxFifo>
  USB_OTG_FlushRxFifo(pdev);
 8002076:	4620      	mov	r0, r4
 8002078:	f7ff ff66 	bl	8001f48 <USB_OTG_FlushRxFifo>
  /* Clear all pending Device Interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 800207c:	6925      	ldr	r5, [r4, #16]
 800207e:	2200      	movs	r2, #0
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8002080:	f04f 30ff 	mov.w	r0, #4294967295
#endif  
  /* Flush the FIFOs */
  USB_OTG_FlushTxFifo(pdev , 0x10); /* all Tx FIFOs */
  USB_OTG_FlushRxFifo(pdev);
  /* Clear all pending Device Interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 8002084:	612a      	str	r2, [r5, #16]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
 8002086:	616a      	str	r2, [r5, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8002088:	61a8      	str	r0, [r5, #24]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
 800208a:	61ea      	str	r2, [r5, #28]
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 800208c:	7863      	ldrb	r3, [r4, #1]
 800208e:	2b00      	cmp	r3, #0
 8002090:	d031      	beq.n	80020f6 <USB_OTG_CoreInitDev+0xa6>
* @brief  USB_OTG_CoreInitDev : Initializes the USB_OTG controller registers 
*         for device mode
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
 8002092:	f104 0014 	add.w	r0, r4, #20
    else
    {
      depctl.d32 = 0;
    }
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
 8002096:	4617      	mov	r7, r2
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 8002098:	26ff      	movs	r6, #255	; 0xff
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[i]->DIEPCTL);
 800209a:	f850 3f04 	ldr.w	r3, [r0, #4]!
 800209e:	6819      	ldr	r1, [r3, #0]
    if (depctl.b.epena)
 80020a0:	f3c1 6e07 	ubfx	lr, r1, #24, #8
 80020a4:	f00e 0c80 	and.w	ip, lr, #128	; 0x80
 80020a8:	fa5f f18c 	uxtb.w	r1, ip
    {
      depctl.d32 = 0;
      depctl.b.epdis = 1;
      depctl.b.snak = 1;
 80020ac:	2900      	cmp	r1, #0
 80020ae:	bf18      	it	ne
 80020b0:	f04f 4190 	movne.w	r1, #1207959552	; 0x48000000
    }
    else
    {
      depctl.d32 = 0;
    }
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
 80020b4:	6019      	str	r1, [r3, #0]
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
 80020b6:	611f      	str	r7, [r3, #16]
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 80020b8:	609e      	str	r6, [r3, #8]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 80020ba:	7863      	ldrb	r3, [r4, #1]
 80020bc:	3201      	adds	r2, #1
 80020be:	4293      	cmp	r3, r2
 80020c0:	d8eb      	bhi.n	800209a <USB_OTG_CoreInitDev+0x4a>
    }
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
  }
  for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
 80020c2:	b1c3      	cbz	r3, 80020f6 <USB_OTG_CoreInitDev+0xa6>
* @brief  USB_OTG_CoreInitDev : Initializes the USB_OTG controller registers 
*         for device mode
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
 80020c4:	2200      	movs	r2, #0
 80020c6:	f104 0050 	add.w	r0, r4, #80	; 0x50
    else
    {
      depctl.d32 = 0;
    }
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPCTL, depctl.d32);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
 80020ca:	4617      	mov	r7, r2
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 80020cc:	26ff      	movs	r6, #255	; 0xff
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
  }
  for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
  {
    USB_OTG_DEPCTL_TypeDef  depctl;
    depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[i]->DOEPCTL);
 80020ce:	f850 3f04 	ldr.w	r3, [r0, #4]!
 80020d2:	6819      	ldr	r1, [r3, #0]
    if (depctl.b.epena)
 80020d4:	f3c1 6e07 	ubfx	lr, r1, #24, #8
 80020d8:	f00e 0c80 	and.w	ip, lr, #128	; 0x80
 80020dc:	fa5f f18c 	uxtb.w	r1, ip
    {
      depctl.d32 = 0;
      depctl.b.epdis = 1;
      depctl.b.snak = 1;
 80020e0:	2900      	cmp	r1, #0
 80020e2:	bf18      	it	ne
 80020e4:	f04f 4190 	movne.w	r1, #1207959552	; 0x48000000
    }
    else
    {
      depctl.d32 = 0;
    }
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPCTL, depctl.d32);
 80020e8:	6019      	str	r1, [r3, #0]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
 80020ea:	611f      	str	r7, [r3, #16]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 80020ec:	609e      	str	r6, [r3, #8]
    }
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
  }
  for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
 80020ee:	7863      	ldrb	r3, [r4, #1]
 80020f0:	3201      	adds	r2, #1
 80020f2:	4293      	cmp	r3, r2
 80020f4:	d8eb      	bhi.n	80020ce <USB_OTG_CoreInitDev+0x7e>
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  msk.d32 = 0;
  msk.b.txfifoundrn = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPMSK, msk.d32, msk.d32);
 80020f6:	692b      	ldr	r3, [r5, #16]
 80020f8:	f443 7080 	orr.w	r0, r3, #256	; 0x100
 80020fc:	6128      	str	r0, [r5, #16]
  
  if (pdev->cfg.dma_enable == 1)
 80020fe:	78e2      	ldrb	r2, [r4, #3]
 8002100:	2a01      	cmp	r2, #1
 8002102:	d108      	bne.n	8002116 <USB_OTG_CoreInitDev+0xc6>
  {
    dthrctl.d32 = 0;
    dthrctl.b.non_iso_thr_en = 1;
    dthrctl.b.iso_thr_en = 1;
    dthrctl.b.tx_thr_len = 64;
 8002104:	2240      	movs	r2, #64	; 0x40
  
  if (pdev->cfg.dma_enable == 1)
  {
    dthrctl.d32 = 0;
    dthrctl.b.non_iso_thr_en = 1;
    dthrctl.b.iso_thr_en = 1;
 8002106:	2003      	movs	r0, #3
    dthrctl.b.tx_thr_len = 64;
 8002108:	f362 008a 	bfi	r0, r2, #2, #9
    dthrctl.b.rx_thr_en = 1;
 800210c:	f440 3180 	orr.w	r1, r0, #65536	; 0x10000
    dthrctl.b.rx_thr_len = 64;
 8002110:	f362 4159 	bfi	r1, r2, #17, #9
    USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DTHRCTL, dthrctl.d32);  
 8002114:	6329      	str	r1, [r5, #48]	; 0x30
  }
  USB_OTG_EnableDevInt(pdev);
 8002116:	4620      	mov	r0, r4
 8002118:	f7ff ff7a 	bl	8002010 <USB_OTG_EnableDevInt>
  return status;
}
 800211c:	2000      	movs	r0, #0
 800211e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
*/
void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
{
  USB_OTG_DCFG_TypeDef   dcfg;
  
  dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
 8002120:	6816      	ldr	r6, [r2, #0]
    
    /* Set Full speed phy */
    USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
    
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 8002122:	68e0      	ldr	r0, [r4, #12]
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
    
    
    /* EP1 TX*/
    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
 8002124:	27c0      	movs	r7, #192	; 0xc0
    
    /* Set Full speed phy */
    USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
    
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 8002126:	2580      	movs	r5, #128	; 0x80
    
    /* EP0 TX*/
    nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
 8002128:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
    
    
    /* EP1 TX*/
    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
 800212c:	f367 030f 	bfi	r3, r7, #0, #16
void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
{
  USB_OTG_DCFG_TypeDef   dcfg;
  
  dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
  dcfg.b.devspd = speed;
 8002130:	f046 0603 	orr.w	r6, r6, #3
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCFG, dcfg.d32);
 8002134:	6016      	str	r6, [r2, #0]
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
    
    
    /* EP1 TX*/
    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
    txfifosize.b.depth = TX1_FIFO_FS_SIZE;
 8002136:	f365 431f 	bfi	r3, r5, #16, #16
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
    
    /* EP0 TX*/
    nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
 800213a:	f365 010f 	bfi	r1, r5, #0, #16
    txfifosize.b.depth = TX1_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
    
    
    /* EP2 TX*/
    txfifosize.b.startaddr += txfifosize.b.depth;
 800213e:	f44f 72a0 	mov.w	r2, #320	; 0x140
    
    /* Set Full speed phy */
    USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
    
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 8002142:	6245      	str	r5, [r0, #36]	; 0x24
    
    /* EP0 TX*/
    nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
 8002144:	6281      	str	r1, [r0, #40]	; 0x28
    
    
    /* EP1 TX*/
    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
    txfifosize.b.depth = TX1_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
 8002146:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
    
    
    /* EP2 TX*/
    txfifosize.b.startaddr += txfifosize.b.depth;
 800214a:	f362 030f 	bfi	r3, r2, #0, #16
    txfifosize.b.depth = TX2_FIFO_FS_SIZE;
 800214e:	f36f 431f 	bfc	r3, #16, #16
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[1], txfifosize.d32 );
 8002152:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
    
    
    /* EP3 TX*/  
    txfifosize.b.startaddr += txfifosize.b.depth;
    txfifosize.b.depth = TX3_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[2], txfifosize.d32 );
 8002156:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
 800215a:	e788      	b.n	800206e <USB_OTG_CoreInitDev+0x1e>

0800215c <USB_OTG_GetDeviceSpeed>:
{
  USB_OTG_DSTS_TypeDef  dsts;
  enum USB_OTG_SPEED speed = USB_SPEED_UNKNOWN;
  
  
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 800215c:	6900      	ldr	r0, [r0, #16]
 800215e:	6883      	ldr	r3, [r0, #8]
  
  switch (dsts.b.enumspd)
 8002160:	f3c3 0341 	ubfx	r3, r3, #1, #2
 8002164:	1e5a      	subs	r2, r3, #1
 8002166:	2a02      	cmp	r2, #2
 8002168:	d804      	bhi.n	8002174 <USB_OTG_GetDeviceSpeed+0x18>
 800216a:	4a03      	ldr	r2, [pc, #12]	; (8002178 <USB_OTG_GetDeviceSpeed+0x1c>)
 800216c:	18d1      	adds	r1, r2, r3
 800216e:	f811 0c01 	ldrb.w	r0, [r1, #-1]
 8002172:	4770      	bx	lr
 8002174:	2003      	movs	r0, #3
    speed = USB_SPEED_LOW;
    break;
  }
  
  return speed;
}
 8002176:	4770      	bx	lr
 8002178:	0800b70c 	.word	0x0800b70c

0800217c <USB_OTG_EP0Activate>:
  USB_OTG_DEPCTL_TypeDef  diepctl;
  USB_OTG_DCTL_TypeDef    dctl;
  
  dctl.d32 = 0;
  /* Read the Device Status and Endpoint 0 Control registers */
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 800217c:	6903      	ldr	r3, [r0, #16]
  diepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL);
 800217e:	6982      	ldr	r2, [r0, #24]
  USB_OTG_DEPCTL_TypeDef  diepctl;
  USB_OTG_DCTL_TypeDef    dctl;
  
  dctl.d32 = 0;
  /* Read the Device Status and Endpoint 0 Control registers */
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8002180:	6898      	ldr	r0, [r3, #8]
  diepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL);
 8002182:	6811      	ldr	r1, [r2, #0]
  /* Set the MPS of the IN EP based on the enumeration speed */
  switch (dsts.b.enumspd)
 8002184:	f3c0 0041 	ubfx	r0, r0, #1, #2
 8002188:	2802      	cmp	r0, #2
 800218a:	d008      	beq.n	800219e <USB_OTG_EP0Activate+0x22>
  {
  case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
  case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
  case DSTS_ENUMSPD_FS_PHY_48MHZ:
    diepctl.b.mps = DEP0CTL_MPS_64;
 800218c:	f36f 010a 	bfc	r1, #0, #11
    break;
  case DSTS_ENUMSPD_LS_PHY_6MHZ:
    diepctl.b.mps = DEP0CTL_MPS_8;
    break;
  }
  USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL, diepctl.d32);
 8002190:	6011      	str	r1, [r2, #0]
  dctl.b.cgnpinnak = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, dctl.d32);
 8002192:	6859      	ldr	r1, [r3, #4]
 8002194:	f441 7280 	orr.w	r2, r1, #256	; 0x100
 8002198:	605a      	str	r2, [r3, #4]
  return status;
}
 800219a:	2000      	movs	r0, #0
 800219c:	4770      	bx	lr
  case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
  case DSTS_ENUMSPD_FS_PHY_48MHZ:
    diepctl.b.mps = DEP0CTL_MPS_64;
    break;
  case DSTS_ENUMSPD_LS_PHY_6MHZ:
    diepctl.b.mps = DEP0CTL_MPS_8;
 800219e:	2003      	movs	r0, #3
 80021a0:	f360 010a 	bfi	r1, r0, #0, #11
    break;
  }
  USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL, diepctl.d32);
 80021a4:	6011      	str	r1, [r2, #0]
  dctl.b.cgnpinnak = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, dctl.d32);
 80021a6:	6859      	ldr	r1, [r3, #4]
 80021a8:	f441 7280 	orr.w	r2, r1, #256	; 0x100
 80021ac:	605a      	str	r2, [r3, #4]
  return status;
}
 80021ae:	2000      	movs	r0, #0
 80021b0:	4770      	bx	lr
 80021b2:	bf00      	nop

080021b4 <USB_OTG_EPActivate>:
* @brief  USB_OTG_EPActivate : Activates an EP
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPActivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 80021b4:	b470      	push	{r4, r5, r6}
  
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 80021b6:	784b      	ldrb	r3, [r1, #1]
  USB_OTG_DAINT_TypeDef  daintmsk;
  __IO uint32_t *addr;
  
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;
 80021b8:	2200      	movs	r2, #0
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 80021ba:	2b01      	cmp	r3, #1
 80021bc:	d027      	beq.n	800220e <USB_OTG_EPActivate+0x5a>
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 80021be:	780c      	ldrb	r4, [r1, #0]
 80021c0:	eb00 0c84 	add.w	ip, r0, r4, lsl #2
    daintmsk.ep.out = 1 << ep->num;
 80021c4:	2501      	movs	r5, #1
 80021c6:	fa15 f304 	lsls.w	r3, r5, r4
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 80021ca:	f8dc 4054 	ldr.w	r4, [ip, #84]	; 0x54
    daintmsk.ep.out = 1 << ep->num;
 80021ce:	f363 421f 	bfi	r2, r3, #16, #16
  }
  /* If the EP is already active don't change the EP Control
  * register. */
  depctl.d32 = USB_OTG_READ_REG32(addr);
 80021d2:	6823      	ldr	r3, [r4, #0]
  if (!depctl.b.usbactep)
 80021d4:	f3c3 2507 	ubfx	r5, r3, #8, #8
 80021d8:	f005 0c80 	and.w	ip, r5, #128	; 0x80
 80021dc:	fa5f f58c 	uxtb.w	r5, ip
 80021e0:	b975      	cbnz	r5, 8002200 <USB_OTG_EPActivate+0x4c>
  {
    depctl.b.mps    = ep->maxpacket;
 80021e2:	688e      	ldr	r6, [r1, #8]
    depctl.b.eptype = ep->type;
 80021e4:	78cd      	ldrb	r5, [r1, #3]
    depctl.b.txfnum = ep->tx_fifo_num;
 80021e6:	f8b1 c006 	ldrh.w	ip, [r1, #6]
  /* If the EP is already active don't change the EP Control
  * register. */
  depctl.d32 = USB_OTG_READ_REG32(addr);
  if (!depctl.b.usbactep)
  {
    depctl.b.mps    = ep->maxpacket;
 80021ea:	f366 030a 	bfi	r3, r6, #0, #11
    depctl.b.eptype = ep->type;
 80021ee:	f365 4393 	bfi	r3, r5, #18, #2
    depctl.b.txfnum = ep->tx_fifo_num;
 80021f2:	f36c 5399 	bfi	r3, ip, #22, #4
    depctl.b.setd0pid = 1;
 80021f6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    depctl.b.usbactep = 1;
 80021fa:	f443 4100 	orr.w	r1, r3, #32768	; 0x8000
    USB_OTG_WRITE_REG32(addr, depctl.d32);
 80021fe:	6021      	str	r1, [r4, #0]
  {
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, 0, daintmsk.d32);
  }
  else
#endif   
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, 0, daintmsk.d32);
 8002200:	6900      	ldr	r0, [r0, #16]
 8002202:	69c1      	ldr	r1, [r0, #28]
 8002204:	430a      	orrs	r2, r1
 8002206:	61c2      	str	r2, [r0, #28]
  return status;
}
 8002208:	2000      	movs	r0, #0
 800220a:	bc70      	pop	{r4, r5, r6}
 800220c:	4770      	bx	lr
  depctl.d32 = 0;
  daintmsk.d32 = 0;
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 800220e:	780c      	ldrb	r4, [r1, #0]
 8002210:	eb00 0584 	add.w	r5, r0, r4, lsl #2
    daintmsk.ep.in = 1 << ep->num;
 8002214:	40a3      	lsls	r3, r4
 8002216:	f363 020f 	bfi	r2, r3, #0, #16
  depctl.d32 = 0;
  daintmsk.d32 = 0;
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 800221a:	69ac      	ldr	r4, [r5, #24]
 800221c:	e7d9      	b.n	80021d2 <USB_OTG_EPActivate+0x1e>
 800221e:	bf00      	nop

08002220 <USB_OTG_EPDeactivate>:
* @brief  USB_OTG_EPDeactivate : Deactivates an EP
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPDeactivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 8002220:	b430      	push	{r4, r5}
  __IO uint32_t *addr;
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 8002222:	784a      	ldrb	r2, [r1, #1]
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_DEPCTL_TypeDef  depctl;
  USB_OTG_DAINT_TypeDef  daintmsk;
  __IO uint32_t *addr;
  
  depctl.d32 = 0;
 8002224:	2300      	movs	r3, #0
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 8002226:	2a01      	cmp	r2, #1
  USB_OTG_DEPCTL_TypeDef  depctl;
  USB_OTG_DAINT_TypeDef  daintmsk;
  __IO uint32_t *addr;
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
 8002228:	461c      	mov	r4, r3
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 800222a:	d014      	beq.n	8002256 <USB_OTG_EPDeactivate+0x36>
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 800222c:	7809      	ldrb	r1, [r1, #0]
 800222e:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
    daintmsk.ep.out = 1 << ep->num;
 8002232:	2501      	movs	r5, #1
 8002234:	fa15 f201 	lsls.w	r2, r5, r1
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 8002238:	f8dc 1054 	ldr.w	r1, [ip, #84]	; 0x54
    daintmsk.ep.out = 1 << ep->num;
 800223c:	f362 441f 	bfi	r4, r2, #16, #16
  {
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, daintmsk.d32, 0);
  }
  else
#endif    
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, daintmsk.d32, 0);
 8002240:	6900      	ldr	r0, [r0, #16]
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
    daintmsk.ep.out = 1 << ep->num;
  }
  depctl.b.usbactep = 0;
 8002242:	f36f 33cf 	bfc	r3, #15, #1
  USB_OTG_WRITE_REG32(addr, depctl.d32);
 8002246:	600b      	str	r3, [r1, #0]
  {
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, daintmsk.d32, 0);
  }
  else
#endif    
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, daintmsk.d32, 0);
 8002248:	69c3      	ldr	r3, [r0, #28]
 800224a:	ea23 0404 	bic.w	r4, r3, r4
 800224e:	61c4      	str	r4, [r0, #28]
  return status;
}
 8002250:	2000      	movs	r0, #0
 8002252:	bc30      	pop	{r4, r5}
 8002254:	4770      	bx	lr
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 8002256:	7809      	ldrb	r1, [r1, #0]
 8002258:	eb00 0581 	add.w	r5, r0, r1, lsl #2
    daintmsk.ep.in = 1 << ep->num;
 800225c:	408a      	lsls	r2, r1
 800225e:	f362 040f 	bfi	r4, r2, #0, #16
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 8002262:	69a9      	ldr	r1, [r5, #24]
 8002264:	e7ec      	b.n	8002240 <USB_OTG_EPDeactivate+0x20>
 8002266:	bf00      	nop

08002268 <USB_OTG_EPStartXfer>:
*         starts the xfer
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPStartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 8002268:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t fifoemptymsk = 0;  
  
  depctl.d32 = 0;
  deptsiz.d32 = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
 800226a:	784b      	ldrb	r3, [r1, #1]
 800226c:	2b01      	cmp	r3, #1
 800226e:	d041      	beq.n	80022f4 <USB_OTG_EPStartXfer+0x8c>
    }    
  }
  else
  {
    /* OUT endpoint */
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL));
 8002270:	f891 c000 	ldrb.w	ip, [r1]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ));
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    if (ep->xfer_len == 0)
 8002274:	694e      	ldr	r6, [r1, #20]
    }    
  }
  else
  {
    /* OUT endpoint */
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL));
 8002276:	eb00 038c 	add.w	r3, r0, ip, lsl #2
 800227a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800227c:	681c      	ldr	r4, [r3, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ));
 800227e:	691a      	ldr	r2, [r3, #16]
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    if (ep->xfer_len == 0)
 8002280:	b1f6      	cbz	r6, 80022c0 <USB_OTG_EPStartXfer+0x58>
      deptsiz.b.xfersize = ep->maxpacket;
      deptsiz.b.pktcnt = 1;
    }
    else
    {
      deptsiz.b.pktcnt = (ep->xfer_len + (ep->maxpacket - 1)) / ep->maxpacket;
 8002282:	688f      	ldr	r7, [r1, #8]
 8002284:	19f5      	adds	r5, r6, r7
 8002286:	3d01      	subs	r5, #1
 8002288:	fbb5 f5f7 	udiv	r5, r5, r7
 800228c:	05ad      	lsls	r5, r5, #22
 800228e:	0dad      	lsrs	r5, r5, #22
 8002290:	f365 42dc 	bfi	r2, r5, #19, #10
      deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
 8002294:	fb07 f505 	mul.w	r5, r7, r5
 8002298:	f365 0212 	bfi	r2, r5, #0, #19
    }
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
 800229c:	611a      	str	r2, [r3, #16]
    
    if (pdev->cfg.dma_enable == 1)
 800229e:	78c2      	ldrb	r2, [r0, #3]
 80022a0:	2a01      	cmp	r2, #1
 80022a2:	d017      	beq.n	80022d4 <USB_OTG_EPStartXfer+0x6c>
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
    }
    
    if (ep->type == EP_TYPE_ISOC)
 80022a4:	78ca      	ldrb	r2, [r1, #3]
 80022a6:	2a01      	cmp	r2, #1
 80022a8:	d01e      	beq.n	80022e8 <USB_OTG_EPStartXfer+0x80>
      }
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL, depctl.d32);
 80022aa:	f891 c000 	ldrb.w	ip, [r1]
 80022ae:	eb00 018c 	add.w	r1, r0, ip, lsl #2
        depctl.b.setd0pid = 1;
      }
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 80022b2:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL, depctl.d32);
 80022b6:	6d48      	ldr	r0, [r1, #84]	; 0x54
 80022b8:	6004      	str	r4, [r0, #0]
  }
  return status;
}
 80022ba:	2000      	movs	r0, #0
 80022bc:	bcf0      	pop	{r4, r5, r6, r7}
 80022be:	4770      	bx	lr
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = ep->maxpacket;
 80022c0:	688d      	ldr	r5, [r1, #8]
 80022c2:	f365 0212 	bfi	r2, r5, #0, #19
      deptsiz.b.pktcnt = 1;
 80022c6:	2501      	movs	r5, #1
 80022c8:	f365 42dc 	bfi	r2, r5, #19, #10
    else
    {
      deptsiz.b.pktcnt = (ep->xfer_len + (ep->maxpacket - 1)) / ep->maxpacket;
      deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
    }
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
 80022cc:	611a      	str	r2, [r3, #16]
    
    if (pdev->cfg.dma_enable == 1)
 80022ce:	78c2      	ldrb	r2, [r0, #3]
 80022d0:	2a01      	cmp	r2, #1
 80022d2:	d1e7      	bne.n	80022a4 <USB_OTG_EPStartXfer+0x3c>
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
 80022d4:	780b      	ldrb	r3, [r1, #0]
 80022d6:	690a      	ldr	r2, [r1, #16]
 80022d8:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
 80022dc:	f8dc 3054 	ldr.w	r3, [ip, #84]	; 0x54
 80022e0:	615a      	str	r2, [r3, #20]
    }
    
    if (ep->type == EP_TYPE_ISOC)
 80022e2:	78ca      	ldrb	r2, [r1, #3]
 80022e4:	2a01      	cmp	r2, #1
 80022e6:	d1e0      	bne.n	80022aa <USB_OTG_EPStartXfer+0x42>
    {
      if (ep->even_odd_frame)
 80022e8:	794b      	ldrb	r3, [r1, #5]
 80022ea:	2b00      	cmp	r3, #0
 80022ec:	d072      	beq.n	80023d4 <USB_OTG_EPStartXfer+0x16c>
      {
        depctl.b.setd1pid = 1;
 80022ee:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
 80022f2:	e7da      	b.n	80022aa <USB_OTG_EPStartXfer+0x42>
  depctl.d32 = 0;
  deptsiz.d32 = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
 80022f4:	780d      	ldrb	r5, [r1, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 80022f6:	694a      	ldr	r2, [r1, #20]
  depctl.d32 = 0;
  deptsiz.d32 = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
 80022f8:	eb00 0485 	add.w	r4, r0, r5, lsl #2
 80022fc:	69a5      	ldr	r5, [r4, #24]
 80022fe:	682e      	ldr	r6, [r5, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
 8002300:	692c      	ldr	r4, [r5, #16]
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 8002302:	2a00      	cmp	r2, #0
 8002304:	d061      	beq.n	80023ca <USB_OTG_EPStartXfer+0x162>
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      deptsiz.b.xfersize = ep->xfer_len;
      deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
 8002306:	688b      	ldr	r3, [r1, #8]

      if (ep->type == EP_TYPE_ISOC)
 8002308:	78cf      	ldrb	r7, [r1, #3]
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      deptsiz.b.xfersize = ep->xfer_len;
      deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
 800230a:	eb02 0c03 	add.w	ip, r2, r3
 800230e:	f10c 3cff 	add.w	ip, ip, #4294967295
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      deptsiz.b.xfersize = ep->xfer_len;
 8002312:	f362 0412 	bfi	r4, r2, #0, #19
      deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
 8002316:	fbbc f3f3 	udiv	r3, ip, r3
 800231a:	f363 44dc 	bfi	r4, r3, #19, #10

      if (ep->type == EP_TYPE_ISOC)
 800231e:	2f01      	cmp	r7, #1
      {
        deptsiz.b.mc = 1;
 8002320:	bf08      	it	eq
 8002322:	f367 745e 	bfieq	r4, r7, #29, #2
      }       
    }
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ, deptsiz.d32);
 8002326:	612c      	str	r4, [r5, #16]
    
    if (pdev->cfg.dma_enable == 1)
 8002328:	78c5      	ldrb	r5, [r0, #3]
 800232a:	2d01      	cmp	r5, #1
 800232c:	d05f      	beq.n	80023ee <USB_OTG_EPStartXfer+0x186>
    {
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);
    }
    else
    {
      if (ep->type != EP_TYPE_ISOC)
 800232e:	78cb      	ldrb	r3, [r1, #3]
 8002330:	2b01      	cmp	r3, #1
 8002332:	d052      	beq.n	80023da <USB_OTG_EPStartXfer+0x172>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0)
 8002334:	b162      	cbz	r2, 8002350 <USB_OTG_EPStartXfer+0xe8>
        {
          fifoemptymsk = 1 << ep->num;
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 8002336:	6903      	ldr	r3, [r0, #16]
      if (ep->type != EP_TYPE_ISOC)
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0)
        {
          fifoemptymsk = 1 << ep->num;
 8002338:	780c      	ldrb	r4, [r1, #0]
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 800233a:	6b5d      	ldr	r5, [r3, #52]	; 0x34
      if (ep->type != EP_TYPE_ISOC)
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0)
        {
          fifoemptymsk = 1 << ep->num;
 800233c:	2701      	movs	r7, #1
 800233e:	fa17 f404 	lsls.w	r4, r7, r4
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 8002342:	432c      	orrs	r4, r5
 8002344:	635c      	str	r4, [r3, #52]	; 0x34
        }
      }
    }
    
    
    if (ep->type == EP_TYPE_ISOC)
 8002346:	f891 c003 	ldrb.w	ip, [r1, #3]
 800234a:	f1bc 0f01 	cmp.w	ip, #1
 800234e:	d044      	beq.n	80023da <USB_OTG_EPStartXfer+0x172>
    } 
    
    /* EP enable, IN data in FIFO */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);
 8002350:	780d      	ldrb	r5, [r1, #0]
 8002352:	eb00 0c85 	add.w	ip, r0, r5, lsl #2
      }
    } 
    
    /* EP enable, IN data in FIFO */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 8002356:	f046 4604 	orr.w	r6, r6, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);
 800235a:	f8dc 3018 	ldr.w	r3, [ip, #24]
 800235e:	601e      	str	r6, [r3, #0]

    if (ep->type == EP_TYPE_ISOC)
 8002360:	78cd      	ldrb	r5, [r1, #3]
 8002362:	2d01      	cmp	r5, #1
 8002364:	d1a9      	bne.n	80022ba <USB_OTG_EPStartXfer+0x52>
                                uint8_t             *src, 
                                uint8_t             ch_ep_num, 
                                uint16_t            len)
{
  USB_OTG_STS status = USB_OTG_OK;
  if (pdev->cfg.dma_enable == 0)
 8002366:	78c4      	ldrb	r4, [r0, #3]
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);

    if (ep->type == EP_TYPE_ISOC)
    {
      USB_OTG_WritePacket(pdev, ep->xfer_buff, ep->num, ep->xfer_len);   
 8002368:	68cb      	ldr	r3, [r1, #12]
 800236a:	7809      	ldrb	r1, [r1, #0]
                                uint8_t             *src, 
                                uint8_t             ch_ep_num, 
                                uint16_t            len)
{
  USB_OTG_STS status = USB_OTG_OK;
  if (pdev->cfg.dma_enable == 0)
 800236c:	2c00      	cmp	r4, #0
 800236e:	d1a4      	bne.n	80022ba <USB_OTG_EPStartXfer+0x52>
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
 8002370:	b294      	uxth	r4, r2
 8002372:	1ce2      	adds	r2, r4, #3
    fifo = pdev->regs.DFIFO[ch_ep_num];
 8002374:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    for (i = 0; i < count32b; i++, src+=4)
 8002378:	1092      	asrs	r2, r2, #2
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
 800237a:	f8d0 40d0 	ldr.w	r4, [r0, #208]	; 0xd0
    for (i = 0; i < count32b; i++, src+=4)
 800237e:	d09c      	beq.n	80022ba <USB_OTG_EPStartXfer+0x52>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8002380:	f853 1b04 	ldr.w	r1, [r3], #4
 8002384:	1e56      	subs	r6, r2, #1
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8002386:	2a01      	cmp	r2, #1
 8002388:	f006 0601 	and.w	r6, r6, #1
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 800238c:	6021      	str	r1, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 800238e:	4628      	mov	r0, r5
 8002390:	d093      	beq.n	80022ba <USB_OTG_EPStartXfer+0x52>
 8002392:	b12e      	cbz	r6, 80023a0 <USB_OTG_EPStartXfer+0x138>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8002394:	f853 1b04 	ldr.w	r1, [r3], #4
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8002398:	2002      	movs	r0, #2
 800239a:	4282      	cmp	r2, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 800239c:	6021      	str	r1, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 800239e:	d08c      	beq.n	80022ba <USB_OTG_EPStartXfer+0x52>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 80023a0:	4619      	mov	r1, r3
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 80023a2:	3002      	adds	r0, #2
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 80023a4:	f851 5b04 	ldr.w	r5, [r1], #4
 80023a8:	6025      	str	r5, [r4, #0]
 80023aa:	685d      	ldr	r5, [r3, #4]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 80023ac:	1d0b      	adds	r3, r1, #4
 80023ae:	4282      	cmp	r2, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 80023b0:	6025      	str	r5, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 80023b2:	d082      	beq.n	80022ba <USB_OTG_EPStartXfer+0x52>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 80023b4:	4619      	mov	r1, r3
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 80023b6:	3002      	adds	r0, #2
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 80023b8:	f851 5b04 	ldr.w	r5, [r1], #4
 80023bc:	6025      	str	r5, [r4, #0]
 80023be:	685d      	ldr	r5, [r3, #4]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 80023c0:	1d0b      	adds	r3, r1, #4
 80023c2:	4282      	cmp	r2, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 80023c4:	6025      	str	r5, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 80023c6:	d1eb      	bne.n	80023a0 <USB_OTG_EPStartXfer+0x138>
 80023c8:	e777      	b.n	80022ba <USB_OTG_EPStartXfer+0x52>
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = 0;
 80023ca:	f362 0412 	bfi	r4, r2, #0, #19
      deptsiz.b.pktcnt = 1;
 80023ce:	f363 44dc 	bfi	r4, r3, #19, #10
 80023d2:	e7a8      	b.n	8002326 <USB_OTG_EPStartXfer+0xbe>
      {
        depctl.b.setd1pid = 1;
      }
      else
      {
        depctl.b.setd0pid = 1;
 80023d4:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
 80023d8:	e767      	b.n	80022aa <USB_OTG_EPStartXfer+0x42>
    }
    
    
    if (ep->type == EP_TYPE_ISOC)
    {
      dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 80023da:	6905      	ldr	r5, [r0, #16]
 80023dc:	68ab      	ldr	r3, [r5, #8]
      
      if (((dsts.b.soffn)&0x1) == 0)
 80023de:	f413 7f80 	tst.w	r3, #256	; 0x100
      {
        depctl.b.setd1pid = 1;
 80023e2:	bf0c      	ite	eq
 80023e4:	f046 5600 	orreq.w	r6, r6, #536870912	; 0x20000000
      }
      else
      {
        depctl.b.setd0pid = 1;
 80023e8:	f046 5680 	orrne.w	r6, r6, #268435456	; 0x10000000
 80023ec:	e7b0      	b.n	8002350 <USB_OTG_EPStartXfer+0xe8>
    }
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ, deptsiz.d32);
    
    if (pdev->cfg.dma_enable == 1)
    {
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);
 80023ee:	780d      	ldrb	r5, [r1, #0]
 80023f0:	690c      	ldr	r4, [r1, #16]
 80023f2:	eb00 0c85 	add.w	ip, r0, r5, lsl #2
 80023f6:	f8dc 3018 	ldr.w	r3, [ip, #24]
 80023fa:	615c      	str	r4, [r3, #20]
 80023fc:	e7a3      	b.n	8002346 <USB_OTG_EPStartXfer+0xde>
 80023fe:	bf00      	nop

08002400 <USB_OTG_EP0StartXfer>:
*         starts the xfer
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EP0StartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 8002400:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t fifoemptymsk = 0;
  
  depctl.d32   = 0;
  deptsiz.d32  = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
 8002402:	784b      	ldrb	r3, [r1, #1]
 8002404:	2b01      	cmp	r3, #1
*         starts the xfer
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EP0StartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 8002406:	b082      	sub	sp, #8
  uint32_t fifoemptymsk = 0;
  
  depctl.d32   = 0;
  deptsiz.d32  = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
 8002408:	d02f      	beq.n	800246a <USB_OTG_EP0StartXfer+0x6a>
    }
  }
  else
  {
    /* OUT endpoint */
    depctl.d32  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 800240a:	f891 c000 	ldrb.w	ip, [r1]
    deptsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ);
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
 800240e:	694e      	ldr	r6, [r1, #20]
    }
  }
  else
  {
    /* OUT endpoint */
    depctl.d32  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 8002410:	eb00 048c 	add.w	r4, r0, ip, lsl #2
 8002414:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8002416:	681a      	ldr	r2, [r3, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ);
 8002418:	691d      	ldr	r5, [r3, #16]
 800241a:	9500      	str	r5, [sp, #0]
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
 800241c:	b1fe      	cbz	r6, 800245e <USB_OTG_EP0StartXfer+0x5e>
      deptsiz.b.xfersize = ep->maxpacket;
      deptsiz.b.pktcnt = 1;
    }
    else
    {
      ep->xfer_len = ep->maxpacket;
 800241e:	688e      	ldr	r6, [r1, #8]
      deptsiz.b.xfersize = ep->maxpacket;
 8002420:	f89d 5000 	ldrb.w	r5, [sp]
      deptsiz.b.pktcnt = 1;
 8002424:	f89d 4002 	ldrb.w	r4, [sp, #2]
      deptsiz.b.xfersize = ep->maxpacket;
      deptsiz.b.pktcnt = 1;
    }
    else
    {
      ep->xfer_len = ep->maxpacket;
 8002428:	614e      	str	r6, [r1, #20]
      deptsiz.b.xfersize = ep->maxpacket;
 800242a:	f366 0506 	bfi	r5, r6, #0, #7
      deptsiz.b.pktcnt = 1;
 800242e:	2601      	movs	r6, #1
 8002430:	f366 04c4 	bfi	r4, r6, #3, #2
      deptsiz.b.pktcnt = 1;
    }
    else
    {
      ep->xfer_len = ep->maxpacket;
      deptsiz.b.xfersize = ep->maxpacket;
 8002434:	f88d 5000 	strb.w	r5, [sp]
      deptsiz.b.pktcnt = 1;
 8002438:	f88d 4002 	strb.w	r4, [sp, #2]
    }
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
 800243c:	9c00      	ldr	r4, [sp, #0]
 800243e:	611c      	str	r4, [r3, #16]
    if (pdev->cfg.dma_enable == 1)
 8002440:	78c3      	ldrb	r3, [r0, #3]
 8002442:	2b01      	cmp	r3, #1
 8002444:	d041      	beq.n	80024ca <USB_OTG_EP0StartXfer+0xca>
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32 (&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL), depctl.d32);
 8002446:	f891 c000 	ldrb.w	ip, [r1]
 800244a:	eb00 008c 	add.w	r0, r0, ip, lsl #2
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 800244e:	f042 4104 	orr.w	r1, r2, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32 (&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL), depctl.d32);
 8002452:	6d42      	ldr	r2, [r0, #84]	; 0x54
 8002454:	6011      	str	r1, [r2, #0]
    
  }
  return status;
}
 8002456:	2000      	movs	r0, #0
 8002458:	b002      	add	sp, #8
 800245a:	bcf0      	pop	{r4, r5, r6, r7}
 800245c:	4770      	bx	lr
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = ep->maxpacket;
 800245e:	f89d 5000 	ldrb.w	r5, [sp]
      deptsiz.b.pktcnt = 1;
 8002462:	f89d 4002 	ldrb.w	r4, [sp, #2]
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = ep->maxpacket;
 8002466:	688e      	ldr	r6, [r1, #8]
 8002468:	e7df      	b.n	800242a <USB_OTG_EP0StartXfer+0x2a>
  depctl.d32   = 0;
  deptsiz.d32  = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    in_regs = pdev->regs.INEP_REGS[0];
 800246a:	6982      	ldr	r2, [r0, #24]
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 800246c:	694c      	ldr	r4, [r1, #20]
  deptsiz.d32  = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    in_regs = pdev->regs.INEP_REGS[0];
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
 800246e:	6815      	ldr	r5, [r2, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
 8002470:	6916      	ldr	r6, [r2, #16]
 8002472:	9600      	str	r6, [sp, #0]
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 8002474:	2c00      	cmp	r4, #0
 8002476:	d030      	beq.n	80024da <USB_OTG_EP0StartXfer+0xda>
      deptsiz.b.pktcnt = 1;
      
    }
    else
    {
      if (ep->xfer_len > ep->maxpacket)
 8002478:	688b      	ldr	r3, [r1, #8]
 800247a:	429c      	cmp	r4, r3
 800247c:	d942      	bls.n	8002504 <USB_OTG_EP0StartXfer+0x104>
      {
        ep->xfer_len = ep->maxpacket;
        deptsiz.b.xfersize = ep->maxpacket;
 800247e:	f89d 4000 	ldrb.w	r4, [sp]
    }
    else
    {
      if (ep->xfer_len > ep->maxpacket)
      {
        ep->xfer_len = ep->maxpacket;
 8002482:	614b      	str	r3, [r1, #20]
        deptsiz.b.xfersize = ep->maxpacket;
 8002484:	f363 0406 	bfi	r4, r3, #0, #7
 8002488:	f88d 4000 	strb.w	r4, [sp]
      }
      else
      {
        deptsiz.b.xfersize = ep->xfer_len;
      }
      deptsiz.b.pktcnt = 1;
 800248c:	f89d c002 	ldrb.w	ip, [sp, #2]
 8002490:	2401      	movs	r4, #1
 8002492:	f364 0cc4 	bfi	ip, r4, #3, #2
 8002496:	f88d c002 	strb.w	ip, [sp, #2]
    }
    USB_OTG_WRITE_REG32(&in_regs->DIEPTSIZ, deptsiz.d32);
 800249a:	9b00      	ldr	r3, [sp, #0]
 800249c:	6113      	str	r3, [r2, #16]
    
    if (pdev->cfg.dma_enable == 1)
 800249e:	78c3      	ldrb	r3, [r0, #3]
 80024a0:	2b01      	cmp	r3, #1
 80024a2:	d027      	beq.n	80024f4 <USB_OTG_EP0StartXfer+0xf4>
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);  
    }
    
    /* EP enable, IN data in FIFO */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 80024a4:	f045 4304 	orr.w	r3, r5, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32(&in_regs->DIEPCTL, depctl.d32);
 80024a8:	6013      	str	r3, [r2, #0]
    
    
    
    if (pdev->cfg.dma_enable == 0)
 80024aa:	78c2      	ldrb	r2, [r0, #3]
 80024ac:	2a00      	cmp	r2, #0
 80024ae:	d1d2      	bne.n	8002456 <USB_OTG_EP0StartXfer+0x56>
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0)
 80024b0:	694a      	ldr	r2, [r1, #20]
 80024b2:	2a00      	cmp	r2, #0
 80024b4:	d0cf      	beq.n	8002456 <USB_OTG_EP0StartXfer+0x56>
      {
        {
          fifoemptymsk |= 1 << ep->num;
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 80024b6:	6903      	ldr	r3, [r0, #16]
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0)
      {
        {
          fifoemptymsk |= 1 << ep->num;
 80024b8:	780a      	ldrb	r2, [r1, #0]
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 80024ba:	6b59      	ldr	r1, [r3, #52]	; 0x34
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0)
      {
        {
          fifoemptymsk |= 1 << ep->num;
 80024bc:	2001      	movs	r0, #1
 80024be:	fa10 f202 	lsls.w	r2, r0, r2
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 80024c2:	ea42 0001 	orr.w	r0, r2, r1
 80024c6:	6358      	str	r0, [r3, #52]	; 0x34
 80024c8:	e7c5      	b.n	8002456 <USB_OTG_EP0StartXfer+0x56>
      deptsiz.b.pktcnt = 1;
    }
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
    if (pdev->cfg.dma_enable == 1)
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
 80024ca:	780b      	ldrb	r3, [r1, #0]
 80024cc:	690c      	ldr	r4, [r1, #16]
 80024ce:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
 80024d2:	f8dc 3054 	ldr.w	r3, [ip, #84]	; 0x54
 80024d6:	615c      	str	r4, [r3, #20]
 80024d8:	e7b5      	b.n	8002446 <USB_OTG_EP0StartXfer+0x46>
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = 0;
 80024da:	f89d 7000 	ldrb.w	r7, [sp]
      deptsiz.b.pktcnt = 1;
 80024de:	f89d 6002 	ldrb.w	r6, [sp, #2]
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = 0;
 80024e2:	f364 0706 	bfi	r7, r4, #0, #7
      deptsiz.b.pktcnt = 1;
 80024e6:	f363 06c4 	bfi	r6, r3, #3, #2
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = 0;
 80024ea:	f88d 7000 	strb.w	r7, [sp]
      deptsiz.b.pktcnt = 1;
 80024ee:	f88d 6002 	strb.w	r6, [sp, #2]
 80024f2:	e7d2      	b.n	800249a <USB_OTG_EP0StartXfer+0x9a>
    }
    USB_OTG_WRITE_REG32(&in_regs->DIEPTSIZ, deptsiz.d32);
    
    if (pdev->cfg.dma_enable == 1)
    {
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);  
 80024f4:	780b      	ldrb	r3, [r1, #0]
 80024f6:	690c      	ldr	r4, [r1, #16]
 80024f8:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
 80024fc:	f8dc 3018 	ldr.w	r3, [ip, #24]
 8002500:	615c      	str	r4, [r3, #20]
 8002502:	e7cf      	b.n	80024a4 <USB_OTG_EP0StartXfer+0xa4>
        ep->xfer_len = ep->maxpacket;
        deptsiz.b.xfersize = ep->maxpacket;
      }
      else
      {
        deptsiz.b.xfersize = ep->xfer_len;
 8002504:	f89d 3000 	ldrb.w	r3, [sp]
 8002508:	f364 0306 	bfi	r3, r4, #0, #7
 800250c:	f88d 3000 	strb.w	r3, [sp]
 8002510:	e7bc      	b.n	800248c <USB_OTG_EP0StartXfer+0x8c>
 8002512:	bf00      	nop

08002514 <USB_OTG_EPSetStall>:
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
 8002514:	784b      	ldrb	r3, [r1, #1]
 8002516:	2b01      	cmp	r3, #1
 8002518:	d00a      	beq.n	8002530 <USB_OTG_EPSetStall+0x1c>
    depctl.b.stall = 1;
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
  }
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 800251a:	7809      	ldrb	r1, [r1, #0]
 800251c:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
 8002520:	f8dc 3054 	ldr.w	r3, [ip, #84]	; 0x54
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 8002524:	681a      	ldr	r2, [r3, #0]
    /* set the stall bit */
    depctl.b.stall = 1;
 8002526:	f442 1000 	orr.w	r0, r2, #2097152	; 0x200000
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
 800252a:	6018      	str	r0, [r3, #0]
  }
  return status;
}
 800252c:	2000      	movs	r0, #0
 800252e:	4770      	bx	lr
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 8002530:	780b      	ldrb	r3, [r1, #0]
 8002532:	eb00 0283 	add.w	r2, r0, r3, lsl #2
 8002536:	6992      	ldr	r2, [r2, #24]
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 8002538:	6813      	ldr	r3, [r2, #0]
    /* set the disable and stall bits */
    if (depctl.b.epena)
 800253a:	f3c3 6c07 	ubfx	ip, r3, #24, #8
 800253e:	f00c 0080 	and.w	r0, ip, #128	; 0x80
 8002542:	b2c1      	uxtb	r1, r0
 8002544:	b109      	cbz	r1, 800254a <USB_OTG_EPSetStall+0x36>
    {
      depctl.b.epdis = 1;
 8002546:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    }
    depctl.b.stall = 1;
 800254a:	f443 1100 	orr.w	r1, r3, #2097152	; 0x200000
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
 800254e:	6011      	str	r1, [r2, #0]
    /* set the stall bit */
    depctl.b.stall = 1;
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
  }
  return status;
}
 8002550:	2000      	movs	r0, #0
 8002552:	4770      	bx	lr

08002554 <USB_OTG_EPClearStall>:
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  
  if (ep->is_in == 1)
 8002554:	f891 c001 	ldrb.w	ip, [r1, #1]
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 8002558:	780b      	ldrb	r3, [r1, #0]
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 800255a:	78c9      	ldrb	r1, [r1, #3]
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  
  if (ep->is_in == 1)
 800255c:	f1bc 0f01 	cmp.w	ip, #1
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 8002560:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
 8002564:	bf0c      	ite	eq
 8002566:	f8dc 2018 	ldreq.w	r2, [ip, #24]
  }
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 800256a:	f8dc 2054 	ldrne.w	r2, [ip, #84]	; 0x54
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 800256e:	1e88      	subs	r0, r1, #2
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
  }
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 8002570:	6813      	ldr	r3, [r2, #0]
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 8002572:	b2c1      	uxtb	r1, r0
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
 8002574:	f36f 5355 	bfc	r3, #21, #1
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 8002578:	2901      	cmp	r1, #1
  {
    depctl.b.setd0pid = 1; /* DATA0 */
 800257a:	bf98      	it	ls
 800257c:	f043 5380 	orrls.w	r3, r3, #268435456	; 0x10000000
  }
  USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
 8002580:	6013      	str	r3, [r2, #0]
  return status;
}
 8002582:	2000      	movs	r0, #0
 8002584:	4770      	bx	lr
 8002586:	bf00      	nop

08002588 <USB_OTG_ReadDevAllOutEp_itr>:
* @retval OUT endpoint interrupt bits
*/
uint32_t USB_OTG_ReadDevAllOutEp_itr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v;
  v  = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
 8002588:	6903      	ldr	r3, [r0, #16]
 800258a:	699a      	ldr	r2, [r3, #24]
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
 800258c:	69d9      	ldr	r1, [r3, #28]
 800258e:	ea01 0002 	and.w	r0, r1, r2
  return ((v & 0xffff0000) >> 16);
}
 8002592:	0c00      	lsrs	r0, r0, #16
 8002594:	4770      	bx	lr
 8002596:	bf00      	nop

08002598 <USB_OTG_ReadDevOutEP_itr>:
* @retval Device OUT EP Interrupt register
*/
uint32_t USB_OTG_ReadDevOutEP_itr(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
  uint32_t v;
  v  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[epnum]->DOEPINT);
 8002598:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOEPMSK);
 800259c:	6902      	ldr	r2, [r0, #16]
* @retval Device OUT EP Interrupt register
*/
uint32_t USB_OTG_ReadDevOutEP_itr(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
  uint32_t v;
  v  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[epnum]->DOEPINT);
 800259e:	f8dc 1054 	ldr.w	r1, [ip, #84]	; 0x54
 80025a2:	688b      	ldr	r3, [r1, #8]
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOEPMSK);
 80025a4:	6950      	ldr	r0, [r2, #20]
  return v;
}
 80025a6:	4018      	ands	r0, r3
 80025a8:	4770      	bx	lr
 80025aa:	bf00      	nop

080025ac <USB_OTG_ReadDevAllInEPItr>:
* @retval int status register
*/
uint32_t USB_OTG_ReadDevAllInEPItr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v;
  v = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
 80025ac:	6902      	ldr	r2, [r0, #16]
 80025ae:	6991      	ldr	r1, [r2, #24]
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
 80025b0:	69d3      	ldr	r3, [r2, #28]
 80025b2:	ea01 0003 	and.w	r0, r1, r3
  return (v & 0xffff);
}
 80025b6:	b280      	uxth	r0, r0
 80025b8:	4770      	bx	lr
 80025ba:	bf00      	nop

080025bc <USB_OTG_EP0_OutStart>:
* @brief  configures EPO to receive SETUP packets
* @param  None
* @retval : None
*/
void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
{
 80025bc:	b082      	sub	sp, #8
  USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
  doeptsize0.d32 = 0;
  doeptsize0.b.supcnt = 3;
  doeptsize0.b.pktcnt = 1;
 80025be:	2201      	movs	r2, #1
* @retval : None
*/
void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
  doeptsize0.d32 = 0;
 80025c0:	2300      	movs	r3, #0
  doeptsize0.b.supcnt = 3;
  doeptsize0.b.pktcnt = 1;
 80025c2:	2100      	movs	r1, #0
* @retval : None
*/
void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
  doeptsize0.d32 = 0;
 80025c4:	9300      	str	r3, [sp, #0]
  doeptsize0.b.supcnt = 3;
  doeptsize0.b.pktcnt = 1;
 80025c6:	f362 01c4 	bfi	r1, r2, #3, #2
  doeptsize0.b.xfersize = 8 * 3;
 80025ca:	2318      	movs	r3, #24
*/
void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
  doeptsize0.d32 = 0;
  doeptsize0.b.supcnt = 3;
 80025cc:	22c0      	movs	r2, #192	; 0xc0
 80025ce:	f88d 2003 	strb.w	r2, [sp, #3]
  doeptsize0.b.pktcnt = 1;
 80025d2:	f88d 1002 	strb.w	r1, [sp, #2]
  doeptsize0.b.xfersize = 8 * 3;
 80025d6:	f88d 3000 	strb.w	r3, [sp]
  USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPTSIZ, doeptsize0.d32 );
 80025da:	6d43      	ldr	r3, [r0, #84]	; 0x54
 80025dc:	9900      	ldr	r1, [sp, #0]
 80025de:	6119      	str	r1, [r3, #16]
  
  if (pdev->cfg.dma_enable == 1)
 80025e0:	78c2      	ldrb	r2, [r0, #3]
 80025e2:	2a01      	cmp	r2, #1
 80025e4:	d106      	bne.n	80025f4 <USB_OTG_EP0_OutStart+0x38>
  {
    USB_OTG_DEPCTL_TypeDef  doepctl;
    doepctl.d32 = 0;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPDMA, 
 80025e6:	f500 61b9 	add.w	r1, r0, #1480	; 0x5c8
 80025ea:	6159      	str	r1, [r3, #20]
    
    /* EP enable */
    doepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[0]->DOEPCTL);
    doepctl.b.epena = 1;
    doepctl.d32 = 0x80008000;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPCTL, doepctl.d32);
 80025ec:	f04f 2080 	mov.w	r0, #2147516416	; 0x80008000
    doepctl.d32 = 0;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPDMA, 
                        (uint32_t)&pdev->dev.setup_packet);
    
    /* EP enable */
    doepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[0]->DOEPCTL);
 80025f0:	681a      	ldr	r2, [r3, #0]
    doepctl.b.epena = 1;
    doepctl.d32 = 0x80008000;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPCTL, doepctl.d32);
 80025f2:	6018      	str	r0, [r3, #0]
  }
}
 80025f4:	b002      	add	sp, #8
 80025f6:	4770      	bx	lr

080025f8 <USB_OTG_ActiveRemoteWakeup>:
  
  USB_OTG_DCTL_TypeDef     dctl;
  USB_OTG_DSTS_TypeDef     dsts;
  USB_OTG_PCGCCTL_TypeDef  power;  
  
  if (pdev->dev.DevRemoteWakeup) 
 80025f8:	f8d0 3114 	ldr.w	r3, [r0, #276]	; 0x114
* @brief  USB_OTG_RemoteWakeup : active remote wakeup signalling
* @param  None
* @retval : None
*/
void USB_OTG_ActiveRemoteWakeup(USB_OTG_CORE_HANDLE *pdev)
{
 80025fc:	b510      	push	{r4, lr}
 80025fe:	4604      	mov	r4, r0
  
  USB_OTG_DCTL_TypeDef     dctl;
  USB_OTG_DSTS_TypeDef     dsts;
  USB_OTG_PCGCCTL_TypeDef  power;  
  
  if (pdev->dev.DevRemoteWakeup) 
 8002600:	b1db      	cbz	r3, 800263a <USB_OTG_ActiveRemoteWakeup+0x42>
  {
    dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8002602:	6903      	ldr	r3, [r0, #16]
 8002604:	689a      	ldr	r2, [r3, #8]
    if(dsts.b.suspsts == 1)
 8002606:	f012 0f01 	tst.w	r2, #1
 800260a:	d016      	beq.n	800263a <USB_OTG_ActiveRemoteWakeup+0x42>
    {
      if(pdev->cfg.low_power)
 800260c:	7a81      	ldrb	r1, [r0, #10]
 800260e:	b141      	cbz	r1, 8002622 <USB_OTG_ActiveRemoteWakeup+0x2a>
      {
        /* un-gate USB Core clock */
        power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
 8002610:	f8d0 210c 	ldr.w	r2, [r0, #268]	; 0x10c
        power.b.gatehclk = 0;
        power.b.stoppclk = 0;
        USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 8002614:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
    {
      if(pdev->cfg.low_power)
      {
        /* un-gate USB Core clock */
        power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
        power.b.gatehclk = 0;
 8002618:	f36f 0241 	bfc	r2, #1, #1
        power.b.stoppclk = 0;
 800261c:	f36f 0200 	bfc	r2, #0, #1
        USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 8002620:	6002      	str	r2, [r0, #0]
      }   
      /* active Remote wakeup signaling */
      dctl.d32 = 0;
      dctl.b.rmtwkupsig = 1;
      USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, 0, dctl.d32);
 8002622:	6859      	ldr	r1, [r3, #4]
 8002624:	f041 0201 	orr.w	r2, r1, #1
 8002628:	605a      	str	r2, [r3, #4]
      USB_OTG_BSP_mDelay(5);
 800262a:	2005      	movs	r0, #5
 800262c:	f001 f991 	bl	8003952 <USB_OTG_BSP_mDelay>
      USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
 8002630:	6923      	ldr	r3, [r4, #16]
 8002632:	6858      	ldr	r0, [r3, #4]
 8002634:	f020 0101 	bic.w	r1, r0, #1
 8002638:	6059      	str	r1, [r3, #4]
 800263a:	bd10      	pop	{r4, pc}

0800263c <USB_OTG_UngateClock>:
* @param  None
* @retval : None
*/
void USB_OTG_UngateClock(USB_OTG_CORE_HANDLE *pdev)
{
  if(pdev->cfg.low_power)
 800263c:	7a83      	ldrb	r3, [r0, #10]
 800263e:	b16b      	cbz	r3, 800265c <USB_OTG_UngateClock+0x20>
  {
    
    USB_OTG_DSTS_TypeDef     dsts;
    USB_OTG_PCGCCTL_TypeDef  power; 
    
    dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8002640:	6902      	ldr	r2, [r0, #16]
 8002642:	6891      	ldr	r1, [r2, #8]
    
    if(dsts.b.suspsts == 1)
 8002644:	f011 0f01 	tst.w	r1, #1
 8002648:	d008      	beq.n	800265c <USB_OTG_UngateClock+0x20>
    {
      /* un-gate USB Core clock */
      power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
 800264a:	f8d0 310c 	ldr.w	r3, [r0, #268]	; 0x10c
      power.b.gatehclk = 0;
      power.b.stoppclk = 0;
      USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 800264e:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
    
    if(dsts.b.suspsts == 1)
    {
      /* un-gate USB Core clock */
      power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
      power.b.gatehclk = 0;
 8002652:	f36f 0341 	bfc	r3, #1, #1
      power.b.stoppclk = 0;
 8002656:	f36f 0300 	bfc	r3, #0, #1
      USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 800265a:	6003      	str	r3, [r0, #0]
 800265c:	4770      	bx	lr
 800265e:	bf00      	nop

08002660 <USB_OTG_StopDevice>:
* @brief  Stop the device and clean up fifo's
* @param  None
* @retval : None
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
{
 8002660:	b570      	push	{r4, r5, r6, lr}
  uint32_t i;
  
  pdev->dev.device_status = 1;
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002662:	7843      	ldrb	r3, [r0, #1]
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t i;
  
  pdev->dev.device_status = 1;
 8002664:	2201      	movs	r2, #1
* @brief  Stop the device and clean up fifo's
* @param  None
* @retval : None
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
{
 8002666:	4604      	mov	r4, r0
  uint32_t i;
  
  pdev->dev.device_status = 1;
 8002668:	f880 2112 	strb.w	r2, [r0, #274]	; 0x112
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 800266c:	b163      	cbz	r3, 8002688 <USB_OTG_StopDevice+0x28>
/**
* @brief  Stop the device and clean up fifo's
* @param  None
* @retval : None
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
 800266e:	f100 0214 	add.w	r2, r0, #20
{
  uint32_t i;
  
  pdev->dev.device_status = 1;
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002672:	2300      	movs	r3, #0
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 8002674:	21ff      	movs	r1, #255	; 0xff
 8002676:	f852 5f04 	ldr.w	r5, [r2, #4]!
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 800267a:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
  
  pdev->dev.device_status = 1;
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 800267c:	60a9      	str	r1, [r5, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 800267e:	6081      	str	r1, [r0, #8]
{
  uint32_t i;
  
  pdev->dev.device_status = 1;
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002680:	7860      	ldrb	r0, [r4, #1]
 8002682:	3301      	adds	r3, #1
 8002684:	4298      	cmp	r0, r3
 8002686:	d8f6      	bhi.n	8002676 <USB_OTG_StopDevice+0x16>
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }

  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 8002688:	6923      	ldr	r3, [r4, #16]
 800268a:	2200      	movs	r2, #0
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
 800268c:	f04f 31ff 	mov.w	r1, #4294967295
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }

  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 8002690:	611a      	str	r2, [r3, #16]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
 8002692:	4620      	mov	r0, r4
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }

  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
 8002694:	615a      	str	r2, [r3, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
 8002696:	61da      	str	r2, [r3, #28]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
 8002698:	6199      	str	r1, [r3, #24]
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
 800269a:	f7ff fc55 	bl	8001f48 <USB_OTG_FlushRxFifo>
  USB_OTG_FlushTxFifo(pdev ,  0x10 );  
 800269e:	4620      	mov	r0, r4
 80026a0:	2110      	movs	r1, #16
}
 80026a2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
  USB_OTG_FlushTxFifo(pdev ,  0x10 );  
 80026a6:	e425      	b.n	8001ef4 <USB_OTG_FlushTxFifo>

080026a8 <USB_OTG_GetEPStatus>:
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  uint32_t Status = 0;  
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
 80026a8:	784b      	ldrb	r3, [r1, #1]
 80026aa:	2b01      	cmp	r3, #1
 80026ac:	d01a      	beq.n	80026e4 <USB_OTG_GetEPStatus+0x3c>
      Status = USB_OTG_EP_TX_VALID;     

  }
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 80026ae:	780b      	ldrb	r3, [r1, #0]
 80026b0:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 80026b4:	6d42      	ldr	r2, [r0, #84]	; 0x54
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 80026b6:	6811      	ldr	r1, [r2, #0]
    if (depctl.b.stall == 1)  
 80026b8:	f3c1 4007 	ubfx	r0, r1, #16, #8
 80026bc:	f000 0c20 	and.w	ip, r0, #32
 80026c0:	fa5f f38c 	uxtb.w	r3, ip
 80026c4:	b95b      	cbnz	r3, 80026de <USB_OTG_GetEPStatus+0x36>
      Status = USB_OTG_EP_RX_STALL;
    else if (depctl.b.naksts == 1)
 80026c6:	f000 0102 	and.w	r1, r0, #2
 80026ca:	fa5f fc81 	uxtb.w	ip, r1
      Status = USB_OTG_EP_RX_NAK;
 80026ce:	f1bc 0f00 	cmp.w	ip, #0
 80026d2:	bf0c      	ite	eq
 80026d4:	f44f 5040 	moveq.w	r0, #12288	; 0x3000
 80026d8:	f44f 5000 	movne.w	r0, #8192	; 0x2000
 80026dc:	4770      	bx	lr
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
    if (depctl.b.stall == 1)  
      Status = USB_OTG_EP_RX_STALL;
 80026de:	f44f 5080 	mov.w	r0, #4096	; 0x1000
      Status = USB_OTG_EP_RX_VALID; 
  } 
  
  /* Return the current status */
  return Status;
}
 80026e2:	4770      	bx	lr
  uint32_t Status = 0;  
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 80026e4:	7809      	ldrb	r1, [r1, #0]
 80026e6:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
 80026ea:	f8dc 3018 	ldr.w	r3, [ip, #24]
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 80026ee:	6818      	ldr	r0, [r3, #0]
    
    if (depctl.b.stall == 1)  
 80026f0:	f3c0 4007 	ubfx	r0, r0, #16, #8
 80026f4:	f000 0220 	and.w	r2, r0, #32
 80026f8:	b2d1      	uxtb	r1, r2
 80026fa:	b939      	cbnz	r1, 800270c <USB_OTG_GetEPStatus+0x64>
      Status = USB_OTG_EP_TX_STALL;
    else if (depctl.b.naksts == 1)
 80026fc:	f000 0002 	and.w	r0, r0, #2
 8002700:	b2c2      	uxtb	r2, r0
      Status = USB_OTG_EP_TX_NAK;
 8002702:	2a00      	cmp	r2, #0
 8002704:	bf0c      	ite	eq
 8002706:	2030      	moveq	r0, #48	; 0x30
 8002708:	2020      	movne	r0, #32
 800270a:	4770      	bx	lr
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
    
    if (depctl.b.stall == 1)  
      Status = USB_OTG_EP_TX_STALL;
 800270c:	2010      	movs	r0, #16
 800270e:	4770      	bx	lr

08002710 <USB_OTG_SetEPStatus>:
*         Status : new Status
*         ep : EP structure
* @retval : None
*/
void USB_OTG_SetEPStatus (USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep , uint32_t Status)
{
 8002710:	b470      	push	{r4, r5, r6}
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;

  /* Process for IN endpoint */
  if (ep->is_in == 1)
 8002712:	784d      	ldrb	r5, [r1, #1]
 8002714:	2d01      	cmp	r5, #1
 8002716:	d016      	beq.n	8002746 <USB_OTG_SetEPStatus+0x36>
    else if (Status == USB_OTG_EP_TX_DIS)
      depctl.b.usbactep = 0;
  } 
  else /* Process for OUT endpoint */
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 8002718:	f891 c000 	ldrb.w	ip, [r1]
 800271c:	eb00 068c 	add.w	r6, r0, ip, lsl #2
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);    
    
    if (Status == USB_OTG_EP_RX_STALL)  {
 8002720:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    else if (Status == USB_OTG_EP_TX_DIS)
      depctl.b.usbactep = 0;
  } 
  else /* Process for OUT endpoint */
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 8002724:	6d75      	ldr	r5, [r6, #84]	; 0x54
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);    
 8002726:	682c      	ldr	r4, [r5, #0]
 8002728:	4626      	mov	r6, r4
    
    if (Status == USB_OTG_EP_RX_STALL)  {
 800272a:	d019      	beq.n	8002760 <USB_OTG_SetEPStatus+0x50>
      depctl.b.stall = 1;
    }
    else if (Status == USB_OTG_EP_RX_NAK)
 800272c:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8002730:	d013      	beq.n	800275a <USB_OTG_SetEPStatus+0x4a>
      depctl.b.snak = 1;
    else if (Status == USB_OTG_EP_RX_VALID)
 8002732:	f5b2 5f40 	cmp.w	r2, #12288	; 0x3000
 8002736:	d018      	beq.n	800276a <USB_OTG_SetEPStatus+0x5a>
      }  
      depctl.b.cnak = 1;
      depctl.b.usbactep = 1;    
      depctl.b.epena = 1;
    }
    else if (Status == USB_OTG_EP_RX_DIS)
 8002738:	b912      	cbnz	r2, 8002740 <USB_OTG_SetEPStatus+0x30>
    {
      depctl.b.usbactep = 0;    
 800273a:	f362 36cf 	bfi	r6, r2, #15, #1
 800273e:	4634      	mov	r4, r6
    }
  }

  USB_OTG_WRITE_REG32(depctl_addr, depctl.d32); 
 8002740:	602c      	str	r4, [r5, #0]
}
 8002742:	bc70      	pop	{r4, r5, r6}
 8002744:	4770      	bx	lr
  depctl.d32 = 0;

  /* Process for IN endpoint */
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 8002746:	780b      	ldrb	r3, [r1, #0]
 8002748:	eb00 0483 	add.w	r4, r0, r3, lsl #2
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
    
    if (Status == USB_OTG_EP_TX_STALL)  
 800274c:	2a10      	cmp	r2, #16
  depctl.d32 = 0;

  /* Process for IN endpoint */
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 800274e:	69a5      	ldr	r5, [r4, #24]
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 8002750:	682c      	ldr	r4, [r5, #0]
 8002752:	4626      	mov	r6, r4
    
    if (Status == USB_OTG_EP_TX_STALL)  
 8002754:	d018      	beq.n	8002788 <USB_OTG_SetEPStatus+0x78>
    {
      USB_OTG_EPSetStall(pdev, ep); return;
    }
    else if (Status == USB_OTG_EP_TX_NAK)
 8002756:	2a20      	cmp	r2, #32
 8002758:	d105      	bne.n	8002766 <USB_OTG_SetEPStatus+0x56>
    
    if (Status == USB_OTG_EP_RX_STALL)  {
      depctl.b.stall = 1;
    }
    else if (Status == USB_OTG_EP_RX_NAK)
      depctl.b.snak = 1;
 800275a:	f044 6400 	orr.w	r4, r4, #134217728	; 0x8000000
 800275e:	e7ef      	b.n	8002740 <USB_OTG_SetEPStatus+0x30>
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);    
    
    if (Status == USB_OTG_EP_RX_STALL)  {
      depctl.b.stall = 1;
 8002760:	f444 1400 	orr.w	r4, r4, #2097152	; 0x200000
 8002764:	e7ec      	b.n	8002740 <USB_OTG_SetEPStatus+0x30>
    {
      USB_OTG_EPSetStall(pdev, ep); return;
    }
    else if (Status == USB_OTG_EP_TX_NAK)
      depctl.b.snak = 1;
    else if (Status == USB_OTG_EP_TX_VALID)
 8002766:	2a30      	cmp	r2, #48	; 0x30
 8002768:	d1e6      	bne.n	8002738 <USB_OTG_SetEPStatus+0x28>
    }
    else if (Status == USB_OTG_EP_RX_NAK)
      depctl.b.snak = 1;
    else if (Status == USB_OTG_EP_RX_VALID)
    {
      if (depctl.b.stall == 1)
 800276a:	f3c4 4c07 	ubfx	ip, r4, #16, #8
 800276e:	f00c 0320 	and.w	r3, ip, #32
 8002772:	b2da      	uxtb	r2, r3
 8002774:	b922      	cbnz	r2, 8002780 <USB_OTG_SetEPStatus+0x70>
      {  
        ep->even_odd_frame = 0;
        USB_OTG_EPClearStall(pdev, ep);
        return;
      }  
      depctl.b.cnak = 1;
 8002776:	f044 6080 	orr.w	r0, r4, #67108864	; 0x4000000
      depctl.b.usbactep = 1;    
      depctl.b.epena = 1;
 800277a:	f040 2480 	orr.w	r4, r0, #2147516416	; 0x80008000
 800277e:	e7df      	b.n	8002740 <USB_OTG_SetEPStatus+0x30>
      depctl.b.snak = 1;
    else if (Status == USB_OTG_EP_RX_VALID)
    {
      if (depctl.b.stall == 1)
      {  
        ep->even_odd_frame = 0;
 8002780:	2200      	movs	r2, #0
 8002782:	714a      	strb	r2, [r1, #5]
      depctl.b.usbactep = 0;    
    }
  }

  USB_OTG_WRITE_REG32(depctl_addr, depctl.d32); 
}
 8002784:	bc70      	pop	{r4, r5, r6}
    else if (Status == USB_OTG_EP_RX_VALID)
    {
      if (depctl.b.stall == 1)
      {  
        ep->even_odd_frame = 0;
        USB_OTG_EPClearStall(pdev, ep);
 8002786:	e6e5      	b.n	8002554 <USB_OTG_EPClearStall>
      depctl.b.usbactep = 0;    
    }
  }

  USB_OTG_WRITE_REG32(depctl_addr, depctl.d32); 
}
 8002788:	bc70      	pop	{r4, r5, r6}
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
    
    if (Status == USB_OTG_EP_TX_STALL)  
    {
      USB_OTG_EPSetStall(pdev, ep); return;
 800278a:	e6c3      	b.n	8002514 <USB_OTG_EPSetStall>

0800278c <DCD_Init>:



void DCD_Init(USB_OTG_CORE_HANDLE *pdev , 
              USB_OTG_CORE_ID_TypeDef coreID)
{
 800278c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002790:	4604      	mov	r4, r0
  uint32_t i;
  USB_OTG_EP *ep;
  
  USB_OTG_SelectCore (pdev , coreID);
 8002792:	f7ff fa3b 	bl	8001c0c <USB_OTG_SelectCore>
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002796:	7866      	ldrb	r6, [r4, #1]
  uint32_t i;
  USB_OTG_EP *ep;
  
  USB_OTG_SelectCore (pdev , coreID);
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
 8002798:	2701      	movs	r7, #1
  pdev->dev.device_address = 0;
 800279a:	2100      	movs	r1, #0
  uint32_t i;
  USB_OTG_EP *ep;
  
  USB_OTG_SelectCore (pdev , coreID);
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
 800279c:	f884 7112 	strb.w	r7, [r4, #274]	; 0x112
  pdev->dev.device_address = 0;
 80027a0:	f884 1113 	strb.w	r1, [r4, #275]	; 0x113
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80027a4:	2e00      	cmp	r6, #0
 80027a6:	f000 809a 	beq.w	80028de <DCD_Init+0x152>
 80027aa:	1e73      	subs	r3, r6, #1
    ep->is_in = 1;
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 80027ac:	f04f 0e40 	mov.w	lr, #64	; 0x40
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80027b0:	42b7      	cmp	r7, r6
 80027b2:	ea03 0207 	and.w	r2, r3, r7
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
 80027b6:	f884 7119 	strb.w	r7, [r4, #281]	; 0x119
    ep->num = i;
 80027ba:	f884 1118 	strb.w	r1, [r4, #280]	; 0x118
    ep->tx_fifo_num = i;
 80027be:	f8a4 111e 	strh.w	r1, [r4, #286]	; 0x11e
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 80027c2:	f884 111b 	strb.w	r1, [r4, #283]	; 0x11b
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 80027c6:	f8c4 e120 	str.w	lr, [r4, #288]	; 0x120
    ep->xfer_buff = 0;
 80027ca:	f8c4 1124 	str.w	r1, [r4, #292]	; 0x124
    ep->xfer_len = 0;
 80027ce:	f8c4 112c 	str.w	r1, [r4, #300]	; 0x12c
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80027d2:	4638      	mov	r0, r7
 80027d4:	f104 0328 	add.w	r3, r4, #40	; 0x28
 80027d8:	d234      	bcs.n	8002844 <DCD_Init+0xb8>
 80027da:	b192      	cbz	r2, 8002802 <DCD_Init+0x76>
 80027dc:	2002      	movs	r0, #2
 80027de:	42b0      	cmp	r0, r6
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
 80027e0:	f883 7119 	strb.w	r7, [r3, #281]	; 0x119
    ep->num = i;
 80027e4:	f883 7118 	strb.w	r7, [r3, #280]	; 0x118
    ep->tx_fifo_num = i;
 80027e8:	f8a3 711e 	strh.w	r7, [r3, #286]	; 0x11e
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 80027ec:	f883 111b 	strb.w	r1, [r3, #283]	; 0x11b
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 80027f0:	f8c3 e120 	str.w	lr, [r3, #288]	; 0x120
    ep->xfer_buff = 0;
 80027f4:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
    ep->xfer_len = 0;
 80027f8:	f8c3 112c 	str.w	r1, [r3, #300]	; 0x12c
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80027fc:	f104 0350 	add.w	r3, r4, #80	; 0x50
 8002800:	d220      	bcs.n	8002844 <DCD_Init+0xb8>
 8002802:	1c45      	adds	r5, r0, #1
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
    ep->num = i;
 8002804:	f883 0118 	strb.w	r0, [r3, #280]	; 0x118
    ep->tx_fifo_num = i;
 8002808:	f8a3 011e 	strh.w	r0, [r3, #286]	; 0x11e
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 800280c:	3002      	adds	r0, #2
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
 800280e:	f883 7119 	strb.w	r7, [r3, #281]	; 0x119
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 8002812:	f883 111b 	strb.w	r1, [r3, #283]	; 0x11b
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 8002816:	f8c3 e120 	str.w	lr, [r3, #288]	; 0x120
    ep->xfer_buff = 0;
 800281a:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
    ep->xfer_len = 0;
 800281e:	f8c3 112c 	str.w	r1, [r3, #300]	; 0x12c
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
 8002822:	f883 7141 	strb.w	r7, [r3, #321]	; 0x141
    ep->num = i;
 8002826:	f883 5140 	strb.w	r5, [r3, #320]	; 0x140
    ep->tx_fifo_num = i;
 800282a:	f8a3 5146 	strh.w	r5, [r3, #326]	; 0x146
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 800282e:	f883 1143 	strb.w	r1, [r3, #323]	; 0x143
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 8002832:	f8c3 e148 	str.w	lr, [r3, #328]	; 0x148
    ep->xfer_buff = 0;
 8002836:	f8c3 114c 	str.w	r1, [r3, #332]	; 0x14c
    ep->xfer_len = 0;
 800283a:	f8c3 1154 	str.w	r1, [r3, #340]	; 0x154
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 800283e:	3350      	adds	r3, #80	; 0x50
 8002840:	42b0      	cmp	r0, r6
 8002842:	d3de      	bcc.n	8002802 <DCD_Init+0x76>
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8002844:	2001      	movs	r0, #1
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002846:	2200      	movs	r2, #0
    ep->is_in = 0;
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 8002848:	2740      	movs	r7, #64	; 0x40
 800284a:	1e71      	subs	r1, r6, #1
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 800284c:	42b0      	cmp	r0, r6
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 800284e:	f884 2371 	strb.w	r2, [r4, #881]	; 0x371
    ep->num = i;
 8002852:	f884 2370 	strb.w	r2, [r4, #880]	; 0x370
    ep->tx_fifo_num = i;
 8002856:	f8a4 2376 	strh.w	r2, [r4, #886]	; 0x376
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
 800285a:	f884 2373 	strb.w	r2, [r4, #883]	; 0x373
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 800285e:	f8c4 7378 	str.w	r7, [r4, #888]	; 0x378
    ep->xfer_buff = 0;
 8002862:	f8c4 237c 	str.w	r2, [r4, #892]	; 0x37c
    ep->xfer_len = 0;
 8002866:	f8c4 2384 	str.w	r2, [r4, #900]	; 0x384
 800286a:	ea01 0100 	and.w	r1, r1, r0
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 800286e:	f104 0328 	add.w	r3, r4, #40	; 0x28
 8002872:	d234      	bcs.n	80028de <DCD_Init+0x152>
 8002874:	b191      	cbz	r1, 800289c <DCD_Init+0x110>
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
    ep->num = i;
 8002876:	f883 0370 	strb.w	r0, [r3, #880]	; 0x370
    ep->tx_fifo_num = i;
 800287a:	f8a3 0376 	strh.w	r0, [r3, #886]	; 0x376
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 800287e:	2002      	movs	r0, #2
 8002880:	42b0      	cmp	r0, r6
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 8002882:	f883 2371 	strb.w	r2, [r3, #881]	; 0x371
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
 8002886:	f883 2373 	strb.w	r2, [r3, #883]	; 0x373
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 800288a:	f8c3 7378 	str.w	r7, [r3, #888]	; 0x378
    ep->xfer_buff = 0;
 800288e:	f8c3 237c 	str.w	r2, [r3, #892]	; 0x37c
    ep->xfer_len = 0;
 8002892:	f8c3 2384 	str.w	r2, [r3, #900]	; 0x384
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8002896:	f104 0350 	add.w	r3, r4, #80	; 0x50
 800289a:	d220      	bcs.n	80028de <DCD_Init+0x152>
 800289c:	1c45      	adds	r5, r0, #1
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
    ep->num = i;
 800289e:	f883 0370 	strb.w	r0, [r3, #880]	; 0x370
    ep->tx_fifo_num = i;
 80028a2:	f8a3 0376 	strh.w	r0, [r3, #886]	; 0x376
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 80028a6:	3002      	adds	r0, #2
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 80028a8:	f883 2371 	strb.w	r2, [r3, #881]	; 0x371
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
 80028ac:	f883 2373 	strb.w	r2, [r3, #883]	; 0x373
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 80028b0:	f8c3 7378 	str.w	r7, [r3, #888]	; 0x378
    ep->xfer_buff = 0;
 80028b4:	f8c3 237c 	str.w	r2, [r3, #892]	; 0x37c
    ep->xfer_len = 0;
 80028b8:	f8c3 2384 	str.w	r2, [r3, #900]	; 0x384
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 80028bc:	f883 2399 	strb.w	r2, [r3, #921]	; 0x399
    ep->num = i;
 80028c0:	f883 5398 	strb.w	r5, [r3, #920]	; 0x398
    ep->tx_fifo_num = i;
 80028c4:	f8a3 539e 	strh.w	r5, [r3, #926]	; 0x39e
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
 80028c8:	f883 239b 	strb.w	r2, [r3, #923]	; 0x39b
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 80028cc:	f8c3 73a0 	str.w	r7, [r3, #928]	; 0x3a0
    ep->xfer_buff = 0;
 80028d0:	f8c3 23a4 	str.w	r2, [r3, #932]	; 0x3a4
    ep->xfer_len = 0;
 80028d4:	f8c3 23ac 	str.w	r2, [r3, #940]	; 0x3ac
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 80028d8:	3350      	adds	r3, #80	; 0x50
 80028da:	42b0      	cmp	r0, r6
 80028dc:	d3de      	bcc.n	800289c <DCD_Init+0x110>
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  USB_OTG_DisableGlobalInt(pdev);
 80028de:	4620      	mov	r0, r4
 80028e0:	f7ff fb00 	bl	8001ee4 <USB_OTG_DisableGlobalInt>
  
  /*Init the Core (common init.) */
  USB_OTG_CoreInit(pdev);
 80028e4:	4620      	mov	r0, r4
 80028e6:	f7ff fa73 	bl	8001dd0 <USB_OTG_CoreInit>


  /* Force Device Mode*/
  USB_OTG_SetCurrentMode(pdev, DEVICE_MODE);
 80028ea:	2100      	movs	r1, #0
 80028ec:	4620      	mov	r0, r4
 80028ee:	f7ff fb51 	bl	8001f94 <USB_OTG_SetCurrentMode>
  
  /* Init Device */
  USB_OTG_CoreInitDev(pdev);
 80028f2:	4620      	mov	r0, r4
 80028f4:	f7ff fbac 	bl	8002050 <USB_OTG_CoreInitDev>
  
  
  /* Enable USB Global interrupt */
  USB_OTG_EnableGlobalInt(pdev);
 80028f8:	4620      	mov	r0, r4
}
 80028fa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  /* Init Device */
  USB_OTG_CoreInitDev(pdev);
  
  
  /* Enable USB Global interrupt */
  USB_OTG_EnableGlobalInt(pdev);
 80028fe:	f7ff bae9 	b.w	8001ed4 <USB_OTG_EnableGlobalInt>
 8002902:	bf00      	nop

08002904 <DCD_EP_Open>:
*/
uint32_t DCD_EP_Open(USB_OTG_CORE_HANDLE *pdev , 
                     uint8_t ep_addr,
                     uint16_t ep_mps,
                     uint8_t ep_type)
{
 8002904:	b538      	push	{r3, r4, r5, lr}
  USB_OTG_EP *ep;
  
  if ((ep_addr & 0x80) == 0x80)
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002906:	f001 057f 	and.w	r5, r1, #127	; 0x7f
                     uint16_t ep_mps,
                     uint8_t ep_type)
{
  USB_OTG_EP *ep;
  
  if ((ep_addr & 0x80) == 0x80)
 800290a:	b2cc      	uxtb	r4, r1
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 800290c:	eb05 0185 	add.w	r1, r5, r5, lsl #2
 8002910:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
                     uint16_t ep_mps,
                     uint8_t ep_type)
{
  USB_OTG_EP *ep;
  
  if ((ep_addr & 0x80) == 0x80)
 8002914:	f014 0f80 	tst.w	r4, #128	; 0x80
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002918:	bf14      	ite	ne
 800291a:	f501 718c 	addne.w	r1, r1, #280	; 0x118
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 800291e:	f501 715c 	addeq.w	r1, r1, #880	; 0x370
  }
  ep->num   = ep_addr & 0x7F;
 8002922:	b2ed      	uxtb	r5, r5
  
  ep->is_in = (0x80 & ep_addr) != 0;
 8002924:	09e4      	lsrs	r4, r4, #7
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
 8002926:	700d      	strb	r5, [r1, #0]
  
  ep->is_in = (0x80 & ep_addr) != 0;
 8002928:	704c      	strb	r4, [r1, #1]
  ep->maxpacket = ep_mps;
 800292a:	608a      	str	r2, [r1, #8]
  ep->type = ep_type;
 800292c:	70cb      	strb	r3, [r1, #3]
  if (ep->is_in)
 800292e:	b104      	cbz	r4, 8002932 <DCD_EP_Open+0x2e>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 8002930:	80cd      	strh	r5, [r1, #6]
  }
  /* Set initial data PID. */
  if (ep_type == USB_OTG_EP_BULK )
 8002932:	2b02      	cmp	r3, #2
 8002934:	d101      	bne.n	800293a <DCD_EP_Open+0x36>
  {
    ep->data_pid_start = 0;
 8002936:	2300      	movs	r3, #0
 8002938:	710b      	strb	r3, [r1, #4]
  }
  USB_OTG_EPActivate(pdev , ep );
 800293a:	f7ff fc3b 	bl	80021b4 <USB_OTG_EPActivate>
  return 0;
}
 800293e:	2000      	movs	r0, #0
 8002940:	bd38      	pop	{r3, r4, r5, pc}
 8002942:	bf00      	nop

08002944 <DCD_EP_Close>:
{
  USB_OTG_EP *ep;
  
  if ((ep_addr&0x80) == 0x80)
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002944:	f001 027f 	and.w	r2, r1, #127	; 0x7f
* @param pdev: device instance
* @param ep_addr: endpoint address
* @retval : status
*/
uint32_t DCD_EP_Close(USB_OTG_CORE_HANDLE *pdev , uint8_t  ep_addr)
{
 8002948:	b508      	push	{r3, lr}
  USB_OTG_EP *ep;
  
  if ((ep_addr&0x80) == 0x80)
 800294a:	b2cb      	uxtb	r3, r1
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 800294c:	eb02 0182 	add.w	r1, r2, r2, lsl #2
*/
uint32_t DCD_EP_Close(USB_OTG_CORE_HANDLE *pdev , uint8_t  ep_addr)
{
  USB_OTG_EP *ep;
  
  if ((ep_addr&0x80) == 0x80)
 8002950:	f013 0f80 	tst.w	r3, #128	; 0x80
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002954:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
 8002958:	bf14      	ite	ne
 800295a:	f501 718c 	addne.w	r1, r1, #280	; 0x118
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 800295e:	f501 715c 	addeq.w	r1, r1, #880	; 0x370
  }
  ep->num   = ep_addr & 0x7F;
  ep->is_in = (0x80 & ep_addr) != 0;
 8002962:	09db      	lsrs	r3, r3, #7
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
 8002964:	700a      	strb	r2, [r1, #0]
  ep->is_in = (0x80 & ep_addr) != 0;
 8002966:	704b      	strb	r3, [r1, #1]
  USB_OTG_EPDeactivate(pdev , ep );
 8002968:	f7ff fc5a 	bl	8002220 <USB_OTG_EPDeactivate>
  return 0;
}
 800296c:	2000      	movs	r0, #0
 800296e:	bd08      	pop	{r3, pc}

08002970 <DCD_EP_PrepareRx>:
                            uint8_t *pbuf,                        
                            uint16_t  buf_len)
{
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8002970:	f001 017f 	and.w	r1, r1, #127	; 0x7f
*/
uint32_t   DCD_EP_PrepareRx( USB_OTG_CORE_HANDLE *pdev,
                            uint8_t   ep_addr,
                            uint8_t *pbuf,                        
                            uint16_t  buf_len)
{
 8002974:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8002976:	eb01 0581 	add.w	r5, r1, r1, lsl #2
 800297a:	00ec      	lsls	r4, r5, #3
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
 800297c:	1905      	adds	r5, r0, r4
  ep->xfer_len = buf_len;
  ep->xfer_count = 0;
 800297e:	2700      	movs	r7, #0
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
 8002980:	b2ce      	uxtb	r6, r1
 8002982:	f885 6370 	strb.w	r6, [r5, #880]	; 0x370
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
  ep->xfer_len = buf_len;
  ep->xfer_count = 0;
  ep->is_in = 0;
 8002986:	f885 7371 	strb.w	r7, [r5, #881]	; 0x371
  ep->num = ep_addr & 0x7F;
  
  if (pdev->cfg.dma_enable == 1)
 800298a:	f890 e003 	ldrb.w	lr, [r0, #3]
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
  ep->xfer_len = buf_len;
 800298e:	f8c5 3384 	str.w	r3, [r5, #900]	; 0x384
  ep->xfer_count = 0;
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
  
  if (pdev->cfg.dma_enable == 1)
 8002992:	f1be 0f01 	cmp.w	lr, #1
                            uint8_t *pbuf,                        
                            uint16_t  buf_len)
{
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8002996:	f504 745c 	add.w	r4, r4, #880	; 0x370
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
  
  if (pdev->cfg.dma_enable == 1)
  {
    ep->dma_addr = (uint32_t)pbuf;  
 800299a:	bf08      	it	eq
 800299c:	b2f6      	uxtbeq	r6, r6
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
 800299e:	f8c5 237c 	str.w	r2, [r5, #892]	; 0x37c
  ep->xfer_len = buf_len;
  ep->xfer_count = 0;
 80029a2:	f8c5 7388 	str.w	r7, [r5, #904]	; 0x388
                            uint8_t *pbuf,                        
                            uint16_t  buf_len)
{
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 80029a6:	eb00 0104 	add.w	r1, r0, r4
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
  
  if (pdev->cfg.dma_enable == 1)
  {
    ep->dma_addr = (uint32_t)pbuf;  
 80029aa:	bf08      	it	eq
 80029ac:	f8c5 2380 	streq.w	r2, [r5, #896]	; 0x380
  }
  
  if ( ep->num == 0 )
 80029b0:	b11e      	cbz	r6, 80029ba <DCD_EP_PrepareRx+0x4a>
  {
    USB_OTG_EP0StartXfer(pdev , ep);
  }
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
 80029b2:	f7ff fc59 	bl	8002268 <USB_OTG_EPStartXfer>
  }
  return 0;
}
 80029b6:	2000      	movs	r0, #0
 80029b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ep->dma_addr = (uint32_t)pbuf;  
  }
  
  if ( ep->num == 0 )
  {
    USB_OTG_EP0StartXfer(pdev , ep);
 80029ba:	f7ff fd21 	bl	8002400 <USB_OTG_EP0StartXfer>
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
  }
  return 0;
}
 80029be:	2000      	movs	r0, #0
 80029c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80029c2:	bf00      	nop

080029c4 <DCD_EP_Tx>:
*/
uint32_t  DCD_EP_Tx ( USB_OTG_CORE_HANDLE *pdev,
                     uint8_t   ep_addr,
                     uint8_t   *pbuf,
                     uint32_t   buf_len)
{
 80029c4:	b570      	push	{r4, r5, r6, lr}
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 80029c6:	f001 057f 	and.w	r5, r1, #127	; 0x7f
 80029ca:	eb05 0485 	add.w	r4, r5, r5, lsl #2
 80029ce:	00e1      	lsls	r1, r4, #3
  
  /* Setup and start the Transfer */
  ep->is_in = 1;
 80029d0:	1844      	adds	r4, r0, r1
                     uint8_t   *pbuf,
                     uint32_t   buf_len)
{
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 80029d2:	f501 768c 	add.w	r6, r1, #280	; 0x118
 80029d6:	1981      	adds	r1, r0, r6
  
  /* Setup and start the Transfer */
  ep->is_in = 1;
  ep->num = ep_addr & 0x7F;  
  ep->xfer_buff = pbuf;
 80029d8:	f8c4 2124 	str.w	r2, [r4, #292]	; 0x124
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
  
  /* Setup and start the Transfer */
  ep->is_in = 1;
 80029dc:	2601      	movs	r6, #1
  ep->num = ep_addr & 0x7F;  
  ep->xfer_buff = pbuf;
  ep->dma_addr = (uint32_t)pbuf;  
 80029de:	f8c4 2128 	str.w	r2, [r4, #296]	; 0x128
  ep->xfer_count = 0;
 80029e2:	2200      	movs	r2, #0
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
  
  /* Setup and start the Transfer */
  ep->is_in = 1;
 80029e4:	f884 6119 	strb.w	r6, [r4, #281]	; 0x119
  ep->num = ep_addr & 0x7F;  
 80029e8:	f884 5118 	strb.w	r5, [r4, #280]	; 0x118
  ep->xfer_buff = pbuf;
  ep->dma_addr = (uint32_t)pbuf;  
  ep->xfer_count = 0;
 80029ec:	f8c4 2130 	str.w	r2, [r4, #304]	; 0x130
  ep->xfer_len  = buf_len;
 80029f0:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
  
  if ( ep->num == 0 )
 80029f4:	b11d      	cbz	r5, 80029fe <DCD_EP_Tx+0x3a>
  {
    USB_OTG_EP0StartXfer(pdev , ep);
  }
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
 80029f6:	f7ff fc37 	bl	8002268 <USB_OTG_EPStartXfer>
  }
  return 0;
}
 80029fa:	2000      	movs	r0, #0
 80029fc:	bd70      	pop	{r4, r5, r6, pc}
  ep->xfer_count = 0;
  ep->xfer_len  = buf_len;
  
  if ( ep->num == 0 )
  {
    USB_OTG_EP0StartXfer(pdev , ep);
 80029fe:	f7ff fcff 	bl	8002400 <USB_OTG_EP0StartXfer>
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
  }
  return 0;
}
 8002a02:	2000      	movs	r0, #0
 8002a04:	bd70      	pop	{r4, r5, r6, pc}
 8002a06:	bf00      	nop

08002a08 <DCD_EP_Stall>:
* @retval : status
*/
uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 8002a08:	b2ca      	uxtb	r2, r1
 8002a0a:	f012 0f80 	tst.w	r2, #128	; 0x80
* @param pdev: device instance
* @param epnum: endpoint address
* @retval : status
*/
uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
{
 8002a0e:	b510      	push	{r4, lr}
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 8002a10:	d111      	bne.n	8002a36 <DCD_EP_Stall+0x2e>
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8002a12:	eb01 0e81 	add.w	lr, r1, r1, lsl #2
 8002a16:	eb00 0cce 	add.w	ip, r0, lr, lsl #3
 8002a1a:	f50c 735c 	add.w	r3, ip, #880	; 0x370
 8002a1e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
  }

  ep->is_stall = 1;
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 8002a22:	09d2      	lsrs	r2, r2, #7
  else
  {
    ep = &pdev->dev.out_ep[epnum];
  }

  ep->is_stall = 1;
 8002a24:	2401      	movs	r4, #1
  ep->num   = epnum & 0x7F;
 8002a26:	7019      	strb	r1, [r3, #0]
  else
  {
    ep = &pdev->dev.out_ep[epnum];
  }

  ep->is_stall = 1;
 8002a28:	709c      	strb	r4, [r3, #2]
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 8002a2a:	705a      	strb	r2, [r3, #1]
  
  USB_OTG_EPSetStall(pdev , ep);
 8002a2c:	4619      	mov	r1, r3
 8002a2e:	f7ff fd71 	bl	8002514 <USB_OTG_EPSetStall>
  return (0);
}
 8002a32:	2000      	movs	r0, #0
 8002a34:	bd10      	pop	{r4, pc}
uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];
 8002a36:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8002a3a:	eb01 0481 	add.w	r4, r1, r1, lsl #2
 8002a3e:	eb00 03c4 	add.w	r3, r0, r4, lsl #3
 8002a42:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8002a46:	e7ec      	b.n	8002a22 <DCD_EP_Stall+0x1a>

08002a48 <DCD_EP_ClrStall>:
* @retval : status
*/
uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 8002a48:	b2ca      	uxtb	r2, r1
 8002a4a:	f012 0f80 	tst.w	r2, #128	; 0x80
* @param pdev: device instance
* @param epnum: endpoint address
* @retval : status
*/
uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
 8002a4e:	b510      	push	{r4, lr}
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 8002a50:	d111      	bne.n	8002a76 <DCD_EP_ClrStall+0x2e>
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8002a52:	eb01 0e81 	add.w	lr, r1, r1, lsl #2
 8002a56:	eb00 0cce 	add.w	ip, r0, lr, lsl #3
 8002a5a:	f50c 735c 	add.w	r3, ip, #880	; 0x370
 8002a5e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
  }
  
  ep->is_stall = 0;  
 8002a62:	2400      	movs	r4, #0
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 8002a64:	09d2      	lsrs	r2, r2, #7
  {
    ep = &pdev->dev.out_ep[epnum];
  }
  
  ep->is_stall = 0;  
  ep->num   = epnum & 0x7F;
 8002a66:	7019      	strb	r1, [r3, #0]
  else
  {
    ep = &pdev->dev.out_ep[epnum];
  }
  
  ep->is_stall = 0;  
 8002a68:	709c      	strb	r4, [r3, #2]
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 8002a6a:	705a      	strb	r2, [r3, #1]
  
  USB_OTG_EPClearStall(pdev , ep);
 8002a6c:	4619      	mov	r1, r3
 8002a6e:	f7ff fd71 	bl	8002554 <USB_OTG_EPClearStall>
  return (0);
}
 8002a72:	4620      	mov	r0, r4
 8002a74:	bd10      	pop	{r4, pc}
uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
 8002a76:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8002a7a:	eb01 0481 	add.w	r4, r1, r1, lsl #2
 8002a7e:	eb00 03c4 	add.w	r3, r0, r4, lsl #3
 8002a82:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8002a86:	e7ec      	b.n	8002a62 <DCD_EP_ClrStall+0x1a>

08002a88 <DCD_EP_Flush>:
* @retval : status
*/
uint32_t  DCD_EP_Flush (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{

  if ((epnum & 0x80) == 0x80)
 8002a88:	f011 0f80 	tst.w	r1, #128	; 0x80
* @param pdev: device instance
* @param epnum: endpoint address
* @retval : status
*/
uint32_t  DCD_EP_Flush (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
 8002a8c:	b508      	push	{r3, lr}

  if ((epnum & 0x80) == 0x80)
 8002a8e:	d103      	bne.n	8002a98 <DCD_EP_Flush+0x10>
  {
    USB_OTG_FlushTxFifo(pdev, epnum & 0x7F);
  }
  else
  {
    USB_OTG_FlushRxFifo(pdev);
 8002a90:	f7ff fa5a 	bl	8001f48 <USB_OTG_FlushRxFifo>
  }

  return (0);
}
 8002a94:	2000      	movs	r0, #0
 8002a96:	bd08      	pop	{r3, pc}
uint32_t  DCD_EP_Flush (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{

  if ((epnum & 0x80) == 0x80)
  {
    USB_OTG_FlushTxFifo(pdev, epnum & 0x7F);
 8002a98:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8002a9c:	f7ff fa2a 	bl	8001ef4 <USB_OTG_FlushTxFifo>
  {
    USB_OTG_FlushRxFifo(pdev);
  }

  return (0);
}
 8002aa0:	2000      	movs	r0, #0
 8002aa2:	bd08      	pop	{r3, pc}

08002aa4 <DCD_EP_SetAddress>:
void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
{
  USB_OTG_DCFG_TypeDef  dcfg;
  dcfg.d32 = 0;
  dcfg.b.devaddr = address;
  USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
 8002aa4:	6903      	ldr	r3, [r0, #16]
* @retval : status
*/
void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
{
  USB_OTG_DCFG_TypeDef  dcfg;
  dcfg.d32 = 0;
 8002aa6:	2200      	movs	r2, #0
  dcfg.b.devaddr = address;
  USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
 8002aa8:	6818      	ldr	r0, [r3, #0]
*/
void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
{
  USB_OTG_DCFG_TypeDef  dcfg;
  dcfg.d32 = 0;
  dcfg.b.devaddr = address;
 8002aaa:	f361 120a 	bfi	r2, r1, #4, #7
  USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
 8002aae:	4302      	orrs	r2, r0
 8002ab0:	601a      	str	r2, [r3, #0]
}
 8002ab2:	4770      	bx	lr

08002ab4 <DCD_DevConnect>:
*/
void  DCD_DevConnect (USB_OTG_CORE_HANDLE *pdev)
{
#ifndef USE_OTG_MODE
  USB_OTG_DCTL_TypeDef  dctl;
  dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 8002ab4:	6903      	ldr	r3, [r0, #16]
 8002ab6:	685a      	ldr	r2, [r3, #4]
  /* Connect device */
  dctl.b.sftdiscon  = 0;
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
  USB_OTG_BSP_mDelay(3);
 8002ab8:	2003      	movs	r0, #3
{
#ifndef USE_OTG_MODE
  USB_OTG_DCTL_TypeDef  dctl;
  dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
  /* Connect device */
  dctl.b.sftdiscon  = 0;
 8002aba:	f36f 0241 	bfc	r2, #1, #1
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
 8002abe:	605a      	str	r2, [r3, #4]
  USB_OTG_BSP_mDelay(3);
 8002ac0:	f000 bf47 	b.w	8003952 <USB_OTG_BSP_mDelay>

08002ac4 <DCD_DevDisconnect>:
*/
void  DCD_DevDisconnect (USB_OTG_CORE_HANDLE *pdev)
{
#ifndef USE_OTG_MODE
  USB_OTG_DCTL_TypeDef  dctl;
  dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 8002ac4:	6903      	ldr	r3, [r0, #16]
 8002ac6:	6858      	ldr	r0, [r3, #4]
  /* Disconnect device for 3ms */
  dctl.b.sftdiscon  = 1;
 8002ac8:	f040 0202 	orr.w	r2, r0, #2
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
  USB_OTG_BSP_mDelay(3);
 8002acc:	2003      	movs	r0, #3
#ifndef USE_OTG_MODE
  USB_OTG_DCTL_TypeDef  dctl;
  dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
  /* Disconnect device for 3ms */
  dctl.b.sftdiscon  = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
 8002ace:	605a      	str	r2, [r3, #4]
  USB_OTG_BSP_mDelay(3);
 8002ad0:	f000 bf3f 	b.w	8003952 <USB_OTG_BSP_mDelay>

08002ad4 <DCD_GetEPStatus>:
uint32_t DCD_GetEPStatus(USB_OTG_CORE_HANDLE *pdev ,uint8_t epnum)
{
  USB_OTG_EP *ep;
  uint32_t Status = 0;  
  
  if ((0x80 & epnum) == 0x80)
 8002ad4:	f011 0f80 	tst.w	r1, #128	; 0x80
 8002ad8:	d107      	bne.n	8002aea <DCD_GetEPStatus+0x16>
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8002ada:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8002ade:	eb00 0cc1 	add.w	ip, r0, r1, lsl #3
 8002ae2:	f50c 715c 	add.w	r1, ip, #880	; 0x370
  }
  
  Status = USB_OTG_GetEPStatus(pdev ,ep);
 8002ae6:	f7ff bddf 	b.w	80026a8 <USB_OTG_GetEPStatus>
  USB_OTG_EP *ep;
  uint32_t Status = 0;  
  
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
 8002aea:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 8002aee:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 8002af2:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
 8002af6:	f501 718c 	add.w	r1, r1, #280	; 0x118
 8002afa:	e7f4      	b.n	8002ae6 <DCD_GetEPStatus+0x12>

08002afc <DCD_SetEPStatus>:
*/
void DCD_SetEPStatus (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum , uint32_t Status)
{
  USB_OTG_EP *ep;
  
  if ((0x80 & epnum) == 0x80)
 8002afc:	f011 0f80 	tst.w	r1, #128	; 0x80
 8002b00:	d107      	bne.n	8002b12 <DCD_SetEPStatus+0x16>
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8002b02:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 8002b06:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
 8002b0a:	f501 715c 	add.w	r1, r1, #880	; 0x370
  }
  
   USB_OTG_SetEPStatus(pdev ,ep , Status);
 8002b0e:	f7ff bdff 	b.w	8002710 <USB_OTG_SetEPStatus>
{
  USB_OTG_EP *ep;
  
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
 8002b12:	f001 0c7f 	and.w	ip, r1, #127	; 0x7f
 8002b16:	eb0c 038c 	add.w	r3, ip, ip, lsl #2
 8002b1a:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
 8002b1e:	f501 718c 	add.w	r1, r1, #280	; 0x118
 8002b22:	e7f4      	b.n	8002b0e <DCD_SetEPStatus+0x12>

08002b24 <USBD_OTG_ISR_Handler>:
*         handles all USB Interrupts
* @param  pdev: device instance
* @retval status
*/
uint32_t USBD_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
{
 8002b24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002b28:	b083      	sub	sp, #12
 8002b2a:	4606      	mov	r6, r0
  USB_OTG_GINTSTS_TypeDef  gintr_status;
  uint32_t retval = 0;
  
  if (USB_OTG_IsDeviceMode(pdev)) /* ensure that we are in device mode */
 8002b2c:	f7ff fa52 	bl	8001fd4 <USB_OTG_IsDeviceMode>
 8002b30:	b910      	cbnz	r0, 8002b38 <USBD_OTG_ISR_Handler+0x14>
      retval |= DCD_OTG_ISR(pdev);
    }   
#endif    
  }
  return retval;
}
 8002b32:	b003      	add	sp, #12
 8002b34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  USB_OTG_GINTSTS_TypeDef  gintr_status;
  uint32_t retval = 0;
  
  if (USB_OTG_IsDeviceMode(pdev)) /* ensure that we are in device mode */
  {
    gintr_status.d32 = USB_OTG_ReadCoreItr(pdev);
 8002b38:	4630      	mov	r0, r6
 8002b3a:	f7ff fa59 	bl	8001ff0 <USB_OTG_ReadCoreItr>
    if (!gintr_status.d32) /* avoid spurious interrupt */
 8002b3e:	4681      	mov	r9, r0
 8002b40:	2800      	cmp	r0, #0
 8002b42:	d0f6      	beq.n	8002b32 <USBD_OTG_ISR_Handler+0xe>
    {
      return 0;
    }
    
    if (gintr_status.b.outepintr)
 8002b44:	f3c0 4107 	ubfx	r1, r0, #16, #8
 8002b48:	f001 0008 	and.w	r0, r1, #8
 8002b4c:	b2c0      	uxtb	r0, r0
 8002b4e:	2800      	cmp	r0, #0
 8002b50:	f040 8118 	bne.w	8002d84 <USBD_OTG_ISR_Handler+0x260>
    {
      retval |= DCD_HandleOutEP_ISR(pdev);
    }    
    
    if (gintr_status.b.inepint)
 8002b54:	f3c9 4e07 	ubfx	lr, r9, #16, #8
 8002b58:	f00e 0c04 	and.w	ip, lr, #4
 8002b5c:	fa5f f38c 	uxtb.w	r3, ip
 8002b60:	2b00      	cmp	r3, #0
 8002b62:	d166      	bne.n	8002c32 <USBD_OTG_ISR_Handler+0x10e>
    {
      retval |= DCD_HandleInEP_ISR(pdev);
    }
    
    if (gintr_status.b.modemismatch)
 8002b64:	f009 0c02 	and.w	ip, r9, #2
 8002b68:	fa5f f38c 	uxtb.w	r3, ip
 8002b6c:	b113      	cbz	r3, 8002b74 <USBD_OTG_ISR_Handler+0x50>
      USB_OTG_GINTSTS_TypeDef  gintsts;
      
      /* Clear interrupt */
      gintsts.d32 = 0;
      gintsts.b.modemismatch = 1;
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002b6e:	68f2      	ldr	r2, [r6, #12]
    {
      USB_OTG_GINTSTS_TypeDef  gintsts;
      
      /* Clear interrupt */
      gintsts.d32 = 0;
      gintsts.b.modemismatch = 1;
 8002b70:	2102      	movs	r1, #2
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002b72:	6151      	str	r1, [r2, #20]
    }
    
    if (gintr_status.b.wkupintr)
 8002b74:	f3c9 6107 	ubfx	r1, r9, #24, #8
 8002b78:	f001 0c80 	and.w	ip, r1, #128	; 0x80
 8002b7c:	fa5f f38c 	uxtb.w	r3, ip
 8002b80:	b193      	cbz	r3, 8002ba8 <USBD_OTG_ISR_Handler+0x84>
{
  USB_OTG_GINTSTS_TypeDef  gintsts;
  USB_OTG_DCTL_TypeDef     devctl;
  USB_OTG_PCGCCTL_TypeDef  power;
  
  if(pdev->cfg.low_power)
 8002b82:	7ab0      	ldrb	r0, [r6, #10]
 8002b84:	2800      	cmp	r0, #0
 8002b86:	f040 8204 	bne.w	8002f92 <USBD_OTG_ISR_Handler+0x46e>
  }
  
  /* Clear the Remote Wake-up Signaling */
  devctl.d32 = 0;
  devctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, devctl.d32, 0);
 8002b8a:	6933      	ldr	r3, [r6, #16]
  
  /* Inform upper layer by the Resume Event */
  USBD_DCD_INT_fops->Resume (pdev);
 8002b8c:	4aa8      	ldr	r2, [pc, #672]	; (8002e30 <USBD_OTG_ISR_Handler+0x30c>)
  }
  
  /* Clear the Remote Wake-up Signaling */
  devctl.d32 = 0;
  devctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, devctl.d32, 0);
 8002b8e:	6859      	ldr	r1, [r3, #4]
  
  /* Inform upper layer by the Resume Event */
  USBD_DCD_INT_fops->Resume (pdev);
 8002b90:	6810      	ldr	r0, [r2, #0]
  }
  
  /* Clear the Remote Wake-up Signaling */
  devctl.d32 = 0;
  devctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, devctl.d32, 0);
 8002b92:	f021 0101 	bic.w	r1, r1, #1
 8002b96:	6059      	str	r1, [r3, #4]
  
  /* Inform upper layer by the Resume Event */
  USBD_DCD_INT_fops->Resume (pdev);
 8002b98:	6982      	ldr	r2, [r0, #24]
 8002b9a:	4630      	mov	r0, r6
 8002b9c:	4790      	blx	r2
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.wkupintr = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002b9e:	68f0      	ldr	r0, [r6, #12]
  /* Inform upper layer by the Resume Event */
  USBD_DCD_INT_fops->Resume (pdev);
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.wkupintr = 1;
 8002ba0:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002ba4:	6141      	str	r1, [r0, #20]
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
    }
    
    if (gintr_status.b.wkupintr)
    {
      retval |= DCD_HandleResume_ISR(pdev);
 8002ba6:	2001      	movs	r0, #1
    }
    
    if (gintr_status.b.usbsuspend)
 8002ba8:	f3c9 2107 	ubfx	r1, r9, #8, #8
 8002bac:	f001 0c08 	and.w	ip, r1, #8
 8002bb0:	fa5f f38c 	uxtb.w	r3, ip
 8002bb4:	2b00      	cmp	r3, #0
 8002bb6:	f040 81cb 	bne.w	8002f50 <USBD_OTG_ISR_Handler+0x42c>
    {
      retval |= DCD_HandleUSBSuspend_ISR(pdev);
    }
    if (gintr_status.b.sofintr)
 8002bba:	f009 0c08 	and.w	ip, r9, #8
 8002bbe:	fa5f f28c 	uxtb.w	r2, ip
 8002bc2:	2a00      	cmp	r2, #0
 8002bc4:	f040 81ba 	bne.w	8002f3c <USBD_OTG_ISR_Handler+0x418>
    {
      retval |= DCD_HandleSof_ISR(pdev);
      
    }
    
    if (gintr_status.b.rxstsqlvl)
 8002bc8:	f009 0c10 	and.w	ip, r9, #16
 8002bcc:	fa5f f38c 	uxtb.w	r3, ip
 8002bd0:	2b00      	cmp	r3, #0
 8002bd2:	f040 818d 	bne.w	8002ef0 <USBD_OTG_ISR_Handler+0x3cc>
    {
      retval |= DCD_HandleRxStatusQueueLevel_ISR(pdev);
      
    }
    
    if (gintr_status.b.usbreset)
 8002bd6:	f3c9 2107 	ubfx	r1, r9, #8, #8
 8002bda:	f001 0c10 	and.w	ip, r1, #16
 8002bde:	fa5f f38c 	uxtb.w	r3, ip
 8002be2:	2b00      	cmp	r3, #0
 8002be4:	f040 814a 	bne.w	8002e7c <USBD_OTG_ISR_Handler+0x358>
    {
      retval |= DCD_HandleUsbReset_ISR(pdev);
      
    }
    if (gintr_status.b.enumdone)
 8002be8:	f3c9 2107 	ubfx	r1, r9, #8, #8
 8002bec:	f001 0c20 	and.w	ip, r1, #32
 8002bf0:	fa5f f38c 	uxtb.w	r3, ip
 8002bf4:	2b00      	cmp	r3, #0
 8002bf6:	f040 8128 	bne.w	8002e4a <USBD_OTG_ISR_Handler+0x326>
    {
      retval |= DCD_HandleEnumDone_ISR(pdev);
    }
    
    if (gintr_status.b.incomplisoin)
 8002bfa:	f3c9 4207 	ubfx	r2, r9, #16, #8
 8002bfe:	f002 0c10 	and.w	ip, r2, #16
 8002c02:	fa5f f18c 	uxtb.w	r1, ip
 8002c06:	2900      	cmp	r1, #0
 8002c08:	f040 8114 	bne.w	8002e34 <USBD_OTG_ISR_Handler+0x310>
    {
      retval |= DCD_IsoINIncomplete_ISR(pdev);
    }

    if (gintr_status.b.incomplisoout)
 8002c0c:	f3c9 4107 	ubfx	r1, r9, #16, #8
 8002c10:	f001 0c20 	and.w	ip, r1, #32
 8002c14:	fa5f f38c 	uxtb.w	r3, ip
 8002c18:	2b00      	cmp	r3, #0
 8002c1a:	d08a      	beq.n	8002b32 <USBD_OTG_ISR_Handler+0xe>
{
  USB_OTG_GINTSTS_TypeDef gintsts;  
  
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoOUTIncomplete (pdev); 
 8002c1c:	4a84      	ldr	r2, [pc, #528]	; (8002e30 <USBD_OTG_ISR_Handler+0x30c>)
 8002c1e:	6811      	ldr	r1, [r2, #0]
 8002c20:	4630      	mov	r0, r6
 8002c22:	6a0b      	ldr	r3, [r1, #32]
 8002c24:	4798      	blx	r3
  
  /* Clear interrupt */
  gintsts.b.incomplisoout = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002c26:	68f0      	ldr	r0, [r6, #12]
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoOUTIncomplete (pdev); 
  
  /* Clear interrupt */
  gintsts.b.incomplisoout = 1;
 8002c28:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002c2c:	6142      	str	r2, [r0, #20]
      retval |= DCD_IsoINIncomplete_ISR(pdev);
    }

    if (gintr_status.b.incomplisoout)
    {
      retval |= DCD_IsoOUTIncomplete_ISR(pdev);
 8002c2e:	2001      	movs	r0, #1
 8002c30:	e77f      	b.n	8002b32 <USBD_OTG_ISR_Handler+0xe>
  
  uint32_t ep_intr;
  uint32_t epnum = 0;
  uint32_t fifoemptymsk;
  diepint.d32 = 0;
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
 8002c32:	4630      	mov	r0, r6
 8002c34:	f7ff fcba 	bl	80025ac <USB_OTG_ReadDevAllInEPItr>
  
  while ( ep_intr )
 8002c38:	4682      	mov	sl, r0
 8002c3a:	2800      	cmp	r0, #0
 8002c3c:	f000 80a0 	beq.w	8002d80 <USBD_OTG_ISR_Handler+0x25c>
 8002c40:	4637      	mov	r7, r6
 8002c42:	4634      	mov	r4, r6
static uint32_t DCD_HandleInEP_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_DIEPINTn_TypeDef  diepint;
  
  uint32_t ep_intr;
  uint32_t epnum = 0;
 8002c44:	f04f 0b00 	mov.w	fp, #0
      {
        CLEAR_IN_EP_INTR(epnum, inepnakeff);
      }
      if ( diepint.b.epdisabled )
      {
        CLEAR_IN_EP_INTR(epnum, epdisabled);
 8002c48:	f8cd 9004 	str.w	r9, [sp, #4]
 8002c4c:	46b0      	mov	r8, r6
  diepint.d32 = 0;
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
  
  while ( ep_intr )
  {
    if (ep_intr&0x1) /* In ITR */
 8002c4e:	f01a 0f01 	tst.w	sl, #1
 8002c52:	f000 808a 	beq.w	8002d6a <USBD_OTG_ISR_Handler+0x246>
* @retval status
*/
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
 8002c56:	f8d8 3010 	ldr.w	r3, [r8, #16]
  diepint.d32 = 0;
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
  
  while ( ep_intr )
  {
    if (ep_intr&0x1) /* In ITR */
 8002c5a:	fa5f f68b 	uxtb.w	r6, fp
* @retval status
*/
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
 8002c5e:	6919      	ldr	r1, [r3, #16]
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
 8002c60:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  msk |= ((emp >> epnum) & 0x1) << 7;
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 8002c62:	eb08 0c86 	add.w	ip, r8, r6, lsl #2
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
  msk |= ((emp >> epnum) & 0x1) << 7;
 8002c66:	fa32 f506 	lsrs.w	r5, r2, r6
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 8002c6a:	f8dc 0018 	ldr.w	r0, [ip, #24]
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
  msk |= ((emp >> epnum) & 0x1) << 7;
 8002c6e:	01ed      	lsls	r5, r5, #7
 8002c70:	f005 02ff 	and.w	r2, r5, #255	; 0xff
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 8002c74:	6880      	ldr	r0, [r0, #8]
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
  msk |= ((emp >> epnum) & 0x1) << 7;
 8002c76:	ea42 0901 	orr.w	r9, r2, r1
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 8002c7a:	ea09 0500 	and.w	r5, r9, r0
  while ( ep_intr )
  {
    if (ep_intr&0x1) /* In ITR */
    {
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
 8002c7e:	b2ed      	uxtb	r5, r5
 8002c80:	f015 0f01 	tst.w	r5, #1
 8002c84:	f040 81b7 	bne.w	8002ff6 <USBD_OTG_ISR_Handler+0x4d2>
            /* prepare to rx more setup packets */
            USB_OTG_EP0_OutStart(pdev);
          }
        }           
      }
      if ( diepint.b.ahberr )
 8002c88:	f005 0904 	and.w	r9, r5, #4
 8002c8c:	fa5f f389 	uxtb.w	r3, r9
 8002c90:	b113      	cbz	r3, 8002c98 <USBD_OTG_ISR_Handler+0x174>
      {
        CLEAR_IN_EP_INTR(epnum, ahberr);
 8002c92:	69ba      	ldr	r2, [r7, #24]
 8002c94:	2504      	movs	r5, #4
 8002c96:	6095      	str	r5, [r2, #8]
      }
      if ( diepint.b.timeout )
 8002c98:	f005 0008 	and.w	r0, r5, #8
 8002c9c:	b2c1      	uxtb	r1, r0
 8002c9e:	b111      	cbz	r1, 8002ca6 <USBD_OTG_ISR_Handler+0x182>
      {
        CLEAR_IN_EP_INTR(epnum, timeout);
 8002ca0:	69bb      	ldr	r3, [r7, #24]
 8002ca2:	2508      	movs	r5, #8
 8002ca4:	609d      	str	r5, [r3, #8]
      }
      if (diepint.b.intktxfemp)
 8002ca6:	f005 0c10 	and.w	ip, r5, #16
 8002caa:	fa5f f28c 	uxtb.w	r2, ip
 8002cae:	b112      	cbz	r2, 8002cb6 <USBD_OTG_ISR_Handler+0x192>
      {
        CLEAR_IN_EP_INTR(epnum, intktxfemp);
 8002cb0:	69b9      	ldr	r1, [r7, #24]
 8002cb2:	2510      	movs	r5, #16
 8002cb4:	608d      	str	r5, [r1, #8]
      }
      if (diepint.b.intknepmis)
 8002cb6:	f005 0920 	and.w	r9, r5, #32
 8002cba:	fa5f f089 	uxtb.w	r0, r9
 8002cbe:	b110      	cbz	r0, 8002cc6 <USBD_OTG_ISR_Handler+0x1a2>
      {
        CLEAR_IN_EP_INTR(epnum, intknepmis);
 8002cc0:	69bb      	ldr	r3, [r7, #24]
 8002cc2:	2520      	movs	r5, #32
 8002cc4:	609d      	str	r5, [r3, #8]
      }
      if (diepint.b.inepnakeff)
 8002cc6:	f005 0c40 	and.w	ip, r5, #64	; 0x40
 8002cca:	fa5f f28c 	uxtb.w	r2, ip
 8002cce:	b112      	cbz	r2, 8002cd6 <USBD_OTG_ISR_Handler+0x1b2>
      {
        CLEAR_IN_EP_INTR(epnum, inepnakeff);
 8002cd0:	69b9      	ldr	r1, [r7, #24]
 8002cd2:	2540      	movs	r5, #64	; 0x40
 8002cd4:	608d      	str	r5, [r1, #8]
      }
      if ( diepint.b.epdisabled )
 8002cd6:	f005 0902 	and.w	r9, r5, #2
 8002cda:	fa5f f089 	uxtb.w	r0, r9
 8002cde:	b110      	cbz	r0, 8002ce6 <USBD_OTG_ISR_Handler+0x1c2>
      {
        CLEAR_IN_EP_INTR(epnum, epdisabled);
 8002ce0:	69bb      	ldr	r3, [r7, #24]
 8002ce2:	2502      	movs	r5, #2
 8002ce4:	609d      	str	r5, [r3, #8]
      }       
      if (diepint.b.emptyintr)
 8002ce6:	f005 0580 	and.w	r5, r5, #128	; 0x80
 8002cea:	b2ed      	uxtb	r5, r5
 8002cec:	2d00      	cmp	r5, #0
 8002cee:	d03c      	beq.n	8002d6a <USBD_OTG_ISR_Handler+0x246>
  uint32_t len32b;
  txstatus.d32 = 0;
  
  ep = &pdev->dev.in_ep[epnum];    
  
  len = ep->xfer_len - ep->xfer_count;
 8002cf0:	f8d4 112c 	ldr.w	r1, [r4, #300]	; 0x12c
 8002cf4:	f8d4 0130 	ldr.w	r0, [r4, #304]	; 0x130
  {
    len = ep->maxpacket;
  }
  
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 8002cf8:	69bb      	ldr	r3, [r7, #24]
  if (len > ep->maxpacket)
  {
    len = ep->maxpacket;
  }
  
  len32b = (len + 3) / 4;
 8002cfa:	f8d4 2120 	ldr.w	r2, [r4, #288]	; 0x120
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 8002cfe:	f8d3 9018 	ldr.w	r9, [r3, #24]
  uint32_t len32b;
  txstatus.d32 = 0;
  
  ep = &pdev->dev.in_ep[epnum];    
  
  len = ep->xfer_len - ep->xfer_count;
 8002d02:	1a0d      	subs	r5, r1, r0
  if (len > ep->maxpacket)
  {
    len = ep->maxpacket;
  }
  
  len32b = (len + 3) / 4;
 8002d04:	4295      	cmp	r5, r2
 8002d06:	bf34      	ite	cc
 8002d08:	46ac      	movcc	ip, r5
 8002d0a:	4694      	movcs	ip, r2
 8002d0c:	f10c 0c03 	add.w	ip, ip, #3
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002d10:	fa1f f989 	uxth.w	r9, r9
 8002d14:	ebb9 0f9c 	cmp.w	r9, ip, lsr #2
 8002d18:	d925      	bls.n	8002d66 <USBD_OTG_ISR_Handler+0x242>
 8002d1a:	4281      	cmp	r1, r0
 8002d1c:	d923      	bls.n	8002d66 <USBD_OTG_ISR_Handler+0x242>
          ep->xfer_count < ep->xfer_len &&
 8002d1e:	b311      	cbz	r1, 8002d66 <USBD_OTG_ISR_Handler+0x242>
 8002d20:	f8d4 1124 	ldr.w	r1, [r4, #292]	; 0x124
 8002d24:	e006      	b.n	8002d34 <USBD_OTG_ISR_Handler+0x210>
 8002d26:	f8d4 512c 	ldr.w	r5, [r4, #300]	; 0x12c
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002d2a:	42aa      	cmp	r2, r5
 8002d2c:	d21b      	bcs.n	8002d66 <USBD_OTG_ISR_Handler+0x242>
 8002d2e:	1aad      	subs	r5, r5, r2
 8002d30:	f8d4 2120 	ldr.w	r2, [r4, #288]	; 0x120
          ep->xfer_count < ep->xfer_len &&
            ep->xfer_len != 0)
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 8002d34:	4295      	cmp	r5, r2
 8002d36:	bf28      	it	cs
 8002d38:	4615      	movcs	r5, r2
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3) / 4;
    
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
 8002d3a:	b2ab      	uxth	r3, r5
 8002d3c:	4632      	mov	r2, r6
 8002d3e:	4640      	mov	r0, r8
 8002d40:	f7fe ff16 	bl	8001b70 <USB_OTG_WritePacket>
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
 8002d44:	f8d4 2130 	ldr.w	r2, [r4, #304]	; 0x130
    
    txstatus.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 8002d48:	69bb      	ldr	r3, [r7, #24]
    }
    len32b = (len + 3) / 4;
    
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
    
    ep->xfer_buff  += len;
 8002d4a:	f8d4 1124 	ldr.w	r1, [r4, #292]	; 0x124
    ep->xfer_count += len;
 8002d4e:	18aa      	adds	r2, r5, r2
 8002d50:	f8c4 2130 	str.w	r2, [r4, #304]	; 0x130
    
    txstatus.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 8002d54:	6998      	ldr	r0, [r3, #24]
    }
    len32b = (len + 3) / 4;
    
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
    
    ep->xfer_buff  += len;
 8002d56:	1949      	adds	r1, r1, r5
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002d58:	b280      	uxth	r0, r0
    
    if (len > ep->maxpacket)
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3) / 4;
 8002d5a:	3503      	adds	r5, #3
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002d5c:	ebb0 0f95 	cmp.w	r0, r5, lsr #2
    }
    len32b = (len + 3) / 4;
    
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
    
    ep->xfer_buff  += len;
 8002d60:	f8c4 1124 	str.w	r1, [r4, #292]	; 0x124
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002d64:	d8df      	bhi.n	8002d26 <USBD_OTG_ISR_Handler+0x202>
      if (diepint.b.emptyintr)
      {
        
        DCD_WriteEmptyTxFifo(pdev , epnum);
        
        CLEAR_IN_EP_INTR(epnum, emptyintr);
 8002d66:	2680      	movs	r6, #128	; 0x80
 8002d68:	609e      	str	r6, [r3, #8]
      }
    }
    epnum++;
    ep_intr >>= 1;
 8002d6a:	3428      	adds	r4, #40	; 0x28
 8002d6c:	3704      	adds	r7, #4
  uint32_t epnum = 0;
  uint32_t fifoemptymsk;
  diepint.d32 = 0;
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
  
  while ( ep_intr )
 8002d6e:	ea5f 0a5a 	movs.w	sl, sl, lsr #1
 8002d72:	d002      	beq.n	8002d7a <USBD_OTG_ISR_Handler+0x256>
        DCD_WriteEmptyTxFifo(pdev , epnum);
        
        CLEAR_IN_EP_INTR(epnum, emptyintr);
      }
    }
    epnum++;
 8002d74:	f10b 0b01 	add.w	fp, fp, #1
 8002d78:	e769      	b.n	8002c4e <USBD_OTG_ISR_Handler+0x12a>
 8002d7a:	f8dd 9004 	ldr.w	r9, [sp, #4]
 8002d7e:	4646      	mov	r6, r8
      retval |= DCD_HandleOutEP_ISR(pdev);
    }    
    
    if (gintr_status.b.inepint)
    {
      retval |= DCD_HandleInEP_ISR(pdev);
 8002d80:	2001      	movs	r0, #1
 8002d82:	e6ef      	b.n	8002b64 <USBD_OTG_ISR_Handler+0x40>
  uint32_t epnum = 0;
  
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
 8002d84:	4630      	mov	r0, r6
 8002d86:	f7ff fbff 	bl	8002588 <USB_OTG_ReadDevAllOutEp_itr>
  
  while ( ep_intr )
 8002d8a:	4604      	mov	r4, r0
 8002d8c:	2800      	cmp	r0, #0
 8002d8e:	d04d      	beq.n	8002e2c <USBD_OTG_ISR_Handler+0x308>
      if ( doepint.b.setup )
      {
        
        /* inform the upper layer that a setup packet is available */
        /* SETUP COMPLETE */
        USBD_DCD_INT_fops->SetupStage(pdev);
 8002d90:	f8df b09c 	ldr.w	fp, [pc, #156]	; 8002e30 <USBD_OTG_ISR_Handler+0x30c>
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
  
  while ( ep_intr )
 8002d94:	4635      	mov	r5, r6
 8002d96:	46b0      	mov	r8, r6
static uint32_t DCD_HandleOutEP_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t ep_intr;
  USB_OTG_DOEPINTn_TypeDef  doepint;
  USB_OTG_DEPXFRSIZ_TypeDef  deptsiz;
  uint32_t epnum = 0;
 8002d98:	2700      	movs	r7, #0
        CLEAR_OUT_EP_INTR(epnum, epdisabled);
      }
      /* AHB Error */
      if ( doepint.b.ahberr )
      {
        CLEAR_OUT_EP_INTR(epnum, ahberr);
 8002d9a:	46ca      	mov	sl, r9
 8002d9c:	e005      	b.n	8002daa <USBD_OTG_ISR_Handler+0x286>
        USBD_DCD_INT_fops->SetupStage(pdev);
        CLEAR_OUT_EP_INTR(epnum, setup);
      }
    }
    epnum++;
    ep_intr >>= 1;
 8002d9e:	3504      	adds	r5, #4
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
  
  while ( ep_intr )
 8002da0:	0864      	lsrs	r4, r4, #1
        USBD_DCD_INT_fops->SetupStage(pdev);
        CLEAR_OUT_EP_INTR(epnum, setup);
      }
    }
    epnum++;
    ep_intr >>= 1;
 8002da2:	f108 0828 	add.w	r8, r8, #40	; 0x28
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
  
  while ( ep_intr )
 8002da6:	d040      	beq.n	8002e2a <USBD_OTG_ISR_Handler+0x306>
        /* SETUP COMPLETE */
        USBD_DCD_INT_fops->SetupStage(pdev);
        CLEAR_OUT_EP_INTR(epnum, setup);
      }
    }
    epnum++;
 8002da8:	3701      	adds	r7, #1
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
  
  while ( ep_intr )
  {
    if (ep_intr&0x1)
 8002daa:	f014 0f01 	tst.w	r4, #1
 8002dae:	d0f6      	beq.n	8002d9e <USBD_OTG_ISR_Handler+0x27a>
 8002db0:	fa5f f987 	uxtb.w	r9, r7
    {
      
      doepint.d32 = USB_OTG_ReadDevOutEP_itr(pdev, epnum);
 8002db4:	4630      	mov	r0, r6
 8002db6:	4649      	mov	r1, r9
 8002db8:	f7ff fbee 	bl	8002598 <USB_OTG_ReadDevOutEP_itr>
      
      /* Transfer complete */
      if ( doepint.b.xfercompl )
 8002dbc:	b2c0      	uxtb	r0, r0
 8002dbe:	f010 0f01 	tst.w	r0, #1
 8002dc2:	d013      	beq.n	8002dec <USBD_OTG_ISR_Handler+0x2c8>
      {
        /* Clear the bit in DOEPINTn for this interrupt */
        CLEAR_OUT_EP_INTR(epnum, xfercompl);
 8002dc4:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8002dc6:	2001      	movs	r0, #1
 8002dc8:	6098      	str	r0, [r3, #8]
        if (pdev->cfg.dma_enable == 1)
 8002dca:	78f2      	ldrb	r2, [r6, #3]
 8002dcc:	2a01      	cmp	r2, #1
 8002dce:	f000 8142 	beq.w	8003056 <USBD_OTG_ISR_Handler+0x532>
          pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
            deptsiz.b.xfersize;
        }
        /* Inform upper layer: data ready */
        /* RX COMPLETE */
        USBD_DCD_INT_fops->DataOutStage(pdev , epnum);
 8002dd2:	f8db 1000 	ldr.w	r1, [fp]
 8002dd6:	4630      	mov	r0, r6
 8002dd8:	680b      	ldr	r3, [r1, #0]
 8002dda:	4649      	mov	r1, r9
 8002ddc:	4798      	blx	r3
        
        if (pdev->cfg.dma_enable == 1)
 8002dde:	f896 9003 	ldrb.w	r9, [r6, #3]
 8002de2:	f1b9 0f01 	cmp.w	r9, #1
 8002de6:	f000 8129 	beq.w	800303c <USBD_OTG_ISR_Handler+0x518>
 8002dea:	2001      	movs	r0, #1
            USB_OTG_EP0_OutStart(pdev);
          }
        }        
      }
      /* Endpoint disable  */
      if ( doepint.b.epdisabled )
 8002dec:	f000 0902 	and.w	r9, r0, #2
 8002df0:	fa5f f289 	uxtb.w	r2, r9
 8002df4:	b112      	cbz	r2, 8002dfc <USBD_OTG_ISR_Handler+0x2d8>
      {
        /* Clear the bit in DOEPINTn for this interrupt */
        CLEAR_OUT_EP_INTR(epnum, epdisabled);
 8002df6:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8002df8:	2002      	movs	r0, #2
 8002dfa:	6098      	str	r0, [r3, #8]
      }
      /* AHB Error */
      if ( doepint.b.ahberr )
 8002dfc:	f000 0c04 	and.w	ip, r0, #4
 8002e00:	fa5f f18c 	uxtb.w	r1, ip
 8002e04:	b111      	cbz	r1, 8002e0c <USBD_OTG_ISR_Handler+0x2e8>
      {
        CLEAR_OUT_EP_INTR(epnum, ahberr);
 8002e06:	6d6a      	ldr	r2, [r5, #84]	; 0x54
 8002e08:	2004      	movs	r0, #4
 8002e0a:	6090      	str	r0, [r2, #8]
      }
      /* Setup Phase Done (control EPs) */
      if ( doepint.b.setup )
 8002e0c:	f000 0e08 	and.w	lr, r0, #8
 8002e10:	fa5f f08e 	uxtb.w	r0, lr
 8002e14:	2800      	cmp	r0, #0
 8002e16:	d0c2      	beq.n	8002d9e <USBD_OTG_ISR_Handler+0x27a>
      {
        
        /* inform the upper layer that a setup packet is available */
        /* SETUP COMPLETE */
        USBD_DCD_INT_fops->SetupStage(pdev);
 8002e18:	f8db 1000 	ldr.w	r1, [fp]
 8002e1c:	4630      	mov	r0, r6
 8002e1e:	688a      	ldr	r2, [r1, #8]
 8002e20:	4790      	blx	r2
        CLEAR_OUT_EP_INTR(epnum, setup);
 8002e22:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8002e24:	2108      	movs	r1, #8
 8002e26:	6099      	str	r1, [r3, #8]
 8002e28:	e7b9      	b.n	8002d9e <USBD_OTG_ISR_Handler+0x27a>
 8002e2a:	46d1      	mov	r9, sl
      return 0;
    }
    
    if (gintr_status.b.outepintr)
    {
      retval |= DCD_HandleOutEP_ISR(pdev);
 8002e2c:	2001      	movs	r0, #1
 8002e2e:	e691      	b.n	8002b54 <USBD_OTG_ISR_Handler+0x30>
 8002e30:	20000148 	.word	0x20000148
{
  USB_OTG_GINTSTS_TypeDef gintsts;  
  
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoINIncomplete (pdev); 
 8002e34:	488d      	ldr	r0, [pc, #564]	; (800306c <USBD_OTG_ISR_Handler+0x548>)
 8002e36:	6802      	ldr	r2, [r0, #0]
 8002e38:	4630      	mov	r0, r6
 8002e3a:	69d1      	ldr	r1, [r2, #28]
 8002e3c:	4788      	blx	r1
  
  /* Clear interrupt */
  gintsts.b.incomplisoin = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002e3e:	68f3      	ldr	r3, [r6, #12]
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoINIncomplete (pdev); 
  
  /* Clear interrupt */
  gintsts.b.incomplisoin = 1;
 8002e40:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002e44:	6158      	str	r0, [r3, #20]
      retval |= DCD_HandleEnumDone_ISR(pdev);
    }
    
    if (gintr_status.b.incomplisoin)
    {
      retval |= DCD_IsoINIncomplete_ISR(pdev);
 8002e46:	2001      	movs	r0, #1
 8002e48:	e6e0      	b.n	8002c0c <USBD_OTG_ISR_Handler+0xe8>
static uint32_t DCD_HandleEnumDone_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_GINTSTS_TypeDef  gintsts;
  USB_OTG_GUSBCFG_TypeDef  gusbcfg;
  
  USB_OTG_EP0Activate(pdev);
 8002e4a:	4630      	mov	r0, r6
 8002e4c:	f7ff f996 	bl	800217c <USB_OTG_EP0Activate>
  
  /* Set USB turn-around time based on device speed and PHY interface. */
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8002e50:	68f4      	ldr	r4, [r6, #12]
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
 8002e52:	4630      	mov	r0, r6
  USB_OTG_GUSBCFG_TypeDef  gusbcfg;
  
  USB_OTG_EP0Activate(pdev);
  
  /* Set USB turn-around time based on device speed and PHY interface. */
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8002e54:	68e4      	ldr	r4, [r4, #12]
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
 8002e56:	f7ff f981 	bl	800215c <USB_OTG_GetDeviceSpeed>
 8002e5a:	2803      	cmp	r0, #3
 8002e5c:	f000 80c1 	beq.w	8002fe2 <USBD_OTG_ISR_Handler+0x4be>
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
    gusbcfg.b.usbtrdtim = 9;
  }
  else
  {
    pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8002e60:	2001      	movs	r0, #1
    pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;  
 8002e62:	2140      	movs	r1, #64	; 0x40
    gusbcfg.b.usbtrdtim = 5;
 8002e64:	2305      	movs	r3, #5
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
    gusbcfg.b.usbtrdtim = 9;
  }
  else
  {
    pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8002e66:	70b0      	strb	r0, [r6, #2]
    pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;  
 8002e68:	80b1      	strh	r1, [r6, #4]
    gusbcfg.b.usbtrdtim = 5;
 8002e6a:	f363 248d 	bfi	r4, r3, #10, #4
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
 8002e6e:	68f3      	ldr	r3, [r6, #12]
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.enumdone = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, gintsts.d32 );
 8002e70:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    pdev->cfg.speed            = USB_OTG_SPEED_FULL;
    pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;  
    gusbcfg.b.usbtrdtim = 5;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
 8002e74:	60dc      	str	r4, [r3, #12]
      retval |= DCD_HandleUsbReset_ISR(pdev);
      
    }
    if (gintr_status.b.enumdone)
    {
      retval |= DCD_HandleEnumDone_ISR(pdev);
 8002e76:	2001      	movs	r0, #1
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.enumdone = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, gintsts.d32 );
 8002e78:	615a      	str	r2, [r3, #20]
 8002e7a:	e6be      	b.n	8002bfa <USBD_OTG_ISR_Handler+0xd6>
  dcfg.d32 = 0;
  gintsts.d32 = 0;
  
  /* Clear the Remote Wake-up Signaling */
  dctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
 8002e7c:	6930      	ldr	r0, [r6, #16]
 8002e7e:	6843      	ldr	r3, [r0, #4]
  USB_OTG_DCFG_TypeDef     dcfg;
  USB_OTG_DCTL_TypeDef     dctl;
  USB_OTG_GINTSTS_TypeDef  gintsts;
  uint32_t i;
  
  dctl.d32 = 0;
 8002e80:	2400      	movs	r4, #0
  dcfg.d32 = 0;
  gintsts.d32 = 0;
  
  /* Clear the Remote Wake-up Signaling */
  dctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
 8002e82:	f023 0201 	bic.w	r2, r3, #1
 8002e86:	6042      	str	r2, [r0, #4]
  
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
 8002e88:	4621      	mov	r1, r4
 8002e8a:	4630      	mov	r0, r6
 8002e8c:	f7ff f832 	bl	8001ef4 <USB_OTG_FlushTxFifo>
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002e90:	7875      	ldrb	r5, [r6, #1]
 8002e92:	b16d      	cbz	r5, 8002eb0 <USBD_OTG_ISR_Handler+0x38c>
* @brief  STM32_USBF_OTG_ISR_Handler
*         handles all USB Interrupts
* @param  pdev: device instance
* @retval status
*/
uint32_t USBD_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
 8002e94:	f106 0214 	add.w	r2, r6, #20
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
  
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002e98:	4623      	mov	r3, r4
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 8002e9a:	21ff      	movs	r1, #255	; 0xff
 8002e9c:	f852 5f04 	ldr.w	r5, [r2, #4]!
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 8002ea0:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 8002ea2:	60a9      	str	r1, [r5, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 8002ea4:	6081      	str	r1, [r0, #8]
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
  
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002ea6:	f896 e001 	ldrb.w	lr, [r6, #1]
 8002eaa:	3301      	adds	r3, #1
 8002eac:	4573      	cmp	r3, lr
 8002eae:	d3f5      	bcc.n	8002e9c <USBD_OTG_ISR_Handler+0x378>
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
  
  daintmsk.ep.in = 1;
 8002eb0:	2501      	movs	r5, #1
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8002eb2:	6933      	ldr	r3, [r6, #16]
  
  daintmsk.ep.in = 1;
 8002eb4:	f365 040f 	bfi	r4, r5, #0, #16
  
  doepmsk.b.setup = 1;
  doepmsk.b.xfercompl = 1;
  doepmsk.b.ahberr = 1;
  doepmsk.b.epdisabled = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, doepmsk.d32 );
 8002eb8:	210f      	movs	r1, #15
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8002eba:	f04f 32ff 	mov.w	r2, #4294967295
  diepmsk.b.xfercompl = 1;
  diepmsk.b.timeout = 1;
  diepmsk.b.epdisabled = 1;
  diepmsk.b.ahberr = 1;
  diepmsk.b.intknepmis = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, diepmsk.d32 );
 8002ebe:	202f      	movs	r0, #47	; 0x2f
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
  
  daintmsk.ep.in = 1;
  daintmsk.ep.out = 1;
 8002ec0:	f365 441f 	bfi	r4, r5, #16, #16
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8002ec4:	619a      	str	r2, [r3, #24]
  
  daintmsk.ep.in = 1;
  daintmsk.ep.out = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, daintmsk.d32 );
 8002ec6:	61dc      	str	r4, [r3, #28]
  
  doepmsk.b.setup = 1;
  doepmsk.b.xfercompl = 1;
  doepmsk.b.ahberr = 1;
  doepmsk.b.epdisabled = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, doepmsk.d32 );
 8002ec8:	6159      	str	r1, [r3, #20]
  diepmsk.b.xfercompl = 1;
  diepmsk.b.timeout = 1;
  diepmsk.b.epdisabled = 1;
  diepmsk.b.ahberr = 1;
  diepmsk.b.intknepmis = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, diepmsk.d32 );
 8002eca:	6118      	str	r0, [r3, #16]
#ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED  
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DINEP1MSK, diepmsk.d32 );
#endif
  /* Reset Device Address */
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
 8002ecc:	681a      	ldr	r2, [r3, #0]
  dcfg.b.devaddr = 0;
 8002ece:	f36f 120a 	bfc	r2, #4, #7
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32);
 8002ed2:	601a      	str	r2, [r3, #0]
  
  
  /* setup EP0 to receive SETUP packets */
  USB_OTG_EP0_OutStart(pdev);
 8002ed4:	4630      	mov	r0, r6
 8002ed6:	f7ff fb71 	bl	80025bc <USB_OTG_EP0_OutStart>
  gintsts.d32 = 0;
  gintsts.b.usbreset = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
  
  /*Reset internal state machine */
  USBD_DCD_INT_fops->Reset(pdev);
 8002eda:	4964      	ldr	r1, [pc, #400]	; (800306c <USBD_OTG_ISR_Handler+0x548>)
  USB_OTG_EP0_OutStart(pdev);
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbreset = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002edc:	68f2      	ldr	r2, [r6, #12]
  
  /*Reset internal state machine */
  USBD_DCD_INT_fops->Reset(pdev);
 8002ede:	680b      	ldr	r3, [r1, #0]
  /* setup EP0 to receive SETUP packets */
  USB_OTG_EP0_OutStart(pdev);
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbreset = 1;
 8002ee0:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002ee4:	6150      	str	r0, [r2, #20]
  
  /*Reset internal state machine */
  USBD_DCD_INT_fops->Reset(pdev);
 8002ee6:	6919      	ldr	r1, [r3, #16]
 8002ee8:	4630      	mov	r0, r6
 8002eea:	4788      	blx	r1
      
    }
    
    if (gintr_status.b.usbreset)
    {
      retval |= DCD_HandleUsbReset_ISR(pdev);
 8002eec:	4628      	mov	r0, r5
 8002eee:	e67b      	b.n	8002be8 <USBD_OTG_ISR_Handler+0xc4>
  USB_OTG_EP *ep;
  
  /* Disable the Rx Status Queue Level interrupt */
  int_mask.d32 = 0;
  int_mask.b.rxstsqlvl = 1;
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32, 0);
 8002ef0:	68f3      	ldr	r3, [r6, #12]
 8002ef2:	699d      	ldr	r5, [r3, #24]
 8002ef4:	f025 0410 	bic.w	r4, r5, #16
 8002ef8:	619c      	str	r4, [r3, #24]
  
  /* Get the Status from the top of the FIFO */
  status.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRXSTSP );
 8002efa:	6a1c      	ldr	r4, [r3, #32]
  
  ep = &pdev->dev.out_ep[status.b.epnum];
  
  switch (status.b.pktsts)
 8002efc:	f3c4 4243 	ubfx	r2, r4, #17, #4
 8002f00:	2a02      	cmp	r2, #2
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32, 0);
  
  /* Get the Status from the top of the FIFO */
  status.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRXSTSP );
  
  ep = &pdev->dev.out_ep[status.b.epnum];
 8002f02:	f004 050f 	and.w	r5, r4, #15
  
  switch (status.b.pktsts)
 8002f06:	d04e      	beq.n	8002fa6 <USBD_OTG_ISR_Handler+0x482>
 8002f08:	2a06      	cmp	r2, #6
 8002f0a:	d111      	bne.n	8002f30 <USBD_OTG_ISR_Handler+0x40c>
    break;
  case STS_SETUP_COMP:
    break;
  case STS_SETUP_UPDT:
    /* Copy the setup packet received in FIFO into the setup buffer in RAM */
    USB_OTG_ReadPacket(pdev , pdev->dev.setup_packet, 8);
 8002f0c:	f506 61b9 	add.w	r1, r6, #1480	; 0x5c8
 8002f10:	4630      	mov	r0, r6
 8002f12:	2208      	movs	r2, #8
    ep->xfer_count += status.b.bcnt;
 8002f14:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    break;
  case STS_SETUP_COMP:
    break;
  case STS_SETUP_UPDT:
    /* Copy the setup packet received in FIFO into the setup buffer in RAM */
    USB_OTG_ReadPacket(pdev , pdev->dev.setup_packet, 8);
 8002f18:	f7fe fe52 	bl	8001bc0 <USB_OTG_ReadPacket>
    ep->xfer_count += status.b.bcnt;
 8002f1c:	eb06 0cc5 	add.w	ip, r6, r5, lsl #3
 8002f20:	f3c4 140a 	ubfx	r4, r4, #4, #11
 8002f24:	f8dc 1388 	ldr.w	r1, [ip, #904]	; 0x388
 8002f28:	68f3      	ldr	r3, [r6, #12]
 8002f2a:	1860      	adds	r0, r4, r1
 8002f2c:	f8cc 0388 	str.w	r0, [ip, #904]	; 0x388
  default:
    break;
  }
  
  /* Enable the Rx Status Queue Level interrupt */
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, int_mask.d32);
 8002f30:	6998      	ldr	r0, [r3, #24]
 8002f32:	f040 0210 	orr.w	r2, r0, #16
 8002f36:	619a      	str	r2, [r3, #24]
      
    }
    
    if (gintr_status.b.rxstsqlvl)
    {
      retval |= DCD_HandleRxStatusQueueLevel_ISR(pdev);
 8002f38:	2001      	movs	r0, #1
 8002f3a:	e64c      	b.n	8002bd6 <USBD_OTG_ISR_Handler+0xb2>
static uint32_t DCD_HandleSof_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_GINTSTS_TypeDef  GINTSTS;
  
  
  USBD_DCD_INT_fops->SOF(pdev);
 8002f3c:	484b      	ldr	r0, [pc, #300]	; (800306c <USBD_OTG_ISR_Handler+0x548>)
 8002f3e:	6802      	ldr	r2, [r0, #0]
 8002f40:	4630      	mov	r0, r6
 8002f42:	68d1      	ldr	r1, [r2, #12]
 8002f44:	4788      	blx	r1
  
  /* Clear interrupt */
  GINTSTS.d32 = 0;
  GINTSTS.b.sofintr = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, GINTSTS.d32);
 8002f46:	68f3      	ldr	r3, [r6, #12]
  
  USBD_DCD_INT_fops->SOF(pdev);
  
  /* Clear interrupt */
  GINTSTS.d32 = 0;
  GINTSTS.b.sofintr = 1;
 8002f48:	2008      	movs	r0, #8
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, GINTSTS.d32);
 8002f4a:	6158      	str	r0, [r3, #20]
    {
      retval |= DCD_HandleUSBSuspend_ISR(pdev);
    }
    if (gintr_status.b.sofintr)
    {
      retval |= DCD_HandleSof_ISR(pdev);
 8002f4c:	2001      	movs	r0, #1
 8002f4e:	e63b      	b.n	8002bc8 <USBD_OTG_ISR_Handler+0xa4>
{
  USB_OTG_GINTSTS_TypeDef  gintsts;
  USB_OTG_PCGCCTL_TypeDef  power;
  USB_OTG_DSTS_TypeDef     dsts;
  
  USBD_DCD_INT_fops->Suspend (pdev);      
 8002f50:	4846      	ldr	r0, [pc, #280]	; (800306c <USBD_OTG_ISR_Handler+0x548>)
 8002f52:	6803      	ldr	r3, [r0, #0]
 8002f54:	4630      	mov	r0, r6
 8002f56:	695a      	ldr	r2, [r3, #20]
 8002f58:	4790      	blx	r2
  
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8002f5a:	6931      	ldr	r1, [r6, #16]
    
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbsuspend = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002f5c:	68f3      	ldr	r3, [r6, #12]
  USB_OTG_PCGCCTL_TypeDef  power;
  USB_OTG_DSTS_TypeDef     dsts;
  
  USBD_DCD_INT_fops->Suspend (pdev);      
  
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8002f5e:	6889      	ldr	r1, [r1, #8]
    
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbsuspend = 1;
 8002f60:	f44f 6200 	mov.w	r2, #2048	; 0x800
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002f64:	615a      	str	r2, [r3, #20]
  
  if((pdev->cfg.low_power) && (dsts.b.suspsts == 1))
 8002f66:	7ab0      	ldrb	r0, [r6, #10]
 8002f68:	b188      	cbz	r0, 8002f8e <USBD_OTG_ISR_Handler+0x46a>
 8002f6a:	f011 0f01 	tst.w	r1, #1
 8002f6e:	d00e      	beq.n	8002f8e <USBD_OTG_ISR_Handler+0x46a>
  {
	/*  switch-off the clocks */
    power.d32 = 0;
    power.b.stoppclk = 1;
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);  
 8002f70:	f8d6 310c 	ldr.w	r3, [r6, #268]	; 0x10c
    
    power.b.gatehclk = 1;
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);
    
    /* Request to enter Sleep mode after exit from current ISR */
    SCB->SCR |= (SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk);
 8002f74:	4a3e      	ldr	r2, [pc, #248]	; (8003070 <USBD_OTG_ISR_Handler+0x54c>)
  if((pdev->cfg.low_power) && (dsts.b.suspsts == 1))
  {
	/*  switch-off the clocks */
    power.d32 = 0;
    power.b.stoppclk = 1;
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);  
 8002f76:	6819      	ldr	r1, [r3, #0]
 8002f78:	f041 0001 	orr.w	r0, r1, #1
 8002f7c:	6018      	str	r0, [r3, #0]
    
    power.b.gatehclk = 1;
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);
 8002f7e:	6819      	ldr	r1, [r3, #0]
 8002f80:	f041 0003 	orr.w	r0, r1, #3
 8002f84:	6018      	str	r0, [r3, #0]
    
    /* Request to enter Sleep mode after exit from current ISR */
    SCB->SCR |= (SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk);
 8002f86:	6913      	ldr	r3, [r2, #16]
 8002f88:	f043 0106 	orr.w	r1, r3, #6
 8002f8c:	6111      	str	r1, [r2, #16]
      retval |= DCD_HandleResume_ISR(pdev);
    }
    
    if (gintr_status.b.usbsuspend)
    {
      retval |= DCD_HandleUSBSuspend_ISR(pdev);
 8002f8e:	2001      	movs	r0, #1
 8002f90:	e613      	b.n	8002bba <USBD_OTG_ISR_Handler+0x96>
  USB_OTG_PCGCCTL_TypeDef  power;
  
  if(pdev->cfg.low_power)
  {
    /* un-gate USB Core clock */
    power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
 8002f92:	f8d6 310c 	ldr.w	r3, [r6, #268]	; 0x10c
    power.b.gatehclk = 0;
    power.b.stoppclk = 0;
    USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 8002f96:	f8d6 210c 	ldr.w	r2, [r6, #268]	; 0x10c
  
  if(pdev->cfg.low_power)
  {
    /* un-gate USB Core clock */
    power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
    power.b.gatehclk = 0;
 8002f9a:	f36f 0341 	bfc	r3, #1, #1
    power.b.stoppclk = 0;
 8002f9e:	f36f 0300 	bfc	r3, #0, #1
    USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 8002fa2:	6013      	str	r3, [r2, #0]
 8002fa4:	e5f1      	b.n	8002b8a <USBD_OTG_ISR_Handler+0x66>
  switch (status.b.pktsts)
  {
  case STS_GOUT_NAK:
    break;
  case STS_DATA_UPDT:
    if (status.b.bcnt)
 8002fa6:	f647 72f0 	movw	r2, #32752	; 0x7ff0
 8002faa:	ea04 0102 	and.w	r1, r4, r2
 8002fae:	2900      	cmp	r1, #0
 8002fb0:	d0be      	beq.n	8002f30 <USBD_OTG_ISR_Handler+0x40c>
    {
      USB_OTG_ReadPacket(pdev,ep->xfer_buff, status.b.bcnt);
 8002fb2:	eb05 0e85 	add.w	lr, r5, r5, lsl #2
 8002fb6:	eb06 05ce 	add.w	r5, r6, lr, lsl #3
 8002fba:	f3c4 140a 	ubfx	r4, r4, #4, #11
 8002fbe:	4622      	mov	r2, r4
 8002fc0:	f8d5 137c 	ldr.w	r1, [r5, #892]	; 0x37c
 8002fc4:	4630      	mov	r0, r6
 8002fc6:	f7fe fdfb 	bl	8001bc0 <USB_OTG_ReadPacket>
      ep->xfer_buff += status.b.bcnt;
 8002fca:	f8d5 237c 	ldr.w	r2, [r5, #892]	; 0x37c
      ep->xfer_count += status.b.bcnt;
 8002fce:	f8d5 1388 	ldr.w	r1, [r5, #904]	; 0x388
 8002fd2:	68f3      	ldr	r3, [r6, #12]
    break;
  case STS_DATA_UPDT:
    if (status.b.bcnt)
    {
      USB_OTG_ReadPacket(pdev,ep->xfer_buff, status.b.bcnt);
      ep->xfer_buff += status.b.bcnt;
 8002fd4:	1910      	adds	r0, r2, r4
      ep->xfer_count += status.b.bcnt;
 8002fd6:	1864      	adds	r4, r4, r1
    break;
  case STS_DATA_UPDT:
    if (status.b.bcnt)
    {
      USB_OTG_ReadPacket(pdev,ep->xfer_buff, status.b.bcnt);
      ep->xfer_buff += status.b.bcnt;
 8002fd8:	f8c5 037c 	str.w	r0, [r5, #892]	; 0x37c
      ep->xfer_count += status.b.bcnt;
 8002fdc:	f8c5 4388 	str.w	r4, [r5, #904]	; 0x388
 8002fe0:	e7a6      	b.n	8002f30 <USBD_OTG_ISR_Handler+0x40c>
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
  {
    pdev->cfg.speed            = USB_OTG_SPEED_HIGH;
 8002fe2:	2200      	movs	r2, #0
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
 8002fe4:	f44f 7e00 	mov.w	lr, #512	; 0x200
    gusbcfg.b.usbtrdtim = 9;
 8002fe8:	2009      	movs	r0, #9
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
  {
    pdev->cfg.speed            = USB_OTG_SPEED_HIGH;
 8002fea:	70b2      	strb	r2, [r6, #2]
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
 8002fec:	f8a6 e004 	strh.w	lr, [r6, #4]
    gusbcfg.b.usbtrdtim = 9;
 8002ff0:	f360 248d 	bfi	r4, r0, #10, #4
 8002ff4:	e73b      	b.n	8002e6e <USBD_OTG_ISR_Handler+0x34a>
      {
        fifoemptymsk = 0x1 << epnum;
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
        CLEAR_IN_EP_INTR(epnum, xfercompl);
        /* TX COMPLETE */
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 8002ff6:	4d1d      	ldr	r5, [pc, #116]	; (800306c <USBD_OTG_ISR_Handler+0x548>)
    {
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
      {
        fifoemptymsk = 0x1 << epnum;
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
 8002ff8:	6b58      	ldr	r0, [r3, #52]	; 0x34
        CLEAR_IN_EP_INTR(epnum, xfercompl);
        /* TX COMPLETE */
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 8002ffa:	6829      	ldr	r1, [r5, #0]
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
      {
        fifoemptymsk = 0x1 << epnum;
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
        CLEAR_IN_EP_INTR(epnum, xfercompl);
 8002ffc:	69ba      	ldr	r2, [r7, #24]
    if (ep_intr&0x1) /* In ITR */
    {
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
      {
        fifoemptymsk = 0x1 << epnum;
 8002ffe:	2501      	movs	r5, #1
 8003000:	fa05 fe0b 	lsl.w	lr, r5, fp
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
 8003004:	ea20 000e 	bic.w	r0, r0, lr
 8003008:	6358      	str	r0, [r3, #52]	; 0x34
        CLEAR_IN_EP_INTR(epnum, xfercompl);
        /* TX COMPLETE */
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 800300a:	684b      	ldr	r3, [r1, #4]
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
      {
        fifoemptymsk = 0x1 << epnum;
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
        CLEAR_IN_EP_INTR(epnum, xfercompl);
 800300c:	6095      	str	r5, [r2, #8]
        /* TX COMPLETE */
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 800300e:	4640      	mov	r0, r8
 8003010:	4631      	mov	r1, r6
 8003012:	4798      	blx	r3
        
        if (pdev->cfg.dma_enable == 1)
 8003014:	f898 9003 	ldrb.w	r9, [r8, #3]
 8003018:	45a9      	cmp	r9, r5
 800301a:	f47f ae35 	bne.w	8002c88 <USBD_OTG_ISR_Handler+0x164>
        {
          if((epnum == 0) && (pdev->dev.device_state == USB_OTG_EP0_STATUS_IN))
 800301e:	f1bb 0f00 	cmp.w	fp, #0
 8003022:	d104      	bne.n	800302e <USBD_OTG_ISR_Handler+0x50a>
 8003024:	f898 c111 	ldrb.w	ip, [r8, #273]	; 0x111
 8003028:	f1bc 0f04 	cmp.w	ip, #4
 800302c:	d001      	beq.n	8003032 <USBD_OTG_ISR_Handler+0x50e>
          {
            /* prepare to rx more setup packets */
            USB_OTG_EP0_OutStart(pdev);
 800302e:	464d      	mov	r5, r9
 8003030:	e62a      	b.n	8002c88 <USBD_OTG_ISR_Handler+0x164>
 8003032:	4640      	mov	r0, r8
 8003034:	f7ff fac2 	bl	80025bc <USB_OTG_EP0_OutStart>
 8003038:	464d      	mov	r5, r9
 800303a:	e625      	b.n	8002c88 <USBD_OTG_ISR_Handler+0x164>
        /* RX COMPLETE */
        USBD_DCD_INT_fops->DataOutStage(pdev , epnum);
        
        if (pdev->cfg.dma_enable == 1)
        {
          if((epnum == 0) && (pdev->dev.device_state == USB_OTG_EP0_STATUS_OUT))
 800303c:	b927      	cbnz	r7, 8003048 <USBD_OTG_ISR_Handler+0x524>
 800303e:	f896 e111 	ldrb.w	lr, [r6, #273]	; 0x111
 8003042:	f1be 0f05 	cmp.w	lr, #5
 8003046:	d001      	beq.n	800304c <USBD_OTG_ISR_Handler+0x528>
          {
            /* prepare to rx more setup packets */
            USB_OTG_EP0_OutStart(pdev);
 8003048:	4648      	mov	r0, r9
 800304a:	e6cf      	b.n	8002dec <USBD_OTG_ISR_Handler+0x2c8>
 800304c:	4630      	mov	r0, r6
 800304e:	f7ff fab5 	bl	80025bc <USB_OTG_EP0_OutStart>
 8003052:	4648      	mov	r0, r9
 8003054:	e6ca      	b.n	8002dec <USBD_OTG_ISR_Handler+0x2c8>
      {
        /* Clear the bit in DOEPINTn for this interrupt */
        CLEAR_OUT_EP_INTR(epnum, xfercompl);
        if (pdev->cfg.dma_enable == 1)
        {
          deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[epnum]->DOEPTSIZ));
 8003056:	691a      	ldr	r2, [r3, #16]
          /*ToDo : handle more than one single MPS size packet */
          pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
 8003058:	f8d8 1378 	ldr.w	r1, [r8, #888]	; 0x378
            deptsiz.b.xfersize;
 800305c:	f3c2 0c12 	ubfx	ip, r2, #0, #19
        CLEAR_OUT_EP_INTR(epnum, xfercompl);
        if (pdev->cfg.dma_enable == 1)
        {
          deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[epnum]->DOEPTSIZ));
          /*ToDo : handle more than one single MPS size packet */
          pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
 8003060:	ebcc 0301 	rsb	r3, ip, r1
 8003064:	f8c8 3388 	str.w	r3, [r8, #904]	; 0x388
 8003068:	e6b3      	b.n	8002dd2 <USBD_OTG_ISR_Handler+0x2ae>
 800306a:	bf00      	nop
 800306c:	20000148 	.word	0x20000148
 8003070:	e000ed00 	.word	0xe000ed00

08003074 <USBD_Resume>:
*/

static uint8_t USBD_Resume(USB_OTG_CORE_HANDLE  *pdev)
{
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceResumed(); 
 8003074:	f8d0 15e4 	ldr.w	r1, [r0, #1508]	; 0x5e4
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Resume(USB_OTG_CORE_HANDLE  *pdev)
{
 8003078:	b510      	push	{r4, lr}
 800307a:	4604      	mov	r4, r0
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceResumed(); 
 800307c:	6908      	ldr	r0, [r1, #16]
 800307e:	4780      	blx	r0
  pdev->dev.device_status = USB_OTG_CONFIGURED;  
 8003080:	2303      	movs	r3, #3
 8003082:	f884 3112 	strb.w	r3, [r4, #274]	; 0x112
  return USBD_OK;
}
 8003086:	2000      	movs	r0, #0
 8003088:	bd10      	pop	{r4, pc}
 800308a:	bf00      	nop

0800308c <USBD_Suspend>:
static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev)
{
  
  pdev->dev.device_status  = USB_OTG_SUSPENDED;
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceSuspended(); 
 800308c:	f8d0 15e4 	ldr.w	r1, [r0, #1508]	; 0x5e4
*/

static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev)
{
  
  pdev->dev.device_status  = USB_OTG_SUSPENDED;
 8003090:	2204      	movs	r2, #4
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev)
{
 8003092:	b508      	push	{r3, lr}
  
  pdev->dev.device_status  = USB_OTG_SUSPENDED;
 8003094:	f880 2112 	strb.w	r2, [r0, #274]	; 0x112
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceSuspended(); 
 8003098:	68cb      	ldr	r3, [r1, #12]
 800309a:	4798      	blx	r3
  return USBD_OK;
}
 800309c:	2000      	movs	r0, #0
 800309e:	bd08      	pop	{r3, pc}

080030a0 <USBD_SOF>:
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_SOF(USB_OTG_CORE_HANDLE  *pdev)
{
 80030a0:	b508      	push	{r3, lr}
  if(pdev->dev.class_cb->SOF)
 80030a2:	f8d0 35e0 	ldr.w	r3, [r0, #1504]	; 0x5e0
 80030a6:	69db      	ldr	r3, [r3, #28]
 80030a8:	b103      	cbz	r3, 80030ac <USBD_SOF+0xc>
  {
    pdev->dev.class_cb->SOF(pdev); 
 80030aa:	4798      	blx	r3
  }
  return USBD_OK;
}
 80030ac:	2000      	movs	r0, #0
 80030ae:	bd08      	pop	{r3, pc}

080030b0 <USBD_IsoINIncomplete>:
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoINIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
  pdev->dev.class_cb->IsoINIncomplete(pdev);   
 80030b0:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
*         Handle iso in incomplete event
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoINIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
 80030b4:	b508      	push	{r3, lr}
  pdev->dev.class_cb->IsoINIncomplete(pdev);   
 80030b6:	6a0b      	ldr	r3, [r1, #32]
 80030b8:	4798      	blx	r3
  return USBD_OK;
}
 80030ba:	2000      	movs	r0, #0
 80030bc:	bd08      	pop	{r3, pc}
 80030be:	bf00      	nop

080030c0 <USBD_IsoOUTIncomplete>:
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoOUTIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
  pdev->dev.class_cb->IsoOUTIncomplete(pdev);   
 80030c0:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
*         Handle iso out incomplete event
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoOUTIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
 80030c4:	b508      	push	{r3, lr}
  pdev->dev.class_cb->IsoOUTIncomplete(pdev);   
 80030c6:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 80030c8:	4798      	blx	r3
  return USBD_OK;
}
 80030ca:	2000      	movs	r0, #0
 80030cc:	bd08      	pop	{r3, pc}
 80030ce:	bf00      	nop

080030d0 <USBD_Reset>:
*/

static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
{
  /* Open EP0 OUT */
  DCD_EP_Open(pdev,
 80030d0:	2100      	movs	r1, #0
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
{
 80030d2:	b510      	push	{r4, lr}
  /* Open EP0 OUT */
  DCD_EP_Open(pdev,
 80030d4:	460b      	mov	r3, r1
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
{
 80030d6:	4604      	mov	r4, r0
  /* Open EP0 OUT */
  DCD_EP_Open(pdev,
 80030d8:	2240      	movs	r2, #64	; 0x40
 80030da:	f7ff fc13 	bl	8002904 <DCD_EP_Open>
              0x00,
              USB_OTG_MAX_EP0_SIZE,
              EP_TYPE_CTRL);
  
  /* Open EP0 IN */
  DCD_EP_Open(pdev,
 80030de:	2180      	movs	r1, #128	; 0x80
 80030e0:	2240      	movs	r2, #64	; 0x40
 80030e2:	2300      	movs	r3, #0
 80030e4:	4620      	mov	r0, r4
 80030e6:	f7ff fc0d 	bl	8002904 <DCD_EP_Open>
              USB_OTG_MAX_EP0_SIZE,
              EP_TYPE_CTRL);
  
  /* Upon Reset call usr call back */
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.usr_cb->DeviceReset(pdev->cfg.speed);
 80030ea:	f8d4 15e4 	ldr.w	r1, [r4, #1508]	; 0x5e4
 80030ee:	78a0      	ldrb	r0, [r4, #2]
              0x80,
              USB_OTG_MAX_EP0_SIZE,
              EP_TYPE_CTRL);
  
  /* Upon Reset call usr call back */
  pdev->dev.device_status = USB_OTG_DEFAULT;
 80030f0:	2201      	movs	r2, #1
 80030f2:	f884 2112 	strb.w	r2, [r4, #274]	; 0x112
  pdev->dev.usr_cb->DeviceReset(pdev->cfg.speed);
 80030f6:	684b      	ldr	r3, [r1, #4]
 80030f8:	4798      	blx	r3
  
  return USBD_OK;
}
 80030fa:	2000      	movs	r0, #0
 80030fc:	bd10      	pop	{r4, pc}
 80030fe:	bf00      	nop

08003100 <USBD_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_SetupStage(USB_OTG_CORE_HANDLE *pdev)
{
 8003100:	b510      	push	{r4, lr}
 8003102:	b082      	sub	sp, #8
  USB_SETUP_REQ req;
  
  USBD_ParseSetupRequest(pdev , &req);
 8003104:	4669      	mov	r1, sp
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_SetupStage(USB_OTG_CORE_HANDLE *pdev)
{
 8003106:	4604      	mov	r4, r0
  USB_SETUP_REQ req;
  
  USBD_ParseSetupRequest(pdev , &req);
 8003108:	f000 f93c 	bl	8003384 <USBD_ParseSetupRequest>
  
  switch (req.bmRequest & 0x1F) 
 800310c:	f89d 1000 	ldrb.w	r1, [sp]
 8003110:	f001 031f 	and.w	r3, r1, #31
 8003114:	2b01      	cmp	r3, #1
 8003116:	d014      	beq.n	8003142 <USBD_SetupStage+0x42>
 8003118:	2b02      	cmp	r3, #2
 800311a:	d00d      	beq.n	8003138 <USBD_SetupStage+0x38>
 800311c:	b13b      	cbz	r3, 800312e <USBD_SetupStage+0x2e>
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &req);   
    break;
    
  default:           
    DCD_EP_Stall(pdev , req.bmRequest & 0x80);
 800311e:	4620      	mov	r0, r4
 8003120:	f001 0180 	and.w	r1, r1, #128	; 0x80
 8003124:	f7ff fc70 	bl	8002a08 <DCD_EP_Stall>
    break;
  }  
  return USBD_OK;
}
 8003128:	2000      	movs	r0, #0
 800312a:	b002      	add	sp, #8
 800312c:	bd10      	pop	{r4, pc}
  USBD_ParseSetupRequest(pdev , &req);
  
  switch (req.bmRequest & 0x1F) 
  {
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &req);
 800312e:	4620      	mov	r0, r4
 8003130:	4669      	mov	r1, sp
 8003132:	f000 f9f1 	bl	8003518 <USBD_StdDevReq>
    break;
 8003136:	e7f7      	b.n	8003128 <USBD_SetupStage+0x28>
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &req);
    break;
    
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &req);   
 8003138:	4620      	mov	r0, r4
 800313a:	4669      	mov	r1, sp
 800313c:	f000 f960 	bl	8003400 <USBD_StdEPReq>
    break;
 8003140:	e7f2      	b.n	8003128 <USBD_SetupStage+0x28>
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &req);
    break;
    
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &req);
 8003142:	4620      	mov	r0, r4
 8003144:	4669      	mov	r1, sp
 8003146:	f000 f9cd 	bl	80034e4 <USBD_StdItfReq>
    break;
 800314a:	e7ed      	b.n	8003128 <USBD_SetupStage+0x28>

0800314c <USBD_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
static uint8_t USBD_DataInStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
 800314c:	b538      	push	{r3, r4, r5, lr}
 800314e:	4604      	mov	r4, r0
  USB_OTG_EP *ep;
  
  if(epnum == 0) 
 8003150:	b929      	cbnz	r1, 800315e <USBD_DataInStage+0x12>
  {
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
 8003152:	f890 3111 	ldrb.w	r3, [r0, #273]	; 0x111
 8003156:	2b02      	cmp	r3, #2
 8003158:	d00d      	beq.n	8003176 <USBD_DataInStage+0x2a>
          (pdev->dev.device_status == USB_OTG_CONFIGURED))
  {
    pdev->dev.class_cb->DataIn(pdev, epnum); 
  }  
  return USBD_OK;
}
 800315a:	2000      	movs	r0, #0
 800315c:	bd38      	pop	{r3, r4, r5, pc}
          USBD_CtlReceiveStatus(pdev);
        }
      }
    }
  }
  else if((pdev->dev.class_cb->DataIn != NULL)&& 
 800315e:	f8d0 25e0 	ldr.w	r2, [r0, #1504]	; 0x5e0
 8003162:	6953      	ldr	r3, [r2, #20]
 8003164:	2b00      	cmp	r3, #0
 8003166:	d0f8      	beq.n	800315a <USBD_DataInStage+0xe>
 8003168:	f890 c112 	ldrb.w	ip, [r0, #274]	; 0x112
 800316c:	f1bc 0f03 	cmp.w	ip, #3
 8003170:	d1f3      	bne.n	800315a <USBD_DataInStage+0xe>
          (pdev->dev.device_status == USB_OTG_CONFIGURED))
  {
    pdev->dev.class_cb->DataIn(pdev, epnum); 
 8003172:	4798      	blx	r3
 8003174:	e7f1      	b.n	800315a <USBD_DataInStage+0xe>
  if(epnum == 0) 
  {
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
    {
      if(ep->rem_data_len > ep->maxpacket)
 8003176:	f8d0 2134 	ldr.w	r2, [r0, #308]	; 0x134
 800317a:	f8d0 3120 	ldr.w	r3, [r0, #288]	; 0x120
 800317e:	429a      	cmp	r2, r3
 8003180:	d910      	bls.n	80031a4 <USBD_DataInStage+0x58>
      {
        ep->rem_data_len -=  ep->maxpacket;
        if(pdev->cfg.dma_enable == 1)
 8003182:	78c1      	ldrb	r1, [r0, #3]
 8003184:	2901      	cmp	r1, #1
 8003186:	f8d0 1124 	ldr.w	r1, [r0, #292]	; 0x124
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 800318a:	ebc3 0202 	rsb	r2, r3, r2
        if(pdev->cfg.dma_enable == 1)
        {
          /* in slave mode this, is handled by the TxFifoEmpty ISR */
          ep->xfer_buff += ep->maxpacket;
 800318e:	bf08      	it	eq
 8003190:	18c9      	addeq	r1, r1, r3
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 8003192:	f8c0 2134 	str.w	r2, [r0, #308]	; 0x134
        if(pdev->cfg.dma_enable == 1)
        {
          /* in slave mode this, is handled by the TxFifoEmpty ISR */
          ep->xfer_buff += ep->maxpacket;
 8003196:	bf08      	it	eq
 8003198:	f8c0 1124 	streq.w	r1, [r0, #292]	; 0x124
        }
        USBD_CtlContinueSendData (pdev, 
 800319c:	b292      	uxth	r2, r2
 800319e:	f000 f8a5 	bl	80032ec <USBD_CtlContinueSendData>
 80031a2:	e7da      	b.n	800315a <USBD_DataInStage+0xe>
                                  ep->xfer_buff, 
                                  ep->rem_data_len);
      }
      else
      { /* last packet is MPS multiple, so send ZLP packet */
        if((ep->total_data_len % ep->maxpacket == 0) &&
 80031a4:	f8d0 2138 	ldr.w	r2, [r0, #312]	; 0x138
 80031a8:	fbb2 f5f3 	udiv	r5, r2, r3
 80031ac:	fb03 2515 	mls	r5, r3, r5, r2
 80031b0:	b95d      	cbnz	r5, 80031ca <USBD_DataInStage+0x7e>
 80031b2:	4293      	cmp	r3, r2
 80031b4:	d809      	bhi.n	80031ca <USBD_DataInStage+0x7e>
           (ep->total_data_len >= ep->maxpacket) &&
 80031b6:	f8d0 313c 	ldr.w	r3, [r0, #316]	; 0x13c
 80031ba:	429a      	cmp	r2, r3
 80031bc:	d205      	bcs.n	80031ca <USBD_DataInStage+0x7e>
             (ep->total_data_len < ep->ctl_data_len ))
        {
          
          USBD_CtlContinueSendData(pdev , NULL, 0);
 80031be:	462a      	mov	r2, r5
 80031c0:	f000 f894 	bl	80032ec <USBD_CtlContinueSendData>
          ep->ctl_data_len = 0;
 80031c4:	f8c4 513c 	str.w	r5, [r4, #316]	; 0x13c
 80031c8:	e7c7      	b.n	800315a <USBD_DataInStage+0xe>
        }
        else
        {
          if((pdev->dev.class_cb->EP0_TxSent != NULL)&&
 80031ca:	f8d4 05e0 	ldr.w	r0, [r4, #1504]	; 0x5e0
 80031ce:	68c3      	ldr	r3, [r0, #12]
 80031d0:	b123      	cbz	r3, 80031dc <USBD_DataInStage+0x90>
 80031d2:	f894 c112 	ldrb.w	ip, [r4, #274]	; 0x112
 80031d6:	f1bc 0f03 	cmp.w	ip, #3
 80031da:	d003      	beq.n	80031e4 <USBD_DataInStage+0x98>
             (pdev->dev.device_status == USB_OTG_CONFIGURED))
          {
            pdev->dev.class_cb->EP0_TxSent(pdev); 
          }          
          USBD_CtlReceiveStatus(pdev);
 80031dc:	4620      	mov	r0, r4
 80031de:	f000 f8b9 	bl	8003354 <USBD_CtlReceiveStatus>
 80031e2:	e7ba      	b.n	800315a <USBD_DataInStage+0xe>
        else
        {
          if((pdev->dev.class_cb->EP0_TxSent != NULL)&&
             (pdev->dev.device_status == USB_OTG_CONFIGURED))
          {
            pdev->dev.class_cb->EP0_TxSent(pdev); 
 80031e4:	4620      	mov	r0, r4
 80031e6:	4798      	blx	r3
 80031e8:	e7f8      	b.n	80031dc <USBD_DataInStage+0x90>
 80031ea:	bf00      	nop

080031ec <USBD_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
static uint8_t USBD_DataOutStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
 80031ec:	b510      	push	{r4, lr}
 80031ee:	4604      	mov	r4, r0
  USB_OTG_EP *ep;
  
  if(epnum == 0) 
 80031f0:	b929      	cbnz	r1, 80031fe <USBD_DataOutStage+0x12>
  {
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
 80031f2:	f890 3111 	ldrb.w	r3, [r0, #273]	; 0x111
 80031f6:	2b03      	cmp	r3, #3
 80031f8:	d00d      	beq.n	8003216 <USBD_DataOutStage+0x2a>
          (pdev->dev.device_status == USB_OTG_CONFIGURED))
  {
    pdev->dev.class_cb->DataOut(pdev, epnum); 
  }  
  return USBD_OK;
}
 80031fa:	2000      	movs	r0, #0
 80031fc:	bd10      	pop	{r4, pc}
        }
        USBD_CtlSendStatus(pdev);
      }
    }
  }
  else if((pdev->dev.class_cb->DataOut != NULL)&&
 80031fe:	f8d0 25e0 	ldr.w	r2, [r0, #1504]	; 0x5e0
 8003202:	6993      	ldr	r3, [r2, #24]
 8003204:	2b00      	cmp	r3, #0
 8003206:	d0f8      	beq.n	80031fa <USBD_DataOutStage+0xe>
 8003208:	f890 c112 	ldrb.w	ip, [r0, #274]	; 0x112
 800320c:	f1bc 0f03 	cmp.w	ip, #3
 8003210:	d1f3      	bne.n	80031fa <USBD_DataOutStage+0xe>
          (pdev->dev.device_status == USB_OTG_CONFIGURED))
  {
    pdev->dev.class_cb->DataOut(pdev, epnum); 
 8003212:	4798      	blx	r3
 8003214:	e7f1      	b.n	80031fa <USBD_DataOutStage+0xe>
  if(epnum == 0) 
  {
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
    {
      if(ep->rem_data_len > ep->maxpacket)
 8003216:	f8d0 238c 	ldr.w	r2, [r0, #908]	; 0x38c
 800321a:	f8d0 3378 	ldr.w	r3, [r0, #888]	; 0x378
 800321e:	429a      	cmp	r2, r3
 8003220:	d912      	bls.n	8003248 <USBD_DataOutStage+0x5c>
      {
        ep->rem_data_len -=  ep->maxpacket;
        
        if(pdev->cfg.dma_enable == 1)
 8003222:	78c1      	ldrb	r1, [r0, #3]
 8003224:	2901      	cmp	r1, #1
 8003226:	f8d0 137c 	ldr.w	r1, [r0, #892]	; 0x37c
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 800322a:	ebc3 0202 	rsb	r2, r3, r2
        
        if(pdev->cfg.dma_enable == 1)
        {
          /* in slave mode this, is handled by the RxSTSQLvl ISR */
          ep->xfer_buff += ep->maxpacket; 
 800322e:	bf04      	itt	eq
 8003230:	18c9      	addeq	r1, r1, r3
 8003232:	f8c0 137c 	streq.w	r1, [r0, #892]	; 0x37c
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 8003236:	f8c0 238c 	str.w	r2, [r0, #908]	; 0x38c
          /* in slave mode this, is handled by the RxSTSQLvl ISR */
          ep->xfer_buff += ep->maxpacket; 
        }        
        USBD_CtlContinueRx (pdev, 
                            ep->xfer_buff,
                            MIN(ep->rem_data_len ,ep->maxpacket));
 800323a:	429a      	cmp	r2, r3
 800323c:	bf28      	it	cs
 800323e:	461a      	movcs	r2, r3
        if(pdev->cfg.dma_enable == 1)
        {
          /* in slave mode this, is handled by the RxSTSQLvl ISR */
          ep->xfer_buff += ep->maxpacket; 
        }        
        USBD_CtlContinueRx (pdev, 
 8003240:	b292      	uxth	r2, r2
 8003242:	f000 f86d 	bl	8003320 <USBD_CtlContinueRx>
 8003246:	e7d8      	b.n	80031fa <USBD_DataOutStage+0xe>
                            ep->xfer_buff,
                            MIN(ep->rem_data_len ,ep->maxpacket));
      }
      else
      {
        if((pdev->dev.class_cb->EP0_RxReady != NULL)&&
 8003248:	f8d0 35e0 	ldr.w	r3, [r0, #1504]	; 0x5e0
 800324c:	691b      	ldr	r3, [r3, #16]
 800324e:	b123      	cbz	r3, 800325a <USBD_DataOutStage+0x6e>
 8003250:	f890 c112 	ldrb.w	ip, [r0, #274]	; 0x112
 8003254:	f1bc 0f03 	cmp.w	ip, #3
 8003258:	d003      	beq.n	8003262 <USBD_DataOutStage+0x76>
           (pdev->dev.device_status == USB_OTG_CONFIGURED))
        {
          pdev->dev.class_cb->EP0_RxReady(pdev); 
        }
        USBD_CtlSendStatus(pdev);
 800325a:	4620      	mov	r0, r4
 800325c:	f000 f86a 	bl	8003334 <USBD_CtlSendStatus>
 8003260:	e7cb      	b.n	80031fa <USBD_DataOutStage+0xe>
      else
      {
        if((pdev->dev.class_cb->EP0_RxReady != NULL)&&
           (pdev->dev.device_status == USB_OTG_CONFIGURED))
        {
          pdev->dev.class_cb->EP0_RxReady(pdev); 
 8003262:	4798      	blx	r3
 8003264:	e7f9      	b.n	800325a <USBD_DataOutStage+0x6e>
 8003266:	bf00      	nop

08003268 <USBD_Init>:
void USBD_Init(USB_OTG_CORE_HANDLE *pdev,
               USB_OTG_CORE_ID_TypeDef coreID,
               USBD_DEVICE *pDevice,                  
               USBD_Class_cb_TypeDef *class_cb, 
               USBD_Usr_cb_TypeDef *usr_cb)
{
 8003268:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800326c:	9d06      	ldr	r5, [sp, #24]
 800326e:	4604      	mov	r4, r0
 8003270:	4616      	mov	r6, r2
 8003272:	461f      	mov	r7, r3
 8003274:	4688      	mov	r8, r1
  /* Hardware Init */
  USB_OTG_BSP_Init(pdev);  
 8003276:	f000 fafb 	bl	8003870 <USB_OTG_BSP_Init>
  pdev->dev.class_cb = class_cb;
  pdev->dev.usr_cb = usr_cb;  
  pdev->dev.usr_device = pDevice;    
  
  /* set USB OTG core params */
  DCD_Init(pdev , coreID);
 800327a:	4620      	mov	r0, r4
 800327c:	4641      	mov	r1, r8
  USB_OTG_BSP_Init(pdev);  
  
  USBD_DeInit(pdev);
  
  /*Register class and user callbacks */
  pdev->dev.class_cb = class_cb;
 800327e:	f8c4 75e0 	str.w	r7, [r4, #1504]	; 0x5e0
  pdev->dev.usr_cb = usr_cb;  
 8003282:	f8c4 55e4 	str.w	r5, [r4, #1508]	; 0x5e4
  pdev->dev.usr_device = pDevice;    
 8003286:	f8c4 65e8 	str.w	r6, [r4, #1512]	; 0x5e8
  
  /* set USB OTG core params */
  DCD_Init(pdev , coreID);
 800328a:	f7ff fa7f 	bl	800278c <DCD_Init>
  
  /* Upon Init call usr callback */
  pdev->dev.usr_cb->Init();
 800328e:	f8d4 05e4 	ldr.w	r0, [r4, #1508]	; 0x5e4
 8003292:	6803      	ldr	r3, [r0, #0]
 8003294:	4798      	blx	r3
  
  /* Enable Interrupts */
  USB_OTG_BSP_EnableInterrupt(pdev);
 8003296:	4620      	mov	r0, r4
}
 8003298:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  
  /* Upon Init call usr callback */
  pdev->dev.usr_cb->Init();
  
  /* Enable Interrupts */
  USB_OTG_BSP_EnableInterrupt(pdev);
 800329c:	f000 bb3a 	b.w	8003914 <USB_OTG_BSP_EnableInterrupt>

080032a0 <USBD_DeInit>:
USBD_Status USBD_DeInit(USB_OTG_CORE_HANDLE *pdev)
{
  /* Software Init */
  
  return USBD_OK;
}
 80032a0:	2000      	movs	r0, #0
 80032a2:	4770      	bx	lr

080032a4 <USBD_SetCfg>:
* @retval status
*/

USBD_Status USBD_SetCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
  pdev->dev.class_cb->Init(pdev, cfgidx); 
 80032a4:	f8d0 35e0 	ldr.w	r3, [r0, #1504]	; 0x5e0
* @param  cfgidx: configuration index
* @retval status
*/

USBD_Status USBD_SetCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
 80032a8:	b510      	push	{r4, lr}
 80032aa:	4604      	mov	r4, r0
  pdev->dev.class_cb->Init(pdev, cfgidx); 
 80032ac:	681a      	ldr	r2, [r3, #0]
 80032ae:	4790      	blx	r2
  
  /* Upon set config call usr call back */
  pdev->dev.usr_cb->DeviceConfigured();
 80032b0:	f8d4 05e4 	ldr.w	r0, [r4, #1508]	; 0x5e4
 80032b4:	6883      	ldr	r3, [r0, #8]
 80032b6:	4798      	blx	r3
  return USBD_OK; 
}
 80032b8:	2000      	movs	r0, #0
 80032ba:	bd10      	pop	{r4, pc}

080032bc <USBD_ClrCfg>:
* @param  cfgidx: configuration index
* @retval status: USBD_Status
*/
USBD_Status USBD_ClrCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
  pdev->dev.class_cb->DeInit(pdev, cfgidx);   
 80032bc:	f8d0 25e0 	ldr.w	r2, [r0, #1504]	; 0x5e0
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_Status
*/
USBD_Status USBD_ClrCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
 80032c0:	b508      	push	{r3, lr}
  pdev->dev.class_cb->DeInit(pdev, cfgidx);   
 80032c2:	6853      	ldr	r3, [r2, #4]
 80032c4:	4798      	blx	r3
  return USBD_OK;
}
 80032c6:	2000      	movs	r0, #0
 80032c8:	bd08      	pop	{r3, pc}
 80032ca:	bf00      	nop

080032cc <USBD_CtlSendData>:
* @retval status
*/
USBD_Status  USBD_CtlSendData (USB_OTG_CORE_HANDLE  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 80032cc:	4613      	mov	r3, r2
 80032ce:	460a      	mov	r2, r1
  USBD_Status ret = USBD_OK;
  
  pdev->dev.in_ep[0].total_data_len = len;
  pdev->dev.in_ep[0].rem_data_len   = len;
  pdev->dev.device_state = USB_OTG_EP0_DATA_IN;
 80032d0:	2102      	movs	r1, #2
* @retval status
*/
USBD_Status  USBD_CtlSendData (USB_OTG_CORE_HANDLE  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 80032d2:	b510      	push	{r4, lr}
  USBD_Status ret = USBD_OK;
  
  pdev->dev.in_ep[0].total_data_len = len;
 80032d4:	f8c0 3138 	str.w	r3, [r0, #312]	; 0x138
  pdev->dev.in_ep[0].rem_data_len   = len;
 80032d8:	f8c0 3134 	str.w	r3, [r0, #308]	; 0x134
  pdev->dev.device_state = USB_OTG_EP0_DATA_IN;
 80032dc:	f880 1111 	strb.w	r1, [r0, #273]	; 0x111

  DCD_EP_Tx (pdev, 0, pbuf, len);
 80032e0:	2100      	movs	r1, #0
 80032e2:	f7ff fb6f 	bl	80029c4 <DCD_EP_Tx>
 
  return ret;
}
 80032e6:	2000      	movs	r0, #0
 80032e8:	bd10      	pop	{r4, pc}
 80032ea:	bf00      	nop

080032ec <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_Status  USBD_CtlContinueSendData (USB_OTG_CORE_HANDLE  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 80032ec:	b510      	push	{r4, lr}
 80032ee:	460c      	mov	r4, r1
 80032f0:	4613      	mov	r3, r2
  USBD_Status ret = USBD_OK;
  
  DCD_EP_Tx (pdev, 0, pbuf, len);
 80032f2:	2100      	movs	r1, #0
 80032f4:	4622      	mov	r2, r4
 80032f6:	f7ff fb65 	bl	80029c4 <DCD_EP_Tx>
  
  
  return ret;
}
 80032fa:	2000      	movs	r0, #0
 80032fc:	bd10      	pop	{r4, pc}
 80032fe:	bf00      	nop

08003300 <USBD_CtlPrepareRx>:
* @retval status
*/
USBD_Status  USBD_CtlPrepareRx (USB_OTG_CORE_HANDLE  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
 8003300:	4613      	mov	r3, r2
 8003302:	460a      	mov	r2, r1
  USBD_Status ret = USBD_OK;
  
  pdev->dev.out_ep[0].total_data_len = len;
  pdev->dev.out_ep[0].rem_data_len   = len;
  pdev->dev.device_state = USB_OTG_EP0_DATA_OUT;
 8003304:	2103      	movs	r1, #3
* @retval status
*/
USBD_Status  USBD_CtlPrepareRx (USB_OTG_CORE_HANDLE  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
 8003306:	b510      	push	{r4, lr}
  USBD_Status ret = USBD_OK;
  
  pdev->dev.out_ep[0].total_data_len = len;
 8003308:	f8c0 3390 	str.w	r3, [r0, #912]	; 0x390
  pdev->dev.out_ep[0].rem_data_len   = len;
 800330c:	f8c0 338c 	str.w	r3, [r0, #908]	; 0x38c
  pdev->dev.device_state = USB_OTG_EP0_DATA_OUT;
 8003310:	f880 1111 	strb.w	r1, [r0, #273]	; 0x111
  
  DCD_EP_PrepareRx (pdev,
 8003314:	2100      	movs	r1, #0
 8003316:	f7ff fb2b 	bl	8002970 <DCD_EP_PrepareRx>
                    pbuf,
                    len);
  

  return ret;
}
 800331a:	2000      	movs	r0, #0
 800331c:	bd10      	pop	{r4, pc}
 800331e:	bf00      	nop

08003320 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_Status  USBD_CtlContinueRx (USB_OTG_CORE_HANDLE  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 8003320:	b510      	push	{r4, lr}
 8003322:	460c      	mov	r4, r1
 8003324:	4613      	mov	r3, r2
  USBD_Status ret = USBD_OK;
  
  DCD_EP_PrepareRx (pdev,
 8003326:	2100      	movs	r1, #0
 8003328:	4622      	mov	r2, r4
 800332a:	f7ff fb21 	bl	8002970 <DCD_EP_PrepareRx>
                    0,                     
                    pbuf,                         
                    len);
  return ret;
}
 800332e:	2000      	movs	r0, #0
 8003330:	bd10      	pop	{r4, pc}
 8003332:	bf00      	nop

08003334 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 8003334:	b538      	push	{r3, r4, r5, lr}
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
  DCD_EP_Tx (pdev,
 8003336:	2100      	movs	r1, #0
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
 8003338:	2504      	movs	r5, #4
*         send zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 800333a:	4604      	mov	r4, r0
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
  DCD_EP_Tx (pdev,
 800333c:	460a      	mov	r2, r1
 800333e:	460b      	mov	r3, r1
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
 8003340:	f880 5111 	strb.w	r5, [r0, #273]	; 0x111
  DCD_EP_Tx (pdev,
 8003344:	f7ff fb3e 	bl	80029c4 <DCD_EP_Tx>
             0,
             NULL, 
             0); 
  
  USB_OTG_EP0_OutStart(pdev);  
 8003348:	4620      	mov	r0, r4
 800334a:	f7ff f937 	bl	80025bc <USB_OTG_EP0_OutStart>
  
  return ret;
}
 800334e:	2000      	movs	r0, #0
 8003350:	bd38      	pop	{r3, r4, r5, pc}
 8003352:	bf00      	nop

08003354 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 8003354:	b538      	push	{r3, r4, r5, lr}
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
  DCD_EP_PrepareRx ( pdev,
 8003356:	2100      	movs	r1, #0
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
 8003358:	2505      	movs	r5, #5
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 800335a:	4604      	mov	r4, r0
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
  DCD_EP_PrepareRx ( pdev,
 800335c:	460a      	mov	r2, r1
 800335e:	460b      	mov	r3, r1
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
 8003360:	f880 5111 	strb.w	r5, [r0, #273]	; 0x111
  DCD_EP_PrepareRx ( pdev,
 8003364:	f7ff fb04 	bl	8002970 <DCD_EP_PrepareRx>
                    0,
                    NULL,
                    0);  

  USB_OTG_EP0_OutStart(pdev);
 8003368:	4620      	mov	r0, r4
 800336a:	f7ff f927 	bl	80025bc <USB_OTG_EP0_OutStart>
  
  return ret;
}
 800336e:	2000      	movs	r0, #0
 8003370:	bd38      	pop	{r3, r4, r5, pc}
 8003372:	bf00      	nop

08003374 <USBD_GetRxCount>:
*         epnum: endpoint index
* @retval Rx Data blength
*/
uint16_t  USBD_GetRxCount (USB_OTG_CORE_HANDLE  *pdev , uint8_t epnum)
{
  return pdev->dev.out_ep[epnum].xfer_count;
 8003374:	eb01 0281 	add.w	r2, r1, r1, lsl #2
 8003378:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
}
 800337c:	f8b1 0388 	ldrh.w	r0, [r1, #904]	; 0x388
 8003380:	4770      	bx	lr
 8003382:	bf00      	nop

08003384 <USBD_ParseSetupRequest>:
*/

void USBD_ParseSetupRequest( USB_OTG_CORE_HANDLE  *pdev,
                            USB_SETUP_REQ *req)
{
  req->bmRequest     = *(uint8_t *)  (pdev->dev.setup_packet);
 8003384:	f890 25c8 	ldrb.w	r2, [r0, #1480]	; 0x5c8
 8003388:	700a      	strb	r2, [r1, #0]
  req->bRequest      = *(uint8_t *)  (pdev->dev.setup_packet +  1);
 800338a:	f890 c5c9 	ldrb.w	ip, [r0, #1481]	; 0x5c9
 800338e:	f881 c001 	strb.w	ip, [r1, #1]
  req->wValue        = SWAPBYTE      (pdev->dev.setup_packet +  2);
 8003392:	f890 35cb 	ldrb.w	r3, [r0, #1483]	; 0x5cb
 8003396:	f890 25ca 	ldrb.w	r2, [r0, #1482]	; 0x5ca
 800339a:	021b      	lsls	r3, r3, #8
 800339c:	eb03 0c02 	add.w	ip, r3, r2
 80033a0:	f8a1 c002 	strh.w	ip, [r1, #2]
  req->wIndex        = SWAPBYTE      (pdev->dev.setup_packet +  4);
 80033a4:	f890 35cd 	ldrb.w	r3, [r0, #1485]	; 0x5cd
 80033a8:	f890 25cc 	ldrb.w	r2, [r0, #1484]	; 0x5cc
 80033ac:	021b      	lsls	r3, r3, #8
 80033ae:	eb03 0c02 	add.w	ip, r3, r2
 80033b2:	f8a1 c004 	strh.w	ip, [r1, #4]
  req->wLength       = SWAPBYTE      (pdev->dev.setup_packet +  6);
 80033b6:	f890 35cf 	ldrb.w	r3, [r0, #1487]	; 0x5cf
 80033ba:	f890 25ce 	ldrb.w	r2, [r0, #1486]	; 0x5ce
 80033be:	021b      	lsls	r3, r3, #8
 80033c0:	eb03 0c02 	add.w	ip, r3, r2
 80033c4:	fa1f f28c 	uxth.w	r2, ip
  
  pdev->dev.in_ep[0].ctl_data_len = req->wLength  ;
  pdev->dev.device_state = USB_OTG_EP0_SETUP;
 80033c8:	2301      	movs	r3, #1
{
  req->bmRequest     = *(uint8_t *)  (pdev->dev.setup_packet);
  req->bRequest      = *(uint8_t *)  (pdev->dev.setup_packet +  1);
  req->wValue        = SWAPBYTE      (pdev->dev.setup_packet +  2);
  req->wIndex        = SWAPBYTE      (pdev->dev.setup_packet +  4);
  req->wLength       = SWAPBYTE      (pdev->dev.setup_packet +  6);
 80033ca:	80ca      	strh	r2, [r1, #6]
  
  pdev->dev.in_ep[0].ctl_data_len = req->wLength  ;
 80033cc:	f8c0 213c 	str.w	r2, [r0, #316]	; 0x13c
  pdev->dev.device_state = USB_OTG_EP0_SETUP;
 80033d0:	f880 3111 	strb.w	r3, [r0, #273]	; 0x111
}
 80033d4:	4770      	bx	lr
 80033d6:	bf00      	nop

080033d8 <USBD_CtlError>:
* @retval None
*/

void USBD_CtlError( USB_OTG_CORE_HANDLE  *pdev,
                            USB_SETUP_REQ *req)
{
 80033d8:	b510      	push	{r4, lr}
  if((req->bmRequest & 0x80) == 0x80)
 80033da:	f991 3000 	ldrsb.w	r3, [r1]
 80033de:	2b00      	cmp	r3, #0
* @retval None
*/

void USBD_CtlError( USB_OTG_CORE_HANDLE  *pdev,
                            USB_SETUP_REQ *req)
{
 80033e0:	4604      	mov	r4, r0
  if((req->bmRequest & 0x80) == 0x80)
 80033e2:	db09      	blt.n	80033f8 <USBD_CtlError+0x20>
  {
    DCD_EP_Stall(pdev , 0x80);
  }
  else 
  {
    if(req->wLength == 0)
 80033e4:	88c9      	ldrh	r1, [r1, #6]
 80033e6:	b139      	cbz	r1, 80033f8 <USBD_CtlError+0x20>
    {
       DCD_EP_Stall(pdev , 0x80);
    }
    else
    {
      DCD_EP_Stall(pdev , 0);
 80033e8:	2100      	movs	r1, #0
 80033ea:	f7ff fb0d 	bl	8002a08 <DCD_EP_Stall>
    }
  }
  USB_OTG_EP0_OutStart(pdev);  
 80033ee:	4620      	mov	r0, r4
}
 80033f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    else
    {
      DCD_EP_Stall(pdev , 0);
    }
  }
  USB_OTG_EP0_OutStart(pdev);  
 80033f4:	f7ff b8e2 	b.w	80025bc <USB_OTG_EP0_OutStart>
  }
  else 
  {
    if(req->wLength == 0)
    {
       DCD_EP_Stall(pdev , 0x80);
 80033f8:	2180      	movs	r1, #128	; 0x80
 80033fa:	f7ff fb05 	bl	8002a08 <DCD_EP_Stall>
 80033fe:	e7f6      	b.n	80033ee <USBD_CtlError+0x16>

08003400 <USBD_StdEPReq>:
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdEPReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 8003400:	b538      	push	{r3, r4, r5, lr}
  uint8_t   ep_addr;
  USBD_Status ret = USBD_OK; 
  
  ep_addr  = LOBYTE(req->wIndex);   
  
  switch (req->bRequest) 
 8003402:	784b      	ldrb	r3, [r1, #1]
{
  
  uint8_t   ep_addr;
  USBD_Status ret = USBD_OK; 
  
  ep_addr  = LOBYTE(req->wIndex);   
 8003404:	790a      	ldrb	r2, [r1, #4]
  
  switch (req->bRequest) 
 8003406:	2b01      	cmp	r3, #1
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdEPReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 8003408:	460c      	mov	r4, r1
 800340a:	4605      	mov	r5, r0
  uint8_t   ep_addr;
  USBD_Status ret = USBD_OK; 
  
  ep_addr  = LOBYTE(req->wIndex);   
  
  switch (req->bRequest) 
 800340c:	d00e      	beq.n	800342c <USBD_StdEPReq+0x2c>
 800340e:	d303      	bcc.n	8003418 <USBD_StdEPReq+0x18>
 8003410:	2b03      	cmp	r3, #3
 8003412:	d017      	beq.n	8003444 <USBD_StdEPReq+0x44>
    
  default:
    break;
  }
  return ret;
}
 8003414:	2000      	movs	r0, #0
 8003416:	bd38      	pop	{r3, r4, r5, pc}
      break;    
    }
    break;
    
  case USB_REQ_GET_STATUS:                  
    switch (pdev->dev.device_status) 
 8003418:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 800341c:	2b02      	cmp	r3, #2
 800341e:	d009      	beq.n	8003434 <USBD_StdEPReq+0x34>
 8003420:	2b03      	cmp	r3, #3
 8003422:	d03c      	beq.n	800349e <USBD_StdEPReq+0x9e>
                        (uint8_t *)&USBD_ep_status,
                        2);
      break;
      
    default:                         
       USBD_CtlError(pdev , req);
 8003424:	f7ff ffd8 	bl	80033d8 <USBD_CtlError>
    
  default:
    break;
  }
  return ret;
}
 8003428:	2000      	movs	r0, #0
 800342a:	bd38      	pop	{r3, r4, r5, pc}
    }
    break;
    
  case USB_REQ_CLEAR_FEATURE :
    
    switch (pdev->dev.device_status) 
 800342c:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 8003430:	2b02      	cmp	r3, #2
 8003432:	d11f      	bne.n	8003474 <USBD_StdEPReq+0x74>
    
  case USB_REQ_GET_STATUS:                  
    switch (pdev->dev.device_status) 
    {
    case USB_OTG_ADDRESSED:          
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8003434:	2a00      	cmp	r2, #0
 8003436:	d0ed      	beq.n	8003414 <USBD_StdEPReq+0x14>
 8003438:	2a80      	cmp	r2, #128	; 0x80
 800343a:	d0eb      	beq.n	8003414 <USBD_StdEPReq+0x14>
      {
        DCD_EP_Stall(pdev , ep_addr);
 800343c:	4611      	mov	r1, r2
 800343e:	f7ff fae3 	bl	8002a08 <DCD_EP_Stall>
 8003442:	e7e7      	b.n	8003414 <USBD_StdEPReq+0x14>
  switch (req->bRequest) 
  {
    
  case USB_REQ_SET_FEATURE :
    
    switch (pdev->dev.device_status) 
 8003444:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 8003448:	2b02      	cmp	r3, #2
 800344a:	d0f3      	beq.n	8003434 <USBD_StdEPReq+0x34>
 800344c:	2b03      	cmp	r3, #3
 800344e:	d1e9      	bne.n	8003424 <USBD_StdEPReq+0x24>
        DCD_EP_Stall(pdev , ep_addr);
      }
      break;	
      
    case USB_OTG_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 8003450:	884b      	ldrh	r3, [r1, #2]
 8003452:	b92b      	cbnz	r3, 8003460 <USBD_StdEPReq+0x60>
      {
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8003454:	b122      	cbz	r2, 8003460 <USBD_StdEPReq+0x60>
 8003456:	2a80      	cmp	r2, #128	; 0x80
 8003458:	d002      	beq.n	8003460 <USBD_StdEPReq+0x60>
        { 
          DCD_EP_Stall(pdev , ep_addr);
 800345a:	4611      	mov	r1, r2
 800345c:	f7ff fad4 	bl	8002a08 <DCD_EP_Stall>
          
        }
      }
      pdev->dev.class_cb->Setup (pdev, req);   
 8003460:	f8d5 15e0 	ldr.w	r1, [r5, #1504]	; 0x5e0
 8003464:	4628      	mov	r0, r5
 8003466:	688a      	ldr	r2, [r1, #8]
 8003468:	4621      	mov	r1, r4
 800346a:	4790      	blx	r2
      USBD_CtlSendStatus(pdev);
 800346c:	4628      	mov	r0, r5
 800346e:	f7ff ff61 	bl	8003334 <USBD_CtlSendStatus>
      
      break;
 8003472:	e7cf      	b.n	8003414 <USBD_StdEPReq+0x14>
    }
    break;
    
  case USB_REQ_CLEAR_FEATURE :
    
    switch (pdev->dev.device_status) 
 8003474:	2b03      	cmp	r3, #3
 8003476:	d1d5      	bne.n	8003424 <USBD_StdEPReq+0x24>
        DCD_EP_Stall(pdev , ep_addr);
      }
      break;	
      
    case USB_OTG_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 8003478:	884b      	ldrh	r3, [r1, #2]
 800347a:	2b00      	cmp	r3, #0
 800347c:	d1ca      	bne.n	8003414 <USBD_StdEPReq+0x14>
      {
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 800347e:	b152      	cbz	r2, 8003496 <USBD_StdEPReq+0x96>
 8003480:	2a80      	cmp	r2, #128	; 0x80
 8003482:	d008      	beq.n	8003496 <USBD_StdEPReq+0x96>
        {        
          DCD_EP_ClrStall(pdev , ep_addr);
 8003484:	4611      	mov	r1, r2
 8003486:	f7ff fadf 	bl	8002a48 <DCD_EP_ClrStall>
          pdev->dev.class_cb->Setup (pdev, req);
 800348a:	f8d5 15e0 	ldr.w	r1, [r5, #1504]	; 0x5e0
 800348e:	4628      	mov	r0, r5
 8003490:	688a      	ldr	r2, [r1, #8]
 8003492:	4621      	mov	r1, r4
 8003494:	4790      	blx	r2
        }
        USBD_CtlSendStatus(pdev);
 8003496:	4628      	mov	r0, r5
 8003498:	f7ff ff4c 	bl	8003334 <USBD_CtlSendStatus>
 800349c:	e7ba      	b.n	8003414 <USBD_StdEPReq+0x14>
      break;	
      
    case USB_OTG_CONFIGURED:         
      
      
      if ((ep_addr & 0x80)== 0x80)
 800349e:	f012 0f80 	tst.w	r2, #128	; 0x80
 80034a2:	d10e      	bne.n	80034c2 <USBD_StdEPReq+0xc2>
          USBD_ep_status = 0x0000;  
        }
      }
      else if ((ep_addr & 0x80)== 0x00)
      {
        if(pdev->dev.out_ep[ep_addr].is_stall)
 80034a4:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80034a8:	eb00 03c2 	add.w	r3, r0, r2, lsl #3
 80034ac:	f893 3372 	ldrb.w	r3, [r3, #882]	; 0x372
 80034b0:	b98b      	cbnz	r3, 80034d6 <USBD_StdEPReq+0xd6>
          USBD_ep_status = 0x0001;     
        }
        
        else 
        {
          USBD_ep_status = 0x0000;     
 80034b2:	4a0b      	ldr	r2, [pc, #44]	; (80034e0 <USBD_StdEPReq+0xe0>)
 80034b4:	6013      	str	r3, [r2, #0]
        }      
      }
      USBD_CtlSendData (pdev,
 80034b6:	4628      	mov	r0, r5
 80034b8:	4909      	ldr	r1, [pc, #36]	; (80034e0 <USBD_StdEPReq+0xe0>)
 80034ba:	2202      	movs	r2, #2
 80034bc:	f7ff ff06 	bl	80032cc <USBD_CtlSendData>
                        (uint8_t *)&USBD_ep_status,
                        2);
      break;
 80034c0:	e7a8      	b.n	8003414 <USBD_StdEPReq+0x14>
    case USB_OTG_CONFIGURED:         
      
      
      if ((ep_addr & 0x80)== 0x80)
      {
        if(pdev->dev.in_ep[ep_addr & 0x7F].is_stall)
 80034c2:	f002 0e7f 	and.w	lr, r2, #127	; 0x7f
 80034c6:	eb0e 0c8e 	add.w	ip, lr, lr, lsl #2
 80034ca:	eb00 00cc 	add.w	r0, r0, ip, lsl #3
 80034ce:	f890 311a 	ldrb.w	r3, [r0, #282]	; 0x11a
 80034d2:	2b00      	cmp	r3, #0
 80034d4:	d0ed      	beq.n	80034b2 <USBD_StdEPReq+0xb2>
      }
      else if ((ep_addr & 0x80)== 0x00)
      {
        if(pdev->dev.out_ep[ep_addr].is_stall)
        {
          USBD_ep_status = 0x0001;     
 80034d6:	4802      	ldr	r0, [pc, #8]	; (80034e0 <USBD_StdEPReq+0xe0>)
 80034d8:	2101      	movs	r1, #1
 80034da:	6001      	str	r1, [r0, #0]
 80034dc:	e7eb      	b.n	80034b6 <USBD_StdEPReq+0xb6>
 80034de:	bf00      	nop
 80034e0:	2000080c 	.word	0x2000080c

080034e4 <USBD_StdItfReq>:
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdItfReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 80034e4:	b538      	push	{r3, r4, r5, lr}
  USBD_Status ret = USBD_OK; 
  
  switch (pdev->dev.device_status) 
 80034e6:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 80034ea:	2b03      	cmp	r3, #3
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdItfReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 80034ec:	4604      	mov	r4, r0
 80034ee:	460d      	mov	r5, r1
  USBD_Status ret = USBD_OK; 
  
  switch (pdev->dev.device_status) 
 80034f0:	d003      	beq.n	80034fa <USBD_StdItfReq+0x16>
       USBD_CtlError(pdev , req);
    }
    break;
    
  default:
     USBD_CtlError(pdev , req);
 80034f2:	f7ff ff71 	bl	80033d8 <USBD_CtlError>
    break;
  }
  return ret;
}
 80034f6:	2000      	movs	r0, #0
 80034f8:	bd38      	pop	{r3, r4, r5, pc}
  
  switch (pdev->dev.device_status) 
  {
  case USB_OTG_CONFIGURED:
    
    if (LOBYTE(req->wIndex) <= USBD_ITF_MAX_NUM) 
 80034fa:	790a      	ldrb	r2, [r1, #4]
 80034fc:	2a01      	cmp	r2, #1
 80034fe:	d8f8      	bhi.n	80034f2 <USBD_StdItfReq+0xe>
    {
      pdev->dev.class_cb->Setup (pdev, req); 
 8003500:	f8d0 25e0 	ldr.w	r2, [r0, #1504]	; 0x5e0
 8003504:	6893      	ldr	r3, [r2, #8]
 8003506:	4798      	blx	r3
      
      if((req->wLength == 0)&& (ret == USBD_OK))
 8003508:	88e8      	ldrh	r0, [r5, #6]
 800350a:	2800      	cmp	r0, #0
 800350c:	d1f3      	bne.n	80034f6 <USBD_StdItfReq+0x12>
      {
         USBD_CtlSendStatus(pdev);
 800350e:	4620      	mov	r0, r4
 8003510:	f7ff ff10 	bl	8003334 <USBD_CtlSendStatus>
 8003514:	e7ef      	b.n	80034f6 <USBD_StdItfReq+0x12>
 8003516:	bf00      	nop

08003518 <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdDevReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 8003518:	b570      	push	{r4, r5, r6, lr}
  USBD_Status ret = USBD_OK;  
  
  switch (req->bRequest) 
 800351a:	784b      	ldrb	r3, [r1, #1]
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdDevReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 800351c:	b082      	sub	sp, #8
 800351e:	460c      	mov	r4, r1
 8003520:	4605      	mov	r5, r0
  USBD_Status ret = USBD_OK;  
  
  switch (req->bRequest) 
 8003522:	2b09      	cmp	r3, #9
 8003524:	d813      	bhi.n	800354e <USBD_StdDevReq+0x36>
 8003526:	e8df f003 	tbb	[pc, r3]
 800352a:	2a18      	.short	0x2a18
 800352c:	57124012 	.word	0x57124012
 8003530:	058b1274 	.word	0x058b1274
                           USB_SETUP_REQ *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 8003534:	78a1      	ldrb	r1, [r4, #2]
 8003536:	4e9b      	ldr	r6, [pc, #620]	; (80037a4 <USBD_StdDevReq+0x28c>)
  
  if (cfgidx > USBD_CFG_MAX_NUM ) 
 8003538:	2901      	cmp	r1, #1
                           USB_SETUP_REQ *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 800353a:	7131      	strb	r1, [r6, #4]
  
  if (cfgidx > USBD_CFG_MAX_NUM ) 
 800353c:	d807      	bhi.n	800354e <USBD_StdDevReq+0x36>
  {            
     USBD_CtlError(pdev , req);                              
  } 
  else 
  {
    switch (pdev->dev.device_status) 
 800353e:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 8003542:	2b02      	cmp	r3, #2
 8003544:	f000 813f 	beq.w	80037c6 <USBD_StdDevReq+0x2ae>
 8003548:	2b03      	cmp	r3, #3
 800354a:	f000 80cd 	beq.w	80036e8 <USBD_StdDevReq+0x1d0>
  case USB_REQ_CLEAR_FEATURE:                                   
    USBD_ClrFeature (pdev , req);
    break;
    
  default:  
    USBD_CtlError(pdev , req);
 800354e:	4621      	mov	r1, r4
 8003550:	f7ff ff42 	bl	80033d8 <USBD_CtlError>
    break;
  }
  
  return ret;
}
 8003554:	2000      	movs	r0, #0
 8003556:	b002      	add	sp, #8
 8003558:	bd70      	pop	{r4, r5, r6, pc}
*/
static void USBD_GetStatus(USB_OTG_CORE_HANDLE  *pdev, 
                           USB_SETUP_REQ *req)
{
  
  switch (pdev->dev.device_status) 
 800355a:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 800355e:	1e99      	subs	r1, r3, #2
 8003560:	2901      	cmp	r1, #1
 8003562:	d8f4      	bhi.n	800354e <USBD_StdDevReq+0x36>
  {
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    
    if (pdev->dev.DevRemoteWakeup) 
 8003564:	f8d0 0114 	ldr.w	r0, [r0, #276]	; 0x114
 8003568:	2800      	cmp	r0, #0
 800356a:	d17e      	bne.n	800366a <USBD_StdDevReq+0x152>
    {
      USBD_cfg_status = USB_CONFIG_SELF_POWERED | USB_CONFIG_REMOTE_WAKEUP;                                
    }
    else
    {
      USBD_cfg_status = USB_CONFIG_SELF_POWERED;   
 800356c:	4b8d      	ldr	r3, [pc, #564]	; (80037a4 <USBD_StdDevReq+0x28c>)
 800356e:	2001      	movs	r0, #1
 8003570:	60d8      	str	r0, [r3, #12]
    }
    
    USBD_CtlSendData (pdev, 
 8003572:	4628      	mov	r0, r5
 8003574:	498c      	ldr	r1, [pc, #560]	; (80037a8 <USBD_StdDevReq+0x290>)
 8003576:	2201      	movs	r2, #1
 8003578:	f7ff fea8 	bl	80032cc <USBD_CtlSendData>
 800357c:	e7ea      	b.n	8003554 <USBD_StdDevReq+0x3c>
* @retval status
*/
static void USBD_ClrFeature(USB_OTG_CORE_HANDLE  *pdev, 
                            USB_SETUP_REQ *req)
{
  switch (pdev->dev.device_status)
 800357e:	f890 2112 	ldrb.w	r2, [r0, #274]	; 0x112
 8003582:	1e91      	subs	r1, r2, #2
 8003584:	2901      	cmp	r1, #1
 8003586:	d8e2      	bhi.n	800354e <USBD_StdDevReq+0x36>
  {
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 8003588:	f8b4 c002 	ldrh.w	ip, [r4, #2]
 800358c:	f1bc 0f01 	cmp.w	ip, #1
 8003590:	d1e0      	bne.n	8003554 <USBD_StdDevReq+0x3c>
    {
      pdev->dev.DevRemoteWakeup = 0; 
      pdev->dev.class_cb->Setup (pdev, req);   
 8003592:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
  {
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
    {
      pdev->dev.DevRemoteWakeup = 0; 
 8003596:	2200      	movs	r2, #0
      pdev->dev.class_cb->Setup (pdev, req);   
 8003598:	688b      	ldr	r3, [r1, #8]
  {
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
    {
      pdev->dev.DevRemoteWakeup = 0; 
 800359a:	f8c0 2114 	str.w	r2, [r0, #276]	; 0x114
      pdev->dev.class_cb->Setup (pdev, req);   
 800359e:	4621      	mov	r1, r4
 80035a0:	4798      	blx	r3
      USBD_CtlSendStatus(pdev);
 80035a2:	4628      	mov	r0, r5
 80035a4:	f7ff fec6 	bl	8003334 <USBD_CtlSendStatus>
 80035a8:	e7d4      	b.n	8003554 <USBD_StdDevReq+0x3c>
{

  USB_OTG_DCTL_TypeDef     dctl;
  uint8_t test_mode = 0;
 
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 80035aa:	8863      	ldrh	r3, [r4, #2]
 80035ac:	2b01      	cmp	r3, #1
 80035ae:	f000 811c 	beq.w	80037ea <USBD_StdDevReq+0x2d2>
    pdev->dev.DevRemoteWakeup = 1;  
    pdev->dev.class_cb->Setup (pdev, req);   
    USBD_CtlSendStatus(pdev);
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
 80035b2:	2b02      	cmp	r3, #2
 80035b4:	d1ce      	bne.n	8003554 <USBD_StdDevReq+0x3c>
           ((req->wIndex & 0xFF) == 0))
 80035b6:	88a3      	ldrh	r3, [r4, #4]
    pdev->dev.DevRemoteWakeup = 1;  
    pdev->dev.class_cb->Setup (pdev, req);   
    USBD_CtlSendStatus(pdev);
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
 80035b8:	f013 0fff 	tst.w	r3, #255	; 0xff
 80035bc:	d1ca      	bne.n	8003554 <USBD_StdDevReq+0x3c>
           ((req->wIndex & 0xFF) == 0))
  {
    dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 80035be:	6901      	ldr	r1, [r0, #16]
    
    test_mode = req->wIndex >> 8;
    switch (test_mode) 
 80035c0:	0a1c      	lsrs	r4, r3, #8
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
           ((req->wIndex & 0xFF) == 0))
  {
    dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 80035c2:	684a      	ldr	r2, [r1, #4]
    
    test_mode = req->wIndex >> 8;
    switch (test_mode) 
 80035c4:	1e63      	subs	r3, r4, #1
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
           ((req->wIndex & 0xFF) == 0))
  {
    dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 80035c6:	4610      	mov	r0, r2
    
    test_mode = req->wIndex >> 8;
    switch (test_mode) 
 80035c8:	2b04      	cmp	r3, #4
 80035ca:	f200 80a4 	bhi.w	8003716 <USBD_StdDevReq+0x1fe>
 80035ce:	e8df f003 	tbb	[pc, r3]
 80035d2:	b1a7      	.short	0xb1a7
 80035d4:	b6ac      	.short	0xb6ac
 80035d6:	9e          	.byte	0x9e
 80035d7:	00          	.byte	0x00
static void USBD_SetAddress(USB_OTG_CORE_HANDLE  *pdev, 
                            USB_SETUP_REQ *req)
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 80035d8:	88a3      	ldrh	r3, [r4, #4]
 80035da:	2b00      	cmp	r3, #0
 80035dc:	d140      	bne.n	8003660 <USBD_StdDevReq+0x148>
 80035de:	88e2      	ldrh	r2, [r4, #6]
 80035e0:	2a00      	cmp	r2, #0
 80035e2:	d13d      	bne.n	8003660 <USBD_StdDevReq+0x148>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    
    if (pdev->dev.device_status == USB_OTG_CONFIGURED) 
 80035e4:	f890 e112 	ldrb.w	lr, [r0, #274]	; 0x112
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 80035e8:	8862      	ldrh	r2, [r4, #2]
    
    if (pdev->dev.device_status == USB_OTG_CONFIGURED) 
 80035ea:	f1be 0f03 	cmp.w	lr, #3
 80035ee:	d0ae      	beq.n	800354e <USBD_StdDevReq+0x36>
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 80035f0:	f002 047f 	and.w	r4, r2, #127	; 0x7f
    {
      USBD_CtlError(pdev , req);
    } 
    else 
    {
      pdev->dev.device_address = dev_addr;
 80035f4:	f880 4113 	strb.w	r4, [r0, #275]	; 0x113
      DCD_EP_SetAddress(pdev, dev_addr);               
 80035f8:	4621      	mov	r1, r4
 80035fa:	f7ff fa53 	bl	8002aa4 <DCD_EP_SetAddress>
      USBD_CtlSendStatus(pdev);                         
 80035fe:	4628      	mov	r0, r5
 8003600:	f7ff fe98 	bl	8003334 <USBD_CtlSendStatus>
      
      if (dev_addr != 0) 
 8003604:	2c00      	cmp	r4, #0
 8003606:	f000 80ec 	beq.w	80037e2 <USBD_StdDevReq+0x2ca>
      {
        pdev->dev.device_status  = USB_OTG_ADDRESSED;
 800360a:	2002      	movs	r0, #2
 800360c:	f885 0112 	strb.w	r0, [r5, #274]	; 0x112
 8003610:	e7a0      	b.n	8003554 <USBD_StdDevReq+0x3c>
                               USB_SETUP_REQ *req)
{
  uint16_t len;
  uint8_t *pbuf;
  
  switch (req->wValue >> 8)
 8003612:	8862      	ldrh	r2, [r4, #2]
 8003614:	0a11      	lsrs	r1, r2, #8
 8003616:	1e4b      	subs	r3, r1, #1
 8003618:	2b06      	cmp	r3, #6
 800361a:	d898      	bhi.n	800354e <USBD_StdDevReq+0x36>
 800361c:	a101      	add	r1, pc, #4	; (adr r1, 8003624 <USBD_StdDevReq+0x10c>)
 800361e:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8003622:	bf00      	nop
 8003624:	080036c7 	.word	0x080036c7
 8003628:	08003689 	.word	0x08003689
 800362c:	08003673 	.word	0x08003673
 8003630:	0800354f 	.word	0x0800354f
 8003634:	0800354f 	.word	0x0800354f
 8003638:	0800354f 	.word	0x0800354f
 800363c:	0800354f 	.word	0x0800354f
*/
static void USBD_GetConfig(USB_OTG_CORE_HANDLE  *pdev, 
                           USB_SETUP_REQ *req)
{
 
  if (req->wLength != 1) 
 8003640:	88e2      	ldrh	r2, [r4, #6]
 8003642:	2a01      	cmp	r2, #1
 8003644:	d183      	bne.n	800354e <USBD_StdDevReq+0x36>
  {                   
     USBD_CtlError(pdev , req);
  }
  else 
  {
    switch (pdev->dev.device_status )  
 8003646:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 800364a:	2b02      	cmp	r3, #2
 800364c:	f000 80b7 	beq.w	80037be <USBD_StdDevReq+0x2a6>
 8003650:	2b03      	cmp	r3, #3
 8003652:	f47f af7c 	bne.w	800354e <USBD_StdDevReq+0x36>
                        1);
      break;
      
    case USB_OTG_CONFIGURED:                   
      
      USBD_CtlSendData (pdev, 
 8003656:	f500 7188 	add.w	r1, r0, #272	; 0x110
 800365a:	f7ff fe37 	bl	80032cc <USBD_CtlSendData>
 800365e:	e779      	b.n	8003554 <USBD_StdDevReq+0x3c>
      }
    }
  } 
  else 
  {
     USBD_CtlError(pdev , req);                        
 8003660:	4628      	mov	r0, r5
 8003662:	4621      	mov	r1, r4
 8003664:	f7ff feb8 	bl	80033d8 <USBD_CtlError>
 8003668:	e774      	b.n	8003554 <USBD_StdDevReq+0x3c>
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    
    if (pdev->dev.DevRemoteWakeup) 
    {
      USBD_cfg_status = USB_CONFIG_SELF_POWERED | USB_CONFIG_REMOTE_WAKEUP;                                
 800366a:	494e      	ldr	r1, [pc, #312]	; (80037a4 <USBD_StdDevReq+0x28c>)
 800366c:	2203      	movs	r2, #3
 800366e:	60ca      	str	r2, [r1, #12]
 8003670:	e77f      	b.n	8003572 <USBD_StdDevReq+0x5a>
    pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    pdev->dev.pConfig_descriptor = pbuf;    
    break;
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
 8003672:	fa5f fc82 	uxtb.w	ip, r2
 8003676:	f1bc 0f05 	cmp.w	ip, #5
 800367a:	f63f af68 	bhi.w	800354e <USBD_StdDevReq+0x36>
 800367e:	e8df f00c 	tbb	[pc, ip]
 8003682:	8795      	.short	0x8795
 8003684:	636c757e 	.word	0x636c757e
      len = 8;
    }
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetConfigDescriptor(pdev->cfg.speed, &len);
 8003688:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
 800368c:	7880      	ldrb	r0, [r0, #2]
 800368e:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8003690:	f10d 0106 	add.w	r1, sp, #6
 8003694:	4798      	blx	r3
       (pdev->cfg.phy_itface  == USB_OTG_ULPI_PHY))
    {
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetOtherConfigDescriptor(pdev->cfg.speed, &len);
    }
#endif  
    pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8003696:	2202      	movs	r2, #2
 8003698:	7042      	strb	r2, [r0, #1]
      len = 8;
    }
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetConfigDescriptor(pdev->cfg.speed, &len);
 800369a:	4601      	mov	r1, r0
    {
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetOtherConfigDescriptor(pdev->cfg.speed, &len);
    }
#endif  
    pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    pdev->dev.pConfig_descriptor = pbuf;    
 800369c:	f8c5 05ec 	str.w	r0, [r5, #1516]	; 0x5ec
  default: 
     USBD_CtlError(pdev , req);
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
 80036a0:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80036a4:	2b00      	cmp	r3, #0
 80036a6:	f43f af55 	beq.w	8003554 <USBD_StdDevReq+0x3c>
 80036aa:	88e2      	ldrh	r2, [r4, #6]
 80036ac:	2a00      	cmp	r2, #0
 80036ae:	f43f af51 	beq.w	8003554 <USBD_StdDevReq+0x3c>
  {
    
    len = MIN(len , req->wLength);
 80036b2:	429a      	cmp	r2, r3
 80036b4:	bf38      	it	cc
 80036b6:	4613      	movcc	r3, r2
    
    USBD_CtlSendData (pdev, 
 80036b8:	4628      	mov	r0, r5
 80036ba:	461a      	mov	r2, r3
  }
  
  if((len != 0)&& (req->wLength != 0))
  {
    
    len = MIN(len , req->wLength);
 80036bc:	f8ad 3006 	strh.w	r3, [sp, #6]
    
    USBD_CtlSendData (pdev, 
 80036c0:	f7ff fe04 	bl	80032cc <USBD_CtlSendData>
 80036c4:	e746      	b.n	8003554 <USBD_StdDevReq+0x3c>
  uint8_t *pbuf;
  
  switch (req->wValue >> 8)
  {
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->dev.usr_device->GetDeviceDescriptor(pdev->cfg.speed, &len);
 80036c6:	f8d0 35e8 	ldr.w	r3, [r0, #1512]	; 0x5e8
 80036ca:	7880      	ldrb	r0, [r0, #2]
 80036cc:	681a      	ldr	r2, [r3, #0]
 80036ce:	f10d 0106 	add.w	r1, sp, #6
 80036d2:	4790      	blx	r2
    if ((req->wLength == 64) ||( pdev->dev.device_status == USB_OTG_DEFAULT))  
 80036d4:	88e2      	ldrh	r2, [r4, #6]
 80036d6:	2a40      	cmp	r2, #64	; 0x40
  uint8_t *pbuf;
  
  switch (req->wValue >> 8)
  {
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->dev.usr_device->GetDeviceDescriptor(pdev->cfg.speed, &len);
 80036d8:	4601      	mov	r1, r0
    if ((req->wLength == 64) ||( pdev->dev.device_status == USB_OTG_DEFAULT))  
 80036da:	d003      	beq.n	80036e4 <USBD_StdDevReq+0x1cc>
 80036dc:	f895 0112 	ldrb.w	r0, [r5, #274]	; 0x112
 80036e0:	2801      	cmp	r0, #1
 80036e2:	d1dd      	bne.n	80036a0 <USBD_StdDevReq+0x188>
  default: 
     USBD_CtlError(pdev , req);
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
 80036e4:	2308      	movs	r3, #8
 80036e6:	e7e1      	b.n	80036ac <USBD_StdDevReq+0x194>
         USBD_CtlSendStatus(pdev);
      }
      break;
      
    case USB_OTG_CONFIGURED:
      if (cfgidx == 0) 
 80036e8:	2900      	cmp	r1, #0
 80036ea:	f000 8089 	beq.w	8003800 <USBD_StdDevReq+0x2e8>
        pdev->dev.device_config = cfgidx;          
        USBD_ClrCfg(pdev , cfgidx);
        USBD_CtlSendStatus(pdev);
        
      } 
      else  if (cfgidx != pdev->dev.device_config) 
 80036ee:	f890 1110 	ldrb.w	r1, [r0, #272]	; 0x110
 80036f2:	2901      	cmp	r1, #1
 80036f4:	d008      	beq.n	8003708 <USBD_StdDevReq+0x1f0>
      {
        /* Clear old configuration */
        USBD_ClrCfg(pdev , pdev->dev.device_config);
 80036f6:	f7ff fde1 	bl	80032bc <USBD_ClrCfg>
        
        /* set new configuration */
        pdev->dev.device_config = cfgidx;
 80036fa:	7931      	ldrb	r1, [r6, #4]
        USBD_SetCfg(pdev , cfgidx);
 80036fc:	4628      	mov	r0, r5
      {
        /* Clear old configuration */
        USBD_ClrCfg(pdev , pdev->dev.device_config);
        
        /* set new configuration */
        pdev->dev.device_config = cfgidx;
 80036fe:	f885 1110 	strb.w	r1, [r5, #272]	; 0x110
        USBD_SetCfg(pdev , cfgidx);
 8003702:	f7ff fdcf 	bl	80032a4 <USBD_SetCfg>
        USBD_CtlSendStatus(pdev);
 8003706:	4628      	mov	r0, r5
 8003708:	f7ff fe14 	bl	8003334 <USBD_CtlSendStatus>
 800370c:	e722      	b.n	8003554 <USBD_StdDevReq+0x3c>
    case 4: // TEST_PACKET
      dctl.b.tstctl = 4;
      break;
      
    case 5: // TEST_FORCE_ENABLE
      dctl.b.tstctl = 5;
 800370e:	2305      	movs	r3, #5
 8003710:	f363 1006 	bfi	r0, r3, #4, #3
 8003714:	4602      	mov	r2, r0
      break;
    }
    USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
 8003716:	604a      	str	r2, [r1, #4]
    USBD_CtlSendStatus(pdev);
 8003718:	4628      	mov	r0, r5
 800371a:	f7ff fe0b 	bl	8003334 <USBD_CtlSendStatus>
 800371e:	e719      	b.n	8003554 <USBD_StdDevReq+0x3c>
    
    test_mode = req->wIndex >> 8;
    switch (test_mode) 
    {
    case 1: // TEST_J
      dctl.b.tstctl = 1;
 8003720:	2201      	movs	r2, #1
 8003722:	f362 1006 	bfi	r0, r2, #4, #3
 8003726:	4602      	mov	r2, r0
 8003728:	e7f5      	b.n	8003716 <USBD_StdDevReq+0x1fe>
    case 2: // TEST_K	
      dctl.b.tstctl = 2;
      break;
      
    case 3: // TEST_SE0_NAK
      dctl.b.tstctl = 3;
 800372a:	2403      	movs	r4, #3
 800372c:	f364 1006 	bfi	r0, r4, #4, #3
 8003730:	4602      	mov	r2, r0
 8003732:	e7f0      	b.n	8003716 <USBD_StdDevReq+0x1fe>
    case 1: // TEST_J
      dctl.b.tstctl = 1;
      break;
      
    case 2: // TEST_K	
      dctl.b.tstctl = 2;
 8003734:	2302      	movs	r3, #2
 8003736:	f363 1006 	bfi	r0, r3, #4, #3
 800373a:	4602      	mov	r2, r0
 800373c:	e7eb      	b.n	8003716 <USBD_StdDevReq+0x1fe>
    case 3: // TEST_SE0_NAK
      dctl.b.tstctl = 3;
      break;
      
    case 4: // TEST_PACKET
      dctl.b.tstctl = 4;
 800373e:	2204      	movs	r2, #4
 8003740:	f362 1006 	bfi	r0, r2, #4, #3
 8003744:	4602      	mov	r2, r0
 8003746:	e7e6      	b.n	8003716 <USBD_StdDevReq+0x1fe>
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->dev.usr_device->GetConfigurationStrDescriptor(pdev->cfg.speed, &len);
      break;
      
    case USBD_IDX_INTERFACE_STR:
      pbuf = pdev->dev.usr_device->GetInterfaceStrDescriptor(pdev->cfg.speed, &len);
 8003748:	f8d0 15e8 	ldr.w	r1, [r0, #1512]	; 0x5e8
 800374c:	7880      	ldrb	r0, [r0, #2]
 800374e:	698a      	ldr	r2, [r1, #24]
 8003750:	f10d 0106 	add.w	r1, sp, #6
 8003754:	4790      	blx	r2
 8003756:	4601      	mov	r1, r0
 8003758:	e7a2      	b.n	80036a0 <USBD_StdDevReq+0x188>
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->dev.usr_device->GetSerialStrDescriptor(pdev->cfg.speed, &len);
      break;
      
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->dev.usr_device->GetConfigurationStrDescriptor(pdev->cfg.speed, &len);
 800375a:	f8d0 35e8 	ldr.w	r3, [r0, #1512]	; 0x5e8
 800375e:	7880      	ldrb	r0, [r0, #2]
 8003760:	695a      	ldr	r2, [r3, #20]
 8003762:	f10d 0106 	add.w	r1, sp, #6
 8003766:	4790      	blx	r2
 8003768:	4601      	mov	r1, r0
 800376a:	e799      	b.n	80036a0 <USBD_StdDevReq+0x188>
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->dev.usr_device->GetProductStrDescriptor(pdev->cfg.speed, &len);
      break;
      
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->dev.usr_device->GetSerialStrDescriptor(pdev->cfg.speed, &len);
 800376c:	f8d0 15e8 	ldr.w	r1, [r0, #1512]	; 0x5e8
 8003770:	7880      	ldrb	r0, [r0, #2]
 8003772:	690b      	ldr	r3, [r1, #16]
 8003774:	f10d 0106 	add.w	r1, sp, #6
 8003778:	4798      	blx	r3
 800377a:	4601      	mov	r1, r0
 800377c:	e790      	b.n	80036a0 <USBD_StdDevReq+0x188>
    case USBD_IDX_MFC_STR:
      pbuf = pdev->dev.usr_device->GetManufacturerStrDescriptor(pdev->cfg.speed, &len);
      break;
      
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->dev.usr_device->GetProductStrDescriptor(pdev->cfg.speed, &len);
 800377e:	f8d0 25e8 	ldr.w	r2, [r0, #1512]	; 0x5e8
 8003782:	7880      	ldrb	r0, [r0, #2]
 8003784:	68d3      	ldr	r3, [r2, #12]
 8003786:	f10d 0106 	add.w	r1, sp, #6
 800378a:	4798      	blx	r3
 800378c:	4601      	mov	r1, r0
 800378e:	e787      	b.n	80036a0 <USBD_StdDevReq+0x188>
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->dev.usr_device->GetLangIDStrDescriptor(pdev->cfg.speed, &len);        
      break;
      
    case USBD_IDX_MFC_STR:
      pbuf = pdev->dev.usr_device->GetManufacturerStrDescriptor(pdev->cfg.speed, &len);
 8003790:	f8d0 15e8 	ldr.w	r1, [r0, #1512]	; 0x5e8
 8003794:	7880      	ldrb	r0, [r0, #2]
 8003796:	688a      	ldr	r2, [r1, #8]
 8003798:	f10d 0106 	add.w	r1, sp, #6
 800379c:	4790      	blx	r2
 800379e:	4601      	mov	r1, r0
 80037a0:	e77e      	b.n	80036a0 <USBD_StdDevReq+0x188>
 80037a2:	bf00      	nop
 80037a4:	2000080c 	.word	0x2000080c
 80037a8:	20000818 	.word	0x20000818
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
    {
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->dev.usr_device->GetLangIDStrDescriptor(pdev->cfg.speed, &len);        
 80037ac:	f8d0 35e8 	ldr.w	r3, [r0, #1512]	; 0x5e8
 80037b0:	7880      	ldrb	r0, [r0, #2]
 80037b2:	685a      	ldr	r2, [r3, #4]
 80037b4:	f10d 0106 	add.w	r1, sp, #6
 80037b8:	4790      	blx	r2
 80037ba:	4601      	mov	r1, r0
 80037bc:	e770      	b.n	80036a0 <USBD_StdDevReq+0x188>
  {
    switch (pdev->dev.device_status )  
    {
    case USB_OTG_ADDRESSED:                     
      
      USBD_CtlSendData (pdev, 
 80037be:	4916      	ldr	r1, [pc, #88]	; (8003818 <USBD_StdDevReq+0x300>)
 80037c0:	f7ff fd84 	bl	80032cc <USBD_CtlSendData>
 80037c4:	e6c6      	b.n	8003554 <USBD_StdDevReq+0x3c>
  else 
  {
    switch (pdev->dev.device_status) 
    {
    case USB_OTG_ADDRESSED:
      if (cfgidx) 
 80037c6:	2900      	cmp	r1, #0
 80037c8:	d09e      	beq.n	8003708 <USBD_StdDevReq+0x1f0>
      {                                			   							   							   				
        pdev->dev.device_config = cfgidx;
 80037ca:	2101      	movs	r1, #1
        pdev->dev.device_status = USB_OTG_CONFIGURED;
 80037cc:	2303      	movs	r3, #3
    switch (pdev->dev.device_status) 
    {
    case USB_OTG_ADDRESSED:
      if (cfgidx) 
      {                                			   							   							   				
        pdev->dev.device_config = cfgidx;
 80037ce:	f880 1110 	strb.w	r1, [r0, #272]	; 0x110
        pdev->dev.device_status = USB_OTG_CONFIGURED;
 80037d2:	f880 3112 	strb.w	r3, [r0, #274]	; 0x112
        USBD_SetCfg(pdev , cfgidx);
 80037d6:	f7ff fd65 	bl	80032a4 <USBD_SetCfg>
        USBD_CtlSendStatus(pdev);
 80037da:	4628      	mov	r0, r5
 80037dc:	f7ff fdaa 	bl	8003334 <USBD_CtlSendStatus>
 80037e0:	e6b8      	b.n	8003554 <USBD_StdDevReq+0x3c>
      {
        pdev->dev.device_status  = USB_OTG_ADDRESSED;
      } 
      else 
      {
        pdev->dev.device_status  = USB_OTG_DEFAULT; 
 80037e2:	2101      	movs	r1, #1
 80037e4:	f885 1112 	strb.w	r1, [r5, #274]	; 0x112
 80037e8:	e6b4      	b.n	8003554 <USBD_StdDevReq+0x3c>
  uint8_t test_mode = 0;
 
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
  {
    pdev->dev.DevRemoteWakeup = 1;  
    pdev->dev.class_cb->Setup (pdev, req);   
 80037ea:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
  USB_OTG_DCTL_TypeDef     dctl;
  uint8_t test_mode = 0;
 
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
  {
    pdev->dev.DevRemoteWakeup = 1;  
 80037ee:	f8c0 3114 	str.w	r3, [r0, #276]	; 0x114
    pdev->dev.class_cb->Setup (pdev, req);   
 80037f2:	688a      	ldr	r2, [r1, #8]
 80037f4:	4621      	mov	r1, r4
 80037f6:	4790      	blx	r2
    USBD_CtlSendStatus(pdev);
 80037f8:	4628      	mov	r0, r5
        USBD_ClrCfg(pdev , pdev->dev.device_config);
        
        /* set new configuration */
        pdev->dev.device_config = cfgidx;
        USBD_SetCfg(pdev , cfgidx);
        USBD_CtlSendStatus(pdev);
 80037fa:	f7ff fd9b 	bl	8003334 <USBD_CtlSendStatus>
 80037fe:	e6a9      	b.n	8003554 <USBD_StdDevReq+0x3c>
      break;
      
    case USB_OTG_CONFIGURED:
      if (cfgidx == 0) 
      {                           
        pdev->dev.device_status = USB_OTG_ADDRESSED;
 8003800:	2202      	movs	r2, #2
 8003802:	f880 2112 	strb.w	r2, [r0, #274]	; 0x112
        pdev->dev.device_config = cfgidx;          
 8003806:	f880 1110 	strb.w	r1, [r0, #272]	; 0x110
        USBD_ClrCfg(pdev , cfgidx);
 800380a:	f7ff fd57 	bl	80032bc <USBD_ClrCfg>
        USBD_CtlSendStatus(pdev);
 800380e:	4628      	mov	r0, r5
 8003810:	f7ff fd90 	bl	8003334 <USBD_CtlSendStatus>
 8003814:	e69e      	b.n	8003554 <USBD_StdDevReq+0x3c>
 8003816:	bf00      	nop
 8003818:	20000814 	.word	0x20000814

0800381c <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 800381c:	b430      	push	{r4, r5}
  uint8_t idx = 0;
  
  if (desc != NULL) 
 800381e:	b1f8      	cbz	r0, 8003860 <USBD_GetString+0x44>
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != NULL) 
 8003820:	7803      	ldrb	r3, [r0, #0]
 8003822:	2b00      	cmp	r3, #0
 8003824:	d01e      	beq.n	8003864 <USBD_GetString+0x48>
 8003826:	4604      	mov	r4, r0
 8003828:	2300      	movs	r3, #0
 800382a:	f814 5f01 	ldrb.w	r5, [r4, #1]!
    {
        len++;
 800382e:	3301      	adds	r3, #1
 8003830:	b2db      	uxtb	r3, r3
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != NULL) 
 8003832:	2d00      	cmp	r5, #0
 8003834:	d1f9      	bne.n	800382a <USBD_GetString+0xe>
 8003836:	005c      	lsls	r4, r3, #1
 8003838:	1ca3      	adds	r3, r4, #2
 800383a:	b2dc      	uxtb	r4, r3
{
  uint8_t idx = 0;
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
 800383c:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 800383e:	2203      	movs	r2, #3
  uint8_t idx = 0;
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
 8003840:	700c      	strb	r4, [r1, #0]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 8003842:	704a      	strb	r2, [r1, #1]
    
    while (*desc != NULL) 
 8003844:	7802      	ldrb	r2, [r0, #0]
 8003846:	b15a      	cbz	r2, 8003860 <USBD_GetString+0x44>
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 8003848:	2302      	movs	r3, #2
    
    while (*desc != NULL) 
    {
      unicode[idx++] = *desc++;
      unicode[idx++] =  0x00;
 800384a:	2500      	movs	r5, #0
 800384c:	1c5c      	adds	r4, r3, #1
 800384e:	b2e4      	uxtb	r4, r4
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
    
    while (*desc != NULL) 
    {
      unicode[idx++] = *desc++;
 8003850:	54ca      	strb	r2, [r1, r3]
      unicode[idx++] =  0x00;
 8003852:	550d      	strb	r5, [r1, r4]
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
    
    while (*desc != NULL) 
 8003854:	f810 2f01 	ldrb.w	r2, [r0, #1]!
    {
      unicode[idx++] = *desc++;
      unicode[idx++] =  0x00;
 8003858:	3302      	adds	r3, #2
 800385a:	b2db      	uxtb	r3, r3
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
    
    while (*desc != NULL) 
 800385c:	2a00      	cmp	r2, #0
 800385e:	d1f5      	bne.n	800384c <USBD_GetString+0x30>
    {
      unicode[idx++] = *desc++;
      unicode[idx++] =  0x00;
    }
  } 
}
 8003860:	bc30      	pop	{r4, r5}
 8003862:	4770      	bx	lr
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != NULL) 
 8003864:	2402      	movs	r4, #2
 8003866:	4623      	mov	r3, r4
 8003868:	e7e8      	b.n	800383c <USBD_GetString+0x20>
 800386a:	bf00      	nop

0800386c <USB_OTG_BSP_ConfigVBUS>:
#include "stm32f4xx_conf.h"


void USB_OTG_BSP_ConfigVBUS(USB_OTG_CORE_HANDLE *pdev) {

}
 800386c:	4770      	bx	lr

0800386e <USB_OTG_BSP_DriveVBUS>:

void USB_OTG_BSP_DriveVBUS(USB_OTG_CORE_HANDLE *pdev,uint8_t state) {

}
 800386e:	4770      	bx	lr

08003870 <USB_OTG_BSP_Init>:
* @param  None
* @retval None
*/

void USB_OTG_BSP_Init(USB_OTG_CORE_HANDLE *pdev)
{
 8003870:	b537      	push	{r0, r1, r2, r4, r5, lr}
#endif


 #ifdef USE_USB_OTG_FS

  RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOA , ENABLE);
 8003872:	2001      	movs	r0, #1
 8003874:	4601      	mov	r1, r0
 8003876:	f7fd fc93 	bl	80011a0 <RCC_AHB1PeriphClockCmd>

  /* Configure SOF VBUS ID DM DP Pins */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8  |
 800387a:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
 800387e:	9300      	str	r3, [sp, #0]
    GPIO_Pin_9  |
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8003880:	2302      	movs	r3, #2
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8  |
    GPIO_Pin_9  |
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8003882:	2503      	movs	r5, #3
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8003884:	f88d 3004 	strb.w	r3, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8003888:	4669      	mov	r1, sp
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800388a:	3b02      	subs	r3, #2
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800388c:	4820      	ldr	r0, [pc, #128]	; (8003910 <USB_OTG_BSP_Init+0xa0>)
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800388e:	f88d 3006 	strb.w	r3, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 8003892:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8  |
    GPIO_Pin_9  |
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8003896:	f88d 5005 	strb.w	r5, [sp, #5]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800389a:	f7fd fec1 	bl	8001620 <GPIO_Init>

  GPIO_PinAFConfig(GPIOA,GPIO_PinSource8,GPIO_AF_OTG1_FS) ;
 800389e:	2108      	movs	r1, #8
 80038a0:	220a      	movs	r2, #10
 80038a2:	481b      	ldr	r0, [pc, #108]	; (8003910 <USB_OTG_BSP_Init+0xa0>)
 80038a4:	f7fd ffb4 	bl	8001810 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_OTG1_FS) ;
 80038a8:	2109      	movs	r1, #9
 80038aa:	220a      	movs	r2, #10
 80038ac:	4818      	ldr	r0, [pc, #96]	; (8003910 <USB_OTG_BSP_Init+0xa0>)
 80038ae:	f7fd ffaf 	bl	8001810 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource11,GPIO_AF_OTG1_FS) ;
 80038b2:	210b      	movs	r1, #11
 80038b4:	220a      	movs	r2, #10
 80038b6:	4816      	ldr	r0, [pc, #88]	; (8003910 <USB_OTG_BSP_Init+0xa0>)
 80038b8:	f7fd ffaa 	bl	8001810 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;
 80038bc:	220a      	movs	r2, #10
 80038be:	210c      	movs	r1, #12
 80038c0:	4813      	ldr	r0, [pc, #76]	; (8003910 <USB_OTG_BSP_Init+0xa0>)
 80038c2:	f7fd ffa5 	bl	8001810 <GPIO_PinAFConfig>

  /* this for ID line debug */


  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 80038c6:	2401      	movs	r4, #1
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;

  /* this for ID line debug */


  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
 80038c8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 80038cc:	4669      	mov	r1, sp
 80038ce:	4810      	ldr	r0, [pc, #64]	; (8003910 <USB_OTG_BSP_Init+0xa0>)
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;

  /* this for ID line debug */


  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
 80038d0:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 80038d2:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
 80038d6:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 80038da:	f88d 5005 	strb.w	r5, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 80038de:	f7fd fe9f 	bl	8001620 <GPIO_Init>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_OTG1_FS) ;
 80038e2:	210a      	movs	r1, #10
 80038e4:	460a      	mov	r2, r1
 80038e6:	480a      	ldr	r0, [pc, #40]	; (8003910 <USB_OTG_BSP_Init+0xa0>)
 80038e8:	f7fd ff92 	bl	8001810 <GPIO_PinAFConfig>

  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 80038ec:	4621      	mov	r1, r4
 80038ee:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80038f2:	f7fd fc8d 	bl	8001210 <RCC_APB2PeriphClockCmd>
  RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_OTG_FS, ENABLE) ;
 80038f6:	2080      	movs	r0, #128	; 0x80
 80038f8:	4621      	mov	r1, r4
 80038fa:	f7fd fc5f 	bl	80011bc <RCC_AHB2PeriphClockCmd>

 #endif //USB_OTG_HS


  /* enable the PWR clock */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
 80038fe:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8003902:	4621      	mov	r1, r4
 8003904:	f7fd fcbc 	bl	8001280 <RCC_APB1PeriphResetCmd>
  NVIC_Init(&NVIC_InitStructure);

  EXTI_ClearITPendingBit(EXTI_Line20);
#endif

  EXTI_ClearITPendingBit(EXTI_Line0);
 8003908:	4620      	mov	r0, r4
 800390a:	f7fd fdf7 	bl	80014fc <EXTI_ClearITPendingBit>
}
 800390e:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8003910:	40020000 	.word	0x40020000

08003914 <USB_OTG_BSP_EnableInterrupt>:
*         Enabele USB Global interrupt
* @param  None
* @retval None
*/
void USB_OTG_BSP_EnableInterrupt(USB_OTG_CORE_HANDLE *pdev)
{
 8003914:	b507      	push	{r0, r1, r2, lr}
  NVIC_InitTypeDef NVIC_InitStructure;

  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
 8003916:	f44f 60c0 	mov.w	r0, #1536	; 0x600
 800391a:	f000 f81f 	bl	800395c <NVIC_PriorityGroupConfig>
#ifdef USE_USB_OTG_HS
  NVIC_InitStructure.NVIC_IRQChannel = OTG_HS_IRQn;
#else
  NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;
 800391e:	2343      	movs	r3, #67	; 0x43
 8003920:	f88d 3004 	strb.w	r3, [sp, #4]
#endif
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 11;
 8003924:	3b38      	subs	r3, #56	; 0x38
 8003926:	f88d 3005 	strb.w	r3, [sp, #5]
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
 800392a:	3b08      	subs	r3, #8
 800392c:	f88d 3006 	strb.w	r3, [sp, #6]
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
 8003930:	a801      	add	r0, sp, #4
#else
  NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;
#endif
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 11;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8003932:	3b02      	subs	r3, #2
 8003934:	f88d 3007 	strb.w	r3, [sp, #7]
  NVIC_Init(&NVIC_InitStructure);
 8003938:	f000 f81a 	bl	8003970 <NVIC_Init>
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 11;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
#endif
}
 800393c:	bd0e      	pop	{r1, r2, r3, pc}

0800393e <USB_OTG_BSP_uDelay>:
* @retval None
*/
void USB_OTG_BSP_uDelay (const uint32_t usec)
{
  uint32_t count = 0;
  const uint32_t utime = (120 * usec / 7);
 800393e:	2378      	movs	r3, #120	; 0x78
 8003940:	2207      	movs	r2, #7
 8003942:	4343      	muls	r3, r0
 8003944:	fbb3 f3f2 	udiv	r3, r3, r2
* @param  usec : Value of delay required in micro sec
* @retval None
*/
void USB_OTG_BSP_uDelay (const uint32_t usec)
{
  uint32_t count = 0;
 8003948:	3a07      	subs	r2, #7
  const uint32_t utime = (120 * usec / 7);
  do
  {
    if ( ++count > utime )
 800394a:	3201      	adds	r2, #1
 800394c:	429a      	cmp	r2, r3
 800394e:	d9fc      	bls.n	800394a <USB_OTG_BSP_uDelay+0xc>
    {
      return ;
    }
  }
  while (1);
}
 8003950:	4770      	bx	lr

08003952 <USB_OTG_BSP_mDelay>:
* @param  msec : Value of delay required in milli sec
* @retval None
*/
void USB_OTG_BSP_mDelay (const uint32_t msec)
{
  USB_OTG_BSP_uDelay(msec * 1000);
 8003952:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8003956:	4358      	muls	r0, r3
 8003958:	e7f1      	b.n	800393e <USB_OTG_BSP_uDelay>
 800395a:	bf00      	nop

0800395c <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 800395c:	f040 61be 	orr.w	r1, r0, #99614720	; 0x5f00000
 8003960:	4b02      	ldr	r3, [pc, #8]	; (800396c <NVIC_PriorityGroupConfig+0x10>)
 8003962:	f441 2020 	orr.w	r0, r1, #655360	; 0xa0000
 8003966:	60d8      	str	r0, [r3, #12]
}
 8003968:	4770      	bx	lr
 800396a:	bf00      	nop
 800396c:	e000ed00 	.word	0xe000ed00

08003970 <NVIC_Init>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8003970:	78c3      	ldrb	r3, [r0, #3]
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8003972:	b470      	push	{r4, r5, r6}
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8003974:	b963      	cbnz	r3, 8003990 <NVIC_Init+0x20>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003976:	7802      	ldrb	r2, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003978:	2101      	movs	r1, #1
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800397a:	0950      	lsrs	r0, r2, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800397c:	f002 031f 	and.w	r3, r2, #31
 8003980:	fa11 f203 	lsls.w	r2, r1, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003984:	3020      	adds	r0, #32
 8003986:	4916      	ldr	r1, [pc, #88]	; (80039e0 <NVIC_Init+0x70>)
 8003988:	f841 2020 	str.w	r2, [r1, r0, lsl #2]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 800398c:	bc70      	pop	{r4, r5, r6}
 800398e:	4770      	bx	lr
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003990:	4b14      	ldr	r3, [pc, #80]	; (80039e4 <NVIC_Init+0x74>)
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8003992:	7846      	ldrb	r6, [r0, #1]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003994:	68dc      	ldr	r4, [r3, #12]
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 8003996:	7885      	ldrb	r5, [r0, #2]
        
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003998:	7801      	ldrb	r1, [r0, #0]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 800399a:	43e2      	mvns	r2, r4
 800399c:	f3c2 2202 	ubfx	r2, r2, #8, #3
    tmppre = (0x4 - tmppriority);
 80039a0:	f1c2 0c04 	rsb	ip, r2, #4
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 80039a4:	fa5f f48c 	uxtb.w	r4, ip
 80039a8:	fa16 f404 	lsls.w	r4, r6, r4
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
 80039ac:	260f      	movs	r6, #15
 80039ae:	fa56 f202 	asrs.w	r2, r6, r2
    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
        
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 80039b2:	f5a3 6340 	sub.w	r3, r3, #3072	; 0xc00
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 80039b6:	ea02 0c05 	and.w	ip, r2, r5
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 80039ba:	b2e4      	uxtb	r4, r4
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 80039bc:	ea4c 0204 	orr.w	r2, ip, r4
        
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 80039c0:	eb01 0c03 	add.w	ip, r1, r3
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
        
    tmppriority = tmppriority << 0x04;
 80039c4:	0112      	lsls	r2, r2, #4
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 80039c6:	f88c 2300 	strb.w	r2, [ip, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80039ca:	7800      	ldrb	r0, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 80039cc:	2201      	movs	r2, #1
 80039ce:	f000 031f 	and.w	r3, r0, #31
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80039d2:	0941      	lsrs	r1, r0, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 80039d4:	fa12 f003 	lsls.w	r0, r2, r3
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80039d8:	4a01      	ldr	r2, [pc, #4]	; (80039e0 <NVIC_Init+0x70>)
 80039da:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
 80039de:	e7d5      	b.n	800398c <NVIC_Init+0x1c>
 80039e0:	e000e100 	.word	0xe000e100
 80039e4:	e000ed00 	.word	0xe000ed00

080039e8 <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 80039e8:	f021 4c60 	bic.w	ip, r1, #3758096384	; 0xe0000000
 80039ec:	f02c 027f 	bic.w	r2, ip, #127	; 0x7f
 80039f0:	4b02      	ldr	r3, [pc, #8]	; (80039fc <NVIC_SetVectorTable+0x14>)
 80039f2:	ea42 0100 	orr.w	r1, r2, r0
 80039f6:	6099      	str	r1, [r3, #8]
}
 80039f8:	4770      	bx	lr
 80039fa:	bf00      	nop
 80039fc:	e000ed00 	.word	0xe000ed00

08003a00 <NVIC_SystemLPConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 8003a00:	b929      	cbnz	r1, 8003a0e <NVIC_SystemLPConfig+0xe>
  {
    SCB->SCR |= LowPowerMode;
  }
  else
  {
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
 8003a02:	4b05      	ldr	r3, [pc, #20]	; (8003a18 <NVIC_SystemLPConfig+0x18>)
 8003a04:	691a      	ldr	r2, [r3, #16]
 8003a06:	ea22 0100 	bic.w	r1, r2, r0
 8003a0a:	6119      	str	r1, [r3, #16]
 8003a0c:	4770      	bx	lr
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    SCB->SCR |= LowPowerMode;
 8003a0e:	4b02      	ldr	r3, [pc, #8]	; (8003a18 <NVIC_SystemLPConfig+0x18>)
 8003a10:	691a      	ldr	r2, [r3, #16]
 8003a12:	4310      	orrs	r0, r2
 8003a14:	6118      	str	r0, [r3, #16]
 8003a16:	4770      	bx	lr
 8003a18:	e000ed00 	.word	0xe000ed00

08003a1c <SysTick_CLKSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8003a1c:	4b04      	ldr	r3, [pc, #16]	; (8003a30 <SysTick_CLKSourceConfig+0x14>)
 8003a1e:	681a      	ldr	r2, [r3, #0]
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 8003a20:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8003a22:	bf0c      	ite	eq
 8003a24:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8003a28:	f022 0204 	bicne.w	r2, r2, #4
 8003a2c:	601a      	str	r2, [r3, #0]
 8003a2e:	4770      	bx	lr
 8003a30:	e000e010 	.word	0xe000e010

08003a34 <DISCgpiopins_Config>:
{
/* ----------------------------- PORTA -------------------------------------- */
/* ----------------------------- PORTB -------------------------------------- */
/* ----------------------------- PORTC -------------------------------------- */
/* ----------------------------- PORTD -------------------------------------- */
	RCC_AHB1ENR |= (1<<3);	// Enable port D clocking (p 110, p 148)
 8003a34:	4b0d      	ldr	r3, [pc, #52]	; (8003a6c <DISCgpiopins_Config+0x38>)
 8003a36:	681a      	ldr	r2, [r3, #0]
 8003a38:	f042 0208 	orr.w	r2, r2, #8
 8003a3c:	601a      	str	r2, [r3, #0]

	/* PD12,13,14,15 are the green, orange, red, blue LEDs on the Discovery board */
	GPIOD_MODER    =   (GPIOD_MODER   & (~(0x00ff << 24))) | (0x0055 << 24);	// Mode = General purpose output
 8003a3e:	4b0c      	ldr	r3, [pc, #48]	; (8003a70 <DISCgpiopins_Config+0x3c>)
 8003a40:	681a      	ldr	r2, [r3, #0]
 8003a42:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8003a46:	f042 42aa 	orr.w	r2, r2, #1426063360	; 0x55000000
 8003a4a:	601a      	str	r2, [r3, #0]
	GPIOD_OTYPER   =   (GPIOD_OTYPER  & (~(0x000f << 12))) | (0x0000 << 12);	// Type output = push-pull
 8003a4c:	685a      	ldr	r2, [r3, #4]
 8003a4e:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
 8003a52:	605a      	str	r2, [r3, #4]
	GPIOD_OSPEEDR  =   (GPIOD_OSPEEDR & (~(0x00ff << 24))) | (0x00aa << 24);	// Pin speed = Speed 50 MHz
 8003a54:	689a      	ldr	r2, [r3, #8]
 8003a56:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8003a5a:	f042 422a 	orr.w	r2, r2, #2852126720	; 0xaa000000
 8003a5e:	609a      	str	r2, [r3, #8]
	GPIOD_PUPDR    =   (GPIOD_PUPDR   & (~(0x00ff << 24))) | (0x0000 << 24);	// Pull up/down = none.
 8003a60:	68da      	ldr	r2, [r3, #12]
 8003a62:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8003a66:	60da      	str	r2, [r3, #12]

	return;
}
 8003a68:	4770      	bx	lr
 8003a6a:	bf00      	nop
 8003a6c:	40023830 	.word	0x40023830
 8003a70:	40020c00 	.word	0x40020c00

08003a74 <DISCgpiopins_default>:
/* ----------------------------- PORTB -------------------------------------- */
/* ----------------------------- PORTC -------------------------------------- */
/* ----------------------------- PORTD -------------------------------------- */
/* ----------------------------- PORTE -------------------------------------- */
	return;
}
 8003a74:	4770      	bx	lr

08003a76 <f4gpiopins_Config>:
 * void f4gpiopins_Config(volatile u32 * p, u16 pinnumber, struct PINCONFIG * s  );
 * @param	: See comments on each in source code
 * @brief	: Configure one gpio pin 
 ******************************************************************************/
void f4gpiopins_Config(volatile u32 * p, u16 pinnumber, struct PINCONFIG * s)
{
 8003a76:	b5f0      	push	{r4, r5, r6, r7, lr}

	/* Make sure bus clocking is enabled so that gpio registers can be accessed (p 110) */
	u32 x = ((u32)p - (u32)GPIOA) >> 10;	// Shift count for enabling RCC_AHB1ENR
 8003a78:	f100 443f 	add.w	r4, r0, #3204448256	; 0xbf000000
 8003a7c:	f504 047e 	add.w	r4, r4, #16646144	; 0xfe0000
	RCC_AHB1ENR |= ((1 << x) & 0x01ff);	// Enable port clocking
 8003a80:	2601      	movs	r6, #1
 8003a82:	4d29      	ldr	r5, [pc, #164]	; (8003b28 <f4gpiopins_Config+0xb2>)
 ******************************************************************************/
void f4gpiopins_Config(volatile u32 * p, u16 pinnumber, struct PINCONFIG * s)
{

	/* Make sure bus clocking is enabled so that gpio registers can be accessed (p 110) */
	u32 x = ((u32)p - (u32)GPIOA) >> 10;	// Shift count for enabling RCC_AHB1ENR
 8003a84:	0aa3      	lsrs	r3, r4, #10
	RCC_AHB1ENR |= ((1 << x) & 0x01ff);	// Enable port clocking
 8003a86:	fa16 f303 	lsls.w	r3, r6, r3
 8003a8a:	682f      	ldr	r7, [r5, #0]
 8003a8c:	05db      	lsls	r3, r3, #23
 8003a8e:	0ddb      	lsrs	r3, r3, #23
 8003a90:	433b      	orrs	r3, r7
 8003a92:	602b      	str	r3, [r5, #0]
00: Input (reset state)
01: General purpose output mode
10: Alternate function mode
11: Analog mode
*/
	GPIO_MODER(p)  &= ~(0x03 << (pinnumber << 1));		// Reset old mode values
 8003a94:	fa11 f306 	lsls.w	r3, r1, r6
 8003a98:	2503      	movs	r5, #3
 8003a9a:	6804      	ldr	r4, [r0, #0]
 8003a9c:	409d      	lsls	r5, r3
 8003a9e:	43ed      	mvns	r5, r5
 8003aa0:	ea05 0404 	and.w	r4, r5, r4
 8003aa4:	6004      	str	r4, [r0, #0]
	GPIO_MODER(p)  |= ((s->mode & 0x03) << (pinnumber << 1));	// Add new values
 8003aa6:	7817      	ldrb	r7, [r2, #0]
 8003aa8:	6804      	ldr	r4, [r0, #0]
 8003aaa:	f007 0703 	and.w	r7, r7, #3
 8003aae:	409f      	lsls	r7, r3
 8003ab0:	4327      	orrs	r7, r4
 8003ab2:	4604      	mov	r4, r0
/* TYPE GPIO_OTYPER
These bits are written by software to configure the output type of the I/O port.
0: Output push-pull (reset state)
1: Output open-drain
*/
	GPIO_MODER(p+1) &= ~(0x01 << pinnumber);		// Reset old type bit
 8003ab4:	408e      	lsls	r6, r1
01: General purpose output mode
10: Alternate function mode
11: Analog mode
*/
	GPIO_MODER(p)  &= ~(0x03 << (pinnumber << 1));		// Reset old mode values
	GPIO_MODER(p)  |= ((s->mode & 0x03) << (pinnumber << 1));	// Add new values
 8003ab6:	f844 7b04 	str.w	r7, [r4], #4
/* TYPE GPIO_OTYPER
These bits are written by software to configure the output type of the I/O port.
0: Output push-pull (reset state)
1: Output open-drain
*/
	GPIO_MODER(p+1) &= ~(0x01 << pinnumber);		// Reset old type bit
 8003aba:	6847      	ldr	r7, [r0, #4]
 8003abc:	ea27 0606 	bic.w	r6, r7, r6
 8003ac0:	6046      	str	r6, [r0, #4]
	GPIO_MODER(p+1) |=  ((s->type & 0x01) << pinnumber);// Add new type bit
 8003ac2:	7856      	ldrb	r6, [r2, #1]
 8003ac4:	6847      	ldr	r7, [r0, #4]
 8003ac6:	f006 0601 	and.w	r6, r6, #1
 8003aca:	408e      	lsls	r6, r1
 8003acc:	433e      	orrs	r6, r7
 8003ace:	6046      	str	r6, [r0, #4]
01: 25 MHz Medium speed
10: 50 MHz Fast speed
11: 100 MHz High speed on 30 pF (80 MHz Output max speed on 15 pF)
*/

	GPIO_MODER(p+2) &= ~(0x03 << (pinnumber << 1));		// Reset old speed values
 8003ad0:	6886      	ldr	r6, [r0, #8]
 8003ad2:	ea05 0606 	and.w	r6, r5, r6
 8003ad6:	6086      	str	r6, [r0, #8]
	GPIO_MODER(p+2) |= ((s->speed & 0x03) << (pinnumber << 1));// Add new values
 8003ad8:	7896      	ldrb	r6, [r2, #2]
 8003ada:	6887      	ldr	r7, [r0, #8]
 8003adc:	f006 0603 	and.w	r6, r6, #3
 8003ae0:	409e      	lsls	r6, r3
 8003ae2:	433e      	orrs	r6, r7
 8003ae4:	6086      	str	r6, [r0, #8]
00: No pull-up, pull-down
01: Pull-up
10: Pull-down
11: Reserved
*/
	GPIO_MODER(p+3) &= ~(0x03 << (pinnumber << 1));		// Reset old pupdn values
 8003ae6:	68c6      	ldr	r6, [r0, #12]
 8003ae8:	4035      	ands	r5, r6
 8003aea:	60c5      	str	r5, [r0, #12]
	GPIO_MODER(p+3) |= ((s->pupdn & 0x03) << (pinnumber << 1));	// Add new values
 8003aec:	78d6      	ldrb	r6, [r2, #3]
 8003aee:	68c5      	ldr	r5, [r0, #12]
 8003af0:	f006 0603 	and.w	r6, r6, #3
 8003af4:	fa16 f303 	lsls.w	r3, r6, r3
 8003af8:	432b      	orrs	r3, r5
                                  1111: AF15
0111: AF7

GPIO_AFRL
*/
	if (pinnumber >= 8)
 8003afa:	2907      	cmp	r1, #7
01: Pull-up
10: Pull-down
11: Reserved
*/
	GPIO_MODER(p+3) &= ~(0x03 << (pinnumber << 1));		// Reset old pupdn values
	GPIO_MODER(p+3) |= ((s->pupdn & 0x03) << (pinnumber << 1));	// Add new values
 8003afc:	60c3      	str	r3, [r0, #12]
                                  1111: AF15
0111: AF7

GPIO_AFRL
*/
	if (pinnumber >= 8)
 8003afe:	d902      	bls.n	8003b06 <f4gpiopins_Config+0x90>
	{ // Here, the high register (pins 8 - 15) (p 152)
		pinnumber -= 8;		// adjust shift count 
 8003b00:	3908      	subs	r1, #8
 8003b02:	b289      	uxth	r1, r1
 8003b04:	4620      	mov	r0, r4
		p++;			// Point to high register
	}

	GPIO_MODER(p+8) &= ~(0x0f << (pinnumber << 2));			// Remove old AF settings
 8003b06:	6a04      	ldr	r4, [r0, #32]
 8003b08:	0089      	lsls	r1, r1, #2
 8003b0a:	230f      	movs	r3, #15
 8003b0c:	408b      	lsls	r3, r1
 8003b0e:	ea24 0303 	bic.w	r3, r4, r3
 8003b12:	6203      	str	r3, [r0, #32]
	GPIO_MODER(p+8) |=  ((s->afrl & 0x0f) << (pinnumber << 2));	// Add new settings
 8003b14:	7912      	ldrb	r2, [r2, #4]
 8003b16:	6a03      	ldr	r3, [r0, #32]
 8003b18:	f002 020f 	and.w	r2, r2, #15
 8003b1c:	fa12 f101 	lsls.w	r1, r2, r1
 8003b20:	4319      	orrs	r1, r3
 8003b22:	6201      	str	r1, [r0, #32]

	return;
}
 8003b24:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003b26:	bf00      	nop
 8003b28:	40023830 	.word	0x40023830

08003b2c <loop>:
{
	LEDSALL_off;
	return;
}	
static void loop(volatile int ct)
{
 8003b2c:	b082      	sub	sp, #8
 8003b2e:	9001      	str	r0, [sp, #4]
	while (ct > 0) ct -= 1; 
 8003b30:	e002      	b.n	8003b38 <loop+0xc>
 8003b32:	9b01      	ldr	r3, [sp, #4]
 8003b34:	3b01      	subs	r3, #1
 8003b36:	9301      	str	r3, [sp, #4]
 8003b38:	9b01      	ldr	r3, [sp, #4]
 8003b3a:	2b00      	cmp	r3, #0
 8003b3c:	dcf9      	bgt.n	8003b32 <loop+0x6>
	return;
}
 8003b3e:	b002      	add	sp, #8
 8003b40:	4770      	bx	lr

08003b42 <panic_leds>:
 * @brief	: Configure gpio pins for Discovery F4 board
 ******************************************************************************/
int PanicCount;

void panic_leds(unsigned int count)
{
 8003b42:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	unsigned int i;
	volatile int x;		// Loop ct for timing pause
	volatile int xon;	// Loop ct for timing LED on duration
	volatile int xoff;	// Loop ct for timing LED off duration
	int sw = 0;
PanicCount = count; // Usefull for debugging this
 8003b44:	4b1d      	ldr	r3, [pc, #116]	; (8003bbc <panic_leds+0x7a>)
	/* Have clocks been setup? */
	if (sysclk_freq < 1000000)
 8003b46:	4a1e      	ldr	r2, [pc, #120]	; (8003bc0 <panic_leds+0x7e>)
	unsigned int i;
	volatile int x;		// Loop ct for timing pause
	volatile int xon;	// Loop ct for timing LED on duration
	volatile int xoff;	// Loop ct for timing LED off duration
	int sw = 0;
PanicCount = count; // Usefull for debugging this
 8003b48:	6018      	str	r0, [r3, #0]
	/* Have clocks been setup? */
	if (sysclk_freq < 1000000)
 8003b4a:	4b1e      	ldr	r3, [pc, #120]	; (8003bc4 <panic_leds+0x82>)
 8003b4c:	6819      	ldr	r1, [r3, #0]
 8003b4e:	4291      	cmp	r1, r2
	{ // Here, no.  We are running on the 8 MHz HSI oscillator
		sysclk_freq = 8000000;	// Set default
 8003b50:	bf9c      	itt	ls
 8003b52:	4d1d      	ldrls	r5, [pc, #116]	; (8003bc8 <panic_leds+0x86>)
 8003b54:	601d      	strls	r5, [r3, #0]
		sw = 8000000;	// Not zero
	}

	/* Setup timing for pause */
	x = sysclk_freq/10;
 8003b56:	681b      	ldr	r3, [r3, #0]
{
	unsigned int i;
	volatile int x;		// Loop ct for timing pause
	volatile int xon;	// Loop ct for timing LED on duration
	volatile int xoff;	// Loop ct for timing LED off duration
	int sw = 0;
 8003b58:	bf88      	it	hi
 8003b5a:	2500      	movhi	r5, #0
		sysclk_freq = 8000000;	// Set default
		sw = 8000000;	// Not zero
	}

	/* Setup timing for pause */
	x = sysclk_freq/10;
 8003b5c:	220a      	movs	r2, #10
 8003b5e:	fbb3 f2f2 	udiv	r2, r3, r2
 8003b62:	9203      	str	r2, [sp, #12]

	/* Setup timing for fast flash */
	xon =  sysclk_freq/250;
 8003b64:	22fa      	movs	r2, #250	; 0xfa
 8003b66:	fbb3 f2f2 	udiv	r2, r3, r2
 8003b6a:	9202      	str	r2, [sp, #8]
	xoff = sysclk_freq/40;
 8003b6c:	2228      	movs	r2, #40	; 0x28
 8003b6e:	fbb3 f3f2 	udiv	r3, r3, r2
 8003b72:	9301      	str	r3, [sp, #4]

	/* Limit max count */
	if (count == 0) count = 6; // Bogus count

	/* Be sure we have the ports and pins setup for the LEDs */
	RCC_AHB1ENR |= 0x08;	// Enable IO port D
 8003b74:	4b15      	ldr	r3, [pc, #84]	; (8003bcc <panic_leds+0x8a>)
 8003b76:	681a      	ldr	r2, [r3, #0]
 8003b78:	f042 0208 	orr.w	r2, r2, #8
 * @brief	: Configure gpio pins for Discovery F4 board
 ******************************************************************************/
int PanicCount;

void panic_leds(unsigned int count)
{
 8003b7c:	4604      	mov	r4, r0

	/* Limit max count */
	if (count == 0) count = 6; // Bogus count

	/* Be sure we have the ports and pins setup for the LEDs */
	RCC_AHB1ENR |= 0x08;	// Enable IO port D
 8003b7e:	601a      	str	r2, [r3, #0]
	/* Setup timing for fast flash */
	xon =  sysclk_freq/250;
	xoff = sysclk_freq/40;

	/* Limit max count */
	if (count == 0) count = 6; // Bogus count
 8003b80:	2800      	cmp	r0, #0
 8003b82:	bf08      	it	eq
 8003b84:	2406      	moveq	r4, #6

	/* Be sure we have the ports and pins setup for the LEDs */
	RCC_AHB1ENR |= 0x08;	// Enable IO port D
	DISCgpiopins_Config();	// Configure pins
 8003b86:	f7ff ff55 	bl	8003a34 <DISCgpiopins_Config>

	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	if (sw == 0)
 8003b8a:	b175      	cbz	r5, 8003baa <panic_leds+0x68>
 8003b8c:	e014      	b.n	8003bb8 <panic_leds+0x76>
#include "libopencm3/stm32/f4/rcc.h"

extern unsigned int	sysclk_freq;	/* 	SYSCLK freq		E.g. 72000000	*/
static void allon(void)
{
	LEDSALL_on;
 8003b8e:	4e10      	ldr	r6, [pc, #64]	; (8003bd0 <panic_leds+0x8e>)
 8003b90:	f44f 4370 	mov.w	r3, #61440	; 0xf000
 8003b94:	6033      	str	r3, [r6, #0]
	{
		while (1==1)
		{
			for (i = 0; i < count; i++)
			{
				allon();	loop(xon);
 8003b96:	9802      	ldr	r0, [sp, #8]
 8003b98:	f7ff ffc8 	bl	8003b2c <loop>
	LEDSALL_on;
	return;
}
static void alloff(void)
{
	LEDSALL_off;
 8003b9c:	f04f 4370 	mov.w	r3, #4026531840	; 0xf0000000
 8003ba0:	6033      	str	r3, [r6, #0]
		while (1==1)
		{
			for (i = 0; i < count; i++)
			{
				allon();	loop(xon);
				alloff();	loop(xoff);			
 8003ba2:	9801      	ldr	r0, [sp, #4]
 8003ba4:	f7ff ffc2 	bl	8003b2c <loop>
	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	if (sw == 0)
	{
		while (1==1)
		{
			for (i = 0; i < count; i++)
 8003ba8:	3501      	adds	r5, #1
 8003baa:	42a5      	cmp	r5, r4
 8003bac:	d3ef      	bcc.n	8003b8e <panic_leds+0x4c>
			{
				allon();	loop(xon);
				alloff();	loop(xoff);			
			}
			loop(x);
 8003bae:	9803      	ldr	r0, [sp, #12]
 8003bb0:	f7ff ffbc 	bl	8003b2c <loop>
	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	if (sw == 0)
	{
		while (1==1)
		{
			for (i = 0; i < count; i++)
 8003bb4:	2500      	movs	r5, #0
 8003bb6:	e7f8      	b.n	8003baa <panic_leds+0x68>
				alloff();	loop(xoff);			
			}
			loop(x);
		}
	}
}
 8003bb8:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
 8003bba:	bf00      	nop
 8003bbc:	2000081c 	.word	0x2000081c
 8003bc0:	000f423f 	.word	0x000f423f
 8003bc4:	20000840 	.word	0x20000840
 8003bc8:	007a1200 	.word	0x007a1200
 8003bcc:	40023830 	.word	0x40023830
 8003bd0:	40020c18 	.word	0x40020c18

08003bd4 <spi2rw_init>:
/******************************************************************************
 * void spi2rw_init(void);
 *  @brief Initialize SPI 
*******************************************************************************/ 
void spi2rw_init(void)
{
 8003bd4:	b538      	push	{r3, r4, r5, lr}
	/* Enable bus clocking for SPI2 */
	RCC_APB1ENR |= (1<<14);	// Enable SPI2 clocking
 8003bd6:	4b17      	ldr	r3, [pc, #92]	; (8003c34 <spi2rw_init+0x60>)

	/* Set up pins for SPI2 use. */
	f4gpiopins_Config ((volatile u32*)GPIOB, 12, (struct PINCONFIG*)&outputcs);	// CS
 8003bd8:	4c17      	ldr	r4, [pc, #92]	; (8003c38 <spi2rw_init+0x64>)
 *  @brief Initialize SPI 
*******************************************************************************/ 
void spi2rw_init(void)
{
	/* Enable bus clocking for SPI2 */
	RCC_APB1ENR |= (1<<14);	// Enable SPI2 clocking
 8003bda:	681a      	ldr	r2, [r3, #0]

	/* Set up pins for SPI2 use. */
	f4gpiopins_Config ((volatile u32*)GPIOB, 12, (struct PINCONFIG*)&outputcs);	// CS
 8003bdc:	4817      	ldr	r0, [pc, #92]	; (8003c3c <spi2rw_init+0x68>)
 *  @brief Initialize SPI 
*******************************************************************************/ 
void spi2rw_init(void)
{
	/* Enable bus clocking for SPI2 */
	RCC_APB1ENR |= (1<<14);	// Enable SPI2 clocking
 8003bde:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8003be2:	601a      	str	r2, [r3, #0]

	/* Set up pins for SPI2 use. */
	f4gpiopins_Config ((volatile u32*)GPIOB, 12, (struct PINCONFIG*)&outputcs);	// CS
 8003be4:	210c      	movs	r1, #12
 8003be6:	4622      	mov	r2, r4
	f4gpiopins_Config ((volatile u32*)GPIOB, 13, (struct PINCONFIG*)&outputaf);	// SCK
 8003be8:	1d65      	adds	r5, r4, #5
{
	/* Enable bus clocking for SPI2 */
	RCC_APB1ENR |= (1<<14);	// Enable SPI2 clocking

	/* Set up pins for SPI2 use. */
	f4gpiopins_Config ((volatile u32*)GPIOB, 12, (struct PINCONFIG*)&outputcs);	// CS
 8003bea:	f7ff ff44 	bl	8003a76 <f4gpiopins_Config>
	f4gpiopins_Config ((volatile u32*)GPIOB, 13, (struct PINCONFIG*)&outputaf);	// SCK
 8003bee:	4813      	ldr	r0, [pc, #76]	; (8003c3c <spi2rw_init+0x68>)
 8003bf0:	210d      	movs	r1, #13
 8003bf2:	462a      	mov	r2, r5
 8003bf4:	f7ff ff3f 	bl	8003a76 <f4gpiopins_Config>
	f4gpiopins_Config ((volatile u32*)GPIOB, 14, (struct PINCONFIG*)&inputaf);	// MISO
 8003bf8:	4810      	ldr	r0, [pc, #64]	; (8003c3c <spi2rw_init+0x68>)
 8003bfa:	210e      	movs	r1, #14
 8003bfc:	f104 020a 	add.w	r2, r4, #10
 8003c00:	f7ff ff39 	bl	8003a76 <f4gpiopins_Config>
	f4gpiopins_Config ((volatile u32*)GPIOB, 15, (struct PINCONFIG*)&outputaf);	// MOSI
 8003c04:	462a      	mov	r2, r5
 8003c06:	480d      	ldr	r0, [pc, #52]	; (8003c3c <spi2rw_init+0x68>)
 8003c08:	210f      	movs	r1, #15
 8003c0a:	f7ff ff34 	bl	8003a76 <f4gpiopins_Config>

	GPIO_BSRR(GPIOB)  = (1<<12);// Set /CS high
 8003c0e:	4b0c      	ldr	r3, [pc, #48]	; (8003c40 <spi2rw_init+0x6c>)
 8003c10:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8003c14:	601a      	str	r2, [r3, #0]

	// Set divisor to max.  If APB1 is 42 Mhz, then divide by 256 = 164062.5 Hz, 48 us per byte
/* NOTE: The following line is where the "phase" is set for the clock and polarity */
	//          (SSM SSI)  |enable peripheral | baud divisor | master select | CK 1 when idle    | phase  )
	SPI2_CR1 =  (0x3 << 8) |   (1 << 6)       | (0x7 << 3)   |   (1 << 2)    |    (1 << 1)       |  0x01    ;
 8003c16:	4b0b      	ldr	r3, [pc, #44]	; (8003c44 <spi2rw_init+0x70>)
 8003c18:	f240 327f 	movw	r2, #895	; 0x37f
 8003c1c:	601a      	str	r2, [r3, #0]
	
	/* SPI-CR2 use default, no interrupt masks enabled at this point */

	/* Set and enable interrupt controller for SPI2 */
	NVICIPR (NVIC_SPI2_IRQ, SPI2_PRIORITY );	// Set interrupt priority
 8003c1e:	4b0a      	ldr	r3, [pc, #40]	; (8003c48 <spi2rw_init+0x74>)
 8003c20:	681a      	ldr	r2, [r3, #0]
 8003c22:	f042 0250 	orr.w	r2, r2, #80	; 0x50
 8003c26:	601a      	str	r2, [r3, #0]
	NVICISER(NVIC_SPI2_IRQ);			// Enable interrupt controller for SPI2
 8003c28:	4b08      	ldr	r3, [pc, #32]	; (8003c4c <spi2rw_init+0x78>)
 8003c2a:	681a      	ldr	r2, [r3, #0]
 8003c2c:	f042 0210 	orr.w	r2, r2, #16
 8003c30:	601a      	str	r2, [r3, #0]

	return;
}
 8003c32:	bd38      	pop	{r3, r4, r5, pc}
 8003c34:	40023840 	.word	0x40023840
 8003c38:	0800b710 	.word	0x0800b710
 8003c3c:	40020400 	.word	0x40020400
 8003c40:	40020418 	.word	0x40020418
 8003c44:	40003800 	.word	0x40003800
 8003c48:	e000e424 	.word	0xe000e424
 8003c4c:	e000e104 	.word	0xe000e104

08003c50 <spi2_busy>:
 * @return	: 0 = /CS line is low; not-zero (busy) = /CS line is high (not busy)
*******************************************************************************/
unsigned short spi2_busy(void)
{
/* The /CS line is used to show if the SPI transfer is in progress */
	return (GPIOB_ODR & (1<<12));	// Return /CS bit
 8003c50:	4b02      	ldr	r3, [pc, #8]	; (8003c5c <spi2_busy+0xc>)
 8003c52:	6818      	ldr	r0, [r3, #0]
}
 8003c54:	f400 5080 	and.w	r0, r0, #4096	; 0x1000
 8003c58:	4770      	bx	lr
 8003c5a:	bf00      	nop
 8003c5c:	40020414 	.word	0x40020414

08003c60 <spi2_rw>:
 * @param	: char *pout = pointer to byte array with bytes to output
 * @param	: char *pin  = pointer to byte array to receive bytes coming in
 * @param	: int count  = byte count of number of write/read cycles
*******************************************************************************/
void spi2_rw (char *pout, char * pin, int count)
{
 8003c60:	b570      	push	{r4, r5, r6, lr}
 8003c62:	4604      	mov	r4, r0
 8003c64:	460d      	mov	r5, r1
 8003c66:	4616      	mov	r6, r2
	/* The following should not be necessary, but it is here JIC. */
	while ( spi2_busy() == 0 );	// Loop until a prior spi communication is complete
 8003c68:	f7ff fff2 	bl	8003c50 <spi2_busy>
 8003c6c:	2800      	cmp	r0, #0
 8003c6e:	d0fb      	beq.n	8003c68 <spi2_rw+0x8>

	GPIO_BSRR(GPIOB)  = (1<<(12+16));	// Set /CS low (show busy)
 8003c70:	4b08      	ldr	r3, [pc, #32]	; (8003c94 <spi2_rw+0x34>)
 8003c72:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003c76:	601a      	str	r2, [r3, #0]
	spi2_outptr = pout;		// Set pointer for interrupt handler to store outgoing data
	spi2_inptr = pin;		// Set pointer for interrupt handler to store incoming data
 8003c78:	4b07      	ldr	r3, [pc, #28]	; (8003c98 <spi2_rw+0x38>)
	spi2_cnt = count;		// Set byte count for interrupt handler
	SPI2_DR = *spi2_outptr++;	// Load outgoing byte to start spi cycle
 8003c7a:	4a08      	ldr	r2, [pc, #32]	; (8003c9c <spi2_rw+0x3c>)
	/* The following should not be necessary, but it is here JIC. */
	while ( spi2_busy() == 0 );	// Loop until a prior spi communication is complete

	GPIO_BSRR(GPIOB)  = (1<<(12+16));	// Set /CS low (show busy)
	spi2_outptr = pout;		// Set pointer for interrupt handler to store outgoing data
	spi2_inptr = pin;		// Set pointer for interrupt handler to store incoming data
 8003c7c:	601d      	str	r5, [r3, #0]
	spi2_cnt = count;		// Set byte count for interrupt handler
 8003c7e:	605e      	str	r6, [r3, #4]
	SPI2_DR = *spi2_outptr++;	// Load outgoing byte to start spi cycle
 8003c80:	f814 1b01 	ldrb.w	r1, [r4], #1
 8003c84:	6011      	str	r1, [r2, #0]
 8003c86:	609c      	str	r4, [r3, #8]
	SPI2_CR2 |= (SPI_CR2_RXNEIE);	// Enable receive buffer loaded (not empty) interrupt
 8003c88:	4b05      	ldr	r3, [pc, #20]	; (8003ca0 <spi2_rw+0x40>)
 8003c8a:	681a      	ldr	r2, [r3, #0]
 8003c8c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8003c90:	601a      	str	r2, [r3, #0]
	return;
}
 8003c92:	bd70      	pop	{r4, r5, r6, pc}
 8003c94:	40020418 	.word	0x40020418
 8003c98:	20000820 	.word	0x20000820
 8003c9c:	4000380c 	.word	0x4000380c
 8003ca0:	40003804 	.word	0x40003804

08003ca4 <SPI2_IRQHandler>:
off (not really necessary), and the i/o pin with the CS line is brought back high. 
*/

	volatile unsigned int dummy;

	if ( (SPI2_SR & SPI_SR_RXNE) != 0)  // Check for bogus interrupt
 8003ca4:	4b15      	ldr	r3, [pc, #84]	; (8003cfc <SPI2_IRQHandler+0x58>)
 8003ca6:	681b      	ldr	r3, [r3, #0]
 8003ca8:	f013 0f01 	tst.w	r3, #1
 * ISR routine
 *####################################################################################### */
int spidebug1;

void SPI2_IRQHandler(void)
{      
 8003cac:	b507      	push	{r0, r1, r2, lr}
off (not really necessary), and the i/o pin with the CS line is brought back high. 
*/

	volatile unsigned int dummy;

	if ( (SPI2_SR & SPI_SR_RXNE) != 0)  // Check for bogus interrupt
 8003cae:	d020      	beq.n	8003cf2 <SPI2_IRQHandler+0x4e>
	{ /* Here, valid receive interrupt. */
		*spi2_inptr++ = SPI2_DR;	// Get byte that was read
 8003cb0:	4b13      	ldr	r3, [pc, #76]	; (8003d00 <SPI2_IRQHandler+0x5c>)
 8003cb2:	4914      	ldr	r1, [pc, #80]	; (8003d04 <SPI2_IRQHandler+0x60>)
 8003cb4:	681a      	ldr	r2, [r3, #0]
 8003cb6:	6808      	ldr	r0, [r1, #0]
 8003cb8:	f802 0b01 	strb.w	r0, [r2], #1
 8003cbc:	601a      	str	r2, [r3, #0]
		spi2_cnt -= 1;	 		// Decrement byte count
 8003cbe:	685a      	ldr	r2, [r3, #4]
 8003cc0:	3a01      	subs	r2, #1
		if (spi2_cnt <= 0)		// Have we exhausted the count?
 8003cc2:	2a00      	cmp	r2, #0
	volatile unsigned int dummy;

	if ( (SPI2_SR & SPI_SR_RXNE) != 0)  // Check for bogus interrupt
	{ /* Here, valid receive interrupt. */
		*spi2_inptr++ = SPI2_DR;	// Get byte that was read
		spi2_cnt -= 1;	 		// Decrement byte count
 8003cc4:	605a      	str	r2, [r3, #4]
		if (spi2_cnt <= 0)		// Have we exhausted the count?
 8003cc6:	dc0c      	bgt.n	8003ce2 <SPI2_IRQHandler+0x3e>
		{ /* Here, yes, this byte is the reponse from the last byte transmitted */ 
			SPI2_CR2 &= ~SPI_CR2_RXNEIE;	// Turn off RXE interrupt enable
 8003cc8:	4a0f      	ldr	r2, [pc, #60]	; (8003d08 <SPI2_IRQHandler+0x64>)
			GPIO_BSRR(GPIOB)  = (1<<12);// Set /CS high (show not busy)
			if (spi2_readdoneptr != 0) // Skip if pointer is NULL
 8003cca:	68db      	ldr	r3, [r3, #12]
	{ /* Here, valid receive interrupt. */
		*spi2_inptr++ = SPI2_DR;	// Get byte that was read
		spi2_cnt -= 1;	 		// Decrement byte count
		if (spi2_cnt <= 0)		// Have we exhausted the count?
		{ /* Here, yes, this byte is the reponse from the last byte transmitted */ 
			SPI2_CR2 &= ~SPI_CR2_RXNEIE;	// Turn off RXE interrupt enable
 8003ccc:	6811      	ldr	r1, [r2, #0]
 8003cce:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 8003cd2:	6011      	str	r1, [r2, #0]
			GPIO_BSRR(GPIOB)  = (1<<12);// Set /CS high (show not busy)
 8003cd4:	4a0d      	ldr	r2, [pc, #52]	; (8003d0c <SPI2_IRQHandler+0x68>)
 8003cd6:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8003cda:	6011      	str	r1, [r2, #0]
			if (spi2_readdoneptr != 0) // Skip if pointer is NULL
 8003cdc:	b163      	cbz	r3, 8003cf8 <SPI2_IRQHandler+0x54>
				(*spi2_readdoneptr)();	// In case we want to do something else
 8003cde:	4798      	blx	r3
 8003ce0:	e00a      	b.n	8003cf8 <SPI2_IRQHandler+0x54>
			return;
		}
		else
		{
spidebug1 +=1;
 8003ce2:	691a      	ldr	r2, [r3, #16]
 8003ce4:	3201      	adds	r2, #1
 8003ce6:	611a      	str	r2, [r3, #16]
			SPI2_DR = *spi2_outptr++;	// Load outgoing byte to start next spi cycle
 8003ce8:	689a      	ldr	r2, [r3, #8]
 8003cea:	f812 0b01 	ldrb.w	r0, [r2], #1
 8003cee:	6008      	str	r0, [r1, #0]
 8003cf0:	609a      	str	r2, [r3, #8]
		}
	}
	dummy = SPI2_SR; // Prevent tail-chaining.
 8003cf2:	4b02      	ldr	r3, [pc, #8]	; (8003cfc <SPI2_IRQHandler+0x58>)
 8003cf4:	681b      	ldr	r3, [r3, #0]
 8003cf6:	9301      	str	r3, [sp, #4]
	return;
}
 8003cf8:	bd0e      	pop	{r1, r2, r3, pc}
 8003cfa:	bf00      	nop
 8003cfc:	40003808 	.word	0x40003808
 8003d00:	20000820 	.word	0x20000820
 8003d04:	4000380c 	.word	0x4000380c
 8003d08:	40003804 	.word	0x40003804
 8003d0c:	40020418 	.word	0x40020418

08003d10 <convert>:
	pclk2_freq  =   hclk_freq/convert(clocks->apb2);	// APB2 driven from AHB
 	return;                                           
}
/* Convert 0,4,5,6,7 input to 1,2,4,8,16 */
unsigned int convert(unsigned int ucX)
{	
 8003d10:	2301      	movs	r3, #1
	return (ucX == 0)?:(1 << (ucX-3) );
 8003d12:	b118      	cbz	r0, 8003d1c <convert+0xc>
 8003d14:	3803      	subs	r0, #3
 8003d16:	fa13 f000 	lsls.w	r0, r3, r0
 8003d1a:	4770      	bx	lr
 8003d1c:	4618      	mov	r0, r3
}
 8003d1e:	4770      	bx	lr

08003d20 <clockspecifysetup>:
 * @brief	: Setup the clocks & bus freq dividers
 * @param	: chase: 0 = use HSI (internal 8 MHz RC osc), 1 = use HSE (external Xtal osc)
 * @return	: static variables are set from input paramaters passed in struct
 ******************************************************************************/
void clockspecifysetup(struct CLOCKS *clocks)
{
 8003d20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003d22:	4603      	mov	r3, r0
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
	unsigned short sw_pll = 0;		// 0 = pll not used; 1 = pll used
	unsigned short pllp = clocks->pllp;	// Likely the clocks struct was a "const" and we may have to override the value given
 8003d24:	89c4      	ldrh	r4, [r0, #14]

	/* See Ref manual page 85 figure 9 */
	/* Note: Out of reset, the HSI (internal rc osc) is selected and ready. */


	switch (clocks->hso)	// Select high speed oscillator source
 8003d26:	781a      	ldrb	r2, [r3, #0]
{
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
	unsigned short sw_pll = 0;		// 0 = pll not used; 1 = pll used
	unsigned short pllp = clocks->pllp;	// Likely the clocks struct was a "const" and we may have to override the value given
	unsigned short pllm = clocks->pllm;
 8003d28:	8a41      	ldrh	r1, [r0, #18]
	unsigned short plln = clocks->plln;
	unsigned short pllq = clocks->pllq;
 8003d2a:	899d      	ldrh	r5, [r3, #12]
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
	unsigned short sw_pll = 0;		// 0 = pll not used; 1 = pll used
	unsigned short pllp = clocks->pllp;	// Likely the clocks struct was a "const" and we may have to override the value given
	unsigned short pllm = clocks->pllm;
	unsigned short plln = clocks->plln;
 8003d2c:	8a00      	ldrh	r0, [r0, #16]
	unsigned short pllq = clocks->pllq;
	unsigned int	freq = clocks->freq;	
 8003d2e:	689e      	ldr	r6, [r3, #8]

	/* See Ref manual page 85 figure 9 */
	/* Note: Out of reset, the HSI (internal rc osc) is selected and ready. */


	switch (clocks->hso)	// Select high speed oscillator source
 8003d30:	2a04      	cmp	r2, #4
 8003d32:	d834      	bhi.n	8003d9e <clockspecifysetup+0x7e>
 8003d34:	e8df f002 	tbb	[pc, r2]
 8003d38:	1e110334 	.word	0x1e110334
 8003d3c:	28          	.byte	0x28
 8003d3d:	00          	.byte	0x00
		/* No action needed needed since HSI is already running and ready.  
			This osc as system clock is what got us to this point! */
		freq = 16000000;				// The internal RC osc is always 16MHz
		break;
	case 1: // Use external xtal controlled osc
		RCC_CR = RCC_CR_HSEON;			// Start hi-speed external oscillator
 8003d3e:	4a6a      	ldr	r2, [pc, #424]	; (8003ee8 <clockspecifysetup+0x1c8>)
 8003d40:	f44f 3780 	mov.w	r7, #65536	; 0x10000
 8003d44:	6017      	str	r7, [r2, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 8003d46:	4a68      	ldr	r2, [pc, #416]	; (8003ee8 <clockspecifysetup+0x1c8>)
 8003d48:	6817      	ldr	r7, [r2, #0]
 8003d4a:	f417 3f00 	tst.w	r7, #131072	; 0x20000
 8003d4e:	d0fa      	beq.n	8003d46 <clockspecifysetup+0x26>
		usSW = 0x01;				// SWS = HSE as system clock
RCC_CR &= ~RCC_CR_HSION;	// Turn off HSI osc
 8003d50:	6817      	ldr	r7, [r2, #0]
 8003d52:	f027 0701 	bic.w	r7, r7, #1
 8003d56:	6017      	str	r7, [r2, #0]
 8003d58:	e01f      	b.n	8003d9a <clockspecifysetup+0x7a>
		break;
	case 2: // Use external signal input
		RCC_CR = RCC_CR_HSEBYP;			// By-pass external osc and use external signal
 8003d5a:	4a63      	ldr	r2, [pc, #396]	; (8003ee8 <clockspecifysetup+0x1c8>)
 8003d5c:	f44f 2780 	mov.w	r7, #262144	; 0x40000
 8003d60:	6017      	str	r7, [r2, #0]
		RCC_CR = RCC_CR_HSEON;			// Start hi-speed external clock
 8003d62:	f44f 3780 	mov.w	r7, #65536	; 0x10000
 8003d66:	6017      	str	r7, [r2, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 8003d68:	4a5f      	ldr	r2, [pc, #380]	; (8003ee8 <clockspecifysetup+0x1c8>)
 8003d6a:	6812      	ldr	r2, [r2, #0]
 8003d6c:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8003d70:	d0fa      	beq.n	8003d68 <clockspecifysetup+0x48>
 8003d72:	e012      	b.n	8003d9a <clockspecifysetup+0x7a>
		usSW = 0x01;				// SWS = HSE as system clock
		break;
	case 3: // Use remapped external osc *xtal*
//$$$		AFIO_MAPR |= (1 << 15); 		// Bit 15 PD01_REMAP: Port D0/Port D1 mapping on OSC_IN/OSC_OUT		
		RCC_CR = RCC_CR_HSEON;			// Start oscillators hi-speed internal and external
 8003d74:	4a5c      	ldr	r2, [pc, #368]	; (8003ee8 <clockspecifysetup+0x1c8>)
 8003d76:	f44f 3780 	mov.w	r7, #65536	; 0x10000
 8003d7a:	6017      	str	r7, [r2, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 8003d7c:	4a5a      	ldr	r2, [pc, #360]	; (8003ee8 <clockspecifysetup+0x1c8>)
 8003d7e:	6812      	ldr	r2, [r2, #0]
 8003d80:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8003d84:	d0fa      	beq.n	8003d7c <clockspecifysetup+0x5c>
 8003d86:	e008      	b.n	8003d9a <clockspecifysetup+0x7a>
		usSW = 0x01;				// SWS = HSE as system clock
		break;
	case 4: // Use remapped external osc *signal*
//$$$		AFIO_MAPR |= (1 << 15); 		// Bit 15 PD01_REMAP: Port D0/Port D1 mapping on OSC_IN/OSC_OUT		
		RCC_CR = RCC_CR_HSEBYP;			// By-pass external osc and use external signal
 8003d88:	4a57      	ldr	r2, [pc, #348]	; (8003ee8 <clockspecifysetup+0x1c8>)
 8003d8a:	f44f 2780 	mov.w	r7, #262144	; 0x40000
 8003d8e:	6017      	str	r7, [r2, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 8003d90:	4a55      	ldr	r2, [pc, #340]	; (8003ee8 <clockspecifysetup+0x1c8>)
 8003d92:	6812      	ldr	r2, [r2, #0]
 8003d94:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8003d98:	d0fa      	beq.n	8003d90 <clockspecifysetup+0x70>
		usSW = 0x01;				// SWS = HSE as system clock
 8003d9a:	2201      	movs	r2, #1
 8003d9c:	e002      	b.n	8003da4 <clockspecifysetup+0x84>
 8003d9e:	e7fe      	b.n	8003d9e <clockspecifysetup+0x7e>
	switch (clocks->hso)	// Select high speed oscillator source
	{
	case 0:	// Use internal 16 Mhz rc osc
		/* No action needed needed since HSI is already running and ready.  
			This osc as system clock is what got us to this point! */
		freq = 16000000;				// The internal RC osc is always 16MHz
 8003da0:	4e52      	ldr	r6, [pc, #328]	; (8003eec <clockspecifysetup+0x1cc>)
 * @param	: chase: 0 = use HSI (internal 8 MHz RC osc), 1 = use HSE (external Xtal osc)
 * @return	: static variables are set from input paramaters passed in struct
 ******************************************************************************/
void clockspecifysetup(struct CLOCKS *clocks)
{
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
 8003da2:	2200      	movs	r2, #0
This register is used to configure the PLL clock outputs according to the formulas:
    f(VCO clock) = f(PLL clock input)  (PLLN / PLLM)
    f(PLL general clock output) = f(VCO clock) / PLLP
    f(USB OTG FS, SDIO, RNG clock output) = f(VCO clock) / PLLQ
*/
	if ( (plln != 0) && (pllm != 0) ) // Is PLL multiplier/divider specifed?
 8003da4:	2800      	cmp	r0, #0
 8003da6:	d041      	beq.n	8003e2c <clockspecifysetup+0x10c>
 8003da8:	2900      	cmp	r1, #0
 8003daa:	d041      	beq.n	8003e30 <clockspecifysetup+0x110>
	{ // Here, yes the PLL is to be used

		/* Make sure pllp is valid */
		if ((clocks->pllp >> 1) == 0 ) pllp = 2;
 8003dac:	89df      	ldrh	r7, [r3, #14]
 8003dae:	087f      	lsrs	r7, r7, #1
 8003db0:	d003      	beq.n	8003dba <clockspecifysetup+0x9a>
		if ((clocks->pllp >> 1) >  4 ) pllp = 8;
 8003db2:	2f04      	cmp	r7, #4
 8003db4:	bf88      	it	hi
 8003db6:	2408      	movhi	r4, #8
 8003db8:	e000      	b.n	8003dbc <clockspecifysetup+0x9c>
*/
	if ( (plln != 0) && (pllm != 0) ) // Is PLL multiplier/divider specifed?
	{ // Here, yes the PLL is to be used

		/* Make sure pllp is valid */
		if ((clocks->pllp >> 1) == 0 ) pllp = 2;
 8003dba:	2402      	movs	r4, #2
		if ((clocks->pllp >> 1) >  4 ) pllp = 8;

		/* Make sure plln, pllm is within range */
		if (plln > 432 ) while (1==1);
 8003dbc:	f5b0 7fd8 	cmp.w	r0, #432	; 0x1b0
 8003dc0:	d900      	bls.n	8003dc4 <clockspecifysetup+0xa4>
 8003dc2:	e7fe      	b.n	8003dc2 <clockspecifysetup+0xa2>
		if (plln <   2 ) while (1==1);
 8003dc4:	2801      	cmp	r0, #1
 8003dc6:	d100      	bne.n	8003dca <clockspecifysetup+0xaa>
 8003dc8:	e7fe      	b.n	8003dc8 <clockspecifysetup+0xa8>
		if (pllm >  64 ) while (1==1);
 8003dca:	2940      	cmp	r1, #64	; 0x40
 8003dcc:	d900      	bls.n	8003dd0 <clockspecifysetup+0xb0>
 8003dce:	e7fe      	b.n	8003dce <clockspecifysetup+0xae>
		if (pllm <   2 ) while (1==1);	
 8003dd0:	2901      	cmp	r1, #1
 8003dd2:	d100      	bne.n	8003dd6 <clockspecifysetup+0xb6>
 8003dd4:	e7fe      	b.n	8003dd4 <clockspecifysetup+0xb4>

		/* Divider for 48 MHz peripherals */
		if ((pllq == 0) || (pllq > 15)) pllq = 15;	
 8003dd6:	1e6f      	subs	r7, r5, #1
 8003dd8:	b2bf      	uxth	r7, r7
 8003dda:	2f0e      	cmp	r7, #14
 8003ddc:	bf88      	it	hi
 8003dde:	250f      	movhi	r5, #15

		vco_freq = (freq * clocks->plln) / clocks->pllm; 	// VCO freq
 8003de0:	8a1f      	ldrh	r7, [r3, #16]
 8003de2:	437e      	muls	r6, r7
 8003de4:	8a5f      	ldrh	r7, [r3, #18]
 8003de6:	fbb6 f6f7 	udiv	r6, r6, r7

		/* Don't blast ahead if the VCO freq is out of range */
		if (vco_freq > 432000000) while(1==1); 	// SCREWED
 8003dea:	4f41      	ldr	r7, [pc, #260]	; (8003ef0 <clockspecifysetup+0x1d0>)
 8003dec:	42be      	cmp	r6, r7
 8003dee:	d900      	bls.n	8003df2 <clockspecifysetup+0xd2>
 8003df0:	e7fe      	b.n	8003df0 <clockspecifysetup+0xd0>
		if (vco_freq < 64) 	  while(1==1); 	// SCREWED
 8003df2:	2e3f      	cmp	r6, #63	; 0x3f
 8003df4:	d800      	bhi.n	8003df8 <clockspecifysetup+0xd8>
 8003df6:	e7fe      	b.n	8003df6 <clockspecifysetup+0xd6>
		
		sysclk_freq = vco_freq / pllp;
 8003df8:	4f3e      	ldr	r7, [pc, #248]	; (8003ef4 <clockspecifysetup+0x1d4>)
 8003dfa:	fbb6 f6f4 	udiv	r6, r6, r4
 8003dfe:	603e      	str	r6, [r7, #0]

		/* Don't blast ahead if the sysclk freq is too high */
		if (sysclk_freq > 168000000)	while(1==1); // SCREWED
 8003e00:	4f3d      	ldr	r7, [pc, #244]	; (8003ef8 <clockspecifysetup+0x1d8>)
 8003e02:	42be      	cmp	r6, r7
 8003e04:	d900      	bls.n	8003e08 <clockspecifysetup+0xe8>
 8003e06:	e7fe      	b.n	8003e06 <clockspecifysetup+0xe6>

		/* Setup PLL counts */
		RCC_PLLCFGR = (pllq << 24) | ( (clocks->pllsrc & 0x01) << 22) | ( pllp << 16) | ( (plln & 0x01ff) << 6) | (pllm);
 8003e08:	785e      	ldrb	r6, [r3, #1]
 8003e0a:	05c0      	lsls	r0, r0, #23
 8003e0c:	0dc0      	lsrs	r0, r0, #23
 8003e0e:	f006 0601 	and.w	r6, r6, #1
 8003e12:	0180      	lsls	r0, r0, #6
 8003e14:	ea40 5086 	orr.w	r0, r0, r6, lsl #22
 8003e18:	ea40 0101 	orr.w	r1, r0, r1
 8003e1c:	ea41 4404 	orr.w	r4, r1, r4, lsl #16
 8003e20:	4836      	ldr	r0, [pc, #216]	; (8003efc <clockspecifysetup+0x1dc>)
 8003e22:	ea44 6505 	orr.w	r5, r4, r5, lsl #24
 8003e26:	6005      	str	r5, [r0, #0]

		sw_pll = 1;
 8003e28:	2601      	movs	r6, #1
 8003e2a:	e002      	b.n	8003e32 <clockspecifysetup+0x112>
 ******************************************************************************/
void clockspecifysetup(struct CLOCKS *clocks)
{
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
	unsigned short sw_pll = 0;		// 0 = pll not used; 1 = pll used
 8003e2c:	4606      	mov	r6, r0
 8003e2e:	e000      	b.n	8003e32 <clockspecifysetup+0x112>
 8003e30:	460e      	mov	r6, r1

		sw_pll = 1;
	}

	/* Determine number of flash wait states p 55.  2.7-3.6v ONLY */
	if (sysclk_freq >  30) ws = 1;
 8003e32:	4930      	ldr	r1, [pc, #192]	; (8003ef4 <clockspecifysetup+0x1d4>)
 8003e34:	680c      	ldr	r4, [r1, #0]
 8003e36:	2c1e      	cmp	r4, #30
 8003e38:	d94e      	bls.n	8003ed8 <clockspecifysetup+0x1b8>
	if (sysclk_freq >  60) ws = 2;
 8003e3a:	2c3c      	cmp	r4, #60	; 0x3c
 8003e3c:	d94e      	bls.n	8003edc <clockspecifysetup+0x1bc>
	if (sysclk_freq >  90) ws = 3;
 8003e3e:	2c5a      	cmp	r4, #90	; 0x5a
 8003e40:	d94e      	bls.n	8003ee0 <clockspecifysetup+0x1c0>
	if (sysclk_freq > 120) ws = 4;
 8003e42:	2c78      	cmp	r4, #120	; 0x78
 8003e44:	d94e      	bls.n	8003ee4 <clockspecifysetup+0x1c4>
 8003e46:	2c96      	cmp	r4, #150	; 0x96
 8003e48:	bf8c      	ite	hi
 8003e4a:	2105      	movhi	r1, #5
 8003e4c:	2104      	movls	r1, #4
	if (sysclk_freq > 150) ws = 5;

	/* Set wait states in register */
	FLASH_ACR |= ws;
 8003e4e:	482c      	ldr	r0, [pc, #176]	; (8003f00 <clockspecifysetup+0x1e0>)
 8003e50:	6805      	ldr	r5, [r0, #0]
 8003e52:	ea41 0505 	orr.w	r5, r1, r5
 8003e56:	6005      	str	r5, [r0, #0]

	/* Wait for register to become effective p 55 */
	while ((FLASH_ACR & 0x07) != ws);
 8003e58:	4829      	ldr	r0, [pc, #164]	; (8003f00 <clockspecifysetup+0x1e0>)
 8003e5a:	6800      	ldr	r0, [r0, #0]
 8003e5c:	f000 0007 	and.w	r0, r0, #7
 8003e60:	4288      	cmp	r0, r1
 8003e62:	d1f9      	bne.n	8003e58 <clockspecifysetup+0x138>


	/* Clock configuraton register (Ref manual, page 97)	*/
	// Setup up bus dividers
	RCC_CFGR = (clocks->apb2  << 13)  |	/* (3b) PPRE2: ABP2 prescaler bit code	(4-7)		*/ 
 8003e64:	78dd      	ldrb	r5, [r3, #3]
		   (clocks->apb1  << 10)  |	/* (3b) PPRE1: APB1 prescaler bit code	(4-7)		*/ 
 8003e66:	7898      	ldrb	r0, [r3, #2]
		   (clocks->ahb   <<  4)  ;	/* (4b) HPRE:  AHB  prescaler bit code	(8-15)		*/
 8003e68:	791b      	ldrb	r3, [r3, #4]
	while ((FLASH_ACR & 0x07) != ws);


	/* Clock configuraton register (Ref manual, page 97)	*/
	// Setup up bus dividers
	RCC_CFGR = (clocks->apb2  << 13)  |	/* (3b) PPRE2: ABP2 prescaler bit code	(4-7)		*/ 
 8003e6a:	4926      	ldr	r1, [pc, #152]	; (8003f04 <clockspecifysetup+0x1e4>)
 8003e6c:	036f      	lsls	r7, r5, #13
 8003e6e:	ea47 2780 	orr.w	r7, r7, r0, lsl #10
		   (clocks->apb1  << 10)  |	/* (3b) PPRE1: APB1 prescaler bit code	(4-7)		*/ 
 8003e72:	ea47 1703 	orr.w	r7, r7, r3, lsl #4
		   (clocks->ahb   <<  4)  ;	/* (4b) HPRE:  AHB  prescaler bit code	(8-15)		*/


	if (sw_pll == 1)	// Are we using the PLL?
 8003e76:	2e01      	cmp	r6, #1
	while ((FLASH_ACR & 0x07) != ws);


	/* Clock configuraton register (Ref manual, page 97)	*/
	// Setup up bus dividers
	RCC_CFGR = (clocks->apb2  << 13)  |	/* (3b) PPRE2: ABP2 prescaler bit code	(4-7)		*/ 
 8003e78:	600f      	str	r7, [r1, #0]
		   (clocks->apb1  << 10)  |	/* (3b) PPRE1: APB1 prescaler bit code	(4-7)		*/ 
		   (clocks->ahb   <<  4)  ;	/* (4b) HPRE:  AHB  prescaler bit code	(8-15)		*/


	if (sw_pll == 1)	// Are we using the PLL?
 8003e7a:	d10a      	bne.n	8003e92 <clockspecifysetup+0x172>
	{ // Here yes, start PLL
		// Enable PLL
		RCC_CR |= (1<<24);			// PLLON:  Turn PLL on
 8003e7c:	4a1a      	ldr	r2, [pc, #104]	; (8003ee8 <clockspecifysetup+0x1c8>)
 8003e7e:	6811      	ldr	r1, [r2, #0]
 8003e80:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 8003e84:	6011      	str	r1, [r2, #0]
		while ((RCC_CR & (1<<25) ) == 0);	// PLLRDY: Wait for PLL to become ready
 8003e86:	4a18      	ldr	r2, [pc, #96]	; (8003ee8 <clockspecifysetup+0x1c8>)
 8003e88:	6812      	ldr	r2, [r2, #0]
 8003e8a:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8003e8e:	d0fa      	beq.n	8003e86 <clockspecifysetup+0x166>

		// Select PLL as system clock source 
		usSW = 0x02;				// Change the usSW code for PLL
 8003e90:	2202      	movs	r2, #2
	}

	

	/* Switch the system clock source to the one specified */
	RCC_CFGR = (RCC_CFGR & ~0x03) | usSW;		// Set system clock source (it has been running on HSI (internal 8 MHz rc clock)
 8003e92:	491c      	ldr	r1, [pc, #112]	; (8003f04 <clockspecifysetup+0x1e4>)
 8003e94:	680e      	ldr	r6, [r1, #0]
 8003e96:	f026 0603 	bic.w	r6, r6, #3
 8003e9a:	ea42 0606 	orr.w	r6, r2, r6
 8003e9e:	600e      	str	r6, [r1, #0]
	while ( (RCC_CFGR & 0x0c) != (unsigned short)(usSW << 2) );	// Wait until system is running on the clock source
 8003ea0:	0092      	lsls	r2, r2, #2
 8003ea2:	4918      	ldr	r1, [pc, #96]	; (8003f04 <clockspecifysetup+0x1e4>)
 8003ea4:	6809      	ldr	r1, [r1, #0]
 8003ea6:	f001 010c 	and.w	r1, r1, #12
 8003eaa:	4291      	cmp	r1, r2
 8003eac:	d1f9      	bne.n	8003ea2 <clockspecifysetup+0x182>


	/* Compute static variables with bus freqs that other routines will use to for their setup */
	hclk_freq   = sysclk_freq/ahbtbl[(clocks->ahb)];	// AHB bus freq = sysclck/ ahb bus divider
 8003eae:	4a16      	ldr	r2, [pc, #88]	; (8003f08 <clockspecifysetup+0x1e8>)
 8003eb0:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8003eb4:	fbb4 f4f3 	udiv	r4, r4, r3
 8003eb8:	4b14      	ldr	r3, [pc, #80]	; (8003f0c <clockspecifysetup+0x1ec>)
 8003eba:	601c      	str	r4, [r3, #0]
	pclk1_freq  =   hclk_freq/convert(clocks->apb1);	// APB1 driven from AHB (must not exceed 36 MHz)
 8003ebc:	f7ff ff28 	bl	8003d10 <convert>
 8003ec0:	4b13      	ldr	r3, [pc, #76]	; (8003f10 <clockspecifysetup+0x1f0>)
 8003ec2:	fbb4 f0f0 	udiv	r0, r4, r0
 8003ec6:	6018      	str	r0, [r3, #0]
	pclk2_freq  =   hclk_freq/convert(clocks->apb2);	// APB2 driven from AHB
 8003ec8:	4628      	mov	r0, r5
 8003eca:	f7ff ff21 	bl	8003d10 <convert>
 8003ece:	4b11      	ldr	r3, [pc, #68]	; (8003f14 <clockspecifysetup+0x1f4>)
 8003ed0:	fbb4 f0f0 	udiv	r0, r4, r0
 8003ed4:	6018      	str	r0, [r3, #0]
 	return;                                           
}
 8003ed6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 * @return	: static variables are set from input paramaters passed in struct
 ******************************************************************************/
void clockspecifysetup(struct CLOCKS *clocks)
{
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
 8003ed8:	2100      	movs	r1, #0
 8003eda:	e7b8      	b.n	8003e4e <clockspecifysetup+0x12e>

		sw_pll = 1;
	}

	/* Determine number of flash wait states p 55.  2.7-3.6v ONLY */
	if (sysclk_freq >  30) ws = 1;
 8003edc:	2101      	movs	r1, #1
 8003ede:	e7b6      	b.n	8003e4e <clockspecifysetup+0x12e>
	if (sysclk_freq >  60) ws = 2;
 8003ee0:	2102      	movs	r1, #2
 8003ee2:	e7b4      	b.n	8003e4e <clockspecifysetup+0x12e>
	if (sysclk_freq >  90) ws = 3;
 8003ee4:	2103      	movs	r1, #3
 8003ee6:	e7b2      	b.n	8003e4e <clockspecifysetup+0x12e>
 8003ee8:	40023800 	.word	0x40023800
 8003eec:	00f42400 	.word	0x00f42400
 8003ef0:	19bfcc00 	.word	0x19bfcc00
 8003ef4:	20000840 	.word	0x20000840
 8003ef8:	0a037a00 	.word	0x0a037a00
 8003efc:	40023804 	.word	0x40023804
 8003f00:	40023c00 	.word	0x40023c00
 8003f04:	40023808 	.word	0x40023808
 8003f08:	0800b720 	.word	0x0800b720
 8003f0c:	20000834 	.word	0x20000834
 8003f10:	20000838 	.word	0x20000838
 8003f14:	2000083c 	.word	0x2000083c

08003f18 <clockI2Ssetup>:
int clockI2Ssetup(unsigned int R, unsigned int N)
{
	int i = 10000;	// Anti-hang loop counter
	
	/* Check input value ranges */
	if (R <   2) return 1;
 8003f18:	2801      	cmp	r0, #1
 * @param	: R = valid range: 2-7 (3 bits)
 * @param	: N = valid range: 192-432 (9 bits). 
 * @return	: 0 = OK; 1 = failed
 ******************************************************************************/
int clockI2Ssetup(unsigned int R, unsigned int N)
{
 8003f1a:	b530      	push	{r4, r5, lr}
	int i = 10000;	// Anti-hang loop counter
	
	/* Check input value ranges */
	if (R <   2) return 1;
 8003f1c:	d91f      	bls.n	8003f5e <clockI2Ssetup+0x46>
	if (R >   7) return 1;
 8003f1e:	2807      	cmp	r0, #7
 8003f20:	d81d      	bhi.n	8003f5e <clockI2Ssetup+0x46>
	if (N < 192) return 1;
 8003f22:	29bf      	cmp	r1, #191	; 0xbf
 8003f24:	d91b      	bls.n	8003f5e <clockI2Ssetup+0x46>
	if (N > 432) return 1;
 8003f26:	f5b1 7fd8 	cmp.w	r1, #432	; 0x1b0
 8003f2a:	d81a      	bhi.n	8003f62 <clockI2Ssetup+0x4a>

	/* Turn PLL off and reset counters */
	RCC_CR &= ~(1<<26);			// Disable PLL2I2S if previously enabled (p 92)
 8003f2c:	4b0e      	ldr	r3, [pc, #56]	; (8003f68 <clockI2Ssetup+0x50>)
	while ( (RCC_CR & (1<<27)) == 1 );	// Be sure it is not ready (p 93)
	RCC_PLLI2SCFGR &= ~(0x70007fc0) ;	// Reset current R & N setttings (p 132)
 8003f2e:	4c0f      	ldr	r4, [pc, #60]	; (8003f6c <clockI2Ssetup+0x54>)
	if (R >   7) return 1;
	if (N < 192) return 1;
	if (N > 432) return 1;

	/* Turn PLL off and reset counters */
	RCC_CR &= ~(1<<26);			// Disable PLL2I2S if previously enabled (p 92)
 8003f30:	681a      	ldr	r2, [r3, #0]
 8003f32:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8003f36:	601a      	str	r2, [r3, #0]
	while ( (RCC_CR & (1<<27)) == 1 );	// Be sure it is not ready (p 93)
 8003f38:	681a      	ldr	r2, [r3, #0]
	RCC_PLLI2SCFGR &= ~(0x70007fc0) ;	// Reset current R & N setttings (p 132)
 8003f3a:	4a0d      	ldr	r2, [pc, #52]	; (8003f70 <clockI2Ssetup+0x58>)
 8003f3c:	6815      	ldr	r5, [r2, #0]
 8003f3e:	ea05 0404 	and.w	r4, r5, r4
 8003f42:	6014      	str	r4, [r2, #0]

	/* Set up new PLL counters (p 132) */
	RCC_PLLI2SCFGR |= (R << 28) | (N << 6) ;
 8003f44:	6814      	ldr	r4, [r2, #0]
 8003f46:	ea44 7000 	orr.w	r0, r4, r0, lsl #28
 8003f4a:	ea40 1181 	orr.w	r1, r0, r1, lsl #6
 8003f4e:	6011      	str	r1, [r2, #0]

	/* Enable PLL */
	RCC_CR |= (1<<26);	// Enable bit
 8003f50:	681a      	ldr	r2, [r3, #0]
 8003f52:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8003f56:	601a      	str	r2, [r3, #0]

	/* Wait for it to come ready, but don't allow to hang forever. (p 93) */
	while ( ((RCC_CR & (1<<27)) == 1) && (--i > 0) );
 8003f58:	681b      	ldr	r3, [r3, #0]
	if ( i < 0 ) return 1;		// Timed out

	return 0;
 8003f5a:	2000      	movs	r0, #0
 8003f5c:	bd30      	pop	{r4, r5, pc}
	int i = 10000;	// Anti-hang loop counter
	
	/* Check input value ranges */
	if (R <   2) return 1;
	if (R >   7) return 1;
	if (N < 192) return 1;
 8003f5e:	2001      	movs	r0, #1
 8003f60:	bd30      	pop	{r4, r5, pc}
	if (N > 432) return 1;
 8003f62:	2001      	movs	r0, #1
	/* Wait for it to come ready, but don't allow to hang forever. (p 93) */
	while ( ((RCC_CR & (1<<27)) == 1) && (--i > 0) );
	if ( i < 0 ) return 1;		// Timed out

	return 0;
}
 8003f64:	bd30      	pop	{r4, r5, pc}
 8003f66:	bf00      	nop
 8003f68:	40023800 	.word	0x40023800
 8003f6c:	8fff803f 	.word	0x8fff803f
 8003f70:	40023884 	.word	0x40023884

08003f74 <nvic_dma_stream_vector_add>:
 * @param	: stream_number = 0-7 for stream selected
 * @return	: 0 = OK; -1 = irq number out of range; -2 or less = stream already in use
******************************************************************************/
int nvic_dma_stream_vector_add(void(*p)(u32*), u32* q, u32 dma_irq_number, u32 stream_number)
{
	if (stream_number > 7) return -1;	// JIC a bozo sent a bad number
 8003f74:	2b07      	cmp	r3, #7
 * @param	: dma_irq_number = nvic irq number
 * @param	: stream_number = 0-7 for stream selected
 * @return	: 0 = OK; -1 = irq number out of range; -2 or less = stream already in use
******************************************************************************/
int nvic_dma_stream_vector_add(void(*p)(u32*), u32* q, u32 dma_irq_number, u32 stream_number)
{
 8003f76:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (stream_number > 7) return -1;	// JIC a bozo sent a bad number
 8003f78:	d863      	bhi.n	8004042 <nvic_dma_stream_vector_add+0xce>

	/* Convert DMA irq number (vector position) to an index 0 - 7 */
	// --------- DMA1 -----------
	if ((dma_irq_number >= DMASTRM10) && (dma_irq_number <= DMASTRM16))
 8003f7a:	f1a2 040b 	sub.w	r4, r2, #11
 8003f7e:	2c06      	cmp	r4, #6
 8003f80:	d815      	bhi.n	8003fae <nvic_dma_stream_vector_add+0x3a>
	{
		if ((dma1_stream_use & (1 << stream_number)) != 0) return -2; 	// Already setup
 8003f82:	4a39      	ldr	r2, [pc, #228]	; (8004068 <nvic_dma_stream_vector_add+0xf4>)
 8003f84:	7815      	ldrb	r5, [r2, #0]
 8003f86:	fa55 f603 	asrs.w	r6, r5, r3
 8003f8a:	f016 0601 	ands.w	r6, r6, #1
 8003f8e:	d15b      	bne.n	8004048 <nvic_dma_stream_vector_add+0xd4>
		dma1_stream_use |=     (1 << stream_number);			// Set bit to show used
 8003f90:	2701      	movs	r7, #1
 8003f92:	fa17 f303 	lsls.w	r3, r7, r3
 8003f96:	ea43 0505 	orr.w	r5, r3, r5
 8003f9a:	7015      	strb	r5, [r2, #0]
		dma1[(dma_irq_number - DMASTRM10)].jmp  = p; // Pointer to IRQ handler
		dma1[(dma_irq_number - DMASTRM10)].base = q; // Pointer to control block
		RCC_AHB1ENR |= (1<<21); // Enable DMA1 clocking
 8003f9c:	4b33      	ldr	r3, [pc, #204]	; (800406c <nvic_dma_stream_vector_add+0xf8>)
	// --------- DMA1 -----------
	if ((dma_irq_number >= DMASTRM10) && (dma_irq_number <= DMASTRM16))
	{
		if ((dma1_stream_use & (1 << stream_number)) != 0) return -2; 	// Already setup
		dma1_stream_use |=     (1 << stream_number);			// Set bit to show used
		dma1[(dma_irq_number - DMASTRM10)].jmp  = p; // Pointer to IRQ handler
 8003f9e:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 8003fa2:	6050      	str	r0, [r2, #4]
		dma1[(dma_irq_number - DMASTRM10)].base = q; // Pointer to control block
 8003fa4:	6091      	str	r1, [r2, #8]
		RCC_AHB1ENR |= (1<<21); // Enable DMA1 clocking
 8003fa6:	681a      	ldr	r2, [r3, #0]
 8003fa8:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8003fac:	e046      	b.n	800403c <nvic_dma_stream_vector_add+0xc8>
		return 0;
	}
	if (dma_irq_number == DMASTRM17)
 8003fae:	2a2f      	cmp	r2, #47	; 0x2f
 8003fb0:	d110      	bne.n	8003fd4 <nvic_dma_stream_vector_add+0x60>
	{
		if ((dma1_stream_use & 0x80) != 0) return -3; 	// Already setup
 8003fb2:	4b2d      	ldr	r3, [pc, #180]	; (8004068 <nvic_dma_stream_vector_add+0xf4>)
 8003fb4:	781a      	ldrb	r2, [r3, #0]
 8003fb6:	f012 0f80 	tst.w	r2, #128	; 0x80
 8003fba:	d148      	bne.n	800404e <nvic_dma_stream_vector_add+0xda>
		dma1_stream_use |=     0x80;			// Set bit to show used
 8003fbc:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8003fc0:	701a      	strb	r2, [r3, #0]
		dma1[7].jmp  = p; 
 8003fc2:	63d8      	str	r0, [r3, #60]	; 0x3c
		dma1[7].base = q;
 8003fc4:	6419      	str	r1, [r3, #64]	; 0x40
		RCC_AHB1ENR |= (1<<21); // Enable DMA1 clocking
 8003fc6:	4b29      	ldr	r3, [pc, #164]	; (800406c <nvic_dma_stream_vector_add+0xf8>)
 8003fc8:	681a      	ldr	r2, [r3, #0]
 8003fca:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8003fce:	601a      	str	r2, [r3, #0]
		return 0;
 8003fd0:	2000      	movs	r0, #0
 8003fd2:	bdf0      	pop	{r4, r5, r6, r7, pc}

	// --------- DMA2 -----------
	}
	if ( (dma_irq_number >= DMASTRM20) && (dma_irq_number <= DMASTRM24 ))
 8003fd4:	f1a2 0438 	sub.w	r4, r2, #56	; 0x38
 8003fd8:	2c04      	cmp	r4, #4
 8003fda:	d813      	bhi.n	8004004 <nvic_dma_stream_vector_add+0x90>
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -4; 	// Already setup
 8003fdc:	4a22      	ldr	r2, [pc, #136]	; (8004068 <nvic_dma_stream_vector_add+0xf4>)
 8003fde:	f892 5044 	ldrb.w	r5, [r2, #68]	; 0x44
 8003fe2:	fa55 f603 	asrs.w	r6, r5, r3
 8003fe6:	f016 0601 	ands.w	r6, r6, #1
 8003fea:	d133      	bne.n	8004054 <nvic_dma_stream_vector_add+0xe0>
		dma2_stream_use |=     (1 << stream_number);			// Set bit to show used
 8003fec:	2701      	movs	r7, #1
 8003fee:	fa17 f303 	lsls.w	r3, r7, r3
 8003ff2:	ea43 0505 	orr.w	r5, r3, r5
 8003ff6:	f882 5044 	strb.w	r5, [r2, #68]	; 0x44
		dma2[dma_irq_number - DMASTRM20].jmp  = p; 
 8003ffa:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 8003ffe:	6490      	str	r0, [r2, #72]	; 0x48
		dma2[dma_irq_number - DMASTRM20].base = q;
 8004000:	64d1      	str	r1, [r2, #76]	; 0x4c
 8004002:	e017      	b.n	8004034 <nvic_dma_stream_vector_add+0xc0>
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
		return 0;
	}
	if ( (dma_irq_number >= DMASTRM25) && (dma_irq_number <= DMASTRM27 ))
 8004004:	f1a2 0444 	sub.w	r4, r2, #68	; 0x44
 8004008:	2c02      	cmp	r4, #2
 800400a:	d826      	bhi.n	800405a <nvic_dma_stream_vector_add+0xe6>
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -5; 	// Already setup
 800400c:	4c16      	ldr	r4, [pc, #88]	; (8004068 <nvic_dma_stream_vector_add+0xf4>)
 800400e:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
 8004012:	fa55 f603 	asrs.w	r6, r5, r3
 8004016:	f016 0601 	ands.w	r6, r6, #1
 800401a:	d121      	bne.n	8004060 <nvic_dma_stream_vector_add+0xec>
		dma2_stream_use |=     (1 << stream_number);			// Set bit to show used
 800401c:	2701      	movs	r7, #1
 800401e:	fa17 f303 	lsls.w	r3, r7, r3
 8004022:	ea43 0505 	orr.w	r5, r3, r5
		dma2[dma_irq_number - DMASTRM25 + 5].jmp  = p; 
 8004026:	3a3f      	subs	r2, #63	; 0x3f
		return 0;
	}
	if ( (dma_irq_number >= DMASTRM25) && (dma_irq_number <= DMASTRM27 ))
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -5; 	// Already setup
		dma2_stream_use |=     (1 << stream_number);			// Set bit to show used
 8004028:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
		dma2[dma_irq_number - DMASTRM25 + 5].jmp  = p; 
 800402c:	eb04 04c2 	add.w	r4, r4, r2, lsl #3
 8004030:	64a0      	str	r0, [r4, #72]	; 0x48
		dma2[dma_irq_number - DMASTRM25 + 5].base = q; 
 8004032:	64e1      	str	r1, [r4, #76]	; 0x4c
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
 8004034:	4b0d      	ldr	r3, [pc, #52]	; (800406c <nvic_dma_stream_vector_add+0xf8>)
 8004036:	681a      	ldr	r2, [r3, #0]
 8004038:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 800403c:	601a      	str	r2, [r3, #0]
		return 0;
 800403e:	4630      	mov	r0, r6
 8004040:	bdf0      	pop	{r4, r5, r6, r7, pc}
 * @param	: stream_number = 0-7 for stream selected
 * @return	: 0 = OK; -1 = irq number out of range; -2 or less = stream already in use
******************************************************************************/
int nvic_dma_stream_vector_add(void(*p)(u32*), u32* q, u32 dma_irq_number, u32 stream_number)
{
	if (stream_number > 7) return -1;	// JIC a bozo sent a bad number
 8004042:	f04f 30ff 	mov.w	r0, #4294967295
 8004046:	bdf0      	pop	{r4, r5, r6, r7, pc}

	/* Convert DMA irq number (vector position) to an index 0 - 7 */
	// --------- DMA1 -----------
	if ((dma_irq_number >= DMASTRM10) && (dma_irq_number <= DMASTRM16))
	{
		if ((dma1_stream_use & (1 << stream_number)) != 0) return -2; 	// Already setup
 8004048:	f06f 0001 	mvn.w	r0, #1
 800404c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		RCC_AHB1ENR |= (1<<21); // Enable DMA1 clocking
		return 0;
	}
	if (dma_irq_number == DMASTRM17)
	{
		if ((dma1_stream_use & 0x80) != 0) return -3; 	// Already setup
 800404e:	f06f 0002 	mvn.w	r0, #2
 8004052:	bdf0      	pop	{r4, r5, r6, r7, pc}

	// --------- DMA2 -----------
	}
	if ( (dma_irq_number >= DMASTRM20) && (dma_irq_number <= DMASTRM24 ))
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -4; 	// Already setup
 8004054:	f06f 0003 	mvn.w	r0, #3
 8004058:	bdf0      	pop	{r4, r5, r6, r7, pc}
		dma2[dma_irq_number - DMASTRM25 + 5].jmp  = p; 
		dma2[dma_irq_number - DMASTRM25 + 5].base = q; 
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
		return 0;
	}
	return -7;
 800405a:	f06f 0006 	mvn.w	r0, #6
 800405e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
		return 0;
	}
	if ( (dma_irq_number >= DMASTRM25) && (dma_irq_number <= DMASTRM27 ))
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -5; 	// Already setup
 8004060:	f06f 0004 	mvn.w	r0, #4
		dma2[dma_irq_number - DMASTRM25 + 5].base = q; 
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
		return 0;
	}
	return -7;
}
 8004064:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004066:	bf00      	nop
 8004068:	20000844 	.word	0x20000844
 800406c:	40023830 	.word	0x40023830

08004070 <DMA1_Stream0_IRQHandler>:
/* IRQ vectors for DMA streams points to the following.
   The following dispatches them to the routines of interest, along with one 32b pointer. */
//                                (*(  (void (**)(void))APPJUMP)   )(            );


void DMA1_Stream0_IRQHandler (void){(*dma1[0].jmp)(dma1[0].base); return;} 
 8004070:	4a02      	ldr	r2, [pc, #8]	; (800407c <DMA1_Stream0_IRQHandler+0xc>)
 8004072:	b508      	push	{r3, lr}
 8004074:	6890      	ldr	r0, [r2, #8]
 8004076:	6853      	ldr	r3, [r2, #4]
 8004078:	4798      	blx	r3
 800407a:	bd08      	pop	{r3, pc}
 800407c:	20000844 	.word	0x20000844

08004080 <DMA1_Stream1_IRQHandler>:
void DMA1_Stream1_IRQHandler (void){(*dma1[1].jmp)(dma1[1].base); return;}	
 8004080:	4a02      	ldr	r2, [pc, #8]	; (800408c <DMA1_Stream1_IRQHandler+0xc>)
 8004082:	b508      	push	{r3, lr}
 8004084:	6910      	ldr	r0, [r2, #16]
 8004086:	68d3      	ldr	r3, [r2, #12]
 8004088:	4798      	blx	r3
 800408a:	bd08      	pop	{r3, pc}
 800408c:	20000844 	.word	0x20000844

08004090 <DMA1_Stream2_IRQHandler>:
void DMA1_Stream2_IRQHandler (void){(*dma1[2].jmp)(dma1[2].base); return;}	
 8004090:	4a02      	ldr	r2, [pc, #8]	; (800409c <DMA1_Stream2_IRQHandler+0xc>)
 8004092:	b508      	push	{r3, lr}
 8004094:	6990      	ldr	r0, [r2, #24]
 8004096:	6953      	ldr	r3, [r2, #20]
 8004098:	4798      	blx	r3
 800409a:	bd08      	pop	{r3, pc}
 800409c:	20000844 	.word	0x20000844

080040a0 <DMA1_Stream3_IRQHandler>:
void DMA1_Stream3_IRQHandler (void){(*dma1[3].jmp)(dma1[3].base); return;}	
 80040a0:	4a02      	ldr	r2, [pc, #8]	; (80040ac <DMA1_Stream3_IRQHandler+0xc>)
 80040a2:	b508      	push	{r3, lr}
 80040a4:	6a10      	ldr	r0, [r2, #32]
 80040a6:	69d3      	ldr	r3, [r2, #28]
 80040a8:	4798      	blx	r3
 80040aa:	bd08      	pop	{r3, pc}
 80040ac:	20000844 	.word	0x20000844

080040b0 <DMA1_Stream4_IRQHandler>:
void DMA1_Stream4_IRQHandler (void){(*dma1[4].jmp)(dma1[4].base); return;}	
 80040b0:	4a02      	ldr	r2, [pc, #8]	; (80040bc <DMA1_Stream4_IRQHandler+0xc>)
 80040b2:	b508      	push	{r3, lr}
 80040b4:	6a90      	ldr	r0, [r2, #40]	; 0x28
 80040b6:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80040b8:	4798      	blx	r3
 80040ba:	bd08      	pop	{r3, pc}
 80040bc:	20000844 	.word	0x20000844

080040c0 <DMA1_Stream5_IRQHandler>:
void DMA1_Stream5_IRQHandler (void){(*dma1[5].jmp)(dma1[5].base); return;}	
 80040c0:	4a02      	ldr	r2, [pc, #8]	; (80040cc <DMA1_Stream5_IRQHandler+0xc>)
 80040c2:	b508      	push	{r3, lr}
 80040c4:	6b10      	ldr	r0, [r2, #48]	; 0x30
 80040c6:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 80040c8:	4798      	blx	r3
 80040ca:	bd08      	pop	{r3, pc}
 80040cc:	20000844 	.word	0x20000844

080040d0 <DMA1_Stream6_IRQHandler>:
void DMA1_Stream6_IRQHandler (void){(*dma1[6].jmp)(dma1[6].base); return;}	
 80040d0:	4a02      	ldr	r2, [pc, #8]	; (80040dc <DMA1_Stream6_IRQHandler+0xc>)
 80040d2:	b508      	push	{r3, lr}
 80040d4:	6b90      	ldr	r0, [r2, #56]	; 0x38
 80040d6:	6b53      	ldr	r3, [r2, #52]	; 0x34
 80040d8:	4798      	blx	r3
 80040da:	bd08      	pop	{r3, pc}
 80040dc:	20000844 	.word	0x20000844

080040e0 <DMA1_Stream7_IRQHandler>:
void DMA1_Stream7_IRQHandler (void){(*dma1[7].jmp)(dma1[7].base); return;}	
 80040e0:	4a02      	ldr	r2, [pc, #8]	; (80040ec <DMA1_Stream7_IRQHandler+0xc>)
 80040e2:	b508      	push	{r3, lr}
 80040e4:	6c10      	ldr	r0, [r2, #64]	; 0x40
 80040e6:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 80040e8:	4798      	blx	r3
 80040ea:	bd08      	pop	{r3, pc}
 80040ec:	20000844 	.word	0x20000844

080040f0 <DMA2_Stream0_IRQHandler>:

void DMA2_Stream0_IRQHandler (void){(*dma2[0].jmp)(dma2[0].base); return;}	
 80040f0:	4a02      	ldr	r2, [pc, #8]	; (80040fc <DMA2_Stream0_IRQHandler+0xc>)
 80040f2:	b508      	push	{r3, lr}
 80040f4:	6cd0      	ldr	r0, [r2, #76]	; 0x4c
 80040f6:	6c93      	ldr	r3, [r2, #72]	; 0x48
 80040f8:	4798      	blx	r3
 80040fa:	bd08      	pop	{r3, pc}
 80040fc:	20000844 	.word	0x20000844

08004100 <DMA2_Stream1_IRQHandler>:
void DMA2_Stream1_IRQHandler (void){(*dma2[1].jmp)(dma2[1].base); return;}	
 8004100:	4a02      	ldr	r2, [pc, #8]	; (800410c <DMA2_Stream1_IRQHandler+0xc>)
 8004102:	b508      	push	{r3, lr}
 8004104:	6d50      	ldr	r0, [r2, #84]	; 0x54
 8004106:	6d13      	ldr	r3, [r2, #80]	; 0x50
 8004108:	4798      	blx	r3
 800410a:	bd08      	pop	{r3, pc}
 800410c:	20000844 	.word	0x20000844

08004110 <DMA2_Stream2_IRQHandler>:
void DMA2_Stream2_IRQHandler (void){(*dma2[2].jmp)(dma2[2].base); return;}	
 8004110:	4a02      	ldr	r2, [pc, #8]	; (800411c <DMA2_Stream2_IRQHandler+0xc>)
 8004112:	b508      	push	{r3, lr}
 8004114:	6dd0      	ldr	r0, [r2, #92]	; 0x5c
 8004116:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8004118:	4798      	blx	r3
 800411a:	bd08      	pop	{r3, pc}
 800411c:	20000844 	.word	0x20000844

08004120 <DMA2_Stream3_IRQHandler>:
void DMA2_Stream3_IRQHandler (void){(*dma2[3].jmp)(dma2[3].base); return;}	
 8004120:	4a02      	ldr	r2, [pc, #8]	; (800412c <DMA2_Stream3_IRQHandler+0xc>)
 8004122:	b508      	push	{r3, lr}
 8004124:	6e50      	ldr	r0, [r2, #100]	; 0x64
 8004126:	6e13      	ldr	r3, [r2, #96]	; 0x60
 8004128:	4798      	blx	r3
 800412a:	bd08      	pop	{r3, pc}
 800412c:	20000844 	.word	0x20000844

08004130 <DMA2_Stream4_IRQHandler>:
void DMA2_Stream4_IRQHandler (void){(*dma2[4].jmp)(dma2[4].base); return;}	
 8004130:	4a02      	ldr	r2, [pc, #8]	; (800413c <DMA2_Stream4_IRQHandler+0xc>)
 8004132:	b508      	push	{r3, lr}
 8004134:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8004136:	6e93      	ldr	r3, [r2, #104]	; 0x68
 8004138:	4798      	blx	r3
 800413a:	bd08      	pop	{r3, pc}
 800413c:	20000844 	.word	0x20000844

08004140 <DMA2_Stream5_IRQHandler>:

void DMA2_Stream5_IRQHandler (void){(*dma2[5].jmp)(dma2[5].base); return;}
 8004140:	4a02      	ldr	r2, [pc, #8]	; (800414c <DMA2_Stream5_IRQHandler+0xc>)
 8004142:	b508      	push	{r3, lr}
 8004144:	6f50      	ldr	r0, [r2, #116]	; 0x74
 8004146:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8004148:	4798      	blx	r3
 800414a:	bd08      	pop	{r3, pc}
 800414c:	20000844 	.word	0x20000844

08004150 <DMA2_Stream6_IRQHandler>:
void DMA2_Stream6_IRQHandler (void){(*dma2[6].jmp)(dma2[6].base); return;}	
 8004150:	4a02      	ldr	r2, [pc, #8]	; (800415c <DMA2_Stream6_IRQHandler+0xc>)
 8004152:	b508      	push	{r3, lr}
 8004154:	6fd0      	ldr	r0, [r2, #124]	; 0x7c
 8004156:	6f93      	ldr	r3, [r2, #120]	; 0x78
 8004158:	4798      	blx	r3
 800415a:	bd08      	pop	{r3, pc}
 800415c:	20000844 	.word	0x20000844

08004160 <DMA2_Stream7_IRQHandler>:
void DMA2_Stream7_IRQHandler (void){(*dma2[7].jmp)(dma2[7].base); return;}	
 8004160:	4a03      	ldr	r2, [pc, #12]	; (8004170 <DMA2_Stream7_IRQHandler+0x10>)
 8004162:	b508      	push	{r3, lr}
 8004164:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84
 8004168:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 800416c:	4798      	blx	r3
 800416e:	bd08      	pop	{r3, pc}
 8004170:	20000844 	.word	0x20000844

08004174 <rxbuff_adv>:
 * @param	: pctl = pointer to control block
 * @param	: p = pointer to be advanced
 * @return	: new pointer 'p'
*******************************************************************************/
static u8* rxbuff_adv (struct CB_UART* pctl, u8* p)
{
 8004174:	4603      	mov	r3, r0
	p += 1; if (p >= pctl->rxbuff_end) p = pctl->rxbuff_base;
 8004176:	1c48      	adds	r0, r1, #1
 8004178:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800417a:	4290      	cmp	r0, r2
 800417c:	bf28      	it	cs
 800417e:	6ad8      	ldrcs	r0, [r3, #44]	; 0x2c
	return p;
}
 8004180:	4770      	bx	lr

08004182 <txbuff_adv>:
 * @param	: pctl = pointer to control block
 * @param	: p = pointer to be advanced
 * @return	: new pointer 'p'
*******************************************************************************/
static u8* txbuff_adv (struct CB_UART* pctl, u8* p)
{
 8004182:	4603      	mov	r3, r0
	p += 1; if (p >= pctl->txbuff_end) p = pctl->txbuff_base;
 8004184:	1c48      	adds	r0, r1, #1
 8004186:	699a      	ldr	r2, [r3, #24]
 8004188:	4290      	cmp	r0, r2
 800418a:	bf28      	it	cs
 800418c:	6958      	ldrcs	r0, [r3, #20]
	return p;
}
 800418e:	4770      	bx	lr

08004190 <common_dma>:
   routine. */
	int tmp;
	u8* ptmp;

	/* Are there bytes buffered? (Certainly yes if entered from mainline.) */  
	tmp = (pctl->txbuff_in - pctl->txbuff_out);
 8004190:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8004192:	6a02      	ldr	r2, [r0, #32]
 8004194:	1ad2      	subs	r2, r2, r3
	if (tmp == 0) return;	
 8004196:	2a00      	cmp	r2, #0
 * @brief	: Set up a disabled (idle) DMA to send if there are byte buffered
 * @param	: pctl = pointer to uart control block
 *####################################################################################### */

static void common_dma(struct CB_UART* pctl)
{
 8004198:	b530      	push	{r4, r5, lr}
	int tmp;
	u8* ptmp;

	/* Are there bytes buffered? (Certainly yes if entered from mainline.) */  
	tmp = (pctl->txbuff_in - pctl->txbuff_out);
	if (tmp == 0) return;	
 800419a:	d022      	beq.n	80041e2 <common_dma+0x52>
 800419c:	68c1      	ldr	r1, [r0, #12]

	if (tmp < 0)	// Wrap around check.
 800419e:	da07      	bge.n	80041b0 <common_dma+0x20>
	{ // Here, there is wrap-around, so send what remains in (non-circular) buffer.
	  // (Upon the next DMA interrupt what remains after the wrap-around will be sent.)

		// Compute number of bytes remaining to the end of the buffer
		tmp = (pctl->txbuff_end - pctl->txbuff_out); 			// Remaining ct
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; 	// Set TX mem address
 80041a0:	6804      	ldr	r4, [r0, #0]
	if (tmp < 0)	// Wrap around check.
	{ // Here, there is wrap-around, so send what remains in (non-circular) buffer.
	  // (Upon the next DMA interrupt what remains after the wrap-around will be sent.)

		// Compute number of bytes remaining to the end of the buffer
		tmp = (pctl->txbuff_end - pctl->txbuff_out); 			// Remaining ct
 80041a2:	6982      	ldr	r2, [r0, #24]
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; 	// Set TX mem address
 80041a4:	2518      	movs	r5, #24
 80041a6:	fb05 4101 	mla	r1, r5, r1, r4
	if (tmp < 0)	// Wrap around check.
	{ // Here, there is wrap-around, so send what remains in (non-circular) buffer.
	  // (Upon the next DMA interrupt what remains after the wrap-around will be sent.)

		// Compute number of bytes remaining to the end of the buffer
		tmp = (pctl->txbuff_end - pctl->txbuff_out); 			// Remaining ct
 80041aa:	1ad2      	subs	r2, r2, r3
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; 	// Set TX mem address
 80041ac:	61cb      	str	r3, [r1, #28]
 80041ae:	e008      	b.n	80041c2 <common_dma+0x32>
		pctl->txbuff_dmanext = pctl->txbuff_base;				// Save new start ptr
	}
	else
	{ // Here, no wrap around, so all buffered bytes can be sent with one setting
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; // Set TX mem address
 80041b0:	6804      	ldr	r4, [r0, #0]
 80041b2:	2518      	movs	r5, #24
 80041b4:	fb05 4101 	mla	r1, r5, r1, r4
 80041b8:	61cb      	str	r3, [r1, #28]
// redundant	tmp = pctl->txbuff_in - pctl->txbuff_out);		// Number of bytes to send
		ptmp = tmp + pctl->txbuff_out;
		if (ptmp >= pctl->txbuff_end)
 80041ba:	6981      	ldr	r1, [r0, #24]
	}
	else
	{ // Here, no wrap around, so all buffered bytes can be sent with one setting
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; // Set TX mem address
// redundant	tmp = pctl->txbuff_in - pctl->txbuff_out);		// Number of bytes to send
		ptmp = tmp + pctl->txbuff_out;
 80041bc:	189b      	adds	r3, r3, r2
		if (ptmp >= pctl->txbuff_end)
 80041be:	428b      	cmp	r3, r1
 80041c0:	d300      	bcc.n	80041c4 <common_dma+0x34>
			ptmp = pctl->txbuff_base;
 80041c2:	6943      	ldr	r3, [r0, #20]
		pctl->txbuff_dmanext = ptmp;				// Save new start ptr
	}

	DMA_SNDTR(pctl->idma,pctl->txdma_stream)  = tmp;		// Set number of bytes
 80041c4:	6804      	ldr	r4, [r0, #0]
 80041c6:	68c1      	ldr	r1, [r0, #12]
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; // Set TX mem address
// redundant	tmp = pctl->txbuff_in - pctl->txbuff_out);		// Number of bytes to send
		ptmp = tmp + pctl->txbuff_out;
		if (ptmp >= pctl->txbuff_end)
			ptmp = pctl->txbuff_base;
		pctl->txbuff_dmanext = ptmp;				// Save new start ptr
 80041c8:	6283      	str	r3, [r0, #40]	; 0x28
	}

	DMA_SNDTR(pctl->idma,pctl->txdma_stream)  = tmp;		// Set number of bytes
 80041ca:	2318      	movs	r3, #24
 80041cc:	4359      	muls	r1, r3
 80041ce:	3414      	adds	r4, #20
 80041d0:	5062      	str	r2, [r4, r1]
	DMA_SCR (pctl->idma,pctl->txdma_stream) |= 0x1;		// Enable DMA and away we go!
 80041d2:	6802      	ldr	r2, [r0, #0]
 80041d4:	68c1      	ldr	r1, [r0, #12]
 80041d6:	3210      	adds	r2, #16
 80041d8:	434b      	muls	r3, r1
 80041da:	58d1      	ldr	r1, [r2, r3]
 80041dc:	f041 0101 	orr.w	r1, r1, #1
 80041e0:	50d1      	str	r1, [r2, r3]
 80041e2:	bd30      	pop	{r4, r5, pc}

080041e4 <DMA_UART_IRQHandler>:
{
	/* The following is for consistency in the code in this file. ('nvic_dma_mgr.c' uses volatile u32*) */
	struct CB_UART* pctl = (struct CB_UART*)pall;

	/* Clear all interrupt flags for this DMA stream */
	if (pctl->txdma_stream > 3)
 80041e4:	68c3      	ldr	r3, [r0, #12]
 80041e6:	4a0a      	ldr	r2, [pc, #40]	; (8004210 <DMA_UART_IRQHandler+0x2c>)
 80041e8:	2b03      	cmp	r3, #3
 80041ea:	d908      	bls.n	80041fe <DMA_UART_IRQHandler+0x1a>
	{// High register
		DMA_HIFCR(pctl->idma) = (0x3d << tcif_tbl[pctl->txdma_stream-4]);
 80041ec:	18d3      	adds	r3, r2, r3
 80041ee:	6801      	ldr	r1, [r0, #0]
 80041f0:	f813 3c04 	ldrb.w	r3, [r3, #-4]
 80041f4:	223d      	movs	r2, #61	; 0x3d
 80041f6:	fa12 f303 	lsls.w	r3, r2, r3
 80041fa:	60cb      	str	r3, [r1, #12]
 80041fc:	e005      	b.n	800420a <DMA_UART_IRQHandler+0x26>
	}
	else
	{ // Low register
		DMA_LIFCR(pctl->idma) = (0x3d << tcif_tbl[pctl->txdma_stream]);
 80041fe:	5cd3      	ldrb	r3, [r2, r3]
 8004200:	6801      	ldr	r1, [r0, #0]
 8004202:	223d      	movs	r2, #61	; 0x3d
 8004204:	fa12 f303 	lsls.w	r3, r2, r3
 8004208:	608b      	str	r3, [r1, #8]
	}
	pctl->txbuff_out = pctl->txbuff_dmanext; // Update where in the buffer we have xmitted
 800420a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800420c:	6243      	str	r3, [r0, #36]	; 0x24

	/* Here, check if there are bytes buffered and if so, figure out how to send them. */
	common_dma(pctl);
 800420e:	e7bf      	b.n	8004190 <common_dma>
 8004210:	0800b740 	.word	0x0800b740

08004214 <bsp_panic>:
static void common_dma(struct CB_UART* pctl);

/* Error trapping */
int PANIC_x;	// Global variable to look at.
void bsp_panic (int x)
{ PANIC_x = x; panic_leds(7); } // Save code, and flash LEDs 7x
 8004214:	4b02      	ldr	r3, [pc, #8]	; (8004220 <bsp_panic+0xc>)
 8004216:	6018      	str	r0, [r3, #0]
 8004218:	2007      	movs	r0, #7
 800421a:	f7ff bc92 	b.w	8003b42 <panic_leds>
 800421e:	bf00      	nop
 8004220:	200008cc 	.word	0x200008cc

08004224 <mapindex>:
 * @brief	: Edit & Map register base address to control block index & enable APBxENR
 * @param	: p = pointer to register base
 * @return	: 0 - 7 = OK; panic_leds for fail
******************************************************************************/	
static int mapindex(volatile u32 iuart)
{
 8004224:	b507      	push	{r0, r1, r2, lr}
 8004226:	9001      	str	r0, [sp, #4]
	int idx;

	/* Index v register base */
	switch (iuart)
 8004228:	9b01      	ldr	r3, [sp, #4]
 800422a:	4a21      	ldr	r2, [pc, #132]	; (80042b0 <mapindex+0x8c>)
 800422c:	4293      	cmp	r3, r2
 800422e:	d030      	beq.n	8004292 <mapindex+0x6e>
 8004230:	d806      	bhi.n	8004240 <mapindex+0x1c>
 8004232:	4a20      	ldr	r2, [pc, #128]	; (80042b4 <mapindex+0x90>)
 8004234:	4293      	cmp	r3, r2
 8004236:	d01e      	beq.n	8004276 <mapindex+0x52>
 8004238:	4a1f      	ldr	r2, [pc, #124]	; (80042b8 <mapindex+0x94>)
 800423a:	4293      	cmp	r3, r2
 800423c:	d109      	bne.n	8004252 <mapindex+0x2e>
 800423e:	e021      	b.n	8004284 <mapindex+0x60>
 8004240:	4a1e      	ldr	r2, [pc, #120]	; (80042bc <mapindex+0x98>)
 8004242:	4293      	cmp	r3, r2
 8004244:	d009      	beq.n	800425a <mapindex+0x36>
 8004246:	4a1e      	ldr	r2, [pc, #120]	; (80042c0 <mapindex+0x9c>)
 8004248:	4293      	cmp	r3, r2
 800424a:	d00d      	beq.n	8004268 <mapindex+0x44>
 800424c:	4a1d      	ldr	r2, [pc, #116]	; (80042c4 <mapindex+0xa0>)
 800424e:	4293      	cmp	r3, r2
 8004250:	d026      	beq.n	80042a0 <mapindex+0x7c>
	case UART4:	idx =  3; break;
	case UART5:	idx =  4; break;
	case USART6:	idx =  5; break;

	default:
		bsp_panic(-61);	// No match for request
 8004252:	f06f 003c 	mvn.w	r0, #60	; 0x3c
 8004256:	f7ff ffdd 	bl	8004214 <bsp_panic>
	}
	/* Enable USART/UART module on appropriate bus */
	switch (idx)
	{
	case 0:	RCC_AHB2ENR |= (1 << 4); break;
 800425a:	4b1b      	ldr	r3, [pc, #108]	; (80042c8 <mapindex+0xa4>)
 800425c:	681a      	ldr	r2, [r3, #0]
 800425e:	f042 0210 	orr.w	r2, r2, #16
 8004262:	601a      	str	r2, [r3, #0]
 8004264:	2000      	movs	r0, #0
 8004266:	e021      	b.n	80042ac <mapindex+0x88>
	case 5:	RCC_AHB2ENR |= (1 << 5); break;	
 8004268:	4b17      	ldr	r3, [pc, #92]	; (80042c8 <mapindex+0xa4>)
 800426a:	681a      	ldr	r2, [r3, #0]
 800426c:	f042 0220 	orr.w	r2, r2, #32
 8004270:	601a      	str	r2, [r3, #0]
 8004272:	2005      	movs	r0, #5
 8004274:	e01a      	b.n	80042ac <mapindex+0x88>

	case 1:	RCC_AHB1ENR |= (1 << 17); break;
 8004276:	4b15      	ldr	r3, [pc, #84]	; (80042cc <mapindex+0xa8>)
 8004278:	681a      	ldr	r2, [r3, #0]
 800427a:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800427e:	601a      	str	r2, [r3, #0]
 8004280:	2001      	movs	r0, #1
 8004282:	e013      	b.n	80042ac <mapindex+0x88>
	case 2:	RCC_AHB1ENR |= (1 << 18); break;
 8004284:	4b11      	ldr	r3, [pc, #68]	; (80042cc <mapindex+0xa8>)
 8004286:	681a      	ldr	r2, [r3, #0]
 8004288:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800428c:	601a      	str	r2, [r3, #0]
 800428e:	2002      	movs	r0, #2
 8004290:	e00c      	b.n	80042ac <mapindex+0x88>
	case 3:	RCC_AHB1ENR |= (1 << 19); break;
 8004292:	4b0e      	ldr	r3, [pc, #56]	; (80042cc <mapindex+0xa8>)
 8004294:	681a      	ldr	r2, [r3, #0]
 8004296:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 800429a:	601a      	str	r2, [r3, #0]
 800429c:	2003      	movs	r0, #3
 800429e:	e005      	b.n	80042ac <mapindex+0x88>
	case 4:	RCC_AHB1ENR |= (1 << 20); break;
 80042a0:	4b0a      	ldr	r3, [pc, #40]	; (80042cc <mapindex+0xa8>)
 80042a2:	681a      	ldr	r2, [r3, #0]
 80042a4:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 80042a8:	601a      	str	r2, [r3, #0]
 80042aa:	2004      	movs	r0, #4
	default:
		bsp_panic(-62);	// Wrong
	}

	return idx;
}
 80042ac:	bd0e      	pop	{r1, r2, r3, pc}
 80042ae:	bf00      	nop
 80042b0:	40004c00 	.word	0x40004c00
 80042b4:	40004400 	.word	0x40004400
 80042b8:	40004800 	.word	0x40004800
 80042bc:	40011000 	.word	0x40011000
 80042c0:	40011400 	.word	0x40011400
 80042c4:	40005000 	.word	0x40005000
 80042c8:	40023834 	.word	0x40023834
 80042cc:	40023830 	.word	0x40023830

080042d0 <getbuff>:
 * @param	: rxbuffsize = requested size of rx buffer
 * @param	: txbuffsize = requested size of rx buffer
 * @return	: 0 = OK; -1; fail = led trap
******************************************************************************/	
static int getbuff(int idx, u32 rxbuffsize, u32 txbuffsize)
{
 80042d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80042d2:	4604      	mov	r4, r0
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
 80042d4:	4f13      	ldr	r7, [pc, #76]	; (8004324 <getbuff+0x54>)
 80042d6:	4608      	mov	r0, r1
 * @param	: rxbuffsize = requested size of rx buffer
 * @param	: txbuffsize = requested size of rx buffer
 * @return	: 0 = OK; -1; fail = led trap
******************************************************************************/	
static int getbuff(int idx, u32 rxbuffsize, u32 txbuffsize)
{
 80042d8:	460d      	mov	r5, r1
 80042da:	4616      	mov	r6, r2
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
 80042dc:	f000 fcd0 	bl	8004c80 <malloc>
 80042e0:	01a3      	lsls	r3, r4, #6
 80042e2:	18fb      	adds	r3, r7, r3
 80042e4:	6318      	str	r0, [r3, #48]	; 0x30
 80042e6:	b910      	cbnz	r0, 80042ee <getbuff+0x1e>
 80042e8:	380d      	subs	r0, #13
 80042ea:	f7ff ff93 	bl	8004214 <bsp_panic>
	if ((cb_uart[idx].txbuff_base = malloc(txbuffsize)) == NULL) bsp_panic(-14);	// malloc failed to obtain tx buffer
 80042ee:	4630      	mov	r0, r6
 80042f0:	f000 fcc6 	bl	8004c80 <malloc>
 80042f4:	01a4      	lsls	r4, r4, #6
 80042f6:	193b      	adds	r3, r7, r4
 80042f8:	6198      	str	r0, [r3, #24]
 80042fa:	b910      	cbnz	r0, 8004302 <getbuff+0x32>
 80042fc:	380e      	subs	r0, #14
 80042fe:	f7ff ff89 	bl	8004214 <bsp_panic>
	cb_uart[idx].rxbuff_end  = cb_uart[idx].rxbuff_base + rxbuffsize;
 8004302:	193c      	adds	r4, r7, r4
	cb_uart[idx].txbuff_dmanext = cb_uart[idx].txbuff_base;
	cb_uart[idx].rxbuff_in   = cb_uart[idx].rxbuff_base;
	cb_uart[idx].txbuff_in   = cb_uart[idx].txbuff_base;
	
	return 0;
}
 8004304:	2000      	movs	r0, #0
static int getbuff(int idx, u32 rxbuffsize, u32 txbuffsize)
{
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
	if ((cb_uart[idx].txbuff_base = malloc(txbuffsize)) == NULL) bsp_panic(-14);	// malloc failed to obtain tx buffer
	cb_uart[idx].rxbuff_end  = cb_uart[idx].rxbuff_base + rxbuffsize;
 8004306:	6b22      	ldr	r2, [r4, #48]	; 0x30
	cb_uart[idx].txbuff_end  = cb_uart[idx].txbuff_base + txbuffsize;
	cb_uart[idx].rxbuff_size = rxbuffsize;
 8004308:	63a5      	str	r5, [r4, #56]	; 0x38
static int getbuff(int idx, u32 rxbuffsize, u32 txbuffsize)
{
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
	if ((cb_uart[idx].txbuff_base = malloc(txbuffsize)) == NULL) bsp_panic(-14);	// malloc failed to obtain tx buffer
	cb_uart[idx].rxbuff_end  = cb_uart[idx].rxbuff_base + rxbuffsize;
 800430a:	1953      	adds	r3, r2, r5
 800430c:	6363      	str	r3, [r4, #52]	; 0x34
	cb_uart[idx].txbuff_end  = cb_uart[idx].txbuff_base + txbuffsize;
 800430e:	69a3      	ldr	r3, [r4, #24]
	cb_uart[idx].rxbuff_size = rxbuffsize;
	cb_uart[idx].txbuff_size = txbuffsize;
 8004310:	6226      	str	r6, [r4, #32]
{
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
	if ((cb_uart[idx].txbuff_base = malloc(txbuffsize)) == NULL) bsp_panic(-14);	// malloc failed to obtain tx buffer
	cb_uart[idx].rxbuff_end  = cb_uart[idx].rxbuff_base + rxbuffsize;
	cb_uart[idx].txbuff_end  = cb_uart[idx].txbuff_base + txbuffsize;
 8004312:	1999      	adds	r1, r3, r6
 8004314:	61e1      	str	r1, [r4, #28]
	cb_uart[idx].rxbuff_size = rxbuffsize;
	cb_uart[idx].txbuff_size = txbuffsize;
	cb_uart[idx].rxbuff_out  = cb_uart[idx].rxbuff_base;
 8004316:	6422      	str	r2, [r4, #64]	; 0x40
	cb_uart[idx].txbuff_out  = cb_uart[idx].txbuff_base;
 8004318:	62a3      	str	r3, [r4, #40]	; 0x28
	cb_uart[idx].txbuff_dmanext = cb_uart[idx].txbuff_base;
 800431a:	62e3      	str	r3, [r4, #44]	; 0x2c
	cb_uart[idx].rxbuff_in   = cb_uart[idx].rxbuff_base;
 800431c:	63e2      	str	r2, [r4, #60]	; 0x3c
	cb_uart[idx].txbuff_in   = cb_uart[idx].txbuff_base;
 800431e:	6263      	str	r3, [r4, #36]	; 0x24
	
	return 0;
}
 8004320:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004322:	bf00      	nop
 8004324:	200008cc 	.word	0x200008cc

08004328 <uartnumber_to_baseaddr>:
*******************************************************************************/
static u32 uartnumber_to_baseaddr(u32 uartnumber)
{
	u32 iuart = 0;
	/* Convert uart number to uart register base address */
	switch (uartnumber)
 8004328:	3801      	subs	r0, #1
 * @brief	: Map uart number (1-6) to uart module base address
 * @param	: uartnumber = (1 -6), e.g. 2 = USART2
 * @return	: USART/UART base address, e.g. USART2 = 0x40004400
*******************************************************************************/
static u32 uartnumber_to_baseaddr(u32 uartnumber)
{
 800432a:	b508      	push	{r3, lr}
	u32 iuart = 0;
	/* Convert uart number to uart register base address */
	switch (uartnumber)
 800432c:	2805      	cmp	r0, #5
 800432e:	d80e      	bhi.n	800434e <uartnumber_to_baseaddr+0x26>
 8004330:	e8df f000 	tbb	[pc, r0]
 8004334:	07051303 	.word	0x07051303
 8004338:	0b09      	.short	0x0b09
	{
	case 1:	iuart = USART1;	break;
 800433a:	4809      	ldr	r0, [pc, #36]	; (8004360 <uartnumber_to_baseaddr+0x38>)
 800433c:	bd08      	pop	{r3, pc}
	case 2:	iuart = USART2;	break;
	case 3:	iuart = USART3;	break;
 800433e:	4809      	ldr	r0, [pc, #36]	; (8004364 <uartnumber_to_baseaddr+0x3c>)
 8004340:	bd08      	pop	{r3, pc}
	case 4:	iuart =  UART4;	break;
 8004342:	4809      	ldr	r0, [pc, #36]	; (8004368 <uartnumber_to_baseaddr+0x40>)
 8004344:	bd08      	pop	{r3, pc}
	case 5:	iuart =  UART5;	break;
 8004346:	4809      	ldr	r0, [pc, #36]	; (800436c <uartnumber_to_baseaddr+0x44>)
 8004348:	bd08      	pop	{r3, pc}
	case 6:	iuart = USART6;	break;
 800434a:	4809      	ldr	r0, [pc, #36]	; (8004370 <uartnumber_to_baseaddr+0x48>)
 800434c:	bd08      	pop	{r3, pc}

	default:
		bsp_panic(-66);	// No match for request
 800434e:	f06f 0041 	mvn.w	r0, #65	; 0x41
 8004352:	f7ff ff5f 	bl	8004214 <bsp_panic>
 * @param	: uartnumber = (1 -6), e.g. 2 = USART2
 * @return	: USART/UART base address, e.g. USART2 = 0x40004400
*******************************************************************************/
static u32 uartnumber_to_baseaddr(u32 uartnumber)
{
	u32 iuart = 0;
 8004356:	2000      	movs	r0, #0
 8004358:	bd08      	pop	{r3, pc}
	/* Convert uart number to uart register base address */
	switch (uartnumber)
	{
	case 1:	iuart = USART1;	break;
	case 2:	iuart = USART2;	break;
 800435a:	4806      	ldr	r0, [pc, #24]	; (8004374 <uartnumber_to_baseaddr+0x4c>)
	default:
		bsp_panic(-66);	// No match for request
	}	
	return iuart;

}
 800435c:	bd08      	pop	{r3, pc}
 800435e:	bf00      	nop
 8004360:	40011000 	.word	0x40011000
 8004364:	40004800 	.word	0x40004800
 8004368:	40004c00 	.word	0x40004c00
 800436c:	40005000 	.word	0x40005000
 8004370:	40011400 	.word	0x40011400
 8004374:	40004400 	.word	0x40004400

08004378 <irq_given_datastream>:
{
	u32	dma;
	int	num;
};
static struct IRQNUM irq_given_datastream(u32 iuart, int dmastream)
{
 8004378:	b570      	push	{r4, r5, r6, lr}
	struct IRQNUM irqnum = {0,0}; 
	if (dmastream < 0) bsp_panic(-714);
 800437a:	1e16      	subs	r6, r2, #0
{
	u32	dma;
	int	num;
};
static struct IRQNUM irq_given_datastream(u32 iuart, int dmastream)
{
 800437c:	4604      	mov	r4, r0
 800437e:	460d      	mov	r5, r1
	struct IRQNUM irqnum = {0,0}; 
	if (dmastream < 0) bsp_panic(-714);
 8004380:	da02      	bge.n	8004388 <irq_given_datastream+0x10>
 8004382:	480f      	ldr	r0, [pc, #60]	; (80043c0 <irq_given_datastream+0x48>)
 8004384:	f7ff ff46 	bl	8004214 <bsp_panic>

	if ((iuart == USART1) || (iuart == USART6))
 8004388:	4b0e      	ldr	r3, [pc, #56]	; (80043c4 <irq_given_datastream+0x4c>)
 800438a:	429d      	cmp	r5, r3
 800438c:	d002      	beq.n	8004394 <irq_given_datastream+0x1c>
 800438e:	4b0e      	ldr	r3, [pc, #56]	; (80043c8 <irq_given_datastream+0x50>)
 8004390:	429d      	cmp	r5, r3
 8004392:	d108      	bne.n	80043a6 <irq_given_datastream+0x2e>
	{
		irqnum.dma = DMA2_BASE;
		if (dmastream > 4)	// Determine IRQ number for the stream 
 8004394:	2e04      	cmp	r6, #4
 8004396:	4b0d      	ldr	r3, [pc, #52]	; (80043cc <irq_given_datastream+0x54>)
 8004398:	dd02      	ble.n	80043a0 <irq_given_datastream+0x28>
 800439a:	6023      	str	r3, [r4, #0]
		{ irqnum.num = (DMASTRM25 + dmastream - 5); return irqnum;}
 800439c:	363f      	adds	r6, #63	; 0x3f
 800439e:	e00b      	b.n	80043b8 <irq_given_datastream+0x40>
 80043a0:	6023      	str	r3, [r4, #0]
		else
		{ irqnum.num = (DMASTRM20 + dmastream); return irqnum;}
 80043a2:	3638      	adds	r6, #56	; 0x38
 80043a4:	e008      	b.n	80043b8 <irq_given_datastream+0x40>
	}

	irqnum.dma = DMA1_BASE;
	if (dmastream == 7)
 80043a6:	2e07      	cmp	r6, #7
 80043a8:	4b09      	ldr	r3, [pc, #36]	; (80043d0 <irq_given_datastream+0x58>)
 80043aa:	d103      	bne.n	80043b4 <irq_given_datastream+0x3c>
 80043ac:	6023      	str	r3, [r4, #0]
 80043ae:	232f      	movs	r3, #47	; 0x2f
 80043b0:	6063      	str	r3, [r4, #4]
		{ irqnum.num = (DMASTRM17); return irqnum;}
 80043b2:	e002      	b.n	80043ba <irq_given_datastream+0x42>
 80043b4:	6023      	str	r3, [r4, #0]
	else
		{ irqnum.num = (DMASTRM10 + dmastream); return irqnum;}
 80043b6:	360b      	adds	r6, #11
		{ irqnum.num = (DMASTRM20 + dmastream); return irqnum;}
	}

	irqnum.dma = DMA1_BASE;
	if (dmastream == 7)
		{ irqnum.num = (DMASTRM17); return irqnum;}
 80043b8:	6066      	str	r6, [r4, #4]
	else
		{ irqnum.num = (DMASTRM10 + dmastream); return irqnum;}

	bsp_panic(-715);	// Shouldn't happen
	return irqnum;
}
 80043ba:	4620      	mov	r0, r4
 80043bc:	bd70      	pop	{r4, r5, r6, pc}
 80043be:	bf00      	nop
 80043c0:	fffffd36 	.word	0xfffffd36
 80043c4:	40011000 	.word	0x40011000
 80043c8:	40011400 	.word	0x40011400
 80043cc:	40026400 	.word	0x40026400
 80043d0:	40026000 	.word	0x40026000

080043d4 <bsp_uart_open>:
 * @return	: control block pointer
******************************************************************************/	
static const char* open_name[8] = {"tty1", "tty2", "tty3", "tty4", "tty5", "tty6", "tty7", "tty8"};

struct CB_UART* bsp_uart_open(const char *name)
{
 80043d4:	b570      	push	{r4, r5, r6, lr}
	int i;
	for (i = 0; i < 8; i++)
	{
		if (strcmp(name, open_name[i]) == 0) break;
	}
	if (i >= 8) return (struct CB_UART*)-1;
 80043d6:	4d09      	ldr	r5, [pc, #36]	; (80043fc <bsp_uart_open+0x28>)
 * @return	: control block pointer
******************************************************************************/	
static const char* open_name[8] = {"tty1", "tty2", "tty3", "tty4", "tty5", "tty6", "tty7", "tty8"};

struct CB_UART* bsp_uart_open(const char *name)
{
 80043d8:	4606      	mov	r6, r0
	int i;
	for (i = 0; i < 8; i++)
 80043da:	2400      	movs	r4, #0
	{
		if (strcmp(name, open_name[i]) == 0) break;
 80043dc:	4630      	mov	r0, r6
 80043de:	f855 1f04 	ldr.w	r1, [r5, #4]!
 80043e2:	f000 ffd1 	bl	8005388 <strcmp>
 80043e6:	b128      	cbz	r0, 80043f4 <bsp_uart_open+0x20>
static const char* open_name[8] = {"tty1", "tty2", "tty3", "tty4", "tty5", "tty6", "tty7", "tty8"};

struct CB_UART* bsp_uart_open(const char *name)
{
	int i;
	for (i = 0; i < 8; i++)
 80043e8:	3401      	adds	r4, #1
 80043ea:	2c08      	cmp	r4, #8
 80043ec:	d1f6      	bne.n	80043dc <bsp_uart_open+0x8>
	{
		if (strcmp(name, open_name[i]) == 0) break;
	}
	if (i >= 8) return (struct CB_UART*)-1;
 80043ee:	f04f 30ff 	mov.w	r0, #4294967295
 80043f2:	bd70      	pop	{r4, r5, r6, pc}
	
	return &cb_uart[i];	// Return control block ptr to 'open'
 80043f4:	4802      	ldr	r0, [pc, #8]	; (8004400 <bsp_uart_open+0x2c>)
 80043f6:	01a4      	lsls	r4, r4, #6
 80043f8:	1900      	adds	r0, r0, r4
}
 80043fa:	bd70      	pop	{r4, r5, r6, pc}
 80043fc:	0800b740 	.word	0x0800b740
 8004400:	200008d0 	.word	0x200008d0

08004404 <bsp_uart_dma_init>:
 * @param	: dmastreamtx: DMA stream number for TX (0 - 7)
 * @param	: dma_tx_int_priority: interrupt priority, (0x00 - 0xf0) e.g. 0xc0, low 4 bits zero
 * @return	: 0 = success; fail traps to 'panic_leds'
*******************************************************************************/
int bsp_uart_dma_init(u32 iuart, u32 baud, u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority)
{
 8004404:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004408:	b08b      	sub	sp, #44	; 0x2c
 800440a:	4604      	mov	r4, r0
 800440c:	9f14      	ldr	r7, [sp, #80]	; 0x50
 800440e:	9101      	str	r1, [sp, #4]
	u32 dma_channel_number_rx = 4;	// Initialize to prevent compiler warning
	u32 dma_channel_number_tx = 5;	


	/* Be sure arguments passed are within range */
	if (dmastreamrx > 7) bsp_panic(-1);
 8004410:	2f07      	cmp	r7, #7
 * @param	: dmastreamtx: DMA stream number for TX (0 - 7)
 * @param	: dma_tx_int_priority: interrupt priority, (0x00 - 0xf0) e.g. 0xc0, low 4 bits zero
 * @return	: 0 = success; fail traps to 'panic_leds'
*******************************************************************************/
int bsp_uart_dma_init(u32 iuart, u32 baud, u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority)
{
 8004412:	9202      	str	r2, [sp, #8]
 8004414:	9303      	str	r3, [sp, #12]
 8004416:	f8dd a054 	ldr.w	sl, [sp, #84]	; 0x54
	u32 dma_channel_number_rx = 4;	// Initialize to prevent compiler warning
	u32 dma_channel_number_tx = 5;	


	/* Be sure arguments passed are within range */
	if (dmastreamrx > 7) bsp_panic(-1);
 800441a:	d903      	bls.n	8004424 <bsp_uart_dma_init+0x20>
 800441c:	f04f 30ff 	mov.w	r0, #4294967295
 8004420:	f7ff fef8 	bl	8004214 <bsp_panic>
	if (dmastreamtx > 7) bsp_panic(-2);
 8004424:	f1ba 0f07 	cmp.w	sl, #7
 8004428:	d903      	bls.n	8004432 <bsp_uart_dma_init+0x2e>
 800442a:	f06f 0001 	mvn.w	r0, #1
 800442e:	f7ff fef1 	bl	8004214 <bsp_panic>
	if ((dma_tx_int_priority & 0xffffff0f) != 0) bsp_panic(-3); // Bogus priority
 8004432:	9916      	ldr	r1, [sp, #88]	; 0x58
 8004434:	f031 01f0 	bics.w	r1, r1, #240	; 0xf0
 8004438:	d003      	beq.n	8004442 <bsp_uart_dma_init+0x3e>
 800443a:	f06f 0002 	mvn.w	r0, #2
 800443e:	f7ff fee9 	bl	8004214 <bsp_panic>
	
	cb_Idx = mapindex(iuart);	// Map usart/uart register base to control block index
 8004442:	4620      	mov	r0, r4
 8004444:	f7ff feee 	bl	8004224 <mapindex>

	/* Convert dma stream to dma base and irq number */
	dma_irq_number_tx = irq_given_datastream(iuart, dmastreamtx); // TX
 8004448:	4621      	mov	r1, r4
 800444a:	4652      	mov	r2, sl
	/* Be sure arguments passed are within range */
	if (dmastreamrx > 7) bsp_panic(-1);
	if (dmastreamtx > 7) bsp_panic(-2);
	if ((dma_tx_int_priority & 0xffffff0f) != 0) bsp_panic(-3); // Bogus priority
	
	cb_Idx = mapindex(iuart);	// Map usart/uart register base to control block index
 800444c:	4683      	mov	fp, r0

	/* Convert dma stream to dma base and irq number */
	dma_irq_number_tx = irq_given_datastream(iuart, dmastreamtx); // TX
 800444e:	a806      	add	r0, sp, #24
 8004450:	f7ff ff92 	bl	8004378 <irq_given_datastream>
	dma_irq_number_rx = irq_given_datastream(iuart, dmastreamrx); // RX
 8004454:	a804      	add	r0, sp, #16
 8004456:	4621      	mov	r1, r4
 8004458:	463a      	mov	r2, r7
	if ((dma_tx_int_priority & 0xffffff0f) != 0) bsp_panic(-3); // Bogus priority
	
	cb_Idx = mapindex(iuart);	// Map usart/uart register base to control block index

	/* Convert dma stream to dma base and irq number */
	dma_irq_number_tx = irq_given_datastream(iuart, dmastreamtx); // TX
 800445a:	9e06      	ldr	r6, [sp, #24]
 800445c:	9d07      	ldr	r5, [sp, #28]
	dma_irq_number_rx = irq_given_datastream(iuart, dmastreamrx); // RX
 800445e:	f7ff ff8b 	bl	8004378 <irq_given_datastream>
	
	/* The DMA determined should be the same...mostly a debugging issue. */
	if (dma_irq_number_tx.dma != dma_irq_number_rx.dma) bsp_panic(-333);
 8004462:	9b04      	ldr	r3, [sp, #16]
	
	cb_Idx = mapindex(iuart);	// Map usart/uart register base to control block index

	/* Convert dma stream to dma base and irq number */
	dma_irq_number_tx = irq_given_datastream(iuart, dmastreamtx); // TX
	dma_irq_number_rx = irq_given_datastream(iuart, dmastreamrx); // RX
 8004464:	f8dd 9014 	ldr.w	r9, [sp, #20]
	
	/* The DMA determined should be the same...mostly a debugging issue. */
	if (dma_irq_number_tx.dma != dma_irq_number_rx.dma) bsp_panic(-333);
 8004468:	429e      	cmp	r6, r3
 800446a:	d003      	beq.n	8004474 <bsp_uart_dma_init+0x70>
 800446c:	f46f 70a6 	mvn.w	r0, #332	; 0x14c
 8004470:	f7ff fed0 	bl	8004214 <bsp_panic>
	dma_x = dma_irq_number_tx.dma;	// Lazy way of dealing with it later

	/* Set dma stream interrupt to revector to this routine; check if dma is in use. */
	tmp = nvic_dma_stream_vector_add( (void(*)(u32*))&DMA_UART_IRQHandler, (u32*)&cb_uart[cb_Idx], dma_irq_number_tx.num, dmastreamtx);
 8004474:	4a85      	ldr	r2, [pc, #532]	; (800468c <bsp_uart_dma_init+0x288>)
 8004476:	4886      	ldr	r0, [pc, #536]	; (8004690 <bsp_uart_dma_init+0x28c>)
 8004478:	ea4f 138b 	mov.w	r3, fp, lsl #6
 800447c:	eb02 0803 	add.w	r8, r2, r3
 8004480:	4641      	mov	r1, r8
 8004482:	462a      	mov	r2, r5
 8004484:	4653      	mov	r3, sl
 8004486:	f7ff fd75 	bl	8003f74 <nvic_dma_stream_vector_add>
	if (tmp != 0) bsp_panic(-30 + tmp);
 800448a:	b110      	cbz	r0, 8004492 <bsp_uart_dma_init+0x8e>
 800448c:	381e      	subs	r0, #30
 800448e:	f7ff fec1 	bl	8004214 <bsp_panic>

	/* RX doesn't interrupt, but we need to show that the stream has been taken */
	tmp = nvic_dma_stream_vector_add( (void(*)(u32*))&DMA_UART_IRQHandler, (u32*)&cb_uart[cb_Idx], dma_irq_number_rx.num, dmastreamrx);
 8004492:	487f      	ldr	r0, [pc, #508]	; (8004690 <bsp_uart_dma_init+0x28c>)
 8004494:	4641      	mov	r1, r8
 8004496:	464a      	mov	r2, r9
 8004498:	463b      	mov	r3, r7
 800449a:	f7ff fd6b 	bl	8003f74 <nvic_dma_stream_vector_add>
	if (tmp != 0) bsp_panic(-130 + tmp);
 800449e:	b110      	cbz	r0, 80044a6 <bsp_uart_dma_init+0xa2>
 80044a0:	3882      	subs	r0, #130	; 0x82
 80044a2:	f7ff feb7 	bl	8004214 <bsp_panic>


	/* Load some parameters that might be important. */
	cb_uart[cb_Idx].idma = dma_x;	// Save dma register base address
 80044a6:	4a7b      	ldr	r2, [pc, #492]	; (8004694 <bsp_uart_dma_init+0x290>)
 80044a8:	ea4f 138b 	mov.w	r3, fp, lsl #6
 80044ac:	18d3      	adds	r3, r2, r3
	cb_uart[cb_Idx].rxdma_stream = dmastreamrx; // Save stream number
	cb_uart[cb_Idx].txdma_stream = dmastreamtx; // Save stream number
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
	cb_uart[cb_Idx].flag = 2;	// Show this setup for dma driven
 80044ae:	2102      	movs	r1, #2
	tmp = nvic_dma_stream_vector_add( (void(*)(u32*))&DMA_UART_IRQHandler, (u32*)&cb_uart[cb_Idx], dma_irq_number_rx.num, dmastreamrx);
	if (tmp != 0) bsp_panic(-130 + tmp);


	/* Load some parameters that might be important. */
	cb_uart[cb_Idx].idma = dma_x;	// Save dma register base address
 80044b0:	605e      	str	r6, [r3, #4]
	cb_uart[cb_Idx].rxdma_stream = dmastreamrx; // Save stream number
 80044b2:	60df      	str	r7, [r3, #12]
	cb_uart[cb_Idx].txdma_stream = dmastreamtx; // Save stream number
 80044b4:	f8c3 a010 	str.w	sl, [r3, #16]
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
 80044b8:	609c      	str	r4, [r3, #8]
	cb_uart[cb_Idx].flag = 2;	// Show this setup for dma driven
 80044ba:	6159      	str	r1, [r3, #20]

	/* Find DMA channel numbers for RX and TX, given stream number */
	switch (dma_x)
 80044bc:	4b76      	ldr	r3, [pc, #472]	; (8004698 <bsp_uart_dma_init+0x294>)
 80044be:	429e      	cmp	r6, r3
 80044c0:	d003      	beq.n	80044ca <bsp_uart_dma_init+0xc6>
 80044c2:	4b76      	ldr	r3, [pc, #472]	; (800469c <bsp_uart_dma_init+0x298>)
 80044c4:	429e      	cmp	r6, r3
 80044c6:	d11f      	bne.n	8004508 <bsp_uart_dma_init+0x104>
 80044c8:	e00f      	b.n	80044ea <bsp_uart_dma_init+0xe6>
	{
	case DMA1_BASE:
		if (dma1_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
 80044ca:	f007 0207 	and.w	r2, r7, #7
 80044ce:	4b74      	ldr	r3, [pc, #464]	; (80046a0 <bsp_uart_dma_init+0x29c>)
 80044d0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80044d4:	42a1      	cmp	r1, r4
 80044d6:	d01b      	beq.n	8004510 <bsp_uart_dma_init+0x10c>
		if (dma1_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
 80044d8:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80044dc:	6a1b      	ldr	r3, [r3, #32]
 80044de:	42a3      	cmp	r3, r4
 80044e0:	d022      	beq.n	8004528 <bsp_uart_dma_init+0x124>
		bsp_panic(-6);	// RX stream specified is not compatible with UART/DMA1
 80044e2:	f06f 0005 	mvn.w	r0, #5
 80044e6:	f7ff fe95 	bl	8004214 <bsp_panic>

	case DMA2_BASE:
		if (dma2_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
 80044ea:	4b6d      	ldr	r3, [pc, #436]	; (80046a0 <bsp_uart_dma_init+0x29c>)
 80044ec:	f007 0207 	and.w	r2, r7, #7
 80044f0:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80044f4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80044f6:	42a2      	cmp	r2, r4
 80044f8:	d00a      	beq.n	8004510 <bsp_uart_dma_init+0x10c>
		if (dma2_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
 80044fa:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80044fc:	42a3      	cmp	r3, r4
 80044fe:	d00a      	beq.n	8004516 <bsp_uart_dma_init+0x112>
		bsp_panic(-7);	// RX stream specified is not compatible with UART/DMA2
 8004500:	f06f 0006 	mvn.w	r0, #6
 8004504:	f7ff fe86 	bl	8004214 <bsp_panic>
	default:
		bsp_panic(-8);	// Something seriously wrong here!
 8004508:	f06f 0007 	mvn.w	r0, #7
 800450c:	f7ff fe82 	bl	8004214 <bsp_panic>
		if (dma1_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
		if (dma1_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
		bsp_panic(-6);	// RX stream specified is not compatible with UART/DMA1

	case DMA2_BASE:
		if (dma2_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
 8004510:	f04f 0904 	mov.w	r9, #4
 8004514:	e001      	b.n	800451a <bsp_uart_dma_init+0x116>
		if (dma2_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
 8004516:	f04f 0905 	mov.w	r9, #5
	default:
		bsp_panic(-8);	// Something seriously wrong here!

	}

	switch (dma_x)
 800451a:	4b5f      	ldr	r3, [pc, #380]	; (8004698 <bsp_uart_dma_init+0x294>)
 800451c:	429e      	cmp	r6, r3
 800451e:	d005      	beq.n	800452c <bsp_uart_dma_init+0x128>
 8004520:	4b5e      	ldr	r3, [pc, #376]	; (800469c <bsp_uart_dma_init+0x298>)
 8004522:	429e      	cmp	r6, r3
 8004524:	d128      	bne.n	8004578 <bsp_uart_dma_init+0x174>
 8004526:	e016      	b.n	8004556 <bsp_uart_dma_init+0x152>
	/* Find DMA channel numbers for RX and TX, given stream number */
	switch (dma_x)
	{
	case DMA1_BASE:
		if (dma1_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
		if (dma1_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
 8004528:	f04f 0905 	mov.w	r9, #5
	}

	switch (dma_x)
	{
	case DMA1_BASE:
		if (dma1_txstreamtbl_4[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 4; break;}
 800452c:	4b5c      	ldr	r3, [pc, #368]	; (80046a0 <bsp_uart_dma_init+0x29c>)
 800452e:	f00a 0207 	and.w	r2, sl, #7
 8004532:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8004536:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 800453a:	42a2      	cmp	r2, r4
 800453c:	d024      	beq.n	8004588 <bsp_uart_dma_init+0x184>
		if (dma1_txstreamtbl_5[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 5; break;}
 800453e:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 8004542:	42a2      	cmp	r2, r4
 8004544:	d023      	beq.n	800458e <bsp_uart_dma_init+0x18a>
		if (dma1_txstreamtbl_7[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 7; break;}
 8004546:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 800454a:	42a3      	cmp	r3, r4
 800454c:	d019      	beq.n	8004582 <bsp_uart_dma_init+0x17e>
		bsp_panic(-9);	// TX stream specified is not compatible with UART/DMA1
 800454e:	f06f 0008 	mvn.w	r0, #8
 8004552:	f7ff fe5f 	bl	8004214 <bsp_panic>

	case DMA2_BASE:
		if (dma2_txstreamtbl_4[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 4; break;}
 8004556:	4b52      	ldr	r3, [pc, #328]	; (80046a0 <bsp_uart_dma_init+0x29c>)
 8004558:	f00a 0207 	and.w	r2, sl, #7
 800455c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8004560:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8004564:	42a2      	cmp	r2, r4
 8004566:	d00f      	beq.n	8004588 <bsp_uart_dma_init+0x184>
		if (dma2_txstreamtbl_5[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 5; break;}
 8004568:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 800456c:	42a3      	cmp	r3, r4
 800456e:	d00e      	beq.n	800458e <bsp_uart_dma_init+0x18a>
		bsp_panic(-10);	// TX stream specified is not compatible with UART/DMA2
 8004570:	f06f 0009 	mvn.w	r0, #9
 8004574:	f7ff fe4e 	bl	8004214 <bsp_panic>
	default:
		bsp_panic(-11);	// Something seriously wrong here!
 8004578:	f06f 000a 	mvn.w	r0, #10
 800457c:	f7ff fe4a 	bl	8004214 <bsp_panic>
 8004580:	e005      	b.n	800458e <bsp_uart_dma_init+0x18a>
	switch (dma_x)
	{
	case DMA1_BASE:
		if (dma1_txstreamtbl_4[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 4; break;}
		if (dma1_txstreamtbl_5[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 5; break;}
		if (dma1_txstreamtbl_7[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 7; break;}
 8004582:	f04f 0807 	mov.w	r8, #7
 8004586:	e004      	b.n	8004592 <bsp_uart_dma_init+0x18e>
		bsp_panic(-9);	// TX stream specified is not compatible with UART/DMA1

	case DMA2_BASE:
		if (dma2_txstreamtbl_4[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 4; break;}
 8004588:	f04f 0804 	mov.w	r8, #4
 800458c:	e001      	b.n	8004592 <bsp_uart_dma_init+0x18e>
		if (dma2_txstreamtbl_5[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 5; break;}
 800458e:	f04f 0805 	mov.w	r8, #5
	default:
		bsp_panic(-11);	// Something seriously wrong here!

	}
static u32 qqq;
	qqq = dma_channel_number_rx;
 8004592:	4a40      	ldr	r2, [pc, #256]	; (8004694 <bsp_uart_dma_init+0x290>)
/* At this point we (should!) have a good DMA channel and stream that associates with the UART. */

	/* Set up UART pins, port & uart clockings.  THIS IS BOARD SPECIFIC */
	if (uart_pins(iuart, &uartpins) != 0) bsp_panic(-15);
 8004594:	4620      	mov	r0, r4
	default:
		bsp_panic(-11);	// Something seriously wrong here!

	}
static u32 qqq;
	qqq = dma_channel_number_rx;
 8004596:	f8c2 9204 	str.w	r9, [r2, #516]	; 0x204
/* At this point we (should!) have a good DMA channel and stream that associates with the UART. */

	/* Set up UART pins, port & uart clockings.  THIS IS BOARD SPECIFIC */
	if (uart_pins(iuart, &uartpins) != 0) bsp_panic(-15);
 800459a:	a908      	add	r1, sp, #32
 800459c:	f000 fa68 	bl	8004a70 <uart_pins>
 80045a0:	b118      	cbz	r0, 80045aa <bsp_uart_dma_init+0x1a6>
 80045a2:	f06f 000e 	mvn.w	r0, #14
 80045a6:	f7ff fe35 	bl	8004214 <bsp_panic>

	/* Setup baud rate */
	usartx_setbaud (iuart, uartpins.pclk, baud);
 80045aa:	4620      	mov	r0, r4
 80045ac:	9908      	ldr	r1, [sp, #32]
 80045ae:	9a01      	ldr	r2, [sp, #4]
 80045b0:	f000 fb26 	bl	8004c00 <usartx_setbaud>

	/* Obtain some buffer space */
	getbuff(cb_Idx, rxbuffsize, txbuffsize);
 80045b4:	4658      	mov	r0, fp
 80045b6:	9902      	ldr	r1, [sp, #8]
 80045b8:	9a03      	ldr	r2, [sp, #12]
 80045ba:	f7ff fe89 	bl	80042d0 <getbuff>

	/* ---------- Set up UART ----------------------------------------------------------------------------------- */

	/* Set up CR1 ---------------------------------------------------- */
	USART_CR1(iuart) |= (1<<13) | (1<<3) | (1<<2);// Set Usart enable, tx enable, rx enable
 80045be:	68e3      	ldr	r3, [r4, #12]
	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 80045c0:	4934      	ldr	r1, [pc, #208]	; (8004694 <bsp_uart_dma_init+0x290>)
	getbuff(cb_Idx, rxbuffsize, txbuffsize);

	/* ---------- Set up UART ----------------------------------------------------------------------------------- */

	/* Set up CR1 ---------------------------------------------------- */
	USART_CR1(iuart) |= (1<<13) | (1<<3) | (1<<2);// Set Usart enable, tx enable, rx enable
 80045c2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80045c6:	f043 030c 	orr.w	r3, r3, #12
 80045ca:	60e3      	str	r3, [r4, #12]

	/* Hook up usart tx and rx to dma channels */
	USART_CR3(iuart) |= (1<<7) | (1<<6);
 80045cc:	6963      	ldr	r3, [r4, #20]
 80045ce:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80045d2:	6163      	str	r3, [r4, #20]
	/* After reset CR2 is 0x0000 and this is just fine */

	/* --------- Set up the DMA channels ------------------------------------------------------------------------ */

	/* Set peripheral address for RX */
	DMA_SPAR(dma_x,dmastreamrx) = (u32*)(iuart + 0x04); // Address of uart DR register
 80045d4:	2318      	movs	r3, #24
 80045d6:	fb03 6707 	mla	r7, r3, r7, r6
	/* Set peripheral address for TX */
	DMA_SPAR(dma_x,dmastreamtx) = (u32*)(iuart + 0x04); // Address of uart DR register

	/* DMA stream configuration register--RX p 325 */
	//                                       Channel number     | MINC    | CIRC   | Per->Mem 
	DMA_SCR(dma_x,dmastreamrx) = ( (dma_channel_number_rx<< 25) | (1<<10) | (1<<8) | (0x0<<6) );   
 80045da:	ea4f 6949 	mov.w	r9, r9, lsl #25

	/* Set peripheral address for RX */
	DMA_SPAR(dma_x,dmastreamrx) = (u32*)(iuart + 0x04); // Address of uart DR register

	/* Set peripheral address for TX */
	DMA_SPAR(dma_x,dmastreamtx) = (u32*)(iuart + 0x04); // Address of uart DR register
 80045de:	fb03 660a 	mla	r6, r3, sl, r6
	/* After reset CR2 is 0x0000 and this is just fine */

	/* --------- Set up the DMA channels ------------------------------------------------------------------------ */

	/* Set peripheral address for RX */
	DMA_SPAR(dma_x,dmastreamrx) = (u32*)(iuart + 0x04); // Address of uart DR register
 80045e2:	3404      	adds	r4, #4
	/* Set peripheral address for TX */
	DMA_SPAR(dma_x,dmastreamtx) = (u32*)(iuart + 0x04); // Address of uart DR register

	/* DMA stream configuration register--RX p 325 */
	//                                       Channel number     | MINC    | CIRC   | Per->Mem 
	DMA_SCR(dma_x,dmastreamrx) = ( (dma_channel_number_rx<< 25) | (1<<10) | (1<<8) | (0x0<<6) );   
 80045e4:	f449 63a0 	orr.w	r3, r9, #1280	; 0x500

	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));
 80045e8:	ea4f 6848 	mov.w	r8, r8, lsl #25
	/* After reset CR2 is 0x0000 and this is just fine */

	/* --------- Set up the DMA channels ------------------------------------------------------------------------ */

	/* Set peripheral address for RX */
	DMA_SPAR(dma_x,dmastreamrx) = (u32*)(iuart + 0x04); // Address of uart DR register
 80045ec:	61bc      	str	r4, [r7, #24]

	/* Set peripheral address for TX */
	DMA_SPAR(dma_x,dmastreamtx) = (u32*)(iuart + 0x04); // Address of uart DR register
 80045ee:	61b4      	str	r4, [r6, #24]

	/* DMA stream configuration register--RX p 325 */
	//                                       Channel number     | MINC    | CIRC   | Per->Mem 
	DMA_SCR(dma_x,dmastreamrx) = ( (dma_channel_number_rx<< 25) | (1<<10) | (1<<8) | (0x0<<6) );   
 80045f0:	613b      	str	r3, [r7, #16]

	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));
 80045f2:	f448 3382 	orr.w	r3, r8, #66560	; 0x10400
 80045f6:	f043 0340 	orr.w	r3, r3, #64	; 0x40

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 80045fa:	ea4f 1b8b 	mov.w	fp, fp, lsl #6
	//                                       Channel number     | MINC    | CIRC   | Per->Mem 
	DMA_SCR(dma_x,dmastreamrx) = ( (dma_channel_number_rx<< 25) | (1<<10) | (1<<8) | (0x0<<6) );   

	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));
 80045fe:	6133      	str	r3, [r6, #16]

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 8004600:	eb01 030b 	add.w	r3, r1, fp

	/* Set the number of bytes in the RX buff */
	DMA_SNDTR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_size;

	/* DMA for TX interrupts */
	NVICIPR (dma_irq_number_tx.num,dma_tx_int_priority);	// Set dma interrupt priority (tx)
 8004604:	2d00      	cmp	r5, #0
	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 8004606:	6b1a      	ldr	r2, [r3, #48]	; 0x30

	/* Set the number of bytes in the RX buff */
	DMA_SNDTR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_size;
 8004608:	6b9b      	ldr	r3, [r3, #56]	; 0x38
	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 800460a:	61fa      	str	r2, [r7, #28]

	/* Set the number of bytes in the RX buff */
	DMA_SNDTR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_size;
 800460c:	617b      	str	r3, [r7, #20]

	/* DMA for TX interrupts */
	NVICIPR (dma_irq_number_tx.num,dma_tx_int_priority);	// Set dma interrupt priority (tx)
 800460e:	4b25      	ldr	r3, [pc, #148]	; (80046a4 <bsp_uart_dma_init+0x2a0>)
 8004610:	462a      	mov	r2, r5
 8004612:	bfb8      	it	lt
 8004614:	1cea      	addlt	r2, r5, #3
 8004616:	f022 0203 	bic.w	r2, r2, #3
 800461a:	ea05 0303 	and.w	r3, r5, r3
 800461e:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
 8004622:	2b00      	cmp	r3, #0
 8004624:	f502 4264 	add.w	r2, r2, #58368	; 0xe400
 8004628:	da03      	bge.n	8004632 <bsp_uart_dma_init+0x22e>
 800462a:	3b01      	subs	r3, #1
 800462c:	f063 0303 	orn	r3, r3, #3
 8004630:	3301      	adds	r3, #1
 8004632:	9916      	ldr	r1, [sp, #88]	; 0x58
 8004634:	00db      	lsls	r3, r3, #3
 8004636:	fa11 f303 	lsls.w	r3, r1, r3
 800463a:	6811      	ldr	r1, [r2, #0]
	NVICISER(dma_irq_number_tx.num);			// Enable dma interrupt (tx)
 800463c:	2d00      	cmp	r5, #0

	/* Set the number of bytes in the RX buff */
	DMA_SNDTR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_size;

	/* DMA for TX interrupts */
	NVICIPR (dma_irq_number_tx.num,dma_tx_int_priority);	// Set dma interrupt priority (tx)
 800463e:	ea41 0303 	orr.w	r3, r1, r3
 8004642:	6013      	str	r3, [r2, #0]
	NVICISER(dma_irq_number_tx.num);			// Enable dma interrupt (tx)
 8004644:	462b      	mov	r3, r5
 8004646:	bfb8      	it	lt
 8004648:	f105 031f 	addlt.w	r3, r5, #31
 800464c:	115a      	asrs	r2, r3, #5
 800464e:	4b16      	ldr	r3, [pc, #88]	; (80046a8 <bsp_uart_dma_init+0x2a4>)
 8004650:	18d3      	adds	r3, r2, r3
 8004652:	009a      	lsls	r2, r3, #2
 8004654:	4b15      	ldr	r3, [pc, #84]	; (80046ac <bsp_uart_dma_init+0x2a8>)
 8004656:	ea05 0303 	and.w	r3, r5, r3
 800465a:	2b00      	cmp	r3, #0
 800465c:	da03      	bge.n	8004666 <bsp_uart_dma_init+0x262>
 800465e:	3b01      	subs	r3, #1
 8004660:	f063 031f 	orn	r3, r3, #31
 8004664:	3301      	adds	r3, #1
 8004666:	2101      	movs	r1, #1
 8004668:	fa11 f303 	lsls.w	r3, r1, r3
 800466c:	6811      	ldr	r1, [r2, #0]
 800466e:	ea41 0303 	orr.w	r3, r1, r3
 8004672:	6013      	str	r3, [r2, #0]

	/* Final enabling of DMA */
	DMA_SCR(dma_x,dmastreamrx) |= (0x1);		// Enable rx stream
 8004674:	693b      	ldr	r3, [r7, #16]
 8004676:	f043 0301 	orr.w	r3, r3, #1
 800467a:	613b      	str	r3, [r7, #16]
	DMA_SCR(dma_x,dmastreamtx) |= ((1<<4));	// TCIE (xfer complete interrupt), not enable stream
 800467c:	6933      	ldr	r3, [r6, #16]
 800467e:	f043 0310 	orr.w	r3, r3, #16
 8004682:	6133      	str	r3, [r6, #16]

	return 0;	// SUCCESS!
}
 8004684:	2000      	movs	r0, #0
 8004686:	b00b      	add	sp, #44	; 0x2c
 8004688:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800468c:	200008d0 	.word	0x200008d0
 8004690:	080041e5 	.word	0x080041e5
 8004694:	200008cc 	.word	0x200008cc
 8004698:	40026000 	.word	0x40026000
 800469c:	40026400 	.word	0x40026400
 80046a0:	2000014c 	.word	0x2000014c
 80046a4:	80000003 	.word	0x80000003
 80046a8:	38003840 	.word	0x38003840
 80046ac:	8000001f 	.word	0x8000001f

080046b0 <bsp_uart_dma_init_number>:
 * int bsp_uart_dma_init_number(u32 uartnumber, u32 baud,u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority);
 * @brief	: A wrapper for 'int bsp_uart_dma_init' with uart number (1-6) rather than uart base address as the first argument
 * @return	: Same as bsp_uart_dma_init
*******************************************************************************/
int bsp_uart_dma_init_number(u32 uartnumber, u32 baud,u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority)
{
 80046b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80046b4:	f8dd 9020 	ldr.w	r9, [sp, #32]
 80046b8:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
 80046bc:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 80046be:	460e      	mov	r6, r1
 80046c0:	4615      	mov	r5, r2
 80046c2:	461c      	mov	r4, r3
	u32 iuart = uartnumber_to_baseaddr(uartnumber);
 80046c4:	f7ff fe30 	bl	8004328 <uartnumber_to_baseaddr>
	return  bsp_uart_dma_init(iuart, baud, rxbuffsize, txbuffsize, dmastreamrx, dmastreamtx, dma_tx_int_priority);
 80046c8:	4631      	mov	r1, r6
 80046ca:	462a      	mov	r2, r5
 80046cc:	4623      	mov	r3, r4
 80046ce:	f8cd 9020 	str.w	r9, [sp, #32]
 80046d2:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
 80046d6:	970a      	str	r7, [sp, #40]	; 0x28
}
 80046d8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 * @return	: Same as bsp_uart_dma_init
*******************************************************************************/
int bsp_uart_dma_init_number(u32 uartnumber, u32 baud,u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority)
{
	u32 iuart = uartnumber_to_baseaddr(uartnumber);
	return  bsp_uart_dma_init(iuart, baud, rxbuffsize, txbuffsize, dmastreamrx, dmastreamtx, dma_tx_int_priority);
 80046dc:	e692      	b.n	8004404 <bsp_uart_dma_init>

080046de <bsp_uart_getcount_ptr>:
*******************************************************************************/
int bsp_uart_getcount_ptr(struct CB_UART* pctl)
{
	int	Diff;

	if (pctl->flag == 1)
 80046de:	6902      	ldr	r2, [r0, #16]
 80046e0:	2a01      	cmp	r2, #1
 * @brief	: Get the number of bytes buffered
 * @param	: pctl = pointer uart control block
 * @return	: number of chars in currently buffered.
*******************************************************************************/
int bsp_uart_getcount_ptr(struct CB_UART* pctl)
{
 80046e2:	4603      	mov	r3, r0
	int	Diff;

	if (pctl->flag == 1)
 80046e4:	d101      	bne.n	80046ea <bsp_uart_getcount_ptr+0xc>
	{ // Here, interrupt driven uart
		Diff = (int)(pctl->rxbuff_in - pctl->rxbuff_out);
 80046e6:	6b80      	ldr	r0, [r0, #56]	; 0x38
 80046e8:	e009      	b.n	80046fe <bsp_uart_getcount_ptr+0x20>
		if (Diff < 0)
			Diff += pctl->rxbuff_size;  // Adjust for wrap
		return Diff;
	}

	if (pctl->flag == 2)
 80046ea:	2a02      	cmp	r2, #2
 80046ec:	d10d      	bne.n	800470a <bsp_uart_getcount_ptr+0x2c>
	{ // Here, DMA driven uart
		/* Difference between where we are taking out chars, and where DMA is/was storing */
		Diff = ( pctl->rxbuff_end - DMA_SNDTR(pctl->idma,pctl->rxdma_stream) - pctl->rxbuff_out );
 80046ee:	6801      	ldr	r1, [r0, #0]
 80046f0:	6882      	ldr	r2, [r0, #8]
 80046f2:	2018      	movs	r0, #24
 80046f4:	4342      	muls	r2, r0
 80046f6:	3114      	adds	r1, #20
 80046f8:	6b18      	ldr	r0, [r3, #48]	; 0x30
 80046fa:	588a      	ldr	r2, [r1, r2]
 80046fc:	1a80      	subs	r0, r0, r2
 80046fe:	6bda      	ldr	r2, [r3, #60]	; 0x3c
		if (Diff < 0)
 8004700:	1a80      	subs	r0, r0, r2
 8004702:	d503      	bpl.n	800470c <bsp_uart_getcount_ptr+0x2e>
			Diff += pctl->rxbuff_size;  // Adjust for wrap
 8004704:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004706:	18c0      	adds	r0, r0, r3
 8004708:	4770      	bx	lr
		return Diff;
	}
	return 0;	// Something wrong if we got here.
 800470a:	2000      	movs	r0, #0
}
 800470c:	4770      	bx	lr

0800470e <bsp_uart_getcount_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_getcount_uartnum(int uartnum)	// Select by uart number (1 - n)
{
	if ( ((uartnum - 1) < 0) || ((uartnum - 1) > 7) ) return 0;
 800470e:	3801      	subs	r0, #1
 8004710:	2807      	cmp	r0, #7
 8004712:	d803      	bhi.n	800471c <bsp_uart_getcount_uartnum+0xe>
	return bsp_uart_getcount_ptr(&cb_uart[uartnum - 1]);
 8004714:	4b02      	ldr	r3, [pc, #8]	; (8004720 <bsp_uart_getcount_uartnum+0x12>)
 8004716:	0180      	lsls	r0, r0, #6
 8004718:	1818      	adds	r0, r3, r0
 800471a:	e7e0      	b.n	80046de <bsp_uart_getcount_ptr>
}
 800471c:	2000      	movs	r0, #0
 800471e:	4770      	bx	lr
 8004720:	200008d0 	.word	0x200008d0

08004724 <bsp_uart_getc_ptr>:
 * @brief	: Get one char
 * @param	: pctl = pointer uart control block
 * @return	: char from buffer
*******************************************************************************/
char bsp_uart_getc_ptr(struct CB_UART* pctl)
{
 8004724:	b538      	push	{r3, r4, r5, lr}
 8004726:	4604      	mov	r4, r0
	char	c;
	u32 	i = 0;
 8004728:	2500      	movs	r5, #0

	/* Hang waiting for incoming bytes if bozo caller didn't check char count. */
	while (( bsp_uart_getcount_ptr(pctl) == 0)  && (i++ < 50000) ) ;
 800472a:	4620      	mov	r0, r4
 800472c:	f7ff ffd7 	bl	80046de <bsp_uart_getcount_ptr>
 8004730:	b120      	cbz	r0, 800473c <bsp_uart_getc_ptr+0x18>
	if (i >= 50000) panic_leds(-50);
 8004732:	f24c 334f 	movw	r3, #49999	; 0xc34f
 8004736:	429d      	cmp	r5, r3
 8004738:	d909      	bls.n	800474e <bsp_uart_getc_ptr+0x2a>
 800473a:	e004      	b.n	8004746 <bsp_uart_getc_ptr+0x22>
{
	char	c;
	u32 	i = 0;

	/* Hang waiting for incoming bytes if bozo caller didn't check char count. */
	while (( bsp_uart_getcount_ptr(pctl) == 0)  && (i++ < 50000) ) ;
 800473c:	3501      	adds	r5, #1
 800473e:	f24c 3351 	movw	r3, #50001	; 0xc351
 8004742:	429d      	cmp	r5, r3
 8004744:	d1f1      	bne.n	800472a <bsp_uart_getc_ptr+0x6>
	if (i >= 50000) panic_leds(-50);
 8004746:	f06f 0031 	mvn.w	r0, #49	; 0x31
 800474a:	f7ff f9fa 	bl	8003b42 <panic_leds>

	c = *pctl->rxbuff_out;
 800474e:	6be1      	ldr	r1, [r4, #60]	; 0x3c
	pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
 8004750:	4620      	mov	r0, r4

	/* Hang waiting for incoming bytes if bozo caller didn't check char count. */
	while (( bsp_uart_getcount_ptr(pctl) == 0)  && (i++ < 50000) ) ;
	if (i >= 50000) panic_leds(-50);

	c = *pctl->rxbuff_out;
 8004752:	780d      	ldrb	r5, [r1, #0]
	pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
 8004754:	f7ff fd0e 	bl	8004174 <rxbuff_adv>
 8004758:	63e0      	str	r0, [r4, #60]	; 0x3c
	return c;
}
 800475a:	4628      	mov	r0, r5
 800475c:	bd38      	pop	{r3, r4, r5, pc}

0800475e <bsp_uart_getc_uartnum>:
/* ---------------------------------------------------------------------------- */
char bsp_uart_getc_uartnum(int uartnum)	// Select by uart number (1 - n)
{
	if (((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 800475e:	3801      	subs	r0, #1
 8004760:	2807      	cmp	r0, #7
 8004762:	d803      	bhi.n	800476c <bsp_uart_getc_uartnum+0xe>
	return bsp_uart_getc_ptr(&cb_uart[uartnum - 1]);
 8004764:	4b02      	ldr	r3, [pc, #8]	; (8004770 <bsp_uart_getc_uartnum+0x12>)
 8004766:	0180      	lsls	r0, r0, #6
 8004768:	1818      	adds	r0, r3, r0
 800476a:	e7db      	b.n	8004724 <bsp_uart_getc_ptr>
}
 800476c:	2000      	movs	r0, #0
 800476e:	4770      	bx	lr
 8004770:	200008d0 	.word	0x200008d0

08004774 <bsp_uart_getn_ptr>:
 * @param	: pchr = pointer to output char buffer
 * @param	: len = number of bytes requested
 * @return	: number of chars actually transferred
*******************************************************************************/
int bsp_uart_getn_ptr(struct CB_UART* pctl, char *pchr, int len)
{
 8004774:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004776:	4604      	mov	r4, r0
 8004778:	460d      	mov	r5, r1
 800477a:	4617      	mov	r7, r2
	int 	i;
	int 	ct;

	ct = bsp_uart_getcount_ptr(pctl);
 800477c:	f7ff ffaf 	bl	80046de <bsp_uart_getcount_ptr>
	if (ct == 0) return 0;
 8004780:	4606      	mov	r6, r0
 8004782:	b178      	cbz	r0, 80047a4 <bsp_uart_getn_ptr+0x30>
 8004784:	42be      	cmp	r6, r7
 8004786:	bfa8      	it	ge
 8004788:	463e      	movge	r6, r7

	if (ct > len) ct = len; // Check fo more ready than requested

	for (i = 0; i < ct; i++)
 800478a:	2700      	movs	r7, #0
 800478c:	e008      	b.n	80047a0 <bsp_uart_getn_ptr+0x2c>
	{
		*pchr++ = *pctl->rxbuff_out;	// Copy from buffer to output
 800478e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004790:	781b      	ldrb	r3, [r3, #0]
 8004792:	55eb      	strb	r3, [r5, r7]
		pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
 8004794:	4620      	mov	r0, r4
 8004796:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8004798:	f7ff fcec 	bl	8004174 <rxbuff_adv>
	ct = bsp_uart_getcount_ptr(pctl);
	if (ct == 0) return 0;

	if (ct > len) ct = len; // Check fo more ready than requested

	for (i = 0; i < ct; i++)
 800479c:	3701      	adds	r7, #1
	{
		*pchr++ = *pctl->rxbuff_out;	// Copy from buffer to output
		pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
 800479e:	63e0      	str	r0, [r4, #60]	; 0x3c
	ct = bsp_uart_getcount_ptr(pctl);
	if (ct == 0) return 0;

	if (ct > len) ct = len; // Check fo more ready than requested

	for (i = 0; i < ct; i++)
 80047a0:	42b7      	cmp	r7, r6
 80047a2:	dbf4      	blt.n	800478e <bsp_uart_getn_ptr+0x1a>
	{
		*pchr++ = *pctl->rxbuff_out;	// Copy from buffer to output
		pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
	}
	return ct; // Return number transfered.
}
 80047a4:	4630      	mov	r0, r6
 80047a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080047a8 <bsp_uart_getn_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_getn_uartnum(int uartnum, char *pchr, int len)	// Select by uart number (1 - n)
{
	if ( ((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 80047a8:	3801      	subs	r0, #1
 80047aa:	2807      	cmp	r0, #7
 80047ac:	d803      	bhi.n	80047b6 <bsp_uart_getn_uartnum+0xe>
	return bsp_uart_getn_ptr(&cb_uart[uartnum - 1],  pchr, len);
 80047ae:	4b03      	ldr	r3, [pc, #12]	; (80047bc <bsp_uart_getn_uartnum+0x14>)
 80047b0:	0180      	lsls	r0, r0, #6
 80047b2:	1818      	adds	r0, r3, r0
 80047b4:	e7de      	b.n	8004774 <bsp_uart_getn_ptr>
}
 80047b6:	2000      	movs	r0, #0
 80047b8:	4770      	bx	lr
 80047ba:	bf00      	nop
 80047bc:	200008d0 	.word	0x200008d0

080047c0 <bsp_uart_start_dma>:
 * @param	: pctl: control block poiner
 * @return	:
*******************************************************************************/
void bsp_uart_start_dma(struct CB_UART* pctl)
{
	if (pctl->flag != 2) return;	// Return, not DMA driven
 80047c0:	6902      	ldr	r2, [r0, #16]
 80047c2:	2a02      	cmp	r2, #2
 * @brief	: If DMA driven uart, start DMA sending if not already sending
 * @param	: pctl: control block poiner
 * @return	:
*******************************************************************************/
void bsp_uart_start_dma(struct CB_UART* pctl)
{
 80047c4:	b510      	push	{r4, lr}
	if (pctl->flag != 2) return;	// Return, not DMA driven
 80047c6:	d10f      	bne.n	80047e8 <bsp_uart_start_dma+0x28>
	
	/* Are we already running? */
	// First look at the enable bit
	if ((DMA_SCR(pctl->idma, pctl->txdma_stream) & 0x1) != 0) return;	// Already running
 80047c8:	6801      	ldr	r1, [r0, #0]
 80047ca:	68c2      	ldr	r2, [r0, #12]
 80047cc:	2418      	movs	r4, #24
 80047ce:	4362      	muls	r2, r4
 80047d0:	3110      	adds	r1, #16
 80047d2:	5889      	ldr	r1, [r1, r2]
 80047d4:	f011 0f01 	tst.w	r1, #1
 80047d8:	d106      	bne.n	80047e8 <bsp_uart_start_dma+0x28>


	// Check if the counter has gone to zero
	if ( DMA_SNDTR(pctl->idma,pctl->txdma_stream) != 0) return;
 80047da:	6803      	ldr	r3, [r0, #0]
 80047dc:	3314      	adds	r3, #20
 80047de:	589b      	ldr	r3, [r3, r2]
 80047e0:	b913      	cbnz	r3, 80047e8 <bsp_uart_start_dma+0x28>
	
	/* Not running.  If there are any to send, set up the DMA. */
	common_dma(pctl);

	return;
}
 80047e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

	// Check if the counter has gone to zero
	if ( DMA_SNDTR(pctl->idma,pctl->txdma_stream) != 0) return;
	
	/* Not running.  If there are any to send, set up the DMA. */
	common_dma(pctl);
 80047e6:	e4d3      	b.n	8004190 <common_dma>
 80047e8:	bd10      	pop	{r4, pc}

080047ea <bsp_uart_send_int>:
 * @param	: pctl = pointer uart control block
 * @return	: 
*******************************************************************************/
void bsp_uart_send_int(struct CB_UART* pctl)
{
	if (pctl->flag != 1) return;	// Return not interrupt drive & initialized
 80047ea:	6903      	ldr	r3, [r0, #16]
 80047ec:	2b01      	cmp	r3, #1
 80047ee:	d109      	bne.n	8004804 <bsp_uart_send_int+0x1a>

	if ((USART_CR1(pctl->iuart) & USART_CR1_TXEIE) != 0) // Already enabled?
 80047f0:	6843      	ldr	r3, [r0, #4]
 80047f2:	68db      	ldr	r3, [r3, #12]
 80047f4:	f013 0f80 	tst.w	r3, #128	; 0x80
 80047f8:	d104      	bne.n	8004804 <bsp_uart_send_int+0x1a>
		return;

	USART_CR1(pctl->iuart) |= USART_CR1_TXEIE ;	// Enable interrupt
 80047fa:	6843      	ldr	r3, [r0, #4]
 80047fc:	68da      	ldr	r2, [r3, #12]
 80047fe:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8004802:	60da      	str	r2, [r3, #12]
 8004804:	4770      	bx	lr

08004806 <bsp_uart_putc_ptr>:
 * @param	: Char to be sent
 * @return	: 1 = one char add; 0 = no chars added; -1 = pctl was null
 * NOTE: this does not start an idle DMA, but starts an idle interrupt driven uart
*******************************************************************************/
int bsp_uart_putc_ptr(struct CB_UART* pctl, char c) // Select by control block ptr
{
 8004806:	b570      	push	{r4, r5, r6, lr}
 8004808:	460e      	mov	r6, r1
	u8* p;

	if (pctl == 0) return -1;
 800480a:	4604      	mov	r4, r0
 800480c:	b180      	cbz	r0, 8004830 <bsp_uart_putc_ptr+0x2a>

	/* Check if buffer filled.  Return zero if full. */
	p = txbuff_adv(pctl, pctl->txbuff_in); 	// Advance input pointer (circularly)
 800480e:	6a05      	ldr	r5, [r0, #32]
 8004810:	4629      	mov	r1, r5
 8004812:	f7ff fcb6 	bl	8004182 <txbuff_adv>
	if (p == pctl->txbuff_out)  return 0; 	// Return zero, rather than overwrite buffer
 8004816:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004818:	4298      	cmp	r0, r3
 800481a:	d00c      	beq.n	8004836 <bsp_uart_putc_ptr+0x30>

	*pctl->txbuff_in = (u8)c;		// Store char
 800481c:	702e      	strb	r6, [r5, #0]

	/* Update the input buffer pointer to the next position. */
	pctl->txbuff_in = p;
 800481e:	6220      	str	r0, [r4, #32]

	/* Start sending if non-dma */
	bsp_uart_send_int(pctl);
 8004820:	4620      	mov	r0, r4
 8004822:	f7ff ffe2 	bl	80047ea <bsp_uart_send_int>

	/* Start sending: if dma and not idle. */
	bsp_uart_start_dma(pctl); 
 8004826:	4620      	mov	r0, r4
 8004828:	f7ff ffca 	bl	80047c0 <bsp_uart_start_dma>

 	return 1; // Return byte count stored.
 800482c:	2001      	movs	r0, #1
 800482e:	bd70      	pop	{r4, r5, r6, pc}
*******************************************************************************/
int bsp_uart_putc_ptr(struct CB_UART* pctl, char c) // Select by control block ptr
{
	u8* p;

	if (pctl == 0) return -1;
 8004830:	f04f 30ff 	mov.w	r0, #4294967295
 8004834:	bd70      	pop	{r4, r5, r6, pc}

	/* Check if buffer filled.  Return zero if full. */
	p = txbuff_adv(pctl, pctl->txbuff_in); 	// Advance input pointer (circularly)
	if (p == pctl->txbuff_out)  return 0; 	// Return zero, rather than overwrite buffer
 8004836:	2000      	movs	r0, #0

	/* Start sending: if dma and not idle. */
	bsp_uart_start_dma(pctl); 

 	return 1; // Return byte count stored.
}
 8004838:	bd70      	pop	{r4, r5, r6, pc}

0800483a <bsp_uart_putc_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_putc_uartnum(int uartnum, char c)	// Select by uart number (1 - n)
{
	if (((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 800483a:	3801      	subs	r0, #1
 800483c:	2807      	cmp	r0, #7
 800483e:	d803      	bhi.n	8004848 <bsp_uart_putc_uartnum+0xe>
	return bsp_uart_putc_ptr(&cb_uart[uartnum - 1], c);
 8004840:	4b02      	ldr	r3, [pc, #8]	; (800484c <bsp_uart_putc_uartnum+0x12>)
 8004842:	0180      	lsls	r0, r0, #6
 8004844:	1818      	adds	r0, r3, r0
 8004846:	e7de      	b.n	8004806 <bsp_uart_putc_ptr>
}
 8004848:	2000      	movs	r0, #0
 800484a:	4770      	bx	lr
 800484c:	200008d0 	.word	0x200008d0

08004850 <bsp_uart_puts_ptr>:
 * @param	: p = pointer to buffer with bytes to be added
 * @return	: count of bytes added to buffer
 * NOTE: this starts either DMA or interrupt driven 
*******************************************************************************/
int bsp_uart_puts_ptr(struct CB_UART* pctl, char* p) // Select: control blk ptr
{
 8004850:	b570      	push	{r4, r5, r6, lr}
 8004852:	460d      	mov	r5, r1
	u32 ct = 0;
	int ret;

	if (pctl == 0) return -1;	// Pointer not set
 8004854:	4606      	mov	r6, r0
 8004856:	b168      	cbz	r0, 8004874 <bsp_uart_puts_ptr+0x24>
 8004858:	2400      	movs	r4, #0
 800485a:	e006      	b.n	800486a <bsp_uart_puts_ptr+0x1a>
	
	while (*p != 0)
	{
		ret = bsp_uart_putc_ptr(pctl, *p);	// Put char
 800485c:	4630      	mov	r0, r6
 800485e:	f7ff ffd2 	bl	8004806 <bsp_uart_putc_ptr>
		if (ret > 0)
 8004862:	2800      	cmp	r0, #0
		{ // Here, one byte was stored in buffer
			ct += ret;	// Add to count loaded
 8004864:	bfc4      	itt	gt
 8004866:	1824      	addgt	r4, r4, r0
			p++;
 8004868:	3501      	addgt	r5, #1
	u32 ct = 0;
	int ret;

	if (pctl == 0) return -1;	// Pointer not set
	
	while (*p != 0)
 800486a:	7829      	ldrb	r1, [r5, #0]
 800486c:	2900      	cmp	r1, #0
 800486e:	d1f5      	bne.n	800485c <bsp_uart_puts_ptr+0xc>
			ct += ret;	// Add to count loaded
			p++;
		} // Note: loop hangs when buffer is full
	}

	return ct;
 8004870:	4620      	mov	r0, r4
 8004872:	bd70      	pop	{r4, r5, r6, pc}
int bsp_uart_puts_ptr(struct CB_UART* pctl, char* p) // Select: control blk ptr
{
	u32 ct = 0;
	int ret;

	if (pctl == 0) return -1;	// Pointer not set
 8004874:	f04f 30ff 	mov.w	r0, #4294967295
			p++;
		} // Note: loop hangs when buffer is full
	}

	return ct;
}
 8004878:	bd70      	pop	{r4, r5, r6, pc}

0800487a <bsp_uart_puts_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_puts_uartnum(int uartnum,char* p)	// Select by uart number (1 - n)
{
	if (((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 800487a:	3801      	subs	r0, #1
 800487c:	2807      	cmp	r0, #7
 800487e:	d803      	bhi.n	8004888 <bsp_uart_puts_uartnum+0xe>
	return bsp_uart_puts_ptr(&cb_uart[uartnum - 1], p);
 8004880:	4b02      	ldr	r3, [pc, #8]	; (800488c <bsp_uart_puts_uartnum+0x12>)
 8004882:	0180      	lsls	r0, r0, #6
 8004884:	1818      	adds	r0, r3, r0
 8004886:	e7e3      	b.n	8004850 <bsp_uart_puts_ptr>
}
 8004888:	2000      	movs	r0, #0
 800488a:	4770      	bx	lr
 800488c:	200008d0 	.word	0x200008d0

08004890 <bsp_uart_putn_ptr>:
 * @param	: count = number of bytes to be added
 * @return	: count of bytes added to buffer
 * NOTE: this starts either DMA or interrupt driven 
*******************************************************************************/
int bsp_uart_putn_ptr(struct CB_UART* pctl, char* p, int len ) // Select: control blk ptr
{
 8004890:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004892:	460c      	mov	r4, r1
 8004894:	4616      	mov	r6, r2
	u32 ct = len;
	int ret;
/* 'ct' and 'len' separate in case we decide to change it to return when the ct loaded is not equal len. */
	if (pctl == 0) return -1;	// Pointer not set
 8004896:	4607      	mov	r7, r0
 8004898:	b170      	cbz	r0, 80048b8 <bsp_uart_putn_ptr+0x28>
 800489a:	4615      	mov	r5, r2
 800489c:	e008      	b.n	80048b0 <bsp_uart_putn_ptr+0x20>
	
	while (len > 0)
	{
		while ((ret = bsp_uart_putc_ptr(pctl, *p)) == 0) ; // Loop if full 
 800489e:	4638      	mov	r0, r7
 80048a0:	7821      	ldrb	r1, [r4, #0]
 80048a2:	f7ff ffb0 	bl	8004806 <bsp_uart_putc_ptr>
 80048a6:	2800      	cmp	r0, #0
 80048a8:	d0f9      	beq.n	800489e <bsp_uart_putn_ptr+0xe>
		if (ret < 0 ) return ret; // Error.
 80048aa:	db07      	blt.n	80048bc <bsp_uart_putn_ptr+0x2c>
		p++;		// 
 80048ac:	3401      	adds	r4, #1
		len -= 1;	// Decrement input count
 80048ae:	3d01      	subs	r5, #1
	u32 ct = len;
	int ret;
/* 'ct' and 'len' separate in case we decide to change it to return when the ct loaded is not equal len. */
	if (pctl == 0) return -1;	// Pointer not set
	
	while (len > 0)
 80048b0:	2d00      	cmp	r5, #0
 80048b2:	dcf4      	bgt.n	800489e <bsp_uart_putn_ptr+0xe>
		while ((ret = bsp_uart_putc_ptr(pctl, *p)) == 0) ; // Loop if full 
		if (ret < 0 ) return ret; // Error.
		p++;		// 
		len -= 1;	// Decrement input count
	}
	return (ct - len);	// Return count added to buffer
 80048b4:	1b70      	subs	r0, r6, r5
 80048b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
int bsp_uart_putn_ptr(struct CB_UART* pctl, char* p, int len ) // Select: control blk ptr
{
	u32 ct = len;
	int ret;
/* 'ct' and 'len' separate in case we decide to change it to return when the ct loaded is not equal len. */
	if (pctl == 0) return -1;	// Pointer not set
 80048b8:	f04f 30ff 	mov.w	r0, #4294967295
		if (ret < 0 ) return ret; // Error.
		p++;		// 
		len -= 1;	// Decrement input count
	}
	return (ct - len);	// Return count added to buffer
}
 80048bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080048be <bsp_uart_putn_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_putn_uartnum(int uartnum, char* p, int len )	// Select by uart number (1 - n)
{
	if (((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 80048be:	3801      	subs	r0, #1
 80048c0:	2807      	cmp	r0, #7
 80048c2:	d803      	bhi.n	80048cc <bsp_uart_putn_uartnum+0xe>
	return bsp_uart_putn_ptr(&cb_uart[uartnum - 1], p, len);
 80048c4:	4b02      	ldr	r3, [pc, #8]	; (80048d0 <bsp_uart_putn_uartnum+0x12>)
 80048c6:	0180      	lsls	r0, r0, #6
 80048c8:	1818      	adds	r0, r3, r0
 80048ca:	e7e1      	b.n	8004890 <bsp_uart_putn_ptr>
}
 80048cc:	2000      	movs	r0, #0
 80048ce:	4770      	bx	lr
 80048d0:	200008d0 	.word	0x200008d0

080048d4 <bsp_uart_int_init>:
 * @param	: uart_int_priority: interrupt priority, (0x00 - 0xf0) e.g. 0xc0, low 4 bits zero
 * @return	: 0 = success; fail traps to 'panic_leds'
*******************************************************************************/

int bsp_uart_int_init(u32 iuart, u32 baud, u32 rxbuffsize, u32 txbuffsize,  u32 uart_int_priority)
{
 80048d4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 80048d8:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
	u32 cb_Idx;
	struct UARTPINS uartpins;

	if ((uart_int_priority & 0xf) != 0) bsp_panic(-3); // Bogus priority
 80048dc:	f018 0f0f 	tst.w	r8, #15
 * @param	: uart_int_priority: interrupt priority, (0x00 - 0xf0) e.g. 0xc0, low 4 bits zero
 * @return	: 0 = success; fail traps to 'panic_leds'
*******************************************************************************/

int bsp_uart_int_init(u32 iuart, u32 baud, u32 rxbuffsize, u32 txbuffsize,  u32 uart_int_priority)
{
 80048e0:	4604      	mov	r4, r0
 80048e2:	460e      	mov	r6, r1
 80048e4:	4615      	mov	r5, r2
 80048e6:	4699      	mov	r9, r3
	u32 cb_Idx;
	struct UARTPINS uartpins;

	if ((uart_int_priority & 0xf) != 0) bsp_panic(-3); // Bogus priority
 80048e8:	d003      	beq.n	80048f2 <bsp_uart_int_init+0x1e>
 80048ea:	f06f 0002 	mvn.w	r0, #2
 80048ee:	f7ff fc91 	bl	8004214 <bsp_panic>
	
	/* Map usart/uart register base to control block index & and enable APBxENR for USART/UART */
	cb_Idx = mapindex(iuart);	
 80048f2:	4620      	mov	r0, r4
 80048f4:	f7ff fc96 	bl	8004224 <mapindex>
		
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
 80048f8:	4b23      	ldr	r3, [pc, #140]	; (8004988 <bsp_uart_int_init+0xb4>)
 80048fa:	0182      	lsls	r2, r0, #6
 80048fc:	1899      	adds	r1, r3, r2
	struct UARTPINS uartpins;

	if ((uart_int_priority & 0xf) != 0) bsp_panic(-3); // Bogus priority
	
	/* Map usart/uart register base to control block index & and enable APBxENR for USART/UART */
	cb_Idx = mapindex(iuart);	
 80048fe:	4607      	mov	r7, r0
		
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
	cb_uart[cb_Idx].flag = 1;	// Show this setup for interrupt driven
 8004900:	2001      	movs	r0, #1
 8004902:	6148      	str	r0, [r1, #20]
	if ((uart_int_priority & 0xf) != 0) bsp_panic(-3); // Bogus priority
	
	/* Map usart/uart register base to control block index & and enable APBxENR for USART/UART */
	cb_Idx = mapindex(iuart);	
		
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
 8004904:	608c      	str	r4, [r1, #8]
	cb_uart[cb_Idx].flag = 1;	// Show this setup for interrupt driven

	/* Mapping adjusted file number to a control block pointer */
	cb_map[cb_Idx] = &cb_uart[cb_Idx];
 8004906:	eb03 0187 	add.w	r1, r3, r7, lsl #2
 800490a:	3304      	adds	r3, #4
 800490c:	189a      	adds	r2, r3, r2
 800490e:	f8c1 2208 	str.w	r2, [r1, #520]	; 0x208

	/* Set up UART pins, port & uart clockings.  THIS IS BOARD SPECIFIC */
	if (uart_pins(iuart, &uartpins) != 0) bsp_panic(-15);
 8004912:	4620      	mov	r0, r4
 8004914:	4669      	mov	r1, sp
 8004916:	f000 f8ab 	bl	8004a70 <uart_pins>
 800491a:	b118      	cbz	r0, 8004924 <bsp_uart_int_init+0x50>
 800491c:	f06f 000e 	mvn.w	r0, #14
 8004920:	f7ff fc78 	bl	8004214 <bsp_panic>

	/* Setup baud rate */
	usartx_setbaud (iuart, uartpins.pclk, baud);
 8004924:	4620      	mov	r0, r4
 8004926:	9900      	ldr	r1, [sp, #0]
 8004928:	4632      	mov	r2, r6
 800492a:	f000 f969 	bl	8004c00 <usartx_setbaud>

	/* Obtain some buffer space */
	getbuff(cb_Idx, rxbuffsize, txbuffsize);
 800492e:	4629      	mov	r1, r5
 8004930:	464a      	mov	r2, r9
 8004932:	4638      	mov	r0, r7
 8004934:	f7ff fccc 	bl	80042d0 <getbuff>
	/* Setup CR2 ------------------------------------------------------------------- */
	/* After reset CR2 is 0x0000 and this is just fine */

	/* Set up CR1 ---------------------------------------------------- */
	//                    UE       RXNEIE    TE       RE
	USART_CR1(iuart) |= (1<<13) | (1<<5) | (1<<3) | (1<<2);
 8004938:	68e3      	ldr	r3, [r4, #12]
 800493a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800493e:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
 8004942:	60e3      	str	r3, [r4, #12]

	/* UART interrupt */
	NVICIPR (uartpins.irqnumber, uart_int_priority);	// Set uart interrupt priority (tx)
 8004944:	9a01      	ldr	r2, [sp, #4]
 8004946:	f022 0303 	bic.w	r3, r2, #3
 800494a:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 800494e:	f503 4364 	add.w	r3, r3, #58368	; 0xe400
 8004952:	f002 0203 	and.w	r2, r2, #3
 8004956:	00d2      	lsls	r2, r2, #3
 8004958:	fa08 f802 	lsl.w	r8, r8, r2
 800495c:	681a      	ldr	r2, [r3, #0]
 800495e:	ea42 0208 	orr.w	r2, r2, r8
 8004962:	601a      	str	r2, [r3, #0]
	NVICISER(uartpins.irqnumber);				// Enable interrupt
 8004964:	9a01      	ldr	r2, [sp, #4]
 8004966:	4b09      	ldr	r3, [pc, #36]	; (800498c <bsp_uart_int_init+0xb8>)
 8004968:	0951      	lsrs	r1, r2, #5
 800496a:	18cb      	adds	r3, r1, r3
 800496c:	009b      	lsls	r3, r3, #2
 800496e:	2101      	movs	r1, #1
 8004970:	f002 021f 	and.w	r2, r2, #31
 8004974:	fa11 f202 	lsls.w	r2, r1, r2
 8004978:	6819      	ldr	r1, [r3, #0]
 800497a:	ea41 0202 	orr.w	r2, r1, r2
 800497e:	601a      	str	r2, [r3, #0]
	
	return 0;
}
 8004980:	2000      	movs	r0, #0
 8004982:	e8bd 83fe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, pc}
 8004986:	bf00      	nop
 8004988:	200008cc 	.word	0x200008cc
 800498c:	38003840 	.word	0x38003840

08004990 <bsp_uart_int_init_number>:
 * int bsp_uart_int_init_number(u32 uartnumber, u32 baud,u32 rxbuffsize, u32 txbuffsize, u32 dma_tx_int_priority);
 * @brief	: A wrapper for 'int bsp_uart_int_init' with uart number (1-6) rather than uart base address as the first argument
 * @return	: Same as bsp_uart_int_init
*******************************************************************************/
int bsp_uart_int_init_number(u32 uartnumber, u32 baud, u32 rxbuffsize, u32 txbuffsize,  u32 uart_int_priority)
{
 8004990:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004994:	9f06      	ldr	r7, [sp, #24]
 8004996:	460e      	mov	r6, r1
 8004998:	4615      	mov	r5, r2
 800499a:	461c      	mov	r4, r3
	u32 iuart = uartnumber_to_baseaddr(uartnumber);
 800499c:	f7ff fcc4 	bl	8004328 <uartnumber_to_baseaddr>
	return  bsp_uart_int_init(iuart, baud, rxbuffsize, txbuffsize, uart_int_priority);
 80049a0:	4631      	mov	r1, r6
 80049a2:	462a      	mov	r2, r5
 80049a4:	4623      	mov	r3, r4
 80049a6:	9706      	str	r7, [sp, #24]
}
 80049a8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 * @return	: Same as bsp_uart_int_init
*******************************************************************************/
int bsp_uart_int_init_number(u32 uartnumber, u32 baud, u32 rxbuffsize, u32 txbuffsize,  u32 uart_int_priority)
{
	u32 iuart = uartnumber_to_baseaddr(uartnumber);
	return  bsp_uart_int_init(iuart, baud, rxbuffsize, txbuffsize, uart_int_priority);
 80049ac:	e792      	b.n	80048d4 <bsp_uart_int_init>

080049ae <UART_IRQHandler>:
void  UART8_IRQHandler(void) {UART_IRQHandler(&cb_uart[7]); return;}

void UART_IRQHandler(struct CB_UART* pctl)
{
	/* Receive */
	if ((USART_SR(pctl->iuart) & USART_SR_RXNE) != 0) // Receive reg loaded?
 80049ae:	6843      	ldr	r3, [r0, #4]
 80049b0:	681b      	ldr	r3, [r3, #0]
 80049b2:	f013 0f20 	tst.w	r3, #32
void USART6_IRQHandler(void) {UART_IRQHandler(&cb_uart[5]); return;}
void  UART7_IRQHandler(void) {UART_IRQHandler(&cb_uart[6]); return;}
void  UART8_IRQHandler(void) {UART_IRQHandler(&cb_uart[7]); return;}

void UART_IRQHandler(struct CB_UART* pctl)
{
 80049b6:	b510      	push	{r4, lr}
 80049b8:	4604      	mov	r4, r0
	/* Receive */
	if ((USART_SR(pctl->iuart) & USART_SR_RXNE) != 0) // Receive reg loaded?
 80049ba:	d007      	beq.n	80049cc <UART_IRQHandler+0x1e>
	{  // Here, receive interrupt flag is on. 
		*pctl->rxbuff_in = USART_DR(pctl->iuart);// Read and store char
 80049bc:	6843      	ldr	r3, [r0, #4]
 80049be:	685a      	ldr	r2, [r3, #4]
 80049c0:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80049c2:	701a      	strb	r2, [r3, #0]

		/* Advance pointers to line buffers and array of counts and reset when end reached */	
		pctl->rxbuff_in = rxbuff_adv(pctl, pctl->rxbuff_in);	// Advance pointers common routine
 80049c4:	6b81      	ldr	r1, [r0, #56]	; 0x38
 80049c6:	f7ff fbd5 	bl	8004174 <rxbuff_adv>
 80049ca:	63a0      	str	r0, [r4, #56]	; 0x38
	}

	/* Transmit */
	if ( (USART_CR1(pctl->iuart) & USART_CR1_TXEIE) != 0)
 80049cc:	6863      	ldr	r3, [r4, #4]
 80049ce:	68db      	ldr	r3, [r3, #12]
 80049d0:	f013 0f80 	tst.w	r3, #128	; 0x80
 80049d4:	d014      	beq.n	8004a00 <UART_IRQHandler+0x52>
	{  // Here, yes.  Transmit interrupts are enabled so check if a tx interrupt
		if ( (USART_SR(pctl->iuart) & USART_SR_TXE) != 0) // Transmit register empty?
 80049d6:	6863      	ldr	r3, [r4, #4]
 80049d8:	681b      	ldr	r3, [r3, #0]
 80049da:	f013 0f80 	tst.w	r3, #128	; 0x80
 80049de:	d00f      	beq.n	8004a00 <UART_IRQHandler+0x52>
		{ // Here, yes.
			USART_DR(pctl->iuart) = *pctl->txbuff_out;// Send next char, step pointer
 80049e0:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80049e2:	6863      	ldr	r3, [r4, #4]
 80049e4:	780a      	ldrb	r2, [r1, #0]

			/* Advance output pointer */
			pctl->txbuff_out = txbuff_adv(pctl, pctl->txbuff_out);
 80049e6:	4620      	mov	r0, r4
	/* Transmit */
	if ( (USART_CR1(pctl->iuart) & USART_CR1_TXEIE) != 0)
	{  // Here, yes.  Transmit interrupts are enabled so check if a tx interrupt
		if ( (USART_SR(pctl->iuart) & USART_SR_TXE) != 0) // Transmit register empty?
		{ // Here, yes.
			USART_DR(pctl->iuart) = *pctl->txbuff_out;// Send next char, step pointer
 80049e8:	605a      	str	r2, [r3, #4]

			/* Advance output pointer */
			pctl->txbuff_out = txbuff_adv(pctl, pctl->txbuff_out);
 80049ea:	f7ff fbca 	bl	8004182 <txbuff_adv>

			/* Was the last byte loaded the last to send? */		
			if (pctl->txbuff_out == pctl->txbuff_in)
 80049ee:	6a23      	ldr	r3, [r4, #32]
		if ( (USART_SR(pctl->iuart) & USART_SR_TXE) != 0) // Transmit register empty?
		{ // Here, yes.
			USART_DR(pctl->iuart) = *pctl->txbuff_out;// Send next char, step pointer

			/* Advance output pointer */
			pctl->txbuff_out = txbuff_adv(pctl, pctl->txbuff_out);
 80049f0:	6260      	str	r0, [r4, #36]	; 0x24

			/* Was the last byte loaded the last to send? */		
			if (pctl->txbuff_out == pctl->txbuff_in)
 80049f2:	4298      	cmp	r0, r3
 80049f4:	d104      	bne.n	8004a00 <UART_IRQHandler+0x52>
			{ // Here yes. 
				USART_CR1(pctl->iuart) &= ~USART_CR1_TXEIE;		// Disable Tx interrupt	
 80049f6:	6863      	ldr	r3, [r4, #4]
 80049f8:	68da      	ldr	r2, [r3, #12]
 80049fa:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80049fe:	60da      	str	r2, [r3, #12]
 8004a00:	bd10      	pop	{r4, pc}

08004a02 <UART8_IRQHandler>:
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
void  UART5_IRQHandler(void) {UART_IRQHandler(&cb_uart[4]); return;}
void USART6_IRQHandler(void) {UART_IRQHandler(&cb_uart[5]); return;}
void  UART7_IRQHandler(void) {UART_IRQHandler(&cb_uart[6]); return;}
void  UART8_IRQHandler(void) {UART_IRQHandler(&cb_uart[7]); return;}
 8004a02:	4801      	ldr	r0, [pc, #4]	; (8004a08 <UART8_IRQHandler+0x6>)
 8004a04:	e7d3      	b.n	80049ae <UART_IRQHandler>
 8004a06:	bf00      	nop
 8004a08:	20000a90 	.word	0x20000a90

08004a0c <UART7_IRQHandler>:
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
void  UART5_IRQHandler(void) {UART_IRQHandler(&cb_uart[4]); return;}
void USART6_IRQHandler(void) {UART_IRQHandler(&cb_uart[5]); return;}
void  UART7_IRQHandler(void) {UART_IRQHandler(&cb_uart[6]); return;}
 8004a0c:	4800      	ldr	r0, [pc, #0]	; (8004a10 <UART7_IRQHandler+0x4>)
 8004a0e:	e7ce      	b.n	80049ae <UART_IRQHandler>
 8004a10:	20000a50 	.word	0x20000a50

08004a14 <USART6_IRQHandler>:
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
void  UART5_IRQHandler(void) {UART_IRQHandler(&cb_uart[4]); return;}
void USART6_IRQHandler(void) {UART_IRQHandler(&cb_uart[5]); return;}
 8004a14:	4800      	ldr	r0, [pc, #0]	; (8004a18 <USART6_IRQHandler+0x4>)
 8004a16:	e7ca      	b.n	80049ae <UART_IRQHandler>
 8004a18:	20000a10 	.word	0x20000a10

08004a1c <UART5_IRQHandler>:
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
void  UART5_IRQHandler(void) {UART_IRQHandler(&cb_uart[4]); return;}
 8004a1c:	4800      	ldr	r0, [pc, #0]	; (8004a20 <UART5_IRQHandler+0x4>)
 8004a1e:	e7c6      	b.n	80049ae <UART_IRQHandler>
 8004a20:	200009d0 	.word	0x200009d0

08004a24 <UART4_IRQHandler>:
/* USART/UART interrupts use a common IRQ handler.  Pass the control block pointer. */
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
 8004a24:	4800      	ldr	r0, [pc, #0]	; (8004a28 <UART4_IRQHandler+0x4>)
 8004a26:	e7c2      	b.n	80049ae <UART_IRQHandler>
 8004a28:	20000990 	.word	0x20000990

08004a2c <USART3_IRQHandler>:
 *####################################################################################### */
/* USART/UART interrupts use a common IRQ handler.  Pass the control block pointer. */
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
 8004a2c:	4800      	ldr	r0, [pc, #0]	; (8004a30 <USART3_IRQHandler+0x4>)
 8004a2e:	e7be      	b.n	80049ae <UART_IRQHandler>
 8004a30:	20000950 	.word	0x20000950

08004a34 <USART2_IRQHandler>:
 * ISR routine
 *####################################################################################### */
/* USART/UART interrupts use a common IRQ handler.  Pass the control block pointer. */
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
 8004a34:	4800      	ldr	r0, [pc, #0]	; (8004a38 <USART2_IRQHandler+0x4>)
 8004a36:	e7ba      	b.n	80049ae <UART_IRQHandler>
 8004a38:	20000910 	.word	0x20000910

08004a3c <USART1_IRQHandler>:
/*#######################################################################################
 * ISR routine
 *####################################################################################### */
/* USART/UART interrupts use a common IRQ handler.  Pass the control block pointer. */
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
 8004a3c:	4800      	ldr	r0, [pc, #0]	; (8004a40 <USART1_IRQHandler+0x4>)
 8004a3e:	e7b6      	b.n	80049ae <UART_IRQHandler>
 8004a40:	200008d0 	.word	0x200008d0

08004a44 <xprintf>:
#include <stdarg.h>
#include <stdio.h>
#include "bsp_uart.h"

int xprintf(int uartnumber, const char *fmt, ...)
{
 8004a44:	b40e      	push	{r1, r2, r3}
 8004a46:	b530      	push	{r4, r5, lr}
 8004a48:	b0c2      	sub	sp, #264	; 0x108
 8004a4a:	aa45      	add	r2, sp, #276	; 0x114
 8004a4c:	4604      	mov	r4, r0
 8004a4e:	f852 1b04 	ldr.w	r1, [r2], #4
	va_list argp;
	char vv[256];\
	int r;
	va_start(argp, fmt);
	va_start(argp, fmt);
	r = vsprintf(vv, fmt, argp);
 8004a52:	a801      	add	r0, sp, #4
{
	va_list argp;
	char vv[256];\
	int r;
	va_start(argp, fmt);
	va_start(argp, fmt);
 8004a54:	9241      	str	r2, [sp, #260]	; 0x104
	r = vsprintf(vv, fmt, argp);
 8004a56:	f000 fd9f 	bl	8005598 <vsprintf>
	va_end(argp);
	bsp_uart_puts_uartnum(uartnumber,vv);
 8004a5a:	a901      	add	r1, sp, #4
	va_list argp;
	char vv[256];\
	int r;
	va_start(argp, fmt);
	va_start(argp, fmt);
	r = vsprintf(vv, fmt, argp);
 8004a5c:	4605      	mov	r5, r0
	va_end(argp);
	bsp_uart_puts_uartnum(uartnumber,vv);
 8004a5e:	4620      	mov	r0, r4
 8004a60:	f7ff ff0b 	bl	800487a <bsp_uart_puts_uartnum>
	return r;
}
 8004a64:	4628      	mov	r0, r5
 8004a66:	b042      	add	sp, #264	; 0x108
 8004a68:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8004a6c:	b003      	add	sp, #12
 8004a6e:	4770      	bx	lr

08004a70 <uart_pins>:
 * @param	: p = pointer to register base
 * @param	: pu = pointer to struct with return values
 * @return	: Edit check--0 = OK; not OK - panic_leds(8)
******************************************************************************/	
int uart_pins(u32 iuart, struct UARTPINS* pu)
{
 8004a70:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

	struct PINCONFIG	pin_uarttx = { \
 8004a72:	4a56      	ldr	r2, [pc, #344]	; (8004bcc <uart_pins+0x15c>)
 * @param	: p = pointer to register base
 * @param	: pu = pointer to struct with return values
 * @return	: Edit check--0 = OK; not OK - panic_leds(8)
******************************************************************************/	
int uart_pins(u32 iuart, struct UARTPINS* pu)
{
 8004a74:	4603      	mov	r3, r0

	struct PINCONFIG	pin_uarttx = { \
 8004a76:	6810      	ldr	r0, [r2, #0]
 8004a78:	9002      	str	r0, [sp, #8]
 8004a7a:	7910      	ldrb	r0, [r2, #4]
 8004a7c:	f88d 000c 	strb.w	r0, [sp, #12]
		GPIO_OTYPE_PP, 		// output type: push-pull 		
		GPIO_OSPEED_100MHZ, 	// speed: highest drive level
		GPIO_PUPD_NONE, 	// pull up/down: none
		0 };			// Alternate function code: to be filled in

	struct PINCONFIG	pin_uartrx = { \
 8004a80:	f852 0f05 	ldr.w	r0, [r2, #5]!
 8004a84:	7912      	ldrb	r2, [r2, #4]
 8004a86:	9000      	str	r0, [sp, #0]
 8004a88:	f88d 2004 	strb.w	r2, [sp, #4]
	u32	txport;
	u32	rxport;

	/* THIS IS BOARD SPECIFIC */
	// Set ports, pins, alternate function code, bus clock freq, and enable peripheral clock
	switch (iuart)
 8004a8c:	4a50      	ldr	r2, [pc, #320]	; (8004bd0 <uart_pins+0x160>)
 8004a8e:	4293      	cmp	r3, r2
 8004a90:	d04f      	beq.n	8004b32 <uart_pins+0xc2>
 8004a92:	d807      	bhi.n	8004aa4 <uart_pins+0x34>
 8004a94:	4a4f      	ldr	r2, [pc, #316]	; (8004bd4 <uart_pins+0x164>)
 8004a96:	4293      	cmp	r3, r2
 8004a98:	d023      	beq.n	8004ae2 <uart_pins+0x72>
 8004a9a:	4a4f      	ldr	r2, [pc, #316]	; (8004bd8 <uart_pins+0x168>)
 8004a9c:	4293      	cmp	r3, r2
 8004a9e:	f040 8091 	bne.w	8004bc4 <uart_pins+0x154>
 8004aa2:	e032      	b.n	8004b0a <uart_pins+0x9a>
 8004aa4:	4a4d      	ldr	r2, [pc, #308]	; (8004bdc <uart_pins+0x16c>)
 8004aa6:	4293      	cmp	r3, r2
 8004aa8:	d007      	beq.n	8004aba <uart_pins+0x4a>
 8004aaa:	4a4d      	ldr	r2, [pc, #308]	; (8004be0 <uart_pins+0x170>)
 8004aac:	4293      	cmp	r3, r2
 8004aae:	d068      	beq.n	8004b82 <uart_pins+0x112>
 8004ab0:	4a4c      	ldr	r2, [pc, #304]	; (8004be4 <uart_pins+0x174>)
 8004ab2:	4293      	cmp	r3, r2
 8004ab4:	f040 8086 	bne.w	8004bc4 <uart_pins+0x154>
 8004ab8:	e04f      	b.n	8004b5a <uart_pins+0xea>
	{
		case USART1:
			rxport = GPIOA; txport = GPIOA; txpin = 9; rxpin = 10; af = 7; pu->pclk = pclk2_freq;
 8004aba:	4b4b      	ldr	r3, [pc, #300]	; (8004be8 <uart_pins+0x178>)
 8004abc:	4c4b      	ldr	r4, [pc, #300]	; (8004bec <uart_pins+0x17c>)
 8004abe:	681b      	ldr	r3, [r3, #0]
 8004ac0:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x01;	// Port A
 8004ac2:	4b4b      	ldr	r3, [pc, #300]	; (8004bf0 <uart_pins+0x180>)
 8004ac4:	681a      	ldr	r2, [r3, #0]
 8004ac6:	f042 0201 	orr.w	r2, r2, #1
 8004aca:	601a      	str	r2, [r3, #0]
//			rxport = GPIOB; txport = GPIOB; txpin = 6; rxpin =  7; af = 7; pu->pclk = pclk2_freq;
//			RCC_AHB1ENR |= 0x02;	// Port B
			RCC_APB2ENR |= (1<<4); // Enable peripheral clock
 8004acc:	695a      	ldr	r2, [r3, #20]
 8004ace:	f042 0210 	orr.w	r2, r2, #16
 8004ad2:	615a      	str	r2, [r3, #20]
			pu->irqnumber = UART1_IRQ_NUMBER;
 8004ad4:	2325      	movs	r3, #37	; 0x25
 8004ad6:	604b      	str	r3, [r1, #4]
	/* THIS IS BOARD SPECIFIC */
	// Set ports, pins, alternate function code, bus clock freq, and enable peripheral clock
	switch (iuart)
	{
		case USART1:
			rxport = GPIOA; txport = GPIOA; txpin = 9; rxpin = 10; af = 7; pu->pclk = pclk2_freq;
 8004ad8:	4620      	mov	r0, r4
 8004ada:	2607      	movs	r6, #7
 8004adc:	2109      	movs	r1, #9
 8004ade:	250a      	movs	r5, #10
			RCC_AHB1ENR |= 0x01;	// Port A
//			rxport = GPIOB; txport = GPIOB; txpin = 6; rxpin =  7; af = 7; pu->pclk = pclk2_freq;
//			RCC_AHB1ENR |= 0x02;	// Port B
			RCC_APB2ENR |= (1<<4); // Enable peripheral clock
			pu->irqnumber = UART1_IRQ_NUMBER;
			break;
 8004ae0:	e062      	b.n	8004ba8 <uart_pins+0x138>

		case (u32)USART2:
			rxport = GPIOA; txport = GPIOA; txpin = 2; rxpin =  3; af = 7; pu->pclk = pclk1_freq;
 8004ae2:	4b44      	ldr	r3, [pc, #272]	; (8004bf4 <uart_pins+0x184>)
 8004ae4:	4c41      	ldr	r4, [pc, #260]	; (8004bec <uart_pins+0x17c>)
 8004ae6:	681b      	ldr	r3, [r3, #0]
 8004ae8:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x01;	// Port A
 8004aea:	4b41      	ldr	r3, [pc, #260]	; (8004bf0 <uart_pins+0x180>)
 8004aec:	681a      	ldr	r2, [r3, #0]
 8004aee:	f042 0201 	orr.w	r2, r2, #1
 8004af2:	601a      	str	r2, [r3, #0]
//			rxport = GPIOD; txport = GPIOD; txpin = 5; rxpin =  6; af = 7; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x08;	// Port D
			RCC_APB1ENR |= (1<<17); // Enable peripheral clock
 8004af4:	691a      	ldr	r2, [r3, #16]
 8004af6:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8004afa:	611a      	str	r2, [r3, #16]
			pu->irqnumber = UART2_IRQ_NUMBER;
 8004afc:	2326      	movs	r3, #38	; 0x26
 8004afe:	604b      	str	r3, [r1, #4]
			RCC_APB2ENR |= (1<<4); // Enable peripheral clock
			pu->irqnumber = UART1_IRQ_NUMBER;
			break;

		case (u32)USART2:
			rxport = GPIOA; txport = GPIOA; txpin = 2; rxpin =  3; af = 7; pu->pclk = pclk1_freq;
 8004b00:	4620      	mov	r0, r4
 8004b02:	2607      	movs	r6, #7
 8004b04:	2102      	movs	r1, #2
 8004b06:	2503      	movs	r5, #3
			RCC_AHB1ENR |= 0x01;	// Port A
//			rxport = GPIOD; txport = GPIOD; txpin = 5; rxpin =  6; af = 7; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x08;	// Port D
			RCC_APB1ENR |= (1<<17); // Enable peripheral clock
			pu->irqnumber = UART2_IRQ_NUMBER;
			break;
 8004b08:	e04e      	b.n	8004ba8 <uart_pins+0x138>
			
		case (u32)USART3:
//			rxport = GPIOB; txport = GPIOB; txpin = 10; rxpin = 11; af = 7; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x02;	// Port B
			rxport = GPIOD; txport = GPIOD; txpin =  8; rxpin =  9; af = 7; pu->pclk = pclk1_freq;
 8004b0a:	4b3a      	ldr	r3, [pc, #232]	; (8004bf4 <uart_pins+0x184>)
 8004b0c:	4c3a      	ldr	r4, [pc, #232]	; (8004bf8 <uart_pins+0x188>)
 8004b0e:	681b      	ldr	r3, [r3, #0]
 8004b10:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x08;	// Port D
 8004b12:	4b37      	ldr	r3, [pc, #220]	; (8004bf0 <uart_pins+0x180>)
 8004b14:	681a      	ldr	r2, [r3, #0]
 8004b16:	f042 0208 	orr.w	r2, r2, #8
 8004b1a:	601a      	str	r2, [r3, #0]
			RCC_APB1ENR |= (1<<18); // Enable peripheral clock
 8004b1c:	691a      	ldr	r2, [r3, #16]
 8004b1e:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8004b22:	611a      	str	r2, [r3, #16]
			pu->irqnumber = UART3_IRQ_NUMBER;
 8004b24:	2327      	movs	r3, #39	; 0x27
 8004b26:	604b      	str	r3, [r1, #4]
			break;
			
		case (u32)USART3:
//			rxport = GPIOB; txport = GPIOB; txpin = 10; rxpin = 11; af = 7; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x02;	// Port B
			rxport = GPIOD; txport = GPIOD; txpin =  8; rxpin =  9; af = 7; pu->pclk = pclk1_freq;
 8004b28:	4620      	mov	r0, r4
 8004b2a:	2607      	movs	r6, #7
 8004b2c:	2108      	movs	r1, #8
 8004b2e:	2509      	movs	r5, #9
			RCC_AHB1ENR |= 0x08;	// Port D
			RCC_APB1ENR |= (1<<18); // Enable peripheral clock
			pu->irqnumber = UART3_IRQ_NUMBER;
			break;
 8004b30:	e03a      	b.n	8004ba8 <uart_pins+0x138>

		case (u32)UART4:
//			rxport = GPIOA; txport = GPIOA; txpin =  0; rxpin =  1; af = 8; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x01;	// Port A
			rxport = GPIOC; txport = GPIOC; txpin = 10; rxpin = 11; af = 8; pu->pclk = pclk1_freq;
 8004b32:	4b30      	ldr	r3, [pc, #192]	; (8004bf4 <uart_pins+0x184>)
 8004b34:	4c31      	ldr	r4, [pc, #196]	; (8004bfc <uart_pins+0x18c>)
 8004b36:	681b      	ldr	r3, [r3, #0]
 8004b38:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x04;	// Port C
 8004b3a:	4b2d      	ldr	r3, [pc, #180]	; (8004bf0 <uart_pins+0x180>)
 8004b3c:	681a      	ldr	r2, [r3, #0]
 8004b3e:	f042 0204 	orr.w	r2, r2, #4
 8004b42:	601a      	str	r2, [r3, #0]
			RCC_APB1ENR |= (1<<19); // Enable peripheral clock
 8004b44:	691a      	ldr	r2, [r3, #16]
 8004b46:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8004b4a:	611a      	str	r2, [r3, #16]
			pu->irqnumber = UART4_IRQ_NUMBER;
 8004b4c:	2334      	movs	r3, #52	; 0x34
 8004b4e:	604b      	str	r3, [r1, #4]
			break;

		case (u32)UART4:
//			rxport = GPIOA; txport = GPIOA; txpin =  0; rxpin =  1; af = 8; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x01;	// Port A
			rxport = GPIOC; txport = GPIOC; txpin = 10; rxpin = 11; af = 8; pu->pclk = pclk1_freq;
 8004b50:	4620      	mov	r0, r4
 8004b52:	2608      	movs	r6, #8
 8004b54:	210a      	movs	r1, #10
 8004b56:	250b      	movs	r5, #11
			RCC_AHB1ENR |= 0x04;	// Port C
			RCC_APB1ENR |= (1<<19); // Enable peripheral clock
			pu->irqnumber = UART4_IRQ_NUMBER;
			break;
 8004b58:	e026      	b.n	8004ba8 <uart_pins+0x138>

		case (u32)UART5:
			txport = GPIOC; rxport = GPIOD; txpin = 12; rxpin =  2; af = 8; pu->pclk = pclk1_freq;
 8004b5a:	4b26      	ldr	r3, [pc, #152]	; (8004bf4 <uart_pins+0x184>)
 8004b5c:	4c26      	ldr	r4, [pc, #152]	; (8004bf8 <uart_pins+0x188>)
 8004b5e:	681b      	ldr	r3, [r3, #0]
 8004b60:	4826      	ldr	r0, [pc, #152]	; (8004bfc <uart_pins+0x18c>)
 8004b62:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x06;	// Port C & D
 8004b64:	4b22      	ldr	r3, [pc, #136]	; (8004bf0 <uart_pins+0x180>)
 8004b66:	681a      	ldr	r2, [r3, #0]
 8004b68:	f042 0206 	orr.w	r2, r2, #6
 8004b6c:	601a      	str	r2, [r3, #0]
			RCC_APB1ENR |= (1<<20); // Enable peripheral clock
 8004b6e:	691a      	ldr	r2, [r3, #16]
 8004b70:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8004b74:	611a      	str	r2, [r3, #16]
			pu->irqnumber = UART5_IRQ_NUMBER;
 8004b76:	2335      	movs	r3, #53	; 0x35
 8004b78:	604b      	str	r3, [r1, #4]
			RCC_APB1ENR |= (1<<19); // Enable peripheral clock
			pu->irqnumber = UART4_IRQ_NUMBER;
			break;

		case (u32)UART5:
			txport = GPIOC; rxport = GPIOD; txpin = 12; rxpin =  2; af = 8; pu->pclk = pclk1_freq;
 8004b7a:	2608      	movs	r6, #8
 8004b7c:	210c      	movs	r1, #12
 8004b7e:	2502      	movs	r5, #2
			RCC_AHB1ENR |= 0x06;	// Port C & D
			RCC_APB1ENR |= (1<<20); // Enable peripheral clock
			pu->irqnumber = UART5_IRQ_NUMBER;
			break;
 8004b80:	e012      	b.n	8004ba8 <uart_pins+0x138>

		case (u32)USART6:
			txport = GPIOC; rxport = GPIOC; txpin =  6; rxpin =  7; af = 8; pu->pclk = pclk2_freq;
 8004b82:	4b19      	ldr	r3, [pc, #100]	; (8004be8 <uart_pins+0x178>)
 8004b84:	4c1d      	ldr	r4, [pc, #116]	; (8004bfc <uart_pins+0x18c>)
 8004b86:	681b      	ldr	r3, [r3, #0]
 8004b88:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x04;	// Port C
 8004b8a:	4b19      	ldr	r3, [pc, #100]	; (8004bf0 <uart_pins+0x180>)
 8004b8c:	681a      	ldr	r2, [r3, #0]
 8004b8e:	f042 0204 	orr.w	r2, r2, #4
 8004b92:	601a      	str	r2, [r3, #0]
			RCC_APB2ENR |= (1<<5); 	// Enable peripheral clock
 8004b94:	695a      	ldr	r2, [r3, #20]
 8004b96:	f042 0220 	orr.w	r2, r2, #32
 8004b9a:	615a      	str	r2, [r3, #20]
			pu->irqnumber = UART6_IRQ_NUMBER;			
 8004b9c:	2347      	movs	r3, #71	; 0x47
 8004b9e:	604b      	str	r3, [r1, #4]
			RCC_APB1ENR |= (1<<20); // Enable peripheral clock
			pu->irqnumber = UART5_IRQ_NUMBER;
			break;

		case (u32)USART6:
			txport = GPIOC; rxport = GPIOC; txpin =  6; rxpin =  7; af = 8; pu->pclk = pclk2_freq;
 8004ba0:	4620      	mov	r0, r4
 8004ba2:	2608      	movs	r6, #8
 8004ba4:	2106      	movs	r1, #6
 8004ba6:	2507      	movs	r5, #7
			return -1;	// Pin assignments: Shouldn't happen
	}

	/* Configure tx pin */
	pin_uarttx.afrl = af;
	f4gpiopins_Config ((volatile u32*)txport, txpin, (struct PINCONFIG*)&pin_uarttx);
 8004ba8:	aa02      	add	r2, sp, #8
		default:
			return -1;	// Pin assignments: Shouldn't happen
	}

	/* Configure tx pin */
	pin_uarttx.afrl = af;
 8004baa:	f88d 600c 	strb.w	r6, [sp, #12]
	f4gpiopins_Config ((volatile u32*)txport, txpin, (struct PINCONFIG*)&pin_uarttx);
 8004bae:	f7fe ff62 	bl	8003a76 <f4gpiopins_Config>

	/* Configure rx pin */
	pin_uartrx.afrl = af;
	f4gpiopins_Config ((volatile u32*)rxport, rxpin, (struct PINCONFIG*)&pin_uartrx);
 8004bb2:	4620      	mov	r0, r4
 8004bb4:	4629      	mov	r1, r5
 8004bb6:	466a      	mov	r2, sp
	/* Configure tx pin */
	pin_uarttx.afrl = af;
	f4gpiopins_Config ((volatile u32*)txport, txpin, (struct PINCONFIG*)&pin_uarttx);

	/* Configure rx pin */
	pin_uartrx.afrl = af;
 8004bb8:	f88d 6004 	strb.w	r6, [sp, #4]
	f4gpiopins_Config ((volatile u32*)rxport, rxpin, (struct PINCONFIG*)&pin_uartrx);
 8004bbc:	f7fe ff5b 	bl	8003a76 <f4gpiopins_Config>

	return 0;
 8004bc0:	2000      	movs	r0, #0
 8004bc2:	e001      	b.n	8004bc8 <uart_pins+0x158>
			RCC_APB2ENR |= (1<<5); 	// Enable peripheral clock
			pu->irqnumber = UART6_IRQ_NUMBER;			
			break;

		default:
			return -1;	// Pin assignments: Shouldn't happen
 8004bc4:	f04f 30ff 	mov.w	r0, #4294967295
	/* Configure rx pin */
	pin_uartrx.afrl = af;
	f4gpiopins_Config ((volatile u32*)rxport, rxpin, (struct PINCONFIG*)&pin_uartrx);

	return 0;
}
 8004bc8:	b004      	add	sp, #16
 8004bca:	bd70      	pop	{r4, r5, r6, pc}
 8004bcc:	0800b764 	.word	0x0800b764
 8004bd0:	40004c00 	.word	0x40004c00
 8004bd4:	40004400 	.word	0x40004400
 8004bd8:	40004800 	.word	0x40004800
 8004bdc:	40011000 	.word	0x40011000
 8004be0:	40011400 	.word	0x40011400
 8004be4:	40005000 	.word	0x40005000
 8004be8:	2000083c 	.word	0x2000083c
 8004bec:	40020000 	.word	0x40020000
 8004bf0:	40023830 	.word	0x40023830
 8004bf4:	20000838 	.word	0x20000838
 8004bf8:	40020c00 	.word	0x40020c00
 8004bfc:	40020800 	.word	0x40020800

08004c00 <usartx_setbaud>:
	u32 tmpreg = 0x00;
	u32 fractionaldivider = 0x00;
	u32 integerdivider = 0x00;

	/* Determine the integer part */
	integerdivider = ((0x19 * pclk_freq) / (0x04 * u32BaudRate));
 8004c00:	2319      	movs	r3, #25
 8004c02:	434b      	muls	r3, r1
 8004c04:	0092      	lsls	r2, r2, #2
 8004c06:	fbb3 f3f2 	udiv	r3, r3, r2
	tmpreg = (integerdivider / 0x64) << 0x04;
 8004c0a:	2164      	movs	r1, #100	; 0x64
 * void usartx_setbaud (u32 usartx, u32 pclk_freq, u32 u32BaudRate);
 * @brief	: set baudrate register (BRR)
 * @param	: u32BaudRate is the baud rate.
******************************************************************************/
void usartx_setbaud (u32 usartx, u32 pclk_freq, u32 u32BaudRate)
{
 8004c0c:	b510      	push	{r4, lr}
	u32 fractionaldivider = 0x00;
	u32 integerdivider = 0x00;

	/* Determine the integer part */
	integerdivider = ((0x19 * pclk_freq) / (0x04 * u32BaudRate));
	tmpreg = (integerdivider / 0x64) << 0x04;
 8004c0e:	fbb3 f4f1 	udiv	r4, r3, r1
 8004c12:	0124      	lsls	r4, r4, #4

	/* Determine the fractional part */
	fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
 8004c14:	0922      	lsrs	r2, r4, #4
 8004c16:	fb01 3312 	mls	r3, r1, r2, r3
	tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((u8)0x0F);
 8004c1a:	011b      	lsls	r3, r3, #4
 8004c1c:	3332      	adds	r3, #50	; 0x32
 8004c1e:	fbb3 f1f1 	udiv	r1, r3, r1
 8004c22:	f001 010f 	and.w	r1, r1, #15
 8004c26:	ea41 0404 	orr.w	r4, r1, r4

	/* Set USART BRR --------------------------------------------------------------- */
	  USART_BRR(usartx) = (u16)tmpreg;
 8004c2a:	b2a4      	uxth	r4, r4
 8004c2c:	6084      	str	r4, [r0, #8]
	return;
}
 8004c2e:	bd10      	pop	{r4, pc}

08004c30 <__libc_init_array>:
 8004c30:	b570      	push	{r4, r5, r6, lr}
 8004c32:	f64b 36ac 	movw	r6, #48044	; 0xbbac
 8004c36:	f64b 35ac 	movw	r5, #48044	; 0xbbac
 8004c3a:	f6c0 0600 	movt	r6, #2048	; 0x800
 8004c3e:	f6c0 0500 	movt	r5, #2048	; 0x800
 8004c42:	1b76      	subs	r6, r6, r5
 8004c44:	10b6      	asrs	r6, r6, #2
 8004c46:	d006      	beq.n	8004c56 <__libc_init_array+0x26>
 8004c48:	2400      	movs	r4, #0
 8004c4a:	f855 3b04 	ldr.w	r3, [r5], #4
 8004c4e:	3401      	adds	r4, #1
 8004c50:	4798      	blx	r3
 8004c52:	42a6      	cmp	r6, r4
 8004c54:	d1f9      	bne.n	8004c4a <__libc_init_array+0x1a>
 8004c56:	f64b 36ac 	movw	r6, #48044	; 0xbbac
 8004c5a:	f64b 35ac 	movw	r5, #48044	; 0xbbac
 8004c5e:	f6c0 0600 	movt	r6, #2048	; 0x800
 8004c62:	f6c0 0500 	movt	r5, #2048	; 0x800
 8004c66:	1b76      	subs	r6, r6, r5
 8004c68:	f7fc f90b 	bl	8000e82 <_init>
 8004c6c:	10b6      	asrs	r6, r6, #2
 8004c6e:	d006      	beq.n	8004c7e <__libc_init_array+0x4e>
 8004c70:	2400      	movs	r4, #0
 8004c72:	f855 3b04 	ldr.w	r3, [r5], #4
 8004c76:	3401      	adds	r4, #1
 8004c78:	4798      	blx	r3
 8004c7a:	42a6      	cmp	r6, r4
 8004c7c:	d1f9      	bne.n	8004c72 <__libc_init_array+0x42>
 8004c7e:	bd70      	pop	{r4, r5, r6, pc}

08004c80 <malloc>:
 8004c80:	f240 236c 	movw	r3, #620	; 0x26c
 8004c84:	4601      	mov	r1, r0
 8004c86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c8a:	6818      	ldr	r0, [r3, #0]
 8004c8c:	f000 b808 	b.w	8004ca0 <_malloc_r>

08004c90 <free>:
 8004c90:	f240 236c 	movw	r3, #620	; 0x26c
 8004c94:	4601      	mov	r1, r0
 8004c96:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c9a:	6818      	ldr	r0, [r3, #0]
 8004c9c:	f000 bee2 	b.w	8005a64 <_free_r>

08004ca0 <_malloc_r>:
 8004ca0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004ca4:	f101 040b 	add.w	r4, r1, #11
 8004ca8:	2c16      	cmp	r4, #22
 8004caa:	b083      	sub	sp, #12
 8004cac:	4606      	mov	r6, r0
 8004cae:	d931      	bls.n	8004d14 <_malloc_r+0x74>
 8004cb0:	f024 0407 	bic.w	r4, r4, #7
 8004cb4:	0fe3      	lsrs	r3, r4, #31
 8004cb6:	428c      	cmp	r4, r1
 8004cb8:	bf2c      	ite	cs
 8004cba:	4619      	movcs	r1, r3
 8004cbc:	f043 0101 	orrcc.w	r1, r3, #1
 8004cc0:	2900      	cmp	r1, #0
 8004cc2:	d130      	bne.n	8004d26 <_malloc_r+0x86>
 8004cc4:	4630      	mov	r0, r6
 8004cc6:	f000 faa9 	bl	800521c <__malloc_lock>
 8004cca:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
 8004cce:	d22f      	bcs.n	8004d30 <_malloc_r+0x90>
 8004cd0:	ea4f 0cd4 	mov.w	ip, r4, lsr #3
 8004cd4:	f240 3560 	movw	r5, #864	; 0x360
 8004cd8:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8004cdc:	eb05 02cc 	add.w	r2, r5, ip, lsl #3
 8004ce0:	462f      	mov	r7, r5
 8004ce2:	68d3      	ldr	r3, [r2, #12]
 8004ce4:	4293      	cmp	r3, r2
 8004ce6:	f000 822d 	beq.w	8005144 <_malloc_r+0x4a4>
 8004cea:	685c      	ldr	r4, [r3, #4]
 8004cec:	f103 0808 	add.w	r8, r3, #8
 8004cf0:	68da      	ldr	r2, [r3, #12]
 8004cf2:	4630      	mov	r0, r6
 8004cf4:	f024 0403 	bic.w	r4, r4, #3
 8004cf8:	6899      	ldr	r1, [r3, #8]
 8004cfa:	191b      	adds	r3, r3, r4
 8004cfc:	685c      	ldr	r4, [r3, #4]
 8004cfe:	60ca      	str	r2, [r1, #12]
 8004d00:	f044 0401 	orr.w	r4, r4, #1
 8004d04:	6091      	str	r1, [r2, #8]
 8004d06:	605c      	str	r4, [r3, #4]
 8004d08:	f000 fa8a 	bl	8005220 <__malloc_unlock>
 8004d0c:	4640      	mov	r0, r8
 8004d0e:	b003      	add	sp, #12
 8004d10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004d14:	2300      	movs	r3, #0
 8004d16:	2410      	movs	r4, #16
 8004d18:	428c      	cmp	r4, r1
 8004d1a:	bf2c      	ite	cs
 8004d1c:	4619      	movcs	r1, r3
 8004d1e:	f043 0101 	orrcc.w	r1, r3, #1
 8004d22:	2900      	cmp	r1, #0
 8004d24:	d0ce      	beq.n	8004cc4 <_malloc_r+0x24>
 8004d26:	230c      	movs	r3, #12
 8004d28:	f04f 0800 	mov.w	r8, #0
 8004d2c:	6033      	str	r3, [r6, #0]
 8004d2e:	e7ed      	b.n	8004d0c <_malloc_r+0x6c>
 8004d30:	ea5f 2c54 	movs.w	ip, r4, lsr #9
 8004d34:	bf04      	itt	eq
 8004d36:	ea4f 0cd4 	moveq.w	ip, r4, lsr #3
 8004d3a:	ea4f 00cc 	moveq.w	r0, ip, lsl #3
 8004d3e:	f040 8086 	bne.w	8004e4e <_malloc_r+0x1ae>
 8004d42:	f240 3560 	movw	r5, #864	; 0x360
 8004d46:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8004d4a:	1828      	adds	r0, r5, r0
 8004d4c:	462f      	mov	r7, r5
 8004d4e:	68c3      	ldr	r3, [r0, #12]
 8004d50:	4298      	cmp	r0, r3
 8004d52:	d106      	bne.n	8004d62 <_malloc_r+0xc2>
 8004d54:	e00d      	b.n	8004d72 <_malloc_r+0xd2>
 8004d56:	2900      	cmp	r1, #0
 8004d58:	f280 8179 	bge.w	800504e <_malloc_r+0x3ae>
 8004d5c:	68db      	ldr	r3, [r3, #12]
 8004d5e:	4298      	cmp	r0, r3
 8004d60:	d007      	beq.n	8004d72 <_malloc_r+0xd2>
 8004d62:	685a      	ldr	r2, [r3, #4]
 8004d64:	f022 0203 	bic.w	r2, r2, #3
 8004d68:	1b11      	subs	r1, r2, r4
 8004d6a:	290f      	cmp	r1, #15
 8004d6c:	ddf3      	ble.n	8004d56 <_malloc_r+0xb6>
 8004d6e:	f10c 3cff 	add.w	ip, ip, #4294967295
 8004d72:	f10c 0c01 	add.w	ip, ip, #1
 8004d76:	4abd      	ldr	r2, [pc, #756]	; (800506c <_malloc_r+0x3cc>)
 8004d78:	6893      	ldr	r3, [r2, #8]
 8004d7a:	429a      	cmp	r2, r3
 8004d7c:	bf08      	it	eq
 8004d7e:	6878      	ldreq	r0, [r7, #4]
 8004d80:	d024      	beq.n	8004dcc <_malloc_r+0x12c>
 8004d82:	6858      	ldr	r0, [r3, #4]
 8004d84:	f020 0003 	bic.w	r0, r0, #3
 8004d88:	1b01      	subs	r1, r0, r4
 8004d8a:	290f      	cmp	r1, #15
 8004d8c:	f300 81c0 	bgt.w	8005110 <_malloc_r+0x470>
 8004d90:	2900      	cmp	r1, #0
 8004d92:	60d2      	str	r2, [r2, #12]
 8004d94:	6092      	str	r2, [r2, #8]
 8004d96:	f280 8094 	bge.w	8004ec2 <_malloc_r+0x222>
 8004d9a:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8004d9e:	f080 8177 	bcs.w	8005090 <_malloc_r+0x3f0>
 8004da2:	08c0      	lsrs	r0, r0, #3
 8004da4:	f04f 0e01 	mov.w	lr, #1
 8004da8:	f8d7 8004 	ldr.w	r8, [r7, #4]
 8004dac:	eb07 01c0 	add.w	r1, r7, r0, lsl #3
 8004db0:	1080      	asrs	r0, r0, #2
 8004db2:	fa0e f000 	lsl.w	r0, lr, r0
 8004db6:	60d9      	str	r1, [r3, #12]
 8004db8:	f8d1 e008 	ldr.w	lr, [r1, #8]
 8004dbc:	ea40 0008 	orr.w	r0, r0, r8
 8004dc0:	6078      	str	r0, [r7, #4]
 8004dc2:	f8c3 e008 	str.w	lr, [r3, #8]
 8004dc6:	f8ce 300c 	str.w	r3, [lr, #12]
 8004dca:	608b      	str	r3, [r1, #8]
 8004dcc:	f04f 0e01 	mov.w	lr, #1
 8004dd0:	ea4f 03ac 	mov.w	r3, ip, asr #2
 8004dd4:	fa0e fe03 	lsl.w	lr, lr, r3
 8004dd8:	4586      	cmp	lr, r0
 8004dda:	d87d      	bhi.n	8004ed8 <_malloc_r+0x238>
 8004ddc:	ea10 0f0e 	tst.w	r0, lr
 8004de0:	d108      	bne.n	8004df4 <_malloc_r+0x154>
 8004de2:	f02c 0c03 	bic.w	ip, ip, #3
 8004de6:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 8004dea:	f10c 0c04 	add.w	ip, ip, #4
 8004dee:	ea10 0f0e 	tst.w	r0, lr
 8004df2:	d0f8      	beq.n	8004de6 <_malloc_r+0x146>
 8004df4:	eb07 0acc 	add.w	sl, r7, ip, lsl #3
 8004df8:	46e1      	mov	r9, ip
 8004dfa:	46d0      	mov	r8, sl
 8004dfc:	f8d8 000c 	ldr.w	r0, [r8, #12]
 8004e00:	4580      	cmp	r8, r0
 8004e02:	d107      	bne.n	8004e14 <_malloc_r+0x174>
 8004e04:	e196      	b.n	8005134 <_malloc_r+0x494>
 8004e06:	2b00      	cmp	r3, #0
 8004e08:	f280 81a6 	bge.w	8005158 <_malloc_r+0x4b8>
 8004e0c:	68c0      	ldr	r0, [r0, #12]
 8004e0e:	4580      	cmp	r8, r0
 8004e10:	f000 8190 	beq.w	8005134 <_malloc_r+0x494>
 8004e14:	6841      	ldr	r1, [r0, #4]
 8004e16:	f021 0103 	bic.w	r1, r1, #3
 8004e1a:	1b0b      	subs	r3, r1, r4
 8004e1c:	2b0f      	cmp	r3, #15
 8004e1e:	ddf2      	ble.n	8004e06 <_malloc_r+0x166>
 8004e20:	4680      	mov	r8, r0
 8004e22:	68c5      	ldr	r5, [r0, #12]
 8004e24:	1901      	adds	r1, r0, r4
 8004e26:	f044 0e01 	orr.w	lr, r4, #1
 8004e2a:	f858 7f08 	ldr.w	r7, [r8, #8]!
 8004e2e:	f043 0401 	orr.w	r4, r3, #1
 8004e32:	f8c0 e004 	str.w	lr, [r0, #4]
 8004e36:	4630      	mov	r0, r6
 8004e38:	604c      	str	r4, [r1, #4]
 8004e3a:	60fd      	str	r5, [r7, #12]
 8004e3c:	60af      	str	r7, [r5, #8]
 8004e3e:	60d1      	str	r1, [r2, #12]
 8004e40:	6091      	str	r1, [r2, #8]
 8004e42:	60ca      	str	r2, [r1, #12]
 8004e44:	608a      	str	r2, [r1, #8]
 8004e46:	50cb      	str	r3, [r1, r3]
 8004e48:	f000 f9ea 	bl	8005220 <__malloc_unlock>
 8004e4c:	e75e      	b.n	8004d0c <_malloc_r+0x6c>
 8004e4e:	f1bc 0f04 	cmp.w	ip, #4
 8004e52:	bf9e      	ittt	ls
 8004e54:	ea4f 1c94 	movls.w	ip, r4, lsr #6
 8004e58:	f10c 0c38 	addls.w	ip, ip, #56	; 0x38
 8004e5c:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8004e60:	f67f af6f 	bls.w	8004d42 <_malloc_r+0xa2>
 8004e64:	f1bc 0f14 	cmp.w	ip, #20
 8004e68:	bf9c      	itt	ls
 8004e6a:	f10c 0c5b 	addls.w	ip, ip, #91	; 0x5b
 8004e6e:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8004e72:	f67f af66 	bls.w	8004d42 <_malloc_r+0xa2>
 8004e76:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
 8004e7a:	bf9e      	ittt	ls
 8004e7c:	ea4f 3c14 	movls.w	ip, r4, lsr #12
 8004e80:	f10c 0c6e 	addls.w	ip, ip, #110	; 0x6e
 8004e84:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8004e88:	f67f af5b 	bls.w	8004d42 <_malloc_r+0xa2>
 8004e8c:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
 8004e90:	bf9e      	ittt	ls
 8004e92:	ea4f 3cd4 	movls.w	ip, r4, lsr #15
 8004e96:	f10c 0c77 	addls.w	ip, ip, #119	; 0x77
 8004e9a:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8004e9e:	f67f af50 	bls.w	8004d42 <_malloc_r+0xa2>
 8004ea2:	f240 5354 	movw	r3, #1364	; 0x554
 8004ea6:	459c      	cmp	ip, r3
 8004ea8:	bf95      	itete	ls
 8004eaa:	ea4f 4c94 	movls.w	ip, r4, lsr #18
 8004eae:	f44f 707c 	movhi.w	r0, #1008	; 0x3f0
 8004eb2:	f10c 0c7c 	addls.w	ip, ip, #124	; 0x7c
 8004eb6:	f04f 0c7e 	movhi.w	ip, #126	; 0x7e
 8004eba:	bf98      	it	ls
 8004ebc:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8004ec0:	e73f      	b.n	8004d42 <_malloc_r+0xa2>
 8004ec2:	181a      	adds	r2, r3, r0
 8004ec4:	f103 0808 	add.w	r8, r3, #8
 8004ec8:	4630      	mov	r0, r6
 8004eca:	6853      	ldr	r3, [r2, #4]
 8004ecc:	f043 0301 	orr.w	r3, r3, #1
 8004ed0:	6053      	str	r3, [r2, #4]
 8004ed2:	f000 f9a5 	bl	8005220 <__malloc_unlock>
 8004ed6:	e719      	b.n	8004d0c <_malloc_r+0x6c>
 8004ed8:	f8d7 8008 	ldr.w	r8, [r7, #8]
 8004edc:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8004ee0:	f023 0903 	bic.w	r9, r3, #3
 8004ee4:	454c      	cmp	r4, r9
 8004ee6:	ebc4 0209 	rsb	r2, r4, r9
 8004eea:	bf94      	ite	ls
 8004eec:	2300      	movls	r3, #0
 8004eee:	2301      	movhi	r3, #1
 8004ef0:	2a0f      	cmp	r2, #15
 8004ef2:	bfd8      	it	le
 8004ef4:	f043 0301 	orrle.w	r3, r3, #1
 8004ef8:	2b00      	cmp	r3, #0
 8004efa:	f000 80b9 	beq.w	8005070 <_malloc_r+0x3d0>
 8004efe:	f640 2af4 	movw	sl, #2804	; 0xaf4
 8004f02:	f8d5 3408 	ldr.w	r3, [r5, #1032]	; 0x408
 8004f06:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 8004f0a:	4630      	mov	r0, r6
 8004f0c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004f10:	f8da 2000 	ldr.w	r2, [sl]
 8004f14:	f102 0b10 	add.w	fp, r2, #16
 8004f18:	44a3      	add	fp, r4
 8004f1a:	bf1f      	itttt	ne
 8004f1c:	f50b 6b7e 	addne.w	fp, fp, #4064	; 0xfe0
 8004f20:	f10b 0b1f 	addne.w	fp, fp, #31
 8004f24:	f42b 6b7e 	bicne.w	fp, fp, #4064	; 0xfe0
 8004f28:	f02b 0b1f 	bicne.w	fp, fp, #31
 8004f2c:	4659      	mov	r1, fp
 8004f2e:	f7fb fd7d 	bl	8000a2c <_sbrk_r>
 8004f32:	f1b0 3fff 	cmp.w	r0, #4294967295
 8004f36:	4603      	mov	r3, r0
 8004f38:	f000 8118 	beq.w	800516c <_malloc_r+0x4cc>
 8004f3c:	eb08 0109 	add.w	r1, r8, r9
 8004f40:	4281      	cmp	r1, r0
 8004f42:	f200 8110 	bhi.w	8005166 <_malloc_r+0x4c6>
 8004f46:	f8da 2004 	ldr.w	r2, [sl, #4]
 8004f4a:	4281      	cmp	r1, r0
 8004f4c:	445a      	add	r2, fp
 8004f4e:	f8ca 2004 	str.w	r2, [sl, #4]
 8004f52:	f000 813e 	beq.w	80051d2 <_malloc_r+0x532>
 8004f56:	f8d5 e408 	ldr.w	lr, [r5, #1032]	; 0x408
 8004f5a:	f240 3560 	movw	r5, #864	; 0x360
 8004f5e:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8004f62:	f1be 3fff 	cmp.w	lr, #4294967295
 8004f66:	bf17      	itett	ne
 8004f68:	1882      	addne	r2, r0, r2
 8004f6a:	f8c5 0408 	streq.w	r0, [r5, #1032]	; 0x408
 8004f6e:	ebc1 0102 	rsbne	r1, r1, r2
 8004f72:	f8ca 1004 	strne.w	r1, [sl, #4]
 8004f76:	f010 0507 	ands.w	r5, r0, #7
 8004f7a:	bf17      	itett	ne
 8004f7c:	f1c5 0508 	rsbne	r5, r5, #8
 8004f80:	f44f 5580 	moveq.w	r5, #4096	; 0x1000
 8004f84:	1943      	addne	r3, r0, r5
 8004f86:	f505 5580 	addne.w	r5, r5, #4096	; 0x1000
 8004f8a:	eb03 020b 	add.w	r2, r3, fp
 8004f8e:	4630      	mov	r0, r6
 8004f90:	9301      	str	r3, [sp, #4]
 8004f92:	0512      	lsls	r2, r2, #20
 8004f94:	0d12      	lsrs	r2, r2, #20
 8004f96:	1aad      	subs	r5, r5, r2
 8004f98:	4629      	mov	r1, r5
 8004f9a:	f7fb fd47 	bl	8000a2c <_sbrk_r>
 8004f9e:	9b01      	ldr	r3, [sp, #4]
 8004fa0:	f1b0 3fff 	cmp.w	r0, #4294967295
 8004fa4:	f000 812c 	beq.w	8005200 <_malloc_r+0x560>
 8004fa8:	1ac1      	subs	r1, r0, r3
 8004faa:	1949      	adds	r1, r1, r5
 8004fac:	f041 0101 	orr.w	r1, r1, #1
 8004fb0:	f8da 2004 	ldr.w	r2, [sl, #4]
 8004fb4:	45b8      	cmp	r8, r7
 8004fb6:	f640 2bf4 	movw	fp, #2804	; 0xaf4
 8004fba:	60bb      	str	r3, [r7, #8]
 8004fbc:	442a      	add	r2, r5
 8004fbe:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 8004fc2:	6059      	str	r1, [r3, #4]
 8004fc4:	f8ca 2004 	str.w	r2, [sl, #4]
 8004fc8:	d017      	beq.n	8004ffa <_malloc_r+0x35a>
 8004fca:	f1b9 0f0f 	cmp.w	r9, #15
 8004fce:	f240 80e1 	bls.w	8005194 <_malloc_r+0x4f4>
 8004fd2:	f1a9 030c 	sub.w	r3, r9, #12
 8004fd6:	f8d8 5004 	ldr.w	r5, [r8, #4]
 8004fda:	f023 0307 	bic.w	r3, r3, #7
 8004fde:	2005      	movs	r0, #5
 8004fe0:	eb08 0103 	add.w	r1, r8, r3
 8004fe4:	2b0f      	cmp	r3, #15
 8004fe6:	f005 0501 	and.w	r5, r5, #1
 8004fea:	ea43 0505 	orr.w	r5, r3, r5
 8004fee:	f8c8 5004 	str.w	r5, [r8, #4]
 8004ff2:	6048      	str	r0, [r1, #4]
 8004ff4:	6088      	str	r0, [r1, #8]
 8004ff6:	f200 80fb 	bhi.w	80051f0 <_malloc_r+0x550>
 8004ffa:	f8da 102c 	ldr.w	r1, [sl, #44]	; 0x2c
 8004ffe:	f640 23f4 	movw	r3, #2804	; 0xaf4
 8005002:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005006:	428a      	cmp	r2, r1
 8005008:	f8da 1030 	ldr.w	r1, [sl, #48]	; 0x30
 800500c:	bf88      	it	hi
 800500e:	62da      	strhi	r2, [r3, #44]	; 0x2c
 8005010:	f640 23f4 	movw	r3, #2804	; 0xaf4
 8005014:	428a      	cmp	r2, r1
 8005016:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800501a:	f240 80a7 	bls.w	800516c <_malloc_r+0x4cc>
 800501e:	f8d7 8008 	ldr.w	r8, [r7, #8]
 8005022:	631a      	str	r2, [r3, #48]	; 0x30
 8005024:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8005028:	f023 0303 	bic.w	r3, r3, #3
 800502c:	429c      	cmp	r4, r3
 800502e:	ebc4 0203 	rsb	r2, r4, r3
 8005032:	bf94      	ite	ls
 8005034:	2300      	movls	r3, #0
 8005036:	2301      	movhi	r3, #1
 8005038:	2a0f      	cmp	r2, #15
 800503a:	bfd8      	it	le
 800503c:	f043 0301 	orrle.w	r3, r3, #1
 8005040:	b1b3      	cbz	r3, 8005070 <_malloc_r+0x3d0>
 8005042:	4630      	mov	r0, r6
 8005044:	f04f 0800 	mov.w	r8, #0
 8005048:	f000 f8ea 	bl	8005220 <__malloc_unlock>
 800504c:	e65e      	b.n	8004d0c <_malloc_r+0x6c>
 800504e:	189a      	adds	r2, r3, r2
 8005050:	68d9      	ldr	r1, [r3, #12]
 8005052:	689c      	ldr	r4, [r3, #8]
 8005054:	f103 0808 	add.w	r8, r3, #8
 8005058:	6855      	ldr	r5, [r2, #4]
 800505a:	4630      	mov	r0, r6
 800505c:	f045 0301 	orr.w	r3, r5, #1
 8005060:	60e1      	str	r1, [r4, #12]
 8005062:	608c      	str	r4, [r1, #8]
 8005064:	6053      	str	r3, [r2, #4]
 8005066:	f000 f8db 	bl	8005220 <__malloc_unlock>
 800506a:	e64f      	b.n	8004d0c <_malloc_r+0x6c>
 800506c:	20000368 	.word	0x20000368
 8005070:	eb08 0304 	add.w	r3, r8, r4
 8005074:	f042 0201 	orr.w	r2, r2, #1
 8005078:	f044 0401 	orr.w	r4, r4, #1
 800507c:	4630      	mov	r0, r6
 800507e:	f8c8 4004 	str.w	r4, [r8, #4]
 8005082:	f108 0808 	add.w	r8, r8, #8
 8005086:	605a      	str	r2, [r3, #4]
 8005088:	60bb      	str	r3, [r7, #8]
 800508a:	f000 f8c9 	bl	8005220 <__malloc_unlock>
 800508e:	e63d      	b.n	8004d0c <_malloc_r+0x6c>
 8005090:	0a41      	lsrs	r1, r0, #9
 8005092:	2904      	cmp	r1, #4
 8005094:	bf9c      	itt	ls
 8005096:	ea4f 1e90 	movls.w	lr, r0, lsr #6
 800509a:	f10e 0e38 	addls.w	lr, lr, #56	; 0x38
 800509e:	d91d      	bls.n	80050dc <_malloc_r+0x43c>
 80050a0:	2914      	cmp	r1, #20
 80050a2:	bf98      	it	ls
 80050a4:	f101 0e5b 	addls.w	lr, r1, #91	; 0x5b
 80050a8:	d918      	bls.n	80050dc <_malloc_r+0x43c>
 80050aa:	2954      	cmp	r1, #84	; 0x54
 80050ac:	bf9c      	itt	ls
 80050ae:	ea4f 3e10 	movls.w	lr, r0, lsr #12
 80050b2:	f10e 0e6e 	addls.w	lr, lr, #110	; 0x6e
 80050b6:	d911      	bls.n	80050dc <_malloc_r+0x43c>
 80050b8:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
 80050bc:	bf9c      	itt	ls
 80050be:	ea4f 3ed0 	movls.w	lr, r0, lsr #15
 80050c2:	f10e 0e77 	addls.w	lr, lr, #119	; 0x77
 80050c6:	d909      	bls.n	80050dc <_malloc_r+0x43c>
 80050c8:	f240 5e54 	movw	lr, #1364	; 0x554
 80050cc:	4571      	cmp	r1, lr
 80050ce:	bf96      	itet	ls
 80050d0:	ea4f 4e90 	movls.w	lr, r0, lsr #18
 80050d4:	f04f 0e7e 	movhi.w	lr, #126	; 0x7e
 80050d8:	f10e 0e7c 	addls.w	lr, lr, #124	; 0x7c
 80050dc:	eb07 08ce 	add.w	r8, r7, lr, lsl #3
 80050e0:	f8d8 1008 	ldr.w	r1, [r8, #8]
 80050e4:	4541      	cmp	r1, r8
 80050e6:	d103      	bne.n	80050f0 <_malloc_r+0x450>
 80050e8:	e047      	b.n	800517a <_malloc_r+0x4da>
 80050ea:	6889      	ldr	r1, [r1, #8]
 80050ec:	4588      	cmp	r8, r1
 80050ee:	d005      	beq.n	80050fc <_malloc_r+0x45c>
 80050f0:	f8d1 e004 	ldr.w	lr, [r1, #4]
 80050f4:	f02e 0e03 	bic.w	lr, lr, #3
 80050f8:	4570      	cmp	r0, lr
 80050fa:	d3f6      	bcc.n	80050ea <_malloc_r+0x44a>
 80050fc:	f8d1 e00c 	ldr.w	lr, [r1, #12]
 8005100:	f8c3 e00c 	str.w	lr, [r3, #12]
 8005104:	6099      	str	r1, [r3, #8]
 8005106:	6878      	ldr	r0, [r7, #4]
 8005108:	60cb      	str	r3, [r1, #12]
 800510a:	f8ce 3008 	str.w	r3, [lr, #8]
 800510e:	e65d      	b.n	8004dcc <_malloc_r+0x12c>
 8005110:	191d      	adds	r5, r3, r4
 8005112:	f041 0701 	orr.w	r7, r1, #1
 8005116:	60d5      	str	r5, [r2, #12]
 8005118:	f044 0401 	orr.w	r4, r4, #1
 800511c:	6095      	str	r5, [r2, #8]
 800511e:	4630      	mov	r0, r6
 8005120:	605c      	str	r4, [r3, #4]
 8005122:	f103 0808 	add.w	r8, r3, #8
 8005126:	60ea      	str	r2, [r5, #12]
 8005128:	60aa      	str	r2, [r5, #8]
 800512a:	606f      	str	r7, [r5, #4]
 800512c:	5069      	str	r1, [r5, r1]
 800512e:	f000 f877 	bl	8005220 <__malloc_unlock>
 8005132:	e5eb      	b.n	8004d0c <_malloc_r+0x6c>
 8005134:	f109 0901 	add.w	r9, r9, #1
 8005138:	f019 0f03 	tst.w	r9, #3
 800513c:	d02f      	beq.n	800519e <_malloc_r+0x4fe>
 800513e:	f108 0808 	add.w	r8, r8, #8
 8005142:	e65b      	b.n	8004dfc <_malloc_r+0x15c>
 8005144:	f103 0208 	add.w	r2, r3, #8
 8005148:	695b      	ldr	r3, [r3, #20]
 800514a:	429a      	cmp	r2, r3
 800514c:	bf08      	it	eq
 800514e:	f10c 0c02 	addeq.w	ip, ip, #2
 8005152:	f43f ae10 	beq.w	8004d76 <_malloc_r+0xd6>
 8005156:	e5c8      	b.n	8004cea <_malloc_r+0x4a>
 8005158:	4680      	mov	r8, r0
 800515a:	1843      	adds	r3, r0, r1
 800515c:	68c2      	ldr	r2, [r0, #12]
 800515e:	4630      	mov	r0, r6
 8005160:	f858 1f08 	ldr.w	r1, [r8, #8]!
 8005164:	e5ca      	b.n	8004cfc <_malloc_r+0x5c>
 8005166:	45b8      	cmp	r8, r7
 8005168:	f43f aeed 	beq.w	8004f46 <_malloc_r+0x2a6>
 800516c:	f8d7 8008 	ldr.w	r8, [r7, #8]
 8005170:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8005174:	f023 0303 	bic.w	r3, r3, #3
 8005178:	e758      	b.n	800502c <_malloc_r+0x38c>
 800517a:	f04f 0901 	mov.w	r9, #1
 800517e:	f8d7 8004 	ldr.w	r8, [r7, #4]
 8005182:	ea4f 00ae 	mov.w	r0, lr, asr #2
 8005186:	468e      	mov	lr, r1
 8005188:	fa09 f000 	lsl.w	r0, r9, r0
 800518c:	ea48 0000 	orr.w	r0, r8, r0
 8005190:	6078      	str	r0, [r7, #4]
 8005192:	e7b5      	b.n	8005100 <_malloc_r+0x460>
 8005194:	4698      	mov	r8, r3
 8005196:	2201      	movs	r2, #1
 8005198:	605a      	str	r2, [r3, #4]
 800519a:	2300      	movs	r3, #0
 800519c:	e746      	b.n	800502c <_malloc_r+0x38c>
 800519e:	4651      	mov	r1, sl
 80051a0:	f01c 0f03 	tst.w	ip, #3
 80051a4:	460b      	mov	r3, r1
 80051a6:	f10c 3cff 	add.w	ip, ip, #4294967295
 80051aa:	d02c      	beq.n	8005206 <_malloc_r+0x566>
 80051ac:	f853 1908 	ldr.w	r1, [r3], #-8
 80051b0:	4299      	cmp	r1, r3
 80051b2:	d0f5      	beq.n	80051a0 <_malloc_r+0x500>
 80051b4:	687b      	ldr	r3, [r7, #4]
 80051b6:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 80051ba:	459e      	cmp	lr, r3
 80051bc:	f63f ae8c 	bhi.w	8004ed8 <_malloc_r+0x238>
 80051c0:	f1be 0f00 	cmp.w	lr, #0
 80051c4:	f43f ae88 	beq.w	8004ed8 <_malloc_r+0x238>
 80051c8:	ea1e 0f03 	tst.w	lr, r3
 80051cc:	d020      	beq.n	8005210 <_malloc_r+0x570>
 80051ce:	46cc      	mov	ip, r9
 80051d0:	e610      	b.n	8004df4 <_malloc_r+0x154>
 80051d2:	ea4f 5e01 	mov.w	lr, r1, lsl #20
 80051d6:	ea4f 5e1e 	mov.w	lr, lr, lsr #20
 80051da:	f1be 0f00 	cmp.w	lr, #0
 80051de:	f47f aeba 	bne.w	8004f56 <_malloc_r+0x2b6>
 80051e2:	68bb      	ldr	r3, [r7, #8]
 80051e4:	eb0b 0109 	add.w	r1, fp, r9
 80051e8:	f041 0101 	orr.w	r1, r1, #1
 80051ec:	6059      	str	r1, [r3, #4]
 80051ee:	e704      	b.n	8004ffa <_malloc_r+0x35a>
 80051f0:	4630      	mov	r0, r6
 80051f2:	f108 0108 	add.w	r1, r8, #8
 80051f6:	f000 fc35 	bl	8005a64 <_free_r>
 80051fa:	f8db 2004 	ldr.w	r2, [fp, #4]
 80051fe:	e6fc      	b.n	8004ffa <_malloc_r+0x35a>
 8005200:	2101      	movs	r1, #1
 8005202:	2500      	movs	r5, #0
 8005204:	e6d4      	b.n	8004fb0 <_malloc_r+0x310>
 8005206:	687b      	ldr	r3, [r7, #4]
 8005208:	ea23 030e 	bic.w	r3, r3, lr
 800520c:	607b      	str	r3, [r7, #4]
 800520e:	e7d1      	b.n	80051b4 <_malloc_r+0x514>
 8005210:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 8005214:	f109 0904 	add.w	r9, r9, #4
 8005218:	e7d6      	b.n	80051c8 <_malloc_r+0x528>
 800521a:	bf00      	nop

0800521c <__malloc_lock>:
 800521c:	4770      	bx	lr
 800521e:	bf00      	nop

08005220 <__malloc_unlock>:
 8005220:	4770      	bx	lr
 8005222:	bf00      	nop

08005224 <setbuf>:
 8005224:	2900      	cmp	r1, #0
 8005226:	bf0c      	ite	eq
 8005228:	2202      	moveq	r2, #2
 800522a:	2200      	movne	r2, #0
 800522c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8005230:	f000 b800 	b.w	8005234 <setvbuf>

08005234 <setvbuf>:
 8005234:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8005238:	f240 256c 	movw	r5, #620	; 0x26c
 800523c:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8005240:	4604      	mov	r4, r0
 8005242:	460e      	mov	r6, r1
 8005244:	4617      	mov	r7, r2
 8005246:	6828      	ldr	r0, [r5, #0]
 8005248:	4698      	mov	r8, r3
 800524a:	b110      	cbz	r0, 8005252 <setvbuf+0x1e>
 800524c:	6983      	ldr	r3, [r0, #24]
 800524e:	2b00      	cmp	r3, #0
 8005250:	d05a      	beq.n	8005308 <setvbuf+0xd4>
 8005252:	f24b 7374 	movw	r3, #46964	; 0xb774
 8005256:	f6c0 0300 	movt	r3, #2048	; 0x800
 800525a:	429c      	cmp	r4, r3
 800525c:	d05c      	beq.n	8005318 <setvbuf+0xe4>
 800525e:	f24b 7394 	movw	r3, #46996	; 0xb794
 8005262:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005266:	429c      	cmp	r4, r3
 8005268:	d059      	beq.n	800531e <setvbuf+0xea>
 800526a:	f24b 73b4 	movw	r3, #47028	; 0xb7b4
 800526e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005272:	429c      	cmp	r4, r3
 8005274:	bf04      	itt	eq
 8005276:	682b      	ldreq	r3, [r5, #0]
 8005278:	68dc      	ldreq	r4, [r3, #12]
 800527a:	2f02      	cmp	r7, #2
 800527c:	bf94      	ite	ls
 800527e:	f04f 0900 	movls.w	r9, #0
 8005282:	f04f 0901 	movhi.w	r9, #1
 8005286:	ea59 79d8 	orrs.w	r9, r9, r8, lsr #31
 800528a:	bf18      	it	ne
 800528c:	f04f 30ff 	movne.w	r0, #4294967295
 8005290:	d001      	beq.n	8005296 <setvbuf+0x62>
 8005292:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005296:	6828      	ldr	r0, [r5, #0]
 8005298:	4621      	mov	r1, r4
 800529a:	f000 f989 	bl	80055b0 <_fflush_r>
 800529e:	89a2      	ldrh	r2, [r4, #12]
 80052a0:	f240 236c 	movw	r3, #620	; 0x26c
 80052a4:	f8c4 9004 	str.w	r9, [r4, #4]
 80052a8:	f012 0f80 	tst.w	r2, #128	; 0x80
 80052ac:	f8c4 9018 	str.w	r9, [r4, #24]
 80052b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80052b4:	d136      	bne.n	8005324 <setvbuf+0xf0>
 80052b6:	2f02      	cmp	r7, #2
 80052b8:	f64f 737c 	movw	r3, #65404	; 0xff7c
 80052bc:	ea02 0303 	and.w	r3, r2, r3
 80052c0:	81a3      	strh	r3, [r4, #12]
 80052c2:	d035      	beq.n	8005330 <setvbuf+0xfc>
 80052c4:	2e00      	cmp	r6, #0
 80052c6:	d041      	beq.n	800534c <setvbuf+0x118>
 80052c8:	2f01      	cmp	r7, #1
 80052ca:	6829      	ldr	r1, [r5, #0]
 80052cc:	bf01      	itttt	eq
 80052ce:	f043 0301 	orreq.w	r3, r3, #1
 80052d2:	81a3      	strheq	r3, [r4, #12]
 80052d4:	f1c8 0200 	rsbeq	r2, r8, #0
 80052d8:	61a2      	streq	r2, [r4, #24]
 80052da:	b29b      	uxth	r3, r3
 80052dc:	f245 72a5 	movw	r2, #22437	; 0x57a5
 80052e0:	f013 0008 	ands.w	r0, r3, #8
 80052e4:	f6c0 0200 	movt	r2, #2048	; 0x800
 80052e8:	628a      	str	r2, [r1, #40]	; 0x28
 80052ea:	6026      	str	r6, [r4, #0]
 80052ec:	6126      	str	r6, [r4, #16]
 80052ee:	f8c4 8014 	str.w	r8, [r4, #20]
 80052f2:	d0ce      	beq.n	8005292 <setvbuf+0x5e>
 80052f4:	f013 0f03 	tst.w	r3, #3
 80052f8:	f04f 0000 	mov.w	r0, #0
 80052fc:	bf0c      	ite	eq
 80052fe:	4643      	moveq	r3, r8
 8005300:	4603      	movne	r3, r0
 8005302:	60a3      	str	r3, [r4, #8]
 8005304:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005308:	f000 fa70 	bl	80057ec <__sinit>
 800530c:	f24b 7374 	movw	r3, #46964	; 0xb774
 8005310:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005314:	429c      	cmp	r4, r3
 8005316:	d1a2      	bne.n	800525e <setvbuf+0x2a>
 8005318:	682b      	ldr	r3, [r5, #0]
 800531a:	685c      	ldr	r4, [r3, #4]
 800531c:	e7ad      	b.n	800527a <setvbuf+0x46>
 800531e:	682b      	ldr	r3, [r5, #0]
 8005320:	689c      	ldr	r4, [r3, #8]
 8005322:	e7aa      	b.n	800527a <setvbuf+0x46>
 8005324:	6818      	ldr	r0, [r3, #0]
 8005326:	6921      	ldr	r1, [r4, #16]
 8005328:	f000 fb9c 	bl	8005a64 <_free_r>
 800532c:	89a2      	ldrh	r2, [r4, #12]
 800532e:	e7c2      	b.n	80052b6 <setvbuf+0x82>
 8005330:	2000      	movs	r0, #0
 8005332:	f104 0247 	add.w	r2, r4, #71	; 0x47
 8005336:	f043 0302 	orr.w	r3, r3, #2
 800533a:	6022      	str	r2, [r4, #0]
 800533c:	81a3      	strh	r3, [r4, #12]
 800533e:	2300      	movs	r3, #0
 8005340:	6122      	str	r2, [r4, #16]
 8005342:	60a3      	str	r3, [r4, #8]
 8005344:	2301      	movs	r3, #1
 8005346:	6163      	str	r3, [r4, #20]
 8005348:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800534c:	f1b8 0f00 	cmp.w	r8, #0
 8005350:	bf08      	it	eq
 8005352:	f44f 6880 	moveq.w	r8, #1024	; 0x400
 8005356:	4640      	mov	r0, r8
 8005358:	f7ff fc92 	bl	8004c80 <malloc>
 800535c:	4606      	mov	r6, r0
 800535e:	b128      	cbz	r0, 800536c <setvbuf+0x138>
 8005360:	89a3      	ldrh	r3, [r4, #12]
 8005362:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8005366:	b29b      	uxth	r3, r3
 8005368:	81a3      	strh	r3, [r4, #12]
 800536a:	e7ad      	b.n	80052c8 <setvbuf+0x94>
 800536c:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8005370:	f7ff fc86 	bl	8004c80 <malloc>
 8005374:	4606      	mov	r6, r0
 8005376:	b918      	cbnz	r0, 8005380 <setvbuf+0x14c>
 8005378:	89a3      	ldrh	r3, [r4, #12]
 800537a:	f04f 30ff 	mov.w	r0, #4294967295
 800537e:	e7d8      	b.n	8005332 <setvbuf+0xfe>
 8005380:	f44f 6880 	mov.w	r8, #1024	; 0x400
 8005384:	e7ec      	b.n	8005360 <setvbuf+0x12c>
 8005386:	bf00      	nop

08005388 <strcmp>:
 8005388:	ea80 0201 	eor.w	r2, r0, r1
 800538c:	f012 0f03 	tst.w	r2, #3
 8005390:	d13a      	bne.n	8005408 <strcmp_unaligned>
 8005392:	f010 0203 	ands.w	r2, r0, #3
 8005396:	f020 0003 	bic.w	r0, r0, #3
 800539a:	f021 0103 	bic.w	r1, r1, #3
 800539e:	f850 cb04 	ldr.w	ip, [r0], #4
 80053a2:	bf08      	it	eq
 80053a4:	f851 3b04 	ldreq.w	r3, [r1], #4
 80053a8:	d00d      	beq.n	80053c6 <strcmp+0x3e>
 80053aa:	f082 0203 	eor.w	r2, r2, #3
 80053ae:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80053b2:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 80053b6:	fa23 f202 	lsr.w	r2, r3, r2
 80053ba:	f851 3b04 	ldr.w	r3, [r1], #4
 80053be:	ea4c 0c02 	orr.w	ip, ip, r2
 80053c2:	ea43 0302 	orr.w	r3, r3, r2
 80053c6:	bf00      	nop
 80053c8:	f1ac 3201 	sub.w	r2, ip, #16843009	; 0x1010101
 80053cc:	459c      	cmp	ip, r3
 80053ce:	bf01      	itttt	eq
 80053d0:	ea22 020c 	biceq.w	r2, r2, ip
 80053d4:	f012 3f80 	tsteq.w	r2, #2155905152	; 0x80808080
 80053d8:	f850 cb04 	ldreq.w	ip, [r0], #4
 80053dc:	f851 3b04 	ldreq.w	r3, [r1], #4
 80053e0:	d0f2      	beq.n	80053c8 <strcmp+0x40>
 80053e2:	ea4f 600c 	mov.w	r0, ip, lsl #24
 80053e6:	ea4f 2c1c 	mov.w	ip, ip, lsr #8
 80053ea:	2801      	cmp	r0, #1
 80053ec:	bf28      	it	cs
 80053ee:	ebb0 6f03 	cmpcs.w	r0, r3, lsl #24
 80053f2:	bf08      	it	eq
 80053f4:	0a1b      	lsreq	r3, r3, #8
 80053f6:	d0f4      	beq.n	80053e2 <strcmp+0x5a>
 80053f8:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 80053fc:	ea4f 6010 	mov.w	r0, r0, lsr #24
 8005400:	eba0 0003 	sub.w	r0, r0, r3
 8005404:	4770      	bx	lr
 8005406:	bf00      	nop

08005408 <strcmp_unaligned>:
 8005408:	f010 0f03 	tst.w	r0, #3
 800540c:	d00a      	beq.n	8005424 <strcmp_unaligned+0x1c>
 800540e:	f810 2b01 	ldrb.w	r2, [r0], #1
 8005412:	f811 3b01 	ldrb.w	r3, [r1], #1
 8005416:	2a01      	cmp	r2, #1
 8005418:	bf28      	it	cs
 800541a:	429a      	cmpcs	r2, r3
 800541c:	d0f4      	beq.n	8005408 <strcmp_unaligned>
 800541e:	eba2 0003 	sub.w	r0, r2, r3
 8005422:	4770      	bx	lr
 8005424:	f84d 5d04 	str.w	r5, [sp, #-4]!
 8005428:	f84d 4d04 	str.w	r4, [sp, #-4]!
 800542c:	f04f 0201 	mov.w	r2, #1
 8005430:	ea42 2202 	orr.w	r2, r2, r2, lsl #8
 8005434:	ea42 4202 	orr.w	r2, r2, r2, lsl #16
 8005438:	f001 0c03 	and.w	ip, r1, #3
 800543c:	f021 0103 	bic.w	r1, r1, #3
 8005440:	f850 4b04 	ldr.w	r4, [r0], #4
 8005444:	f851 5b04 	ldr.w	r5, [r1], #4
 8005448:	f1bc 0f02 	cmp.w	ip, #2
 800544c:	d026      	beq.n	800549c <strcmp_unaligned+0x94>
 800544e:	d84b      	bhi.n	80054e8 <strcmp_unaligned+0xe0>
 8005450:	f024 4c7f 	bic.w	ip, r4, #4278190080	; 0xff000000
 8005454:	ebbc 2f15 	cmp.w	ip, r5, lsr #8
 8005458:	eba4 0302 	sub.w	r3, r4, r2
 800545c:	ea23 0304 	bic.w	r3, r3, r4
 8005460:	d10d      	bne.n	800547e <strcmp_unaligned+0x76>
 8005462:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 8005466:	bf08      	it	eq
 8005468:	f851 5b04 	ldreq.w	r5, [r1], #4
 800546c:	d10a      	bne.n	8005484 <strcmp_unaligned+0x7c>
 800546e:	ea8c 0c04 	eor.w	ip, ip, r4
 8005472:	ebbc 6f05 	cmp.w	ip, r5, lsl #24
 8005476:	d10c      	bne.n	8005492 <strcmp_unaligned+0x8a>
 8005478:	f850 4b04 	ldr.w	r4, [r0], #4
 800547c:	e7e8      	b.n	8005450 <strcmp_unaligned+0x48>
 800547e:	ea4f 2515 	mov.w	r5, r5, lsr #8
 8005482:	e05c      	b.n	800553e <strcmp_unaligned+0x136>
 8005484:	f033 437f 	bics.w	r3, r3, #4278190080	; 0xff000000
 8005488:	d152      	bne.n	8005530 <strcmp_unaligned+0x128>
 800548a:	780d      	ldrb	r5, [r1, #0]
 800548c:	ea4f 6c14 	mov.w	ip, r4, lsr #24
 8005490:	e055      	b.n	800553e <strcmp_unaligned+0x136>
 8005492:	ea4f 6c14 	mov.w	ip, r4, lsr #24
 8005496:	f005 05ff 	and.w	r5, r5, #255	; 0xff
 800549a:	e050      	b.n	800553e <strcmp_unaligned+0x136>
 800549c:	ea4f 4c04 	mov.w	ip, r4, lsl #16
 80054a0:	eba4 0302 	sub.w	r3, r4, r2
 80054a4:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 80054a8:	ea23 0304 	bic.w	r3, r3, r4
 80054ac:	ebbc 4f15 	cmp.w	ip, r5, lsr #16
 80054b0:	d117      	bne.n	80054e2 <strcmp_unaligned+0xda>
 80054b2:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 80054b6:	bf08      	it	eq
 80054b8:	f851 5b04 	ldreq.w	r5, [r1], #4
 80054bc:	d107      	bne.n	80054ce <strcmp_unaligned+0xc6>
 80054be:	ea8c 0c04 	eor.w	ip, ip, r4
 80054c2:	ebbc 4f05 	cmp.w	ip, r5, lsl #16
 80054c6:	d108      	bne.n	80054da <strcmp_unaligned+0xd2>
 80054c8:	f850 4b04 	ldr.w	r4, [r0], #4
 80054cc:	e7e6      	b.n	800549c <strcmp_unaligned+0x94>
 80054ce:	041b      	lsls	r3, r3, #16
 80054d0:	d12e      	bne.n	8005530 <strcmp_unaligned+0x128>
 80054d2:	880d      	ldrh	r5, [r1, #0]
 80054d4:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 80054d8:	e031      	b.n	800553e <strcmp_unaligned+0x136>
 80054da:	ea4f 4505 	mov.w	r5, r5, lsl #16
 80054de:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 80054e2:	ea4f 4515 	mov.w	r5, r5, lsr #16
 80054e6:	e02a      	b.n	800553e <strcmp_unaligned+0x136>
 80054e8:	f004 0cff 	and.w	ip, r4, #255	; 0xff
 80054ec:	ebbc 6f15 	cmp.w	ip, r5, lsr #24
 80054f0:	eba4 0302 	sub.w	r3, r4, r2
 80054f4:	ea23 0304 	bic.w	r3, r3, r4
 80054f8:	d10d      	bne.n	8005516 <strcmp_unaligned+0x10e>
 80054fa:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 80054fe:	bf08      	it	eq
 8005500:	f851 5b04 	ldreq.w	r5, [r1], #4
 8005504:	d10a      	bne.n	800551c <strcmp_unaligned+0x114>
 8005506:	ea8c 0c04 	eor.w	ip, ip, r4
 800550a:	ebbc 2f05 	cmp.w	ip, r5, lsl #8
 800550e:	d10a      	bne.n	8005526 <strcmp_unaligned+0x11e>
 8005510:	f850 4b04 	ldr.w	r4, [r0], #4
 8005514:	e7e8      	b.n	80054e8 <strcmp_unaligned+0xe0>
 8005516:	ea4f 6515 	mov.w	r5, r5, lsr #24
 800551a:	e010      	b.n	800553e <strcmp_unaligned+0x136>
 800551c:	f014 0fff 	tst.w	r4, #255	; 0xff
 8005520:	d006      	beq.n	8005530 <strcmp_unaligned+0x128>
 8005522:	f851 5b04 	ldr.w	r5, [r1], #4
 8005526:	ea4f 2c14 	mov.w	ip, r4, lsr #8
 800552a:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
 800552e:	e006      	b.n	800553e <strcmp_unaligned+0x136>
 8005530:	f04f 0000 	mov.w	r0, #0
 8005534:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005538:	f85d 5b04 	ldr.w	r5, [sp], #4
 800553c:	4770      	bx	lr
 800553e:	f00c 02ff 	and.w	r2, ip, #255	; 0xff
 8005542:	f005 00ff 	and.w	r0, r5, #255	; 0xff
 8005546:	2801      	cmp	r0, #1
 8005548:	bf28      	it	cs
 800554a:	4290      	cmpcs	r0, r2
 800554c:	bf04      	itt	eq
 800554e:	ea4f 2c1c 	moveq.w	ip, ip, lsr #8
 8005552:	0a2d      	lsreq	r5, r5, #8
 8005554:	d0f3      	beq.n	800553e <strcmp_unaligned+0x136>
 8005556:	eba2 0000 	sub.w	r0, r2, r0
 800555a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800555e:	f85d 5b04 	ldr.w	r5, [sp], #4
 8005562:	4770      	bx	lr

08005564 <_vsprintf_r>:
 8005564:	b570      	push	{r4, r5, r6, lr}
 8005566:	b09a      	sub	sp, #104	; 0x68
 8005568:	460d      	mov	r5, r1
 800556a:	4669      	mov	r1, sp
 800556c:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
 8005570:	f44f 7602 	mov.w	r6, #520	; 0x208
 8005574:	9500      	str	r5, [sp, #0]
 8005576:	f8ad 600c 	strh.w	r6, [sp, #12]
 800557a:	f04f 36ff 	mov.w	r6, #4294967295
 800557e:	9504      	str	r5, [sp, #16]
 8005580:	f8ad 600e 	strh.w	r6, [sp, #14]
 8005584:	9402      	str	r4, [sp, #8]
 8005586:	9405      	str	r4, [sp, #20]
 8005588:	f000 fc32 	bl	8005df0 <_svfprintf_r>
 800558c:	9b00      	ldr	r3, [sp, #0]
 800558e:	2200      	movs	r2, #0
 8005590:	701a      	strb	r2, [r3, #0]
 8005592:	b01a      	add	sp, #104	; 0x68
 8005594:	bd70      	pop	{r4, r5, r6, pc}
 8005596:	bf00      	nop

08005598 <vsprintf>:
 8005598:	b430      	push	{r4, r5}
 800559a:	f240 246c 	movw	r4, #620	; 0x26c
 800559e:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80055a2:	460d      	mov	r5, r1
 80055a4:	4613      	mov	r3, r2
 80055a6:	4601      	mov	r1, r0
 80055a8:	462a      	mov	r2, r5
 80055aa:	6820      	ldr	r0, [r4, #0]
 80055ac:	bc30      	pop	{r4, r5}
 80055ae:	e7d9      	b.n	8005564 <_vsprintf_r>

080055b0 <_fflush_r>:
 80055b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80055b4:	460c      	mov	r4, r1
 80055b6:	690e      	ldr	r6, [r1, #16]
 80055b8:	4680      	mov	r8, r0
 80055ba:	2e00      	cmp	r6, #0
 80055bc:	d04a      	beq.n	8005654 <_fflush_r+0xa4>
 80055be:	b118      	cbz	r0, 80055c8 <_fflush_r+0x18>
 80055c0:	6983      	ldr	r3, [r0, #24]
 80055c2:	2b00      	cmp	r3, #0
 80055c4:	f000 808e 	beq.w	80056e4 <_fflush_r+0x134>
 80055c8:	f24b 7374 	movw	r3, #46964	; 0xb774
 80055cc:	f6c0 0300 	movt	r3, #2048	; 0x800
 80055d0:	429c      	cmp	r4, r3
 80055d2:	bf08      	it	eq
 80055d4:	f8d8 4004 	ldreq.w	r4, [r8, #4]
 80055d8:	d010      	beq.n	80055fc <_fflush_r+0x4c>
 80055da:	f24b 7394 	movw	r3, #46996	; 0xb794
 80055de:	f6c0 0300 	movt	r3, #2048	; 0x800
 80055e2:	429c      	cmp	r4, r3
 80055e4:	bf08      	it	eq
 80055e6:	f8d8 4008 	ldreq.w	r4, [r8, #8]
 80055ea:	d007      	beq.n	80055fc <_fflush_r+0x4c>
 80055ec:	f24b 73b4 	movw	r3, #47028	; 0xb7b4
 80055f0:	f6c0 0300 	movt	r3, #2048	; 0x800
 80055f4:	429c      	cmp	r4, r3
 80055f6:	bf08      	it	eq
 80055f8:	f8d8 400c 	ldreq.w	r4, [r8, #12]
 80055fc:	89a6      	ldrh	r6, [r4, #12]
 80055fe:	2e00      	cmp	r6, #0
 8005600:	d028      	beq.n	8005654 <_fflush_r+0xa4>
 8005602:	b233      	sxth	r3, r6
 8005604:	f013 0008 	ands.w	r0, r3, #8
 8005608:	d027      	beq.n	800565a <_fflush_r+0xaa>
 800560a:	6926      	ldr	r6, [r4, #16]
 800560c:	b316      	cbz	r6, 8005654 <_fflush_r+0xa4>
 800560e:	f013 0f03 	tst.w	r3, #3
 8005612:	6825      	ldr	r5, [r4, #0]
 8005614:	6026      	str	r6, [r4, #0]
 8005616:	bf08      	it	eq
 8005618:	6963      	ldreq	r3, [r4, #20]
 800561a:	ebc6 0505 	rsb	r5, r6, r5
 800561e:	bf18      	it	ne
 8005620:	2300      	movne	r3, #0
 8005622:	2d00      	cmp	r5, #0
 8005624:	60a3      	str	r3, [r4, #8]
 8005626:	dc02      	bgt.n	800562e <_fflush_r+0x7e>
 8005628:	e09a      	b.n	8005760 <_fflush_r+0x1b0>
 800562a:	2d00      	cmp	r5, #0
 800562c:	dd74      	ble.n	8005718 <_fflush_r+0x168>
 800562e:	4632      	mov	r2, r6
 8005630:	462b      	mov	r3, r5
 8005632:	6aa7      	ldr	r7, [r4, #40]	; 0x28
 8005634:	4640      	mov	r0, r8
 8005636:	6a21      	ldr	r1, [r4, #32]
 8005638:	47b8      	blx	r7
 800563a:	2800      	cmp	r0, #0
 800563c:	ebc0 0505 	rsb	r5, r0, r5
 8005640:	4406      	add	r6, r0
 8005642:	dcf2      	bgt.n	800562a <_fflush_r+0x7a>
 8005644:	89a3      	ldrh	r3, [r4, #12]
 8005646:	f04f 30ff 	mov.w	r0, #4294967295
 800564a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800564e:	81a3      	strh	r3, [r4, #12]
 8005650:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005654:	4630      	mov	r0, r6
 8005656:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800565a:	6862      	ldr	r2, [r4, #4]
 800565c:	f446 6300 	orr.w	r3, r6, #2048	; 0x800
 8005660:	81a3      	strh	r3, [r4, #12]
 8005662:	2a00      	cmp	r2, #0
 8005664:	dd5b      	ble.n	800571e <_fflush_r+0x16e>
 8005666:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8005668:	2e00      	cmp	r6, #0
 800566a:	d0f3      	beq.n	8005654 <_fflush_r+0xa4>
 800566c:	b29b      	uxth	r3, r3
 800566e:	2200      	movs	r2, #0
 8005670:	f413 5780 	ands.w	r7, r3, #4096	; 0x1000
 8005674:	f8d8 5000 	ldr.w	r5, [r8]
 8005678:	f8c8 2000 	str.w	r2, [r8]
 800567c:	bf18      	it	ne
 800567e:	6d62      	ldrne	r2, [r4, #84]	; 0x54
 8005680:	d033      	beq.n	80056ea <_fflush_r+0x13a>
 8005682:	f013 0f04 	tst.w	r3, #4
 8005686:	d005      	beq.n	8005694 <_fflush_r+0xe4>
 8005688:	6861      	ldr	r1, [r4, #4]
 800568a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800568c:	1a52      	subs	r2, r2, r1
 800568e:	b10b      	cbz	r3, 8005694 <_fflush_r+0xe4>
 8005690:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8005692:	1ad2      	subs	r2, r2, r3
 8005694:	2300      	movs	r3, #0
 8005696:	4640      	mov	r0, r8
 8005698:	6a21      	ldr	r1, [r4, #32]
 800569a:	47b0      	blx	r6
 800569c:	f1b0 3fff 	cmp.w	r0, #4294967295
 80056a0:	d02f      	beq.n	8005702 <_fflush_r+0x152>
 80056a2:	89a3      	ldrh	r3, [r4, #12]
 80056a4:	2100      	movs	r1, #0
 80056a6:	6922      	ldr	r2, [r4, #16]
 80056a8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80056ac:	6061      	str	r1, [r4, #4]
 80056ae:	041b      	lsls	r3, r3, #16
 80056b0:	6022      	str	r2, [r4, #0]
 80056b2:	0c1b      	lsrs	r3, r3, #16
 80056b4:	81a3      	strh	r3, [r4, #12]
 80056b6:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 80056ba:	d003      	beq.n	80056c4 <_fflush_r+0x114>
 80056bc:	f1b0 3fff 	cmp.w	r0, #4294967295
 80056c0:	d031      	beq.n	8005726 <_fflush_r+0x176>
 80056c2:	6560      	str	r0, [r4, #84]	; 0x54
 80056c4:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80056c6:	f8c8 5000 	str.w	r5, [r8]
 80056ca:	2900      	cmp	r1, #0
 80056cc:	d031      	beq.n	8005732 <_fflush_r+0x182>
 80056ce:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80056d2:	4299      	cmp	r1, r3
 80056d4:	d002      	beq.n	80056dc <_fflush_r+0x12c>
 80056d6:	4640      	mov	r0, r8
 80056d8:	f000 f9c4 	bl	8005a64 <_free_r>
 80056dc:	2000      	movs	r0, #0
 80056de:	6360      	str	r0, [r4, #52]	; 0x34
 80056e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80056e4:	f000 f882 	bl	80057ec <__sinit>
 80056e8:	e76e      	b.n	80055c8 <_fflush_r+0x18>
 80056ea:	463a      	mov	r2, r7
 80056ec:	2301      	movs	r3, #1
 80056ee:	4640      	mov	r0, r8
 80056f0:	6a21      	ldr	r1, [r4, #32]
 80056f2:	47b0      	blx	r6
 80056f4:	f1b0 3fff 	cmp.w	r0, #4294967295
 80056f8:	4602      	mov	r2, r0
 80056fa:	d01d      	beq.n	8005738 <_fflush_r+0x188>
 80056fc:	89a3      	ldrh	r3, [r4, #12]
 80056fe:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8005700:	e7bf      	b.n	8005682 <_fflush_r+0xd2>
 8005702:	f8d8 3000 	ldr.w	r3, [r8]
 8005706:	2b1d      	cmp	r3, #29
 8005708:	d89c      	bhi.n	8005644 <_fflush_r+0x94>
 800570a:	f44f 7201 	mov.w	r2, #516	; 0x204
 800570e:	f2c8 0200 	movt	r2, #32768	; 0x8000
 8005712:	409a      	lsls	r2, r3
 8005714:	d4c5      	bmi.n	80056a2 <_fflush_r+0xf2>
 8005716:	e795      	b.n	8005644 <_fflush_r+0x94>
 8005718:	2000      	movs	r0, #0
 800571a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800571e:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8005720:	2a00      	cmp	r2, #0
 8005722:	dca0      	bgt.n	8005666 <_fflush_r+0xb6>
 8005724:	e7f9      	b.n	800571a <_fflush_r+0x16a>
 8005726:	f8d8 3000 	ldr.w	r3, [r8]
 800572a:	2b00      	cmp	r3, #0
 800572c:	d1ca      	bne.n	80056c4 <_fflush_r+0x114>
 800572e:	6560      	str	r0, [r4, #84]	; 0x54
 8005730:	e7c8      	b.n	80056c4 <_fflush_r+0x114>
 8005732:	4608      	mov	r0, r1
 8005734:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005738:	f8d8 3000 	ldr.w	r3, [r8]
 800573c:	2b00      	cmp	r3, #0
 800573e:	d0dd      	beq.n	80056fc <_fflush_r+0x14c>
 8005740:	f1a3 021d 	sub.w	r2, r3, #29
 8005744:	4251      	negs	r1, r2
 8005746:	eb41 0102 	adc.w	r1, r1, r2
 800574a:	2b16      	cmp	r3, #22
 800574c:	bf14      	ite	ne
 800574e:	460b      	movne	r3, r1
 8005750:	f041 0301 	orreq.w	r3, r1, #1
 8005754:	b13b      	cbz	r3, 8005766 <_fflush_r+0x1b6>
 8005756:	f8c8 5000 	str.w	r5, [r8]
 800575a:	4638      	mov	r0, r7
 800575c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005760:	2000      	movs	r0, #0
 8005762:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005766:	89a3      	ldrh	r3, [r4, #12]
 8005768:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800576c:	81a3      	strh	r3, [r4, #12]
 800576e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005772:	bf00      	nop

08005774 <fflush>:
 8005774:	b130      	cbz	r0, 8005784 <fflush+0x10>
 8005776:	f240 236c 	movw	r3, #620	; 0x26c
 800577a:	4601      	mov	r1, r0
 800577c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005780:	6818      	ldr	r0, [r3, #0]
 8005782:	e715      	b.n	80055b0 <_fflush_r>
 8005784:	f24b 7370 	movw	r3, #46960	; 0xb770
 8005788:	f245 51b1 	movw	r1, #21937	; 0x55b1
 800578c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005790:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005794:	6818      	ldr	r0, [r3, #0]
 8005796:	f000 ba5b 	b.w	8005c50 <_fwalk_reent>
 800579a:	bf00      	nop

0800579c <__fp_lock>:
 800579c:	2000      	movs	r0, #0
 800579e:	4770      	bx	lr

080057a0 <__fp_unlock>:
 80057a0:	2000      	movs	r0, #0
 80057a2:	4770      	bx	lr

080057a4 <_cleanup_r>:
 80057a4:	f248 5125 	movw	r1, #34085	; 0x8525
 80057a8:	f6c0 0100 	movt	r1, #2048	; 0x800
 80057ac:	f000 ba26 	b.w	8005bfc <_fwalk>

080057b0 <__sfmoreglue>:
 80057b0:	b570      	push	{r4, r5, r6, lr}
 80057b2:	2568      	movs	r5, #104	; 0x68
 80057b4:	460e      	mov	r6, r1
 80057b6:	fb05 f501 	mul.w	r5, r5, r1
 80057ba:	f105 010c 	add.w	r1, r5, #12
 80057be:	f7ff fa6f 	bl	8004ca0 <_malloc_r>
 80057c2:	4604      	mov	r4, r0
 80057c4:	b148      	cbz	r0, 80057da <__sfmoreglue+0x2a>
 80057c6:	f100 030c 	add.w	r3, r0, #12
 80057ca:	2100      	movs	r1, #0
 80057cc:	6046      	str	r6, [r0, #4]
 80057ce:	462a      	mov	r2, r5
 80057d0:	4618      	mov	r0, r3
 80057d2:	6021      	str	r1, [r4, #0]
 80057d4:	60a3      	str	r3, [r4, #8]
 80057d6:	f000 fa67 	bl	8005ca8 <memset>
 80057da:	4620      	mov	r0, r4
 80057dc:	bd70      	pop	{r4, r5, r6, pc}
 80057de:	bf00      	nop

080057e0 <_cleanup>:
 80057e0:	f24b 7370 	movw	r3, #46960	; 0xb770
 80057e4:	f6c0 0300 	movt	r3, #2048	; 0x800
 80057e8:	6818      	ldr	r0, [r3, #0]
 80057ea:	e7db      	b.n	80057a4 <_cleanup_r>

080057ec <__sinit>:
 80057ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80057f0:	4605      	mov	r5, r0
 80057f2:	6984      	ldr	r4, [r0, #24]
 80057f4:	b083      	sub	sp, #12
 80057f6:	2c00      	cmp	r4, #0
 80057f8:	d178      	bne.n	80058ec <__sinit+0x100>
 80057fa:	f245 72a5 	movw	r2, #22437	; 0x57a5
 80057fe:	2301      	movs	r3, #1
 8005800:	f6c0 0200 	movt	r2, #2048	; 0x800
 8005804:	6183      	str	r3, [r0, #24]
 8005806:	6282      	str	r2, [r0, #40]	; 0x28
 8005808:	f645 595d 	movw	r9, #23901	; 0x5d5d
 800580c:	f8c0 40d8 	str.w	r4, [r0, #216]	; 0xd8
 8005810:	f645 5885 	movw	r8, #23941	; 0x5d85
 8005814:	f8c0 40dc 	str.w	r4, [r0, #220]	; 0xdc
 8005818:	f645 5ac1 	movw	sl, #24001	; 0x5dc1
 800581c:	f8c0 40e0 	str.w	r4, [r0, #224]	; 0xe0
 8005820:	f645 5be9 	movw	fp, #24041	; 0x5de9
 8005824:	9301      	str	r3, [sp, #4]
 8005826:	f000 f865 	bl	80058f4 <__sfp>
 800582a:	f6c0 0900 	movt	r9, #2048	; 0x800
 800582e:	f6c0 0800 	movt	r8, #2048	; 0x800
 8005832:	f6c0 0a00 	movt	sl, #2048	; 0x800
 8005836:	f6c0 0b00 	movt	fp, #2048	; 0x800
 800583a:	6068      	str	r0, [r5, #4]
 800583c:	4628      	mov	r0, r5
 800583e:	f000 f859 	bl	80058f4 <__sfp>
 8005842:	60a8      	str	r0, [r5, #8]
 8005844:	4628      	mov	r0, r5
 8005846:	f000 f855 	bl	80058f4 <__sfp>
 800584a:	686f      	ldr	r7, [r5, #4]
 800584c:	4621      	mov	r1, r4
 800584e:	2208      	movs	r2, #8
 8005850:	60e8      	str	r0, [r5, #12]
 8005852:	2004      	movs	r0, #4
 8005854:	603c      	str	r4, [r7, #0]
 8005856:	81b8      	strh	r0, [r7, #12]
 8005858:	f107 005c 	add.w	r0, r7, #92	; 0x5c
 800585c:	607c      	str	r4, [r7, #4]
 800585e:	60bc      	str	r4, [r7, #8]
 8005860:	667c      	str	r4, [r7, #100]	; 0x64
 8005862:	81fc      	strh	r4, [r7, #14]
 8005864:	613c      	str	r4, [r7, #16]
 8005866:	617c      	str	r4, [r7, #20]
 8005868:	61bc      	str	r4, [r7, #24]
 800586a:	f000 fa1d 	bl	8005ca8 <memset>
 800586e:	68ae      	ldr	r6, [r5, #8]
 8005870:	9b01      	ldr	r3, [sp, #4]
 8005872:	4621      	mov	r1, r4
 8005874:	2208      	movs	r2, #8
 8005876:	2009      	movs	r0, #9
 8005878:	623f      	str	r7, [r7, #32]
 800587a:	81b0      	strh	r0, [r6, #12]
 800587c:	f106 005c 	add.w	r0, r6, #92	; 0x5c
 8005880:	81f3      	strh	r3, [r6, #14]
 8005882:	f8c7 9024 	str.w	r9, [r7, #36]	; 0x24
 8005886:	f8c7 8028 	str.w	r8, [r7, #40]	; 0x28
 800588a:	f8c7 a02c 	str.w	sl, [r7, #44]	; 0x2c
 800588e:	f8c7 b030 	str.w	fp, [r7, #48]	; 0x30
 8005892:	6034      	str	r4, [r6, #0]
 8005894:	6074      	str	r4, [r6, #4]
 8005896:	60b4      	str	r4, [r6, #8]
 8005898:	6674      	str	r4, [r6, #100]	; 0x64
 800589a:	6134      	str	r4, [r6, #16]
 800589c:	6174      	str	r4, [r6, #20]
 800589e:	61b4      	str	r4, [r6, #24]
 80058a0:	f000 fa02 	bl	8005ca8 <memset>
 80058a4:	68ed      	ldr	r5, [r5, #12]
 80058a6:	2312      	movs	r3, #18
 80058a8:	2002      	movs	r0, #2
 80058aa:	6236      	str	r6, [r6, #32]
 80058ac:	4621      	mov	r1, r4
 80058ae:	81e8      	strh	r0, [r5, #14]
 80058b0:	2208      	movs	r2, #8
 80058b2:	f8c6 9024 	str.w	r9, [r6, #36]	; 0x24
 80058b6:	f105 005c 	add.w	r0, r5, #92	; 0x5c
 80058ba:	81ab      	strh	r3, [r5, #12]
 80058bc:	f8c6 8028 	str.w	r8, [r6, #40]	; 0x28
 80058c0:	f8c6 a02c 	str.w	sl, [r6, #44]	; 0x2c
 80058c4:	f8c6 b030 	str.w	fp, [r6, #48]	; 0x30
 80058c8:	602c      	str	r4, [r5, #0]
 80058ca:	606c      	str	r4, [r5, #4]
 80058cc:	60ac      	str	r4, [r5, #8]
 80058ce:	666c      	str	r4, [r5, #100]	; 0x64
 80058d0:	612c      	str	r4, [r5, #16]
 80058d2:	616c      	str	r4, [r5, #20]
 80058d4:	61ac      	str	r4, [r5, #24]
 80058d6:	f000 f9e7 	bl	8005ca8 <memset>
 80058da:	622d      	str	r5, [r5, #32]
 80058dc:	f8c5 9024 	str.w	r9, [r5, #36]	; 0x24
 80058e0:	f8c5 8028 	str.w	r8, [r5, #40]	; 0x28
 80058e4:	f8c5 a02c 	str.w	sl, [r5, #44]	; 0x2c
 80058e8:	f8c5 b030 	str.w	fp, [r5, #48]	; 0x30
 80058ec:	b003      	add	sp, #12
 80058ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80058f2:	bf00      	nop

080058f4 <__sfp>:
 80058f4:	f24b 7370 	movw	r3, #46960	; 0xb770
 80058f8:	f6c0 0300 	movt	r3, #2048	; 0x800
 80058fc:	b570      	push	{r4, r5, r6, lr}
 80058fe:	4606      	mov	r6, r0
 8005900:	681d      	ldr	r5, [r3, #0]
 8005902:	69ab      	ldr	r3, [r5, #24]
 8005904:	2b00      	cmp	r3, #0
 8005906:	d029      	beq.n	800595c <__sfp+0x68>
 8005908:	35d8      	adds	r5, #216	; 0xd8
 800590a:	686b      	ldr	r3, [r5, #4]
 800590c:	68ac      	ldr	r4, [r5, #8]
 800590e:	3b01      	subs	r3, #1
 8005910:	d503      	bpl.n	800591a <__sfp+0x26>
 8005912:	e01f      	b.n	8005954 <__sfp+0x60>
 8005914:	3468      	adds	r4, #104	; 0x68
 8005916:	3b01      	subs	r3, #1
 8005918:	d31c      	bcc.n	8005954 <__sfp+0x60>
 800591a:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 800591e:	2a00      	cmp	r2, #0
 8005920:	d1f8      	bne.n	8005914 <__sfp+0x20>
 8005922:	2500      	movs	r5, #0
 8005924:	f04f 33ff 	mov.w	r3, #4294967295
 8005928:	6665      	str	r5, [r4, #100]	; 0x64
 800592a:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 800592e:	81e3      	strh	r3, [r4, #14]
 8005930:	4629      	mov	r1, r5
 8005932:	2301      	movs	r3, #1
 8005934:	6025      	str	r5, [r4, #0]
 8005936:	81a3      	strh	r3, [r4, #12]
 8005938:	2208      	movs	r2, #8
 800593a:	60a5      	str	r5, [r4, #8]
 800593c:	6065      	str	r5, [r4, #4]
 800593e:	6125      	str	r5, [r4, #16]
 8005940:	6165      	str	r5, [r4, #20]
 8005942:	61a5      	str	r5, [r4, #24]
 8005944:	f000 f9b0 	bl	8005ca8 <memset>
 8005948:	6365      	str	r5, [r4, #52]	; 0x34
 800594a:	63a5      	str	r5, [r4, #56]	; 0x38
 800594c:	64a5      	str	r5, [r4, #72]	; 0x48
 800594e:	64e5      	str	r5, [r4, #76]	; 0x4c
 8005950:	4620      	mov	r0, r4
 8005952:	bd70      	pop	{r4, r5, r6, pc}
 8005954:	6828      	ldr	r0, [r5, #0]
 8005956:	b128      	cbz	r0, 8005964 <__sfp+0x70>
 8005958:	4605      	mov	r5, r0
 800595a:	e7d6      	b.n	800590a <__sfp+0x16>
 800595c:	4628      	mov	r0, r5
 800595e:	f7ff ff45 	bl	80057ec <__sinit>
 8005962:	e7d1      	b.n	8005908 <__sfp+0x14>
 8005964:	4630      	mov	r0, r6
 8005966:	2104      	movs	r1, #4
 8005968:	f7ff ff22 	bl	80057b0 <__sfmoreglue>
 800596c:	6028      	str	r0, [r5, #0]
 800596e:	2800      	cmp	r0, #0
 8005970:	d1f2      	bne.n	8005958 <__sfp+0x64>
 8005972:	230c      	movs	r3, #12
 8005974:	4604      	mov	r4, r0
 8005976:	6033      	str	r3, [r6, #0]
 8005978:	e7ea      	b.n	8005950 <__sfp+0x5c>
 800597a:	bf00      	nop

0800597c <__sfp_lock_acquire>:
 800597c:	4770      	bx	lr
 800597e:	bf00      	nop

08005980 <__sfp_lock_release>:
 8005980:	4770      	bx	lr
 8005982:	bf00      	nop

08005984 <__sinit_lock_acquire>:
 8005984:	4770      	bx	lr
 8005986:	bf00      	nop

08005988 <__sinit_lock_release>:
 8005988:	4770      	bx	lr
 800598a:	bf00      	nop

0800598c <__fp_lock_all>:
 800598c:	f240 236c 	movw	r3, #620	; 0x26c
 8005990:	f245 719d 	movw	r1, #22429	; 0x579d
 8005994:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005998:	f6c0 0100 	movt	r1, #2048	; 0x800
 800599c:	6818      	ldr	r0, [r3, #0]
 800599e:	f000 b92d 	b.w	8005bfc <_fwalk>
 80059a2:	bf00      	nop

080059a4 <__fp_unlock_all>:
 80059a4:	f240 236c 	movw	r3, #620	; 0x26c
 80059a8:	f245 71a1 	movw	r1, #22433	; 0x57a1
 80059ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80059b0:	f6c0 0100 	movt	r1, #2048	; 0x800
 80059b4:	6818      	ldr	r0, [r3, #0]
 80059b6:	f000 b921 	b.w	8005bfc <_fwalk>
 80059ba:	bf00      	nop

080059bc <_malloc_trim_r>:
 80059bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80059be:	f240 3460 	movw	r4, #864	; 0x360
 80059c2:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80059c6:	460f      	mov	r7, r1
 80059c8:	4605      	mov	r5, r0
 80059ca:	f7ff fc27 	bl	800521c <__malloc_lock>
 80059ce:	68a3      	ldr	r3, [r4, #8]
 80059d0:	685e      	ldr	r6, [r3, #4]
 80059d2:	f026 0603 	bic.w	r6, r6, #3
 80059d6:	f506 637e 	add.w	r3, r6, #4064	; 0xfe0
 80059da:	330f      	adds	r3, #15
 80059dc:	1bdf      	subs	r7, r3, r7
 80059de:	0b3f      	lsrs	r7, r7, #12
 80059e0:	3f01      	subs	r7, #1
 80059e2:	033f      	lsls	r7, r7, #12
 80059e4:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
 80059e8:	db07      	blt.n	80059fa <_malloc_trim_r+0x3e>
 80059ea:	2100      	movs	r1, #0
 80059ec:	4628      	mov	r0, r5
 80059ee:	f7fb f81d 	bl	8000a2c <_sbrk_r>
 80059f2:	68a3      	ldr	r3, [r4, #8]
 80059f4:	199b      	adds	r3, r3, r6
 80059f6:	4298      	cmp	r0, r3
 80059f8:	d004      	beq.n	8005a04 <_malloc_trim_r+0x48>
 80059fa:	4628      	mov	r0, r5
 80059fc:	f7ff fc10 	bl	8005220 <__malloc_unlock>
 8005a00:	2000      	movs	r0, #0
 8005a02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005a04:	4279      	negs	r1, r7
 8005a06:	4628      	mov	r0, r5
 8005a08:	f7fb f810 	bl	8000a2c <_sbrk_r>
 8005a0c:	f1b0 3fff 	cmp.w	r0, #4294967295
 8005a10:	d010      	beq.n	8005a34 <_malloc_trim_r+0x78>
 8005a12:	f640 23f8 	movw	r3, #2808	; 0xaf8
 8005a16:	68a1      	ldr	r1, [r4, #8]
 8005a18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a1c:	1bf6      	subs	r6, r6, r7
 8005a1e:	4628      	mov	r0, r5
 8005a20:	f046 0601 	orr.w	r6, r6, #1
 8005a24:	681a      	ldr	r2, [r3, #0]
 8005a26:	604e      	str	r6, [r1, #4]
 8005a28:	1bd7      	subs	r7, r2, r7
 8005a2a:	601f      	str	r7, [r3, #0]
 8005a2c:	f7ff fbf8 	bl	8005220 <__malloc_unlock>
 8005a30:	2001      	movs	r0, #1
 8005a32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005a34:	2100      	movs	r1, #0
 8005a36:	4628      	mov	r0, r5
 8005a38:	f7fa fff8 	bl	8000a2c <_sbrk_r>
 8005a3c:	68a3      	ldr	r3, [r4, #8]
 8005a3e:	1ac2      	subs	r2, r0, r3
 8005a40:	2a0f      	cmp	r2, #15
 8005a42:	ddda      	ble.n	80059fa <_malloc_trim_r+0x3e>
 8005a44:	f240 7468 	movw	r4, #1896	; 0x768
 8005a48:	f640 21f8 	movw	r1, #2808	; 0xaf8
 8005a4c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8005a50:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8005a54:	f042 0201 	orr.w	r2, r2, #1
 8005a58:	605a      	str	r2, [r3, #4]
 8005a5a:	6823      	ldr	r3, [r4, #0]
 8005a5c:	1ac0      	subs	r0, r0, r3
 8005a5e:	6008      	str	r0, [r1, #0]
 8005a60:	e7cb      	b.n	80059fa <_malloc_trim_r+0x3e>
 8005a62:	bf00      	nop

08005a64 <_free_r>:
 8005a64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005a68:	460d      	mov	r5, r1
 8005a6a:	4604      	mov	r4, r0
 8005a6c:	2900      	cmp	r1, #0
 8005a6e:	d058      	beq.n	8005b22 <_free_r+0xbe>
 8005a70:	f7ff fbd4 	bl	800521c <__malloc_lock>
 8005a74:	f1a5 0208 	sub.w	r2, r5, #8
 8005a78:	f240 3060 	movw	r0, #864	; 0x360
 8005a7c:	6856      	ldr	r6, [r2, #4]
 8005a7e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005a82:	f026 0301 	bic.w	r3, r6, #1
 8005a86:	f8d0 c008 	ldr.w	ip, [r0, #8]
 8005a8a:	18d1      	adds	r1, r2, r3
 8005a8c:	458c      	cmp	ip, r1
 8005a8e:	684f      	ldr	r7, [r1, #4]
 8005a90:	f027 0703 	bic.w	r7, r7, #3
 8005a94:	d065      	beq.n	8005b62 <_free_r+0xfe>
 8005a96:	f016 0601 	ands.w	r6, r6, #1
 8005a9a:	604f      	str	r7, [r1, #4]
 8005a9c:	d031      	beq.n	8005b02 <_free_r+0x9e>
 8005a9e:	2600      	movs	r6, #0
 8005aa0:	19cd      	adds	r5, r1, r7
 8005aa2:	686d      	ldr	r5, [r5, #4]
 8005aa4:	f015 0f01 	tst.w	r5, #1
 8005aa8:	d106      	bne.n	8005ab8 <_free_r+0x54>
 8005aaa:	19db      	adds	r3, r3, r7
 8005aac:	2e00      	cmp	r6, #0
 8005aae:	d04b      	beq.n	8005b48 <_free_r+0xe4>
 8005ab0:	688d      	ldr	r5, [r1, #8]
 8005ab2:	68c9      	ldr	r1, [r1, #12]
 8005ab4:	60e9      	str	r1, [r5, #12]
 8005ab6:	608d      	str	r5, [r1, #8]
 8005ab8:	f043 0101 	orr.w	r1, r3, #1
 8005abc:	50d3      	str	r3, [r2, r3]
 8005abe:	6051      	str	r1, [r2, #4]
 8005ac0:	b9d6      	cbnz	r6, 8005af8 <_free_r+0x94>
 8005ac2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8005ac6:	d32e      	bcc.n	8005b26 <_free_r+0xc2>
 8005ac8:	0a59      	lsrs	r1, r3, #9
 8005aca:	2904      	cmp	r1, #4
 8005acc:	d86b      	bhi.n	8005ba6 <_free_r+0x142>
 8005ace:	099e      	lsrs	r6, r3, #6
 8005ad0:	3638      	adds	r6, #56	; 0x38
 8005ad2:	00f5      	lsls	r5, r6, #3
 8005ad4:	1945      	adds	r5, r0, r5
 8005ad6:	68a9      	ldr	r1, [r5, #8]
 8005ad8:	42a9      	cmp	r1, r5
 8005ada:	d103      	bne.n	8005ae4 <_free_r+0x80>
 8005adc:	e069      	b.n	8005bb2 <_free_r+0x14e>
 8005ade:	6889      	ldr	r1, [r1, #8]
 8005ae0:	428d      	cmp	r5, r1
 8005ae2:	d004      	beq.n	8005aee <_free_r+0x8a>
 8005ae4:	6848      	ldr	r0, [r1, #4]
 8005ae6:	f020 0003 	bic.w	r0, r0, #3
 8005aea:	4283      	cmp	r3, r0
 8005aec:	d3f7      	bcc.n	8005ade <_free_r+0x7a>
 8005aee:	68cb      	ldr	r3, [r1, #12]
 8005af0:	60d3      	str	r3, [r2, #12]
 8005af2:	6091      	str	r1, [r2, #8]
 8005af4:	60ca      	str	r2, [r1, #12]
 8005af6:	609a      	str	r2, [r3, #8]
 8005af8:	4620      	mov	r0, r4
 8005afa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8005afe:	f7ff bb8f 	b.w	8005220 <__malloc_unlock>
 8005b02:	f855 5c08 	ldr.w	r5, [r5, #-8]
 8005b06:	f100 0c08 	add.w	ip, r0, #8
 8005b0a:	1b52      	subs	r2, r2, r5
 8005b0c:	195b      	adds	r3, r3, r5
 8005b0e:	6895      	ldr	r5, [r2, #8]
 8005b10:	4565      	cmp	r5, ip
 8005b12:	d046      	beq.n	8005ba2 <_free_r+0x13e>
 8005b14:	f8d2 c00c 	ldr.w	ip, [r2, #12]
 8005b18:	f8c5 c00c 	str.w	ip, [r5, #12]
 8005b1c:	f8cc 5008 	str.w	r5, [ip, #8]
 8005b20:	e7be      	b.n	8005aa0 <_free_r+0x3c>
 8005b22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005b26:	08db      	lsrs	r3, r3, #3
 8005b28:	2501      	movs	r5, #1
 8005b2a:	6846      	ldr	r6, [r0, #4]
 8005b2c:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
 8005b30:	109b      	asrs	r3, r3, #2
 8005b32:	fa15 f303 	lsls.w	r3, r5, r3
 8005b36:	60d1      	str	r1, [r2, #12]
 8005b38:	688d      	ldr	r5, [r1, #8]
 8005b3a:	ea46 0303 	orr.w	r3, r6, r3
 8005b3e:	6043      	str	r3, [r0, #4]
 8005b40:	6095      	str	r5, [r2, #8]
 8005b42:	60ea      	str	r2, [r5, #12]
 8005b44:	608a      	str	r2, [r1, #8]
 8005b46:	e7d7      	b.n	8005af8 <_free_r+0x94>
 8005b48:	688d      	ldr	r5, [r1, #8]
 8005b4a:	4f2b      	ldr	r7, [pc, #172]	; (8005bf8 <_free_r+0x194>)
 8005b4c:	42bd      	cmp	r5, r7
 8005b4e:	d1b0      	bne.n	8005ab2 <_free_r+0x4e>
 8005b50:	60ea      	str	r2, [r5, #12]
 8005b52:	f043 0101 	orr.w	r1, r3, #1
 8005b56:	60aa      	str	r2, [r5, #8]
 8005b58:	60d5      	str	r5, [r2, #12]
 8005b5a:	6095      	str	r5, [r2, #8]
 8005b5c:	6051      	str	r1, [r2, #4]
 8005b5e:	50d3      	str	r3, [r2, r3]
 8005b60:	e7ca      	b.n	8005af8 <_free_r+0x94>
 8005b62:	f016 0f01 	tst.w	r6, #1
 8005b66:	443b      	add	r3, r7
 8005b68:	d107      	bne.n	8005b7a <_free_r+0x116>
 8005b6a:	f855 1c08 	ldr.w	r1, [r5, #-8]
 8005b6e:	1a52      	subs	r2, r2, r1
 8005b70:	185b      	adds	r3, r3, r1
 8005b72:	6895      	ldr	r5, [r2, #8]
 8005b74:	68d1      	ldr	r1, [r2, #12]
 8005b76:	60e9      	str	r1, [r5, #12]
 8005b78:	608d      	str	r5, [r1, #8]
 8005b7a:	f240 716c 	movw	r1, #1900	; 0x76c
 8005b7e:	f043 0501 	orr.w	r5, r3, #1
 8005b82:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8005b86:	6055      	str	r5, [r2, #4]
 8005b88:	6082      	str	r2, [r0, #8]
 8005b8a:	680a      	ldr	r2, [r1, #0]
 8005b8c:	4293      	cmp	r3, r2
 8005b8e:	d3b3      	bcc.n	8005af8 <_free_r+0x94>
 8005b90:	f640 23f4 	movw	r3, #2804	; 0xaf4
 8005b94:	4620      	mov	r0, r4
 8005b96:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b9a:	6819      	ldr	r1, [r3, #0]
 8005b9c:	f7ff ff0e 	bl	80059bc <_malloc_trim_r>
 8005ba0:	e7aa      	b.n	8005af8 <_free_r+0x94>
 8005ba2:	2601      	movs	r6, #1
 8005ba4:	e77c      	b.n	8005aa0 <_free_r+0x3c>
 8005ba6:	2914      	cmp	r1, #20
 8005ba8:	d80c      	bhi.n	8005bc4 <_free_r+0x160>
 8005baa:	f101 065b 	add.w	r6, r1, #91	; 0x5b
 8005bae:	00f5      	lsls	r5, r6, #3
 8005bb0:	e790      	b.n	8005ad4 <_free_r+0x70>
 8005bb2:	2501      	movs	r5, #1
 8005bb4:	6847      	ldr	r7, [r0, #4]
 8005bb6:	10b6      	asrs	r6, r6, #2
 8005bb8:	460b      	mov	r3, r1
 8005bba:	40b5      	lsls	r5, r6
 8005bbc:	ea47 0505 	orr.w	r5, r7, r5
 8005bc0:	6045      	str	r5, [r0, #4]
 8005bc2:	e795      	b.n	8005af0 <_free_r+0x8c>
 8005bc4:	2954      	cmp	r1, #84	; 0x54
 8005bc6:	d803      	bhi.n	8005bd0 <_free_r+0x16c>
 8005bc8:	0b1e      	lsrs	r6, r3, #12
 8005bca:	366e      	adds	r6, #110	; 0x6e
 8005bcc:	00f5      	lsls	r5, r6, #3
 8005bce:	e781      	b.n	8005ad4 <_free_r+0x70>
 8005bd0:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
 8005bd4:	d803      	bhi.n	8005bde <_free_r+0x17a>
 8005bd6:	0bde      	lsrs	r6, r3, #15
 8005bd8:	3677      	adds	r6, #119	; 0x77
 8005bda:	00f5      	lsls	r5, r6, #3
 8005bdc:	e77a      	b.n	8005ad4 <_free_r+0x70>
 8005bde:	f240 5554 	movw	r5, #1364	; 0x554
 8005be2:	42a9      	cmp	r1, r5
 8005be4:	d803      	bhi.n	8005bee <_free_r+0x18a>
 8005be6:	0c9e      	lsrs	r6, r3, #18
 8005be8:	367c      	adds	r6, #124	; 0x7c
 8005bea:	00f5      	lsls	r5, r6, #3
 8005bec:	e772      	b.n	8005ad4 <_free_r+0x70>
 8005bee:	f44f 757c 	mov.w	r5, #1008	; 0x3f0
 8005bf2:	267e      	movs	r6, #126	; 0x7e
 8005bf4:	e76e      	b.n	8005ad4 <_free_r+0x70>
 8005bf6:	bf00      	nop
 8005bf8:	20000368 	.word	0x20000368

08005bfc <_fwalk>:
 8005bfc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8005c00:	4607      	mov	r7, r0
 8005c02:	4689      	mov	r9, r1
 8005c04:	f7ff feba 	bl	800597c <__sfp_lock_acquire>
 8005c08:	37d8      	adds	r7, #216	; 0xd8
 8005c0a:	bf08      	it	eq
 8005c0c:	46b8      	moveq	r8, r7
 8005c0e:	d01a      	beq.n	8005c46 <_fwalk+0x4a>
 8005c10:	f04f 0800 	mov.w	r8, #0
 8005c14:	687e      	ldr	r6, [r7, #4]
 8005c16:	68bc      	ldr	r4, [r7, #8]
 8005c18:	2e00      	cmp	r6, #0
 8005c1a:	dd11      	ble.n	8005c40 <_fwalk+0x44>
 8005c1c:	2500      	movs	r5, #0
 8005c1e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8005c22:	3501      	adds	r5, #1
 8005c24:	b143      	cbz	r3, 8005c38 <_fwalk+0x3c>
 8005c26:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 8005c2a:	4620      	mov	r0, r4
 8005c2c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005c30:	d002      	beq.n	8005c38 <_fwalk+0x3c>
 8005c32:	47c8      	blx	r9
 8005c34:	ea48 0800 	orr.w	r8, r8, r0
 8005c38:	42b5      	cmp	r5, r6
 8005c3a:	f104 0468 	add.w	r4, r4, #104	; 0x68
 8005c3e:	d1ee      	bne.n	8005c1e <_fwalk+0x22>
 8005c40:	683f      	ldr	r7, [r7, #0]
 8005c42:	2f00      	cmp	r7, #0
 8005c44:	d1e6      	bne.n	8005c14 <_fwalk+0x18>
 8005c46:	f7ff fe9b 	bl	8005980 <__sfp_lock_release>
 8005c4a:	4640      	mov	r0, r8
 8005c4c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08005c50 <_fwalk_reent>:
 8005c50:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005c54:	4680      	mov	r8, r0
 8005c56:	468a      	mov	sl, r1
 8005c58:	f7ff fe90 	bl	800597c <__sfp_lock_acquire>
 8005c5c:	f118 07d8 	adds.w	r7, r8, #216	; 0xd8
 8005c60:	bf08      	it	eq
 8005c62:	46b9      	moveq	r9, r7
 8005c64:	d01b      	beq.n	8005c9e <_fwalk_reent+0x4e>
 8005c66:	f04f 0900 	mov.w	r9, #0
 8005c6a:	687e      	ldr	r6, [r7, #4]
 8005c6c:	68bc      	ldr	r4, [r7, #8]
 8005c6e:	2e00      	cmp	r6, #0
 8005c70:	dd12      	ble.n	8005c98 <_fwalk_reent+0x48>
 8005c72:	2500      	movs	r5, #0
 8005c74:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8005c78:	3501      	adds	r5, #1
 8005c7a:	b14b      	cbz	r3, 8005c90 <_fwalk_reent+0x40>
 8005c7c:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 8005c80:	4621      	mov	r1, r4
 8005c82:	4640      	mov	r0, r8
 8005c84:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005c88:	d002      	beq.n	8005c90 <_fwalk_reent+0x40>
 8005c8a:	47d0      	blx	sl
 8005c8c:	ea49 0900 	orr.w	r9, r9, r0
 8005c90:	42b5      	cmp	r5, r6
 8005c92:	f104 0468 	add.w	r4, r4, #104	; 0x68
 8005c96:	d1ed      	bne.n	8005c74 <_fwalk_reent+0x24>
 8005c98:	683f      	ldr	r7, [r7, #0]
 8005c9a:	2f00      	cmp	r7, #0
 8005c9c:	d1e5      	bne.n	8005c6a <_fwalk_reent+0x1a>
 8005c9e:	f7ff fe6f 	bl	8005980 <__sfp_lock_release>
 8005ca2:	4648      	mov	r0, r9
 8005ca4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08005ca8 <memset>:
 8005ca8:	2a03      	cmp	r2, #3
 8005caa:	b2c9      	uxtb	r1, r1
 8005cac:	b470      	push	{r4, r5, r6}
 8005cae:	d808      	bhi.n	8005cc2 <memset+0x1a>
 8005cb0:	b12a      	cbz	r2, 8005cbe <memset+0x16>
 8005cb2:	4603      	mov	r3, r0
 8005cb4:	1812      	adds	r2, r2, r0
 8005cb6:	f803 1b01 	strb.w	r1, [r3], #1
 8005cba:	4293      	cmp	r3, r2
 8005cbc:	d1fb      	bne.n	8005cb6 <memset+0xe>
 8005cbe:	bc70      	pop	{r4, r5, r6}
 8005cc0:	4770      	bx	lr
 8005cc2:	1882      	adds	r2, r0, r2
 8005cc4:	4604      	mov	r4, r0
 8005cc6:	e001      	b.n	8005ccc <memset+0x24>
 8005cc8:	f804 1b01 	strb.w	r1, [r4], #1
 8005ccc:	f014 0f03 	tst.w	r4, #3
 8005cd0:	d1fa      	bne.n	8005cc8 <memset+0x20>
 8005cd2:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
 8005cd6:	fb03 f301 	mul.w	r3, r3, r1
 8005cda:	e01f      	b.n	8005d1c <memset+0x74>
 8005cdc:	f844 3c40 	str.w	r3, [r4, #-64]
 8005ce0:	f844 3c3c 	str.w	r3, [r4, #-60]
 8005ce4:	f844 3c38 	str.w	r3, [r4, #-56]
 8005ce8:	f844 3c34 	str.w	r3, [r4, #-52]
 8005cec:	f844 3c30 	str.w	r3, [r4, #-48]
 8005cf0:	f844 3c2c 	str.w	r3, [r4, #-44]
 8005cf4:	f844 3c28 	str.w	r3, [r4, #-40]
 8005cf8:	f844 3c24 	str.w	r3, [r4, #-36]
 8005cfc:	f844 3c20 	str.w	r3, [r4, #-32]
 8005d00:	f844 3c1c 	str.w	r3, [r4, #-28]
 8005d04:	f844 3c18 	str.w	r3, [r4, #-24]
 8005d08:	f844 3c14 	str.w	r3, [r4, #-20]
 8005d0c:	f844 3c10 	str.w	r3, [r4, #-16]
 8005d10:	f844 3c0c 	str.w	r3, [r4, #-12]
 8005d14:	f844 3c08 	str.w	r3, [r4, #-8]
 8005d18:	f844 3c04 	str.w	r3, [r4, #-4]
 8005d1c:	1b16      	subs	r6, r2, r4
 8005d1e:	4625      	mov	r5, r4
 8005d20:	3440      	adds	r4, #64	; 0x40
 8005d22:	2e3f      	cmp	r6, #63	; 0x3f
 8005d24:	dcda      	bgt.n	8005cdc <memset+0x34>
 8005d26:	462c      	mov	r4, r5
 8005d28:	e007      	b.n	8005d3a <memset+0x92>
 8005d2a:	f844 3c10 	str.w	r3, [r4, #-16]
 8005d2e:	f844 3c0c 	str.w	r3, [r4, #-12]
 8005d32:	f844 3c08 	str.w	r3, [r4, #-8]
 8005d36:	f844 3c04 	str.w	r3, [r4, #-4]
 8005d3a:	1b16      	subs	r6, r2, r4
 8005d3c:	4625      	mov	r5, r4
 8005d3e:	3410      	adds	r4, #16
 8005d40:	2e0f      	cmp	r6, #15
 8005d42:	dcf2      	bgt.n	8005d2a <memset+0x82>
 8005d44:	e001      	b.n	8005d4a <memset+0xa2>
 8005d46:	f845 3b04 	str.w	r3, [r5], #4
 8005d4a:	1b54      	subs	r4, r2, r5
 8005d4c:	2c03      	cmp	r4, #3
 8005d4e:	dcfa      	bgt.n	8005d46 <memset+0x9e>
 8005d50:	e001      	b.n	8005d56 <memset+0xae>
 8005d52:	f805 1b01 	strb.w	r1, [r5], #1
 8005d56:	4295      	cmp	r5, r2
 8005d58:	d3fb      	bcc.n	8005d52 <memset+0xaa>
 8005d5a:	e7b0      	b.n	8005cbe <memset+0x16>

08005d5c <__sread>:
 8005d5c:	b510      	push	{r4, lr}
 8005d5e:	460c      	mov	r4, r1
 8005d60:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8005d64:	f003 f9c8 	bl	80090f8 <_read_r>
 8005d68:	2800      	cmp	r0, #0
 8005d6a:	bfab      	itete	ge
 8005d6c:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8005d6e:	89a3      	ldrhlt	r3, [r4, #12]
 8005d70:	181b      	addge	r3, r3, r0
 8005d72:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8005d76:	bfac      	ite	ge
 8005d78:	6563      	strge	r3, [r4, #84]	; 0x54
 8005d7a:	81a3      	strhlt	r3, [r4, #12]
 8005d7c:	bd10      	pop	{r4, pc}
 8005d7e:	bf00      	nop

08005d80 <__seofread>:
 8005d80:	2000      	movs	r0, #0
 8005d82:	4770      	bx	lr

08005d84 <__swrite>:
 8005d84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005d88:	461d      	mov	r5, r3
 8005d8a:	898b      	ldrh	r3, [r1, #12]
 8005d8c:	460c      	mov	r4, r1
 8005d8e:	4607      	mov	r7, r0
 8005d90:	4616      	mov	r6, r2
 8005d92:	f413 7f80 	tst.w	r3, #256	; 0x100
 8005d96:	d006      	beq.n	8005da6 <__swrite+0x22>
 8005d98:	2302      	movs	r3, #2
 8005d9a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8005d9e:	2200      	movs	r2, #0
 8005da0:	f002 fc18 	bl	80085d4 <_lseek_r>
 8005da4:	89a3      	ldrh	r3, [r4, #12]
 8005da6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8005daa:	4638      	mov	r0, r7
 8005dac:	81a3      	strh	r3, [r4, #12]
 8005dae:	4632      	mov	r2, r6
 8005db0:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8005db4:	462b      	mov	r3, r5
 8005db6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8005dba:	f001 bb39 	b.w	8007430 <_write_r>
 8005dbe:	bf00      	nop

08005dc0 <__sseek>:
 8005dc0:	b510      	push	{r4, lr}
 8005dc2:	460c      	mov	r4, r1
 8005dc4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8005dc8:	f002 fc04 	bl	80085d4 <_lseek_r>
 8005dcc:	89a3      	ldrh	r3, [r4, #12]
 8005dce:	f1b0 3fff 	cmp.w	r0, #4294967295
 8005dd2:	bf15      	itete	ne
 8005dd4:	6560      	strne	r0, [r4, #84]	; 0x54
 8005dd6:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8005dda:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8005dde:	81a3      	strheq	r3, [r4, #12]
 8005de0:	bf18      	it	ne
 8005de2:	81a3      	strhne	r3, [r4, #12]
 8005de4:	bd10      	pop	{r4, pc}
 8005de6:	bf00      	nop

08005de8 <__sclose>:
 8005de8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8005dec:	f001 bb36 	b.w	800745c <_close_r>

08005df0 <_svfprintf_r>:
 8005df0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005df4:	b0c5      	sub	sp, #276	; 0x114
 8005df6:	4614      	mov	r4, r2
 8005df8:	9312      	str	r3, [sp, #72]	; 0x48
 8005dfa:	910c      	str	r1, [sp, #48]	; 0x30
 8005dfc:	9011      	str	r0, [sp, #68]	; 0x44
 8005dfe:	f002 fbd9 	bl	80085b4 <_localeconv_r>
 8005e02:	6800      	ldr	r0, [r0, #0]
 8005e04:	9019      	str	r0, [sp, #100]	; 0x64
 8005e06:	f003 fa61 	bl	80092cc <strlen>
 8005e0a:	901c      	str	r0, [sp, #112]	; 0x70
 8005e0c:	980c      	ldr	r0, [sp, #48]	; 0x30
 8005e0e:	8983      	ldrh	r3, [r0, #12]
 8005e10:	f013 0f80 	tst.w	r3, #128	; 0x80
 8005e14:	d003      	beq.n	8005e1e <_svfprintf_r+0x2e>
 8005e16:	6903      	ldr	r3, [r0, #16]
 8005e18:	2b00      	cmp	r3, #0
 8005e1a:	f001 816f 	beq.w	80070fc <_svfprintf_r+0x130c>
 8005e1e:	f10d 0a7c 	add.w	sl, sp, #124	; 0x7c
 8005e22:	2300      	movs	r3, #0
 8005e24:	4656      	mov	r6, sl
 8005e26:	f10d 01f7 	add.w	r1, sp, #247	; 0xf7
 8005e2a:	930e      	str	r3, [sp, #56]	; 0x38
 8005e2c:	9409      	str	r4, [sp, #36]	; 0x24
 8005e2e:	931a      	str	r3, [sp, #104]	; 0x68
 8005e30:	931b      	str	r3, [sp, #108]	; 0x6c
 8005e32:	9317      	str	r3, [sp, #92]	; 0x5c
 8005e34:	931d      	str	r3, [sp, #116]	; 0x74
 8005e36:	930f      	str	r3, [sp, #60]	; 0x3c
 8005e38:	9107      	str	r1, [sp, #28]
 8005e3a:	f8cd a0e4 	str.w	sl, [sp, #228]	; 0xe4
 8005e3e:	933b      	str	r3, [sp, #236]	; 0xec
 8005e40:	933a      	str	r3, [sp, #232]	; 0xe8
 8005e42:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8005e44:	7813      	ldrb	r3, [r2, #0]
 8005e46:	f1b3 0225 	subs.w	r2, r3, #37	; 0x25
 8005e4a:	bf18      	it	ne
 8005e4c:	2201      	movne	r2, #1
 8005e4e:	2b00      	cmp	r3, #0
 8005e50:	bf0c      	ite	eq
 8005e52:	2300      	moveq	r3, #0
 8005e54:	f002 0301 	andne.w	r3, r2, #1
 8005e58:	2b00      	cmp	r3, #0
 8005e5a:	f000 80bd 	beq.w	8005fd8 <_svfprintf_r+0x1e8>
 8005e5e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8005e60:	1c5a      	adds	r2, r3, #1
 8005e62:	4617      	mov	r7, r2
 8005e64:	3201      	adds	r2, #1
 8005e66:	783b      	ldrb	r3, [r7, #0]
 8005e68:	1e19      	subs	r1, r3, #0
 8005e6a:	bf18      	it	ne
 8005e6c:	2101      	movne	r1, #1
 8005e6e:	2b25      	cmp	r3, #37	; 0x25
 8005e70:	bf0c      	ite	eq
 8005e72:	2300      	moveq	r3, #0
 8005e74:	f001 0301 	andne.w	r3, r1, #1
 8005e78:	2b00      	cmp	r3, #0
 8005e7a:	d1f2      	bne.n	8005e62 <_svfprintf_r+0x72>
 8005e7c:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8005e7e:	ebb7 0804 	subs.w	r8, r7, r4
 8005e82:	d010      	beq.n	8005ea6 <_svfprintf_r+0xb6>
 8005e84:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8005e86:	9809      	ldr	r0, [sp, #36]	; 0x24
 8005e88:	3401      	adds	r4, #1
 8005e8a:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8005e8c:	2c07      	cmp	r4, #7
 8005e8e:	f8c6 8004 	str.w	r8, [r6, #4]
 8005e92:	6030      	str	r0, [r6, #0]
 8005e94:	4445      	add	r5, r8
 8005e96:	943a      	str	r4, [sp, #232]	; 0xe8
 8005e98:	953b      	str	r5, [sp, #236]	; 0xec
 8005e9a:	f300 8081 	bgt.w	8005fa0 <_svfprintf_r+0x1b0>
 8005e9e:	3608      	adds	r6, #8
 8005ea0:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8005ea2:	4441      	add	r1, r8
 8005ea4:	910f      	str	r1, [sp, #60]	; 0x3c
 8005ea6:	783b      	ldrb	r3, [r7, #0]
 8005ea8:	2b00      	cmp	r3, #0
 8005eaa:	f000 8081 	beq.w	8005fb0 <_svfprintf_r+0x1c0>
 8005eae:	1c7c      	adds	r4, r7, #1
 8005eb0:	2200      	movs	r2, #0
 8005eb2:	2300      	movs	r3, #0
 8005eb4:	920d      	str	r2, [sp, #52]	; 0x34
 8005eb6:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
 8005eba:	2520      	movs	r5, #32
 8005ebc:	9409      	str	r4, [sp, #36]	; 0x24
 8005ebe:	212b      	movs	r1, #43	; 0x2b
 8005ec0:	787b      	ldrb	r3, [r7, #1]
 8005ec2:	f04f 37ff 	mov.w	r7, #4294967295
 8005ec6:	9208      	str	r2, [sp, #32]
 8005ec8:	4622      	mov	r2, r4
 8005eca:	3201      	adds	r2, #1
 8005ecc:	f1a3 0020 	sub.w	r0, r3, #32
 8005ed0:	2858      	cmp	r0, #88	; 0x58
 8005ed2:	f200 831c 	bhi.w	800650e <_svfprintf_r+0x71e>
 8005ed6:	e8df f010 	tbh	[pc, r0, lsl #1]
 8005eda:	032d      	.short	0x032d
 8005edc:	031a031a 	.word	0x031a031a
 8005ee0:	031a0336 	.word	0x031a0336
 8005ee4:	031a031a 	.word	0x031a031a
 8005ee8:	031a031a 	.word	0x031a031a
 8005eec:	03c7031a 	.word	0x03c7031a
 8005ef0:	031a0081 	.word	0x031a0081
 8005ef4:	0085005d 	.word	0x0085005d
 8005ef8:	009f031a 	.word	0x009f031a
 8005efc:	00a500a5 	.word	0x00a500a5
 8005f00:	00a500a5 	.word	0x00a500a5
 8005f04:	00a500a5 	.word	0x00a500a5
 8005f08:	00a500a5 	.word	0x00a500a5
 8005f0c:	031a00a5 	.word	0x031a00a5
 8005f10:	031a031a 	.word	0x031a031a
 8005f14:	031a031a 	.word	0x031a031a
 8005f18:	031a031a 	.word	0x031a031a
 8005f1c:	031a031a 	.word	0x031a031a
 8005f20:	00b7031a 	.word	0x00b7031a
 8005f24:	031a0241 	.word	0x031a0241
 8005f28:	031a0241 	.word	0x031a0241
 8005f2c:	031a031a 	.word	0x031a031a
 8005f30:	027f031a 	.word	0x027f031a
 8005f34:	031a031a 	.word	0x031a031a
 8005f38:	031a0285 	.word	0x031a0285
 8005f3c:	031a031a 	.word	0x031a031a
 8005f40:	031a031a 	.word	0x031a031a
 8005f44:	031a02a3 	.word	0x031a02a3
 8005f48:	02b2031a 	.word	0x02b2031a
 8005f4c:	031a031a 	.word	0x031a031a
 8005f50:	031a031a 	.word	0x031a031a
 8005f54:	031a031a 	.word	0x031a031a
 8005f58:	031a031a 	.word	0x031a031a
 8005f5c:	031a031a 	.word	0x031a031a
 8005f60:	033c0354 	.word	0x033c0354
 8005f64:	02410241 	.word	0x02410241
 8005f68:	034e0241 	.word	0x034e0241
 8005f6c:	031a033c 	.word	0x031a033c
 8005f70:	030b031a 	.word	0x030b031a
 8005f74:	039a031a 	.word	0x039a031a
 8005f78:	037e0368 	.word	0x037e0368
 8005f7c:	031a02dd 	.word	0x031a02dd
 8005f80:	031a02e3 	.word	0x031a02e3
 8005f84:	031a03ab 	.word	0x031a03ab
 8005f88:	03d2031a 	.word	0x03d2031a
 8005f8c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005f8e:	9012      	str	r0, [sp, #72]	; 0x48
 8005f90:	425b      	negs	r3, r3
 8005f92:	930d      	str	r3, [sp, #52]	; 0x34
 8005f94:	9c08      	ldr	r4, [sp, #32]
 8005f96:	f044 0404 	orr.w	r4, r4, #4
 8005f9a:	9408      	str	r4, [sp, #32]
 8005f9c:	7813      	ldrb	r3, [r2, #0]
 8005f9e:	e794      	b.n	8005eca <_svfprintf_r+0xda>
 8005fa0:	9811      	ldr	r0, [sp, #68]	; 0x44
 8005fa2:	aa39      	add	r2, sp, #228	; 0xe4
 8005fa4:	990c      	ldr	r1, [sp, #48]	; 0x30
 8005fa6:	f003 f9c1 	bl	800932c <__ssprint_r>
 8005faa:	b940      	cbnz	r0, 8005fbe <_svfprintf_r+0x1ce>
 8005fac:	4656      	mov	r6, sl
 8005fae:	e777      	b.n	8005ea0 <_svfprintf_r+0xb0>
 8005fb0:	9b3b      	ldr	r3, [sp, #236]	; 0xec
 8005fb2:	b123      	cbz	r3, 8005fbe <_svfprintf_r+0x1ce>
 8005fb4:	9811      	ldr	r0, [sp, #68]	; 0x44
 8005fb6:	aa39      	add	r2, sp, #228	; 0xe4
 8005fb8:	990c      	ldr	r1, [sp, #48]	; 0x30
 8005fba:	f003 f9b7 	bl	800932c <__ssprint_r>
 8005fbe:	990c      	ldr	r1, [sp, #48]	; 0x30
 8005fc0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8005fc2:	898b      	ldrh	r3, [r1, #12]
 8005fc4:	f013 0f40 	tst.w	r3, #64	; 0x40
 8005fc8:	bf18      	it	ne
 8005fca:	f04f 32ff 	movne.w	r2, #4294967295
 8005fce:	920f      	str	r2, [sp, #60]	; 0x3c
 8005fd0:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8005fd2:	b045      	add	sp, #276	; 0x114
 8005fd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005fd8:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8005fda:	e764      	b.n	8005ea6 <_svfprintf_r+0xb6>
 8005fdc:	f88d 110f 	strb.w	r1, [sp, #271]	; 0x10f
 8005fe0:	7813      	ldrb	r3, [r2, #0]
 8005fe2:	e772      	b.n	8005eca <_svfprintf_r+0xda>
 8005fe4:	f812 3b01 	ldrb.w	r3, [r2], #1
 8005fe8:	2b2a      	cmp	r3, #42	; 0x2a
 8005fea:	f001 81fc 	beq.w	80073e6 <_svfprintf_r+0x15f6>
 8005fee:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 8005ff2:	2809      	cmp	r0, #9
 8005ff4:	f201 81ac 	bhi.w	8007350 <_svfprintf_r+0x1560>
 8005ff8:	4614      	mov	r4, r2
 8005ffa:	2700      	movs	r7, #0
 8005ffc:	f814 3b01 	ldrb.w	r3, [r4], #1
 8006000:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 8006004:	eb00 0747 	add.w	r7, r0, r7, lsl #1
 8006008:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 800600c:	2809      	cmp	r0, #9
 800600e:	4622      	mov	r2, r4
 8006010:	d9f4      	bls.n	8005ffc <_svfprintf_r+0x20c>
 8006012:	ea47 77e7 	orr.w	r7, r7, r7, asr #31
 8006016:	e759      	b.n	8005ecc <_svfprintf_r+0xdc>
 8006018:	9b08      	ldr	r3, [sp, #32]
 800601a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800601e:	9308      	str	r3, [sp, #32]
 8006020:	7813      	ldrb	r3, [r2, #0]
 8006022:	e752      	b.n	8005eca <_svfprintf_r+0xda>
 8006024:	4614      	mov	r4, r2
 8006026:	2000      	movs	r0, #0
 8006028:	f1a3 0830 	sub.w	r8, r3, #48	; 0x30
 800602c:	f814 3b01 	ldrb.w	r3, [r4], #1
 8006030:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8006034:	f1a3 0c30 	sub.w	ip, r3, #48	; 0x30
 8006038:	4622      	mov	r2, r4
 800603a:	f1bc 0f09 	cmp.w	ip, #9
 800603e:	eb08 0040 	add.w	r0, r8, r0, lsl #1
 8006042:	d9f1      	bls.n	8006028 <_svfprintf_r+0x238>
 8006044:	900d      	str	r0, [sp, #52]	; 0x34
 8006046:	e741      	b.n	8005ecc <_svfprintf_r+0xdc>
 8006048:	9209      	str	r2, [sp, #36]	; 0x24
 800604a:	9a08      	ldr	r2, [sp, #32]
 800604c:	9316      	str	r3, [sp, #88]	; 0x58
 800604e:	f042 0210 	orr.w	r2, r2, #16
 8006052:	9208      	str	r2, [sp, #32]
 8006054:	9b08      	ldr	r3, [sp, #32]
 8006056:	f013 0f20 	tst.w	r3, #32
 800605a:	f000 8281 	beq.w	8006560 <_svfprintf_r+0x770>
 800605e:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8006060:	1de3      	adds	r3, r4, #7
 8006062:	f023 0307 	bic.w	r3, r3, #7
 8006066:	f103 0008 	add.w	r0, r3, #8
 800606a:	9012      	str	r0, [sp, #72]	; 0x48
 800606c:	e9d3 4500 	ldrd	r4, r5, [r3]
 8006070:	2c00      	cmp	r4, #0
 8006072:	f175 0200 	sbcs.w	r2, r5, #0
 8006076:	f2c0 85cd 	blt.w	8006c14 <_svfprintf_r+0xe24>
 800607a:	ea54 0305 	orrs.w	r3, r4, r5
 800607e:	f04f 0301 	mov.w	r3, #1
 8006082:	bf0c      	ite	eq
 8006084:	2200      	moveq	r2, #0
 8006086:	2201      	movne	r2, #1
 8006088:	2f00      	cmp	r7, #0
 800608a:	bfa2      	ittt	ge
 800608c:	9908      	ldrge	r1, [sp, #32]
 800608e:	f021 0180 	bicge.w	r1, r1, #128	; 0x80
 8006092:	9108      	strge	r1, [sp, #32]
 8006094:	2f00      	cmp	r7, #0
 8006096:	bf18      	it	ne
 8006098:	f042 0201 	orrne.w	r2, r2, #1
 800609c:	2a00      	cmp	r2, #0
 800609e:	f000 83ac 	beq.w	80067fa <_svfprintf_r+0xa0a>
 80060a2:	2b01      	cmp	r3, #1
 80060a4:	f000 84fe 	beq.w	8006aa4 <_svfprintf_r+0xcb4>
 80060a8:	2b02      	cmp	r3, #2
 80060aa:	f000 84de 	beq.w	8006a6a <_svfprintf_r+0xc7a>
 80060ae:	f10d 0bbc 	add.w	fp, sp, #188	; 0xbc
 80060b2:	f10b 0327 	add.w	r3, fp, #39	; 0x27
 80060b6:	08ea      	lsrs	r2, r5, #3
 80060b8:	ea4f 08d4 	mov.w	r8, r4, lsr #3
 80060bc:	ea48 7845 	orr.w	r8, r8, r5, lsl #29
 80060c0:	f004 0407 	and.w	r4, r4, #7
 80060c4:	4611      	mov	r1, r2
 80060c6:	f104 0230 	add.w	r2, r4, #48	; 0x30
 80060ca:	460d      	mov	r5, r1
 80060cc:	4644      	mov	r4, r8
 80060ce:	469c      	mov	ip, r3
 80060d0:	701a      	strb	r2, [r3, #0]
 80060d2:	3b01      	subs	r3, #1
 80060d4:	ea54 0005 	orrs.w	r0, r4, r5
 80060d8:	d1ed      	bne.n	80060b6 <_svfprintf_r+0x2c6>
 80060da:	9908      	ldr	r1, [sp, #32]
 80060dc:	f8cd c04c 	str.w	ip, [sp, #76]	; 0x4c
 80060e0:	f011 0f01 	tst.w	r1, #1
 80060e4:	f040 8588 	bne.w	8006bf8 <_svfprintf_r+0xe08>
 80060e8:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 80060ec:	ebcc 020b 	rsb	r2, ip, fp
 80060f0:	9210      	str	r2, [sp, #64]	; 0x40
 80060f2:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 80060f6:	2000      	movs	r0, #0
 80060f8:	9c10      	ldr	r4, [sp, #64]	; 0x40
 80060fa:	9714      	str	r7, [sp, #80]	; 0x50
 80060fc:	42bc      	cmp	r4, r7
 80060fe:	bfb8      	it	lt
 8006100:	463c      	movlt	r4, r7
 8006102:	9018      	str	r0, [sp, #96]	; 0x60
 8006104:	940a      	str	r4, [sp, #40]	; 0x28
 8006106:	b112      	cbz	r2, 800610e <_svfprintf_r+0x31e>
 8006108:	980a      	ldr	r0, [sp, #40]	; 0x28
 800610a:	3001      	adds	r0, #1
 800610c:	900a      	str	r0, [sp, #40]	; 0x28
 800610e:	9908      	ldr	r1, [sp, #32]
 8006110:	f011 0b02 	ands.w	fp, r1, #2
 8006114:	d002      	beq.n	800611c <_svfprintf_r+0x32c>
 8006116:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8006118:	3302      	adds	r3, #2
 800611a:	930a      	str	r3, [sp, #40]	; 0x28
 800611c:	9c08      	ldr	r4, [sp, #32]
 800611e:	f014 0484 	ands.w	r4, r4, #132	; 0x84
 8006122:	9415      	str	r4, [sp, #84]	; 0x54
 8006124:	f040 82cd 	bne.w	80066c2 <_svfprintf_r+0x8d2>
 8006128:	980d      	ldr	r0, [sp, #52]	; 0x34
 800612a:	990a      	ldr	r1, [sp, #40]	; 0x28
 800612c:	1a47      	subs	r7, r0, r1
 800612e:	2f00      	cmp	r7, #0
 8006130:	f340 82c7 	ble.w	80066c2 <_svfprintf_r+0x8d2>
 8006134:	2f10      	cmp	r7, #16
 8006136:	f341 8065 	ble.w	8007204 <_svfprintf_r+0x1414>
 800613a:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800613c:	f24b 78d4 	movw	r8, #47060	; 0xb7d4
 8006140:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006142:	f6c0 0800 	movt	r8, #2048	; 0x800
 8006146:	4629      	mov	r1, r5
 8006148:	f04f 0910 	mov.w	r9, #16
 800614c:	4622      	mov	r2, r4
 800614e:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8006150:	4644      	mov	r4, r8
 8006152:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8006156:	e002      	b.n	800615e <_svfprintf_r+0x36e>
 8006158:	3f10      	subs	r7, #16
 800615a:	2f10      	cmp	r7, #16
 800615c:	dd1b      	ble.n	8006196 <_svfprintf_r+0x3a6>
 800615e:	3201      	adds	r2, #1
 8006160:	6034      	str	r4, [r6, #0]
 8006162:	f8c6 9004 	str.w	r9, [r6, #4]
 8006166:	3110      	adds	r1, #16
 8006168:	3608      	adds	r6, #8
 800616a:	2a07      	cmp	r2, #7
 800616c:	923a      	str	r2, [sp, #232]	; 0xe8
 800616e:	f106 0308 	add.w	r3, r6, #8
 8006172:	913b      	str	r1, [sp, #236]	; 0xec
 8006174:	ddf0      	ble.n	8006158 <_svfprintf_r+0x368>
 8006176:	4640      	mov	r0, r8
 8006178:	4629      	mov	r1, r5
 800617a:	aa39      	add	r2, sp, #228	; 0xe4
 800617c:	4656      	mov	r6, sl
 800617e:	f003 f8d5 	bl	800932c <__ssprint_r>
 8006182:	f10a 0308 	add.w	r3, sl, #8
 8006186:	2800      	cmp	r0, #0
 8006188:	f47f af19 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 800618c:	3f10      	subs	r7, #16
 800618e:	993b      	ldr	r1, [sp, #236]	; 0xec
 8006190:	2f10      	cmp	r7, #16
 8006192:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 8006194:	dce3      	bgt.n	800615e <_svfprintf_r+0x36e>
 8006196:	46a0      	mov	r8, r4
 8006198:	460d      	mov	r5, r1
 800619a:	4614      	mov	r4, r2
 800619c:	3401      	adds	r4, #1
 800619e:	f8c6 8000 	str.w	r8, [r6]
 80061a2:	2c07      	cmp	r4, #7
 80061a4:	6077      	str	r7, [r6, #4]
 80061a6:	443d      	add	r5, r7
 80061a8:	943a      	str	r4, [sp, #232]	; 0xe8
 80061aa:	953b      	str	r5, [sp, #236]	; 0xec
 80061ac:	f300 827e 	bgt.w	80066ac <_svfprintf_r+0x8bc>
 80061b0:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 80061b4:	461e      	mov	r6, r3
 80061b6:	b16a      	cbz	r2, 80061d4 <_svfprintf_r+0x3e4>
 80061b8:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80061ba:	ab43      	add	r3, sp, #268	; 0x10c
 80061bc:	3303      	adds	r3, #3
 80061be:	6033      	str	r3, [r6, #0]
 80061c0:	3401      	adds	r4, #1
 80061c2:	2301      	movs	r3, #1
 80061c4:	2c07      	cmp	r4, #7
 80061c6:	6073      	str	r3, [r6, #4]
 80061c8:	441d      	add	r5, r3
 80061ca:	943a      	str	r4, [sp, #232]	; 0xe8
 80061cc:	953b      	str	r5, [sp, #236]	; 0xec
 80061ce:	f300 83e9 	bgt.w	80069a4 <_svfprintf_r+0xbb4>
 80061d2:	3608      	adds	r6, #8
 80061d4:	f1bb 0f00 	cmp.w	fp, #0
 80061d8:	d00c      	beq.n	80061f4 <_svfprintf_r+0x404>
 80061da:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80061dc:	ab43      	add	r3, sp, #268	; 0x10c
 80061de:	6033      	str	r3, [r6, #0]
 80061e0:	2302      	movs	r3, #2
 80061e2:	3401      	adds	r4, #1
 80061e4:	6073      	str	r3, [r6, #4]
 80061e6:	2c07      	cmp	r4, #7
 80061e8:	441d      	add	r5, r3
 80061ea:	943a      	str	r4, [sp, #232]	; 0xe8
 80061ec:	953b      	str	r5, [sp, #236]	; 0xec
 80061ee:	f300 83ce 	bgt.w	800698e <_svfprintf_r+0xb9e>
 80061f2:	3608      	adds	r6, #8
 80061f4:	9a15      	ldr	r2, [sp, #84]	; 0x54
 80061f6:	2a80      	cmp	r2, #128	; 0x80
 80061f8:	f000 8310 	beq.w	800681c <_svfprintf_r+0xa2c>
 80061fc:	9914      	ldr	r1, [sp, #80]	; 0x50
 80061fe:	9810      	ldr	r0, [sp, #64]	; 0x40
 8006200:	1a0f      	subs	r7, r1, r0
 8006202:	2f00      	cmp	r7, #0
 8006204:	f340 835b 	ble.w	80068be <_svfprintf_r+0xace>
 8006208:	2f10      	cmp	r7, #16
 800620a:	f340 85eb 	ble.w	8006de4 <_svfprintf_r+0xff4>
 800620e:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006210:	462a      	mov	r2, r5
 8006212:	f8df 8a98 	ldr.w	r8, [pc, #2712]	; 8006cac <_svfprintf_r+0xebc>
 8006216:	f04f 0b10 	mov.w	fp, #16
 800621a:	4623      	mov	r3, r4
 800621c:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 800621e:	4644      	mov	r4, r8
 8006220:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8006224:	e002      	b.n	800622c <_svfprintf_r+0x43c>
 8006226:	3f10      	subs	r7, #16
 8006228:	2f10      	cmp	r7, #16
 800622a:	dd1b      	ble.n	8006264 <_svfprintf_r+0x474>
 800622c:	3301      	adds	r3, #1
 800622e:	6034      	str	r4, [r6, #0]
 8006230:	f8c6 b004 	str.w	fp, [r6, #4]
 8006234:	3210      	adds	r2, #16
 8006236:	3608      	adds	r6, #8
 8006238:	2b07      	cmp	r3, #7
 800623a:	933a      	str	r3, [sp, #232]	; 0xe8
 800623c:	f106 0908 	add.w	r9, r6, #8
 8006240:	923b      	str	r2, [sp, #236]	; 0xec
 8006242:	ddf0      	ble.n	8006226 <_svfprintf_r+0x436>
 8006244:	4640      	mov	r0, r8
 8006246:	4629      	mov	r1, r5
 8006248:	aa39      	add	r2, sp, #228	; 0xe4
 800624a:	f10a 0908 	add.w	r9, sl, #8
 800624e:	f003 f86d 	bl	800932c <__ssprint_r>
 8006252:	4656      	mov	r6, sl
 8006254:	2800      	cmp	r0, #0
 8006256:	f47f aeb2 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 800625a:	3f10      	subs	r7, #16
 800625c:	9a3b      	ldr	r2, [sp, #236]	; 0xec
 800625e:	2f10      	cmp	r7, #16
 8006260:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 8006262:	dce3      	bgt.n	800622c <_svfprintf_r+0x43c>
 8006264:	46a0      	mov	r8, r4
 8006266:	4615      	mov	r5, r2
 8006268:	461c      	mov	r4, r3
 800626a:	3401      	adds	r4, #1
 800626c:	f8c6 8000 	str.w	r8, [r6]
 8006270:	2c07      	cmp	r4, #7
 8006272:	6077      	str	r7, [r6, #4]
 8006274:	443d      	add	r5, r7
 8006276:	943a      	str	r4, [sp, #232]	; 0xe8
 8006278:	953b      	str	r5, [sp, #236]	; 0xec
 800627a:	f300 837d 	bgt.w	8006978 <_svfprintf_r+0xb88>
 800627e:	9a08      	ldr	r2, [sp, #32]
 8006280:	f412 7f80 	tst.w	r2, #256	; 0x100
 8006284:	f040 824e 	bne.w	8006724 <_svfprintf_r+0x934>
 8006288:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 800628a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800628c:	3401      	adds	r4, #1
 800628e:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8006290:	2c07      	cmp	r4, #7
 8006292:	441d      	add	r5, r3
 8006294:	f8c9 3004 	str.w	r3, [r9, #4]
 8006298:	f8c9 0000 	str.w	r0, [r9]
 800629c:	953b      	str	r5, [sp, #236]	; 0xec
 800629e:	943a      	str	r4, [sp, #232]	; 0xe8
 80062a0:	f300 8235 	bgt.w	800670e <_svfprintf_r+0x91e>
 80062a4:	f109 0908 	add.w	r9, r9, #8
 80062a8:	9c08      	ldr	r4, [sp, #32]
 80062aa:	f014 0f04 	tst.w	r4, #4
 80062ae:	d046      	beq.n	800633e <_svfprintf_r+0x54e>
 80062b0:	980d      	ldr	r0, [sp, #52]	; 0x34
 80062b2:	990a      	ldr	r1, [sp, #40]	; 0x28
 80062b4:	1a46      	subs	r6, r0, r1
 80062b6:	2e00      	cmp	r6, #0
 80062b8:	dd41      	ble.n	800633e <_svfprintf_r+0x54e>
 80062ba:	2e10      	cmp	r6, #16
 80062bc:	f340 87da 	ble.w	8007274 <_svfprintf_r+0x1484>
 80062c0:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80062c2:	f24b 78d4 	movw	r8, #47060	; 0xb7d4
 80062c6:	f6c0 0800 	movt	r8, #2048	; 0x800
 80062ca:	2710      	movs	r7, #16
 80062cc:	4623      	mov	r3, r4
 80062ce:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 80062d2:	4644      	mov	r4, r8
 80062d4:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 80062d8:	e002      	b.n	80062e0 <_svfprintf_r+0x4f0>
 80062da:	3e10      	subs	r6, #16
 80062dc:	2e10      	cmp	r6, #16
 80062de:	dd19      	ble.n	8006314 <_svfprintf_r+0x524>
 80062e0:	3301      	adds	r3, #1
 80062e2:	3510      	adds	r5, #16
 80062e4:	2b07      	cmp	r3, #7
 80062e6:	f8c9 4000 	str.w	r4, [r9]
 80062ea:	f8c9 7004 	str.w	r7, [r9, #4]
 80062ee:	f109 0908 	add.w	r9, r9, #8
 80062f2:	933a      	str	r3, [sp, #232]	; 0xe8
 80062f4:	953b      	str	r5, [sp, #236]	; 0xec
 80062f6:	ddf0      	ble.n	80062da <_svfprintf_r+0x4ea>
 80062f8:	4640      	mov	r0, r8
 80062fa:	4659      	mov	r1, fp
 80062fc:	aa39      	add	r2, sp, #228	; 0xe4
 80062fe:	46d1      	mov	r9, sl
 8006300:	f003 f814 	bl	800932c <__ssprint_r>
 8006304:	2800      	cmp	r0, #0
 8006306:	f47f ae5a 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 800630a:	3e10      	subs	r6, #16
 800630c:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800630e:	2e10      	cmp	r6, #16
 8006310:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 8006312:	dce5      	bgt.n	80062e0 <_svfprintf_r+0x4f0>
 8006314:	46a0      	mov	r8, r4
 8006316:	461c      	mov	r4, r3
 8006318:	3401      	adds	r4, #1
 800631a:	f8c9 8000 	str.w	r8, [r9]
 800631e:	2c07      	cmp	r4, #7
 8006320:	f8c9 6004 	str.w	r6, [r9, #4]
 8006324:	4435      	add	r5, r6
 8006326:	943a      	str	r4, [sp, #232]	; 0xe8
 8006328:	953b      	str	r5, [sp, #236]	; 0xec
 800632a:	dd08      	ble.n	800633e <_svfprintf_r+0x54e>
 800632c:	9811      	ldr	r0, [sp, #68]	; 0x44
 800632e:	aa39      	add	r2, sp, #228	; 0xe4
 8006330:	990c      	ldr	r1, [sp, #48]	; 0x30
 8006332:	f002 fffb 	bl	800932c <__ssprint_r>
 8006336:	2800      	cmp	r0, #0
 8006338:	f47f ae41 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 800633c:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800633e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8006340:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8006342:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8006344:	429c      	cmp	r4, r3
 8006346:	bfac      	ite	ge
 8006348:	1912      	addge	r2, r2, r4
 800634a:	18d2      	addlt	r2, r2, r3
 800634c:	920f      	str	r2, [sp, #60]	; 0x3c
 800634e:	2d00      	cmp	r5, #0
 8006350:	f040 8303 	bne.w	800695a <_svfprintf_r+0xb6a>
 8006354:	2000      	movs	r0, #0
 8006356:	4656      	mov	r6, sl
 8006358:	903a      	str	r0, [sp, #232]	; 0xe8
 800635a:	e572      	b.n	8005e42 <_svfprintf_r+0x52>
 800635c:	9908      	ldr	r1, [sp, #32]
 800635e:	461d      	mov	r5, r3
 8006360:	9209      	str	r2, [sp, #36]	; 0x24
 8006362:	f011 0f08 	tst.w	r1, #8
 8006366:	9316      	str	r3, [sp, #88]	; 0x58
 8006368:	f000 8487 	beq.w	8006c7a <_svfprintf_r+0xe8a>
 800636c:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800636e:	1dd3      	adds	r3, r2, #7
 8006370:	f023 0307 	bic.w	r3, r3, #7
 8006374:	f103 0408 	add.w	r4, r3, #8
 8006378:	9412      	str	r4, [sp, #72]	; 0x48
 800637a:	6818      	ldr	r0, [r3, #0]
 800637c:	901a      	str	r0, [sp, #104]	; 0x68
 800637e:	685b      	ldr	r3, [r3, #4]
 8006380:	931b      	str	r3, [sp, #108]	; 0x6c
 8006382:	981a      	ldr	r0, [sp, #104]	; 0x68
 8006384:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8006386:	f002 ff59 	bl	800923c <__fpclassifyd>
 800638a:	2801      	cmp	r0, #1
 800638c:	f040 8450 	bne.w	8006c30 <_svfprintf_r+0xe40>
 8006390:	981a      	ldr	r0, [sp, #104]	; 0x68
 8006392:	2200      	movs	r2, #0
 8006394:	2300      	movs	r3, #0
 8006396:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8006398:	f004 fdba 	bl	800af10 <__aeabi_dcmplt>
 800639c:	2800      	cmp	r0, #0
 800639e:	f040 871c 	bne.w	80071da <_svfprintf_r+0x13ea>
 80063a2:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 80063a6:	2003      	movs	r0, #3
 80063a8:	f64b 3348 	movw	r3, #47944	; 0xbb48
 80063ac:	f64b 3144 	movw	r1, #47940	; 0xbb44
 80063b0:	900a      	str	r0, [sp, #40]	; 0x28
 80063b2:	9816      	ldr	r0, [sp, #88]	; 0x58
 80063b4:	f6c0 0100 	movt	r1, #2048	; 0x800
 80063b8:	f6c0 0300 	movt	r3, #2048	; 0x800
 80063bc:	2400      	movs	r4, #0
 80063be:	2847      	cmp	r0, #71	; 0x47
 80063c0:	bfd8      	it	le
 80063c2:	460b      	movle	r3, r1
 80063c4:	9908      	ldr	r1, [sp, #32]
 80063c6:	9313      	str	r3, [sp, #76]	; 0x4c
 80063c8:	2303      	movs	r3, #3
 80063ca:	f021 0180 	bic.w	r1, r1, #128	; 0x80
 80063ce:	9414      	str	r4, [sp, #80]	; 0x50
 80063d0:	9108      	str	r1, [sp, #32]
 80063d2:	9310      	str	r3, [sp, #64]	; 0x40
 80063d4:	9418      	str	r4, [sp, #96]	; 0x60
 80063d6:	e696      	b.n	8006106 <_svfprintf_r+0x316>
 80063d8:	9c08      	ldr	r4, [sp, #32]
 80063da:	f044 0408 	orr.w	r4, r4, #8
 80063de:	9408      	str	r4, [sp, #32]
 80063e0:	7813      	ldrb	r3, [r2, #0]
 80063e2:	e572      	b.n	8005eca <_svfprintf_r+0xda>
 80063e4:	9908      	ldr	r1, [sp, #32]
 80063e6:	9209      	str	r2, [sp, #36]	; 0x24
 80063e8:	f041 0110 	orr.w	r1, r1, #16
 80063ec:	9108      	str	r1, [sp, #32]
 80063ee:	9a08      	ldr	r2, [sp, #32]
 80063f0:	9316      	str	r3, [sp, #88]	; 0x58
 80063f2:	f012 0320 	ands.w	r3, r2, #32
 80063f6:	f000 80df 	beq.w	80065b8 <_svfprintf_r+0x7c8>
 80063fa:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80063fc:	1dda      	adds	r2, r3, #7
 80063fe:	2300      	movs	r3, #0
 8006400:	f022 0207 	bic.w	r2, r2, #7
 8006404:	f102 0408 	add.w	r4, r2, #8
 8006408:	9412      	str	r4, [sp, #72]	; 0x48
 800640a:	e9d2 4500 	ldrd	r4, r5, [r2]
 800640e:	ea54 0005 	orrs.w	r0, r4, r5
 8006412:	bf0c      	ite	eq
 8006414:	2200      	moveq	r2, #0
 8006416:	2201      	movne	r2, #1
 8006418:	2000      	movs	r0, #0
 800641a:	f88d 010f 	strb.w	r0, [sp, #271]	; 0x10f
 800641e:	e633      	b.n	8006088 <_svfprintf_r+0x298>
 8006420:	9c08      	ldr	r4, [sp, #32]
 8006422:	9209      	str	r2, [sp, #36]	; 0x24
 8006424:	f044 0410 	orr.w	r4, r4, #16
 8006428:	9408      	str	r4, [sp, #32]
 800642a:	9808      	ldr	r0, [sp, #32]
 800642c:	9316      	str	r3, [sp, #88]	; 0x58
 800642e:	f010 0f20 	tst.w	r0, #32
 8006432:	f000 8104 	beq.w	800663e <_svfprintf_r+0x84e>
 8006436:	9912      	ldr	r1, [sp, #72]	; 0x48
 8006438:	2301      	movs	r3, #1
 800643a:	1dca      	adds	r2, r1, #7
 800643c:	e7e0      	b.n	8006400 <_svfprintf_r+0x610>
 800643e:	9209      	str	r2, [sp, #36]	; 0x24
 8006440:	f64b 3154 	movw	r1, #47956	; 0xbb54
 8006444:	9a08      	ldr	r2, [sp, #32]
 8006446:	f6c0 0100 	movt	r1, #2048	; 0x800
 800644a:	9316      	str	r3, [sp, #88]	; 0x58
 800644c:	f012 0f20 	tst.w	r2, #32
 8006450:	9117      	str	r1, [sp, #92]	; 0x5c
 8006452:	f000 8120 	beq.w	8006696 <_svfprintf_r+0x8a6>
 8006456:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8006458:	1de3      	adds	r3, r4, #7
 800645a:	f023 0307 	bic.w	r3, r3, #7
 800645e:	f103 0008 	add.w	r0, r3, #8
 8006462:	9012      	str	r0, [sp, #72]	; 0x48
 8006464:	e9d3 4500 	ldrd	r4, r5, [r3]
 8006468:	ea54 0205 	orrs.w	r2, r4, r5
 800646c:	9b08      	ldr	r3, [sp, #32]
 800646e:	bf0c      	ite	eq
 8006470:	2200      	moveq	r2, #0
 8006472:	2201      	movne	r2, #1
 8006474:	4213      	tst	r3, r2
 8006476:	f000 8369 	beq.w	8006b4c <_svfprintf_r+0xd5c>
 800647a:	9816      	ldr	r0, [sp, #88]	; 0x58
 800647c:	2330      	movs	r3, #48	; 0x30
 800647e:	9908      	ldr	r1, [sp, #32]
 8006480:	2201      	movs	r2, #1
 8006482:	f88d 310c 	strb.w	r3, [sp, #268]	; 0x10c
 8006486:	2302      	movs	r3, #2
 8006488:	f041 0102 	orr.w	r1, r1, #2
 800648c:	f88d 010d 	strb.w	r0, [sp, #269]	; 0x10d
 8006490:	9108      	str	r1, [sp, #32]
 8006492:	e7c1      	b.n	8006418 <_svfprintf_r+0x628>
 8006494:	9808      	ldr	r0, [sp, #32]
 8006496:	f040 0020 	orr.w	r0, r0, #32
 800649a:	9008      	str	r0, [sp, #32]
 800649c:	7813      	ldrb	r3, [r2, #0]
 800649e:	e514      	b.n	8005eca <_svfprintf_r+0xda>
 80064a0:	9209      	str	r2, [sp, #36]	; 0x24
 80064a2:	2100      	movs	r1, #0
 80064a4:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80064a6:	9316      	str	r3, [sp, #88]	; 0x58
 80064a8:	f88d 110f 	strb.w	r1, [sp, #271]	; 0x10f
 80064ac:	1d14      	adds	r4, r2, #4
 80064ae:	6813      	ldr	r3, [r2, #0]
 80064b0:	9313      	str	r3, [sp, #76]	; 0x4c
 80064b2:	2b00      	cmp	r3, #0
 80064b4:	f000 86f0 	beq.w	8007298 <_svfprintf_r+0x14a8>
 80064b8:	2f00      	cmp	r7, #0
 80064ba:	f2c0 8693 	blt.w	80071e4 <_svfprintf_r+0x13f4>
 80064be:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80064c0:	2100      	movs	r1, #0
 80064c2:	463a      	mov	r2, r7
 80064c4:	f002 f89c 	bl	8008600 <memchr>
 80064c8:	2800      	cmp	r0, #0
 80064ca:	f000 8736 	beq.w	800733a <_svfprintf_r+0x154a>
 80064ce:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80064d0:	1ac0      	subs	r0, r0, r3
 80064d2:	9010      	str	r0, [sp, #64]	; 0x40
 80064d4:	42b8      	cmp	r0, r7
 80064d6:	f340 84f4 	ble.w	8006ec2 <_svfprintf_r+0x10d2>
 80064da:	2000      	movs	r0, #0
 80064dc:	ea27 71e7 	bic.w	r1, r7, r7, asr #31
 80064e0:	9014      	str	r0, [sp, #80]	; 0x50
 80064e2:	910a      	str	r1, [sp, #40]	; 0x28
 80064e4:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 80064e8:	9412      	str	r4, [sp, #72]	; 0x48
 80064ea:	9710      	str	r7, [sp, #64]	; 0x40
 80064ec:	9018      	str	r0, [sp, #96]	; 0x60
 80064ee:	e60a      	b.n	8006106 <_svfprintf_r+0x316>
 80064f0:	7813      	ldrb	r3, [r2, #0]
 80064f2:	2b6c      	cmp	r3, #108	; 0x6c
 80064f4:	bf0b      	itete	eq
 80064f6:	9b08      	ldreq	r3, [sp, #32]
 80064f8:	9c08      	ldrne	r4, [sp, #32]
 80064fa:	f043 0320 	orreq.w	r3, r3, #32
 80064fe:	f044 0410 	orrne.w	r4, r4, #16
 8006502:	bf0a      	itet	eq
 8006504:	9308      	streq	r3, [sp, #32]
 8006506:	9408      	strne	r4, [sp, #32]
 8006508:	f812 3f01 	ldrbeq.w	r3, [r2, #1]!
 800650c:	e4dd      	b.n	8005eca <_svfprintf_r+0xda>
 800650e:	9209      	str	r2, [sp, #36]	; 0x24
 8006510:	9316      	str	r3, [sp, #88]	; 0x58
 8006512:	2b00      	cmp	r3, #0
 8006514:	f43f ad4c 	beq.w	8005fb0 <_svfprintf_r+0x1c0>
 8006518:	2200      	movs	r2, #0
 800651a:	2101      	movs	r1, #1
 800651c:	f88d 30bc 	strb.w	r3, [sp, #188]	; 0xbc
 8006520:	ac2f      	add	r4, sp, #188	; 0xbc
 8006522:	2300      	movs	r3, #0
 8006524:	910a      	str	r1, [sp, #40]	; 0x28
 8006526:	9110      	str	r1, [sp, #64]	; 0x40
 8006528:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
 800652c:	9214      	str	r2, [sp, #80]	; 0x50
 800652e:	9218      	str	r2, [sp, #96]	; 0x60
 8006530:	9413      	str	r4, [sp, #76]	; 0x4c
 8006532:	e5ec      	b.n	800610e <_svfprintf_r+0x31e>
 8006534:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
 8006538:	2b00      	cmp	r3, #0
 800653a:	f040 839b 	bne.w	8006c74 <_svfprintf_r+0xe84>
 800653e:	f88d 510f 	strb.w	r5, [sp, #271]	; 0x10f
 8006542:	7813      	ldrb	r3, [r2, #0]
 8006544:	e4c1      	b.n	8005eca <_svfprintf_r+0xda>
 8006546:	9808      	ldr	r0, [sp, #32]
 8006548:	f040 0001 	orr.w	r0, r0, #1
 800654c:	9008      	str	r0, [sp, #32]
 800654e:	7813      	ldrb	r3, [r2, #0]
 8006550:	e4bb      	b.n	8005eca <_svfprintf_r+0xda>
 8006552:	9316      	str	r3, [sp, #88]	; 0x58
 8006554:	9b08      	ldr	r3, [sp, #32]
 8006556:	9209      	str	r2, [sp, #36]	; 0x24
 8006558:	f013 0f20 	tst.w	r3, #32
 800655c:	f47f ad7f 	bne.w	800605e <_svfprintf_r+0x26e>
 8006560:	9908      	ldr	r1, [sp, #32]
 8006562:	f011 0f10 	tst.w	r1, #16
 8006566:	f000 83a3 	beq.w	8006cb0 <_svfprintf_r+0xec0>
 800656a:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800656c:	6814      	ldr	r4, [r2, #0]
 800656e:	3204      	adds	r2, #4
 8006570:	9212      	str	r2, [sp, #72]	; 0x48
 8006572:	17e5      	asrs	r5, r4, #31
 8006574:	e57c      	b.n	8006070 <_svfprintf_r+0x280>
 8006576:	9808      	ldr	r0, [sp, #32]
 8006578:	f040 0040 	orr.w	r0, r0, #64	; 0x40
 800657c:	9008      	str	r0, [sp, #32]
 800657e:	7813      	ldrb	r3, [r2, #0]
 8006580:	e4a3      	b.n	8005eca <_svfprintf_r+0xda>
 8006582:	9316      	str	r3, [sp, #88]	; 0x58
 8006584:	2101      	movs	r1, #1
 8006586:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006588:	2000      	movs	r0, #0
 800658a:	9209      	str	r2, [sp, #36]	; 0x24
 800658c:	2200      	movs	r2, #0
 800658e:	1d1c      	adds	r4, r3, #4
 8006590:	910a      	str	r1, [sp, #40]	; 0x28
 8006592:	681b      	ldr	r3, [r3, #0]
 8006594:	9412      	str	r4, [sp, #72]	; 0x48
 8006596:	9110      	str	r1, [sp, #64]	; 0x40
 8006598:	a92f      	add	r1, sp, #188	; 0xbc
 800659a:	f88d 010f 	strb.w	r0, [sp, #271]	; 0x10f
 800659e:	9214      	str	r2, [sp, #80]	; 0x50
 80065a0:	9218      	str	r2, [sp, #96]	; 0x60
 80065a2:	9113      	str	r1, [sp, #76]	; 0x4c
 80065a4:	f88d 30bc 	strb.w	r3, [sp, #188]	; 0xbc
 80065a8:	e5b1      	b.n	800610e <_svfprintf_r+0x31e>
 80065aa:	9209      	str	r2, [sp, #36]	; 0x24
 80065ac:	9a08      	ldr	r2, [sp, #32]
 80065ae:	9316      	str	r3, [sp, #88]	; 0x58
 80065b0:	f012 0320 	ands.w	r3, r2, #32
 80065b4:	f47f af21 	bne.w	80063fa <_svfprintf_r+0x60a>
 80065b8:	9908      	ldr	r1, [sp, #32]
 80065ba:	f011 0210 	ands.w	r2, r1, #16
 80065be:	f000 8391 	beq.w	8006ce4 <_svfprintf_r+0xef4>
 80065c2:	9c12      	ldr	r4, [sp, #72]	; 0x48
 80065c4:	6822      	ldr	r2, [r4, #0]
 80065c6:	3404      	adds	r4, #4
 80065c8:	2500      	movs	r5, #0
 80065ca:	9412      	str	r4, [sp, #72]	; 0x48
 80065cc:	4614      	mov	r4, r2
 80065ce:	3a00      	subs	r2, #0
 80065d0:	bf18      	it	ne
 80065d2:	2201      	movne	r2, #1
 80065d4:	e720      	b.n	8006418 <_svfprintf_r+0x628>
 80065d6:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80065d8:	2178      	movs	r1, #120	; 0x78
 80065da:	9c08      	ldr	r4, [sp, #32]
 80065dc:	2500      	movs	r5, #0
 80065de:	9209      	str	r2, [sp, #36]	; 0x24
 80065e0:	f64b 3068 	movw	r0, #47976	; 0xbb68
 80065e4:	681a      	ldr	r2, [r3, #0]
 80065e6:	f044 0402 	orr.w	r4, r4, #2
 80065ea:	3304      	adds	r3, #4
 80065ec:	9408      	str	r4, [sp, #32]
 80065ee:	9312      	str	r3, [sp, #72]	; 0x48
 80065f0:	4614      	mov	r4, r2
 80065f2:	2330      	movs	r3, #48	; 0x30
 80065f4:	3a00      	subs	r2, #0
 80065f6:	f88d 310c 	strb.w	r3, [sp, #268]	; 0x10c
 80065fa:	bf18      	it	ne
 80065fc:	2201      	movne	r2, #1
 80065fe:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006602:	f88d 110d 	strb.w	r1, [sp, #269]	; 0x10d
 8006606:	9017      	str	r0, [sp, #92]	; 0x5c
 8006608:	2302      	movs	r3, #2
 800660a:	9116      	str	r1, [sp, #88]	; 0x58
 800660c:	e704      	b.n	8006418 <_svfprintf_r+0x628>
 800660e:	9209      	str	r2, [sp, #36]	; 0x24
 8006610:	9a08      	ldr	r2, [sp, #32]
 8006612:	f012 0f20 	tst.w	r2, #32
 8006616:	f000 8358 	beq.w	8006cca <_svfprintf_r+0xeda>
 800661a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800661c:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 800661e:	9812      	ldr	r0, [sp, #72]	; 0x48
 8006620:	6819      	ldr	r1, [r3, #0]
 8006622:	4622      	mov	r2, r4
 8006624:	17e3      	asrs	r3, r4, #31
 8006626:	3004      	adds	r0, #4
 8006628:	9012      	str	r0, [sp, #72]	; 0x48
 800662a:	e9c1 2300 	strd	r2, r3, [r1]
 800662e:	e408      	b.n	8005e42 <_svfprintf_r+0x52>
 8006630:	9808      	ldr	r0, [sp, #32]
 8006632:	9209      	str	r2, [sp, #36]	; 0x24
 8006634:	f010 0f20 	tst.w	r0, #32
 8006638:	9316      	str	r3, [sp, #88]	; 0x58
 800663a:	f47f aefc 	bne.w	8006436 <_svfprintf_r+0x646>
 800663e:	9908      	ldr	r1, [sp, #32]
 8006640:	f011 0f10 	tst.w	r1, #16
 8006644:	f040 8291 	bne.w	8006b6a <_svfprintf_r+0xd7a>
 8006648:	9808      	ldr	r0, [sp, #32]
 800664a:	f010 0f40 	tst.w	r0, #64	; 0x40
 800664e:	f000 828c 	beq.w	8006b6a <_svfprintf_r+0xd7a>
 8006652:	9912      	ldr	r1, [sp, #72]	; 0x48
 8006654:	2301      	movs	r3, #1
 8006656:	2500      	movs	r5, #0
 8006658:	880a      	ldrh	r2, [r1, #0]
 800665a:	3104      	adds	r1, #4
 800665c:	9112      	str	r1, [sp, #72]	; 0x48
 800665e:	4614      	mov	r4, r2
 8006660:	3a00      	subs	r2, #0
 8006662:	bf18      	it	ne
 8006664:	2201      	movne	r2, #1
 8006666:	e6d7      	b.n	8006418 <_svfprintf_r+0x628>
 8006668:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800666a:	9c12      	ldr	r4, [sp, #72]	; 0x48
 800666c:	681b      	ldr	r3, [r3, #0]
 800666e:	1d20      	adds	r0, r4, #4
 8006670:	2b00      	cmp	r3, #0
 8006672:	930d      	str	r3, [sp, #52]	; 0x34
 8006674:	f6ff ac8a 	blt.w	8005f8c <_svfprintf_r+0x19c>
 8006678:	7813      	ldrb	r3, [r2, #0]
 800667a:	9012      	str	r0, [sp, #72]	; 0x48
 800667c:	e425      	b.n	8005eca <_svfprintf_r+0xda>
 800667e:	9209      	str	r2, [sp, #36]	; 0x24
 8006680:	f64b 3068 	movw	r0, #47976	; 0xbb68
 8006684:	9a08      	ldr	r2, [sp, #32]
 8006686:	f6c0 0000 	movt	r0, #2048	; 0x800
 800668a:	9316      	str	r3, [sp, #88]	; 0x58
 800668c:	f012 0f20 	tst.w	r2, #32
 8006690:	9017      	str	r0, [sp, #92]	; 0x5c
 8006692:	f47f aee0 	bne.w	8006456 <_svfprintf_r+0x666>
 8006696:	9908      	ldr	r1, [sp, #32]
 8006698:	f011 0f10 	tst.w	r1, #16
 800669c:	f000 82fa 	beq.w	8006c94 <_svfprintf_r+0xea4>
 80066a0:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80066a2:	2500      	movs	r5, #0
 80066a4:	6814      	ldr	r4, [r2, #0]
 80066a6:	3204      	adds	r2, #4
 80066a8:	9212      	str	r2, [sp, #72]	; 0x48
 80066aa:	e6dd      	b.n	8006468 <_svfprintf_r+0x678>
 80066ac:	9811      	ldr	r0, [sp, #68]	; 0x44
 80066ae:	aa39      	add	r2, sp, #228	; 0xe4
 80066b0:	990c      	ldr	r1, [sp, #48]	; 0x30
 80066b2:	f002 fe3b 	bl	800932c <__ssprint_r>
 80066b6:	2800      	cmp	r0, #0
 80066b8:	f47f ac81 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 80066bc:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 80066c0:	4656      	mov	r6, sl
 80066c2:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80066c4:	e577      	b.n	80061b6 <_svfprintf_r+0x3c6>
 80066c6:	9a08      	ldr	r2, [sp, #32]
 80066c8:	f012 0f01 	tst.w	r2, #1
 80066cc:	f040 80fd 	bne.w	80068ca <_svfprintf_r+0xada>
 80066d0:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80066d2:	3501      	adds	r5, #1
 80066d4:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80066d6:	2301      	movs	r3, #1
 80066d8:	3401      	adds	r4, #1
 80066da:	f8c9 3004 	str.w	r3, [r9, #4]
 80066de:	2c07      	cmp	r4, #7
 80066e0:	f8c9 2000 	str.w	r2, [r9]
 80066e4:	953b      	str	r5, [sp, #236]	; 0xec
 80066e6:	943a      	str	r4, [sp, #232]	; 0xe8
 80066e8:	f300 851f 	bgt.w	800712a <_svfprintf_r+0x133a>
 80066ec:	f109 0b08 	add.w	fp, r9, #8
 80066f0:	f10b 0908 	add.w	r9, fp, #8
 80066f4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80066f6:	3401      	adds	r4, #1
 80066f8:	2c07      	cmp	r4, #7
 80066fa:	441d      	add	r5, r3
 80066fc:	f8cb 3004 	str.w	r3, [fp, #4]
 8006700:	ab3e      	add	r3, sp, #248	; 0xf8
 8006702:	f8cb 3000 	str.w	r3, [fp]
 8006706:	953b      	str	r5, [sp, #236]	; 0xec
 8006708:	943a      	str	r4, [sp, #232]	; 0xe8
 800670a:	f77f adcd 	ble.w	80062a8 <_svfprintf_r+0x4b8>
 800670e:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006710:	aa39      	add	r2, sp, #228	; 0xe4
 8006712:	990c      	ldr	r1, [sp, #48]	; 0x30
 8006714:	f002 fe0a 	bl	800932c <__ssprint_r>
 8006718:	2800      	cmp	r0, #0
 800671a:	f47f ac50 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 800671e:	46d1      	mov	r9, sl
 8006720:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006722:	e5c1      	b.n	80062a8 <_svfprintf_r+0x4b8>
 8006724:	9916      	ldr	r1, [sp, #88]	; 0x58
 8006726:	2965      	cmp	r1, #101	; 0x65
 8006728:	f340 80cb 	ble.w	80068c2 <_svfprintf_r+0xad2>
 800672c:	981a      	ldr	r0, [sp, #104]	; 0x68
 800672e:	2200      	movs	r2, #0
 8006730:	2300      	movs	r3, #0
 8006732:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8006734:	f004 fbe2 	bl	800aefc <__aeabi_dcmpeq>
 8006738:	2800      	cmp	r0, #0
 800673a:	f000 813e 	beq.w	80069ba <_svfprintf_r+0xbca>
 800673e:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006740:	f64b 3384 	movw	r3, #48004	; 0xbb84
 8006744:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006748:	f8c9 3000 	str.w	r3, [r9]
 800674c:	3401      	adds	r4, #1
 800674e:	2301      	movs	r3, #1
 8006750:	2c07      	cmp	r4, #7
 8006752:	f8c9 3004 	str.w	r3, [r9, #4]
 8006756:	441d      	add	r5, r3
 8006758:	943a      	str	r4, [sp, #232]	; 0xe8
 800675a:	953b      	str	r5, [sp, #236]	; 0xec
 800675c:	bfd8      	it	le
 800675e:	f109 0908 	addle.w	r9, r9, #8
 8006762:	f300 8346 	bgt.w	8006df2 <_svfprintf_r+0x1002>
 8006766:	9b42      	ldr	r3, [sp, #264]	; 0x108
 8006768:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800676a:	4293      	cmp	r3, r2
 800676c:	db04      	blt.n	8006778 <_svfprintf_r+0x988>
 800676e:	9b08      	ldr	r3, [sp, #32]
 8006770:	f013 0f01 	tst.w	r3, #1
 8006774:	f43f ad98 	beq.w	80062a8 <_svfprintf_r+0x4b8>
 8006778:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 800677a:	981c      	ldr	r0, [sp, #112]	; 0x70
 800677c:	3401      	adds	r4, #1
 800677e:	9919      	ldr	r1, [sp, #100]	; 0x64
 8006780:	2c07      	cmp	r4, #7
 8006782:	4405      	add	r5, r0
 8006784:	f8c9 0004 	str.w	r0, [r9, #4]
 8006788:	bfd8      	it	le
 800678a:	f109 0308 	addle.w	r3, r9, #8
 800678e:	f8c9 1000 	str.w	r1, [r9]
 8006792:	953b      	str	r5, [sp, #236]	; 0xec
 8006794:	943a      	str	r4, [sp, #232]	; 0xe8
 8006796:	f300 83bc 	bgt.w	8006f12 <_svfprintf_r+0x1122>
 800679a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800679c:	1e56      	subs	r6, r2, #1
 800679e:	2e00      	cmp	r6, #0
 80067a0:	f340 831d 	ble.w	8006dde <_svfprintf_r+0xfee>
 80067a4:	2e10      	cmp	r6, #16
 80067a6:	f340 85e8 	ble.w	800737a <_svfprintf_r+0x158a>
 80067aa:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80067ac:	2710      	movs	r7, #16
 80067ae:	f8df 84fc 	ldr.w	r8, [pc, #1276]	; 8006cac <_svfprintf_r+0xebc>
 80067b2:	4622      	mov	r2, r4
 80067b4:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 80067b8:	4644      	mov	r4, r8
 80067ba:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 80067be:	e003      	b.n	80067c8 <_svfprintf_r+0x9d8>
 80067c0:	3e10      	subs	r6, #16
 80067c2:	2e10      	cmp	r6, #16
 80067c4:	f340 81c4 	ble.w	8006b50 <_svfprintf_r+0xd60>
 80067c8:	3201      	adds	r2, #1
 80067ca:	601c      	str	r4, [r3, #0]
 80067cc:	605f      	str	r7, [r3, #4]
 80067ce:	3510      	adds	r5, #16
 80067d0:	3308      	adds	r3, #8
 80067d2:	2a07      	cmp	r2, #7
 80067d4:	923a      	str	r2, [sp, #232]	; 0xe8
 80067d6:	f103 0908 	add.w	r9, r3, #8
 80067da:	953b      	str	r5, [sp, #236]	; 0xec
 80067dc:	ddf0      	ble.n	80067c0 <_svfprintf_r+0x9d0>
 80067de:	4640      	mov	r0, r8
 80067e0:	4659      	mov	r1, fp
 80067e2:	aa39      	add	r2, sp, #228	; 0xe4
 80067e4:	f10a 0908 	add.w	r9, sl, #8
 80067e8:	f002 fda0 	bl	800932c <__ssprint_r>
 80067ec:	4653      	mov	r3, sl
 80067ee:	2800      	cmp	r0, #0
 80067f0:	f47f abe5 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 80067f4:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80067f6:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 80067f8:	e7e2      	b.n	80067c0 <_svfprintf_r+0x9d0>
 80067fa:	2b00      	cmp	r3, #0
 80067fc:	f040 80b7 	bne.w	800696e <_svfprintf_r+0xb7e>
 8006800:	9c08      	ldr	r4, [sp, #32]
 8006802:	f014 0f01 	tst.w	r4, #1
 8006806:	f000 812b 	beq.w	8006a60 <_svfprintf_r+0xc70>
 800680a:	2001      	movs	r0, #1
 800680c:	2330      	movs	r3, #48	; 0x30
 800680e:	f10d 01e3 	add.w	r1, sp, #227	; 0xe3
 8006812:	9010      	str	r0, [sp, #64]	; 0x40
 8006814:	f88d 30e3 	strb.w	r3, [sp, #227]	; 0xe3
 8006818:	9113      	str	r1, [sp, #76]	; 0x4c
 800681a:	e46a      	b.n	80060f2 <_svfprintf_r+0x302>
 800681c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800681e:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8006820:	1b1f      	subs	r7, r3, r4
 8006822:	2f00      	cmp	r7, #0
 8006824:	f77f acea 	ble.w	80061fc <_svfprintf_r+0x40c>
 8006828:	2f10      	cmp	r7, #16
 800682a:	f340 8569 	ble.w	8007300 <_svfprintf_r+0x1510>
 800682e:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006830:	4633      	mov	r3, r6
 8006832:	f8df 8478 	ldr.w	r8, [pc, #1144]	; 8006cac <_svfprintf_r+0xebc>
 8006836:	f04f 0910 	mov.w	r9, #16
 800683a:	4622      	mov	r2, r4
 800683c:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 8006840:	4644      	mov	r4, r8
 8006842:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8006846:	e002      	b.n	800684e <_svfprintf_r+0xa5e>
 8006848:	3f10      	subs	r7, #16
 800684a:	2f10      	cmp	r7, #16
 800684c:	dd1b      	ble.n	8006886 <_svfprintf_r+0xa96>
 800684e:	3201      	adds	r2, #1
 8006850:	601c      	str	r4, [r3, #0]
 8006852:	f8c3 9004 	str.w	r9, [r3, #4]
 8006856:	3510      	adds	r5, #16
 8006858:	3308      	adds	r3, #8
 800685a:	2a07      	cmp	r2, #7
 800685c:	923a      	str	r2, [sp, #232]	; 0xe8
 800685e:	f103 0608 	add.w	r6, r3, #8
 8006862:	953b      	str	r5, [sp, #236]	; 0xec
 8006864:	ddf0      	ble.n	8006848 <_svfprintf_r+0xa58>
 8006866:	4640      	mov	r0, r8
 8006868:	4659      	mov	r1, fp
 800686a:	aa39      	add	r2, sp, #228	; 0xe4
 800686c:	f10a 0608 	add.w	r6, sl, #8
 8006870:	f002 fd5c 	bl	800932c <__ssprint_r>
 8006874:	4653      	mov	r3, sl
 8006876:	2800      	cmp	r0, #0
 8006878:	f47f aba1 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 800687c:	3f10      	subs	r7, #16
 800687e:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006880:	2f10      	cmp	r7, #16
 8006882:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 8006884:	dce3      	bgt.n	800684e <_svfprintf_r+0xa5e>
 8006886:	46a0      	mov	r8, r4
 8006888:	4614      	mov	r4, r2
 800688a:	3401      	adds	r4, #1
 800688c:	f8c3 8000 	str.w	r8, [r3]
 8006890:	2c07      	cmp	r4, #7
 8006892:	605f      	str	r7, [r3, #4]
 8006894:	443d      	add	r5, r7
 8006896:	943a      	str	r4, [sp, #232]	; 0xe8
 8006898:	953b      	str	r5, [sp, #236]	; 0xec
 800689a:	f77f acaf 	ble.w	80061fc <_svfprintf_r+0x40c>
 800689e:	9811      	ldr	r0, [sp, #68]	; 0x44
 80068a0:	aa39      	add	r2, sp, #228	; 0xe4
 80068a2:	990c      	ldr	r1, [sp, #48]	; 0x30
 80068a4:	f002 fd42 	bl	800932c <__ssprint_r>
 80068a8:	2800      	cmp	r0, #0
 80068aa:	f47f ab88 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 80068ae:	9914      	ldr	r1, [sp, #80]	; 0x50
 80068b0:	4656      	mov	r6, sl
 80068b2:	9810      	ldr	r0, [sp, #64]	; 0x40
 80068b4:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80068b6:	1a0f      	subs	r7, r1, r0
 80068b8:	2f00      	cmp	r7, #0
 80068ba:	f73f aca5 	bgt.w	8006208 <_svfprintf_r+0x418>
 80068be:	46b1      	mov	r9, r6
 80068c0:	e4dd      	b.n	800627e <_svfprintf_r+0x48e>
 80068c2:	990e      	ldr	r1, [sp, #56]	; 0x38
 80068c4:	2901      	cmp	r1, #1
 80068c6:	f77f aefe 	ble.w	80066c6 <_svfprintf_r+0x8d6>
 80068ca:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80068cc:	3501      	adds	r5, #1
 80068ce:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80068d0:	3401      	adds	r4, #1
 80068d2:	f8c9 3000 	str.w	r3, [r9]
 80068d6:	2301      	movs	r3, #1
 80068d8:	2c07      	cmp	r4, #7
 80068da:	f8c9 3004 	str.w	r3, [r9, #4]
 80068de:	bfd8      	it	le
 80068e0:	f109 0908 	addle.w	r9, r9, #8
 80068e4:	953b      	str	r5, [sp, #236]	; 0xec
 80068e6:	943a      	str	r4, [sp, #232]	; 0xe8
 80068e8:	bfd8      	it	le
 80068ea:	f109 0608 	addle.w	r6, r9, #8
 80068ee:	f300 8141 	bgt.w	8006b74 <_svfprintf_r+0xd84>
 80068f2:	3401      	adds	r4, #1
 80068f4:	991c      	ldr	r1, [sp, #112]	; 0x70
 80068f6:	9819      	ldr	r0, [sp, #100]	; 0x64
 80068f8:	2c07      	cmp	r4, #7
 80068fa:	440d      	add	r5, r1
 80068fc:	bfd8      	it	le
 80068fe:	f106 0b08 	addle.w	fp, r6, #8
 8006902:	f8c9 1004 	str.w	r1, [r9, #4]
 8006906:	f8c9 0000 	str.w	r0, [r9]
 800690a:	943a      	str	r4, [sp, #232]	; 0xe8
 800690c:	953b      	str	r5, [sp, #236]	; 0xec
 800690e:	f300 813f 	bgt.w	8006b90 <_svfprintf_r+0xda0>
 8006912:	981a      	ldr	r0, [sp, #104]	; 0x68
 8006914:	2200      	movs	r2, #0
 8006916:	2300      	movs	r3, #0
 8006918:	991b      	ldr	r1, [sp, #108]	; 0x6c
 800691a:	f004 faef 	bl	800aefc <__aeabi_dcmpeq>
 800691e:	2800      	cmp	r0, #0
 8006920:	f040 80ce 	bne.w	8006ac0 <_svfprintf_r+0xcd0>
 8006924:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8006926:	3401      	adds	r4, #1
 8006928:	9813      	ldr	r0, [sp, #76]	; 0x4c
 800692a:	1e5a      	subs	r2, r3, #1
 800692c:	6072      	str	r2, [r6, #4]
 800692e:	1c43      	adds	r3, r0, #1
 8006930:	2c07      	cmp	r4, #7
 8006932:	6033      	str	r3, [r6, #0]
 8006934:	4415      	add	r5, r2
 8006936:	943a      	str	r4, [sp, #232]	; 0xe8
 8006938:	953b      	str	r5, [sp, #236]	; 0xec
 800693a:	f77f aed9 	ble.w	80066f0 <_svfprintf_r+0x900>
 800693e:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006940:	aa39      	add	r2, sp, #228	; 0xe4
 8006942:	990c      	ldr	r1, [sp, #48]	; 0x30
 8006944:	f002 fcf2 	bl	800932c <__ssprint_r>
 8006948:	2800      	cmp	r0, #0
 800694a:	f47f ab38 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 800694e:	f10a 0908 	add.w	r9, sl, #8
 8006952:	46d3      	mov	fp, sl
 8006954:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006956:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006958:	e6cc      	b.n	80066f4 <_svfprintf_r+0x904>
 800695a:	9811      	ldr	r0, [sp, #68]	; 0x44
 800695c:	aa39      	add	r2, sp, #228	; 0xe4
 800695e:	990c      	ldr	r1, [sp, #48]	; 0x30
 8006960:	f002 fce4 	bl	800932c <__ssprint_r>
 8006964:	2800      	cmp	r0, #0
 8006966:	f43f acf5 	beq.w	8006354 <_svfprintf_r+0x564>
 800696a:	f7ff bb28 	b.w	8005fbe <_svfprintf_r+0x1ce>
 800696e:	9210      	str	r2, [sp, #64]	; 0x40
 8006970:	aa39      	add	r2, sp, #228	; 0xe4
 8006972:	9213      	str	r2, [sp, #76]	; 0x4c
 8006974:	f7ff bbbd 	b.w	80060f2 <_svfprintf_r+0x302>
 8006978:	9811      	ldr	r0, [sp, #68]	; 0x44
 800697a:	aa39      	add	r2, sp, #228	; 0xe4
 800697c:	990c      	ldr	r1, [sp, #48]	; 0x30
 800697e:	f002 fcd5 	bl	800932c <__ssprint_r>
 8006982:	2800      	cmp	r0, #0
 8006984:	f47f ab1b 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 8006988:	46d1      	mov	r9, sl
 800698a:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800698c:	e477      	b.n	800627e <_svfprintf_r+0x48e>
 800698e:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006990:	aa39      	add	r2, sp, #228	; 0xe4
 8006992:	990c      	ldr	r1, [sp, #48]	; 0x30
 8006994:	f002 fcca 	bl	800932c <__ssprint_r>
 8006998:	2800      	cmp	r0, #0
 800699a:	f47f ab10 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 800699e:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80069a0:	4656      	mov	r6, sl
 80069a2:	e427      	b.n	80061f4 <_svfprintf_r+0x404>
 80069a4:	9811      	ldr	r0, [sp, #68]	; 0x44
 80069a6:	aa39      	add	r2, sp, #228	; 0xe4
 80069a8:	990c      	ldr	r1, [sp, #48]	; 0x30
 80069aa:	f002 fcbf 	bl	800932c <__ssprint_r>
 80069ae:	2800      	cmp	r0, #0
 80069b0:	f47f ab05 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 80069b4:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80069b6:	4656      	mov	r6, sl
 80069b8:	e40c      	b.n	80061d4 <_svfprintf_r+0x3e4>
 80069ba:	9e42      	ldr	r6, [sp, #264]	; 0x108
 80069bc:	2e00      	cmp	r6, #0
 80069be:	f340 8223 	ble.w	8006e08 <_svfprintf_r+0x1018>
 80069c2:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 80069c4:	9c18      	ldr	r4, [sp, #96]	; 0x60
 80069c6:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80069c8:	42a6      	cmp	r6, r4
 80069ca:	bfa8      	it	ge
 80069cc:	4626      	movge	r6, r4
 80069ce:	990e      	ldr	r1, [sp, #56]	; 0x38
 80069d0:	2e00      	cmp	r6, #0
 80069d2:	eb00 0b01 	add.w	fp, r0, r1
 80069d6:	dd0e      	ble.n	80069f6 <_svfprintf_r+0xc06>
 80069d8:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80069da:	19ad      	adds	r5, r5, r6
 80069dc:	f8c9 0000 	str.w	r0, [r9]
 80069e0:	3401      	adds	r4, #1
 80069e2:	f8c9 6004 	str.w	r6, [r9, #4]
 80069e6:	2c07      	cmp	r4, #7
 80069e8:	953b      	str	r5, [sp, #236]	; 0xec
 80069ea:	943a      	str	r4, [sp, #232]	; 0xe8
 80069ec:	bfd8      	it	le
 80069ee:	f109 0908 	addle.w	r9, r9, #8
 80069f2:	f300 8411 	bgt.w	8007218 <_svfprintf_r+0x1428>
 80069f6:	9a18      	ldr	r2, [sp, #96]	; 0x60
 80069f8:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
 80069fc:	1b96      	subs	r6, r2, r6
 80069fe:	2e00      	cmp	r6, #0
 8006a00:	f340 83e9 	ble.w	80071d6 <_svfprintf_r+0x13e6>
 8006a04:	2e10      	cmp	r6, #16
 8006a06:	f340 84e1 	ble.w	80073cc <_svfprintf_r+0x15dc>
 8006a0a:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006a0c:	4629      	mov	r1, r5
 8006a0e:	f8df 829c 	ldr.w	r8, [pc, #668]	; 8006cac <_svfprintf_r+0xebc>
 8006a12:	2710      	movs	r7, #16
 8006a14:	4622      	mov	r2, r4
 8006a16:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8006a18:	4644      	mov	r4, r8
 8006a1a:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8006a1e:	e003      	b.n	8006a28 <_svfprintf_r+0xc38>
 8006a20:	3e10      	subs	r6, #16
 8006a22:	2e10      	cmp	r6, #16
 8006a24:	f340 8170 	ble.w	8006d08 <_svfprintf_r+0xf18>
 8006a28:	3201      	adds	r2, #1
 8006a2a:	3110      	adds	r1, #16
 8006a2c:	2a07      	cmp	r2, #7
 8006a2e:	f8c9 4000 	str.w	r4, [r9]
 8006a32:	f8c9 7004 	str.w	r7, [r9, #4]
 8006a36:	f109 0908 	add.w	r9, r9, #8
 8006a3a:	923a      	str	r2, [sp, #232]	; 0xe8
 8006a3c:	f109 0308 	add.w	r3, r9, #8
 8006a40:	913b      	str	r1, [sp, #236]	; 0xec
 8006a42:	dded      	ble.n	8006a20 <_svfprintf_r+0xc30>
 8006a44:	4640      	mov	r0, r8
 8006a46:	4629      	mov	r1, r5
 8006a48:	aa39      	add	r2, sp, #228	; 0xe4
 8006a4a:	46d1      	mov	r9, sl
 8006a4c:	f002 fc6e 	bl	800932c <__ssprint_r>
 8006a50:	f10a 0308 	add.w	r3, sl, #8
 8006a54:	2800      	cmp	r0, #0
 8006a56:	f47f aab2 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 8006a5a:	993b      	ldr	r1, [sp, #236]	; 0xec
 8006a5c:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 8006a5e:	e7df      	b.n	8006a20 <_svfprintf_r+0xc30>
 8006a60:	9310      	str	r3, [sp, #64]	; 0x40
 8006a62:	ab39      	add	r3, sp, #228	; 0xe4
 8006a64:	9313      	str	r3, [sp, #76]	; 0x4c
 8006a66:	f7ff bb44 	b.w	80060f2 <_svfprintf_r+0x302>
 8006a6a:	f10d 0bbc 	add.w	fp, sp, #188	; 0xbc
 8006a6e:	9917      	ldr	r1, [sp, #92]	; 0x5c
 8006a70:	f10b 0027 	add.w	r0, fp, #39	; 0x27
 8006a74:	f004 020f 	and.w	r2, r4, #15
 8006a78:	0923      	lsrs	r3, r4, #4
 8006a7a:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 8006a7e:	ea4f 1c15 	mov.w	ip, r5, lsr #4
 8006a82:	5c8a      	ldrb	r2, [r1, r2]
 8006a84:	461c      	mov	r4, r3
 8006a86:	4603      	mov	r3, r0
 8006a88:	4665      	mov	r5, ip
 8006a8a:	3801      	subs	r0, #1
 8006a8c:	701a      	strb	r2, [r3, #0]
 8006a8e:	ea54 0205 	orrs.w	r2, r4, r5
 8006a92:	d1ef      	bne.n	8006a74 <_svfprintf_r+0xc84>
 8006a94:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8006a98:	9313      	str	r3, [sp, #76]	; 0x4c
 8006a9a:	ebc3 030b 	rsb	r3, r3, fp
 8006a9e:	9310      	str	r3, [sp, #64]	; 0x40
 8006aa0:	f7ff bb27 	b.w	80060f2 <_svfprintf_r+0x302>
 8006aa4:	2c0a      	cmp	r4, #10
 8006aa6:	f175 0100 	sbcs.w	r1, r5, #0
 8006aaa:	d27f      	bcs.n	8006bac <_svfprintf_r+0xdbc>
 8006aac:	3430      	adds	r4, #48	; 0x30
 8006aae:	2201      	movs	r2, #1
 8006ab0:	f10d 03e3 	add.w	r3, sp, #227	; 0xe3
 8006ab4:	9210      	str	r2, [sp, #64]	; 0x40
 8006ab6:	f88d 40e3 	strb.w	r4, [sp, #227]	; 0xe3
 8006aba:	9313      	str	r3, [sp, #76]	; 0x4c
 8006abc:	f7ff bb19 	b.w	80060f2 <_svfprintf_r+0x302>
 8006ac0:	990e      	ldr	r1, [sp, #56]	; 0x38
 8006ac2:	1e4f      	subs	r7, r1, #1
 8006ac4:	2f00      	cmp	r7, #0
 8006ac6:	bfdc      	itt	le
 8006ac8:	f106 0908 	addle.w	r9, r6, #8
 8006acc:	46b3      	movle	fp, r6
 8006ace:	f77f ae11 	ble.w	80066f4 <_svfprintf_r+0x904>
 8006ad2:	2f10      	cmp	r7, #16
 8006ad4:	bfd8      	it	le
 8006ad6:	f8df 81d4 	ldrle.w	r8, [pc, #468]	; 8006cac <_svfprintf_r+0xebc>
 8006ada:	dd2c      	ble.n	8006b36 <_svfprintf_r+0xd46>
 8006adc:	f8df 81cc 	ldr.w	r8, [pc, #460]	; 8006cac <_svfprintf_r+0xebc>
 8006ae0:	4623      	mov	r3, r4
 8006ae2:	462a      	mov	r2, r5
 8006ae4:	f04f 0910 	mov.w	r9, #16
 8006ae8:	4644      	mov	r4, r8
 8006aea:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8006aec:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8006af0:	e002      	b.n	8006af8 <_svfprintf_r+0xd08>
 8006af2:	3f10      	subs	r7, #16
 8006af4:	2f10      	cmp	r7, #16
 8006af6:	dd1b      	ble.n	8006b30 <_svfprintf_r+0xd40>
 8006af8:	3301      	adds	r3, #1
 8006afa:	6034      	str	r4, [r6, #0]
 8006afc:	f8c6 9004 	str.w	r9, [r6, #4]
 8006b00:	3210      	adds	r2, #16
 8006b02:	3608      	adds	r6, #8
 8006b04:	2b07      	cmp	r3, #7
 8006b06:	933a      	str	r3, [sp, #232]	; 0xe8
 8006b08:	f106 0b08 	add.w	fp, r6, #8
 8006b0c:	923b      	str	r2, [sp, #236]	; 0xec
 8006b0e:	ddf0      	ble.n	8006af2 <_svfprintf_r+0xd02>
 8006b10:	4640      	mov	r0, r8
 8006b12:	4629      	mov	r1, r5
 8006b14:	aa39      	add	r2, sp, #228	; 0xe4
 8006b16:	f10a 0b08 	add.w	fp, sl, #8
 8006b1a:	f002 fc07 	bl	800932c <__ssprint_r>
 8006b1e:	4656      	mov	r6, sl
 8006b20:	2800      	cmp	r0, #0
 8006b22:	f47f aa4c 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 8006b26:	3f10      	subs	r7, #16
 8006b28:	9a3b      	ldr	r2, [sp, #236]	; 0xec
 8006b2a:	2f10      	cmp	r7, #16
 8006b2c:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 8006b2e:	dce3      	bgt.n	8006af8 <_svfprintf_r+0xd08>
 8006b30:	46a0      	mov	r8, r4
 8006b32:	4615      	mov	r5, r2
 8006b34:	461c      	mov	r4, r3
 8006b36:	3401      	adds	r4, #1
 8006b38:	f8c6 8000 	str.w	r8, [r6]
 8006b3c:	2c07      	cmp	r4, #7
 8006b3e:	6077      	str	r7, [r6, #4]
 8006b40:	443d      	add	r5, r7
 8006b42:	943a      	str	r4, [sp, #232]	; 0xe8
 8006b44:	953b      	str	r5, [sp, #236]	; 0xec
 8006b46:	f77f add3 	ble.w	80066f0 <_svfprintf_r+0x900>
 8006b4a:	e6f8      	b.n	800693e <_svfprintf_r+0xb4e>
 8006b4c:	2302      	movs	r3, #2
 8006b4e:	e463      	b.n	8006418 <_svfprintf_r+0x628>
 8006b50:	46a0      	mov	r8, r4
 8006b52:	4614      	mov	r4, r2
 8006b54:	3401      	adds	r4, #1
 8006b56:	f8c3 8000 	str.w	r8, [r3]
 8006b5a:	2c07      	cmp	r4, #7
 8006b5c:	605e      	str	r6, [r3, #4]
 8006b5e:	4435      	add	r5, r6
 8006b60:	943a      	str	r4, [sp, #232]	; 0xe8
 8006b62:	953b      	str	r5, [sp, #236]	; 0xec
 8006b64:	f77f aba0 	ble.w	80062a8 <_svfprintf_r+0x4b8>
 8006b68:	e5d1      	b.n	800670e <_svfprintf_r+0x91e>
 8006b6a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006b6c:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8006b6e:	681a      	ldr	r2, [r3, #0]
 8006b70:	2301      	movs	r3, #1
 8006b72:	e528      	b.n	80065c6 <_svfprintf_r+0x7d6>
 8006b74:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006b76:	aa39      	add	r2, sp, #228	; 0xe4
 8006b78:	990c      	ldr	r1, [sp, #48]	; 0x30
 8006b7a:	f002 fbd7 	bl	800932c <__ssprint_r>
 8006b7e:	2800      	cmp	r0, #0
 8006b80:	f47f aa1d 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 8006b84:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006b86:	f10a 0608 	add.w	r6, sl, #8
 8006b8a:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006b8c:	46d1      	mov	r9, sl
 8006b8e:	e6b0      	b.n	80068f2 <_svfprintf_r+0xb02>
 8006b90:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006b92:	aa39      	add	r2, sp, #228	; 0xe4
 8006b94:	990c      	ldr	r1, [sp, #48]	; 0x30
 8006b96:	f002 fbc9 	bl	800932c <__ssprint_r>
 8006b9a:	2800      	cmp	r0, #0
 8006b9c:	f47f aa0f 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 8006ba0:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006ba2:	f10a 0b08 	add.w	fp, sl, #8
 8006ba6:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006ba8:	4656      	mov	r6, sl
 8006baa:	e6b2      	b.n	8006912 <_svfprintf_r+0xb22>
 8006bac:	f10d 0bbc 	add.w	fp, sp, #188	; 0xbc
 8006bb0:	46b1      	mov	r9, r6
 8006bb2:	f10b 0827 	add.w	r8, fp, #39	; 0x27
 8006bb6:	4620      	mov	r0, r4
 8006bb8:	4629      	mov	r1, r5
 8006bba:	220a      	movs	r2, #10
 8006bbc:	2300      	movs	r3, #0
 8006bbe:	f004 f9f7 	bl	800afb0 <__aeabi_uldivmod>
 8006bc2:	4646      	mov	r6, r8
 8006bc4:	4620      	mov	r0, r4
 8006bc6:	4629      	mov	r1, r5
 8006bc8:	2300      	movs	r3, #0
 8006bca:	f108 38ff 	add.w	r8, r8, #4294967295
 8006bce:	f102 0430 	add.w	r4, r2, #48	; 0x30
 8006bd2:	220a      	movs	r2, #10
 8006bd4:	7034      	strb	r4, [r6, #0]
 8006bd6:	f004 f9eb 	bl	800afb0 <__aeabi_uldivmod>
 8006bda:	4604      	mov	r4, r0
 8006bdc:	460d      	mov	r5, r1
 8006bde:	ea54 0005 	orrs.w	r0, r4, r5
 8006be2:	d1e8      	bne.n	8006bb6 <_svfprintf_r+0xdc6>
 8006be4:	9613      	str	r6, [sp, #76]	; 0x4c
 8006be6:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8006bea:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8006bec:	464e      	mov	r6, r9
 8006bee:	ebc1 010b 	rsb	r1, r1, fp
 8006bf2:	9110      	str	r1, [sp, #64]	; 0x40
 8006bf4:	f7ff ba7d 	b.w	80060f2 <_svfprintf_r+0x302>
 8006bf8:	2a30      	cmp	r2, #48	; 0x30
 8006bfa:	f000 8333 	beq.w	8007264 <_svfprintf_r+0x1474>
 8006bfe:	9313      	str	r3, [sp, #76]	; 0x4c
 8006c00:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8006c04:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8006c06:	ebc3 040b 	rsb	r4, r3, fp
 8006c0a:	2330      	movs	r3, #48	; 0x30
 8006c0c:	9410      	str	r4, [sp, #64]	; 0x40
 8006c0e:	7003      	strb	r3, [r0, #0]
 8006c10:	f7ff ba6f 	b.w	80060f2 <_svfprintf_r+0x302>
 8006c14:	4264      	negs	r4, r4
 8006c16:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 8006c1a:	232d      	movs	r3, #45	; 0x2d
 8006c1c:	ea54 0005 	orrs.w	r0, r4, r5
 8006c20:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
 8006c24:	bf0c      	ite	eq
 8006c26:	2200      	moveq	r2, #0
 8006c28:	2201      	movne	r2, #1
 8006c2a:	2301      	movs	r3, #1
 8006c2c:	f7ff ba2c 	b.w	8006088 <_svfprintf_r+0x298>
 8006c30:	981a      	ldr	r0, [sp, #104]	; 0x68
 8006c32:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8006c34:	f002 fb02 	bl	800923c <__fpclassifyd>
 8006c38:	2800      	cmp	r0, #0
 8006c3a:	f040 8175 	bne.w	8006f28 <_svfprintf_r+0x1138>
 8006c3e:	9014      	str	r0, [sp, #80]	; 0x50
 8006c40:	f64b 3350 	movw	r3, #47952	; 0xbb50
 8006c44:	f64b 324c 	movw	r2, #47948	; 0xbb4c
 8006c48:	9816      	ldr	r0, [sp, #88]	; 0x58
 8006c4a:	f6c0 0200 	movt	r2, #2048	; 0x800
 8006c4e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006c52:	2847      	cmp	r0, #71	; 0x47
 8006c54:	bfd8      	it	le
 8006c56:	4613      	movle	r3, r2
 8006c58:	9313      	str	r3, [sp, #76]	; 0x4c
 8006c5a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8006c5c:	2403      	movs	r4, #3
 8006c5e:	9908      	ldr	r1, [sp, #32]
 8006c60:	940a      	str	r4, [sp, #40]	; 0x28
 8006c62:	f021 0180 	bic.w	r1, r1, #128	; 0x80
 8006c66:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8006c6a:	9108      	str	r1, [sp, #32]
 8006c6c:	9410      	str	r4, [sp, #64]	; 0x40
 8006c6e:	9318      	str	r3, [sp, #96]	; 0x60
 8006c70:	f7ff ba49 	b.w	8006106 <_svfprintf_r+0x316>
 8006c74:	7813      	ldrb	r3, [r2, #0]
 8006c76:	f7ff b928 	b.w	8005eca <_svfprintf_r+0xda>
 8006c7a:	9912      	ldr	r1, [sp, #72]	; 0x48
 8006c7c:	1dcb      	adds	r3, r1, #7
 8006c7e:	f023 0307 	bic.w	r3, r3, #7
 8006c82:	f103 0208 	add.w	r2, r3, #8
 8006c86:	9212      	str	r2, [sp, #72]	; 0x48
 8006c88:	681c      	ldr	r4, [r3, #0]
 8006c8a:	941a      	str	r4, [sp, #104]	; 0x68
 8006c8c:	685b      	ldr	r3, [r3, #4]
 8006c8e:	931b      	str	r3, [sp, #108]	; 0x6c
 8006c90:	f7ff bb77 	b.w	8006382 <_svfprintf_r+0x592>
 8006c94:	9b08      	ldr	r3, [sp, #32]
 8006c96:	f013 0f40 	tst.w	r3, #64	; 0x40
 8006c9a:	f000 8126 	beq.w	8006eea <_svfprintf_r+0x10fa>
 8006c9e:	9812      	ldr	r0, [sp, #72]	; 0x48
 8006ca0:	2500      	movs	r5, #0
 8006ca2:	8804      	ldrh	r4, [r0, #0]
 8006ca4:	3004      	adds	r0, #4
 8006ca6:	9012      	str	r0, [sp, #72]	; 0x48
 8006ca8:	f7ff bbde 	b.w	8006468 <_svfprintf_r+0x678>
 8006cac:	0800b7e4 	.word	0x0800b7e4
 8006cb0:	9b08      	ldr	r3, [sp, #32]
 8006cb2:	f013 0f40 	tst.w	r3, #64	; 0x40
 8006cb6:	f000 8111 	beq.w	8006edc <_svfprintf_r+0x10ec>
 8006cba:	9812      	ldr	r0, [sp, #72]	; 0x48
 8006cbc:	f9b0 4000 	ldrsh.w	r4, [r0]
 8006cc0:	3004      	adds	r0, #4
 8006cc2:	9012      	str	r0, [sp, #72]	; 0x48
 8006cc4:	17e5      	asrs	r5, r4, #31
 8006cc6:	f7ff b9d3 	b.w	8006070 <_svfprintf_r+0x280>
 8006cca:	9908      	ldr	r1, [sp, #32]
 8006ccc:	f011 0f10 	tst.w	r1, #16
 8006cd0:	f000 8112 	beq.w	8006ef8 <_svfprintf_r+0x1108>
 8006cd4:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8006cd6:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 8006cd8:	6813      	ldr	r3, [r2, #0]
 8006cda:	3204      	adds	r2, #4
 8006cdc:	9212      	str	r2, [sp, #72]	; 0x48
 8006cde:	601c      	str	r4, [r3, #0]
 8006ce0:	f7ff b8af 	b.w	8005e42 <_svfprintf_r+0x52>
 8006ce4:	9808      	ldr	r0, [sp, #32]
 8006ce6:	f010 0340 	ands.w	r3, r0, #64	; 0x40
 8006cea:	f000 81fc 	beq.w	80070e6 <_svfprintf_r+0x12f6>
 8006cee:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006cf0:	2500      	movs	r5, #0
 8006cf2:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8006cf4:	8819      	ldrh	r1, [r3, #0]
 8006cf6:	3404      	adds	r4, #4
 8006cf8:	4613      	mov	r3, r2
 8006cfa:	9412      	str	r4, [sp, #72]	; 0x48
 8006cfc:	1e0a      	subs	r2, r1, #0
 8006cfe:	460c      	mov	r4, r1
 8006d00:	bf18      	it	ne
 8006d02:	2201      	movne	r2, #1
 8006d04:	f7ff bb88 	b.w	8006418 <_svfprintf_r+0x628>
 8006d08:	46a0      	mov	r8, r4
 8006d0a:	460d      	mov	r5, r1
 8006d0c:	4614      	mov	r4, r2
 8006d0e:	3401      	adds	r4, #1
 8006d10:	f8c9 8000 	str.w	r8, [r9]
 8006d14:	2c07      	cmp	r4, #7
 8006d16:	f8c9 6004 	str.w	r6, [r9, #4]
 8006d1a:	4435      	add	r5, r6
 8006d1c:	943a      	str	r4, [sp, #232]	; 0xe8
 8006d1e:	953b      	str	r5, [sp, #236]	; 0xec
 8006d20:	f300 82af 	bgt.w	8007282 <_svfprintf_r+0x1492>
 8006d24:	9a42      	ldr	r2, [sp, #264]	; 0x108
 8006d26:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 8006d28:	42a2      	cmp	r2, r4
 8006d2a:	db4a      	blt.n	8006dc2 <_svfprintf_r+0xfd2>
 8006d2c:	9808      	ldr	r0, [sp, #32]
 8006d2e:	f010 0f01 	tst.w	r0, #1
 8006d32:	d146      	bne.n	8006dc2 <_svfprintf_r+0xfd2>
 8006d34:	9c13      	ldr	r4, [sp, #76]	; 0x4c
 8006d36:	9818      	ldr	r0, [sp, #96]	; 0x60
 8006d38:	1821      	adds	r1, r4, r0
 8006d3a:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 8006d3c:	ebc1 070b 	rsb	r7, r1, fp
 8006d40:	1aa2      	subs	r2, r4, r2
 8006d42:	42ba      	cmp	r2, r7
 8006d44:	bfb8      	it	lt
 8006d46:	4617      	movlt	r7, r2
 8006d48:	2f00      	cmp	r7, #0
 8006d4a:	dd0a      	ble.n	8006d62 <_svfprintf_r+0xf72>
 8006d4c:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006d4e:	19ed      	adds	r5, r5, r7
 8006d50:	6019      	str	r1, [r3, #0]
 8006d52:	3401      	adds	r4, #1
 8006d54:	605f      	str	r7, [r3, #4]
 8006d56:	2c07      	cmp	r4, #7
 8006d58:	953b      	str	r5, [sp, #236]	; 0xec
 8006d5a:	943a      	str	r4, [sp, #232]	; 0xe8
 8006d5c:	f300 8274 	bgt.w	8007248 <_svfprintf_r+0x1458>
 8006d60:	3308      	adds	r3, #8
 8006d62:	ea27 76e7 	bic.w	r6, r7, r7, asr #31
 8006d66:	1b96      	subs	r6, r2, r6
 8006d68:	2e00      	cmp	r6, #0
 8006d6a:	dd38      	ble.n	8006dde <_svfprintf_r+0xfee>
 8006d6c:	2e10      	cmp	r6, #16
 8006d6e:	f340 8304 	ble.w	800737a <_svfprintf_r+0x158a>
 8006d72:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006d74:	2710      	movs	r7, #16
 8006d76:	f8df 86b4 	ldr.w	r8, [pc, #1716]	; 800742c <_svfprintf_r+0x163c>
 8006d7a:	4622      	mov	r2, r4
 8006d7c:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 8006d80:	4644      	mov	r4, r8
 8006d82:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8006d86:	e003      	b.n	8006d90 <_svfprintf_r+0xfa0>
 8006d88:	3e10      	subs	r6, #16
 8006d8a:	2e10      	cmp	r6, #16
 8006d8c:	f77f aee0 	ble.w	8006b50 <_svfprintf_r+0xd60>
 8006d90:	3201      	adds	r2, #1
 8006d92:	601c      	str	r4, [r3, #0]
 8006d94:	605f      	str	r7, [r3, #4]
 8006d96:	3510      	adds	r5, #16
 8006d98:	3308      	adds	r3, #8
 8006d9a:	2a07      	cmp	r2, #7
 8006d9c:	923a      	str	r2, [sp, #232]	; 0xe8
 8006d9e:	f103 0908 	add.w	r9, r3, #8
 8006da2:	953b      	str	r5, [sp, #236]	; 0xec
 8006da4:	ddf0      	ble.n	8006d88 <_svfprintf_r+0xf98>
 8006da6:	4640      	mov	r0, r8
 8006da8:	4659      	mov	r1, fp
 8006daa:	aa39      	add	r2, sp, #228	; 0xe4
 8006dac:	f10a 0908 	add.w	r9, sl, #8
 8006db0:	f002 fabc 	bl	800932c <__ssprint_r>
 8006db4:	4653      	mov	r3, sl
 8006db6:	2800      	cmp	r0, #0
 8006db8:	f47f a901 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 8006dbc:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006dbe:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 8006dc0:	e7e2      	b.n	8006d88 <_svfprintf_r+0xf98>
 8006dc2:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006dc4:	991c      	ldr	r1, [sp, #112]	; 0x70
 8006dc6:	3401      	adds	r4, #1
 8006dc8:	9819      	ldr	r0, [sp, #100]	; 0x64
 8006dca:	2c07      	cmp	r4, #7
 8006dcc:	440d      	add	r5, r1
 8006dce:	6059      	str	r1, [r3, #4]
 8006dd0:	6018      	str	r0, [r3, #0]
 8006dd2:	953b      	str	r5, [sp, #236]	; 0xec
 8006dd4:	943a      	str	r4, [sp, #232]	; 0xe8
 8006dd6:	f300 822b 	bgt.w	8007230 <_svfprintf_r+0x1440>
 8006dda:	3308      	adds	r3, #8
 8006ddc:	e7aa      	b.n	8006d34 <_svfprintf_r+0xf44>
 8006dde:	4699      	mov	r9, r3
 8006de0:	f7ff ba62 	b.w	80062a8 <_svfprintf_r+0x4b8>
 8006de4:	f106 0908 	add.w	r9, r6, #8
 8006de8:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006dea:	f8df 8640 	ldr.w	r8, [pc, #1600]	; 800742c <_svfprintf_r+0x163c>
 8006dee:	f7ff ba3c 	b.w	800626a <_svfprintf_r+0x47a>
 8006df2:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006df4:	aa39      	add	r2, sp, #228	; 0xe4
 8006df6:	990c      	ldr	r1, [sp, #48]	; 0x30
 8006df8:	f002 fa98 	bl	800932c <__ssprint_r>
 8006dfc:	2800      	cmp	r0, #0
 8006dfe:	f47f a8de 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 8006e02:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006e04:	46d1      	mov	r9, sl
 8006e06:	e4ae      	b.n	8006766 <_svfprintf_r+0x976>
 8006e08:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006e0a:	f64b 3384 	movw	r3, #48004	; 0xbb84
 8006e0e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006e12:	f8c9 3000 	str.w	r3, [r9]
 8006e16:	3401      	adds	r4, #1
 8006e18:	2301      	movs	r3, #1
 8006e1a:	2c07      	cmp	r4, #7
 8006e1c:	f8c9 3004 	str.w	r3, [r9, #4]
 8006e20:	441d      	add	r5, r3
 8006e22:	943a      	str	r4, [sp, #232]	; 0xe8
 8006e24:	953b      	str	r5, [sp, #236]	; 0xec
 8006e26:	bfd8      	it	le
 8006e28:	f109 0908 	addle.w	r9, r9, #8
 8006e2c:	f300 818c 	bgt.w	8007148 <_svfprintf_r+0x1358>
 8006e30:	b936      	cbnz	r6, 8006e40 <_svfprintf_r+0x1050>
 8006e32:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8006e34:	b923      	cbnz	r3, 8006e40 <_svfprintf_r+0x1050>
 8006e36:	9c08      	ldr	r4, [sp, #32]
 8006e38:	f014 0f01 	tst.w	r4, #1
 8006e3c:	f43f aa34 	beq.w	80062a8 <_svfprintf_r+0x4b8>
 8006e40:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006e42:	981c      	ldr	r0, [sp, #112]	; 0x70
 8006e44:	3401      	adds	r4, #1
 8006e46:	9919      	ldr	r1, [sp, #100]	; 0x64
 8006e48:	2c07      	cmp	r4, #7
 8006e4a:	4405      	add	r5, r0
 8006e4c:	f8c9 0004 	str.w	r0, [r9, #4]
 8006e50:	f8c9 1000 	str.w	r1, [r9]
 8006e54:	bfd8      	it	le
 8006e56:	f109 0908 	addle.w	r9, r9, #8
 8006e5a:	953b      	str	r5, [sp, #236]	; 0xec
 8006e5c:	943a      	str	r4, [sp, #232]	; 0xe8
 8006e5e:	f300 81ab 	bgt.w	80071b8 <_svfprintf_r+0x13c8>
 8006e62:	4276      	negs	r6, r6
 8006e64:	2e00      	cmp	r6, #0
 8006e66:	f340 8198 	ble.w	800719a <_svfprintf_r+0x13aa>
 8006e6a:	2e10      	cmp	r6, #16
 8006e6c:	bfd8      	it	le
 8006e6e:	f8df 85bc 	ldrle.w	r8, [pc, #1468]	; 800742c <_svfprintf_r+0x163c>
 8006e72:	f340 817a 	ble.w	800716a <_svfprintf_r+0x137a>
 8006e76:	f8df 85b4 	ldr.w	r8, [pc, #1460]	; 800742c <_svfprintf_r+0x163c>
 8006e7a:	4623      	mov	r3, r4
 8006e7c:	2710      	movs	r7, #16
 8006e7e:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 8006e82:	4644      	mov	r4, r8
 8006e84:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8006e88:	e003      	b.n	8006e92 <_svfprintf_r+0x10a2>
 8006e8a:	3e10      	subs	r6, #16
 8006e8c:	2e10      	cmp	r6, #16
 8006e8e:	f340 816a 	ble.w	8007166 <_svfprintf_r+0x1376>
 8006e92:	3301      	adds	r3, #1
 8006e94:	3510      	adds	r5, #16
 8006e96:	2b07      	cmp	r3, #7
 8006e98:	f8c9 4000 	str.w	r4, [r9]
 8006e9c:	f8c9 7004 	str.w	r7, [r9, #4]
 8006ea0:	f109 0908 	add.w	r9, r9, #8
 8006ea4:	933a      	str	r3, [sp, #232]	; 0xe8
 8006ea6:	953b      	str	r5, [sp, #236]	; 0xec
 8006ea8:	ddef      	ble.n	8006e8a <_svfprintf_r+0x109a>
 8006eaa:	4640      	mov	r0, r8
 8006eac:	4659      	mov	r1, fp
 8006eae:	aa39      	add	r2, sp, #228	; 0xe4
 8006eb0:	46d1      	mov	r9, sl
 8006eb2:	f002 fa3b 	bl	800932c <__ssprint_r>
 8006eb6:	2800      	cmp	r0, #0
 8006eb8:	f47f a881 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 8006ebc:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006ebe:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 8006ec0:	e7e3      	b.n	8006e8a <_svfprintf_r+0x109a>
 8006ec2:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8006ec4:	2200      	movs	r2, #0
 8006ec6:	9412      	str	r4, [sp, #72]	; 0x48
 8006ec8:	2400      	movs	r4, #0
 8006eca:	9214      	str	r2, [sp, #80]	; 0x50
 8006ecc:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8006ed0:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8006ed4:	930a      	str	r3, [sp, #40]	; 0x28
 8006ed6:	9418      	str	r4, [sp, #96]	; 0x60
 8006ed8:	f7ff b915 	b.w	8006106 <_svfprintf_r+0x316>
 8006edc:	9912      	ldr	r1, [sp, #72]	; 0x48
 8006ede:	680c      	ldr	r4, [r1, #0]
 8006ee0:	3104      	adds	r1, #4
 8006ee2:	9112      	str	r1, [sp, #72]	; 0x48
 8006ee4:	17e5      	asrs	r5, r4, #31
 8006ee6:	f7ff b8c3 	b.w	8006070 <_svfprintf_r+0x280>
 8006eea:	9912      	ldr	r1, [sp, #72]	; 0x48
 8006eec:	2500      	movs	r5, #0
 8006eee:	680c      	ldr	r4, [r1, #0]
 8006ef0:	3104      	adds	r1, #4
 8006ef2:	9112      	str	r1, [sp, #72]	; 0x48
 8006ef4:	f7ff bab8 	b.w	8006468 <_svfprintf_r+0x678>
 8006ef8:	9808      	ldr	r0, [sp, #32]
 8006efa:	f010 0f40 	tst.w	r0, #64	; 0x40
 8006efe:	f000 810c 	beq.w	800711a <_svfprintf_r+0x132a>
 8006f02:	9912      	ldr	r1, [sp, #72]	; 0x48
 8006f04:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8006f06:	680b      	ldr	r3, [r1, #0]
 8006f08:	3104      	adds	r1, #4
 8006f0a:	9112      	str	r1, [sp, #72]	; 0x48
 8006f0c:	801a      	strh	r2, [r3, #0]
 8006f0e:	f7fe bf98 	b.w	8005e42 <_svfprintf_r+0x52>
 8006f12:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006f14:	aa39      	add	r2, sp, #228	; 0xe4
 8006f16:	990c      	ldr	r1, [sp, #48]	; 0x30
 8006f18:	f002 fa08 	bl	800932c <__ssprint_r>
 8006f1c:	2800      	cmp	r0, #0
 8006f1e:	f47f a84e 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 8006f22:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006f24:	4653      	mov	r3, sl
 8006f26:	e438      	b.n	800679a <_svfprintf_r+0x9aa>
 8006f28:	f1b7 3fff 	cmp.w	r7, #4294967295
 8006f2c:	f000 8151 	beq.w	80071d2 <_svfprintf_r+0x13e2>
 8006f30:	9c16      	ldr	r4, [sp, #88]	; 0x58
 8006f32:	f1a4 0e67 	sub.w	lr, r4, #103	; 0x67
 8006f36:	f1de 0300 	rsbs	r3, lr, #0
 8006f3a:	eb43 030e 	adc.w	r3, r3, lr
 8006f3e:	2c47      	cmp	r4, #71	; 0x47
 8006f40:	bf08      	it	eq
 8006f42:	f043 0301 	orreq.w	r3, r3, #1
 8006f46:	b113      	cbz	r3, 8006f4e <_svfprintf_r+0x115e>
 8006f48:	2f00      	cmp	r7, #0
 8006f4a:	bf08      	it	eq
 8006f4c:	2701      	moveq	r7, #1
 8006f4e:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8006f50:	9808      	ldr	r0, [sp, #32]
 8006f52:	2b00      	cmp	r3, #0
 8006f54:	f440 7080 	orr.w	r0, r0, #256	; 0x100
 8006f58:	9008      	str	r0, [sp, #32]
 8006f5a:	f2c0 8201 	blt.w	8007360 <_svfprintf_r+0x1570>
 8006f5e:	f8dd 906c 	ldr.w	r9, [sp, #108]	; 0x6c
 8006f62:	2200      	movs	r2, #0
 8006f64:	9214      	str	r2, [sp, #80]	; 0x50
 8006f66:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8006f68:	f1a3 0466 	sub.w	r4, r3, #102	; 0x66
 8006f6c:	f1d4 0b00 	rsbs	fp, r4, #0
 8006f70:	eb4b 0b04 	adc.w	fp, fp, r4
 8006f74:	2b46      	cmp	r3, #70	; 0x46
 8006f76:	bf08      	it	eq
 8006f78:	f04b 0b01 	orreq.w	fp, fp, #1
 8006f7c:	f1bb 0f00 	cmp.w	fp, #0
 8006f80:	f040 81bb 	bne.w	80072fa <_svfprintf_r+0x150a>
 8006f84:	2b45      	cmp	r3, #69	; 0x45
 8006f86:	d002      	beq.n	8006f8e <_svfprintf_r+0x119e>
 8006f88:	2b65      	cmp	r3, #101	; 0x65
 8006f8a:	f040 81e6 	bne.w	800735a <_svfprintf_r+0x156a>
 8006f8e:	f107 0801 	add.w	r8, r7, #1
 8006f92:	2302      	movs	r3, #2
 8006f94:	9c1a      	ldr	r4, [sp, #104]	; 0x68
 8006f96:	a942      	add	r1, sp, #264	; 0x108
 8006f98:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
 8006f9c:	9300      	str	r3, [sp, #0]
 8006f9e:	940a      	str	r4, [sp, #40]	; 0x28
 8006fa0:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 8006fa4:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006fa6:	9102      	str	r1, [sp, #8]
 8006fa8:	a941      	add	r1, sp, #260	; 0x104
 8006faa:	f8cd 8004 	str.w	r8, [sp, #4]
 8006fae:	9103      	str	r1, [sp, #12]
 8006fb0:	a940      	add	r1, sp, #256	; 0x100
 8006fb2:	9104      	str	r1, [sp, #16]
 8006fb4:	f000 fafe 	bl	80075b4 <_dtoa_r>
 8006fb8:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8006fba:	f1b2 0367 	subs.w	r3, r2, #103	; 0x67
 8006fbe:	bf18      	it	ne
 8006fc0:	2301      	movne	r3, #1
 8006fc2:	2a47      	cmp	r2, #71	; 0x47
 8006fc4:	bf0c      	ite	eq
 8006fc6:	2300      	moveq	r3, #0
 8006fc8:	f003 0301 	andne.w	r3, r3, #1
 8006fcc:	9013      	str	r0, [sp, #76]	; 0x4c
 8006fce:	b923      	cbnz	r3, 8006fda <_svfprintf_r+0x11ea>
 8006fd0:	9b08      	ldr	r3, [sp, #32]
 8006fd2:	f013 0f01 	tst.w	r3, #1
 8006fd6:	f000 81e1 	beq.w	800739c <_svfprintf_r+0x15ac>
 8006fda:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8006fdc:	eb00 0408 	add.w	r4, r0, r8
 8006fe0:	f1bb 0f00 	cmp.w	fp, #0
 8006fe4:	d005      	beq.n	8006ff2 <_svfprintf_r+0x1202>
 8006fe6:	7803      	ldrb	r3, [r0, #0]
 8006fe8:	2b30      	cmp	r3, #48	; 0x30
 8006fea:	f000 81e2 	beq.w	80073b2 <_svfprintf_r+0x15c2>
 8006fee:	9b42      	ldr	r3, [sp, #264]	; 0x108
 8006ff0:	18e4      	adds	r4, r4, r3
 8006ff2:	981a      	ldr	r0, [sp, #104]	; 0x68
 8006ff4:	2200      	movs	r2, #0
 8006ff6:	2300      	movs	r3, #0
 8006ff8:	4649      	mov	r1, r9
 8006ffa:	f003 ff7f 	bl	800aefc <__aeabi_dcmpeq>
 8006ffe:	2800      	cmp	r0, #0
 8007000:	f000 8185 	beq.w	800730e <_svfprintf_r+0x151e>
 8007004:	4623      	mov	r3, r4
 8007006:	9440      	str	r4, [sp, #256]	; 0x100
 8007008:	9916      	ldr	r1, [sp, #88]	; 0x58
 800700a:	9c13      	ldr	r4, [sp, #76]	; 0x4c
 800700c:	f1a1 0067 	sub.w	r0, r1, #103	; 0x67
 8007010:	4242      	negs	r2, r0
 8007012:	ebc4 0303 	rsb	r3, r4, r3
 8007016:	eb42 0200 	adc.w	r2, r2, r0
 800701a:	930e      	str	r3, [sp, #56]	; 0x38
 800701c:	2947      	cmp	r1, #71	; 0x47
 800701e:	bf14      	ite	ne
 8007020:	4613      	movne	r3, r2
 8007022:	f042 0301 	orreq.w	r3, r2, #1
 8007026:	2b00      	cmp	r3, #0
 8007028:	f000 8148 	beq.w	80072bc <_svfprintf_r+0x14cc>
 800702c:	9b42      	ldr	r3, [sp, #264]	; 0x108
 800702e:	f113 0f03 	cmn.w	r3, #3
 8007032:	9310      	str	r3, [sp, #64]	; 0x40
 8007034:	db02      	blt.n	800703c <_svfprintf_r+0x124c>
 8007036:	429f      	cmp	r7, r3
 8007038:	f280 8174 	bge.w	8007324 <_svfprintf_r+0x1534>
 800703c:	9816      	ldr	r0, [sp, #88]	; 0x58
 800703e:	3802      	subs	r0, #2
 8007040:	9016      	str	r0, [sp, #88]	; 0x58
 8007042:	3b01      	subs	r3, #1
 8007044:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8007046:	2b00      	cmp	r3, #0
 8007048:	9342      	str	r3, [sp, #264]	; 0x108
 800704a:	f88d 20f8 	strb.w	r2, [sp, #248]	; 0xf8
 800704e:	f2c0 81c3 	blt.w	80073d8 <_svfprintf_r+0x15e8>
 8007052:	222b      	movs	r2, #43	; 0x2b
 8007054:	f88d 20f9 	strb.w	r2, [sp, #249]	; 0xf9
 8007058:	2b09      	cmp	r3, #9
 800705a:	f340 8186 	ble.w	800736a <_svfprintf_r+0x157a>
 800705e:	f246 6467 	movw	r4, #26215	; 0x6667
 8007062:	f10d 00f6 	add.w	r0, sp, #246	; 0xf6
 8007066:	f2c6 6466 	movt	r4, #26214	; 0x6666
 800706a:	fb84 2103 	smull	r2, r1, r4, r3
 800706e:	17da      	asrs	r2, r3, #31
 8007070:	4605      	mov	r5, r0
 8007072:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
 8007076:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 800707a:	eba3 0141 	sub.w	r1, r3, r1, lsl #1
 800707e:	4613      	mov	r3, r2
 8007080:	3130      	adds	r1, #48	; 0x30
 8007082:	2a09      	cmp	r2, #9
 8007084:	f800 1901 	strb.w	r1, [r0], #-1
 8007088:	dcef      	bgt.n	800706a <_svfprintf_r+0x127a>
 800708a:	3330      	adds	r3, #48	; 0x30
 800708c:	1e6a      	subs	r2, r5, #1
 800708e:	f805 3c01 	strb.w	r3, [r5, #-1]
 8007092:	f10d 03f7 	add.w	r3, sp, #247	; 0xf7
 8007096:	429a      	cmp	r2, r3
 8007098:	f080 81c4 	bcs.w	8007424 <_svfprintf_r+0x1634>
 800709c:	f10d 03fa 	add.w	r3, sp, #250	; 0xfa
 80070a0:	f812 1b01 	ldrb.w	r1, [r2], #1
 80070a4:	f803 1b01 	strb.w	r1, [r3], #1
 80070a8:	4619      	mov	r1, r3
 80070aa:	9c07      	ldr	r4, [sp, #28]
 80070ac:	4294      	cmp	r4, r2
 80070ae:	d8f7      	bhi.n	80070a0 <_svfprintf_r+0x12b0>
 80070b0:	ab3e      	add	r3, sp, #248	; 0xf8
 80070b2:	980e      	ldr	r0, [sp, #56]	; 0x38
 80070b4:	1acb      	subs	r3, r1, r3
 80070b6:	990e      	ldr	r1, [sp, #56]	; 0x38
 80070b8:	1818      	adds	r0, r3, r0
 80070ba:	931d      	str	r3, [sp, #116]	; 0x74
 80070bc:	2901      	cmp	r1, #1
 80070be:	9010      	str	r0, [sp, #64]	; 0x40
 80070c0:	f340 816e 	ble.w	80073a0 <_svfprintf_r+0x15b0>
 80070c4:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80070c6:	2400      	movs	r4, #0
 80070c8:	9418      	str	r4, [sp, #96]	; 0x60
 80070ca:	3301      	adds	r3, #1
 80070cc:	9310      	str	r3, [sp, #64]	; 0x40
 80070ce:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80070d0:	2b00      	cmp	r3, #0
 80070d2:	f040 8107 	bne.w	80072e4 <_svfprintf_r+0x14f4>
 80070d6:	9c10      	ldr	r4, [sp, #64]	; 0x40
 80070d8:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 80070dc:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
 80070e0:	940a      	str	r4, [sp, #40]	; 0x28
 80070e2:	f7ff b810 	b.w	8006106 <_svfprintf_r+0x316>
 80070e6:	9812      	ldr	r0, [sp, #72]	; 0x48
 80070e8:	2500      	movs	r5, #0
 80070ea:	6802      	ldr	r2, [r0, #0]
 80070ec:	3004      	adds	r0, #4
 80070ee:	9012      	str	r0, [sp, #72]	; 0x48
 80070f0:	4614      	mov	r4, r2
 80070f2:	3a00      	subs	r2, #0
 80070f4:	bf18      	it	ne
 80070f6:	2201      	movne	r2, #1
 80070f8:	f7ff b98e 	b.w	8006418 <_svfprintf_r+0x628>
 80070fc:	2140      	movs	r1, #64	; 0x40
 80070fe:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007100:	f7fd fdce 	bl	8004ca0 <_malloc_r>
 8007104:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007106:	6008      	str	r0, [r1, #0]
 8007108:	6108      	str	r0, [r1, #16]
 800710a:	2800      	cmp	r0, #0
 800710c:	f000 8182 	beq.w	8007414 <_svfprintf_r+0x1624>
 8007110:	980c      	ldr	r0, [sp, #48]	; 0x30
 8007112:	2340      	movs	r3, #64	; 0x40
 8007114:	6143      	str	r3, [r0, #20]
 8007116:	f7fe be82 	b.w	8005e1e <_svfprintf_r+0x2e>
 800711a:	9c12      	ldr	r4, [sp, #72]	; 0x48
 800711c:	980f      	ldr	r0, [sp, #60]	; 0x3c
 800711e:	6823      	ldr	r3, [r4, #0]
 8007120:	3404      	adds	r4, #4
 8007122:	9412      	str	r4, [sp, #72]	; 0x48
 8007124:	6018      	str	r0, [r3, #0]
 8007126:	f7fe be8c 	b.w	8005e42 <_svfprintf_r+0x52>
 800712a:	9811      	ldr	r0, [sp, #68]	; 0x44
 800712c:	aa39      	add	r2, sp, #228	; 0xe4
 800712e:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007130:	f002 f8fc 	bl	800932c <__ssprint_r>
 8007134:	2800      	cmp	r0, #0
 8007136:	f47e af42 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 800713a:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800713c:	f10d 0984 	add.w	r9, sp, #132	; 0x84
 8007140:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007142:	46d3      	mov	fp, sl
 8007144:	f7ff bad6 	b.w	80066f4 <_svfprintf_r+0x904>
 8007148:	9811      	ldr	r0, [sp, #68]	; 0x44
 800714a:	aa39      	add	r2, sp, #228	; 0xe4
 800714c:	990c      	ldr	r1, [sp, #48]	; 0x30
 800714e:	f002 f8ed 	bl	800932c <__ssprint_r>
 8007152:	2800      	cmp	r0, #0
 8007154:	f47e af33 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 8007158:	9e42      	ldr	r6, [sp, #264]	; 0x108
 800715a:	46d1      	mov	r9, sl
 800715c:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800715e:	2e00      	cmp	r6, #0
 8007160:	f47f ae6e 	bne.w	8006e40 <_svfprintf_r+0x1050>
 8007164:	e665      	b.n	8006e32 <_svfprintf_r+0x1042>
 8007166:	46a0      	mov	r8, r4
 8007168:	461c      	mov	r4, r3
 800716a:	3401      	adds	r4, #1
 800716c:	f8c9 8000 	str.w	r8, [r9]
 8007170:	2c07      	cmp	r4, #7
 8007172:	f8c9 6004 	str.w	r6, [r9, #4]
 8007176:	4435      	add	r5, r6
 8007178:	943a      	str	r4, [sp, #232]	; 0xe8
 800717a:	953b      	str	r5, [sp, #236]	; 0xec
 800717c:	bfd8      	it	le
 800717e:	f109 0908 	addle.w	r9, r9, #8
 8007182:	dd0a      	ble.n	800719a <_svfprintf_r+0x13aa>
 8007184:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007186:	aa39      	add	r2, sp, #228	; 0xe4
 8007188:	990c      	ldr	r1, [sp, #48]	; 0x30
 800718a:	f002 f8cf 	bl	800932c <__ssprint_r>
 800718e:	2800      	cmp	r0, #0
 8007190:	f47e af15 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 8007194:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007196:	46d1      	mov	r9, sl
 8007198:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 800719a:	3401      	adds	r4, #1
 800719c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800719e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80071a0:	2c07      	cmp	r4, #7
 80071a2:	441d      	add	r5, r3
 80071a4:	f8c9 3004 	str.w	r3, [r9, #4]
 80071a8:	f8c9 2000 	str.w	r2, [r9]
 80071ac:	943a      	str	r4, [sp, #232]	; 0xe8
 80071ae:	953b      	str	r5, [sp, #236]	; 0xec
 80071b0:	f77f a878 	ble.w	80062a4 <_svfprintf_r+0x4b4>
 80071b4:	f7ff baab 	b.w	800670e <_svfprintf_r+0x91e>
 80071b8:	9811      	ldr	r0, [sp, #68]	; 0x44
 80071ba:	aa39      	add	r2, sp, #228	; 0xe4
 80071bc:	990c      	ldr	r1, [sp, #48]	; 0x30
 80071be:	f002 f8b5 	bl	800932c <__ssprint_r>
 80071c2:	2800      	cmp	r0, #0
 80071c4:	f47e aefb 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 80071c8:	9e42      	ldr	r6, [sp, #264]	; 0x108
 80071ca:	46d1      	mov	r9, sl
 80071cc:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80071ce:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80071d0:	e647      	b.n	8006e62 <_svfprintf_r+0x1072>
 80071d2:	2706      	movs	r7, #6
 80071d4:	e6bb      	b.n	8006f4e <_svfprintf_r+0x115e>
 80071d6:	464b      	mov	r3, r9
 80071d8:	e5a4      	b.n	8006d24 <_svfprintf_r+0xf34>
 80071da:	222d      	movs	r2, #45	; 0x2d
 80071dc:	f88d 210f 	strb.w	r2, [sp, #271]	; 0x10f
 80071e0:	f7ff b8e1 	b.w	80063a6 <_svfprintf_r+0x5b6>
 80071e4:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80071e6:	2100      	movs	r1, #0
 80071e8:	9114      	str	r1, [sp, #80]	; 0x50
 80071ea:	f002 f86f 	bl	80092cc <strlen>
 80071ee:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80071f0:	9412      	str	r4, [sp, #72]	; 0x48
 80071f2:	9318      	str	r3, [sp, #96]	; 0x60
 80071f4:	ea20 72e0 	bic.w	r2, r0, r0, asr #31
 80071f8:	9010      	str	r0, [sp, #64]	; 0x40
 80071fa:	920a      	str	r2, [sp, #40]	; 0x28
 80071fc:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8007200:	f7fe bf81 	b.w	8006106 <_svfprintf_r+0x316>
 8007204:	f24b 78d4 	movw	r8, #47060	; 0xb7d4
 8007208:	f106 0308 	add.w	r3, r6, #8
 800720c:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800720e:	f6c0 0800 	movt	r8, #2048	; 0x800
 8007212:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007214:	f7fe bfc2 	b.w	800619c <_svfprintf_r+0x3ac>
 8007218:	9811      	ldr	r0, [sp, #68]	; 0x44
 800721a:	aa39      	add	r2, sp, #228	; 0xe4
 800721c:	990c      	ldr	r1, [sp, #48]	; 0x30
 800721e:	f002 f885 	bl	800932c <__ssprint_r>
 8007222:	2800      	cmp	r0, #0
 8007224:	f47e aecb 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 8007228:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800722a:	46d1      	mov	r9, sl
 800722c:	f7ff bbe3 	b.w	80069f6 <_svfprintf_r+0xc06>
 8007230:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007232:	aa39      	add	r2, sp, #228	; 0xe4
 8007234:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007236:	f002 f879 	bl	800932c <__ssprint_r>
 800723a:	2800      	cmp	r0, #0
 800723c:	f47e aebf 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 8007240:	9a42      	ldr	r2, [sp, #264]	; 0x108
 8007242:	4653      	mov	r3, sl
 8007244:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007246:	e575      	b.n	8006d34 <_svfprintf_r+0xf44>
 8007248:	9811      	ldr	r0, [sp, #68]	; 0x44
 800724a:	aa39      	add	r2, sp, #228	; 0xe4
 800724c:	990c      	ldr	r1, [sp, #48]	; 0x30
 800724e:	f002 f86d 	bl	800932c <__ssprint_r>
 8007252:	2800      	cmp	r0, #0
 8007254:	f47e aeb3 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 8007258:	9a42      	ldr	r2, [sp, #264]	; 0x108
 800725a:	4653      	mov	r3, sl
 800725c:	980e      	ldr	r0, [sp, #56]	; 0x38
 800725e:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007260:	1a82      	subs	r2, r0, r2
 8007262:	e57e      	b.n	8006d62 <_svfprintf_r+0xf72>
 8007264:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8007266:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 800726a:	ebc3 030b 	rsb	r3, r3, fp
 800726e:	9310      	str	r3, [sp, #64]	; 0x40
 8007270:	f7fe bf3f 	b.w	80060f2 <_svfprintf_r+0x302>
 8007274:	f24b 78d4 	movw	r8, #47060	; 0xb7d4
 8007278:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 800727a:	f6c0 0800 	movt	r8, #2048	; 0x800
 800727e:	f7ff b84b 	b.w	8006318 <_svfprintf_r+0x528>
 8007282:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007284:	aa39      	add	r2, sp, #228	; 0xe4
 8007286:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007288:	f002 f850 	bl	800932c <__ssprint_r>
 800728c:	2800      	cmp	r0, #0
 800728e:	f47e ae96 	bne.w	8005fbe <_svfprintf_r+0x1ce>
 8007292:	4653      	mov	r3, sl
 8007294:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007296:	e545      	b.n	8006d24 <_svfprintf_r+0xf34>
 8007298:	2f06      	cmp	r7, #6
 800729a:	bf28      	it	cs
 800729c:	2706      	movcs	r7, #6
 800729e:	f64b 307c 	movw	r0, #47996	; 0xbb7c
 80072a2:	ea27 71e7 	bic.w	r1, r7, r7, asr #31
 80072a6:	f6c0 0000 	movt	r0, #2048	; 0x800
 80072aa:	461a      	mov	r2, r3
 80072ac:	9710      	str	r7, [sp, #64]	; 0x40
 80072ae:	910a      	str	r1, [sp, #40]	; 0x28
 80072b0:	9412      	str	r4, [sp, #72]	; 0x48
 80072b2:	9314      	str	r3, [sp, #80]	; 0x50
 80072b4:	9318      	str	r3, [sp, #96]	; 0x60
 80072b6:	9013      	str	r0, [sp, #76]	; 0x4c
 80072b8:	f7fe bf25 	b.w	8006106 <_svfprintf_r+0x316>
 80072bc:	9916      	ldr	r1, [sp, #88]	; 0x58
 80072be:	2966      	cmp	r1, #102	; 0x66
 80072c0:	f040 808f 	bne.w	80073e2 <_svfprintf_r+0x15f2>
 80072c4:	9b42      	ldr	r3, [sp, #264]	; 0x108
 80072c6:	2b00      	cmp	r3, #0
 80072c8:	9310      	str	r3, [sp, #64]	; 0x40
 80072ca:	f340 8098 	ble.w	80073fe <_svfprintf_r+0x160e>
 80072ce:	b91f      	cbnz	r7, 80072d8 <_svfprintf_r+0x14e8>
 80072d0:	9808      	ldr	r0, [sp, #32]
 80072d2:	f010 0f01 	tst.w	r0, #1
 80072d6:	d002      	beq.n	80072de <_svfprintf_r+0x14ee>
 80072d8:	1c5a      	adds	r2, r3, #1
 80072da:	19d2      	adds	r2, r2, r7
 80072dc:	9210      	str	r2, [sp, #64]	; 0x40
 80072de:	9318      	str	r3, [sp, #96]	; 0x60
 80072e0:	9516      	str	r5, [sp, #88]	; 0x58
 80072e2:	e6f4      	b.n	80070ce <_svfprintf_r+0x12de>
 80072e4:	9810      	ldr	r0, [sp, #64]	; 0x40
 80072e6:	222d      	movs	r2, #45	; 0x2d
 80072e8:	2100      	movs	r1, #0
 80072ea:	f88d 210f 	strb.w	r2, [sp, #271]	; 0x10f
 80072ee:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80072f2:	9114      	str	r1, [sp, #80]	; 0x50
 80072f4:	900a      	str	r0, [sp, #40]	; 0x28
 80072f6:	f7fe bf07 	b.w	8006108 <_svfprintf_r+0x318>
 80072fa:	46b8      	mov	r8, r7
 80072fc:	2303      	movs	r3, #3
 80072fe:	e649      	b.n	8006f94 <_svfprintf_r+0x11a4>
 8007300:	4633      	mov	r3, r6
 8007302:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007304:	3608      	adds	r6, #8
 8007306:	f8df 8124 	ldr.w	r8, [pc, #292]	; 800742c <_svfprintf_r+0x163c>
 800730a:	f7ff babe 	b.w	800688a <_svfprintf_r+0xa9a>
 800730e:	9b40      	ldr	r3, [sp, #256]	; 0x100
 8007310:	429c      	cmp	r4, r3
 8007312:	f67f ae79 	bls.w	8007008 <_svfprintf_r+0x1218>
 8007316:	2230      	movs	r2, #48	; 0x30
 8007318:	f803 2b01 	strb.w	r2, [r3], #1
 800731c:	42a3      	cmp	r3, r4
 800731e:	9340      	str	r3, [sp, #256]	; 0x100
 8007320:	d1fa      	bne.n	8007318 <_svfprintf_r+0x1528>
 8007322:	e671      	b.n	8007008 <_svfprintf_r+0x1218>
 8007324:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8007326:	4293      	cmp	r3, r2
 8007328:	db2e      	blt.n	8007388 <_svfprintf_r+0x1598>
 800732a:	9c08      	ldr	r4, [sp, #32]
 800732c:	f014 0f01 	tst.w	r4, #1
 8007330:	d03d      	beq.n	80073ae <_svfprintf_r+0x15be>
 8007332:	1c58      	adds	r0, r3, #1
 8007334:	2567      	movs	r5, #103	; 0x67
 8007336:	9010      	str	r0, [sp, #64]	; 0x40
 8007338:	e7d1      	b.n	80072de <_svfprintf_r+0x14ee>
 800733a:	ea27 72e7 	bic.w	r2, r7, r7, asr #31
 800733e:	9014      	str	r0, [sp, #80]	; 0x50
 8007340:	920a      	str	r2, [sp, #40]	; 0x28
 8007342:	9412      	str	r4, [sp, #72]	; 0x48
 8007344:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8007348:	9710      	str	r7, [sp, #64]	; 0x40
 800734a:	9018      	str	r0, [sp, #96]	; 0x60
 800734c:	f7fe bedb 	b.w	8006106 <_svfprintf_r+0x316>
 8007350:	2700      	movs	r7, #0
 8007352:	ea47 77e7 	orr.w	r7, r7, r7, asr #31
 8007356:	f7fe bdb9 	b.w	8005ecc <_svfprintf_r+0xdc>
 800735a:	46b8      	mov	r8, r7
 800735c:	2302      	movs	r3, #2
 800735e:	e619      	b.n	8006f94 <_svfprintf_r+0x11a4>
 8007360:	212d      	movs	r1, #45	; 0x2d
 8007362:	f103 4900 	add.w	r9, r3, #2147483648	; 0x80000000
 8007366:	9114      	str	r1, [sp, #80]	; 0x50
 8007368:	e5fd      	b.n	8006f66 <_svfprintf_r+0x1176>
 800736a:	3330      	adds	r3, #48	; 0x30
 800736c:	2230      	movs	r2, #48	; 0x30
 800736e:	a93f      	add	r1, sp, #252	; 0xfc
 8007370:	f88d 20fa 	strb.w	r2, [sp, #250]	; 0xfa
 8007374:	f88d 30fb 	strb.w	r3, [sp, #251]	; 0xfb
 8007378:	e69a      	b.n	80070b0 <_svfprintf_r+0x12c0>
 800737a:	f103 0908 	add.w	r9, r3, #8
 800737e:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007380:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 800742c <_svfprintf_r+0x163c>
 8007384:	f7ff bbe6 	b.w	8006b54 <_svfprintf_r+0xd64>
 8007388:	2b00      	cmp	r3, #0
 800738a:	990e      	ldr	r1, [sp, #56]	; 0x38
 800738c:	bfd4      	ite	le
 800738e:	f1c3 0202 	rsble	r2, r3, #2
 8007392:	2201      	movgt	r2, #1
 8007394:	1852      	adds	r2, r2, r1
 8007396:	2567      	movs	r5, #103	; 0x67
 8007398:	9210      	str	r2, [sp, #64]	; 0x40
 800739a:	e7a0      	b.n	80072de <_svfprintf_r+0x14ee>
 800739c:	9b40      	ldr	r3, [sp, #256]	; 0x100
 800739e:	e633      	b.n	8007008 <_svfprintf_r+0x1218>
 80073a0:	9a08      	ldr	r2, [sp, #32]
 80073a2:	f012 0301 	ands.w	r3, r2, #1
 80073a6:	f47f ae8d 	bne.w	80070c4 <_svfprintf_r+0x12d4>
 80073aa:	9318      	str	r3, [sp, #96]	; 0x60
 80073ac:	e68f      	b.n	80070ce <_svfprintf_r+0x12de>
 80073ae:	2567      	movs	r5, #103	; 0x67
 80073b0:	e795      	b.n	80072de <_svfprintf_r+0x14ee>
 80073b2:	981a      	ldr	r0, [sp, #104]	; 0x68
 80073b4:	2200      	movs	r2, #0
 80073b6:	2300      	movs	r3, #0
 80073b8:	4649      	mov	r1, r9
 80073ba:	f003 fd9f 	bl	800aefc <__aeabi_dcmpeq>
 80073be:	2800      	cmp	r0, #0
 80073c0:	f47f ae15 	bne.w	8006fee <_svfprintf_r+0x11fe>
 80073c4:	f1c8 0301 	rsb	r3, r8, #1
 80073c8:	9342      	str	r3, [sp, #264]	; 0x108
 80073ca:	e610      	b.n	8006fee <_svfprintf_r+0x11fe>
 80073cc:	f109 0308 	add.w	r3, r9, #8
 80073d0:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80073d2:	f8df 8058 	ldr.w	r8, [pc, #88]	; 800742c <_svfprintf_r+0x163c>
 80073d6:	e49a      	b.n	8006d0e <_svfprintf_r+0xf1e>
 80073d8:	222d      	movs	r2, #45	; 0x2d
 80073da:	425b      	negs	r3, r3
 80073dc:	f88d 20f9 	strb.w	r2, [sp, #249]	; 0xf9
 80073e0:	e63a      	b.n	8007058 <_svfprintf_r+0x1268>
 80073e2:	9b42      	ldr	r3, [sp, #264]	; 0x108
 80073e4:	e62d      	b.n	8007042 <_svfprintf_r+0x1252>
 80073e6:	9812      	ldr	r0, [sp, #72]	; 0x48
 80073e8:	6807      	ldr	r7, [r0, #0]
 80073ea:	3004      	adds	r0, #4
 80073ec:	2f00      	cmp	r7, #0
 80073ee:	f6bf a943 	bge.w	8006678 <_svfprintf_r+0x888>
 80073f2:	7813      	ldrb	r3, [r2, #0]
 80073f4:	f04f 37ff 	mov.w	r7, #4294967295
 80073f8:	9012      	str	r0, [sp, #72]	; 0x48
 80073fa:	f7fe bd66 	b.w	8005eca <_svfprintf_r+0xda>
 80073fe:	b91f      	cbnz	r7, 8007408 <_svfprintf_r+0x1618>
 8007400:	9908      	ldr	r1, [sp, #32]
 8007402:	f011 0f01 	tst.w	r1, #1
 8007406:	d002      	beq.n	800740e <_svfprintf_r+0x161e>
 8007408:	3702      	adds	r7, #2
 800740a:	9710      	str	r7, [sp, #64]	; 0x40
 800740c:	e767      	b.n	80072de <_svfprintf_r+0x14ee>
 800740e:	2201      	movs	r2, #1
 8007410:	9210      	str	r2, [sp, #64]	; 0x40
 8007412:	e764      	b.n	80072de <_svfprintf_r+0x14ee>
 8007414:	9c11      	ldr	r4, [sp, #68]	; 0x44
 8007416:	f04f 32ff 	mov.w	r2, #4294967295
 800741a:	230c      	movs	r3, #12
 800741c:	920f      	str	r2, [sp, #60]	; 0x3c
 800741e:	6023      	str	r3, [r4, #0]
 8007420:	f7fe bdd6 	b.w	8005fd0 <_svfprintf_r+0x1e0>
 8007424:	f10d 01fa 	add.w	r1, sp, #250	; 0xfa
 8007428:	e642      	b.n	80070b0 <_svfprintf_r+0x12c0>
 800742a:	bf00      	nop
 800742c:	0800b7e4 	.word	0x0800b7e4

08007430 <_write_r>:
 8007430:	b538      	push	{r3, r4, r5, lr}
 8007432:	f641 24e4 	movw	r4, #6884	; 0x1ae4
 8007436:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800743a:	4605      	mov	r5, r0
 800743c:	4608      	mov	r0, r1
 800743e:	4611      	mov	r1, r2
 8007440:	461a      	mov	r2, r3
 8007442:	2300      	movs	r3, #0
 8007444:	6023      	str	r3, [r4, #0]
 8007446:	f7f9 fb05 	bl	8000a54 <_write>
 800744a:	f1b0 3fff 	cmp.w	r0, #4294967295
 800744e:	d000      	beq.n	8007452 <_write_r+0x22>
 8007450:	bd38      	pop	{r3, r4, r5, pc}
 8007452:	6823      	ldr	r3, [r4, #0]
 8007454:	2b00      	cmp	r3, #0
 8007456:	d0fb      	beq.n	8007450 <_write_r+0x20>
 8007458:	602b      	str	r3, [r5, #0]
 800745a:	bd38      	pop	{r3, r4, r5, pc}

0800745c <_close_r>:
 800745c:	b538      	push	{r3, r4, r5, lr}
 800745e:	f641 24e4 	movw	r4, #6884	; 0x1ae4
 8007462:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8007466:	4605      	mov	r5, r0
 8007468:	4608      	mov	r0, r1
 800746a:	2300      	movs	r3, #0
 800746c:	6023      	str	r3, [r4, #0]
 800746e:	f7f9 fa85 	bl	800097c <_close>
 8007472:	f1b0 3fff 	cmp.w	r0, #4294967295
 8007476:	d000      	beq.n	800747a <_close_r+0x1e>
 8007478:	bd38      	pop	{r3, r4, r5, pc}
 800747a:	6823      	ldr	r3, [r4, #0]
 800747c:	2b00      	cmp	r3, #0
 800747e:	d0fb      	beq.n	8007478 <_close_r+0x1c>
 8007480:	602b      	str	r3, [r5, #0]
 8007482:	bd38      	pop	{r3, r4, r5, pc}
 8007484:	0000      	movs	r0, r0
	...

08007488 <quorem>:
 8007488:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800748c:	b083      	sub	sp, #12
 800748e:	6903      	ldr	r3, [r0, #16]
 8007490:	4681      	mov	r9, r0
 8007492:	690d      	ldr	r5, [r1, #16]
 8007494:	9101      	str	r1, [sp, #4]
 8007496:	429d      	cmp	r5, r3
 8007498:	f300 8089 	bgt.w	80075ae <quorem+0x126>
 800749c:	1cea      	adds	r2, r5, #3
 800749e:	f101 0414 	add.w	r4, r1, #20
 80074a2:	f100 0814 	add.w	r8, r0, #20
 80074a6:	3d01      	subs	r5, #1
 80074a8:	0092      	lsls	r2, r2, #2
 80074aa:	188b      	adds	r3, r1, r2
 80074ac:	1882      	adds	r2, r0, r2
 80074ae:	1d1f      	adds	r7, r3, #4
 80074b0:	6859      	ldr	r1, [r3, #4]
 80074b2:	6850      	ldr	r0, [r2, #4]
 80074b4:	3101      	adds	r1, #1
 80074b6:	f002 ffc3 	bl	800a440 <__aeabi_uidiv>
 80074ba:	4606      	mov	r6, r0
 80074bc:	2800      	cmp	r0, #0
 80074be:	d03c      	beq.n	800753a <quorem+0xb2>
 80074c0:	2000      	movs	r0, #0
 80074c2:	4642      	mov	r2, r8
 80074c4:	4623      	mov	r3, r4
 80074c6:	4686      	mov	lr, r0
 80074c8:	f853 cb04 	ldr.w	ip, [r3], #4
 80074cc:	6811      	ldr	r1, [r2, #0]
 80074ce:	fa1f fb8c 	uxth.w	fp, ip
 80074d2:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 80074d6:	fa1f fa81 	uxth.w	sl, r1
 80074da:	fb0b 0b06 	mla	fp, fp, r6, r0
 80074de:	44d6      	add	lr, sl
 80074e0:	fb0c f006 	mul.w	r0, ip, r6
 80074e4:	eb00 401b 	add.w	r0, r0, fp, lsr #16
 80074e8:	fa1f fb8b 	uxth.w	fp, fp
 80074ec:	ebcb 0a0e 	rsb	sl, fp, lr
 80074f0:	fa1f fe80 	uxth.w	lr, r0
 80074f4:	0c00      	lsrs	r0, r0, #16
 80074f6:	ebce 4e11 	rsb	lr, lr, r1, lsr #16
 80074fa:	429f      	cmp	r7, r3
 80074fc:	eb0e 4e2a 	add.w	lr, lr, sl, asr #16
 8007500:	fa1f fc8a 	uxth.w	ip, sl
 8007504:	ea4c 410e 	orr.w	r1, ip, lr, lsl #16
 8007508:	ea4f 4e2e 	mov.w	lr, lr, asr #16
 800750c:	f842 1b04 	str.w	r1, [r2], #4
 8007510:	d2da      	bcs.n	80074c8 <quorem+0x40>
 8007512:	1d2a      	adds	r2, r5, #4
 8007514:	eb09 0382 	add.w	r3, r9, r2, lsl #2
 8007518:	6859      	ldr	r1, [r3, #4]
 800751a:	b971      	cbnz	r1, 800753a <quorem+0xb2>
 800751c:	4598      	cmp	r8, r3
 800751e:	d20a      	bcs.n	8007536 <quorem+0xae>
 8007520:	f859 2022 	ldr.w	r2, [r9, r2, lsl #2]
 8007524:	b93a      	cbnz	r2, 8007536 <quorem+0xae>
 8007526:	3b04      	subs	r3, #4
 8007528:	e002      	b.n	8007530 <quorem+0xa8>
 800752a:	f853 2904 	ldr.w	r2, [r3], #-4
 800752e:	b912      	cbnz	r2, 8007536 <quorem+0xae>
 8007530:	3d01      	subs	r5, #1
 8007532:	4598      	cmp	r8, r3
 8007534:	d3f9      	bcc.n	800752a <quorem+0xa2>
 8007536:	f8c9 5010 	str.w	r5, [r9, #16]
 800753a:	4648      	mov	r0, r9
 800753c:	9901      	ldr	r1, [sp, #4]
 800753e:	f001 fbc3 	bl	8008cc8 <__mcmp>
 8007542:	2800      	cmp	r0, #0
 8007544:	db2f      	blt.n	80075a6 <quorem+0x11e>
 8007546:	3601      	adds	r6, #1
 8007548:	4643      	mov	r3, r8
 800754a:	f04f 0c00 	mov.w	ip, #0
 800754e:	f854 0b04 	ldr.w	r0, [r4], #4
 8007552:	6819      	ldr	r1, [r3, #0]
 8007554:	fa1f fa80 	uxth.w	sl, r0
 8007558:	0c00      	lsrs	r0, r0, #16
 800755a:	b28a      	uxth	r2, r1
 800755c:	ebc0 4111 	rsb	r1, r0, r1, lsr #16
 8007560:	ebca 0202 	rsb	r2, sl, r2
 8007564:	42a7      	cmp	r7, r4
 8007566:	4494      	add	ip, r2
 8007568:	eb01 422c 	add.w	r2, r1, ip, asr #16
 800756c:	fa1f fc8c 	uxth.w	ip, ip
 8007570:	ea4c 4102 	orr.w	r1, ip, r2, lsl #16
 8007574:	ea4f 4c22 	mov.w	ip, r2, asr #16
 8007578:	f843 1b04 	str.w	r1, [r3], #4
 800757c:	d2e7      	bcs.n	800754e <quorem+0xc6>
 800757e:	1d2a      	adds	r2, r5, #4
 8007580:	eb09 0382 	add.w	r3, r9, r2, lsl #2
 8007584:	6859      	ldr	r1, [r3, #4]
 8007586:	b971      	cbnz	r1, 80075a6 <quorem+0x11e>
 8007588:	4598      	cmp	r8, r3
 800758a:	d20a      	bcs.n	80075a2 <quorem+0x11a>
 800758c:	f859 2022 	ldr.w	r2, [r9, r2, lsl #2]
 8007590:	b93a      	cbnz	r2, 80075a2 <quorem+0x11a>
 8007592:	3b04      	subs	r3, #4
 8007594:	e002      	b.n	800759c <quorem+0x114>
 8007596:	f853 2904 	ldr.w	r2, [r3], #-4
 800759a:	b912      	cbnz	r2, 80075a2 <quorem+0x11a>
 800759c:	3d01      	subs	r5, #1
 800759e:	4598      	cmp	r8, r3
 80075a0:	d3f9      	bcc.n	8007596 <quorem+0x10e>
 80075a2:	f8c9 5010 	str.w	r5, [r9, #16]
 80075a6:	4630      	mov	r0, r6
 80075a8:	b003      	add	sp, #12
 80075aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80075ae:	2000      	movs	r0, #0
 80075b0:	e7fa      	b.n	80075a8 <quorem+0x120>
 80075b2:	bf00      	nop

080075b4 <_dtoa_r>:
 80075b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80075b8:	b09f      	sub	sp, #124	; 0x7c
 80075ba:	6a45      	ldr	r5, [r0, #36]	; 0x24
 80075bc:	4604      	mov	r4, r0
 80075be:	4690      	mov	r8, r2
 80075c0:	4699      	mov	r9, r3
 80075c2:	9e2b      	ldr	r6, [sp, #172]	; 0xac
 80075c4:	2d00      	cmp	r5, #0
 80075c6:	f000 8390 	beq.w	8007cea <_dtoa_r+0x736>
 80075ca:	682b      	ldr	r3, [r5, #0]
 80075cc:	b153      	cbz	r3, 80075e4 <_dtoa_r+0x30>
 80075ce:	686a      	ldr	r2, [r5, #4]
 80075d0:	2501      	movs	r5, #1
 80075d2:	4619      	mov	r1, r3
 80075d4:	4095      	lsls	r5, r2
 80075d6:	609d      	str	r5, [r3, #8]
 80075d8:	605a      	str	r2, [r3, #4]
 80075da:	f001 f933 	bl	8008844 <_Bfree>
 80075de:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80075e0:	2200      	movs	r2, #0
 80075e2:	601a      	str	r2, [r3, #0]
 80075e4:	f1b9 0500 	subs.w	r5, r9, #0
 80075e8:	f2c0 80d3 	blt.w	8007792 <_dtoa_r+0x1de>
 80075ec:	2300      	movs	r3, #0
 80075ee:	6033      	str	r3, [r6, #0]
 80075f0:	2300      	movs	r3, #0
 80075f2:	461a      	mov	r2, r3
 80075f4:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 80075f8:	f6c7 72f0 	movt	r2, #32752	; 0x7ff0
 80075fc:	ea05 0303 	and.w	r3, r5, r3
 8007600:	4293      	cmp	r3, r2
 8007602:	f000 80af 	beq.w	8007764 <_dtoa_r+0x1b0>
 8007606:	2200      	movs	r2, #0
 8007608:	2300      	movs	r3, #0
 800760a:	4640      	mov	r0, r8
 800760c:	4649      	mov	r1, r9
 800760e:	e9cd 8902 	strd	r8, r9, [sp, #8]
 8007612:	2601      	movs	r6, #1
 8007614:	f003 fc72 	bl	800aefc <__aeabi_dcmpeq>
 8007618:	b988      	cbnz	r0, 800763e <_dtoa_r+0x8a>
 800761a:	f016 0fff 	tst.w	r6, #255	; 0xff
 800761e:	d112      	bne.n	8007646 <_dtoa_r+0x92>
 8007620:	982a      	ldr	r0, [sp, #168]	; 0xa8
 8007622:	2301      	movs	r3, #1
 8007624:	992c      	ldr	r1, [sp, #176]	; 0xb0
 8007626:	6003      	str	r3, [r0, #0]
 8007628:	f64b 3084 	movw	r0, #48004	; 0xbb84
 800762c:	f6c0 0000 	movt	r0, #2048	; 0x800
 8007630:	b111      	cbz	r1, 8007638 <_dtoa_r+0x84>
 8007632:	4b7b      	ldr	r3, [pc, #492]	; (8007820 <_dtoa_r+0x26c>)
 8007634:	1e58      	subs	r0, r3, #1
 8007636:	600b      	str	r3, [r1, #0]
 8007638:	b01f      	add	sp, #124	; 0x7c
 800763a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800763e:	2600      	movs	r6, #0
 8007640:	f016 0fff 	tst.w	r6, #255	; 0xff
 8007644:	d0ec      	beq.n	8007620 <_dtoa_r+0x6c>
 8007646:	4620      	mov	r0, r4
 8007648:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800764c:	a91c      	add	r1, sp, #112	; 0x70
 800764e:	9100      	str	r1, [sp, #0]
 8007650:	a91d      	add	r1, sp, #116	; 0x74
 8007652:	9101      	str	r1, [sp, #4]
 8007654:	f001 fc4c 	bl	8008ef0 <__d2b>
 8007658:	f3c5 560a 	ubfx	r6, r5, #20, #11
 800765c:	4682      	mov	sl, r0
 800765e:	2e00      	cmp	r6, #0
 8007660:	f000 80ac 	beq.w	80077bc <_dtoa_r+0x208>
 8007664:	9803      	ldr	r0, [sp, #12]
 8007666:	f5a6 767e 	sub.w	r6, r6, #1016	; 0x3f8
 800766a:	9f1d      	ldr	r7, [sp, #116]	; 0x74
 800766c:	3e07      	subs	r6, #7
 800766e:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
 8007672:	2100      	movs	r1, #0
 8007674:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 8007678:	9116      	str	r1, [sp, #88]	; 0x58
 800767a:	f043 537e 	orr.w	r3, r3, #1065353216	; 0x3f800000
 800767e:	f443 03e0 	orr.w	r3, r3, #7340032	; 0x700000
 8007682:	9303      	str	r3, [sp, #12]
 8007684:	2300      	movs	r3, #0
 8007686:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800768a:	2200      	movs	r2, #0
 800768c:	f6c3 73f8 	movt	r3, #16376	; 0x3ff8
 8007690:	f003 f818 	bl	800a6c4 <__aeabi_dsub>
 8007694:	a35c      	add	r3, pc, #368	; (adr r3, 8007808 <_dtoa_r+0x254>)
 8007696:	e9d3 2300 	ldrd	r2, r3, [r3]
 800769a:	f003 f9c7 	bl	800aa2c <__aeabi_dmul>
 800769e:	a35c      	add	r3, pc, #368	; (adr r3, 8007810 <_dtoa_r+0x25c>)
 80076a0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80076a4:	f003 f810 	bl	800a6c8 <__adddf3>
 80076a8:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80076ac:	4630      	mov	r0, r6
 80076ae:	f003 f957 	bl	800a960 <__aeabi_i2d>
 80076b2:	a359      	add	r3, pc, #356	; (adr r3, 8007818 <_dtoa_r+0x264>)
 80076b4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80076b8:	f003 f9b8 	bl	800aa2c <__aeabi_dmul>
 80076bc:	4602      	mov	r2, r0
 80076be:	460b      	mov	r3, r1
 80076c0:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80076c4:	f003 f800 	bl	800a6c8 <__adddf3>
 80076c8:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80076cc:	f003 fc48 	bl	800af60 <__aeabi_d2iz>
 80076d0:	2200      	movs	r2, #0
 80076d2:	2300      	movs	r3, #0
 80076d4:	4605      	mov	r5, r0
 80076d6:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80076da:	f003 fc19 	bl	800af10 <__aeabi_dcmplt>
 80076de:	b140      	cbz	r0, 80076f2 <_dtoa_r+0x13e>
 80076e0:	4628      	mov	r0, r5
 80076e2:	f003 f93d 	bl	800a960 <__aeabi_i2d>
 80076e6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80076ea:	f003 fc07 	bl	800aefc <__aeabi_dcmpeq>
 80076ee:	b900      	cbnz	r0, 80076f2 <_dtoa_r+0x13e>
 80076f0:	3d01      	subs	r5, #1
 80076f2:	2d16      	cmp	r5, #22
 80076f4:	f200 8255 	bhi.w	8007ba2 <_dtoa_r+0x5ee>
 80076f8:	f64b 0108 	movw	r1, #47112	; 0xb808
 80076fc:	4642      	mov	r2, r8
 80076fe:	f6c0 0100 	movt	r1, #2048	; 0x800
 8007702:	464b      	mov	r3, r9
 8007704:	eb01 01c5 	add.w	r1, r1, r5, lsl #3
 8007708:	e9d1 0100 	ldrd	r0, r1, [r1]
 800770c:	f003 fc1e 	bl	800af4c <__aeabi_dcmpgt>
 8007710:	2800      	cmp	r0, #0
 8007712:	f000 8300 	beq.w	8007d16 <_dtoa_r+0x762>
 8007716:	3d01      	subs	r5, #1
 8007718:	2000      	movs	r0, #0
 800771a:	9015      	str	r0, [sp, #84]	; 0x54
 800771c:	3f01      	subs	r7, #1
 800771e:	1bbe      	subs	r6, r7, r6
 8007720:	f100 82f4 	bmi.w	8007d0c <_dtoa_r+0x758>
 8007724:	2000      	movs	r0, #0
 8007726:	960b      	str	r6, [sp, #44]	; 0x2c
 8007728:	900d      	str	r0, [sp, #52]	; 0x34
 800772a:	2d00      	cmp	r5, #0
 800772c:	f2c0 82e6 	blt.w	8007cfc <_dtoa_r+0x748>
 8007730:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8007732:	2200      	movs	r2, #0
 8007734:	9511      	str	r5, [sp, #68]	; 0x44
 8007736:	1949      	adds	r1, r1, r5
 8007738:	920f      	str	r2, [sp, #60]	; 0x3c
 800773a:	910b      	str	r1, [sp, #44]	; 0x2c
 800773c:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800773e:	2a09      	cmp	r2, #9
 8007740:	d870      	bhi.n	8007824 <_dtoa_r+0x270>
 8007742:	2a05      	cmp	r2, #5
 8007744:	f340 8690 	ble.w	8008468 <_dtoa_r+0xeb4>
 8007748:	2700      	movs	r7, #0
 800774a:	3a04      	subs	r2, #4
 800774c:	9228      	str	r2, [sp, #160]	; 0xa0
 800774e:	9828      	ldr	r0, [sp, #160]	; 0xa0
 8007750:	1e83      	subs	r3, r0, #2
 8007752:	2b03      	cmp	r3, #3
 8007754:	f200 840a 	bhi.w	8007f6c <_dtoa_r+0x9b8>
 8007758:	e8df f013 	tbh	[pc, r3, lsl #1]
 800775c:	03ec0402 	.word	0x03ec0402
 8007760:	040503cc 	.word	0x040503cc
 8007764:	982a      	ldr	r0, [sp, #168]	; 0xa8
 8007766:	f242 730f 	movw	r3, #9999	; 0x270f
 800776a:	6003      	str	r3, [r0, #0]
 800776c:	f64b 3094 	movw	r0, #48020	; 0xbb94
 8007770:	f6c0 0000 	movt	r0, #2048	; 0x800
 8007774:	f1b8 0f00 	cmp.w	r8, #0
 8007778:	d011      	beq.n	800779e <_dtoa_r+0x1ea>
 800777a:	992c      	ldr	r1, [sp, #176]	; 0xb0
 800777c:	2900      	cmp	r1, #0
 800777e:	f43f af5b 	beq.w	8007638 <_dtoa_r+0x84>
 8007782:	78c2      	ldrb	r2, [r0, #3]
 8007784:	1cc3      	adds	r3, r0, #3
 8007786:	b10a      	cbz	r2, 800778c <_dtoa_r+0x1d8>
 8007788:	f100 0308 	add.w	r3, r0, #8
 800778c:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
 800778e:	6013      	str	r3, [r2, #0]
 8007790:	e752      	b.n	8007638 <_dtoa_r+0x84>
 8007792:	f025 4500 	bic.w	r5, r5, #2147483648	; 0x80000000
 8007796:	2301      	movs	r3, #1
 8007798:	46a9      	mov	r9, r5
 800779a:	6033      	str	r3, [r6, #0]
 800779c:	e728      	b.n	80075f0 <_dtoa_r+0x3c>
 800779e:	f64b 3288 	movw	r2, #48008	; 0xbb88
 80077a2:	f64b 3394 	movw	r3, #48020	; 0xbb94
 80077a6:	f3c5 0013 	ubfx	r0, r5, #0, #20
 80077aa:	f6c0 0200 	movt	r2, #2048	; 0x800
 80077ae:	f6c0 0300 	movt	r3, #2048	; 0x800
 80077b2:	2800      	cmp	r0, #0
 80077b4:	bf0c      	ite	eq
 80077b6:	4610      	moveq	r0, r2
 80077b8:	4618      	movne	r0, r3
 80077ba:	e7de      	b.n	800777a <_dtoa_r+0x1c6>
 80077bc:	9f1d      	ldr	r7, [sp, #116]	; 0x74
 80077be:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 80077c0:	18fb      	adds	r3, r7, r3
 80077c2:	f503 6386 	add.w	r3, r3, #1072	; 0x430
 80077c6:	1c9e      	adds	r6, r3, #2
 80077c8:	2e20      	cmp	r6, #32
 80077ca:	bfdc      	itt	le
 80077cc:	f1c6 0020 	rsble	r0, r6, #32
 80077d0:	fa08 f000 	lslle.w	r0, r8, r0
 80077d4:	dd07      	ble.n	80077e6 <_dtoa_r+0x232>
 80077d6:	f1c6 0040 	rsb	r0, r6, #64	; 0x40
 80077da:	3b1e      	subs	r3, #30
 80077dc:	4085      	lsls	r5, r0
 80077de:	fa28 f303 	lsr.w	r3, r8, r3
 80077e2:	ea45 0003 	orr.w	r0, r5, r3
 80077e6:	2201      	movs	r2, #1
 80077e8:	9216      	str	r2, [sp, #88]	; 0x58
 80077ea:	f003 f8a9 	bl	800a940 <__aeabi_ui2d>
 80077ee:	f5a6 6686 	sub.w	r6, r6, #1072	; 0x430
 80077f2:	3e03      	subs	r6, #3
 80077f4:	460b      	mov	r3, r1
 80077f6:	4602      	mov	r2, r0
 80077f8:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80077fc:	9b03      	ldr	r3, [sp, #12]
 80077fe:	f1a3 73f8 	sub.w	r3, r3, #32505856	; 0x1f00000
 8007802:	9303      	str	r3, [sp, #12]
 8007804:	e73e      	b.n	8007684 <_dtoa_r+0xd0>
 8007806:	bf00      	nop
 8007808:	636f4361 	.word	0x636f4361
 800780c:	3fd287a7 	.word	0x3fd287a7
 8007810:	8b60c8b3 	.word	0x8b60c8b3
 8007814:	3fc68a28 	.word	0x3fc68a28
 8007818:	509f79fb 	.word	0x509f79fb
 800781c:	3fd34413 	.word	0x3fd34413
 8007820:	0800bb85 	.word	0x0800bb85
 8007824:	2000      	movs	r0, #0
 8007826:	f04f 31ff 	mov.w	r1, #4294967295
 800782a:	4607      	mov	r7, r0
 800782c:	2201      	movs	r2, #1
 800782e:	9028      	str	r0, [sp, #160]	; 0xa0
 8007830:	910e      	str	r1, [sp, #56]	; 0x38
 8007832:	9210      	str	r2, [sp, #64]	; 0x40
 8007834:	910a      	str	r1, [sp, #40]	; 0x28
 8007836:	9029      	str	r0, [sp, #164]	; 0xa4
 8007838:	6a66      	ldr	r6, [r4, #36]	; 0x24
 800783a:	2300      	movs	r3, #0
 800783c:	6073      	str	r3, [r6, #4]
 800783e:	4620      	mov	r0, r4
 8007840:	6871      	ldr	r1, [r6, #4]
 8007842:	f000 ffcb 	bl	80087dc <_Balloc>
 8007846:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007848:	6030      	str	r0, [r6, #0]
 800784a:	681b      	ldr	r3, [r3, #0]
 800784c:	930c      	str	r3, [sp, #48]	; 0x30
 800784e:	2f00      	cmp	r7, #0
 8007850:	f000 80de 	beq.w	8007a10 <_dtoa_r+0x45c>
 8007854:	2d00      	cmp	r5, #0
 8007856:	4640      	mov	r0, r8
 8007858:	4649      	mov	r1, r9
 800785a:	e9cd 8908 	strd	r8, r9, [sp, #32]
 800785e:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8007862:	f340 842e 	ble.w	80080c2 <_dtoa_r+0xb0e>
 8007866:	f64b 0308 	movw	r3, #47112	; 0xb808
 800786a:	f005 020f 	and.w	r2, r5, #15
 800786e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8007872:	112e      	asrs	r6, r5, #4
 8007874:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8007878:	f016 0f10 	tst.w	r6, #16
 800787c:	bf08      	it	eq
 800787e:	f04f 0802 	moveq.w	r8, #2
 8007882:	e9d3 0100 	ldrd	r0, r1, [r3]
 8007886:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
 800788a:	f040 8247 	bne.w	8007d1c <_dtoa_r+0x768>
 800788e:	b1be      	cbz	r6, 80078c0 <_dtoa_r+0x30c>
 8007890:	f64b 07d0 	movw	r7, #47312	; 0xb8d0
 8007894:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 8007898:	f6c0 0700 	movt	r7, #2048	; 0x800
 800789c:	f016 0f01 	tst.w	r6, #1
 80078a0:	4610      	mov	r0, r2
 80078a2:	4619      	mov	r1, r3
 80078a4:	d007      	beq.n	80078b6 <_dtoa_r+0x302>
 80078a6:	e9d7 2300 	ldrd	r2, r3, [r7]
 80078aa:	f108 0801 	add.w	r8, r8, #1
 80078ae:	f003 f8bd 	bl	800aa2c <__aeabi_dmul>
 80078b2:	4602      	mov	r2, r0
 80078b4:	460b      	mov	r3, r1
 80078b6:	3708      	adds	r7, #8
 80078b8:	1076      	asrs	r6, r6, #1
 80078ba:	d1ef      	bne.n	800789c <_dtoa_r+0x2e8>
 80078bc:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
 80078c0:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80078c4:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 80078c8:	f003 f9da 	bl	800ac80 <__aeabi_ddiv>
 80078cc:	e9cd 0108 	strd	r0, r1, [sp, #32]
 80078d0:	9915      	ldr	r1, [sp, #84]	; 0x54
 80078d2:	2900      	cmp	r1, #0
 80078d4:	d038      	beq.n	8007948 <_dtoa_r+0x394>
 80078d6:	2300      	movs	r3, #0
 80078d8:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80078dc:	2200      	movs	r2, #0
 80078de:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
 80078e2:	2601      	movs	r6, #1
 80078e4:	f003 fb14 	bl	800af10 <__aeabi_dcmplt>
 80078e8:	2800      	cmp	r0, #0
 80078ea:	f000 8301 	beq.w	8007ef0 <_dtoa_r+0x93c>
 80078ee:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80078f0:	2a00      	cmp	r2, #0
 80078f2:	bfd4      	ite	le
 80078f4:	2600      	movle	r6, #0
 80078f6:	f006 0601 	andgt.w	r6, r6, #1
 80078fa:	b32e      	cbz	r6, 8007948 <_dtoa_r+0x394>
 80078fc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80078fe:	2b00      	cmp	r3, #0
 8007900:	f340 8082 	ble.w	8007a08 <_dtoa_r+0x454>
 8007904:	2300      	movs	r3, #0
 8007906:	2200      	movs	r2, #0
 8007908:	f2c4 0324 	movt	r3, #16420	; 0x4024
 800790c:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8007910:	f003 f88c 	bl	800aa2c <__aeabi_dmul>
 8007914:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8007918:	f108 0001 	add.w	r0, r8, #1
 800791c:	1e69      	subs	r1, r5, #1
 800791e:	9112      	str	r1, [sp, #72]	; 0x48
 8007920:	f003 f81e 	bl	800a960 <__aeabi_i2d>
 8007924:	4602      	mov	r2, r0
 8007926:	460b      	mov	r3, r1
 8007928:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800792c:	f003 f87e 	bl	800aa2c <__aeabi_dmul>
 8007930:	2300      	movs	r3, #0
 8007932:	2200      	movs	r2, #0
 8007934:	f2c4 031c 	movt	r3, #16412	; 0x401c
 8007938:	f002 fec6 	bl	800a6c8 <__adddf3>
 800793c:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
 8007940:	4680      	mov	r8, r0
 8007942:	f1a1 7950 	sub.w	r9, r1, #54525952	; 0x3400000
 8007946:	e23c      	b.n	8007dc2 <_dtoa_r+0x80e>
 8007948:	4640      	mov	r0, r8
 800794a:	f003 f809 	bl	800a960 <__aeabi_i2d>
 800794e:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8007952:	f003 f86b 	bl	800aa2c <__aeabi_dmul>
 8007956:	2300      	movs	r3, #0
 8007958:	2200      	movs	r2, #0
 800795a:	f2c4 031c 	movt	r3, #16412	; 0x401c
 800795e:	f002 feb3 	bl	800a6c8 <__adddf3>
 8007962:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8007964:	f1a1 7650 	sub.w	r6, r1, #54525952	; 0x3400000
 8007968:	4680      	mov	r8, r0
 800796a:	46b1      	mov	r9, r6
 800796c:	2a00      	cmp	r2, #0
 800796e:	f040 8225 	bne.w	8007dbc <_dtoa_r+0x808>
 8007972:	2300      	movs	r3, #0
 8007974:	2200      	movs	r2, #0
 8007976:	f2c4 0314 	movt	r3, #16404	; 0x4014
 800797a:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800797e:	f002 fea1 	bl	800a6c4 <__aeabi_dsub>
 8007982:	4642      	mov	r2, r8
 8007984:	4633      	mov	r3, r6
 8007986:	e9cd 0108 	strd	r0, r1, [sp, #32]
 800798a:	f003 fadf 	bl	800af4c <__aeabi_dcmpgt>
 800798e:	2800      	cmp	r0, #0
 8007990:	f040 820f 	bne.w	8007db2 <_dtoa_r+0x7fe>
 8007994:	4642      	mov	r2, r8
 8007996:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800799a:	f106 4300 	add.w	r3, r6, #2147483648	; 0x80000000
 800799e:	f003 fab7 	bl	800af10 <__aeabi_dcmplt>
 80079a2:	2800      	cmp	r0, #0
 80079a4:	d030      	beq.n	8007a08 <_dtoa_r+0x454>
 80079a6:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 80079aa:	f8cd b020 	str.w	fp, [sp, #32]
 80079ae:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 80079b0:	2700      	movs	r7, #0
 80079b2:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 80079b4:	43dd      	mvns	r5, r3
 80079b6:	4659      	mov	r1, fp
 80079b8:	4620      	mov	r0, r4
 80079ba:	f000 ff43 	bl	8008844 <_Bfree>
 80079be:	9908      	ldr	r1, [sp, #32]
 80079c0:	b171      	cbz	r1, 80079e0 <_dtoa_r+0x42c>
 80079c2:	1e3b      	subs	r3, r7, #0
 80079c4:	bf18      	it	ne
 80079c6:	2301      	movne	r3, #1
 80079c8:	428f      	cmp	r7, r1
 80079ca:	bf0c      	ite	eq
 80079cc:	2300      	moveq	r3, #0
 80079ce:	f003 0301 	andne.w	r3, r3, #1
 80079d2:	2b00      	cmp	r3, #0
 80079d4:	f040 835e 	bne.w	8008094 <_dtoa_r+0xae0>
 80079d8:	4620      	mov	r0, r4
 80079da:	9908      	ldr	r1, [sp, #32]
 80079dc:	f000 ff32 	bl	8008844 <_Bfree>
 80079e0:	4620      	mov	r0, r4
 80079e2:	4651      	mov	r1, sl
 80079e4:	f000 ff2e 	bl	8008844 <_Bfree>
 80079e8:	2300      	movs	r3, #0
 80079ea:	7033      	strb	r3, [r6, #0]
 80079ec:	3501      	adds	r5, #1
 80079ee:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 80079f0:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 80079f2:	6015      	str	r5, [r2, #0]
 80079f4:	2b00      	cmp	r3, #0
 80079f6:	f000 8418 	beq.w	800822a <_dtoa_r+0xc76>
 80079fa:	601e      	str	r6, [r3, #0]
 80079fc:	980c      	ldr	r0, [sp, #48]	; 0x30
 80079fe:	e61b      	b.n	8007638 <_dtoa_r+0x84>
 8007a00:	9d18      	ldr	r5, [sp, #96]	; 0x60
 8007a02:	f8dd a05c 	ldr.w	sl, [sp, #92]	; 0x5c
 8007a06:	9c08      	ldr	r4, [sp, #32]
 8007a08:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8007a0c:	4680      	mov	r8, r0
 8007a0e:	4689      	mov	r9, r1
 8007a10:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8007a12:	43df      	mvns	r7, r3
 8007a14:	0fff      	lsrs	r7, r7, #31
 8007a16:	2d0e      	cmp	r5, #14
 8007a18:	bfcc      	ite	gt
 8007a1a:	2700      	movgt	r7, #0
 8007a1c:	f007 0701 	andle.w	r7, r7, #1
 8007a20:	2f00      	cmp	r7, #0
 8007a22:	f000 80c1 	beq.w	8007ba8 <_dtoa_r+0x5f4>
 8007a26:	f64b 0308 	movw	r3, #47112	; 0xb808
 8007a2a:	9929      	ldr	r1, [sp, #164]	; 0xa4
 8007a2c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8007a30:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8007a32:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 8007a36:	0fcf      	lsrs	r7, r1, #31
 8007a38:	e9d3 0100 	ldrd	r0, r1, [r3]
 8007a3c:	2a00      	cmp	r2, #0
 8007a3e:	bfcc      	ite	gt
 8007a40:	2700      	movgt	r7, #0
 8007a42:	f007 0701 	andle.w	r7, r7, #1
 8007a46:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8007a4a:	2f00      	cmp	r7, #0
 8007a4c:	f040 819e 	bne.w	8007d8c <_dtoa_r+0x7d8>
 8007a50:	4602      	mov	r2, r0
 8007a52:	460b      	mov	r3, r1
 8007a54:	4640      	mov	r0, r8
 8007a56:	4649      	mov	r1, r9
 8007a58:	e9cd 8904 	strd	r8, r9, [sp, #16]
 8007a5c:	f003 f910 	bl	800ac80 <__aeabi_ddiv>
 8007a60:	f003 fa7e 	bl	800af60 <__aeabi_d2iz>
 8007a64:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8007a66:	4681      	mov	r9, r0
 8007a68:	f002 ff7a 	bl	800a960 <__aeabi_i2d>
 8007a6c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8007a70:	f002 ffdc 	bl	800aa2c <__aeabi_dmul>
 8007a74:	4602      	mov	r2, r0
 8007a76:	460b      	mov	r3, r1
 8007a78:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8007a7c:	f002 fe22 	bl	800a6c4 <__aeabi_dsub>
 8007a80:	f109 0330 	add.w	r3, r9, #48	; 0x30
 8007a84:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8007a88:	f806 3b01 	strb.w	r3, [r6], #1
 8007a8c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8007a8e:	2a01      	cmp	r2, #1
 8007a90:	d056      	beq.n	8007b40 <_dtoa_r+0x58c>
 8007a92:	2300      	movs	r3, #0
 8007a94:	2200      	movs	r2, #0
 8007a96:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8007a9a:	f04f 0801 	mov.w	r8, #1
 8007a9e:	f002 ffc5 	bl	800aa2c <__aeabi_dmul>
 8007aa2:	2200      	movs	r2, #0
 8007aa4:	2300      	movs	r3, #0
 8007aa6:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8007aaa:	f003 fa27 	bl	800aefc <__aeabi_dcmpeq>
 8007aae:	b100      	cbz	r0, 8007ab2 <_dtoa_r+0x4fe>
 8007ab0:	46b8      	mov	r8, r7
 8007ab2:	f018 0fff 	tst.w	r8, #255	; 0xff
 8007ab6:	d093      	beq.n	80079e0 <_dtoa_r+0x42c>
 8007ab8:	990a      	ldr	r1, [sp, #40]	; 0x28
 8007aba:	4637      	mov	r7, r6
 8007abc:	980c      	ldr	r0, [sp, #48]	; 0x30
 8007abe:	46a0      	mov	r8, r4
 8007ac0:	9507      	str	r5, [sp, #28]
 8007ac2:	eb00 0b01 	add.w	fp, r0, r1
 8007ac6:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
 8007aca:	465d      	mov	r5, fp
 8007acc:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 8007ad0:	e00d      	b.n	8007aee <_dtoa_r+0x53a>
 8007ad2:	f002 ffab 	bl	800aa2c <__aeabi_dmul>
 8007ad6:	2200      	movs	r2, #0
 8007ad8:	2300      	movs	r3, #0
 8007ada:	4682      	mov	sl, r0
 8007adc:	468b      	mov	fp, r1
 8007ade:	f003 fa0d 	bl	800aefc <__aeabi_dcmpeq>
 8007ae2:	b100      	cbz	r0, 8007ae6 <_dtoa_r+0x532>
 8007ae4:	2400      	movs	r4, #0
 8007ae6:	f014 0fff 	tst.w	r4, #255	; 0xff
 8007aea:	f000 840f 	beq.w	800830c <_dtoa_r+0xd58>
 8007aee:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8007af2:	4650      	mov	r0, sl
 8007af4:	4659      	mov	r1, fp
 8007af6:	2401      	movs	r4, #1
 8007af8:	f003 f8c2 	bl	800ac80 <__aeabi_ddiv>
 8007afc:	f003 fa30 	bl	800af60 <__aeabi_d2iz>
 8007b00:	4681      	mov	r9, r0
 8007b02:	f002 ff2d 	bl	800a960 <__aeabi_i2d>
 8007b06:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8007b0a:	f109 0630 	add.w	r6, r9, #48	; 0x30
 8007b0e:	f002 ff8d 	bl	800aa2c <__aeabi_dmul>
 8007b12:	4602      	mov	r2, r0
 8007b14:	460b      	mov	r3, r1
 8007b16:	4650      	mov	r0, sl
 8007b18:	4659      	mov	r1, fp
 8007b1a:	f002 fdd3 	bl	800a6c4 <__aeabi_dsub>
 8007b1e:	2300      	movs	r3, #0
 8007b20:	f807 6b01 	strb.w	r6, [r7], #1
 8007b24:	2200      	movs	r2, #0
 8007b26:	42af      	cmp	r7, r5
 8007b28:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8007b2c:	463e      	mov	r6, r7
 8007b2e:	4682      	mov	sl, r0
 8007b30:	468b      	mov	fp, r1
 8007b32:	d1ce      	bne.n	8007ad2 <_dtoa_r+0x51e>
 8007b34:	e9cd ab04 	strd	sl, fp, [sp, #16]
 8007b38:	4644      	mov	r4, r8
 8007b3a:	9d07      	ldr	r5, [sp, #28]
 8007b3c:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 8007b40:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8007b44:	4602      	mov	r2, r0
 8007b46:	460b      	mov	r3, r1
 8007b48:	f002 fdbe 	bl	800a6c8 <__adddf3>
 8007b4c:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8007b50:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8007b54:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8007b58:	f003 f9da 	bl	800af10 <__aeabi_dcmplt>
 8007b5c:	b960      	cbnz	r0, 8007b78 <_dtoa_r+0x5c4>
 8007b5e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8007b62:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8007b66:	f003 f9c9 	bl	800aefc <__aeabi_dcmpeq>
 8007b6a:	2800      	cmp	r0, #0
 8007b6c:	f43f af38 	beq.w	80079e0 <_dtoa_r+0x42c>
 8007b70:	f019 0f01 	tst.w	r9, #1
 8007b74:	f43f af34 	beq.w	80079e0 <_dtoa_r+0x42c>
 8007b78:	9512      	str	r5, [sp, #72]	; 0x48
 8007b7a:	980c      	ldr	r0, [sp, #48]	; 0x30
 8007b7c:	4633      	mov	r3, r6
 8007b7e:	f813 1c01 	ldrb.w	r1, [r3, #-1]
 8007b82:	1e5a      	subs	r2, r3, #1
 8007b84:	461e      	mov	r6, r3
 8007b86:	4613      	mov	r3, r2
 8007b88:	2939      	cmp	r1, #57	; 0x39
 8007b8a:	f040 83e1 	bne.w	8008350 <_dtoa_r+0xd9c>
 8007b8e:	4283      	cmp	r3, r0
 8007b90:	d1f5      	bne.n	8007b7e <_dtoa_r+0x5ca>
 8007b92:	980c      	ldr	r0, [sp, #48]	; 0x30
 8007b94:	2131      	movs	r1, #49	; 0x31
 8007b96:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8007b98:	1c5d      	adds	r5, r3, #1
 8007b9a:	2330      	movs	r3, #48	; 0x30
 8007b9c:	7003      	strb	r3, [r0, #0]
 8007b9e:	7011      	strb	r1, [r2, #0]
 8007ba0:	e71e      	b.n	80079e0 <_dtoa_r+0x42c>
 8007ba2:	2101      	movs	r1, #1
 8007ba4:	9115      	str	r1, [sp, #84]	; 0x54
 8007ba6:	e5b9      	b.n	800771c <_dtoa_r+0x168>
 8007ba8:	9910      	ldr	r1, [sp, #64]	; 0x40
 8007baa:	2900      	cmp	r1, #0
 8007bac:	f040 80c7 	bne.w	8007d3e <_dtoa_r+0x78a>
 8007bb0:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007bb2:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 8007bb4:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 8007bb6:	9308      	str	r3, [sp, #32]
 8007bb8:	2e00      	cmp	r6, #0
 8007bba:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8007bbc:	bfd4      	ite	le
 8007bbe:	2300      	movle	r3, #0
 8007bc0:	2301      	movgt	r3, #1
 8007bc2:	2800      	cmp	r0, #0
 8007bc4:	bfd4      	ite	le
 8007bc6:	2300      	movle	r3, #0
 8007bc8:	f003 0301 	andgt.w	r3, r3, #1
 8007bcc:	b14b      	cbz	r3, 8007be2 <_dtoa_r+0x62e>
 8007bce:	4603      	mov	r3, r0
 8007bd0:	990d      	ldr	r1, [sp, #52]	; 0x34
 8007bd2:	42b3      	cmp	r3, r6
 8007bd4:	bfa8      	it	ge
 8007bd6:	4633      	movge	r3, r6
 8007bd8:	1af6      	subs	r6, r6, r3
 8007bda:	1ac9      	subs	r1, r1, r3
 8007bdc:	1ac0      	subs	r0, r0, r3
 8007bde:	910d      	str	r1, [sp, #52]	; 0x34
 8007be0:	900b      	str	r0, [sp, #44]	; 0x2c
 8007be2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8007be4:	2a00      	cmp	r2, #0
 8007be6:	dd1a      	ble.n	8007c1e <_dtoa_r+0x66a>
 8007be8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007bea:	2b00      	cmp	r3, #0
 8007bec:	f000 8394 	beq.w	8008318 <_dtoa_r+0xd64>
 8007bf0:	2f00      	cmp	r7, #0
 8007bf2:	dd10      	ble.n	8007c16 <_dtoa_r+0x662>
 8007bf4:	9908      	ldr	r1, [sp, #32]
 8007bf6:	463a      	mov	r2, r7
 8007bf8:	4620      	mov	r0, r4
 8007bfa:	f000 ffbd 	bl	8008b78 <__pow5mult>
 8007bfe:	4652      	mov	r2, sl
 8007c00:	9008      	str	r0, [sp, #32]
 8007c02:	4620      	mov	r0, r4
 8007c04:	9908      	ldr	r1, [sp, #32]
 8007c06:	f000 ff23 	bl	8008a50 <__multiply>
 8007c0a:	4651      	mov	r1, sl
 8007c0c:	4683      	mov	fp, r0
 8007c0e:	4620      	mov	r0, r4
 8007c10:	f000 fe18 	bl	8008844 <_Bfree>
 8007c14:	46da      	mov	sl, fp
 8007c16:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007c18:	1bc2      	subs	r2, r0, r7
 8007c1a:	f040 8384 	bne.w	8008326 <_dtoa_r+0xd72>
 8007c1e:	2101      	movs	r1, #1
 8007c20:	4620      	mov	r0, r4
 8007c22:	f000 ff0b 	bl	8008a3c <__i2b>
 8007c26:	9911      	ldr	r1, [sp, #68]	; 0x44
 8007c28:	2900      	cmp	r1, #0
 8007c2a:	4683      	mov	fp, r0
 8007c2c:	dd05      	ble.n	8007c3a <_dtoa_r+0x686>
 8007c2e:	4659      	mov	r1, fp
 8007c30:	4620      	mov	r0, r4
 8007c32:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8007c34:	f000 ffa0 	bl	8008b78 <__pow5mult>
 8007c38:	4683      	mov	fp, r0
 8007c3a:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8007c3c:	2a01      	cmp	r2, #1
 8007c3e:	f340 819e 	ble.w	8007f7e <_dtoa_r+0x9ca>
 8007c42:	2700      	movs	r7, #0
 8007c44:	9911      	ldr	r1, [sp, #68]	; 0x44
 8007c46:	2900      	cmp	r1, #0
 8007c48:	f040 82f2 	bne.w	8008230 <_dtoa_r+0xc7c>
 8007c4c:	2301      	movs	r3, #1
 8007c4e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8007c50:	189b      	adds	r3, r3, r2
 8007c52:	f013 031f 	ands.w	r3, r3, #31
 8007c56:	f000 8222 	beq.w	800809e <_dtoa_r+0xaea>
 8007c5a:	f1c3 0320 	rsb	r3, r3, #32
 8007c5e:	2b04      	cmp	r3, #4
 8007c60:	f340 83f6 	ble.w	8008450 <_dtoa_r+0xe9c>
 8007c64:	3b04      	subs	r3, #4
 8007c66:	980d      	ldr	r0, [sp, #52]	; 0x34
 8007c68:	18f6      	adds	r6, r6, r3
 8007c6a:	18d2      	adds	r2, r2, r3
 8007c6c:	18c0      	adds	r0, r0, r3
 8007c6e:	920b      	str	r2, [sp, #44]	; 0x2c
 8007c70:	900d      	str	r0, [sp, #52]	; 0x34
 8007c72:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007c74:	2b00      	cmp	r3, #0
 8007c76:	dd05      	ble.n	8007c84 <_dtoa_r+0x6d0>
 8007c78:	4651      	mov	r1, sl
 8007c7a:	4620      	mov	r0, r4
 8007c7c:	461a      	mov	r2, r3
 8007c7e:	f000 ffcd 	bl	8008c1c <__lshift>
 8007c82:	4682      	mov	sl, r0
 8007c84:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8007c86:	2800      	cmp	r0, #0
 8007c88:	dd05      	ble.n	8007c96 <_dtoa_r+0x6e2>
 8007c8a:	4659      	mov	r1, fp
 8007c8c:	4620      	mov	r0, r4
 8007c8e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8007c90:	f000 ffc4 	bl	8008c1c <__lshift>
 8007c94:	4683      	mov	fp, r0
 8007c96:	9915      	ldr	r1, [sp, #84]	; 0x54
 8007c98:	2900      	cmp	r1, #0
 8007c9a:	f040 82d3 	bne.w	8008244 <_dtoa_r+0xc90>
 8007c9e:	9928      	ldr	r1, [sp, #160]	; 0xa0
 8007ca0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8007ca2:	2902      	cmp	r1, #2
 8007ca4:	bfd4      	ite	le
 8007ca6:	2300      	movle	r3, #0
 8007ca8:	2301      	movgt	r3, #1
 8007caa:	2a00      	cmp	r2, #0
 8007cac:	bfcc      	ite	gt
 8007cae:	2300      	movgt	r3, #0
 8007cb0:	f003 0301 	andle.w	r3, r3, #1
 8007cb4:	2b00      	cmp	r3, #0
 8007cb6:	f000 817c 	beq.w	8007fb2 <_dtoa_r+0x9fe>
 8007cba:	2a00      	cmp	r2, #0
 8007cbc:	f47f ae77 	bne.w	80079ae <_dtoa_r+0x3fa>
 8007cc0:	4659      	mov	r1, fp
 8007cc2:	2205      	movs	r2, #5
 8007cc4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007cc6:	4620      	mov	r0, r4
 8007cc8:	f000 fdd8 	bl	800887c <__multadd>
 8007ccc:	4683      	mov	fp, r0
 8007cce:	4650      	mov	r0, sl
 8007cd0:	4659      	mov	r1, fp
 8007cd2:	f000 fff9 	bl	8008cc8 <__mcmp>
 8007cd6:	2800      	cmp	r0, #0
 8007cd8:	f77f ae69 	ble.w	80079ae <_dtoa_r+0x3fa>
 8007cdc:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8007cde:	2331      	movs	r3, #49	; 0x31
 8007ce0:	3501      	adds	r5, #1
 8007ce2:	2700      	movs	r7, #0
 8007ce4:	f806 3b01 	strb.w	r3, [r6], #1
 8007ce8:	e665      	b.n	80079b6 <_dtoa_r+0x402>
 8007cea:	2010      	movs	r0, #16
 8007cec:	f7fc ffc8 	bl	8004c80 <malloc>
 8007cf0:	6260      	str	r0, [r4, #36]	; 0x24
 8007cf2:	6045      	str	r5, [r0, #4]
 8007cf4:	6085      	str	r5, [r0, #8]
 8007cf6:	6005      	str	r5, [r0, #0]
 8007cf8:	60c5      	str	r5, [r0, #12]
 8007cfa:	e473      	b.n	80075e4 <_dtoa_r+0x30>
 8007cfc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007cfe:	4268      	negs	r0, r5
 8007d00:	2100      	movs	r1, #0
 8007d02:	900f      	str	r0, [sp, #60]	; 0x3c
 8007d04:	1b5b      	subs	r3, r3, r5
 8007d06:	9111      	str	r1, [sp, #68]	; 0x44
 8007d08:	930d      	str	r3, [sp, #52]	; 0x34
 8007d0a:	e517      	b.n	800773c <_dtoa_r+0x188>
 8007d0c:	4276      	negs	r6, r6
 8007d0e:	2300      	movs	r3, #0
 8007d10:	960d      	str	r6, [sp, #52]	; 0x34
 8007d12:	930b      	str	r3, [sp, #44]	; 0x2c
 8007d14:	e509      	b.n	800772a <_dtoa_r+0x176>
 8007d16:	2200      	movs	r2, #0
 8007d18:	9215      	str	r2, [sp, #84]	; 0x54
 8007d1a:	e4ff      	b.n	800771c <_dtoa_r+0x168>
 8007d1c:	f64b 03d0 	movw	r3, #47312	; 0xb8d0
 8007d20:	4640      	mov	r0, r8
 8007d22:	f6c0 0300 	movt	r3, #2048	; 0x800
 8007d26:	4649      	mov	r1, r9
 8007d28:	f006 060f 	and.w	r6, r6, #15
 8007d2c:	f04f 0803 	mov.w	r8, #3
 8007d30:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8007d34:	f002 ffa4 	bl	800ac80 <__aeabi_ddiv>
 8007d38:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8007d3c:	e5a7      	b.n	800788e <_dtoa_r+0x2da>
 8007d3e:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8007d40:	2a01      	cmp	r2, #1
 8007d42:	f340 82f6 	ble.w	8008332 <_dtoa_r+0xd7e>
 8007d46:	990a      	ldr	r1, [sp, #40]	; 0x28
 8007d48:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8007d4a:	1e4b      	subs	r3, r1, #1
 8007d4c:	429a      	cmp	r2, r3
 8007d4e:	bfa8      	it	ge
 8007d50:	ebc3 0702 	rsbge	r7, r3, r2
 8007d54:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8007d56:	bfbf      	itttt	lt
 8007d58:	980f      	ldrlt	r0, [sp, #60]	; 0x3c
 8007d5a:	9911      	ldrlt	r1, [sp, #68]	; 0x44
 8007d5c:	ebc0 0303 	rsblt	r3, r0, r3
 8007d60:	18c9      	addlt	r1, r1, r3
 8007d62:	bfbe      	ittt	lt
 8007d64:	18c0      	addlt	r0, r0, r3
 8007d66:	9111      	strlt	r1, [sp, #68]	; 0x44
 8007d68:	900f      	strlt	r0, [sp, #60]	; 0x3c
 8007d6a:	2a00      	cmp	r2, #0
 8007d6c:	f2c0 82f9 	blt.w	8008362 <_dtoa_r+0xdae>
 8007d70:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 8007d72:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007d74:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8007d76:	4620      	mov	r0, r4
 8007d78:	2101      	movs	r1, #1
 8007d7a:	18d2      	adds	r2, r2, r3
 8007d7c:	920d      	str	r2, [sp, #52]	; 0x34
 8007d7e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8007d80:	18d2      	adds	r2, r2, r3
 8007d82:	920b      	str	r2, [sp, #44]	; 0x2c
 8007d84:	f000 fe5a 	bl	8008a3c <__i2b>
 8007d88:	9008      	str	r0, [sp, #32]
 8007d8a:	e715      	b.n	8007bb8 <_dtoa_r+0x604>
 8007d8c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007d8e:	2b00      	cmp	r3, #0
 8007d90:	f040 82d8 	bne.w	8008344 <_dtoa_r+0xd90>
 8007d94:	2300      	movs	r3, #0
 8007d96:	2200      	movs	r2, #0
 8007d98:	f2c4 0314 	movt	r3, #16404	; 0x4014
 8007d9c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8007da0:	f002 fe44 	bl	800aa2c <__aeabi_dmul>
 8007da4:	4642      	mov	r2, r8
 8007da6:	464b      	mov	r3, r9
 8007da8:	f003 f8c6 	bl	800af38 <__aeabi_dcmpge>
 8007dac:	2800      	cmp	r0, #0
 8007dae:	f47f adfa 	bne.w	80079a6 <_dtoa_r+0x3f2>
 8007db2:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 8007db6:	f8cd b020 	str.w	fp, [sp, #32]
 8007dba:	e78f      	b.n	8007cdc <_dtoa_r+0x728>
 8007dbc:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 8007dc0:	9512      	str	r5, [sp, #72]	; 0x48
 8007dc2:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007dc4:	2b00      	cmp	r3, #0
 8007dc6:	f000 81af 	beq.w	8008128 <_dtoa_r+0xb74>
 8007dca:	f64b 0308 	movw	r3, #47112	; 0xb808
 8007dce:	2100      	movs	r1, #0
 8007dd0:	f6c0 0300 	movt	r3, #2048	; 0x800
 8007dd4:	2000      	movs	r0, #0
 8007dd6:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 8007dda:	f6c3 71e0 	movt	r1, #16352	; 0x3fe0
 8007dde:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8007de0:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 8007de4:	f002 ff4c 	bl	800ac80 <__aeabi_ddiv>
 8007de8:	4642      	mov	r2, r8
 8007dea:	464b      	mov	r3, r9
 8007dec:	f002 fc6a 	bl	800a6c4 <__aeabi_dsub>
 8007df0:	4680      	mov	r8, r0
 8007df2:	4689      	mov	r9, r1
 8007df4:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8007df8:	f003 f8b2 	bl	800af60 <__aeabi_d2iz>
 8007dfc:	4607      	mov	r7, r0
 8007dfe:	f002 fdaf 	bl	800a960 <__aeabi_i2d>
 8007e02:	4602      	mov	r2, r0
 8007e04:	460b      	mov	r3, r1
 8007e06:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8007e0a:	f002 fc5b 	bl	800a6c4 <__aeabi_dsub>
 8007e0e:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8007e12:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8007e16:	4640      	mov	r0, r8
 8007e18:	f806 3b01 	strb.w	r3, [r6], #1
 8007e1c:	4649      	mov	r1, r9
 8007e1e:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8007e22:	f003 f893 	bl	800af4c <__aeabi_dcmpgt>
 8007e26:	2800      	cmp	r0, #0
 8007e28:	f040 81fc 	bne.w	8008224 <_dtoa_r+0xc70>
 8007e2c:	2100      	movs	r1, #0
 8007e2e:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8007e32:	2000      	movs	r0, #0
 8007e34:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
 8007e38:	f002 fc44 	bl	800a6c4 <__aeabi_dsub>
 8007e3c:	4602      	mov	r2, r0
 8007e3e:	460b      	mov	r3, r1
 8007e40:	4640      	mov	r0, r8
 8007e42:	4649      	mov	r1, r9
 8007e44:	f003 f882 	bl	800af4c <__aeabi_dcmpgt>
 8007e48:	2800      	cmp	r0, #0
 8007e4a:	f47f ae96 	bne.w	8007b7a <_dtoa_r+0x5c6>
 8007e4e:	f1bb 0f01 	cmp.w	fp, #1
 8007e52:	f77f add9 	ble.w	8007a08 <_dtoa_r+0x454>
 8007e56:	980c      	ldr	r0, [sp, #48]	; 0x30
 8007e58:	4637      	mov	r7, r6
 8007e5a:	9518      	str	r5, [sp, #96]	; 0x60
 8007e5c:	4483      	add	fp, r0
 8007e5e:	f8cd a05c 	str.w	sl, [sp, #92]	; 0x5c
 8007e62:	465d      	mov	r5, fp
 8007e64:	e9dd ab08 	ldrd	sl, fp, [sp, #32]
 8007e68:	9408      	str	r4, [sp, #32]
 8007e6a:	e00f      	b.n	8007e8c <_dtoa_r+0x8d8>
 8007e6c:	2100      	movs	r1, #0
 8007e6e:	2000      	movs	r0, #0
 8007e70:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
 8007e74:	f002 fc26 	bl	800a6c4 <__aeabi_dsub>
 8007e78:	4642      	mov	r2, r8
 8007e7a:	464b      	mov	r3, r9
 8007e7c:	f003 f848 	bl	800af10 <__aeabi_dcmplt>
 8007e80:	2800      	cmp	r0, #0
 8007e82:	f040 826a 	bne.w	800835a <_dtoa_r+0xda6>
 8007e86:	42af      	cmp	r7, r5
 8007e88:	f43f adba 	beq.w	8007a00 <_dtoa_r+0x44c>
 8007e8c:	2300      	movs	r3, #0
 8007e8e:	2200      	movs	r2, #0
 8007e90:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8007e94:	4640      	mov	r0, r8
 8007e96:	4649      	mov	r1, r9
 8007e98:	f002 fdc8 	bl	800aa2c <__aeabi_dmul>
 8007e9c:	2300      	movs	r3, #0
 8007e9e:	2200      	movs	r2, #0
 8007ea0:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8007ea4:	4680      	mov	r8, r0
 8007ea6:	4689      	mov	r9, r1
 8007ea8:	4650      	mov	r0, sl
 8007eaa:	4659      	mov	r1, fp
 8007eac:	f002 fdbe 	bl	800aa2c <__aeabi_dmul>
 8007eb0:	468b      	mov	fp, r1
 8007eb2:	4682      	mov	sl, r0
 8007eb4:	f003 f854 	bl	800af60 <__aeabi_d2iz>
 8007eb8:	4604      	mov	r4, r0
 8007eba:	f002 fd51 	bl	800a960 <__aeabi_i2d>
 8007ebe:	3430      	adds	r4, #48	; 0x30
 8007ec0:	4602      	mov	r2, r0
 8007ec2:	460b      	mov	r3, r1
 8007ec4:	4650      	mov	r0, sl
 8007ec6:	4659      	mov	r1, fp
 8007ec8:	f002 fbfc 	bl	800a6c4 <__aeabi_dsub>
 8007ecc:	4642      	mov	r2, r8
 8007ece:	464b      	mov	r3, r9
 8007ed0:	f807 4b01 	strb.w	r4, [r7], #1
 8007ed4:	463e      	mov	r6, r7
 8007ed6:	4682      	mov	sl, r0
 8007ed8:	468b      	mov	fp, r1
 8007eda:	f003 f819 	bl	800af10 <__aeabi_dcmplt>
 8007ede:	4652      	mov	r2, sl
 8007ee0:	465b      	mov	r3, fp
 8007ee2:	2800      	cmp	r0, #0
 8007ee4:	d0c2      	beq.n	8007e6c <_dtoa_r+0x8b8>
 8007ee6:	f8dd a05c 	ldr.w	sl, [sp, #92]	; 0x5c
 8007eea:	9c08      	ldr	r4, [sp, #32]
 8007eec:	9d12      	ldr	r5, [sp, #72]	; 0x48
 8007eee:	e577      	b.n	80079e0 <_dtoa_r+0x42c>
 8007ef0:	2600      	movs	r6, #0
 8007ef2:	e4fc      	b.n	80078ee <_dtoa_r+0x33a>
 8007ef4:	2301      	movs	r3, #1
 8007ef6:	9310      	str	r3, [sp, #64]	; 0x40
 8007ef8:	9929      	ldr	r1, [sp, #164]	; 0xa4
 8007efa:	2900      	cmp	r1, #0
 8007efc:	bfc2      	ittt	gt
 8007efe:	468b      	movgt	fp, r1
 8007f00:	910e      	strgt	r1, [sp, #56]	; 0x38
 8007f02:	910a      	strgt	r1, [sp, #40]	; 0x28
 8007f04:	f340 81b4 	ble.w	8008270 <_dtoa_r+0xcbc>
 8007f08:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8007f0a:	2200      	movs	r2, #0
 8007f0c:	f1bb 0f17 	cmp.w	fp, #23
 8007f10:	6072      	str	r2, [r6, #4]
 8007f12:	f240 82a1 	bls.w	8008458 <_dtoa_r+0xea4>
 8007f16:	2304      	movs	r3, #4
 8007f18:	005b      	lsls	r3, r3, #1
 8007f1a:	3201      	adds	r2, #1
 8007f1c:	f103 0114 	add.w	r1, r3, #20
 8007f20:	4559      	cmp	r1, fp
 8007f22:	d9f9      	bls.n	8007f18 <_dtoa_r+0x964>
 8007f24:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007f26:	6072      	str	r2, [r6, #4]
 8007f28:	2b0e      	cmp	r3, #14
 8007f2a:	bf8c      	ite	hi
 8007f2c:	2700      	movhi	r7, #0
 8007f2e:	f007 0701 	andls.w	r7, r7, #1
 8007f32:	e484      	b.n	800783e <_dtoa_r+0x28a>
 8007f34:	2300      	movs	r3, #0
 8007f36:	9310      	str	r3, [sp, #64]	; 0x40
 8007f38:	9829      	ldr	r0, [sp, #164]	; 0xa4
 8007f3a:	1828      	adds	r0, r5, r0
 8007f3c:	900e      	str	r0, [sp, #56]	; 0x38
 8007f3e:	f100 0b01 	add.w	fp, r0, #1
 8007f42:	f1bb 0f00 	cmp.w	fp, #0
 8007f46:	bfc8      	it	gt
 8007f48:	f8cd b028 	strgt.w	fp, [sp, #40]	; 0x28
 8007f4c:	dcdc      	bgt.n	8007f08 <_dtoa_r+0x954>
 8007f4e:	f1bb 0f0e 	cmp.w	fp, #14
 8007f52:	bf8c      	ite	hi
 8007f54:	2700      	movhi	r7, #0
 8007f56:	f007 0701 	andls.w	r7, r7, #1
 8007f5a:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
 8007f5e:	e46b      	b.n	8007838 <_dtoa_r+0x284>
 8007f60:	2000      	movs	r0, #0
 8007f62:	9010      	str	r0, [sp, #64]	; 0x40
 8007f64:	e7c8      	b.n	8007ef8 <_dtoa_r+0x944>
 8007f66:	2201      	movs	r2, #1
 8007f68:	9210      	str	r2, [sp, #64]	; 0x40
 8007f6a:	e7e5      	b.n	8007f38 <_dtoa_r+0x984>
 8007f6c:	f04f 33ff 	mov.w	r3, #4294967295
 8007f70:	2700      	movs	r7, #0
 8007f72:	2001      	movs	r0, #1
 8007f74:	930e      	str	r3, [sp, #56]	; 0x38
 8007f76:	9010      	str	r0, [sp, #64]	; 0x40
 8007f78:	930a      	str	r3, [sp, #40]	; 0x28
 8007f7a:	9729      	str	r7, [sp, #164]	; 0xa4
 8007f7c:	e45c      	b.n	8007838 <_dtoa_r+0x284>
 8007f7e:	f1b8 0f00 	cmp.w	r8, #0
 8007f82:	f47f ae5e 	bne.w	8007c42 <_dtoa_r+0x68e>
 8007f86:	f3c9 0313 	ubfx	r3, r9, #0, #20
 8007f8a:	4647      	mov	r7, r8
 8007f8c:	2b00      	cmp	r3, #0
 8007f8e:	f47f ae59 	bne.w	8007c44 <_dtoa_r+0x690>
 8007f92:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 8007f96:	ea09 0303 	and.w	r3, r9, r3
 8007f9a:	461f      	mov	r7, r3
 8007f9c:	2b00      	cmp	r3, #0
 8007f9e:	f43f ae51 	beq.w	8007c44 <_dtoa_r+0x690>
 8007fa2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007fa4:	2701      	movs	r7, #1
 8007fa6:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8007fa8:	3301      	adds	r3, #1
 8007faa:	930d      	str	r3, [sp, #52]	; 0x34
 8007fac:	3001      	adds	r0, #1
 8007fae:	900b      	str	r0, [sp, #44]	; 0x2c
 8007fb0:	e648      	b.n	8007c44 <_dtoa_r+0x690>
 8007fb2:	9810      	ldr	r0, [sp, #64]	; 0x40
 8007fb4:	2800      	cmp	r0, #0
 8007fb6:	f000 8161 	beq.w	800827c <_dtoa_r+0xcc8>
 8007fba:	2e00      	cmp	r6, #0
 8007fbc:	dd05      	ble.n	8007fca <_dtoa_r+0xa16>
 8007fbe:	4620      	mov	r0, r4
 8007fc0:	9908      	ldr	r1, [sp, #32]
 8007fc2:	4632      	mov	r2, r6
 8007fc4:	f000 fe2a 	bl	8008c1c <__lshift>
 8007fc8:	9008      	str	r0, [sp, #32]
 8007fca:	2f00      	cmp	r7, #0
 8007fcc:	f040 81ed 	bne.w	80083aa <_dtoa_r+0xdf6>
 8007fd0:	9808      	ldr	r0, [sp, #32]
 8007fd2:	9002      	str	r0, [sp, #8]
 8007fd4:	990a      	ldr	r1, [sp, #40]	; 0x28
 8007fd6:	f008 0201 	and.w	r2, r8, #1
 8007fda:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8007fdc:	9f08      	ldr	r7, [sp, #32]
 8007fde:	1871      	adds	r1, r6, r1
 8007fe0:	920a      	str	r2, [sp, #40]	; 0x28
 8007fe2:	910b      	str	r1, [sp, #44]	; 0x2c
 8007fe4:	9508      	str	r5, [sp, #32]
 8007fe6:	4659      	mov	r1, fp
 8007fe8:	4650      	mov	r0, sl
 8007fea:	f7ff fa4d 	bl	8007488 <quorem>
 8007fee:	4639      	mov	r1, r7
 8007ff0:	f04f 0901 	mov.w	r9, #1
 8007ff4:	3030      	adds	r0, #48	; 0x30
 8007ff6:	9007      	str	r0, [sp, #28]
 8007ff8:	4650      	mov	r0, sl
 8007ffa:	f000 fe65 	bl	8008cc8 <__mcmp>
 8007ffe:	4659      	mov	r1, fp
 8008000:	9a02      	ldr	r2, [sp, #8]
 8008002:	4605      	mov	r5, r0
 8008004:	4620      	mov	r0, r4
 8008006:	f000 fe7d 	bl	8008d04 <__mdiff>
 800800a:	68c3      	ldr	r3, [r0, #12]
 800800c:	4680      	mov	r8, r0
 800800e:	2b00      	cmp	r3, #0
 8008010:	d03a      	beq.n	8008088 <_dtoa_r+0xad4>
 8008012:	4620      	mov	r0, r4
 8008014:	4641      	mov	r1, r8
 8008016:	f000 fc15 	bl	8008844 <_Bfree>
 800801a:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 800801c:	ea59 0303 	orrs.w	r3, r9, r3
 8008020:	d103      	bne.n	800802a <_dtoa_r+0xa76>
 8008022:	980a      	ldr	r0, [sp, #40]	; 0x28
 8008024:	2800      	cmp	r0, #0
 8008026:	f000 81f3 	beq.w	8008410 <_dtoa_r+0xe5c>
 800802a:	2d00      	cmp	r5, #0
 800802c:	f2c0 819d 	blt.w	800836a <_dtoa_r+0xdb6>
 8008030:	9828      	ldr	r0, [sp, #160]	; 0xa0
 8008032:	4328      	orrs	r0, r5
 8008034:	d103      	bne.n	800803e <_dtoa_r+0xa8a>
 8008036:	990a      	ldr	r1, [sp, #40]	; 0x28
 8008038:	2900      	cmp	r1, #0
 800803a:	f000 8196 	beq.w	800836a <_dtoa_r+0xdb6>
 800803e:	f1b9 0f00 	cmp.w	r9, #0
 8008042:	f300 81d2 	bgt.w	80083ea <_dtoa_r+0xe36>
 8008046:	9a07      	ldr	r2, [sp, #28]
 8008048:	f806 2b01 	strb.w	r2, [r6], #1
 800804c:	46b0      	mov	r8, r6
 800804e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008050:	429e      	cmp	r6, r3
 8008052:	f000 81c6 	beq.w	80083e2 <_dtoa_r+0xe2e>
 8008056:	4651      	mov	r1, sl
 8008058:	220a      	movs	r2, #10
 800805a:	2300      	movs	r3, #0
 800805c:	4620      	mov	r0, r4
 800805e:	f000 fc0d 	bl	800887c <__multadd>
 8008062:	4682      	mov	sl, r0
 8008064:	9802      	ldr	r0, [sp, #8]
 8008066:	4287      	cmp	r7, r0
 8008068:	d022      	beq.n	80080b0 <_dtoa_r+0xafc>
 800806a:	4639      	mov	r1, r7
 800806c:	220a      	movs	r2, #10
 800806e:	2300      	movs	r3, #0
 8008070:	4620      	mov	r0, r4
 8008072:	f000 fc03 	bl	800887c <__multadd>
 8008076:	9902      	ldr	r1, [sp, #8]
 8008078:	220a      	movs	r2, #10
 800807a:	2300      	movs	r3, #0
 800807c:	4607      	mov	r7, r0
 800807e:	4620      	mov	r0, r4
 8008080:	f000 fbfc 	bl	800887c <__multadd>
 8008084:	9002      	str	r0, [sp, #8]
 8008086:	e7ae      	b.n	8007fe6 <_dtoa_r+0xa32>
 8008088:	4650      	mov	r0, sl
 800808a:	4641      	mov	r1, r8
 800808c:	f000 fe1c 	bl	8008cc8 <__mcmp>
 8008090:	4681      	mov	r9, r0
 8008092:	e7be      	b.n	8008012 <_dtoa_r+0xa5e>
 8008094:	4620      	mov	r0, r4
 8008096:	4639      	mov	r1, r7
 8008098:	f000 fbd4 	bl	8008844 <_Bfree>
 800809c:	e49c      	b.n	80079d8 <_dtoa_r+0x424>
 800809e:	231c      	movs	r3, #28
 80080a0:	990d      	ldr	r1, [sp, #52]	; 0x34
 80080a2:	18f6      	adds	r6, r6, r3
 80080a4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80080a6:	18c9      	adds	r1, r1, r3
 80080a8:	910d      	str	r1, [sp, #52]	; 0x34
 80080aa:	18d2      	adds	r2, r2, r3
 80080ac:	920b      	str	r2, [sp, #44]	; 0x2c
 80080ae:	e5e0      	b.n	8007c72 <_dtoa_r+0x6be>
 80080b0:	4639      	mov	r1, r7
 80080b2:	4620      	mov	r0, r4
 80080b4:	220a      	movs	r2, #10
 80080b6:	2300      	movs	r3, #0
 80080b8:	f000 fbe0 	bl	800887c <__multadd>
 80080bc:	4607      	mov	r7, r0
 80080be:	9002      	str	r0, [sp, #8]
 80080c0:	e791      	b.n	8007fe6 <_dtoa_r+0xa32>
 80080c2:	426e      	negs	r6, r5
 80080c4:	2e00      	cmp	r6, #0
 80080c6:	f000 811d 	beq.w	8008304 <_dtoa_r+0xd50>
 80080ca:	f006 030f 	and.w	r3, r6, #15
 80080ce:	f64b 0208 	movw	r2, #47112	; 0xb808
 80080d2:	f6c0 0200 	movt	r2, #2048	; 0x800
 80080d6:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80080da:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80080de:	e9d3 2300 	ldrd	r2, r3, [r3]
 80080e2:	f002 fca3 	bl	800aa2c <__aeabi_dmul>
 80080e6:	1136      	asrs	r6, r6, #4
 80080e8:	e9cd 0108 	strd	r0, r1, [sp, #32]
 80080ec:	f000 810a 	beq.w	8008304 <_dtoa_r+0xd50>
 80080f0:	f64b 07d0 	movw	r7, #47312	; 0xb8d0
 80080f4:	f04f 0802 	mov.w	r8, #2
 80080f8:	f6c0 0700 	movt	r7, #2048	; 0x800
 80080fc:	4602      	mov	r2, r0
 80080fe:	460b      	mov	r3, r1
 8008100:	f016 0f01 	tst.w	r6, #1
 8008104:	4610      	mov	r0, r2
 8008106:	4619      	mov	r1, r3
 8008108:	d007      	beq.n	800811a <_dtoa_r+0xb66>
 800810a:	e9d7 2300 	ldrd	r2, r3, [r7]
 800810e:	f108 0801 	add.w	r8, r8, #1
 8008112:	f002 fc8b 	bl	800aa2c <__aeabi_dmul>
 8008116:	4602      	mov	r2, r0
 8008118:	460b      	mov	r3, r1
 800811a:	3708      	adds	r7, #8
 800811c:	1076      	asrs	r6, r6, #1
 800811e:	d1ef      	bne.n	8008100 <_dtoa_r+0xb4c>
 8008120:	e9cd 2308 	strd	r2, r3, [sp, #32]
 8008124:	f7ff bbd4 	b.w	80078d0 <_dtoa_r+0x31c>
 8008128:	f10b 32ff 	add.w	r2, fp, #4294967295
 800812c:	9217      	str	r2, [sp, #92]	; 0x5c
 800812e:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8008130:	f64b 0108 	movw	r1, #47112	; 0xb808
 8008134:	f6c0 0100 	movt	r1, #2048	; 0x800
 8008138:	4642      	mov	r2, r8
 800813a:	464b      	mov	r3, r9
 800813c:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 800813e:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 8008142:	e9d1 0100 	ldrd	r0, r1, [r1]
 8008146:	f002 fc71 	bl	800aa2c <__aeabi_dmul>
 800814a:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
 800814e:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8008152:	f002 ff05 	bl	800af60 <__aeabi_d2iz>
 8008156:	4607      	mov	r7, r0
 8008158:	f002 fc02 	bl	800a960 <__aeabi_i2d>
 800815c:	460b      	mov	r3, r1
 800815e:	4602      	mov	r2, r0
 8008160:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8008164:	f002 faae 	bl	800a6c4 <__aeabi_dsub>
 8008168:	f1bb 0f01 	cmp.w	fp, #1
 800816c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8008170:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8008174:	f806 3b01 	strb.w	r3, [r6], #1
 8008178:	d02b      	beq.n	80081d2 <_dtoa_r+0xc1e>
 800817a:	990c      	ldr	r1, [sp, #48]	; 0x30
 800817c:	951b      	str	r5, [sp, #108]	; 0x6c
 800817e:	f101 39ff 	add.w	r9, r1, #4294967295
 8008182:	460f      	mov	r7, r1
 8008184:	44d9      	add	r9, fp
 8008186:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800818a:	46d3      	mov	fp, sl
 800818c:	464d      	mov	r5, r9
 800818e:	46b2      	mov	sl, r6
 8008190:	4626      	mov	r6, r4
 8008192:	2300      	movs	r3, #0
 8008194:	2200      	movs	r2, #0
 8008196:	f2c4 0324 	movt	r3, #16420	; 0x4024
 800819a:	f002 fc47 	bl	800aa2c <__aeabi_dmul>
 800819e:	4689      	mov	r9, r1
 80081a0:	4680      	mov	r8, r0
 80081a2:	f002 fedd 	bl	800af60 <__aeabi_d2iz>
 80081a6:	4604      	mov	r4, r0
 80081a8:	f002 fbda 	bl	800a960 <__aeabi_i2d>
 80081ac:	3430      	adds	r4, #48	; 0x30
 80081ae:	4602      	mov	r2, r0
 80081b0:	460b      	mov	r3, r1
 80081b2:	4640      	mov	r0, r8
 80081b4:	4649      	mov	r1, r9
 80081b6:	f002 fa85 	bl	800a6c4 <__aeabi_dsub>
 80081ba:	f807 4f01 	strb.w	r4, [r7, #1]!
 80081be:	42af      	cmp	r7, r5
 80081c0:	d1e7      	bne.n	8008192 <_dtoa_r+0xbde>
 80081c2:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80081c4:	4634      	mov	r4, r6
 80081c6:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
 80081c8:	4656      	mov	r6, sl
 80081ca:	18b6      	adds	r6, r6, r2
 80081cc:	46da      	mov	sl, fp
 80081ce:	e9cd 0108 	strd	r0, r1, [sp, #32]
 80081d2:	2300      	movs	r3, #0
 80081d4:	2200      	movs	r2, #0
 80081d6:	f6c3 73e0 	movt	r3, #16352	; 0x3fe0
 80081da:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
 80081de:	f002 fa73 	bl	800a6c8 <__adddf3>
 80081e2:	4602      	mov	r2, r0
 80081e4:	460b      	mov	r3, r1
 80081e6:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80081ea:	f002 feaf 	bl	800af4c <__aeabi_dcmpgt>
 80081ee:	2800      	cmp	r0, #0
 80081f0:	f47f acc3 	bne.w	8007b7a <_dtoa_r+0x5c6>
 80081f4:	2100      	movs	r1, #0
 80081f6:	e9dd 2318 	ldrd	r2, r3, [sp, #96]	; 0x60
 80081fa:	2000      	movs	r0, #0
 80081fc:	f6c3 71e0 	movt	r1, #16352	; 0x3fe0
 8008200:	f002 fa60 	bl	800a6c4 <__aeabi_dsub>
 8008204:	4602      	mov	r2, r0
 8008206:	460b      	mov	r3, r1
 8008208:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800820c:	f002 fe80 	bl	800af10 <__aeabi_dcmplt>
 8008210:	2800      	cmp	r0, #0
 8008212:	f43f abf9 	beq.w	8007a08 <_dtoa_r+0x454>
 8008216:	4633      	mov	r3, r6
 8008218:	461e      	mov	r6, r3
 800821a:	3b01      	subs	r3, #1
 800821c:	f816 2c01 	ldrb.w	r2, [r6, #-1]
 8008220:	2a30      	cmp	r2, #48	; 0x30
 8008222:	d0f9      	beq.n	8008218 <_dtoa_r+0xc64>
 8008224:	9d12      	ldr	r5, [sp, #72]	; 0x48
 8008226:	f7ff bbdb 	b.w	80079e0 <_dtoa_r+0x42c>
 800822a:	980c      	ldr	r0, [sp, #48]	; 0x30
 800822c:	f7ff ba04 	b.w	8007638 <_dtoa_r+0x84>
 8008230:	f8db 3010 	ldr.w	r3, [fp, #16]
 8008234:	eb0b 0383 	add.w	r3, fp, r3, lsl #2
 8008238:	6918      	ldr	r0, [r3, #16]
 800823a:	f000 fbad 	bl	8008998 <__hi0bits>
 800823e:	f1c0 0320 	rsb	r3, r0, #32
 8008242:	e504      	b.n	8007c4e <_dtoa_r+0x69a>
 8008244:	4650      	mov	r0, sl
 8008246:	4659      	mov	r1, fp
 8008248:	f000 fd3e 	bl	8008cc8 <__mcmp>
 800824c:	2800      	cmp	r0, #0
 800824e:	f6bf ad26 	bge.w	8007c9e <_dtoa_r+0x6ea>
 8008252:	4651      	mov	r1, sl
 8008254:	220a      	movs	r2, #10
 8008256:	4620      	mov	r0, r4
 8008258:	2300      	movs	r3, #0
 800825a:	f000 fb0f 	bl	800887c <__multadd>
 800825e:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8008260:	3d01      	subs	r5, #1
 8008262:	4682      	mov	sl, r0
 8008264:	2a00      	cmp	r2, #0
 8008266:	f040 80e9 	bne.w	800843c <_dtoa_r+0xe88>
 800826a:	980e      	ldr	r0, [sp, #56]	; 0x38
 800826c:	900a      	str	r0, [sp, #40]	; 0x28
 800826e:	e516      	b.n	8007c9e <_dtoa_r+0x6ea>
 8008270:	2201      	movs	r2, #1
 8008272:	920e      	str	r2, [sp, #56]	; 0x38
 8008274:	920a      	str	r2, [sp, #40]	; 0x28
 8008276:	9229      	str	r2, [sp, #164]	; 0xa4
 8008278:	f7ff bade 	b.w	8007838 <_dtoa_r+0x284>
 800827c:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 800827e:	2701      	movs	r7, #1
 8008280:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
 8008284:	9502      	str	r5, [sp, #8]
 8008286:	e002      	b.n	800828e <_dtoa_r+0xcda>
 8008288:	f000 faf8 	bl	800887c <__multadd>
 800828c:	4682      	mov	sl, r0
 800828e:	4659      	mov	r1, fp
 8008290:	4650      	mov	r0, sl
 8008292:	f7ff f8f9 	bl	8007488 <quorem>
 8008296:	220a      	movs	r2, #10
 8008298:	2300      	movs	r3, #0
 800829a:	454f      	cmp	r7, r9
 800829c:	4651      	mov	r1, sl
 800829e:	f107 0701 	add.w	r7, r7, #1
 80082a2:	f100 0530 	add.w	r5, r0, #48	; 0x30
 80082a6:	4620      	mov	r0, r4
 80082a8:	f806 5b01 	strb.w	r5, [r6], #1
 80082ac:	46b0      	mov	r8, r6
 80082ae:	dbeb      	blt.n	8008288 <_dtoa_r+0xcd4>
 80082b0:	9507      	str	r5, [sp, #28]
 80082b2:	2700      	movs	r7, #0
 80082b4:	9d02      	ldr	r5, [sp, #8]
 80082b6:	4651      	mov	r1, sl
 80082b8:	2201      	movs	r2, #1
 80082ba:	4620      	mov	r0, r4
 80082bc:	f000 fcae 	bl	8008c1c <__lshift>
 80082c0:	4659      	mov	r1, fp
 80082c2:	4682      	mov	sl, r0
 80082c4:	f000 fd00 	bl	8008cc8 <__mcmp>
 80082c8:	2800      	cmp	r0, #0
 80082ca:	dd0f      	ble.n	80082ec <_dtoa_r+0xd38>
 80082cc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80082ce:	4646      	mov	r6, r8
 80082d0:	f108 38ff 	add.w	r8, r8, #4294967295
 80082d4:	f816 3c01 	ldrb.w	r3, [r6, #-1]
 80082d8:	2b39      	cmp	r3, #57	; 0x39
 80082da:	d161      	bne.n	80083a0 <_dtoa_r+0xdec>
 80082dc:	4590      	cmp	r8, r2
 80082de:	d1f6      	bne.n	80082ce <_dtoa_r+0xd1a>
 80082e0:	980c      	ldr	r0, [sp, #48]	; 0x30
 80082e2:	2331      	movs	r3, #49	; 0x31
 80082e4:	3501      	adds	r5, #1
 80082e6:	7003      	strb	r3, [r0, #0]
 80082e8:	f7ff bb65 	b.w	80079b6 <_dtoa_r+0x402>
 80082ec:	d103      	bne.n	80082f6 <_dtoa_r+0xd42>
 80082ee:	9a07      	ldr	r2, [sp, #28]
 80082f0:	f012 0f01 	tst.w	r2, #1
 80082f4:	d1ea      	bne.n	80082cc <_dtoa_r+0xd18>
 80082f6:	4646      	mov	r6, r8
 80082f8:	f818 3d01 	ldrb.w	r3, [r8, #-1]!
 80082fc:	2b30      	cmp	r3, #48	; 0x30
 80082fe:	d0fa      	beq.n	80082f6 <_dtoa_r+0xd42>
 8008300:	f7ff bb59 	b.w	80079b6 <_dtoa_r+0x402>
 8008304:	f04f 0802 	mov.w	r8, #2
 8008308:	f7ff bae2 	b.w	80078d0 <_dtoa_r+0x31c>
 800830c:	9d07      	ldr	r5, [sp, #28]
 800830e:	4644      	mov	r4, r8
 8008310:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 8008314:	f7ff bb64 	b.w	80079e0 <_dtoa_r+0x42c>
 8008318:	4651      	mov	r1, sl
 800831a:	4620      	mov	r0, r4
 800831c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800831e:	f000 fc2b 	bl	8008b78 <__pow5mult>
 8008322:	4682      	mov	sl, r0
 8008324:	e47b      	b.n	8007c1e <_dtoa_r+0x66a>
 8008326:	4651      	mov	r1, sl
 8008328:	4620      	mov	r0, r4
 800832a:	f000 fc25 	bl	8008b78 <__pow5mult>
 800832e:	4682      	mov	sl, r0
 8008330:	e475      	b.n	8007c1e <_dtoa_r+0x66a>
 8008332:	9816      	ldr	r0, [sp, #88]	; 0x58
 8008334:	2800      	cmp	r0, #0
 8008336:	d04e      	beq.n	80083d6 <_dtoa_r+0xe22>
 8008338:	f503 6386 	add.w	r3, r3, #1072	; 0x430
 800833c:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 800833e:	3303      	adds	r3, #3
 8008340:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 8008342:	e517      	b.n	8007d74 <_dtoa_r+0x7c0>
 8008344:	f04f 0b00 	mov.w	fp, #0
 8008348:	f8cd b020 	str.w	fp, [sp, #32]
 800834c:	f7ff bb2f 	b.w	80079ae <_dtoa_r+0x3fa>
 8008350:	3101      	adds	r1, #1
 8008352:	9d12      	ldr	r5, [sp, #72]	; 0x48
 8008354:	7011      	strb	r1, [r2, #0]
 8008356:	f7ff bb43 	b.w	80079e0 <_dtoa_r+0x42c>
 800835a:	f8dd a05c 	ldr.w	sl, [sp, #92]	; 0x5c
 800835e:	9c08      	ldr	r4, [sp, #32]
 8008360:	e40b      	b.n	8007b7a <_dtoa_r+0x5c6>
 8008362:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008364:	1a9e      	subs	r6, r3, r2
 8008366:	2300      	movs	r3, #0
 8008368:	e504      	b.n	8007d74 <_dtoa_r+0x7c0>
 800836a:	f1b9 0f00 	cmp.w	r9, #0
 800836e:	9d08      	ldr	r5, [sp, #32]
 8008370:	dd0f      	ble.n	8008392 <_dtoa_r+0xdde>
 8008372:	4651      	mov	r1, sl
 8008374:	2201      	movs	r2, #1
 8008376:	4620      	mov	r0, r4
 8008378:	f000 fc50 	bl	8008c1c <__lshift>
 800837c:	4659      	mov	r1, fp
 800837e:	4682      	mov	sl, r0
 8008380:	f000 fca2 	bl	8008cc8 <__mcmp>
 8008384:	2800      	cmp	r0, #0
 8008386:	dd53      	ble.n	8008430 <_dtoa_r+0xe7c>
 8008388:	9b07      	ldr	r3, [sp, #28]
 800838a:	2b39      	cmp	r3, #57	; 0x39
 800838c:	d039      	beq.n	8008402 <_dtoa_r+0xe4e>
 800838e:	3301      	adds	r3, #1
 8008390:	9307      	str	r3, [sp, #28]
 8008392:	9802      	ldr	r0, [sp, #8]
 8008394:	9907      	ldr	r1, [sp, #28]
 8008396:	9008      	str	r0, [sp, #32]
 8008398:	f806 1b01 	strb.w	r1, [r6], #1
 800839c:	f7ff bb0b 	b.w	80079b6 <_dtoa_r+0x402>
 80083a0:	3301      	adds	r3, #1
 80083a2:	f888 3000 	strb.w	r3, [r8]
 80083a6:	f7ff bb06 	b.w	80079b6 <_dtoa_r+0x402>
 80083aa:	9a08      	ldr	r2, [sp, #32]
 80083ac:	4620      	mov	r0, r4
 80083ae:	6851      	ldr	r1, [r2, #4]
 80083b0:	f000 fa14 	bl	80087dc <_Balloc>
 80083b4:	9b08      	ldr	r3, [sp, #32]
 80083b6:	f103 010c 	add.w	r1, r3, #12
 80083ba:	691a      	ldr	r2, [r3, #16]
 80083bc:	3202      	adds	r2, #2
 80083be:	0092      	lsls	r2, r2, #2
 80083c0:	4606      	mov	r6, r0
 80083c2:	300c      	adds	r0, #12
 80083c4:	f000 f962 	bl	800868c <memcpy>
 80083c8:	4620      	mov	r0, r4
 80083ca:	4631      	mov	r1, r6
 80083cc:	2201      	movs	r2, #1
 80083ce:	f000 fc25 	bl	8008c1c <__lshift>
 80083d2:	9002      	str	r0, [sp, #8]
 80083d4:	e5fe      	b.n	8007fd4 <_dtoa_r+0xa20>
 80083d6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80083d8:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 80083da:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 80083dc:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 80083e0:	e4c8      	b.n	8007d74 <_dtoa_r+0x7c0>
 80083e2:	9902      	ldr	r1, [sp, #8]
 80083e4:	9d08      	ldr	r5, [sp, #32]
 80083e6:	9108      	str	r1, [sp, #32]
 80083e8:	e765      	b.n	80082b6 <_dtoa_r+0xd02>
 80083ea:	9a07      	ldr	r2, [sp, #28]
 80083ec:	9d08      	ldr	r5, [sp, #32]
 80083ee:	2a39      	cmp	r2, #57	; 0x39
 80083f0:	d007      	beq.n	8008402 <_dtoa_r+0xe4e>
 80083f2:	9902      	ldr	r1, [sp, #8]
 80083f4:	9807      	ldr	r0, [sp, #28]
 80083f6:	9108      	str	r1, [sp, #32]
 80083f8:	1c43      	adds	r3, r0, #1
 80083fa:	f806 3b01 	strb.w	r3, [r6], #1
 80083fe:	f7ff bada 	b.w	80079b6 <_dtoa_r+0x402>
 8008402:	9b02      	ldr	r3, [sp, #8]
 8008404:	46b0      	mov	r8, r6
 8008406:	9308      	str	r3, [sp, #32]
 8008408:	2339      	movs	r3, #57	; 0x39
 800840a:	f808 3b01 	strb.w	r3, [r8], #1
 800840e:	e75d      	b.n	80082cc <_dtoa_r+0xd18>
 8008410:	9907      	ldr	r1, [sp, #28]
 8008412:	462b      	mov	r3, r5
 8008414:	9d08      	ldr	r5, [sp, #32]
 8008416:	2939      	cmp	r1, #57	; 0x39
 8008418:	d0f3      	beq.n	8008402 <_dtoa_r+0xe4e>
 800841a:	2b00      	cmp	r3, #0
 800841c:	dd01      	ble.n	8008422 <_dtoa_r+0xe6e>
 800841e:	3101      	adds	r1, #1
 8008420:	9107      	str	r1, [sp, #28]
 8008422:	9a02      	ldr	r2, [sp, #8]
 8008424:	9b07      	ldr	r3, [sp, #28]
 8008426:	9208      	str	r2, [sp, #32]
 8008428:	f806 3b01 	strb.w	r3, [r6], #1
 800842c:	f7ff bac3 	b.w	80079b6 <_dtoa_r+0x402>
 8008430:	d1af      	bne.n	8008392 <_dtoa_r+0xdde>
 8008432:	9a07      	ldr	r2, [sp, #28]
 8008434:	f012 0f01 	tst.w	r2, #1
 8008438:	d0ab      	beq.n	8008392 <_dtoa_r+0xdde>
 800843a:	e7a5      	b.n	8008388 <_dtoa_r+0xdd4>
 800843c:	2300      	movs	r3, #0
 800843e:	4620      	mov	r0, r4
 8008440:	9908      	ldr	r1, [sp, #32]
 8008442:	220a      	movs	r2, #10
 8008444:	f000 fa1a 	bl	800887c <__multadd>
 8008448:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800844a:	930a      	str	r3, [sp, #40]	; 0x28
 800844c:	9008      	str	r0, [sp, #32]
 800844e:	e426      	b.n	8007c9e <_dtoa_r+0x6ea>
 8008450:	f43f ac0f 	beq.w	8007c72 <_dtoa_r+0x6be>
 8008454:	331c      	adds	r3, #28
 8008456:	e623      	b.n	80080a0 <_dtoa_r+0xaec>
 8008458:	990a      	ldr	r1, [sp, #40]	; 0x28
 800845a:	290e      	cmp	r1, #14
 800845c:	bf8c      	ite	hi
 800845e:	2700      	movhi	r7, #0
 8008460:	f007 0701 	andls.w	r7, r7, #1
 8008464:	f7ff b9eb 	b.w	800783e <_dtoa_r+0x28a>
 8008468:	2701      	movs	r7, #1
 800846a:	f7ff b970 	b.w	800774e <_dtoa_r+0x19a>
 800846e:	bf00      	nop

08008470 <_fclose_r>:
 8008470:	b570      	push	{r4, r5, r6, lr}
 8008472:	460c      	mov	r4, r1
 8008474:	4605      	mov	r5, r0
 8008476:	460e      	mov	r6, r1
 8008478:	2900      	cmp	r1, #0
 800847a:	d048      	beq.n	800850e <_fclose_r+0x9e>
 800847c:	f7fd fa7e 	bl	800597c <__sfp_lock_acquire>
 8008480:	b115      	cbz	r5, 8008488 <_fclose_r+0x18>
 8008482:	69ab      	ldr	r3, [r5, #24]
 8008484:	2b00      	cmp	r3, #0
 8008486:	d044      	beq.n	8008512 <_fclose_r+0xa2>
 8008488:	f24b 7374 	movw	r3, #46964	; 0xb774
 800848c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008490:	429c      	cmp	r4, r3
 8008492:	bf08      	it	eq
 8008494:	686c      	ldreq	r4, [r5, #4]
 8008496:	d00e      	beq.n	80084b6 <_fclose_r+0x46>
 8008498:	f24b 7394 	movw	r3, #46996	; 0xb794
 800849c:	f6c0 0300 	movt	r3, #2048	; 0x800
 80084a0:	429c      	cmp	r4, r3
 80084a2:	bf08      	it	eq
 80084a4:	68ac      	ldreq	r4, [r5, #8]
 80084a6:	d006      	beq.n	80084b6 <_fclose_r+0x46>
 80084a8:	f24b 73b4 	movw	r3, #47028	; 0xb7b4
 80084ac:	f6c0 0300 	movt	r3, #2048	; 0x800
 80084b0:	429c      	cmp	r4, r3
 80084b2:	bf08      	it	eq
 80084b4:	68ec      	ldreq	r4, [r5, #12]
 80084b6:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
 80084ba:	b336      	cbz	r6, 800850a <_fclose_r+0x9a>
 80084bc:	4628      	mov	r0, r5
 80084be:	4621      	mov	r1, r4
 80084c0:	f7fd f876 	bl	80055b0 <_fflush_r>
 80084c4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80084c6:	4606      	mov	r6, r0
 80084c8:	b13b      	cbz	r3, 80084da <_fclose_r+0x6a>
 80084ca:	4628      	mov	r0, r5
 80084cc:	6a21      	ldr	r1, [r4, #32]
 80084ce:	4798      	blx	r3
 80084d0:	ea36 0620 	bics.w	r6, r6, r0, asr #32
 80084d4:	bf28      	it	cs
 80084d6:	f04f 36ff 	movcs.w	r6, #4294967295
 80084da:	89a3      	ldrh	r3, [r4, #12]
 80084dc:	f013 0f80 	tst.w	r3, #128	; 0x80
 80084e0:	d11b      	bne.n	800851a <_fclose_r+0xaa>
 80084e2:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80084e4:	b141      	cbz	r1, 80084f8 <_fclose_r+0x88>
 80084e6:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80084ea:	4299      	cmp	r1, r3
 80084ec:	d002      	beq.n	80084f4 <_fclose_r+0x84>
 80084ee:	4628      	mov	r0, r5
 80084f0:	f7fd fab8 	bl	8005a64 <_free_r>
 80084f4:	2300      	movs	r3, #0
 80084f6:	6363      	str	r3, [r4, #52]	; 0x34
 80084f8:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 80084fa:	b121      	cbz	r1, 8008506 <_fclose_r+0x96>
 80084fc:	4628      	mov	r0, r5
 80084fe:	f7fd fab1 	bl	8005a64 <_free_r>
 8008502:	2300      	movs	r3, #0
 8008504:	64a3      	str	r3, [r4, #72]	; 0x48
 8008506:	2300      	movs	r3, #0
 8008508:	81a3      	strh	r3, [r4, #12]
 800850a:	f7fd fa39 	bl	8005980 <__sfp_lock_release>
 800850e:	4630      	mov	r0, r6
 8008510:	bd70      	pop	{r4, r5, r6, pc}
 8008512:	4628      	mov	r0, r5
 8008514:	f7fd f96a 	bl	80057ec <__sinit>
 8008518:	e7b6      	b.n	8008488 <_fclose_r+0x18>
 800851a:	4628      	mov	r0, r5
 800851c:	6921      	ldr	r1, [r4, #16]
 800851e:	f7fd faa1 	bl	8005a64 <_free_r>
 8008522:	e7de      	b.n	80084e2 <_fclose_r+0x72>

08008524 <fclose>:
 8008524:	f240 236c 	movw	r3, #620	; 0x26c
 8008528:	4601      	mov	r1, r0
 800852a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800852e:	6818      	ldr	r0, [r3, #0]
 8008530:	e79e      	b.n	8008470 <_fclose_r>
 8008532:	bf00      	nop

08008534 <_setlocale_r>:
 8008534:	b510      	push	{r4, lr}
 8008536:	4614      	mov	r4, r2
 8008538:	b13a      	cbz	r2, 800854a <_setlocale_r+0x16>
 800853a:	f64b 3198 	movw	r1, #48024	; 0xbb98
 800853e:	4610      	mov	r0, r2
 8008540:	f6c0 0100 	movt	r1, #2048	; 0x800
 8008544:	f7fc ff20 	bl	8005388 <strcmp>
 8008548:	b920      	cbnz	r0, 8008554 <_setlocale_r+0x20>
 800854a:	f64b 3040 	movw	r0, #47936	; 0xbb40
 800854e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008552:	bd10      	pop	{r4, pc}
 8008554:	f64b 3140 	movw	r1, #47936	; 0xbb40
 8008558:	4620      	mov	r0, r4
 800855a:	f6c0 0100 	movt	r1, #2048	; 0x800
 800855e:	f7fc ff13 	bl	8005388 <strcmp>
 8008562:	b920      	cbnz	r0, 800856e <_setlocale_r+0x3a>
 8008564:	f64b 3040 	movw	r0, #47936	; 0xbb40
 8008568:	f6c0 0000 	movt	r0, #2048	; 0x800
 800856c:	bd10      	pop	{r4, pc}
 800856e:	f64b 3164 	movw	r1, #47972	; 0xbb64
 8008572:	4620      	mov	r0, r4
 8008574:	f6c0 0100 	movt	r1, #2048	; 0x800
 8008578:	f7fc ff06 	bl	8005388 <strcmp>
 800857c:	f64b 3340 	movw	r3, #47936	; 0xbb40
 8008580:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008584:	2800      	cmp	r0, #0
 8008586:	bf0c      	ite	eq
 8008588:	4618      	moveq	r0, r3
 800858a:	2000      	movne	r0, #0
 800858c:	bd10      	pop	{r4, pc}
 800858e:	bf00      	nop

08008590 <__locale_charset>:
 8008590:	f240 7070 	movw	r0, #1904	; 0x770
 8008594:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8008598:	4770      	bx	lr
 800859a:	bf00      	nop

0800859c <__locale_mb_cur_max>:
 800859c:	f240 7370 	movw	r3, #1904	; 0x770
 80085a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80085a4:	6a18      	ldr	r0, [r3, #32]
 80085a6:	4770      	bx	lr

080085a8 <__locale_msgcharset>:
 80085a8:	4800      	ldr	r0, [pc, #0]	; (80085ac <__locale_msgcharset+0x4>)
 80085aa:	4770      	bx	lr
 80085ac:	20000794 	.word	0x20000794

080085b0 <__locale_cjk_lang>:
 80085b0:	2000      	movs	r0, #0
 80085b2:	4770      	bx	lr

080085b4 <_localeconv_r>:
 80085b4:	4800      	ldr	r0, [pc, #0]	; (80085b8 <_localeconv_r+0x4>)
 80085b6:	4770      	bx	lr
 80085b8:	200007b4 	.word	0x200007b4

080085bc <setlocale>:
 80085bc:	f240 236c 	movw	r3, #620	; 0x26c
 80085c0:	460a      	mov	r2, r1
 80085c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80085c6:	4601      	mov	r1, r0
 80085c8:	6818      	ldr	r0, [r3, #0]
 80085ca:	e7b3      	b.n	8008534 <_setlocale_r>

080085cc <localeconv>:
 80085cc:	4800      	ldr	r0, [pc, #0]	; (80085d0 <localeconv+0x4>)
 80085ce:	4770      	bx	lr
 80085d0:	200007b4 	.word	0x200007b4

080085d4 <_lseek_r>:
 80085d4:	b538      	push	{r3, r4, r5, lr}
 80085d6:	f641 24e4 	movw	r4, #6884	; 0x1ae4
 80085da:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80085de:	4605      	mov	r5, r0
 80085e0:	4608      	mov	r0, r1
 80085e2:	4611      	mov	r1, r2
 80085e4:	461a      	mov	r2, r3
 80085e6:	2300      	movs	r3, #0
 80085e8:	6023      	str	r3, [r4, #0]
 80085ea:	f7f8 f9cd 	bl	8000988 <_lseek>
 80085ee:	f1b0 3fff 	cmp.w	r0, #4294967295
 80085f2:	d000      	beq.n	80085f6 <_lseek_r+0x22>
 80085f4:	bd38      	pop	{r3, r4, r5, pc}
 80085f6:	6823      	ldr	r3, [r4, #0]
 80085f8:	2b00      	cmp	r3, #0
 80085fa:	d0fb      	beq.n	80085f4 <_lseek_r+0x20>
 80085fc:	602b      	str	r3, [r5, #0]
 80085fe:	bd38      	pop	{r3, r4, r5, pc}

08008600 <memchr>:
 8008600:	f010 0f03 	tst.w	r0, #3
 8008604:	4603      	mov	r3, r0
 8008606:	b470      	push	{r4, r5, r6}
 8008608:	b2c9      	uxtb	r1, r1
 800860a:	d011      	beq.n	8008630 <memchr+0x30>
 800860c:	2a00      	cmp	r2, #0
 800860e:	d022      	beq.n	8008656 <memchr+0x56>
 8008610:	7803      	ldrb	r3, [r0, #0]
 8008612:	428b      	cmp	r3, r1
 8008614:	d01d      	beq.n	8008652 <memchr+0x52>
 8008616:	3a01      	subs	r2, #1
 8008618:	3001      	adds	r0, #1
 800861a:	e005      	b.n	8008628 <memchr+0x28>
 800861c:	b1da      	cbz	r2, 8008656 <memchr+0x56>
 800861e:	f810 4b01 	ldrb.w	r4, [r0], #1
 8008622:	3a01      	subs	r2, #1
 8008624:	428c      	cmp	r4, r1
 8008626:	d018      	beq.n	800865a <memchr+0x5a>
 8008628:	f010 0f03 	tst.w	r0, #3
 800862c:	4603      	mov	r3, r0
 800862e:	d1f5      	bne.n	800861c <memchr+0x1c>
 8008630:	2a03      	cmp	r2, #3
 8008632:	d814      	bhi.n	800865e <memchr+0x5e>
 8008634:	b17a      	cbz	r2, 8008656 <memchr+0x56>
 8008636:	7818      	ldrb	r0, [r3, #0]
 8008638:	4288      	cmp	r0, r1
 800863a:	d00e      	beq.n	800865a <memchr+0x5a>
 800863c:	1e54      	subs	r4, r2, #1
 800863e:	1c5d      	adds	r5, r3, #1
 8008640:	e003      	b.n	800864a <memchr+0x4a>
 8008642:	f815 6b01 	ldrb.w	r6, [r5], #1
 8008646:	428e      	cmp	r6, r1
 8008648:	d003      	beq.n	8008652 <memchr+0x52>
 800864a:	3c01      	subs	r4, #1
 800864c:	4628      	mov	r0, r5
 800864e:	d2f8      	bcs.n	8008642 <memchr+0x42>
 8008650:	2000      	movs	r0, #0
 8008652:	bc70      	pop	{r4, r5, r6}
 8008654:	4770      	bx	lr
 8008656:	4610      	mov	r0, r2
 8008658:	e7fb      	b.n	8008652 <memchr+0x52>
 800865a:	4618      	mov	r0, r3
 800865c:	e7f9      	b.n	8008652 <memchr+0x52>
 800865e:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 8008662:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 8008666:	4618      	mov	r0, r3
 8008668:	f853 4b04 	ldr.w	r4, [r3], #4
 800866c:	ea86 0404 	eor.w	r4, r6, r4
 8008670:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 8008674:	ea25 0404 	bic.w	r4, r5, r4
 8008678:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 800867c:	d103      	bne.n	8008686 <memchr+0x86>
 800867e:	3a04      	subs	r2, #4
 8008680:	4618      	mov	r0, r3
 8008682:	2a03      	cmp	r2, #3
 8008684:	d8ef      	bhi.n	8008666 <memchr+0x66>
 8008686:	4603      	mov	r3, r0
 8008688:	e7d4      	b.n	8008634 <memchr+0x34>
 800868a:	bf00      	nop

0800868c <memcpy>:
 800868c:	2a03      	cmp	r2, #3
 800868e:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 8008692:	d809      	bhi.n	80086a8 <memcpy+0x1c>
 8008694:	b12a      	cbz	r2, 80086a2 <memcpy+0x16>
 8008696:	2300      	movs	r3, #0
 8008698:	5ccc      	ldrb	r4, [r1, r3]
 800869a:	54c4      	strb	r4, [r0, r3]
 800869c:	3301      	adds	r3, #1
 800869e:	4293      	cmp	r3, r2
 80086a0:	d1fa      	bne.n	8008698 <memcpy+0xc>
 80086a2:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 80086a6:	4770      	bx	lr
 80086a8:	460b      	mov	r3, r1
 80086aa:	1882      	adds	r2, r0, r2
 80086ac:	4601      	mov	r1, r0
 80086ae:	e003      	b.n	80086b8 <memcpy+0x2c>
 80086b0:	7824      	ldrb	r4, [r4, #0]
 80086b2:	3301      	adds	r3, #1
 80086b4:	f801 4b01 	strb.w	r4, [r1], #1
 80086b8:	f011 0f03 	tst.w	r1, #3
 80086bc:	461c      	mov	r4, r3
 80086be:	d1f7      	bne.n	80086b0 <memcpy+0x24>
 80086c0:	f013 0503 	ands.w	r5, r3, #3
 80086c4:	d05d      	beq.n	8008782 <memcpy+0xf6>
 80086c6:	426e      	negs	r6, r5
 80086c8:	f1c5 0c04 	rsb	ip, r5, #4
 80086cc:	00ed      	lsls	r5, r5, #3
 80086ce:	599b      	ldr	r3, [r3, r6]
 80086d0:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 80086d4:	e008      	b.n	80086e8 <memcpy+0x5c>
 80086d6:	3404      	adds	r4, #4
 80086d8:	59a7      	ldr	r7, [r4, r6]
 80086da:	463b      	mov	r3, r7
 80086dc:	fa07 f70c 	lsl.w	r7, r7, ip
 80086e0:	ea48 0707 	orr.w	r7, r8, r7
 80086e4:	f841 7b04 	str.w	r7, [r1], #4
 80086e8:	1a57      	subs	r7, r2, r1
 80086ea:	fa23 f805 	lsr.w	r8, r3, r5
 80086ee:	2f03      	cmp	r7, #3
 80086f0:	dcf1      	bgt.n	80086d6 <memcpy+0x4a>
 80086f2:	e003      	b.n	80086fc <memcpy+0x70>
 80086f4:	f814 3b01 	ldrb.w	r3, [r4], #1
 80086f8:	f801 3b01 	strb.w	r3, [r1], #1
 80086fc:	428a      	cmp	r2, r1
 80086fe:	d8f9      	bhi.n	80086f4 <memcpy+0x68>
 8008700:	e7cf      	b.n	80086a2 <memcpy+0x16>
 8008702:	f853 4c40 	ldr.w	r4, [r3, #-64]
 8008706:	f841 4c40 	str.w	r4, [r1, #-64]
 800870a:	f853 4c3c 	ldr.w	r4, [r3, #-60]
 800870e:	f841 4c3c 	str.w	r4, [r1, #-60]
 8008712:	f853 4c38 	ldr.w	r4, [r3, #-56]
 8008716:	f841 4c38 	str.w	r4, [r1, #-56]
 800871a:	f853 4c34 	ldr.w	r4, [r3, #-52]
 800871e:	f841 4c34 	str.w	r4, [r1, #-52]
 8008722:	f853 4c30 	ldr.w	r4, [r3, #-48]
 8008726:	f841 4c30 	str.w	r4, [r1, #-48]
 800872a:	f853 4c2c 	ldr.w	r4, [r3, #-44]
 800872e:	f841 4c2c 	str.w	r4, [r1, #-44]
 8008732:	f853 4c28 	ldr.w	r4, [r3, #-40]
 8008736:	f841 4c28 	str.w	r4, [r1, #-40]
 800873a:	f853 4c24 	ldr.w	r4, [r3, #-36]
 800873e:	f841 4c24 	str.w	r4, [r1, #-36]
 8008742:	f853 4c20 	ldr.w	r4, [r3, #-32]
 8008746:	f841 4c20 	str.w	r4, [r1, #-32]
 800874a:	f853 4c1c 	ldr.w	r4, [r3, #-28]
 800874e:	f841 4c1c 	str.w	r4, [r1, #-28]
 8008752:	f853 4c18 	ldr.w	r4, [r3, #-24]
 8008756:	f841 4c18 	str.w	r4, [r1, #-24]
 800875a:	f853 4c14 	ldr.w	r4, [r3, #-20]
 800875e:	f841 4c14 	str.w	r4, [r1, #-20]
 8008762:	f853 4c10 	ldr.w	r4, [r3, #-16]
 8008766:	f841 4c10 	str.w	r4, [r1, #-16]
 800876a:	f853 4c0c 	ldr.w	r4, [r3, #-12]
 800876e:	f841 4c0c 	str.w	r4, [r1, #-12]
 8008772:	f853 4c08 	ldr.w	r4, [r3, #-8]
 8008776:	f841 4c08 	str.w	r4, [r1, #-8]
 800877a:	f853 4c04 	ldr.w	r4, [r3, #-4]
 800877e:	f841 4c04 	str.w	r4, [r1, #-4]
 8008782:	1a56      	subs	r6, r2, r1
 8008784:	461d      	mov	r5, r3
 8008786:	460c      	mov	r4, r1
 8008788:	3340      	adds	r3, #64	; 0x40
 800878a:	3140      	adds	r1, #64	; 0x40
 800878c:	2e3f      	cmp	r6, #63	; 0x3f
 800878e:	dcb8      	bgt.n	8008702 <memcpy+0x76>
 8008790:	462b      	mov	r3, r5
 8008792:	e00f      	b.n	80087b4 <memcpy+0x128>
 8008794:	f853 1c10 	ldr.w	r1, [r3, #-16]
 8008798:	f844 1c10 	str.w	r1, [r4, #-16]
 800879c:	f853 1c0c 	ldr.w	r1, [r3, #-12]
 80087a0:	f844 1c0c 	str.w	r1, [r4, #-12]
 80087a4:	f853 1c08 	ldr.w	r1, [r3, #-8]
 80087a8:	f844 1c08 	str.w	r1, [r4, #-8]
 80087ac:	f853 1c04 	ldr.w	r1, [r3, #-4]
 80087b0:	f844 1c04 	str.w	r1, [r4, #-4]
 80087b4:	1b16      	subs	r6, r2, r4
 80087b6:	4621      	mov	r1, r4
 80087b8:	461d      	mov	r5, r3
 80087ba:	3410      	adds	r4, #16
 80087bc:	3310      	adds	r3, #16
 80087be:	2e0f      	cmp	r6, #15
 80087c0:	dce8      	bgt.n	8008794 <memcpy+0x108>
 80087c2:	462b      	mov	r3, r5
 80087c4:	e002      	b.n	80087cc <memcpy+0x140>
 80087c6:	6824      	ldr	r4, [r4, #0]
 80087c8:	f841 4b04 	str.w	r4, [r1], #4
 80087cc:	1a55      	subs	r5, r2, r1
 80087ce:	461c      	mov	r4, r3
 80087d0:	2d03      	cmp	r5, #3
 80087d2:	f103 0304 	add.w	r3, r3, #4
 80087d6:	dcf6      	bgt.n	80087c6 <memcpy+0x13a>
 80087d8:	e790      	b.n	80086fc <memcpy+0x70>
 80087da:	bf00      	nop

080087dc <_Balloc>:
 80087dc:	b570      	push	{r4, r5, r6, lr}
 80087de:	4606      	mov	r6, r0
 80087e0:	6a44      	ldr	r4, [r0, #36]	; 0x24
 80087e2:	460d      	mov	r5, r1
 80087e4:	b15c      	cbz	r4, 80087fe <_Balloc+0x22>
 80087e6:	68e3      	ldr	r3, [r4, #12]
 80087e8:	b19b      	cbz	r3, 8008812 <_Balloc+0x36>
 80087ea:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 80087ee:	b1e0      	cbz	r0, 800882a <_Balloc+0x4e>
 80087f0:	6802      	ldr	r2, [r0, #0]
 80087f2:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
 80087f6:	2300      	movs	r3, #0
 80087f8:	6103      	str	r3, [r0, #16]
 80087fa:	60c3      	str	r3, [r0, #12]
 80087fc:	bd70      	pop	{r4, r5, r6, pc}
 80087fe:	2010      	movs	r0, #16
 8008800:	f7fc fa3e 	bl	8004c80 <malloc>
 8008804:	2300      	movs	r3, #0
 8008806:	4604      	mov	r4, r0
 8008808:	6270      	str	r0, [r6, #36]	; 0x24
 800880a:	6043      	str	r3, [r0, #4]
 800880c:	6083      	str	r3, [r0, #8]
 800880e:	6003      	str	r3, [r0, #0]
 8008810:	60c3      	str	r3, [r0, #12]
 8008812:	4630      	mov	r0, r6
 8008814:	2104      	movs	r1, #4
 8008816:	2221      	movs	r2, #33	; 0x21
 8008818:	f001 fb7c 	bl	8009f14 <_calloc_r>
 800881c:	6a73      	ldr	r3, [r6, #36]	; 0x24
 800881e:	60e0      	str	r0, [r4, #12]
 8008820:	68db      	ldr	r3, [r3, #12]
 8008822:	2b00      	cmp	r3, #0
 8008824:	d1e1      	bne.n	80087ea <_Balloc+0xe>
 8008826:	4618      	mov	r0, r3
 8008828:	bd70      	pop	{r4, r5, r6, pc}
 800882a:	2401      	movs	r4, #1
 800882c:	4630      	mov	r0, r6
 800882e:	4621      	mov	r1, r4
 8008830:	40ac      	lsls	r4, r5
 8008832:	1d62      	adds	r2, r4, #5
 8008834:	0092      	lsls	r2, r2, #2
 8008836:	f001 fb6d 	bl	8009f14 <_calloc_r>
 800883a:	2800      	cmp	r0, #0
 800883c:	d0f4      	beq.n	8008828 <_Balloc+0x4c>
 800883e:	6045      	str	r5, [r0, #4]
 8008840:	6084      	str	r4, [r0, #8]
 8008842:	e7d8      	b.n	80087f6 <_Balloc+0x1a>

08008844 <_Bfree>:
 8008844:	b530      	push	{r4, r5, lr}
 8008846:	4604      	mov	r4, r0
 8008848:	6a45      	ldr	r5, [r0, #36]	; 0x24
 800884a:	b083      	sub	sp, #12
 800884c:	b155      	cbz	r5, 8008864 <_Bfree+0x20>
 800884e:	b139      	cbz	r1, 8008860 <_Bfree+0x1c>
 8008850:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008852:	684a      	ldr	r2, [r1, #4]
 8008854:	68db      	ldr	r3, [r3, #12]
 8008856:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 800885a:	6008      	str	r0, [r1, #0]
 800885c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8008860:	b003      	add	sp, #12
 8008862:	bd30      	pop	{r4, r5, pc}
 8008864:	2010      	movs	r0, #16
 8008866:	9101      	str	r1, [sp, #4]
 8008868:	f7fc fa0a 	bl	8004c80 <malloc>
 800886c:	9901      	ldr	r1, [sp, #4]
 800886e:	6260      	str	r0, [r4, #36]	; 0x24
 8008870:	6045      	str	r5, [r0, #4]
 8008872:	6085      	str	r5, [r0, #8]
 8008874:	6005      	str	r5, [r0, #0]
 8008876:	60c5      	str	r5, [r0, #12]
 8008878:	e7e9      	b.n	800884e <_Bfree+0xa>
 800887a:	bf00      	nop

0800887c <__multadd>:
 800887c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008880:	460c      	mov	r4, r1
 8008882:	4605      	mov	r5, r0
 8008884:	690e      	ldr	r6, [r1, #16]
 8008886:	f101 0014 	add.w	r0, r1, #20
 800888a:	b082      	sub	sp, #8
 800888c:	2100      	movs	r1, #0
 800888e:	6807      	ldr	r7, [r0, #0]
 8008890:	3101      	adds	r1, #1
 8008892:	fa1f fc87 	uxth.w	ip, r7
 8008896:	0c3f      	lsrs	r7, r7, #16
 8008898:	fb0c 3302 	mla	r3, ip, r2, r3
 800889c:	fb07 f702 	mul.w	r7, r7, r2
 80088a0:	eb07 4713 	add.w	r7, r7, r3, lsr #16
 80088a4:	fa1f fc83 	uxth.w	ip, r3
 80088a8:	0c3b      	lsrs	r3, r7, #16
 80088aa:	428e      	cmp	r6, r1
 80088ac:	ea4f 4807 	mov.w	r8, r7, lsl #16
 80088b0:	eb08 070c 	add.w	r7, r8, ip
 80088b4:	f840 7b04 	str.w	r7, [r0], #4
 80088b8:	dce9      	bgt.n	800888e <__multadd+0x12>
 80088ba:	b13b      	cbz	r3, 80088cc <__multadd+0x50>
 80088bc:	68a2      	ldr	r2, [r4, #8]
 80088be:	4296      	cmp	r6, r2
 80088c0:	da08      	bge.n	80088d4 <__multadd+0x58>
 80088c2:	eb04 0286 	add.w	r2, r4, r6, lsl #2
 80088c6:	3601      	adds	r6, #1
 80088c8:	6126      	str	r6, [r4, #16]
 80088ca:	6153      	str	r3, [r2, #20]
 80088cc:	4620      	mov	r0, r4
 80088ce:	b002      	add	sp, #8
 80088d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80088d4:	6861      	ldr	r1, [r4, #4]
 80088d6:	4628      	mov	r0, r5
 80088d8:	9301      	str	r3, [sp, #4]
 80088da:	3101      	adds	r1, #1
 80088dc:	f7ff ff7e 	bl	80087dc <_Balloc>
 80088e0:	6922      	ldr	r2, [r4, #16]
 80088e2:	f104 010c 	add.w	r1, r4, #12
 80088e6:	3202      	adds	r2, #2
 80088e8:	0092      	lsls	r2, r2, #2
 80088ea:	4607      	mov	r7, r0
 80088ec:	300c      	adds	r0, #12
 80088ee:	f7ff fecd 	bl	800868c <memcpy>
 80088f2:	4621      	mov	r1, r4
 80088f4:	4628      	mov	r0, r5
 80088f6:	463c      	mov	r4, r7
 80088f8:	f7ff ffa4 	bl	8008844 <_Bfree>
 80088fc:	9b01      	ldr	r3, [sp, #4]
 80088fe:	e7e0      	b.n	80088c2 <__multadd+0x46>

08008900 <__s2b>:
 8008900:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008904:	f648 6539 	movw	r5, #36409	; 0x8e39
 8008908:	461f      	mov	r7, r3
 800890a:	f6c3 05e3 	movt	r5, #14563	; 0x38e3
 800890e:	3308      	adds	r3, #8
 8008910:	460e      	mov	r6, r1
 8008912:	4604      	mov	r4, r0
 8008914:	4690      	mov	r8, r2
 8008916:	fb85 1503 	smull	r1, r5, r5, r3
 800891a:	17db      	asrs	r3, r3, #31
 800891c:	ebc3 0365 	rsb	r3, r3, r5, asr #1
 8008920:	2b01      	cmp	r3, #1
 8008922:	dd37      	ble.n	8008994 <__s2b+0x94>
 8008924:	2201      	movs	r2, #1
 8008926:	2100      	movs	r1, #0
 8008928:	0052      	lsls	r2, r2, #1
 800892a:	3101      	adds	r1, #1
 800892c:	4293      	cmp	r3, r2
 800892e:	dcfb      	bgt.n	8008928 <__s2b+0x28>
 8008930:	4620      	mov	r0, r4
 8008932:	f7ff ff53 	bl	80087dc <_Balloc>
 8008936:	9b08      	ldr	r3, [sp, #32]
 8008938:	6143      	str	r3, [r0, #20]
 800893a:	2301      	movs	r3, #1
 800893c:	f1b8 0f09 	cmp.w	r8, #9
 8008940:	4601      	mov	r1, r0
 8008942:	6103      	str	r3, [r0, #16]
 8008944:	dd22      	ble.n	800898c <__s2b+0x8c>
 8008946:	f106 0909 	add.w	r9, r6, #9
 800894a:	4446      	add	r6, r8
 800894c:	464d      	mov	r5, r9
 800894e:	f815 3b01 	ldrb.w	r3, [r5], #1
 8008952:	220a      	movs	r2, #10
 8008954:	4620      	mov	r0, r4
 8008956:	3b30      	subs	r3, #48	; 0x30
 8008958:	f7ff ff90 	bl	800887c <__multadd>
 800895c:	42b5      	cmp	r5, r6
 800895e:	4601      	mov	r1, r0
 8008960:	d1f5      	bne.n	800894e <__s2b+0x4e>
 8008962:	eb09 0608 	add.w	r6, r9, r8
 8008966:	3e08      	subs	r6, #8
 8008968:	4547      	cmp	r7, r8
 800896a:	dd0c      	ble.n	8008986 <__s2b+0x86>
 800896c:	19f7      	adds	r7, r6, r7
 800896e:	ebc8 0707 	rsb	r7, r8, r7
 8008972:	f816 3b01 	ldrb.w	r3, [r6], #1
 8008976:	220a      	movs	r2, #10
 8008978:	4620      	mov	r0, r4
 800897a:	3b30      	subs	r3, #48	; 0x30
 800897c:	f7ff ff7e 	bl	800887c <__multadd>
 8008980:	42be      	cmp	r6, r7
 8008982:	4601      	mov	r1, r0
 8008984:	d1f5      	bne.n	8008972 <__s2b+0x72>
 8008986:	4608      	mov	r0, r1
 8008988:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800898c:	360a      	adds	r6, #10
 800898e:	f04f 0809 	mov.w	r8, #9
 8008992:	e7e9      	b.n	8008968 <__s2b+0x68>
 8008994:	2100      	movs	r1, #0
 8008996:	e7cb      	b.n	8008930 <__s2b+0x30>

08008998 <__hi0bits>:
 8008998:	0c02      	lsrs	r2, r0, #16
 800899a:	4603      	mov	r3, r0
 800899c:	d119      	bne.n	80089d2 <__hi0bits+0x3a>
 800899e:	0403      	lsls	r3, r0, #16
 80089a0:	2010      	movs	r0, #16
 80089a2:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
 80089a6:	d101      	bne.n	80089ac <__hi0bits+0x14>
 80089a8:	3008      	adds	r0, #8
 80089aa:	021b      	lsls	r3, r3, #8
 80089ac:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
 80089b0:	d101      	bne.n	80089b6 <__hi0bits+0x1e>
 80089b2:	3004      	adds	r0, #4
 80089b4:	011b      	lsls	r3, r3, #4
 80089b6:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
 80089ba:	d101      	bne.n	80089c0 <__hi0bits+0x28>
 80089bc:	3002      	adds	r0, #2
 80089be:	009b      	lsls	r3, r3, #2
 80089c0:	2b00      	cmp	r3, #0
 80089c2:	db05      	blt.n	80089d0 <__hi0bits+0x38>
 80089c4:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
 80089c8:	d001      	beq.n	80089ce <__hi0bits+0x36>
 80089ca:	3001      	adds	r0, #1
 80089cc:	4770      	bx	lr
 80089ce:	2020      	movs	r0, #32
 80089d0:	4770      	bx	lr
 80089d2:	2000      	movs	r0, #0
 80089d4:	e7e5      	b.n	80089a2 <__hi0bits+0xa>
 80089d6:	bf00      	nop

080089d8 <__lo0bits>:
 80089d8:	6803      	ldr	r3, [r0, #0]
 80089da:	4602      	mov	r2, r0
 80089dc:	f013 0007 	ands.w	r0, r3, #7
 80089e0:	d009      	beq.n	80089f6 <__lo0bits+0x1e>
 80089e2:	f013 0f01 	tst.w	r3, #1
 80089e6:	d121      	bne.n	8008a2c <__lo0bits+0x54>
 80089e8:	f013 0f02 	tst.w	r3, #2
 80089ec:	d122      	bne.n	8008a34 <__lo0bits+0x5c>
 80089ee:	089b      	lsrs	r3, r3, #2
 80089f0:	2002      	movs	r0, #2
 80089f2:	6013      	str	r3, [r2, #0]
 80089f4:	4770      	bx	lr
 80089f6:	b299      	uxth	r1, r3
 80089f8:	b909      	cbnz	r1, 80089fe <__lo0bits+0x26>
 80089fa:	0c1b      	lsrs	r3, r3, #16
 80089fc:	2010      	movs	r0, #16
 80089fe:	f013 0fff 	tst.w	r3, #255	; 0xff
 8008a02:	d101      	bne.n	8008a08 <__lo0bits+0x30>
 8008a04:	3008      	adds	r0, #8
 8008a06:	0a1b      	lsrs	r3, r3, #8
 8008a08:	f013 0f0f 	tst.w	r3, #15
 8008a0c:	d101      	bne.n	8008a12 <__lo0bits+0x3a>
 8008a0e:	3004      	adds	r0, #4
 8008a10:	091b      	lsrs	r3, r3, #4
 8008a12:	f013 0f03 	tst.w	r3, #3
 8008a16:	d101      	bne.n	8008a1c <__lo0bits+0x44>
 8008a18:	3002      	adds	r0, #2
 8008a1a:	089b      	lsrs	r3, r3, #2
 8008a1c:	f013 0f01 	tst.w	r3, #1
 8008a20:	d102      	bne.n	8008a28 <__lo0bits+0x50>
 8008a22:	085b      	lsrs	r3, r3, #1
 8008a24:	d004      	beq.n	8008a30 <__lo0bits+0x58>
 8008a26:	3001      	adds	r0, #1
 8008a28:	6013      	str	r3, [r2, #0]
 8008a2a:	4770      	bx	lr
 8008a2c:	2000      	movs	r0, #0
 8008a2e:	4770      	bx	lr
 8008a30:	2020      	movs	r0, #32
 8008a32:	4770      	bx	lr
 8008a34:	085b      	lsrs	r3, r3, #1
 8008a36:	2001      	movs	r0, #1
 8008a38:	6013      	str	r3, [r2, #0]
 8008a3a:	4770      	bx	lr

08008a3c <__i2b>:
 8008a3c:	b510      	push	{r4, lr}
 8008a3e:	460c      	mov	r4, r1
 8008a40:	2101      	movs	r1, #1
 8008a42:	f7ff fecb 	bl	80087dc <_Balloc>
 8008a46:	2201      	movs	r2, #1
 8008a48:	6144      	str	r4, [r0, #20]
 8008a4a:	6102      	str	r2, [r0, #16]
 8008a4c:	bd10      	pop	{r4, pc}
 8008a4e:	bf00      	nop

08008a50 <__multiply>:
 8008a50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008a54:	4690      	mov	r8, r2
 8008a56:	690f      	ldr	r7, [r1, #16]
 8008a58:	460d      	mov	r5, r1
 8008a5a:	6916      	ldr	r6, [r2, #16]
 8008a5c:	b085      	sub	sp, #20
 8008a5e:	42b7      	cmp	r7, r6
 8008a60:	bfbf      	itttt	lt
 8008a62:	4645      	movlt	r5, r8
 8008a64:	463a      	movlt	r2, r7
 8008a66:	4637      	movlt	r7, r6
 8008a68:	4616      	movlt	r6, r2
 8008a6a:	68ab      	ldr	r3, [r5, #8]
 8008a6c:	bfb8      	it	lt
 8008a6e:	4688      	movlt	r8, r1
 8008a70:	19f4      	adds	r4, r6, r7
 8008a72:	6869      	ldr	r1, [r5, #4]
 8008a74:	429c      	cmp	r4, r3
 8008a76:	bfc8      	it	gt
 8008a78:	3101      	addgt	r1, #1
 8008a7a:	f7ff feaf 	bl	80087dc <_Balloc>
 8008a7e:	eb00 0384 	add.w	r3, r0, r4, lsl #2
 8008a82:	f100 0c14 	add.w	ip, r0, #20
 8008a86:	3314      	adds	r3, #20
 8008a88:	9001      	str	r0, [sp, #4]
 8008a8a:	459c      	cmp	ip, r3
 8008a8c:	9302      	str	r3, [sp, #8]
 8008a8e:	d206      	bcs.n	8008a9e <__multiply+0x4e>
 8008a90:	9902      	ldr	r1, [sp, #8]
 8008a92:	4663      	mov	r3, ip
 8008a94:	2200      	movs	r2, #0
 8008a96:	f843 2b04 	str.w	r2, [r3], #4
 8008a9a:	4299      	cmp	r1, r3
 8008a9c:	d8fb      	bhi.n	8008a96 <__multiply+0x46>
 8008a9e:	eb08 0686 	add.w	r6, r8, r6, lsl #2
 8008aa2:	eb05 0787 	add.w	r7, r5, r7, lsl #2
 8008aa6:	f108 0814 	add.w	r8, r8, #20
 8008aaa:	3614      	adds	r6, #20
 8008aac:	3514      	adds	r5, #20
 8008aae:	3714      	adds	r7, #20
 8008ab0:	45b0      	cmp	r8, r6
 8008ab2:	9500      	str	r5, [sp, #0]
 8008ab4:	d24d      	bcs.n	8008b52 <__multiply+0x102>
 8008ab6:	9403      	str	r4, [sp, #12]
 8008ab8:	f858 4b04 	ldr.w	r4, [r8], #4
 8008abc:	b2a0      	uxth	r0, r4
 8008abe:	b1f0      	cbz	r0, 8008afe <__multiply+0xae>
 8008ac0:	9a00      	ldr	r2, [sp, #0]
 8008ac2:	4663      	mov	r3, ip
 8008ac4:	2400      	movs	r4, #0
 8008ac6:	f852 5b04 	ldr.w	r5, [r2], #4
 8008aca:	6819      	ldr	r1, [r3, #0]
 8008acc:	fa1f fa85 	uxth.w	sl, r5
 8008ad0:	0c2d      	lsrs	r5, r5, #16
 8008ad2:	fa1f f981 	uxth.w	r9, r1
 8008ad6:	0c09      	lsrs	r1, r1, #16
 8008ad8:	fb00 990a 	mla	r9, r0, sl, r9
 8008adc:	fb00 1105 	mla	r1, r0, r5, r1
 8008ae0:	44a1      	add	r9, r4
 8008ae2:	eb01 4119 	add.w	r1, r1, r9, lsr #16
 8008ae6:	fa1f f989 	uxth.w	r9, r9
 8008aea:	0c0c      	lsrs	r4, r1, #16
 8008aec:	4297      	cmp	r7, r2
 8008aee:	ea49 4501 	orr.w	r5, r9, r1, lsl #16
 8008af2:	f843 5b04 	str.w	r5, [r3], #4
 8008af6:	d8e6      	bhi.n	8008ac6 <__multiply+0x76>
 8008af8:	601c      	str	r4, [r3, #0]
 8008afa:	f858 4c04 	ldr.w	r4, [r8, #-4]
 8008afe:	0c24      	lsrs	r4, r4, #16
 8008b00:	d021      	beq.n	8008b46 <__multiply+0xf6>
 8008b02:	f8dc 2000 	ldr.w	r2, [ip]
 8008b06:	4660      	mov	r0, ip
 8008b08:	9b00      	ldr	r3, [sp, #0]
 8008b0a:	46e1      	mov	r9, ip
 8008b0c:	4611      	mov	r1, r2
 8008b0e:	2500      	movs	r5, #0
 8008b10:	f8b3 a000 	ldrh.w	sl, [r3]
 8008b14:	fa1f fb82 	uxth.w	fp, r2
 8008b18:	fb0a 5504 	mla	r5, sl, r4, r5
 8008b1c:	eb05 4511 	add.w	r5, r5, r1, lsr #16
 8008b20:	ea4b 4205 	orr.w	r2, fp, r5, lsl #16
 8008b24:	f840 2b04 	str.w	r2, [r0], #4
 8008b28:	f853 2b04 	ldr.w	r2, [r3], #4
 8008b2c:	f859 1f04 	ldr.w	r1, [r9, #4]!
 8008b30:	0c12      	lsrs	r2, r2, #16
 8008b32:	fa1f fa81 	uxth.w	sl, r1
 8008b36:	fb02 a204 	mla	r2, r2, r4, sl
 8008b3a:	eb02 4215 	add.w	r2, r2, r5, lsr #16
 8008b3e:	0c15      	lsrs	r5, r2, #16
 8008b40:	429f      	cmp	r7, r3
 8008b42:	d8e5      	bhi.n	8008b10 <__multiply+0xc0>
 8008b44:	6002      	str	r2, [r0, #0]
 8008b46:	4546      	cmp	r6, r8
 8008b48:	d902      	bls.n	8008b50 <__multiply+0x100>
 8008b4a:	f10c 0c04 	add.w	ip, ip, #4
 8008b4e:	e7b3      	b.n	8008ab8 <__multiply+0x68>
 8008b50:	9c03      	ldr	r4, [sp, #12]
 8008b52:	2c00      	cmp	r4, #0
 8008b54:	dd0a      	ble.n	8008b6c <__multiply+0x11c>
 8008b56:	9902      	ldr	r1, [sp, #8]
 8008b58:	1f0b      	subs	r3, r1, #4
 8008b5a:	f851 2c04 	ldr.w	r2, [r1, #-4]
 8008b5e:	b11a      	cbz	r2, 8008b68 <__multiply+0x118>
 8008b60:	e004      	b.n	8008b6c <__multiply+0x11c>
 8008b62:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 8008b66:	b90a      	cbnz	r2, 8008b6c <__multiply+0x11c>
 8008b68:	3c01      	subs	r4, #1
 8008b6a:	d1fa      	bne.n	8008b62 <__multiply+0x112>
 8008b6c:	9a01      	ldr	r2, [sp, #4]
 8008b6e:	4610      	mov	r0, r2
 8008b70:	6114      	str	r4, [r2, #16]
 8008b72:	b005      	add	sp, #20
 8008b74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08008b78 <__pow5mult>:
 8008b78:	f012 0303 	ands.w	r3, r2, #3
 8008b7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008b80:	4615      	mov	r5, r2
 8008b82:	4604      	mov	r4, r0
 8008b84:	4688      	mov	r8, r1
 8008b86:	d128      	bne.n	8008bda <__pow5mult+0x62>
 8008b88:	10ad      	asrs	r5, r5, #2
 8008b8a:	d01a      	beq.n	8008bc2 <__pow5mult+0x4a>
 8008b8c:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8008b8e:	2e00      	cmp	r6, #0
 8008b90:	d02f      	beq.n	8008bf2 <__pow5mult+0x7a>
 8008b92:	68b7      	ldr	r7, [r6, #8]
 8008b94:	b92f      	cbnz	r7, 8008ba2 <__pow5mult+0x2a>
 8008b96:	e036      	b.n	8008c06 <__pow5mult+0x8e>
 8008b98:	106d      	asrs	r5, r5, #1
 8008b9a:	d012      	beq.n	8008bc2 <__pow5mult+0x4a>
 8008b9c:	683e      	ldr	r6, [r7, #0]
 8008b9e:	b19e      	cbz	r6, 8008bc8 <__pow5mult+0x50>
 8008ba0:	4637      	mov	r7, r6
 8008ba2:	f015 0f01 	tst.w	r5, #1
 8008ba6:	d0f7      	beq.n	8008b98 <__pow5mult+0x20>
 8008ba8:	4641      	mov	r1, r8
 8008baa:	463a      	mov	r2, r7
 8008bac:	4620      	mov	r0, r4
 8008bae:	f7ff ff4f 	bl	8008a50 <__multiply>
 8008bb2:	4641      	mov	r1, r8
 8008bb4:	4606      	mov	r6, r0
 8008bb6:	4620      	mov	r0, r4
 8008bb8:	f7ff fe44 	bl	8008844 <_Bfree>
 8008bbc:	106d      	asrs	r5, r5, #1
 8008bbe:	46b0      	mov	r8, r6
 8008bc0:	d1ec      	bne.n	8008b9c <__pow5mult+0x24>
 8008bc2:	4640      	mov	r0, r8
 8008bc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008bc8:	4639      	mov	r1, r7
 8008bca:	463a      	mov	r2, r7
 8008bcc:	4620      	mov	r0, r4
 8008bce:	f7ff ff3f 	bl	8008a50 <__multiply>
 8008bd2:	6038      	str	r0, [r7, #0]
 8008bd4:	4607      	mov	r7, r0
 8008bd6:	6006      	str	r6, [r0, #0]
 8008bd8:	e7e3      	b.n	8008ba2 <__pow5mult+0x2a>
 8008bda:	f24b 72f8 	movw	r2, #47096	; 0xb7f8
 8008bde:	1e5e      	subs	r6, r3, #1
 8008be0:	f6c0 0200 	movt	r2, #2048	; 0x800
 8008be4:	2300      	movs	r3, #0
 8008be6:	f852 2026 	ldr.w	r2, [r2, r6, lsl #2]
 8008bea:	f7ff fe47 	bl	800887c <__multadd>
 8008bee:	4680      	mov	r8, r0
 8008bf0:	e7ca      	b.n	8008b88 <__pow5mult+0x10>
 8008bf2:	2010      	movs	r0, #16
 8008bf4:	f7fc f844 	bl	8004c80 <malloc>
 8008bf8:	2300      	movs	r3, #0
 8008bfa:	4606      	mov	r6, r0
 8008bfc:	6260      	str	r0, [r4, #36]	; 0x24
 8008bfe:	6043      	str	r3, [r0, #4]
 8008c00:	6083      	str	r3, [r0, #8]
 8008c02:	6003      	str	r3, [r0, #0]
 8008c04:	60c3      	str	r3, [r0, #12]
 8008c06:	4620      	mov	r0, r4
 8008c08:	f240 2171 	movw	r1, #625	; 0x271
 8008c0c:	f7ff ff16 	bl	8008a3c <__i2b>
 8008c10:	2300      	movs	r3, #0
 8008c12:	60b0      	str	r0, [r6, #8]
 8008c14:	4607      	mov	r7, r0
 8008c16:	6003      	str	r3, [r0, #0]
 8008c18:	e7c3      	b.n	8008ba2 <__pow5mult+0x2a>
 8008c1a:	bf00      	nop

08008c1c <__lshift>:
 8008c1c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008c20:	1156      	asrs	r6, r2, #5
 8008c22:	690d      	ldr	r5, [r1, #16]
 8008c24:	460c      	mov	r4, r1
 8008c26:	688b      	ldr	r3, [r1, #8]
 8008c28:	4690      	mov	r8, r2
 8008c2a:	3501      	adds	r5, #1
 8008c2c:	4681      	mov	r9, r0
 8008c2e:	19ad      	adds	r5, r5, r6
 8008c30:	6849      	ldr	r1, [r1, #4]
 8008c32:	429d      	cmp	r5, r3
 8008c34:	dd03      	ble.n	8008c3e <__lshift+0x22>
 8008c36:	005b      	lsls	r3, r3, #1
 8008c38:	3101      	adds	r1, #1
 8008c3a:	429d      	cmp	r5, r3
 8008c3c:	dcfb      	bgt.n	8008c36 <__lshift+0x1a>
 8008c3e:	4648      	mov	r0, r9
 8008c40:	f7ff fdcc 	bl	80087dc <_Balloc>
 8008c44:	2e00      	cmp	r6, #0
 8008c46:	4607      	mov	r7, r0
 8008c48:	f100 0214 	add.w	r2, r0, #20
 8008c4c:	dd0a      	ble.n	8008c64 <__lshift+0x48>
 8008c4e:	2300      	movs	r3, #0
 8008c50:	4619      	mov	r1, r3
 8008c52:	3301      	adds	r3, #1
 8008c54:	f842 1b04 	str.w	r1, [r2], #4
 8008c58:	42b3      	cmp	r3, r6
 8008c5a:	d1fa      	bne.n	8008c52 <__lshift+0x36>
 8008c5c:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 8008c60:	f103 0214 	add.w	r2, r3, #20
 8008c64:	6926      	ldr	r6, [r4, #16]
 8008c66:	f104 0114 	add.w	r1, r4, #20
 8008c6a:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 8008c6e:	3614      	adds	r6, #20
 8008c70:	f018 081f 	ands.w	r8, r8, #31
 8008c74:	d01a      	beq.n	8008cac <__lshift+0x90>
 8008c76:	f1c8 0e20 	rsb	lr, r8, #32
 8008c7a:	2000      	movs	r0, #0
 8008c7c:	680b      	ldr	r3, [r1, #0]
 8008c7e:	fa03 f308 	lsl.w	r3, r3, r8
 8008c82:	4318      	orrs	r0, r3
 8008c84:	f842 0b04 	str.w	r0, [r2], #4
 8008c88:	f851 0b04 	ldr.w	r0, [r1], #4
 8008c8c:	428e      	cmp	r6, r1
 8008c8e:	fa20 f00e 	lsr.w	r0, r0, lr
 8008c92:	d8f3      	bhi.n	8008c7c <__lshift+0x60>
 8008c94:	6010      	str	r0, [r2, #0]
 8008c96:	b100      	cbz	r0, 8008c9a <__lshift+0x7e>
 8008c98:	3501      	adds	r5, #1
 8008c9a:	4648      	mov	r0, r9
 8008c9c:	3d01      	subs	r5, #1
 8008c9e:	4621      	mov	r1, r4
 8008ca0:	613d      	str	r5, [r7, #16]
 8008ca2:	f7ff fdcf 	bl	8008844 <_Bfree>
 8008ca6:	4638      	mov	r0, r7
 8008ca8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8008cac:	f851 3b04 	ldr.w	r3, [r1], #4
 8008cb0:	428e      	cmp	r6, r1
 8008cb2:	f842 3b04 	str.w	r3, [r2], #4
 8008cb6:	d9f0      	bls.n	8008c9a <__lshift+0x7e>
 8008cb8:	f851 3b04 	ldr.w	r3, [r1], #4
 8008cbc:	428e      	cmp	r6, r1
 8008cbe:	f842 3b04 	str.w	r3, [r2], #4
 8008cc2:	d8f3      	bhi.n	8008cac <__lshift+0x90>
 8008cc4:	e7e9      	b.n	8008c9a <__lshift+0x7e>
 8008cc6:	bf00      	nop

08008cc8 <__mcmp>:
 8008cc8:	4603      	mov	r3, r0
 8008cca:	690a      	ldr	r2, [r1, #16]
 8008ccc:	6900      	ldr	r0, [r0, #16]
 8008cce:	b430      	push	{r4, r5}
 8008cd0:	1a80      	subs	r0, r0, r2
 8008cd2:	d10f      	bne.n	8008cf4 <__mcmp+0x2c>
 8008cd4:	3204      	adds	r2, #4
 8008cd6:	f103 0514 	add.w	r5, r3, #20
 8008cda:	0092      	lsls	r2, r2, #2
 8008cdc:	189b      	adds	r3, r3, r2
 8008cde:	1889      	adds	r1, r1, r2
 8008ce0:	3304      	adds	r3, #4
 8008ce2:	3104      	adds	r1, #4
 8008ce4:	f853 4d04 	ldr.w	r4, [r3, #-4]!
 8008ce8:	f851 2d04 	ldr.w	r2, [r1, #-4]!
 8008cec:	4294      	cmp	r4, r2
 8008cee:	d103      	bne.n	8008cf8 <__mcmp+0x30>
 8008cf0:	429d      	cmp	r5, r3
 8008cf2:	d3f7      	bcc.n	8008ce4 <__mcmp+0x1c>
 8008cf4:	bc30      	pop	{r4, r5}
 8008cf6:	4770      	bx	lr
 8008cf8:	bf38      	it	cc
 8008cfa:	f04f 30ff 	movcc.w	r0, #4294967295
 8008cfe:	d3f9      	bcc.n	8008cf4 <__mcmp+0x2c>
 8008d00:	2001      	movs	r0, #1
 8008d02:	e7f7      	b.n	8008cf4 <__mcmp+0x2c>

08008d04 <__mdiff>:
 8008d04:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008d08:	4689      	mov	r9, r1
 8008d0a:	4604      	mov	r4, r0
 8008d0c:	4611      	mov	r1, r2
 8008d0e:	4648      	mov	r0, r9
 8008d10:	4690      	mov	r8, r2
 8008d12:	f7ff ffd9 	bl	8008cc8 <__mcmp>
 8008d16:	1e05      	subs	r5, r0, #0
 8008d18:	d064      	beq.n	8008de4 <__mdiff+0xe0>
 8008d1a:	bfbc      	itt	lt
 8008d1c:	464b      	movlt	r3, r9
 8008d1e:	46c1      	movlt	r9, r8
 8008d20:	4620      	mov	r0, r4
 8008d22:	bfb8      	it	lt
 8008d24:	4698      	movlt	r8, r3
 8008d26:	f8d9 1004 	ldr.w	r1, [r9, #4]
 8008d2a:	bfac      	ite	ge
 8008d2c:	f04f 0a00 	movge.w	sl, #0
 8008d30:	f04f 0a01 	movlt.w	sl, #1
 8008d34:	f7ff fd52 	bl	80087dc <_Balloc>
 8008d38:	f8d9 6010 	ldr.w	r6, [r9, #16]
 8008d3c:	f109 0514 	add.w	r5, r9, #20
 8008d40:	f8d8 3010 	ldr.w	r3, [r8, #16]
 8008d44:	f108 0714 	add.w	r7, r8, #20
 8008d48:	2400      	movs	r4, #0
 8008d4a:	eb09 0986 	add.w	r9, r9, r6, lsl #2
 8008d4e:	f109 0914 	add.w	r9, r9, #20
 8008d52:	4683      	mov	fp, r0
 8008d54:	3014      	adds	r0, #20
 8008d56:	f8cb a00c 	str.w	sl, [fp, #12]
 8008d5a:	eb08 0a83 	add.w	sl, r8, r3, lsl #2
 8008d5e:	f10a 0a14 	add.w	sl, sl, #20
 8008d62:	f855 1b04 	ldr.w	r1, [r5], #4
 8008d66:	4603      	mov	r3, r0
 8008d68:	f857 0b04 	ldr.w	r0, [r7], #4
 8008d6c:	462a      	mov	r2, r5
 8008d6e:	fa1f f881 	uxth.w	r8, r1
 8008d72:	fa1f fc80 	uxth.w	ip, r0
 8008d76:	0c00      	lsrs	r0, r0, #16
 8008d78:	ebcc 0c08 	rsb	ip, ip, r8
 8008d7c:	ebc0 4011 	rsb	r0, r0, r1, lsr #16
 8008d80:	4464      	add	r4, ip
 8008d82:	eb00 4024 	add.w	r0, r0, r4, asr #16
 8008d86:	b2a4      	uxth	r4, r4
 8008d88:	ea44 4100 	orr.w	r1, r4, r0, lsl #16
 8008d8c:	1404      	asrs	r4, r0, #16
 8008d8e:	45ba      	cmp	sl, r7
 8008d90:	f843 1b04 	str.w	r1, [r3], #4
 8008d94:	4618      	mov	r0, r3
 8008d96:	d8e4      	bhi.n	8008d62 <__mdiff+0x5e>
 8008d98:	45a9      	cmp	r9, r5
 8008d9a:	461f      	mov	r7, r3
 8008d9c:	d914      	bls.n	8008dc8 <__mdiff+0xc4>
 8008d9e:	f852 1b04 	ldr.w	r1, [r2], #4
 8008da2:	b288      	uxth	r0, r1
 8008da4:	0c09      	lsrs	r1, r1, #16
 8008da6:	1824      	adds	r4, r4, r0
 8008da8:	eb01 4124 	add.w	r1, r1, r4, asr #16
 8008dac:	b2a4      	uxth	r4, r4
 8008dae:	ea44 4001 	orr.w	r0, r4, r1, lsl #16
 8008db2:	140c      	asrs	r4, r1, #16
 8008db4:	4591      	cmp	r9, r2
 8008db6:	f843 0b04 	str.w	r0, [r3], #4
 8008dba:	d8f0      	bhi.n	8008d9e <__mdiff+0x9a>
 8008dbc:	43eb      	mvns	r3, r5
 8008dbe:	444b      	add	r3, r9
 8008dc0:	f023 0303 	bic.w	r3, r3, #3
 8008dc4:	3304      	adds	r3, #4
 8008dc6:	18fb      	adds	r3, r7, r3
 8008dc8:	f853 2c04 	ldr.w	r2, [r3, #-4]
 8008dcc:	3b04      	subs	r3, #4
 8008dce:	b922      	cbnz	r2, 8008dda <__mdiff+0xd6>
 8008dd0:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 8008dd4:	3e01      	subs	r6, #1
 8008dd6:	2a00      	cmp	r2, #0
 8008dd8:	d0fa      	beq.n	8008dd0 <__mdiff+0xcc>
 8008dda:	f8cb 6010 	str.w	r6, [fp, #16]
 8008dde:	4658      	mov	r0, fp
 8008de0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008de4:	4620      	mov	r0, r4
 8008de6:	4629      	mov	r1, r5
 8008de8:	f7ff fcf8 	bl	80087dc <_Balloc>
 8008dec:	2301      	movs	r3, #1
 8008dee:	4683      	mov	fp, r0
 8008df0:	6145      	str	r5, [r0, #20]
 8008df2:	6103      	str	r3, [r0, #16]
 8008df4:	4658      	mov	r0, fp
 8008df6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008dfa:	bf00      	nop

08008dfc <__ulp>:
 8008dfc:	2300      	movs	r3, #0
 8008dfe:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 8008e02:	ea01 0303 	and.w	r3, r1, r3
 8008e06:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
 8008e0a:	2b00      	cmp	r3, #0
 8008e0c:	dd02      	ble.n	8008e14 <__ulp+0x18>
 8008e0e:	4619      	mov	r1, r3
 8008e10:	2000      	movs	r0, #0
 8008e12:	4770      	bx	lr
 8008e14:	425b      	negs	r3, r3
 8008e16:	151b      	asrs	r3, r3, #20
 8008e18:	2b13      	cmp	r3, #19
 8008e1a:	dd0d      	ble.n	8008e38 <__ulp+0x3c>
 8008e1c:	3b14      	subs	r3, #20
 8008e1e:	2100      	movs	r1, #0
 8008e20:	2b1e      	cmp	r3, #30
 8008e22:	dd02      	ble.n	8008e2a <__ulp+0x2e>
 8008e24:	2301      	movs	r3, #1
 8008e26:	4618      	mov	r0, r3
 8008e28:	4770      	bx	lr
 8008e2a:	2201      	movs	r2, #1
 8008e2c:	f1c3 031f 	rsb	r3, r3, #31
 8008e30:	fa12 f303 	lsls.w	r3, r2, r3
 8008e34:	4618      	mov	r0, r3
 8008e36:	4770      	bx	lr
 8008e38:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8008e3c:	2000      	movs	r0, #0
 8008e3e:	fa52 f103 	asrs.w	r1, r2, r3
 8008e42:	4770      	bx	lr

08008e44 <__b2d>:
 8008e44:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008e48:	f100 0614 	add.w	r6, r0, #20
 8008e4c:	6904      	ldr	r4, [r0, #16]
 8008e4e:	460f      	mov	r7, r1
 8008e50:	3404      	adds	r4, #4
 8008e52:	f850 5024 	ldr.w	r5, [r0, r4, lsl #2]
 8008e56:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 8008e5a:	46a0      	mov	r8, r4
 8008e5c:	4628      	mov	r0, r5
 8008e5e:	f7ff fd9b 	bl	8008998 <__hi0bits>
 8008e62:	280a      	cmp	r0, #10
 8008e64:	f1c0 0320 	rsb	r3, r0, #32
 8008e68:	603b      	str	r3, [r7, #0]
 8008e6a:	dc15      	bgt.n	8008e98 <__b2d+0x54>
 8008e6c:	f1c0 010b 	rsb	r1, r0, #11
 8008e70:	fa35 f701 	lsrs.w	r7, r5, r1
 8008e74:	42a6      	cmp	r6, r4
 8008e76:	f047 577e 	orr.w	r7, r7, #1065353216	; 0x3f800000
 8008e7a:	f447 03e0 	orr.w	r3, r7, #7340032	; 0x700000
 8008e7e:	d233      	bcs.n	8008ee8 <__b2d+0xa4>
 8008e80:	f854 4c04 	ldr.w	r4, [r4, #-4]
 8008e84:	fa34 f101 	lsrs.w	r1, r4, r1
 8008e88:	3015      	adds	r0, #21
 8008e8a:	4085      	lsls	r5, r0
 8008e8c:	ea41 0205 	orr.w	r2, r1, r5
 8008e90:	4610      	mov	r0, r2
 8008e92:	4619      	mov	r1, r3
 8008e94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008e98:	42a6      	cmp	r6, r4
 8008e9a:	d321      	bcc.n	8008ee0 <__b2d+0x9c>
 8008e9c:	2100      	movs	r1, #0
 8008e9e:	380b      	subs	r0, #11
 8008ea0:	bf02      	ittt	eq
 8008ea2:	f045 557e 	orreq.w	r5, r5, #1065353216	; 0x3f800000
 8008ea6:	460a      	moveq	r2, r1
 8008ea8:	f445 03e0 	orreq.w	r3, r5, #7340032	; 0x700000
 8008eac:	d0f0      	beq.n	8008e90 <__b2d+0x4c>
 8008eae:	4085      	lsls	r5, r0
 8008eb0:	f1c0 0720 	rsb	r7, r0, #32
 8008eb4:	f045 557e 	orr.w	r5, r5, #1065353216	; 0x3f800000
 8008eb8:	42b4      	cmp	r4, r6
 8008eba:	fa21 fc07 	lsr.w	ip, r1, r7
 8008ebe:	f445 05e0 	orr.w	r5, r5, #7340032	; 0x700000
 8008ec2:	ea45 030c 	orr.w	r3, r5, ip
 8008ec6:	d911      	bls.n	8008eec <__b2d+0xa8>
 8008ec8:	f854 4c04 	ldr.w	r4, [r4, #-4]
 8008ecc:	fa34 f707 	lsrs.w	r7, r4, r7
 8008ed0:	fa11 f000 	lsls.w	r0, r1, r0
 8008ed4:	4619      	mov	r1, r3
 8008ed6:	ea47 0200 	orr.w	r2, r7, r0
 8008eda:	4610      	mov	r0, r2
 8008edc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008ee0:	3c04      	subs	r4, #4
 8008ee2:	f858 1c04 	ldr.w	r1, [r8, #-4]
 8008ee6:	e7da      	b.n	8008e9e <__b2d+0x5a>
 8008ee8:	2100      	movs	r1, #0
 8008eea:	e7cd      	b.n	8008e88 <__b2d+0x44>
 8008eec:	2700      	movs	r7, #0
 8008eee:	e7ef      	b.n	8008ed0 <__b2d+0x8c>

08008ef0 <__d2b>:
 8008ef0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008ef4:	b083      	sub	sp, #12
 8008ef6:	2101      	movs	r1, #1
 8008ef8:	461d      	mov	r5, r3
 8008efa:	4614      	mov	r4, r2
 8008efc:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8008efe:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 8008f00:	f7ff fc6c 	bl	80087dc <_Balloc>
 8008f04:	f3c5 590a 	ubfx	r9, r5, #20, #11
 8008f08:	f025 437f 	bic.w	r3, r5, #4278190080	; 0xff000000
 8008f0c:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 8008f10:	9300      	str	r3, [sp, #0]
 8008f12:	4680      	mov	r8, r0
 8008f14:	f1b9 0f00 	cmp.w	r9, #0
 8008f18:	d002      	beq.n	8008f20 <__d2b+0x30>
 8008f1a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8008f1e:	9300      	str	r3, [sp, #0]
 8008f20:	2c00      	cmp	r4, #0
 8008f22:	d025      	beq.n	8008f70 <__d2b+0x80>
 8008f24:	a802      	add	r0, sp, #8
 8008f26:	f840 4d04 	str.w	r4, [r0, #-4]!
 8008f2a:	f7ff fd55 	bl	80089d8 <__lo0bits>
 8008f2e:	2800      	cmp	r0, #0
 8008f30:	d136      	bne.n	8008fa0 <__d2b+0xb0>
 8008f32:	9a01      	ldr	r2, [sp, #4]
 8008f34:	9b00      	ldr	r3, [sp, #0]
 8008f36:	f8c8 2014 	str.w	r2, [r8, #20]
 8008f3a:	2b00      	cmp	r3, #0
 8008f3c:	bf0c      	ite	eq
 8008f3e:	2401      	moveq	r4, #1
 8008f40:	2402      	movne	r4, #2
 8008f42:	f8c8 3018 	str.w	r3, [r8, #24]
 8008f46:	f8c8 4010 	str.w	r4, [r8, #16]
 8008f4a:	f1b9 0f00 	cmp.w	r9, #0
 8008f4e:	d11d      	bne.n	8008f8c <__d2b+0x9c>
 8008f50:	eb08 0384 	add.w	r3, r8, r4, lsl #2
 8008f54:	f5a0 6086 	sub.w	r0, r0, #1072	; 0x430
 8008f58:	3802      	subs	r0, #2
 8008f5a:	6038      	str	r0, [r7, #0]
 8008f5c:	6918      	ldr	r0, [r3, #16]
 8008f5e:	0164      	lsls	r4, r4, #5
 8008f60:	f7ff fd1a 	bl	8008998 <__hi0bits>
 8008f64:	1a24      	subs	r4, r4, r0
 8008f66:	6034      	str	r4, [r6, #0]
 8008f68:	4640      	mov	r0, r8
 8008f6a:	b003      	add	sp, #12
 8008f6c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8008f70:	4668      	mov	r0, sp
 8008f72:	f7ff fd31 	bl	80089d8 <__lo0bits>
 8008f76:	2301      	movs	r3, #1
 8008f78:	461c      	mov	r4, r3
 8008f7a:	f8c8 3010 	str.w	r3, [r8, #16]
 8008f7e:	9b00      	ldr	r3, [sp, #0]
 8008f80:	f8c8 3014 	str.w	r3, [r8, #20]
 8008f84:	3020      	adds	r0, #32
 8008f86:	f1b9 0f00 	cmp.w	r9, #0
 8008f8a:	d0e1      	beq.n	8008f50 <__d2b+0x60>
 8008f8c:	f5a9 6986 	sub.w	r9, r9, #1072	; 0x430
 8008f90:	f1c0 0335 	rsb	r3, r0, #53	; 0x35
 8008f94:	f1a9 0903 	sub.w	r9, r9, #3
 8008f98:	4448      	add	r0, r9
 8008f9a:	6038      	str	r0, [r7, #0]
 8008f9c:	6033      	str	r3, [r6, #0]
 8008f9e:	e7e3      	b.n	8008f68 <__d2b+0x78>
 8008fa0:	9b00      	ldr	r3, [sp, #0]
 8008fa2:	f1c0 0220 	rsb	r2, r0, #32
 8008fa6:	9901      	ldr	r1, [sp, #4]
 8008fa8:	fa13 f202 	lsls.w	r2, r3, r2
 8008fac:	40c3      	lsrs	r3, r0
 8008fae:	430a      	orrs	r2, r1
 8008fb0:	9300      	str	r3, [sp, #0]
 8008fb2:	f8c8 2014 	str.w	r2, [r8, #20]
 8008fb6:	e7c0      	b.n	8008f3a <__d2b+0x4a>

08008fb8 <__ratio>:
 8008fb8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008fbc:	b082      	sub	sp, #8
 8008fbe:	4688      	mov	r8, r1
 8008fc0:	a901      	add	r1, sp, #4
 8008fc2:	4606      	mov	r6, r0
 8008fc4:	f7ff ff3e 	bl	8008e44 <__b2d>
 8008fc8:	460d      	mov	r5, r1
 8008fca:	4604      	mov	r4, r0
 8008fcc:	4669      	mov	r1, sp
 8008fce:	4640      	mov	r0, r8
 8008fd0:	f7ff ff38 	bl	8008e44 <__b2d>
 8008fd4:	f8d8 e010 	ldr.w	lr, [r8, #16]
 8008fd8:	f8d6 c010 	ldr.w	ip, [r6, #16]
 8008fdc:	f8dd 8004 	ldr.w	r8, [sp, #4]
 8008fe0:	ebce 0c0c 	rsb	ip, lr, ip
 8008fe4:	f8dd e000 	ldr.w	lr, [sp]
 8008fe8:	ea4f 1c4c 	mov.w	ip, ip, lsl #5
 8008fec:	ebce 0e08 	rsb	lr, lr, r8
 8008ff0:	44e6      	add	lr, ip
 8008ff2:	f1be 0f00 	cmp.w	lr, #0
 8008ff6:	ea4f 5e0e 	mov.w	lr, lr, lsl #20
 8008ffa:	bfc4      	itt	gt
 8008ffc:	eb0e 0705 	addgt.w	r7, lr, r5
 8009000:	463d      	movgt	r5, r7
 8009002:	460b      	mov	r3, r1
 8009004:	bfd8      	it	le
 8009006:	ebce 0101 	rsble	r1, lr, r1
 800900a:	4602      	mov	r2, r0
 800900c:	bfdc      	itt	le
 800900e:	460b      	movle	r3, r1
 8009010:	4602      	movle	r2, r0
 8009012:	4629      	mov	r1, r5
 8009014:	4620      	mov	r0, r4
 8009016:	f001 fe33 	bl	800ac80 <__aeabi_ddiv>
 800901a:	b002      	add	sp, #8
 800901c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08009020 <_mprec_log10>:
 8009020:	2817      	cmp	r0, #23
 8009022:	b510      	push	{r4, lr}
 8009024:	4604      	mov	r4, r0
 8009026:	dd0c      	ble.n	8009042 <_mprec_log10+0x22>
 8009028:	2100      	movs	r1, #0
 800902a:	2000      	movs	r0, #0
 800902c:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
 8009030:	2300      	movs	r3, #0
 8009032:	2200      	movs	r2, #0
 8009034:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8009038:	f001 fcf8 	bl	800aa2c <__aeabi_dmul>
 800903c:	3c01      	subs	r4, #1
 800903e:	d1f7      	bne.n	8009030 <_mprec_log10+0x10>
 8009040:	bd10      	pop	{r4, pc}
 8009042:	f24b 73f8 	movw	r3, #47096	; 0xb7f8
 8009046:	f6c0 0300 	movt	r3, #2048	; 0x800
 800904a:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 800904e:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8009052:	bd10      	pop	{r4, pc}

08009054 <__copybits>:
 8009054:	b470      	push	{r4, r5, r6}
 8009056:	3901      	subs	r1, #1
 8009058:	6916      	ldr	r6, [r2, #16]
 800905a:	f102 0314 	add.w	r3, r2, #20
 800905e:	1149      	asrs	r1, r1, #5
 8009060:	3101      	adds	r1, #1
 8009062:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 8009066:	3614      	adds	r6, #20
 8009068:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 800906c:	42b3      	cmp	r3, r6
 800906e:	d20c      	bcs.n	800908a <__copybits+0x36>
 8009070:	4604      	mov	r4, r0
 8009072:	f853 5b04 	ldr.w	r5, [r3], #4
 8009076:	429e      	cmp	r6, r3
 8009078:	f844 5b04 	str.w	r5, [r4], #4
 800907c:	d8f9      	bhi.n	8009072 <__copybits+0x1e>
 800907e:	1ab3      	subs	r3, r6, r2
 8009080:	3b15      	subs	r3, #21
 8009082:	f023 0303 	bic.w	r3, r3, #3
 8009086:	3304      	adds	r3, #4
 8009088:	18c0      	adds	r0, r0, r3
 800908a:	4281      	cmp	r1, r0
 800908c:	d904      	bls.n	8009098 <__copybits+0x44>
 800908e:	2300      	movs	r3, #0
 8009090:	f840 3b04 	str.w	r3, [r0], #4
 8009094:	4281      	cmp	r1, r0
 8009096:	d8fb      	bhi.n	8009090 <__copybits+0x3c>
 8009098:	bc70      	pop	{r4, r5, r6}
 800909a:	4770      	bx	lr

0800909c <__any_on>:
 800909c:	6902      	ldr	r2, [r0, #16]
 800909e:	114b      	asrs	r3, r1, #5
 80090a0:	b410      	push	{r4}
 80090a2:	429a      	cmp	r2, r3
 80090a4:	db11      	blt.n	80090ca <__any_on+0x2e>
 80090a6:	dd0f      	ble.n	80090c8 <__any_on+0x2c>
 80090a8:	f011 011f 	ands.w	r1, r1, #31
 80090ac:	d00c      	beq.n	80090c8 <__any_on+0x2c>
 80090ae:	461a      	mov	r2, r3
 80090b0:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80090b4:	695b      	ldr	r3, [r3, #20]
 80090b6:	fa33 f401 	lsrs.w	r4, r3, r1
 80090ba:	fa14 f101 	lsls.w	r1, r4, r1
 80090be:	4299      	cmp	r1, r3
 80090c0:	d003      	beq.n	80090ca <__any_on+0x2e>
 80090c2:	2001      	movs	r0, #1
 80090c4:	bc10      	pop	{r4}
 80090c6:	4770      	bx	lr
 80090c8:	461a      	mov	r2, r3
 80090ca:	3204      	adds	r2, #4
 80090cc:	f100 0114 	add.w	r1, r0, #20
 80090d0:	eb00 0382 	add.w	r3, r0, r2, lsl #2
 80090d4:	1d1c      	adds	r4, r3, #4
 80090d6:	42a1      	cmp	r1, r4
 80090d8:	d20b      	bcs.n	80090f2 <__any_on+0x56>
 80090da:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 80090de:	2a00      	cmp	r2, #0
 80090e0:	d1ef      	bne.n	80090c2 <__any_on+0x26>
 80090e2:	4299      	cmp	r1, r3
 80090e4:	d205      	bcs.n	80090f2 <__any_on+0x56>
 80090e6:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 80090ea:	2a00      	cmp	r2, #0
 80090ec:	d1e9      	bne.n	80090c2 <__any_on+0x26>
 80090ee:	4299      	cmp	r1, r3
 80090f0:	d3f9      	bcc.n	80090e6 <__any_on+0x4a>
 80090f2:	2000      	movs	r0, #0
 80090f4:	e7e6      	b.n	80090c4 <__any_on+0x28>
 80090f6:	bf00      	nop

080090f8 <_read_r>:
 80090f8:	b538      	push	{r3, r4, r5, lr}
 80090fa:	f641 24e4 	movw	r4, #6884	; 0x1ae4
 80090fe:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8009102:	4605      	mov	r5, r0
 8009104:	4608      	mov	r0, r1
 8009106:	4611      	mov	r1, r2
 8009108:	461a      	mov	r2, r3
 800910a:	2300      	movs	r3, #0
 800910c:	6023      	str	r3, [r4, #0]
 800910e:	f7f7 fc59 	bl	80009c4 <_read>
 8009112:	f1b0 3fff 	cmp.w	r0, #4294967295
 8009116:	d000      	beq.n	800911a <_read_r+0x22>
 8009118:	bd38      	pop	{r3, r4, r5, pc}
 800911a:	6823      	ldr	r3, [r4, #0]
 800911c:	2b00      	cmp	r3, #0
 800911e:	d0fb      	beq.n	8009118 <_read_r+0x20>
 8009120:	602b      	str	r3, [r5, #0]
 8009122:	bd38      	pop	{r3, r4, r5, pc}

08009124 <cleanup_glue>:
 8009124:	b570      	push	{r4, r5, r6, lr}
 8009126:	460c      	mov	r4, r1
 8009128:	6809      	ldr	r1, [r1, #0]
 800912a:	4605      	mov	r5, r0
 800912c:	b109      	cbz	r1, 8009132 <cleanup_glue+0xe>
 800912e:	f7ff fff9 	bl	8009124 <cleanup_glue>
 8009132:	4628      	mov	r0, r5
 8009134:	4621      	mov	r1, r4
 8009136:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800913a:	f7fc bc93 	b.w	8005a64 <_free_r>
 800913e:	bf00      	nop

08009140 <_reclaim_reent>:
 8009140:	f240 236c 	movw	r3, #620	; 0x26c
 8009144:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009148:	b570      	push	{r4, r5, r6, lr}
 800914a:	4605      	mov	r5, r0
 800914c:	681b      	ldr	r3, [r3, #0]
 800914e:	4298      	cmp	r0, r3
 8009150:	d04a      	beq.n	80091e8 <_reclaim_reent+0xa8>
 8009152:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8009154:	b302      	cbz	r2, 8009198 <_reclaim_reent+0x58>
 8009156:	68d3      	ldr	r3, [r2, #12]
 8009158:	b1cb      	cbz	r3, 800918e <_reclaim_reent+0x4e>
 800915a:	2100      	movs	r1, #0
 800915c:	460e      	mov	r6, r1
 800915e:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 8009162:	b909      	cbnz	r1, 8009168 <_reclaim_reent+0x28>
 8009164:	e008      	b.n	8009178 <_reclaim_reent+0x38>
 8009166:	4621      	mov	r1, r4
 8009168:	680c      	ldr	r4, [r1, #0]
 800916a:	4628      	mov	r0, r5
 800916c:	f7fc fc7a 	bl	8005a64 <_free_r>
 8009170:	2c00      	cmp	r4, #0
 8009172:	d1f8      	bne.n	8009166 <_reclaim_reent+0x26>
 8009174:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8009176:	68d3      	ldr	r3, [r2, #12]
 8009178:	3601      	adds	r6, #1
 800917a:	2e20      	cmp	r6, #32
 800917c:	4631      	mov	r1, r6
 800917e:	d001      	beq.n	8009184 <_reclaim_reent+0x44>
 8009180:	68d3      	ldr	r3, [r2, #12]
 8009182:	e7ec      	b.n	800915e <_reclaim_reent+0x1e>
 8009184:	4628      	mov	r0, r5
 8009186:	4619      	mov	r1, r3
 8009188:	f7fc fc6c 	bl	8005a64 <_free_r>
 800918c:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800918e:	6811      	ldr	r1, [r2, #0]
 8009190:	b111      	cbz	r1, 8009198 <_reclaim_reent+0x58>
 8009192:	4628      	mov	r0, r5
 8009194:	f7fc fc66 	bl	8005a64 <_free_r>
 8009198:	6969      	ldr	r1, [r5, #20]
 800919a:	b111      	cbz	r1, 80091a2 <_reclaim_reent+0x62>
 800919c:	4628      	mov	r0, r5
 800919e:	f7fc fc61 	bl	8005a64 <_free_r>
 80091a2:	6a69      	ldr	r1, [r5, #36]	; 0x24
 80091a4:	b111      	cbz	r1, 80091ac <_reclaim_reent+0x6c>
 80091a6:	4628      	mov	r0, r5
 80091a8:	f7fc fc5c 	bl	8005a64 <_free_r>
 80091ac:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 80091ae:	b111      	cbz	r1, 80091b6 <_reclaim_reent+0x76>
 80091b0:	4628      	mov	r0, r5
 80091b2:	f7fc fc57 	bl	8005a64 <_free_r>
 80091b6:	6be9      	ldr	r1, [r5, #60]	; 0x3c
 80091b8:	b111      	cbz	r1, 80091c0 <_reclaim_reent+0x80>
 80091ba:	4628      	mov	r0, r5
 80091bc:	f7fc fc52 	bl	8005a64 <_free_r>
 80091c0:	6c29      	ldr	r1, [r5, #64]	; 0x40
 80091c2:	b111      	cbz	r1, 80091ca <_reclaim_reent+0x8a>
 80091c4:	4628      	mov	r0, r5
 80091c6:	f7fc fc4d 	bl	8005a64 <_free_r>
 80091ca:	6cab      	ldr	r3, [r5, #72]	; 0x48
 80091cc:	b12b      	cbz	r3, 80091da <_reclaim_reent+0x9a>
 80091ce:	f8d3 1088 	ldr.w	r1, [r3, #136]	; 0x88
 80091d2:	b111      	cbz	r1, 80091da <_reclaim_reent+0x9a>
 80091d4:	4628      	mov	r0, r5
 80091d6:	f7fc fc45 	bl	8005a64 <_free_r>
 80091da:	6b69      	ldr	r1, [r5, #52]	; 0x34
 80091dc:	b111      	cbz	r1, 80091e4 <_reclaim_reent+0xa4>
 80091de:	4628      	mov	r0, r5
 80091e0:	f7fc fc40 	bl	8005a64 <_free_r>
 80091e4:	69ab      	ldr	r3, [r5, #24]
 80091e6:	b903      	cbnz	r3, 80091ea <_reclaim_reent+0xaa>
 80091e8:	bd70      	pop	{r4, r5, r6, pc}
 80091ea:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80091ec:	4628      	mov	r0, r5
 80091ee:	4798      	blx	r3
 80091f0:	f8d5 10d8 	ldr.w	r1, [r5, #216]	; 0xd8
 80091f4:	2900      	cmp	r1, #0
 80091f6:	d0f7      	beq.n	80091e8 <_reclaim_reent+0xa8>
 80091f8:	4628      	mov	r0, r5
 80091fa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80091fe:	e791      	b.n	8009124 <cleanup_glue>

08009200 <_wrapup_reent>:
 8009200:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009202:	4607      	mov	r7, r0
 8009204:	b198      	cbz	r0, 800922e <_wrapup_reent+0x2e>
 8009206:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8009208:	b163      	cbz	r3, 8009224 <_wrapup_reent+0x24>
 800920a:	685e      	ldr	r6, [r3, #4]
 800920c:	2e00      	cmp	r6, #0
 800920e:	dd09      	ble.n	8009224 <_wrapup_reent+0x24>
 8009210:	1cb5      	adds	r5, r6, #2
 8009212:	2400      	movs	r4, #0
 8009214:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8009218:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 800921c:	3401      	adds	r4, #1
 800921e:	4798      	blx	r3
 8009220:	42b4      	cmp	r4, r6
 8009222:	d1f9      	bne.n	8009218 <_wrapup_reent+0x18>
 8009224:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009226:	b10b      	cbz	r3, 800922c <_wrapup_reent+0x2c>
 8009228:	4638      	mov	r0, r7
 800922a:	4798      	blx	r3
 800922c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800922e:	f240 236c 	movw	r3, #620	; 0x26c
 8009232:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009236:	681f      	ldr	r7, [r3, #0]
 8009238:	e7e5      	b.n	8009206 <_wrapup_reent+0x6>
 800923a:	bf00      	nop

0800923c <__fpclassifyd>:
 800923c:	ea50 0301 	orrs.w	r3, r0, r1
 8009240:	b410      	push	{r4}
 8009242:	d03c      	beq.n	80092be <__fpclassifyd+0x82>
 8009244:	f1d0 0201 	rsbs	r2, r0, #1
 8009248:	bf38      	it	cc
 800924a:	2200      	movcc	r2, #0
 800924c:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 8009250:	bf14      	ite	ne
 8009252:	2300      	movne	r3, #0
 8009254:	f002 0301 	andeq.w	r3, r2, #1
 8009258:	2b00      	cmp	r3, #0
 800925a:	d130      	bne.n	80092be <__fpclassifyd+0x82>
 800925c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009260:	f5a1 1080 	sub.w	r0, r1, #1048576	; 0x100000
 8009264:	f6c7 73df 	movt	r3, #32735	; 0x7fdf
 8009268:	f101 44fe 	add.w	r4, r1, #2130706432	; 0x7f000000
 800926c:	4298      	cmp	r0, r3
 800926e:	f504 0470 	add.w	r4, r4, #15728640	; 0xf00000
 8009272:	bf8c      	ite	hi
 8009274:	2000      	movhi	r0, #0
 8009276:	2001      	movls	r0, #1
 8009278:	429c      	cmp	r4, r3
 800927a:	bf8c      	ite	hi
 800927c:	4603      	movhi	r3, r0
 800927e:	f040 0301 	orrls.w	r3, r0, #1
 8009282:	2b00      	cmp	r3, #0
 8009284:	d120      	bne.n	80092c8 <__fpclassifyd+0x8c>
 8009286:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 800928a:	f101 4000 	add.w	r0, r1, #2147483648	; 0x80000000
 800928e:	bf2c      	ite	cs
 8009290:	2300      	movcs	r3, #0
 8009292:	2301      	movcc	r3, #1
 8009294:	f5b0 1f80 	cmp.w	r0, #1048576	; 0x100000
 8009298:	bf38      	it	cc
 800929a:	f043 0301 	orrcc.w	r3, r3, #1
 800929e:	b98b      	cbnz	r3, 80092c4 <__fpclassifyd+0x88>
 80092a0:	f511 1f80 	cmn.w	r1, #1048576	; 0x100000
 80092a4:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 80092a8:	bf14      	ite	ne
 80092aa:	2000      	movne	r0, #0
 80092ac:	2001      	moveq	r0, #1
 80092ae:	4299      	cmp	r1, r3
 80092b0:	bf14      	ite	ne
 80092b2:	4601      	movne	r1, r0
 80092b4:	f040 0101 	orreq.w	r1, r0, #1
 80092b8:	ea02 0001 	and.w	r0, r2, r1
 80092bc:	e000      	b.n	80092c0 <__fpclassifyd+0x84>
 80092be:	2002      	movs	r0, #2
 80092c0:	bc10      	pop	{r4}
 80092c2:	4770      	bx	lr
 80092c4:	2003      	movs	r0, #3
 80092c6:	e7fb      	b.n	80092c0 <__fpclassifyd+0x84>
 80092c8:	2004      	movs	r0, #4
 80092ca:	e7f9      	b.n	80092c0 <__fpclassifyd+0x84>

080092cc <strlen>:
 80092cc:	f020 0103 	bic.w	r1, r0, #3
 80092d0:	f010 0003 	ands.w	r0, r0, #3
 80092d4:	f1c0 0000 	rsb	r0, r0, #0
 80092d8:	f851 3b04 	ldr.w	r3, [r1], #4
 80092dc:	f100 0c04 	add.w	ip, r0, #4
 80092e0:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 80092e4:	f06f 0200 	mvn.w	r2, #0
 80092e8:	bf1c      	itt	ne
 80092ea:	fa22 f20c 	lsrne.w	r2, r2, ip
 80092ee:	4313      	orrne	r3, r2
 80092f0:	f04f 0c01 	mov.w	ip, #1
 80092f4:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 80092f8:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 80092fc:	eba3 020c 	sub.w	r2, r3, ip
 8009300:	ea22 0203 	bic.w	r2, r2, r3
 8009304:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 8009308:	bf04      	itt	eq
 800930a:	f851 3b04 	ldreq.w	r3, [r1], #4
 800930e:	3004      	addeq	r0, #4
 8009310:	d0f4      	beq.n	80092fc <strlen+0x30>
 8009312:	f013 0fff 	tst.w	r3, #255	; 0xff
 8009316:	bf1f      	itttt	ne
 8009318:	3001      	addne	r0, #1
 800931a:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
 800931e:	3001      	addne	r0, #1
 8009320:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
 8009324:	bf18      	it	ne
 8009326:	3001      	addne	r0, #1
 8009328:	4770      	bx	lr
 800932a:	bf00      	nop

0800932c <__ssprint_r>:
 800932c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009330:	b083      	sub	sp, #12
 8009332:	4691      	mov	r9, r2
 8009334:	460d      	mov	r5, r1
 8009336:	9001      	str	r0, [sp, #4]
 8009338:	6890      	ldr	r0, [r2, #8]
 800933a:	6817      	ldr	r7, [r2, #0]
 800933c:	2800      	cmp	r0, #0
 800933e:	d077      	beq.n	8009430 <__ssprint_r+0x104>
 8009340:	f04f 0a00 	mov.w	sl, #0
 8009344:	6808      	ldr	r0, [r1, #0]
 8009346:	688b      	ldr	r3, [r1, #8]
 8009348:	4654      	mov	r4, sl
 800934a:	2c00      	cmp	r4, #0
 800934c:	d04c      	beq.n	80093e8 <__ssprint_r+0xbc>
 800934e:	429c      	cmp	r4, r3
 8009350:	461e      	mov	r6, r3
 8009352:	4698      	mov	r8, r3
 8009354:	bf3c      	itt	cc
 8009356:	4626      	movcc	r6, r4
 8009358:	46a0      	movcc	r8, r4
 800935a:	d335      	bcc.n	80093c8 <__ssprint_r+0x9c>
 800935c:	89ab      	ldrh	r3, [r5, #12]
 800935e:	f413 6f90 	tst.w	r3, #1152	; 0x480
 8009362:	d031      	beq.n	80093c8 <__ssprint_r+0x9c>
 8009364:	696a      	ldr	r2, [r5, #20]
 8009366:	f104 0e01 	add.w	lr, r4, #1
 800936a:	6929      	ldr	r1, [r5, #16]
 800936c:	eb02 0b42 	add.w	fp, r2, r2, lsl #1
 8009370:	1a46      	subs	r6, r0, r1
 8009372:	eb0e 0006 	add.w	r0, lr, r6
 8009376:	eb0b 7bdb 	add.w	fp, fp, fp, lsr #31
 800937a:	ea4f 0b6b 	mov.w	fp, fp, asr #1
 800937e:	4583      	cmp	fp, r0
 8009380:	465a      	mov	r2, fp
 8009382:	bf3c      	itt	cc
 8009384:	4683      	movcc	fp, r0
 8009386:	4602      	movcc	r2, r0
 8009388:	f413 6f80 	tst.w	r3, #1024	; 0x400
 800938c:	d031      	beq.n	80093f2 <__ssprint_r+0xc6>
 800938e:	9801      	ldr	r0, [sp, #4]
 8009390:	4611      	mov	r1, r2
 8009392:	f7fb fc85 	bl	8004ca0 <_malloc_r>
 8009396:	4680      	mov	r8, r0
 8009398:	2800      	cmp	r0, #0
 800939a:	d034      	beq.n	8009406 <__ssprint_r+0xda>
 800939c:	6929      	ldr	r1, [r5, #16]
 800939e:	4632      	mov	r2, r6
 80093a0:	f7ff f974 	bl	800868c <memcpy>
 80093a4:	89ab      	ldrh	r3, [r5, #12]
 80093a6:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 80093aa:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80093ae:	81ab      	strh	r3, [r5, #12]
 80093b0:	eb08 0006 	add.w	r0, r8, r6
 80093b4:	ebc6 030b 	rsb	r3, r6, fp
 80093b8:	f8c5 8010 	str.w	r8, [r5, #16]
 80093bc:	4626      	mov	r6, r4
 80093be:	46a0      	mov	r8, r4
 80093c0:	6028      	str	r0, [r5, #0]
 80093c2:	f8c5 b014 	str.w	fp, [r5, #20]
 80093c6:	60ab      	str	r3, [r5, #8]
 80093c8:	4642      	mov	r2, r8
 80093ca:	4651      	mov	r1, sl
 80093cc:	f000 fdd0 	bl	8009f70 <memmove>
 80093d0:	f8d9 2008 	ldr.w	r2, [r9, #8]
 80093d4:	68ab      	ldr	r3, [r5, #8]
 80093d6:	6828      	ldr	r0, [r5, #0]
 80093d8:	1b14      	subs	r4, r2, r4
 80093da:	1b9b      	subs	r3, r3, r6
 80093dc:	60ab      	str	r3, [r5, #8]
 80093de:	4440      	add	r0, r8
 80093e0:	6028      	str	r0, [r5, #0]
 80093e2:	f8c9 4008 	str.w	r4, [r9, #8]
 80093e6:	b1ec      	cbz	r4, 8009424 <__ssprint_r+0xf8>
 80093e8:	f8d7 a000 	ldr.w	sl, [r7]
 80093ec:	687c      	ldr	r4, [r7, #4]
 80093ee:	3708      	adds	r7, #8
 80093f0:	e7ab      	b.n	800934a <__ssprint_r+0x1e>
 80093f2:	9801      	ldr	r0, [sp, #4]
 80093f4:	f000 fe16 	bl	800a024 <_realloc_r>
 80093f8:	4680      	mov	r8, r0
 80093fa:	2800      	cmp	r0, #0
 80093fc:	d1d8      	bne.n	80093b0 <__ssprint_r+0x84>
 80093fe:	9801      	ldr	r0, [sp, #4]
 8009400:	6929      	ldr	r1, [r5, #16]
 8009402:	f7fc fb2f 	bl	8005a64 <_free_r>
 8009406:	9a01      	ldr	r2, [sp, #4]
 8009408:	230c      	movs	r3, #12
 800940a:	f04f 30ff 	mov.w	r0, #4294967295
 800940e:	6013      	str	r3, [r2, #0]
 8009410:	2300      	movs	r3, #0
 8009412:	89aa      	ldrh	r2, [r5, #12]
 8009414:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8009418:	81aa      	strh	r2, [r5, #12]
 800941a:	f8c9 3008 	str.w	r3, [r9, #8]
 800941e:	f8c9 3004 	str.w	r3, [r9, #4]
 8009422:	e002      	b.n	800942a <__ssprint_r+0xfe>
 8009424:	4620      	mov	r0, r4
 8009426:	f8c9 4004 	str.w	r4, [r9, #4]
 800942a:	b003      	add	sp, #12
 800942c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009430:	6050      	str	r0, [r2, #4]
 8009432:	e7fa      	b.n	800942a <__ssprint_r+0xfe>

08009434 <_svfiprintf_r>:
 8009434:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009438:	b0ab      	sub	sp, #172	; 0xac
 800943a:	4689      	mov	r9, r1
 800943c:	4683      	mov	fp, r0
 800943e:	9306      	str	r3, [sp, #24]
 8009440:	898b      	ldrh	r3, [r1, #12]
 8009442:	f013 0f80 	tst.w	r3, #128	; 0x80
 8009446:	d003      	beq.n	8009450 <_svfiprintf_r+0x1c>
 8009448:	690b      	ldr	r3, [r1, #16]
 800944a:	2b00      	cmp	r3, #0
 800944c:	f000 8515 	beq.w	8009e7a <_svfiprintf_r+0xa46>
 8009450:	4617      	mov	r7, r2
 8009452:	2300      	movs	r3, #0
 8009454:	ae0c      	add	r6, sp, #48	; 0x30
 8009456:	9308      	str	r3, [sp, #32]
 8009458:	9305      	str	r3, [sp, #20]
 800945a:	9626      	str	r6, [sp, #152]	; 0x98
 800945c:	9328      	str	r3, [sp, #160]	; 0xa0
 800945e:	9327      	str	r3, [sp, #156]	; 0x9c
 8009460:	783b      	ldrb	r3, [r7, #0]
 8009462:	f1b3 0225 	subs.w	r2, r3, #37	; 0x25
 8009466:	bf18      	it	ne
 8009468:	2201      	movne	r2, #1
 800946a:	2b00      	cmp	r3, #0
 800946c:	bf0c      	ite	eq
 800946e:	2300      	moveq	r3, #0
 8009470:	f002 0301 	andne.w	r3, r2, #1
 8009474:	2b00      	cmp	r3, #0
 8009476:	f000 8360 	beq.w	8009b3a <_svfiprintf_r+0x706>
 800947a:	1c7a      	adds	r2, r7, #1
 800947c:	4614      	mov	r4, r2
 800947e:	3201      	adds	r2, #1
 8009480:	7823      	ldrb	r3, [r4, #0]
 8009482:	1e19      	subs	r1, r3, #0
 8009484:	bf18      	it	ne
 8009486:	2101      	movne	r1, #1
 8009488:	2b25      	cmp	r3, #37	; 0x25
 800948a:	bf0c      	ite	eq
 800948c:	2300      	moveq	r3, #0
 800948e:	f001 0301 	andne.w	r3, r1, #1
 8009492:	2b00      	cmp	r3, #0
 8009494:	d1f2      	bne.n	800947c <_svfiprintf_r+0x48>
 8009496:	1be5      	subs	r5, r4, r7
 8009498:	d00e      	beq.n	80094b8 <_svfiprintf_r+0x84>
 800949a:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800949c:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800949e:	3301      	adds	r3, #1
 80094a0:	6037      	str	r7, [r6, #0]
 80094a2:	2b07      	cmp	r3, #7
 80094a4:	6075      	str	r5, [r6, #4]
 80094a6:	442a      	add	r2, r5
 80094a8:	9327      	str	r3, [sp, #156]	; 0x9c
 80094aa:	9228      	str	r2, [sp, #160]	; 0xa0
 80094ac:	f300 83bc 	bgt.w	8009c28 <_svfiprintf_r+0x7f4>
 80094b0:	3608      	adds	r6, #8
 80094b2:	9905      	ldr	r1, [sp, #20]
 80094b4:	1949      	adds	r1, r1, r5
 80094b6:	9105      	str	r1, [sp, #20]
 80094b8:	7823      	ldrb	r3, [r4, #0]
 80094ba:	2b00      	cmp	r3, #0
 80094bc:	f000 833f 	beq.w	8009b3e <_svfiprintf_r+0x70a>
 80094c0:	2200      	movs	r2, #0
 80094c2:	2300      	movs	r3, #0
 80094c4:	9204      	str	r2, [sp, #16]
 80094c6:	1c67      	adds	r7, r4, #1
 80094c8:	f88d 30a7 	strb.w	r3, [sp, #167]	; 0xa7
 80094cc:	f04f 38ff 	mov.w	r8, #4294967295
 80094d0:	7863      	ldrb	r3, [r4, #1]
 80094d2:	4692      	mov	sl, r2
 80094d4:	f04f 0c20 	mov.w	ip, #32
 80094d8:	242b      	movs	r4, #43	; 0x2b
 80094da:	3701      	adds	r7, #1
 80094dc:	f1a3 0220 	sub.w	r2, r3, #32
 80094e0:	2a58      	cmp	r2, #88	; 0x58
 80094e2:	f200 824e 	bhi.w	8009982 <_svfiprintf_r+0x54e>
 80094e6:	e8df f012 	tbh	[pc, r2, lsl #1]
 80094ea:	025a      	.short	0x025a
 80094ec:	024c024c 	.word	0x024c024c
 80094f0:	024c01fb 	.word	0x024c01fb
 80094f4:	024c024c 	.word	0x024c024c
 80094f8:	024c024c 	.word	0x024c024c
 80094fc:	00fe024c 	.word	0x00fe024c
 8009500:	024c0214 	.word	0x024c0214
 8009504:	0218010a 	.word	0x0218010a
 8009508:	0210024c 	.word	0x0210024c
 800950c:	01ff01ff 	.word	0x01ff01ff
 8009510:	01ff01ff 	.word	0x01ff01ff
 8009514:	01ff01ff 	.word	0x01ff01ff
 8009518:	01ff01ff 	.word	0x01ff01ff
 800951c:	024c01ff 	.word	0x024c01ff
 8009520:	024c024c 	.word	0x024c024c
 8009524:	024c024c 	.word	0x024c024c
 8009528:	024c024c 	.word	0x024c024c
 800952c:	024c024c 	.word	0x024c024c
 8009530:	00c7024c 	.word	0x00c7024c
 8009534:	024c024c 	.word	0x024c024c
 8009538:	024c024c 	.word	0x024c024c
 800953c:	024c024c 	.word	0x024c024c
 8009540:	024c024c 	.word	0x024c024c
 8009544:	024c024c 	.word	0x024c024c
 8009548:	024c00bd 	.word	0x024c00bd
 800954c:	024c024c 	.word	0x024c024c
 8009550:	024c024c 	.word	0x024c024c
 8009554:	024c0059 	.word	0x024c0059
 8009558:	016d024c 	.word	0x016d024c
 800955c:	024c024c 	.word	0x024c024c
 8009560:	024c024c 	.word	0x024c024c
 8009564:	024c024c 	.word	0x024c024c
 8009568:	024c024c 	.word	0x024c024c
 800956c:	024c024c 	.word	0x024c024c
 8009570:	00c90192 	.word	0x00c90192
 8009574:	024c024c 	.word	0x024c024c
 8009578:	0169024c 	.word	0x0169024c
 800957c:	024c00c9 	.word	0x024c00c9
 8009580:	015f024c 	.word	0x015f024c
 8009584:	014c024c 	.word	0x014c024c
 8009588:	013400bf 	.word	0x013400bf
 800958c:	024c0130 	.word	0x024c0130
 8009590:	024c010e 	.word	0x024c010e
 8009594:	024c005b 	.word	0x024c005b
 8009598:	0235024c 	.word	0x0235024c
 800959c:	f04a 0a10 	orr.w	sl, sl, #16
 80095a0:	f01a 0f20 	tst.w	sl, #32
 80095a4:	f000 83bf 	beq.w	8009d26 <_svfiprintf_r+0x8f2>
 80095a8:	9b06      	ldr	r3, [sp, #24]
 80095aa:	1dda      	adds	r2, r3, #7
 80095ac:	2301      	movs	r3, #1
 80095ae:	f022 0207 	bic.w	r2, r2, #7
 80095b2:	f102 0508 	add.w	r5, r2, #8
 80095b6:	9506      	str	r5, [sp, #24]
 80095b8:	e9d2 4500 	ldrd	r4, r5, [r2]
 80095bc:	ea54 0005 	orrs.w	r0, r4, r5
 80095c0:	bf0c      	ite	eq
 80095c2:	2200      	moveq	r2, #0
 80095c4:	2201      	movne	r2, #1
 80095c6:	2100      	movs	r1, #0
 80095c8:	f88d 10a7 	strb.w	r1, [sp, #167]	; 0xa7
 80095cc:	f1b8 0f00 	cmp.w	r8, #0
 80095d0:	bfa8      	it	ge
 80095d2:	f02a 0a80 	bicge.w	sl, sl, #128	; 0x80
 80095d6:	f1b8 0f00 	cmp.w	r8, #0
 80095da:	bf18      	it	ne
 80095dc:	f042 0201 	orrne.w	r2, r2, #1
 80095e0:	2a00      	cmp	r2, #0
 80095e2:	d070      	beq.n	80096c6 <_svfiprintf_r+0x292>
 80095e4:	2b01      	cmp	r3, #1
 80095e6:	f000 8348 	beq.w	8009c7a <_svfiprintf_r+0x846>
 80095ea:	2b02      	cmp	r3, #2
 80095ec:	f000 836f 	beq.w	8009cce <_svfiprintf_r+0x89a>
 80095f0:	aa1c      	add	r2, sp, #112	; 0x70
 80095f2:	46b4      	mov	ip, r6
 80095f4:	f102 0327 	add.w	r3, r2, #39	; 0x27
 80095f8:	9202      	str	r2, [sp, #8]
 80095fa:	9703      	str	r7, [sp, #12]
 80095fc:	08ea      	lsrs	r2, r5, #3
 80095fe:	08e7      	lsrs	r7, r4, #3
 8009600:	ea47 7745 	orr.w	r7, r7, r5, lsl #29
 8009604:	f004 0407 	and.w	r4, r4, #7
 8009608:	4611      	mov	r1, r2
 800960a:	f104 0230 	add.w	r2, r4, #48	; 0x30
 800960e:	460d      	mov	r5, r1
 8009610:	463c      	mov	r4, r7
 8009612:	461e      	mov	r6, r3
 8009614:	701a      	strb	r2, [r3, #0]
 8009616:	3b01      	subs	r3, #1
 8009618:	ea54 0005 	orrs.w	r0, r4, r5
 800961c:	d1ee      	bne.n	80095fc <_svfiprintf_r+0x1c8>
 800961e:	f01a 0f01 	tst.w	sl, #1
 8009622:	9609      	str	r6, [sp, #36]	; 0x24
 8009624:	9f03      	ldr	r7, [sp, #12]
 8009626:	4666      	mov	r6, ip
 8009628:	f000 83ab 	beq.w	8009d82 <_svfiprintf_r+0x94e>
 800962c:	2a30      	cmp	r2, #48	; 0x30
 800962e:	f000 8365 	beq.w	8009cfc <_svfiprintf_r+0x8c8>
 8009632:	9309      	str	r3, [sp, #36]	; 0x24
 8009634:	9902      	ldr	r1, [sp, #8]
 8009636:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8009638:	f101 0328 	add.w	r3, r1, #40	; 0x28
 800963c:	1a9b      	subs	r3, r3, r2
 800963e:	9303      	str	r3, [sp, #12]
 8009640:	2330      	movs	r3, #48	; 0x30
 8009642:	7013      	strb	r3, [r2, #0]
 8009644:	f8cd 801c 	str.w	r8, [sp, #28]
 8009648:	9803      	ldr	r0, [sp, #12]
 800964a:	9907      	ldr	r1, [sp, #28]
 800964c:	f89d 30a7 	ldrb.w	r3, [sp, #167]	; 0xa7
 8009650:	4288      	cmp	r0, r1
 8009652:	bfb8      	it	lt
 8009654:	4608      	movlt	r0, r1
 8009656:	9002      	str	r0, [sp, #8]
 8009658:	2b00      	cmp	r3, #0
 800965a:	f000 80e8 	beq.w	800982e <_svfiprintf_r+0x3fa>
 800965e:	3001      	adds	r0, #1
 8009660:	9002      	str	r0, [sp, #8]
 8009662:	e0e4      	b.n	800982e <_svfiprintf_r+0x3fa>
 8009664:	f04a 0a10 	orr.w	sl, sl, #16
 8009668:	f01a 0320 	ands.w	r3, sl, #32
 800966c:	f000 8366 	beq.w	8009d3c <_svfiprintf_r+0x908>
 8009670:	9b06      	ldr	r3, [sp, #24]
 8009672:	1dda      	adds	r2, r3, #7
 8009674:	2300      	movs	r3, #0
 8009676:	e79a      	b.n	80095ae <_svfiprintf_r+0x17a>
 8009678:	f04a 0a10 	orr.w	sl, sl, #16
 800967c:	f01a 0f20 	tst.w	sl, #32
 8009680:	f000 8343 	beq.w	8009d0a <_svfiprintf_r+0x8d6>
 8009684:	9806      	ldr	r0, [sp, #24]
 8009686:	1dc3      	adds	r3, r0, #7
 8009688:	f023 0307 	bic.w	r3, r3, #7
 800968c:	f103 0108 	add.w	r1, r3, #8
 8009690:	9106      	str	r1, [sp, #24]
 8009692:	e9d3 4500 	ldrd	r4, r5, [r3]
 8009696:	2c00      	cmp	r4, #0
 8009698:	f175 0000 	sbcs.w	r0, r5, #0
 800969c:	f2c0 83ab 	blt.w	8009df6 <_svfiprintf_r+0x9c2>
 80096a0:	ea54 0105 	orrs.w	r1, r4, r5
 80096a4:	f04f 0301 	mov.w	r3, #1
 80096a8:	bf0c      	ite	eq
 80096aa:	2200      	moveq	r2, #0
 80096ac:	2201      	movne	r2, #1
 80096ae:	f1b8 0f00 	cmp.w	r8, #0
 80096b2:	bfa8      	it	ge
 80096b4:	f02a 0a80 	bicge.w	sl, sl, #128	; 0x80
 80096b8:	f1b8 0f00 	cmp.w	r8, #0
 80096bc:	bf18      	it	ne
 80096be:	f042 0201 	orrne.w	r2, r2, #1
 80096c2:	2a00      	cmp	r2, #0
 80096c4:	d18e      	bne.n	80095e4 <_svfiprintf_r+0x1b0>
 80096c6:	2b00      	cmp	r3, #0
 80096c8:	f040 82aa 	bne.w	8009c20 <_svfiprintf_r+0x7ec>
 80096cc:	f01a 0f01 	tst.w	sl, #1
 80096d0:	f000 82f9 	beq.w	8009cc6 <_svfiprintf_r+0x892>
 80096d4:	2101      	movs	r1, #1
 80096d6:	2330      	movs	r3, #48	; 0x30
 80096d8:	f10d 0297 	add.w	r2, sp, #151	; 0x97
 80096dc:	9103      	str	r1, [sp, #12]
 80096de:	f88d 3097 	strb.w	r3, [sp, #151]	; 0x97
 80096e2:	9209      	str	r2, [sp, #36]	; 0x24
 80096e4:	e7ae      	b.n	8009644 <_svfiprintf_r+0x210>
 80096e6:	9806      	ldr	r0, [sp, #24]
 80096e8:	9906      	ldr	r1, [sp, #24]
 80096ea:	6800      	ldr	r0, [r0, #0]
 80096ec:	1d0a      	adds	r2, r1, #4
 80096ee:	2800      	cmp	r0, #0
 80096f0:	9004      	str	r0, [sp, #16]
 80096f2:	f280 8338 	bge.w	8009d66 <_svfiprintf_r+0x932>
 80096f6:	9b04      	ldr	r3, [sp, #16]
 80096f8:	9206      	str	r2, [sp, #24]
 80096fa:	425b      	negs	r3, r3
 80096fc:	9304      	str	r3, [sp, #16]
 80096fe:	f04a 0a04 	orr.w	sl, sl, #4
 8009702:	783b      	ldrb	r3, [r7, #0]
 8009704:	e6e9      	b.n	80094da <_svfiprintf_r+0xa6>
 8009706:	9b06      	ldr	r3, [sp, #24]
 8009708:	2500      	movs	r5, #0
 800970a:	f88d 50a7 	strb.w	r5, [sp, #167]	; 0xa7
 800970e:	1d18      	adds	r0, r3, #4
 8009710:	9006      	str	r0, [sp, #24]
 8009712:	681b      	ldr	r3, [r3, #0]
 8009714:	9309      	str	r3, [sp, #36]	; 0x24
 8009716:	2b00      	cmp	r3, #0
 8009718:	f000 83ce 	beq.w	8009eb8 <_svfiprintf_r+0xa84>
 800971c:	f1b8 0f00 	cmp.w	r8, #0
 8009720:	f2c0 837b 	blt.w	8009e1a <_svfiprintf_r+0x9e6>
 8009724:	9809      	ldr	r0, [sp, #36]	; 0x24
 8009726:	2100      	movs	r1, #0
 8009728:	4642      	mov	r2, r8
 800972a:	f7fe ff69 	bl	8008600 <memchr>
 800972e:	2800      	cmp	r0, #0
 8009730:	f000 83d4 	beq.w	8009edc <_svfiprintf_r+0xaa8>
 8009734:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8009736:	1b40      	subs	r0, r0, r5
 8009738:	9003      	str	r0, [sp, #12]
 800973a:	4540      	cmp	r0, r8
 800973c:	f340 837f 	ble.w	8009e3e <_svfiprintf_r+0xa0a>
 8009740:	2500      	movs	r5, #0
 8009742:	f8cd 800c 	str.w	r8, [sp, #12]
 8009746:	9507      	str	r5, [sp, #28]
 8009748:	e77e      	b.n	8009648 <_svfiprintf_r+0x214>
 800974a:	f04a 0a20 	orr.w	sl, sl, #32
 800974e:	783b      	ldrb	r3, [r7, #0]
 8009750:	e6c3      	b.n	80094da <_svfiprintf_r+0xa6>
 8009752:	9b06      	ldr	r3, [sp, #24]
 8009754:	f64b 3168 	movw	r1, #47976	; 0xbb68
 8009758:	2500      	movs	r5, #0
 800975a:	f6c0 0100 	movt	r1, #2048	; 0x800
 800975e:	f04a 0a02 	orr.w	sl, sl, #2
 8009762:	681a      	ldr	r2, [r3, #0]
 8009764:	3304      	adds	r3, #4
 8009766:	9306      	str	r3, [sp, #24]
 8009768:	2330      	movs	r3, #48	; 0x30
 800976a:	4614      	mov	r4, r2
 800976c:	f88d 30a4 	strb.w	r3, [sp, #164]	; 0xa4
 8009770:	2378      	movs	r3, #120	; 0x78
 8009772:	3a00      	subs	r2, #0
 8009774:	f88d 30a5 	strb.w	r3, [sp, #165]	; 0xa5
 8009778:	bf18      	it	ne
 800977a:	2201      	movne	r2, #1
 800977c:	9108      	str	r1, [sp, #32]
 800977e:	2302      	movs	r3, #2
 8009780:	e721      	b.n	80095c6 <_svfiprintf_r+0x192>
 8009782:	f01a 0f20 	tst.w	sl, #32
 8009786:	f040 830c 	bne.w	8009da2 <_svfiprintf_r+0x96e>
 800978a:	f01a 0f10 	tst.w	sl, #16
 800978e:	f040 834b 	bne.w	8009e28 <_svfiprintf_r+0x9f4>
 8009792:	f01a 0f40 	tst.w	sl, #64	; 0x40
 8009796:	f000 8347 	beq.w	8009e28 <_svfiprintf_r+0x9f4>
 800979a:	9d06      	ldr	r5, [sp, #24]
 800979c:	9805      	ldr	r0, [sp, #20]
 800979e:	682b      	ldr	r3, [r5, #0]
 80097a0:	3504      	adds	r5, #4
 80097a2:	9506      	str	r5, [sp, #24]
 80097a4:	8018      	strh	r0, [r3, #0]
 80097a6:	e65b      	b.n	8009460 <_svfiprintf_r+0x2c>
 80097a8:	783b      	ldrb	r3, [r7, #0]
 80097aa:	2b6c      	cmp	r3, #108	; 0x6c
 80097ac:	bf0a      	itet	eq
 80097ae:	f04a 0a20 	orreq.w	sl, sl, #32
 80097b2:	f04a 0a10 	orrne.w	sl, sl, #16
 80097b6:	f817 3f01 	ldrbeq.w	r3, [r7, #1]!
 80097ba:	e68e      	b.n	80094da <_svfiprintf_r+0xa6>
 80097bc:	f04a 0a40 	orr.w	sl, sl, #64	; 0x40
 80097c0:	783b      	ldrb	r3, [r7, #0]
 80097c2:	e68a      	b.n	80094da <_svfiprintf_r+0xa6>
 80097c4:	f01a 0f20 	tst.w	sl, #32
 80097c8:	f64b 3254 	movw	r2, #47956	; 0xbb54
 80097cc:	f6c0 0200 	movt	r2, #2048	; 0x800
 80097d0:	9208      	str	r2, [sp, #32]
 80097d2:	f000 80c8 	beq.w	8009966 <_svfiprintf_r+0x532>
 80097d6:	9d06      	ldr	r5, [sp, #24]
 80097d8:	1dea      	adds	r2, r5, #7
 80097da:	f022 0207 	bic.w	r2, r2, #7
 80097de:	f102 0008 	add.w	r0, r2, #8
 80097e2:	9006      	str	r0, [sp, #24]
 80097e4:	e9d2 4500 	ldrd	r4, r5, [r2]
 80097e8:	ea54 0005 	orrs.w	r0, r4, r5
 80097ec:	bf0c      	ite	eq
 80097ee:	2200      	moveq	r2, #0
 80097f0:	2201      	movne	r2, #1
 80097f2:	ea1a 0f02 	tst.w	sl, r2
 80097f6:	f000 82b4 	beq.w	8009d62 <_svfiprintf_r+0x92e>
 80097fa:	f88d 30a5 	strb.w	r3, [sp, #165]	; 0xa5
 80097fe:	f04a 0a02 	orr.w	sl, sl, #2
 8009802:	2330      	movs	r3, #48	; 0x30
 8009804:	2201      	movs	r2, #1
 8009806:	f88d 30a4 	strb.w	r3, [sp, #164]	; 0xa4
 800980a:	2302      	movs	r3, #2
 800980c:	e6db      	b.n	80095c6 <_svfiprintf_r+0x192>
 800980e:	9b06      	ldr	r3, [sp, #24]
 8009810:	2001      	movs	r0, #1
 8009812:	aa1c      	add	r2, sp, #112	; 0x70
 8009814:	2500      	movs	r5, #0
 8009816:	1d19      	adds	r1, r3, #4
 8009818:	9002      	str	r0, [sp, #8]
 800981a:	681b      	ldr	r3, [r3, #0]
 800981c:	9106      	str	r1, [sp, #24]
 800981e:	9003      	str	r0, [sp, #12]
 8009820:	9209      	str	r2, [sp, #36]	; 0x24
 8009822:	f88d 50a7 	strb.w	r5, [sp, #167]	; 0xa7
 8009826:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
 800982a:	2100      	movs	r1, #0
 800982c:	9107      	str	r1, [sp, #28]
 800982e:	f01a 0202 	ands.w	r2, sl, #2
 8009832:	920a      	str	r2, [sp, #40]	; 0x28
 8009834:	d002      	beq.n	800983c <_svfiprintf_r+0x408>
 8009836:	9b02      	ldr	r3, [sp, #8]
 8009838:	3302      	adds	r3, #2
 800983a:	9302      	str	r3, [sp, #8]
 800983c:	f01a 0584 	ands.w	r5, sl, #132	; 0x84
 8009840:	950b      	str	r5, [sp, #44]	; 0x2c
 8009842:	f040 80b5 	bne.w	80099b0 <_svfiprintf_r+0x57c>
 8009846:	9804      	ldr	r0, [sp, #16]
 8009848:	9902      	ldr	r1, [sp, #8]
 800984a:	1a44      	subs	r4, r0, r1
 800984c:	2c00      	cmp	r4, #0
 800984e:	f340 80af 	ble.w	80099b0 <_svfiprintf_r+0x57c>
 8009852:	2c10      	cmp	r4, #16
 8009854:	f340 8321 	ble.w	8009e9a <_svfiprintf_r+0xa66>
 8009858:	f64b 1520 	movw	r5, #47392	; 0xb920
 800985c:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800985e:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009860:	f6c0 0500 	movt	r5, #2048	; 0x800
 8009864:	f04f 0810 	mov.w	r8, #16
 8009868:	e002      	b.n	8009870 <_svfiprintf_r+0x43c>
 800986a:	3c10      	subs	r4, #16
 800986c:	2c10      	cmp	r4, #16
 800986e:	dd1c      	ble.n	80098aa <_svfiprintf_r+0x476>
 8009870:	3301      	adds	r3, #1
 8009872:	6035      	str	r5, [r6, #0]
 8009874:	f8c6 8004 	str.w	r8, [r6, #4]
 8009878:	3210      	adds	r2, #16
 800987a:	3608      	adds	r6, #8
 800987c:	2b07      	cmp	r3, #7
 800987e:	9327      	str	r3, [sp, #156]	; 0x9c
 8009880:	f106 0c08 	add.w	ip, r6, #8
 8009884:	9228      	str	r2, [sp, #160]	; 0xa0
 8009886:	ddf0      	ble.n	800986a <_svfiprintf_r+0x436>
 8009888:	aa26      	add	r2, sp, #152	; 0x98
 800988a:	4658      	mov	r0, fp
 800988c:	4649      	mov	r1, r9
 800988e:	ae0c      	add	r6, sp, #48	; 0x30
 8009890:	f7ff fd4c 	bl	800932c <__ssprint_r>
 8009894:	aa0c      	add	r2, sp, #48	; 0x30
 8009896:	f102 0c08 	add.w	ip, r2, #8
 800989a:	2800      	cmp	r0, #0
 800989c:	f040 8156 	bne.w	8009b4c <_svfiprintf_r+0x718>
 80098a0:	3c10      	subs	r4, #16
 80098a2:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 80098a4:	2c10      	cmp	r4, #16
 80098a6:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 80098a8:	dce2      	bgt.n	8009870 <_svfiprintf_r+0x43c>
 80098aa:	3301      	adds	r3, #1
 80098ac:	6035      	str	r5, [r6, #0]
 80098ae:	2b07      	cmp	r3, #7
 80098b0:	6074      	str	r4, [r6, #4]
 80098b2:	4422      	add	r2, r4
 80098b4:	9327      	str	r3, [sp, #156]	; 0x9c
 80098b6:	9228      	str	r2, [sp, #160]	; 0xa0
 80098b8:	bfdc      	itt	le
 80098ba:	f10c 0108 	addle.w	r1, ip, #8
 80098be:	4666      	movle	r6, ip
 80098c0:	dd7a      	ble.n	80099b8 <_svfiprintf_r+0x584>
 80098c2:	4658      	mov	r0, fp
 80098c4:	4649      	mov	r1, r9
 80098c6:	aa26      	add	r2, sp, #152	; 0x98
 80098c8:	f7ff fd30 	bl	800932c <__ssprint_r>
 80098cc:	2800      	cmp	r0, #0
 80098ce:	f040 813d 	bne.w	8009b4c <_svfiprintf_r+0x718>
 80098d2:	ab0c      	add	r3, sp, #48	; 0x30
 80098d4:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 80098d6:	f103 0108 	add.w	r1, r3, #8
 80098da:	ae0c      	add	r6, sp, #48	; 0x30
 80098dc:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 80098de:	e06b      	b.n	80099b8 <_svfiprintf_r+0x584>
 80098e0:	f04a 0a01 	orr.w	sl, sl, #1
 80098e4:	783b      	ldrb	r3, [r7, #0]
 80098e6:	e5f8      	b.n	80094da <_svfiprintf_r+0xa6>
 80098e8:	4639      	mov	r1, r7
 80098ea:	2200      	movs	r2, #0
 80098ec:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
 80098f0:	f811 3b01 	ldrb.w	r3, [r1], #1
 80098f4:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80098f8:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 80098fc:	460f      	mov	r7, r1
 80098fe:	2809      	cmp	r0, #9
 8009900:	eb05 0242 	add.w	r2, r5, r2, lsl #1
 8009904:	d9f2      	bls.n	80098ec <_svfiprintf_r+0x4b8>
 8009906:	9204      	str	r2, [sp, #16]
 8009908:	e5e8      	b.n	80094dc <_svfiprintf_r+0xa8>
 800990a:	f04a 0a80 	orr.w	sl, sl, #128	; 0x80
 800990e:	783b      	ldrb	r3, [r7, #0]
 8009910:	e5e3      	b.n	80094da <_svfiprintf_r+0xa6>
 8009912:	f88d 40a7 	strb.w	r4, [sp, #167]	; 0xa7
 8009916:	783b      	ldrb	r3, [r7, #0]
 8009918:	e5df      	b.n	80094da <_svfiprintf_r+0xa6>
 800991a:	f817 3b01 	ldrb.w	r3, [r7], #1
 800991e:	2b2a      	cmp	r3, #42	; 0x2a
 8009920:	f000 82e1 	beq.w	8009ee6 <_svfiprintf_r+0xab2>
 8009924:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8009928:	2a09      	cmp	r2, #9
 800992a:	bf88      	it	hi
 800992c:	f04f 0800 	movhi.w	r8, #0
 8009930:	d80d      	bhi.n	800994e <_svfiprintf_r+0x51a>
 8009932:	4639      	mov	r1, r7
 8009934:	f04f 0800 	mov.w	r8, #0
 8009938:	f811 3b01 	ldrb.w	r3, [r1], #1
 800993c:	eb08 0888 	add.w	r8, r8, r8, lsl #2
 8009940:	eb02 0848 	add.w	r8, r2, r8, lsl #1
 8009944:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8009948:	2a09      	cmp	r2, #9
 800994a:	460f      	mov	r7, r1
 800994c:	d9f4      	bls.n	8009938 <_svfiprintf_r+0x504>
 800994e:	ea48 78e8 	orr.w	r8, r8, r8, asr #31
 8009952:	e5c3      	b.n	80094dc <_svfiprintf_r+0xa8>
 8009954:	f01a 0f20 	tst.w	sl, #32
 8009958:	f64b 3168 	movw	r1, #47976	; 0xbb68
 800995c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8009960:	9108      	str	r1, [sp, #32]
 8009962:	f47f af38 	bne.w	80097d6 <_svfiprintf_r+0x3a2>
 8009966:	f01a 0f10 	tst.w	sl, #16
 800996a:	f040 8226 	bne.w	8009dba <_svfiprintf_r+0x986>
 800996e:	f01a 0f40 	tst.w	sl, #64	; 0x40
 8009972:	f000 8278 	beq.w	8009e66 <_svfiprintf_r+0xa32>
 8009976:	9a06      	ldr	r2, [sp, #24]
 8009978:	2500      	movs	r5, #0
 800997a:	8814      	ldrh	r4, [r2, #0]
 800997c:	3204      	adds	r2, #4
 800997e:	9206      	str	r2, [sp, #24]
 8009980:	e732      	b.n	80097e8 <_svfiprintf_r+0x3b4>
 8009982:	2b00      	cmp	r3, #0
 8009984:	f000 80db 	beq.w	8009b3e <_svfiprintf_r+0x70a>
 8009988:	2001      	movs	r0, #1
 800998a:	2100      	movs	r1, #0
 800998c:	aa1c      	add	r2, sp, #112	; 0x70
 800998e:	9002      	str	r0, [sp, #8]
 8009990:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
 8009994:	f88d 10a7 	strb.w	r1, [sp, #167]	; 0xa7
 8009998:	9003      	str	r0, [sp, #12]
 800999a:	9209      	str	r2, [sp, #36]	; 0x24
 800999c:	e745      	b.n	800982a <_svfiprintf_r+0x3f6>
 800999e:	f89d 30a7 	ldrb.w	r3, [sp, #167]	; 0xa7
 80099a2:	2b00      	cmp	r3, #0
 80099a4:	f040 821a 	bne.w	8009ddc <_svfiprintf_r+0x9a8>
 80099a8:	f88d c0a7 	strb.w	ip, [sp, #167]	; 0xa7
 80099ac:	783b      	ldrb	r3, [r7, #0]
 80099ae:	e594      	b.n	80094da <_svfiprintf_r+0xa6>
 80099b0:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 80099b2:	f106 0108 	add.w	r1, r6, #8
 80099b6:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 80099b8:	f89d 00a7 	ldrb.w	r0, [sp, #167]	; 0xa7
 80099bc:	b168      	cbz	r0, 80099da <_svfiprintf_r+0x5a6>
 80099be:	3301      	adds	r3, #1
 80099c0:	f10d 00a7 	add.w	r0, sp, #167	; 0xa7
 80099c4:	6030      	str	r0, [r6, #0]
 80099c6:	2001      	movs	r0, #1
 80099c8:	2b07      	cmp	r3, #7
 80099ca:	6070      	str	r0, [r6, #4]
 80099cc:	4402      	add	r2, r0
 80099ce:	9327      	str	r3, [sp, #156]	; 0x9c
 80099d0:	9228      	str	r2, [sp, #160]	; 0xa0
 80099d2:	f300 8132 	bgt.w	8009c3a <_svfiprintf_r+0x806>
 80099d6:	460e      	mov	r6, r1
 80099d8:	3108      	adds	r1, #8
 80099da:	980a      	ldr	r0, [sp, #40]	; 0x28
 80099dc:	b160      	cbz	r0, 80099f8 <_svfiprintf_r+0x5c4>
 80099de:	3301      	adds	r3, #1
 80099e0:	a829      	add	r0, sp, #164	; 0xa4
 80099e2:	6030      	str	r0, [r6, #0]
 80099e4:	2002      	movs	r0, #2
 80099e6:	2b07      	cmp	r3, #7
 80099e8:	6070      	str	r0, [r6, #4]
 80099ea:	4402      	add	r2, r0
 80099ec:	9327      	str	r3, [sp, #156]	; 0x9c
 80099ee:	9228      	str	r2, [sp, #160]	; 0xa0
 80099f0:	f300 8134 	bgt.w	8009c5c <_svfiprintf_r+0x828>
 80099f4:	460e      	mov	r6, r1
 80099f6:	3108      	adds	r1, #8
 80099f8:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80099fa:	2d80      	cmp	r5, #128	; 0x80
 80099fc:	f000 80b3 	beq.w	8009b66 <_svfiprintf_r+0x732>
 8009a00:	9807      	ldr	r0, [sp, #28]
 8009a02:	9d03      	ldr	r5, [sp, #12]
 8009a04:	1b44      	subs	r4, r0, r5
 8009a06:	2c00      	cmp	r4, #0
 8009a08:	dd3e      	ble.n	8009a88 <_svfiprintf_r+0x654>
 8009a0a:	2c10      	cmp	r4, #16
 8009a0c:	f340 8214 	ble.w	8009e38 <_svfiprintf_r+0xa04>
 8009a10:	4d91      	ldr	r5, [pc, #580]	; (8009c58 <_svfiprintf_r+0x824>)
 8009a12:	f04f 0810 	mov.w	r8, #16
 8009a16:	e002      	b.n	8009a1e <_svfiprintf_r+0x5ea>
 8009a18:	3c10      	subs	r4, #16
 8009a1a:	2c10      	cmp	r4, #16
 8009a1c:	dd1b      	ble.n	8009a56 <_svfiprintf_r+0x622>
 8009a1e:	3301      	adds	r3, #1
 8009a20:	6035      	str	r5, [r6, #0]
 8009a22:	f8c6 8004 	str.w	r8, [r6, #4]
 8009a26:	3210      	adds	r2, #16
 8009a28:	3608      	adds	r6, #8
 8009a2a:	2b07      	cmp	r3, #7
 8009a2c:	9327      	str	r3, [sp, #156]	; 0x9c
 8009a2e:	f106 0c08 	add.w	ip, r6, #8
 8009a32:	9228      	str	r2, [sp, #160]	; 0xa0
 8009a34:	ddf0      	ble.n	8009a18 <_svfiprintf_r+0x5e4>
 8009a36:	4649      	mov	r1, r9
 8009a38:	4658      	mov	r0, fp
 8009a3a:	aa26      	add	r2, sp, #152	; 0x98
 8009a3c:	ae0c      	add	r6, sp, #48	; 0x30
 8009a3e:	f7ff fc75 	bl	800932c <__ssprint_r>
 8009a42:	a90c      	add	r1, sp, #48	; 0x30
 8009a44:	f101 0c08 	add.w	ip, r1, #8
 8009a48:	2800      	cmp	r0, #0
 8009a4a:	d17f      	bne.n	8009b4c <_svfiprintf_r+0x718>
 8009a4c:	3c10      	subs	r4, #16
 8009a4e:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009a50:	2c10      	cmp	r4, #16
 8009a52:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009a54:	dce3      	bgt.n	8009a1e <_svfiprintf_r+0x5ea>
 8009a56:	3301      	adds	r3, #1
 8009a58:	6035      	str	r5, [r6, #0]
 8009a5a:	2b07      	cmp	r3, #7
 8009a5c:	6074      	str	r4, [r6, #4]
 8009a5e:	4422      	add	r2, r4
 8009a60:	9327      	str	r3, [sp, #156]	; 0x9c
 8009a62:	9228      	str	r2, [sp, #160]	; 0xa0
 8009a64:	bfdc      	itt	le
 8009a66:	f10c 0108 	addle.w	r1, ip, #8
 8009a6a:	4666      	movle	r6, ip
 8009a6c:	dd0c      	ble.n	8009a88 <_svfiprintf_r+0x654>
 8009a6e:	4658      	mov	r0, fp
 8009a70:	4649      	mov	r1, r9
 8009a72:	aa26      	add	r2, sp, #152	; 0x98
 8009a74:	f7ff fc5a 	bl	800932c <__ssprint_r>
 8009a78:	2800      	cmp	r0, #0
 8009a7a:	d167      	bne.n	8009b4c <_svfiprintf_r+0x718>
 8009a7c:	ab0c      	add	r3, sp, #48	; 0x30
 8009a7e:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009a80:	f103 0108 	add.w	r1, r3, #8
 8009a84:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009a86:	ae0c      	add	r6, sp, #48	; 0x30
 8009a88:	3301      	adds	r3, #1
 8009a8a:	9803      	ldr	r0, [sp, #12]
 8009a8c:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8009a8e:	2b07      	cmp	r3, #7
 8009a90:	4402      	add	r2, r0
 8009a92:	6070      	str	r0, [r6, #4]
 8009a94:	6035      	str	r5, [r6, #0]
 8009a96:	9327      	str	r3, [sp, #156]	; 0x9c
 8009a98:	9228      	str	r2, [sp, #160]	; 0xa0
 8009a9a:	f300 80ae 	bgt.w	8009bfa <_svfiprintf_r+0x7c6>
 8009a9e:	f01a 0f04 	tst.w	sl, #4
 8009aa2:	d030      	beq.n	8009b06 <_svfiprintf_r+0x6d2>
 8009aa4:	9b04      	ldr	r3, [sp, #16]
 8009aa6:	9d02      	ldr	r5, [sp, #8]
 8009aa8:	1b5c      	subs	r4, r3, r5
 8009aaa:	2c00      	cmp	r4, #0
 8009aac:	dd2b      	ble.n	8009b06 <_svfiprintf_r+0x6d2>
 8009aae:	2c10      	cmp	r4, #16
 8009ab0:	f340 81fc 	ble.w	8009eac <_svfiprintf_r+0xa78>
 8009ab4:	f64b 1520 	movw	r5, #47392	; 0xb920
 8009ab8:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009aba:	f6c0 0500 	movt	r5, #2048	; 0x800
 8009abe:	2610      	movs	r6, #16
 8009ac0:	e002      	b.n	8009ac8 <_svfiprintf_r+0x694>
 8009ac2:	3c10      	subs	r4, #16
 8009ac4:	2c10      	cmp	r4, #16
 8009ac6:	dd15      	ble.n	8009af4 <_svfiprintf_r+0x6c0>
 8009ac8:	3301      	adds	r3, #1
 8009aca:	600d      	str	r5, [r1, #0]
 8009acc:	604e      	str	r6, [r1, #4]
 8009ace:	3210      	adds	r2, #16
 8009ad0:	3108      	adds	r1, #8
 8009ad2:	2b07      	cmp	r3, #7
 8009ad4:	9327      	str	r3, [sp, #156]	; 0x9c
 8009ad6:	9228      	str	r2, [sp, #160]	; 0xa0
 8009ad8:	ddf3      	ble.n	8009ac2 <_svfiprintf_r+0x68e>
 8009ada:	4649      	mov	r1, r9
 8009adc:	4658      	mov	r0, fp
 8009ade:	aa26      	add	r2, sp, #152	; 0x98
 8009ae0:	f7ff fc24 	bl	800932c <__ssprint_r>
 8009ae4:	a90c      	add	r1, sp, #48	; 0x30
 8009ae6:	2800      	cmp	r0, #0
 8009ae8:	d130      	bne.n	8009b4c <_svfiprintf_r+0x718>
 8009aea:	3c10      	subs	r4, #16
 8009aec:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009aee:	2c10      	cmp	r4, #16
 8009af0:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009af2:	dce9      	bgt.n	8009ac8 <_svfiprintf_r+0x694>
 8009af4:	3301      	adds	r3, #1
 8009af6:	600d      	str	r5, [r1, #0]
 8009af8:	2b07      	cmp	r3, #7
 8009afa:	604c      	str	r4, [r1, #4]
 8009afc:	4422      	add	r2, r4
 8009afe:	9327      	str	r3, [sp, #156]	; 0x9c
 8009b00:	9228      	str	r2, [sp, #160]	; 0xa0
 8009b02:	f300 8134 	bgt.w	8009d6e <_svfiprintf_r+0x93a>
 8009b06:	9805      	ldr	r0, [sp, #20]
 8009b08:	9b02      	ldr	r3, [sp, #8]
 8009b0a:	9904      	ldr	r1, [sp, #16]
 8009b0c:	428b      	cmp	r3, r1
 8009b0e:	bfac      	ite	ge
 8009b10:	18c0      	addge	r0, r0, r3
 8009b12:	1840      	addlt	r0, r0, r1
 8009b14:	9005      	str	r0, [sp, #20]
 8009b16:	2a00      	cmp	r2, #0
 8009b18:	d179      	bne.n	8009c0e <_svfiprintf_r+0x7da>
 8009b1a:	2500      	movs	r5, #0
 8009b1c:	9527      	str	r5, [sp, #156]	; 0x9c
 8009b1e:	783b      	ldrb	r3, [r7, #0]
 8009b20:	ae0c      	add	r6, sp, #48	; 0x30
 8009b22:	f1b3 0225 	subs.w	r2, r3, #37	; 0x25
 8009b26:	bf18      	it	ne
 8009b28:	2201      	movne	r2, #1
 8009b2a:	2b00      	cmp	r3, #0
 8009b2c:	bf0c      	ite	eq
 8009b2e:	2300      	moveq	r3, #0
 8009b30:	f002 0301 	andne.w	r3, r2, #1
 8009b34:	2b00      	cmp	r3, #0
 8009b36:	f47f aca0 	bne.w	800947a <_svfiprintf_r+0x46>
 8009b3a:	463c      	mov	r4, r7
 8009b3c:	e4bc      	b.n	80094b8 <_svfiprintf_r+0x84>
 8009b3e:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 8009b40:	b123      	cbz	r3, 8009b4c <_svfiprintf_r+0x718>
 8009b42:	4658      	mov	r0, fp
 8009b44:	4649      	mov	r1, r9
 8009b46:	aa26      	add	r2, sp, #152	; 0x98
 8009b48:	f7ff fbf0 	bl	800932c <__ssprint_r>
 8009b4c:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8009b50:	9805      	ldr	r0, [sp, #20]
 8009b52:	f013 0f40 	tst.w	r3, #64	; 0x40
 8009b56:	bf18      	it	ne
 8009b58:	f04f 30ff 	movne.w	r0, #4294967295
 8009b5c:	9005      	str	r0, [sp, #20]
 8009b5e:	9805      	ldr	r0, [sp, #20]
 8009b60:	b02b      	add	sp, #172	; 0xac
 8009b62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009b66:	9804      	ldr	r0, [sp, #16]
 8009b68:	9d02      	ldr	r5, [sp, #8]
 8009b6a:	1b44      	subs	r4, r0, r5
 8009b6c:	2c00      	cmp	r4, #0
 8009b6e:	bfd8      	it	le
 8009b70:	f106 0108 	addle.w	r1, r6, #8
 8009b74:	f77f af44 	ble.w	8009a00 <_svfiprintf_r+0x5cc>
 8009b78:	2c10      	cmp	r4, #16
 8009b7a:	f340 81ac 	ble.w	8009ed6 <_svfiprintf_r+0xaa2>
 8009b7e:	4d36      	ldr	r5, [pc, #216]	; (8009c58 <_svfiprintf_r+0x824>)
 8009b80:	f04f 0810 	mov.w	r8, #16
 8009b84:	e002      	b.n	8009b8c <_svfiprintf_r+0x758>
 8009b86:	3c10      	subs	r4, #16
 8009b88:	2c10      	cmp	r4, #16
 8009b8a:	dd1b      	ble.n	8009bc4 <_svfiprintf_r+0x790>
 8009b8c:	3301      	adds	r3, #1
 8009b8e:	6035      	str	r5, [r6, #0]
 8009b90:	f8c6 8004 	str.w	r8, [r6, #4]
 8009b94:	3210      	adds	r2, #16
 8009b96:	3608      	adds	r6, #8
 8009b98:	2b07      	cmp	r3, #7
 8009b9a:	9327      	str	r3, [sp, #156]	; 0x9c
 8009b9c:	f106 0c08 	add.w	ip, r6, #8
 8009ba0:	9228      	str	r2, [sp, #160]	; 0xa0
 8009ba2:	ddf0      	ble.n	8009b86 <_svfiprintf_r+0x752>
 8009ba4:	4649      	mov	r1, r9
 8009ba6:	4658      	mov	r0, fp
 8009ba8:	aa26      	add	r2, sp, #152	; 0x98
 8009baa:	ae0c      	add	r6, sp, #48	; 0x30
 8009bac:	f7ff fbbe 	bl	800932c <__ssprint_r>
 8009bb0:	a90c      	add	r1, sp, #48	; 0x30
 8009bb2:	f101 0c08 	add.w	ip, r1, #8
 8009bb6:	2800      	cmp	r0, #0
 8009bb8:	d1c8      	bne.n	8009b4c <_svfiprintf_r+0x718>
 8009bba:	3c10      	subs	r4, #16
 8009bbc:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009bbe:	2c10      	cmp	r4, #16
 8009bc0:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009bc2:	dce3      	bgt.n	8009b8c <_svfiprintf_r+0x758>
 8009bc4:	3301      	adds	r3, #1
 8009bc6:	6035      	str	r5, [r6, #0]
 8009bc8:	2b07      	cmp	r3, #7
 8009bca:	6074      	str	r4, [r6, #4]
 8009bcc:	4422      	add	r2, r4
 8009bce:	9327      	str	r3, [sp, #156]	; 0x9c
 8009bd0:	9228      	str	r2, [sp, #160]	; 0xa0
 8009bd2:	bfdc      	itt	le
 8009bd4:	f10c 0108 	addle.w	r1, ip, #8
 8009bd8:	4666      	movle	r6, ip
 8009bda:	f77f af11 	ble.w	8009a00 <_svfiprintf_r+0x5cc>
 8009bde:	4658      	mov	r0, fp
 8009be0:	4649      	mov	r1, r9
 8009be2:	aa26      	add	r2, sp, #152	; 0x98
 8009be4:	f7ff fba2 	bl	800932c <__ssprint_r>
 8009be8:	2800      	cmp	r0, #0
 8009bea:	d1af      	bne.n	8009b4c <_svfiprintf_r+0x718>
 8009bec:	ab0c      	add	r3, sp, #48	; 0x30
 8009bee:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009bf0:	f103 0108 	add.w	r1, r3, #8
 8009bf4:	ae0c      	add	r6, sp, #48	; 0x30
 8009bf6:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009bf8:	e702      	b.n	8009a00 <_svfiprintf_r+0x5cc>
 8009bfa:	4658      	mov	r0, fp
 8009bfc:	4649      	mov	r1, r9
 8009bfe:	aa26      	add	r2, sp, #152	; 0x98
 8009c00:	f7ff fb94 	bl	800932c <__ssprint_r>
 8009c04:	2800      	cmp	r0, #0
 8009c06:	d1a1      	bne.n	8009b4c <_svfiprintf_r+0x718>
 8009c08:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009c0a:	a90c      	add	r1, sp, #48	; 0x30
 8009c0c:	e747      	b.n	8009a9e <_svfiprintf_r+0x66a>
 8009c0e:	4658      	mov	r0, fp
 8009c10:	4649      	mov	r1, r9
 8009c12:	aa26      	add	r2, sp, #152	; 0x98
 8009c14:	f7ff fb8a 	bl	800932c <__ssprint_r>
 8009c18:	2800      	cmp	r0, #0
 8009c1a:	f43f af7e 	beq.w	8009b1a <_svfiprintf_r+0x6e6>
 8009c1e:	e795      	b.n	8009b4c <_svfiprintf_r+0x718>
 8009c20:	ab26      	add	r3, sp, #152	; 0x98
 8009c22:	9203      	str	r2, [sp, #12]
 8009c24:	9309      	str	r3, [sp, #36]	; 0x24
 8009c26:	e50d      	b.n	8009644 <_svfiprintf_r+0x210>
 8009c28:	4658      	mov	r0, fp
 8009c2a:	4649      	mov	r1, r9
 8009c2c:	aa26      	add	r2, sp, #152	; 0x98
 8009c2e:	f7ff fb7d 	bl	800932c <__ssprint_r>
 8009c32:	2800      	cmp	r0, #0
 8009c34:	d18a      	bne.n	8009b4c <_svfiprintf_r+0x718>
 8009c36:	ae0c      	add	r6, sp, #48	; 0x30
 8009c38:	e43b      	b.n	80094b2 <_svfiprintf_r+0x7e>
 8009c3a:	4658      	mov	r0, fp
 8009c3c:	4649      	mov	r1, r9
 8009c3e:	aa26      	add	r2, sp, #152	; 0x98
 8009c40:	f7ff fb74 	bl	800932c <__ssprint_r>
 8009c44:	2800      	cmp	r0, #0
 8009c46:	d181      	bne.n	8009b4c <_svfiprintf_r+0x718>
 8009c48:	ad0c      	add	r5, sp, #48	; 0x30
 8009c4a:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009c4c:	f105 0108 	add.w	r1, r5, #8
 8009c50:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009c52:	462e      	mov	r6, r5
 8009c54:	e6c1      	b.n	80099da <_svfiprintf_r+0x5a6>
 8009c56:	bf00      	nop
 8009c58:	0800b930 	.word	0x0800b930
 8009c5c:	4658      	mov	r0, fp
 8009c5e:	4649      	mov	r1, r9
 8009c60:	aa26      	add	r2, sp, #152	; 0x98
 8009c62:	f7ff fb63 	bl	800932c <__ssprint_r>
 8009c66:	2800      	cmp	r0, #0
 8009c68:	f47f af70 	bne.w	8009b4c <_svfiprintf_r+0x718>
 8009c6c:	ab0c      	add	r3, sp, #48	; 0x30
 8009c6e:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009c70:	f103 0108 	add.w	r1, r3, #8
 8009c74:	ae0c      	add	r6, sp, #48	; 0x30
 8009c76:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009c78:	e6be      	b.n	80099f8 <_svfiprintf_r+0x5c4>
 8009c7a:	2c0a      	cmp	r4, #10
 8009c7c:	f175 0300 	sbcs.w	r3, r5, #0
 8009c80:	f0c0 8086 	bcc.w	8009d90 <_svfiprintf_r+0x95c>
 8009c84:	a91c      	add	r1, sp, #112	; 0x70
 8009c86:	9703      	str	r7, [sp, #12]
 8009c88:	f101 0327 	add.w	r3, r1, #39	; 0x27
 8009c8c:	9102      	str	r1, [sp, #8]
 8009c8e:	461f      	mov	r7, r3
 8009c90:	9607      	str	r6, [sp, #28]
 8009c92:	4620      	mov	r0, r4
 8009c94:	4629      	mov	r1, r5
 8009c96:	220a      	movs	r2, #10
 8009c98:	2300      	movs	r3, #0
 8009c9a:	f001 f989 	bl	800afb0 <__aeabi_uldivmod>
 8009c9e:	463e      	mov	r6, r7
 8009ca0:	4620      	mov	r0, r4
 8009ca2:	4629      	mov	r1, r5
 8009ca4:	2300      	movs	r3, #0
 8009ca6:	3f01      	subs	r7, #1
 8009ca8:	f102 0430 	add.w	r4, r2, #48	; 0x30
 8009cac:	220a      	movs	r2, #10
 8009cae:	7034      	strb	r4, [r6, #0]
 8009cb0:	f001 f97e 	bl	800afb0 <__aeabi_uldivmod>
 8009cb4:	4604      	mov	r4, r0
 8009cb6:	460d      	mov	r5, r1
 8009cb8:	ea54 0205 	orrs.w	r2, r4, r5
 8009cbc:	d1e9      	bne.n	8009c92 <_svfiprintf_r+0x85e>
 8009cbe:	9609      	str	r6, [sp, #36]	; 0x24
 8009cc0:	9f03      	ldr	r7, [sp, #12]
 8009cc2:	9e07      	ldr	r6, [sp, #28]
 8009cc4:	e01a      	b.n	8009cfc <_svfiprintf_r+0x8c8>
 8009cc6:	ad26      	add	r5, sp, #152	; 0x98
 8009cc8:	9303      	str	r3, [sp, #12]
 8009cca:	9509      	str	r5, [sp, #36]	; 0x24
 8009ccc:	e4ba      	b.n	8009644 <_svfiprintf_r+0x210>
 8009cce:	a91c      	add	r1, sp, #112	; 0x70
 8009cd0:	f8dd c020 	ldr.w	ip, [sp, #32]
 8009cd4:	f101 0027 	add.w	r0, r1, #39	; 0x27
 8009cd8:	9102      	str	r1, [sp, #8]
 8009cda:	f004 020f 	and.w	r2, r4, #15
 8009cde:	0923      	lsrs	r3, r4, #4
 8009ce0:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 8009ce4:	0929      	lsrs	r1, r5, #4
 8009ce6:	f81c 2002 	ldrb.w	r2, [ip, r2]
 8009cea:	461c      	mov	r4, r3
 8009cec:	4603      	mov	r3, r0
 8009cee:	460d      	mov	r5, r1
 8009cf0:	3801      	subs	r0, #1
 8009cf2:	701a      	strb	r2, [r3, #0]
 8009cf4:	ea54 0205 	orrs.w	r2, r4, r5
 8009cf8:	d1ef      	bne.n	8009cda <_svfiprintf_r+0x8a6>
 8009cfa:	9309      	str	r3, [sp, #36]	; 0x24
 8009cfc:	9d02      	ldr	r5, [sp, #8]
 8009cfe:	9809      	ldr	r0, [sp, #36]	; 0x24
 8009d00:	f105 0328 	add.w	r3, r5, #40	; 0x28
 8009d04:	1a1b      	subs	r3, r3, r0
 8009d06:	9303      	str	r3, [sp, #12]
 8009d08:	e49c      	b.n	8009644 <_svfiprintf_r+0x210>
 8009d0a:	f01a 0f10 	tst.w	sl, #16
 8009d0e:	d168      	bne.n	8009de2 <_svfiprintf_r+0x9ae>
 8009d10:	f01a 0f40 	tst.w	sl, #64	; 0x40
 8009d14:	f000 8096 	beq.w	8009e44 <_svfiprintf_r+0xa10>
 8009d18:	9b06      	ldr	r3, [sp, #24]
 8009d1a:	f9b3 4000 	ldrsh.w	r4, [r3]
 8009d1e:	3304      	adds	r3, #4
 8009d20:	9306      	str	r3, [sp, #24]
 8009d22:	17e5      	asrs	r5, r4, #31
 8009d24:	e4b7      	b.n	8009696 <_svfiprintf_r+0x262>
 8009d26:	f01a 0f10 	tst.w	sl, #16
 8009d2a:	d172      	bne.n	8009e12 <_svfiprintf_r+0x9de>
 8009d2c:	f01a 0f40 	tst.w	sl, #64	; 0x40
 8009d30:	f000 809f 	beq.w	8009e72 <_svfiprintf_r+0xa3e>
 8009d34:	9b06      	ldr	r3, [sp, #24]
 8009d36:	881a      	ldrh	r2, [r3, #0]
 8009d38:	2301      	movs	r3, #1
 8009d3a:	e009      	b.n	8009d50 <_svfiprintf_r+0x91c>
 8009d3c:	f01a 0110 	ands.w	r1, sl, #16
 8009d40:	d141      	bne.n	8009dc6 <_svfiprintf_r+0x992>
 8009d42:	f01a 0340 	ands.w	r3, sl, #64	; 0x40
 8009d46:	f000 8083 	beq.w	8009e50 <_svfiprintf_r+0xa1c>
 8009d4a:	9b06      	ldr	r3, [sp, #24]
 8009d4c:	881a      	ldrh	r2, [r3, #0]
 8009d4e:	460b      	mov	r3, r1
 8009d50:	9d06      	ldr	r5, [sp, #24]
 8009d52:	4614      	mov	r4, r2
 8009d54:	3504      	adds	r5, #4
 8009d56:	9506      	str	r5, [sp, #24]
 8009d58:	2500      	movs	r5, #0
 8009d5a:	3a00      	subs	r2, #0
 8009d5c:	bf18      	it	ne
 8009d5e:	2201      	movne	r2, #1
 8009d60:	e431      	b.n	80095c6 <_svfiprintf_r+0x192>
 8009d62:	2302      	movs	r3, #2
 8009d64:	e42f      	b.n	80095c6 <_svfiprintf_r+0x192>
 8009d66:	783b      	ldrb	r3, [r7, #0]
 8009d68:	9206      	str	r2, [sp, #24]
 8009d6a:	f7ff bbb6 	b.w	80094da <_svfiprintf_r+0xa6>
 8009d6e:	4658      	mov	r0, fp
 8009d70:	4649      	mov	r1, r9
 8009d72:	aa26      	add	r2, sp, #152	; 0x98
 8009d74:	f7ff fada 	bl	800932c <__ssprint_r>
 8009d78:	2800      	cmp	r0, #0
 8009d7a:	f47f aee7 	bne.w	8009b4c <_svfiprintf_r+0x718>
 8009d7e:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009d80:	e6c1      	b.n	8009b06 <_svfiprintf_r+0x6d2>
 8009d82:	9902      	ldr	r1, [sp, #8]
 8009d84:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8009d86:	f101 0328 	add.w	r3, r1, #40	; 0x28
 8009d8a:	1a9b      	subs	r3, r3, r2
 8009d8c:	9303      	str	r3, [sp, #12]
 8009d8e:	e459      	b.n	8009644 <_svfiprintf_r+0x210>
 8009d90:	3430      	adds	r4, #48	; 0x30
 8009d92:	2501      	movs	r5, #1
 8009d94:	f10d 0097 	add.w	r0, sp, #151	; 0x97
 8009d98:	9503      	str	r5, [sp, #12]
 8009d9a:	f88d 4097 	strb.w	r4, [sp, #151]	; 0x97
 8009d9e:	9009      	str	r0, [sp, #36]	; 0x24
 8009da0:	e450      	b.n	8009644 <_svfiprintf_r+0x210>
 8009da2:	9b06      	ldr	r3, [sp, #24]
 8009da4:	9d05      	ldr	r5, [sp, #20]
 8009da6:	9806      	ldr	r0, [sp, #24]
 8009da8:	6819      	ldr	r1, [r3, #0]
 8009daa:	462a      	mov	r2, r5
 8009dac:	17eb      	asrs	r3, r5, #31
 8009dae:	3004      	adds	r0, #4
 8009db0:	9006      	str	r0, [sp, #24]
 8009db2:	e9c1 2300 	strd	r2, r3, [r1]
 8009db6:	f7ff bb53 	b.w	8009460 <_svfiprintf_r+0x2c>
 8009dba:	9906      	ldr	r1, [sp, #24]
 8009dbc:	2500      	movs	r5, #0
 8009dbe:	680c      	ldr	r4, [r1, #0]
 8009dc0:	3104      	adds	r1, #4
 8009dc2:	9106      	str	r1, [sp, #24]
 8009dc4:	e510      	b.n	80097e8 <_svfiprintf_r+0x3b4>
 8009dc6:	9906      	ldr	r1, [sp, #24]
 8009dc8:	680a      	ldr	r2, [r1, #0]
 8009dca:	3104      	adds	r1, #4
 8009dcc:	4614      	mov	r4, r2
 8009dce:	2500      	movs	r5, #0
 8009dd0:	3a00      	subs	r2, #0
 8009dd2:	9106      	str	r1, [sp, #24]
 8009dd4:	bf18      	it	ne
 8009dd6:	2201      	movne	r2, #1
 8009dd8:	f7ff bbf5 	b.w	80095c6 <_svfiprintf_r+0x192>
 8009ddc:	783b      	ldrb	r3, [r7, #0]
 8009dde:	f7ff bb7c 	b.w	80094da <_svfiprintf_r+0xa6>
 8009de2:	9a06      	ldr	r2, [sp, #24]
 8009de4:	6814      	ldr	r4, [r2, #0]
 8009de6:	3204      	adds	r2, #4
 8009de8:	9206      	str	r2, [sp, #24]
 8009dea:	17e5      	asrs	r5, r4, #31
 8009dec:	2c00      	cmp	r4, #0
 8009dee:	f175 0000 	sbcs.w	r0, r5, #0
 8009df2:	f6bf ac55 	bge.w	80096a0 <_svfiprintf_r+0x26c>
 8009df6:	4264      	negs	r4, r4
 8009df8:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 8009dfc:	232d      	movs	r3, #45	; 0x2d
 8009dfe:	ea54 0205 	orrs.w	r2, r4, r5
 8009e02:	f88d 30a7 	strb.w	r3, [sp, #167]	; 0xa7
 8009e06:	bf0c      	ite	eq
 8009e08:	2200      	moveq	r2, #0
 8009e0a:	2201      	movne	r2, #1
 8009e0c:	2301      	movs	r3, #1
 8009e0e:	f7ff bbdd 	b.w	80095cc <_svfiprintf_r+0x198>
 8009e12:	9906      	ldr	r1, [sp, #24]
 8009e14:	2301      	movs	r3, #1
 8009e16:	680a      	ldr	r2, [r1, #0]
 8009e18:	e7d7      	b.n	8009dca <_svfiprintf_r+0x996>
 8009e1a:	9809      	ldr	r0, [sp, #36]	; 0x24
 8009e1c:	2100      	movs	r1, #0
 8009e1e:	9107      	str	r1, [sp, #28]
 8009e20:	f7ff fa54 	bl	80092cc <strlen>
 8009e24:	9003      	str	r0, [sp, #12]
 8009e26:	e40f      	b.n	8009648 <_svfiprintf_r+0x214>
 8009e28:	9906      	ldr	r1, [sp, #24]
 8009e2a:	9a05      	ldr	r2, [sp, #20]
 8009e2c:	680b      	ldr	r3, [r1, #0]
 8009e2e:	3104      	adds	r1, #4
 8009e30:	9106      	str	r1, [sp, #24]
 8009e32:	601a      	str	r2, [r3, #0]
 8009e34:	f7ff bb14 	b.w	8009460 <_svfiprintf_r+0x2c>
 8009e38:	4d35      	ldr	r5, [pc, #212]	; (8009f10 <_svfiprintf_r+0xadc>)
 8009e3a:	468c      	mov	ip, r1
 8009e3c:	e60b      	b.n	8009a56 <_svfiprintf_r+0x622>
 8009e3e:	2300      	movs	r3, #0
 8009e40:	9307      	str	r3, [sp, #28]
 8009e42:	e401      	b.n	8009648 <_svfiprintf_r+0x214>
 8009e44:	9d06      	ldr	r5, [sp, #24]
 8009e46:	682c      	ldr	r4, [r5, #0]
 8009e48:	3504      	adds	r5, #4
 8009e4a:	9506      	str	r5, [sp, #24]
 8009e4c:	17e5      	asrs	r5, r4, #31
 8009e4e:	e422      	b.n	8009696 <_svfiprintf_r+0x262>
 8009e50:	9806      	ldr	r0, [sp, #24]
 8009e52:	6802      	ldr	r2, [r0, #0]
 8009e54:	3004      	adds	r0, #4
 8009e56:	4614      	mov	r4, r2
 8009e58:	2500      	movs	r5, #0
 8009e5a:	3a00      	subs	r2, #0
 8009e5c:	9006      	str	r0, [sp, #24]
 8009e5e:	bf18      	it	ne
 8009e60:	2201      	movne	r2, #1
 8009e62:	f7ff bbb0 	b.w	80095c6 <_svfiprintf_r+0x192>
 8009e66:	9d06      	ldr	r5, [sp, #24]
 8009e68:	682c      	ldr	r4, [r5, #0]
 8009e6a:	3504      	adds	r5, #4
 8009e6c:	9506      	str	r5, [sp, #24]
 8009e6e:	2500      	movs	r5, #0
 8009e70:	e4ba      	b.n	80097e8 <_svfiprintf_r+0x3b4>
 8009e72:	9806      	ldr	r0, [sp, #24]
 8009e74:	2301      	movs	r3, #1
 8009e76:	6802      	ldr	r2, [r0, #0]
 8009e78:	e7ec      	b.n	8009e54 <_svfiprintf_r+0xa20>
 8009e7a:	2140      	movs	r1, #64	; 0x40
 8009e7c:	9201      	str	r2, [sp, #4]
 8009e7e:	f7fa ff0f 	bl	8004ca0 <_malloc_r>
 8009e82:	9a01      	ldr	r2, [sp, #4]
 8009e84:	f8c9 0000 	str.w	r0, [r9]
 8009e88:	f8c9 0010 	str.w	r0, [r9, #16]
 8009e8c:	2800      	cmp	r0, #0
 8009e8e:	d038      	beq.n	8009f02 <_svfiprintf_r+0xace>
 8009e90:	2340      	movs	r3, #64	; 0x40
 8009e92:	f8c9 3014 	str.w	r3, [r9, #20]
 8009e96:	f7ff badb 	b.w	8009450 <_svfiprintf_r+0x1c>
 8009e9a:	f64b 1520 	movw	r5, #47392	; 0xb920
 8009e9e:	f106 0c08 	add.w	ip, r6, #8
 8009ea2:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009ea4:	f6c0 0500 	movt	r5, #2048	; 0x800
 8009ea8:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009eaa:	e4fe      	b.n	80098aa <_svfiprintf_r+0x476>
 8009eac:	f64b 1520 	movw	r5, #47392	; 0xb920
 8009eb0:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009eb2:	f6c0 0500 	movt	r5, #2048	; 0x800
 8009eb6:	e61d      	b.n	8009af4 <_svfiprintf_r+0x6c0>
 8009eb8:	f1b8 0f06 	cmp.w	r8, #6
 8009ebc:	bf34      	ite	cc
 8009ebe:	4641      	movcc	r1, r8
 8009ec0:	2106      	movcs	r1, #6
 8009ec2:	f64b 327c 	movw	r2, #47996	; 0xbb7c
 8009ec6:	ea21 73e1 	bic.w	r3, r1, r1, asr #31
 8009eca:	f6c0 0200 	movt	r2, #2048	; 0x800
 8009ece:	9103      	str	r1, [sp, #12]
 8009ed0:	9302      	str	r3, [sp, #8]
 8009ed2:	9209      	str	r2, [sp, #36]	; 0x24
 8009ed4:	e4a9      	b.n	800982a <_svfiprintf_r+0x3f6>
 8009ed6:	4d0e      	ldr	r5, [pc, #56]	; (8009f10 <_svfiprintf_r+0xadc>)
 8009ed8:	468c      	mov	ip, r1
 8009eda:	e673      	b.n	8009bc4 <_svfiprintf_r+0x790>
 8009edc:	f8cd 800c 	str.w	r8, [sp, #12]
 8009ee0:	9007      	str	r0, [sp, #28]
 8009ee2:	f7ff bbb1 	b.w	8009648 <_svfiprintf_r+0x214>
 8009ee6:	9d06      	ldr	r5, [sp, #24]
 8009ee8:	1d2a      	adds	r2, r5, #4
 8009eea:	f8d5 8000 	ldr.w	r8, [r5]
 8009eee:	f1b8 0f00 	cmp.w	r8, #0
 8009ef2:	f6bf af38 	bge.w	8009d66 <_svfiprintf_r+0x932>
 8009ef6:	783b      	ldrb	r3, [r7, #0]
 8009ef8:	f04f 38ff 	mov.w	r8, #4294967295
 8009efc:	9206      	str	r2, [sp, #24]
 8009efe:	f7ff baec 	b.w	80094da <_svfiprintf_r+0xa6>
 8009f02:	3801      	subs	r0, #1
 8009f04:	230c      	movs	r3, #12
 8009f06:	9005      	str	r0, [sp, #20]
 8009f08:	f8cb 3000 	str.w	r3, [fp]
 8009f0c:	e627      	b.n	8009b5e <_svfiprintf_r+0x72a>
 8009f0e:	bf00      	nop
 8009f10:	0800b930 	.word	0x0800b930

08009f14 <_calloc_r>:
 8009f14:	b538      	push	{r3, r4, r5, lr}
 8009f16:	fb01 f102 	mul.w	r1, r1, r2
 8009f1a:	f7fa fec1 	bl	8004ca0 <_malloc_r>
 8009f1e:	4604      	mov	r4, r0
 8009f20:	b1f8      	cbz	r0, 8009f62 <_calloc_r+0x4e>
 8009f22:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8009f26:	f022 0203 	bic.w	r2, r2, #3
 8009f2a:	3a04      	subs	r2, #4
 8009f2c:	2a24      	cmp	r2, #36	; 0x24
 8009f2e:	d81a      	bhi.n	8009f66 <_calloc_r+0x52>
 8009f30:	2a13      	cmp	r2, #19
 8009f32:	4603      	mov	r3, r0
 8009f34:	d90f      	bls.n	8009f56 <_calloc_r+0x42>
 8009f36:	2100      	movs	r1, #0
 8009f38:	f840 1b04 	str.w	r1, [r0], #4
 8009f3c:	1d03      	adds	r3, r0, #4
 8009f3e:	2a1b      	cmp	r2, #27
 8009f40:	6061      	str	r1, [r4, #4]
 8009f42:	d908      	bls.n	8009f56 <_calloc_r+0x42>
 8009f44:	1d1d      	adds	r5, r3, #4
 8009f46:	6041      	str	r1, [r0, #4]
 8009f48:	6059      	str	r1, [r3, #4]
 8009f4a:	3308      	adds	r3, #8
 8009f4c:	2a24      	cmp	r2, #36	; 0x24
 8009f4e:	bf02      	ittt	eq
 8009f50:	6069      	streq	r1, [r5, #4]
 8009f52:	6059      	streq	r1, [r3, #4]
 8009f54:	3308      	addeq	r3, #8
 8009f56:	461a      	mov	r2, r3
 8009f58:	2100      	movs	r1, #0
 8009f5a:	f842 1b04 	str.w	r1, [r2], #4
 8009f5e:	6059      	str	r1, [r3, #4]
 8009f60:	6051      	str	r1, [r2, #4]
 8009f62:	4620      	mov	r0, r4
 8009f64:	bd38      	pop	{r3, r4, r5, pc}
 8009f66:	2100      	movs	r1, #0
 8009f68:	f7fb fe9e 	bl	8005ca8 <memset>
 8009f6c:	4620      	mov	r0, r4
 8009f6e:	bd38      	pop	{r3, r4, r5, pc}

08009f70 <memmove>:
 8009f70:	4288      	cmp	r0, r1
 8009f72:	4603      	mov	r3, r0
 8009f74:	b4f0      	push	{r4, r5, r6, r7}
 8009f76:	460c      	mov	r4, r1
 8009f78:	d90e      	bls.n	8009f98 <memmove+0x28>
 8009f7a:	188d      	adds	r5, r1, r2
 8009f7c:	42a8      	cmp	r0, r5
 8009f7e:	d20b      	bcs.n	8009f98 <memmove+0x28>
 8009f80:	b142      	cbz	r2, 8009f94 <memmove+0x24>
 8009f82:	1883      	adds	r3, r0, r2
 8009f84:	4629      	mov	r1, r5
 8009f86:	1a9a      	subs	r2, r3, r2
 8009f88:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
 8009f8c:	f803 4d01 	strb.w	r4, [r3, #-1]!
 8009f90:	4293      	cmp	r3, r2
 8009f92:	d1f9      	bne.n	8009f88 <memmove+0x18>
 8009f94:	bcf0      	pop	{r4, r5, r6, r7}
 8009f96:	4770      	bx	lr
 8009f98:	2a0f      	cmp	r2, #15
 8009f9a:	d938      	bls.n	800a00e <memmove+0x9e>
 8009f9c:	ea41 0500 	orr.w	r5, r1, r0
 8009fa0:	f015 0f03 	tst.w	r5, #3
 8009fa4:	d135      	bne.n	800a012 <memmove+0xa2>
 8009fa6:	f1a2 0610 	sub.w	r6, r2, #16
 8009faa:	f101 0510 	add.w	r5, r1, #16
 8009fae:	460b      	mov	r3, r1
 8009fb0:	4602      	mov	r2, r0
 8009fb2:	0937      	lsrs	r7, r6, #4
 8009fb4:	eb05 1507 	add.w	r5, r5, r7, lsl #4
 8009fb8:	681c      	ldr	r4, [r3, #0]
 8009fba:	6014      	str	r4, [r2, #0]
 8009fbc:	685c      	ldr	r4, [r3, #4]
 8009fbe:	6054      	str	r4, [r2, #4]
 8009fc0:	689c      	ldr	r4, [r3, #8]
 8009fc2:	6094      	str	r4, [r2, #8]
 8009fc4:	68dc      	ldr	r4, [r3, #12]
 8009fc6:	3310      	adds	r3, #16
 8009fc8:	60d4      	str	r4, [r2, #12]
 8009fca:	3210      	adds	r2, #16
 8009fcc:	429d      	cmp	r5, r3
 8009fce:	d1f3      	bne.n	8009fb8 <memmove+0x48>
 8009fd0:	1c7c      	adds	r4, r7, #1
 8009fd2:	f006 020f 	and.w	r2, r6, #15
 8009fd6:	0124      	lsls	r4, r4, #4
 8009fd8:	2a03      	cmp	r2, #3
 8009fda:	eb00 0304 	add.w	r3, r0, r4
 8009fde:	4421      	add	r1, r4
 8009fe0:	d914      	bls.n	800a00c <memmove+0x9c>
 8009fe2:	3a04      	subs	r2, #4
 8009fe4:	460c      	mov	r4, r1
 8009fe6:	461d      	mov	r5, r3
 8009fe8:	ea4f 0c92 	mov.w	ip, r2, lsr #2
 8009fec:	eb01 078c 	add.w	r7, r1, ip, lsl #2
 8009ff0:	3704      	adds	r7, #4
 8009ff2:	f854 6b04 	ldr.w	r6, [r4], #4
 8009ff6:	42bc      	cmp	r4, r7
 8009ff8:	f845 6b04 	str.w	r6, [r5], #4
 8009ffc:	d1f9      	bne.n	8009ff2 <memmove+0x82>
 8009ffe:	f10c 0401 	add.w	r4, ip, #1
 800a002:	f002 0203 	and.w	r2, r2, #3
 800a006:	00a4      	lsls	r4, r4, #2
 800a008:	191b      	adds	r3, r3, r4
 800a00a:	1909      	adds	r1, r1, r4
 800a00c:	460c      	mov	r4, r1
 800a00e:	2a00      	cmp	r2, #0
 800a010:	d0c0      	beq.n	8009f94 <memmove+0x24>
 800a012:	4621      	mov	r1, r4
 800a014:	18a2      	adds	r2, r4, r2
 800a016:	f811 4b01 	ldrb.w	r4, [r1], #1
 800a01a:	4291      	cmp	r1, r2
 800a01c:	f803 4b01 	strb.w	r4, [r3], #1
 800a020:	d1f9      	bne.n	800a016 <memmove+0xa6>
 800a022:	e7b7      	b.n	8009f94 <memmove+0x24>

0800a024 <_realloc_r>:
 800a024:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a028:	460d      	mov	r5, r1
 800a02a:	b083      	sub	sp, #12
 800a02c:	4607      	mov	r7, r0
 800a02e:	4690      	mov	r8, r2
 800a030:	2900      	cmp	r1, #0
 800a032:	f000 8155 	beq.w	800a2e0 <_realloc_r+0x2bc>
 800a036:	f108 040b 	add.w	r4, r8, #11
 800a03a:	f1a1 0a08 	sub.w	sl, r1, #8
 800a03e:	f7fb f8ed 	bl	800521c <__malloc_lock>
 800a042:	2c16      	cmp	r4, #22
 800a044:	f8da 3004 	ldr.w	r3, [sl, #4]
 800a048:	f200 8097 	bhi.w	800a17a <_realloc_r+0x156>
 800a04c:	2210      	movs	r2, #16
 800a04e:	2000      	movs	r0, #0
 800a050:	4614      	mov	r4, r2
 800a052:	4544      	cmp	r4, r8
 800a054:	bf38      	it	cc
 800a056:	f040 0001 	orrcc.w	r0, r0, #1
 800a05a:	2800      	cmp	r0, #0
 800a05c:	f040 8146 	bne.w	800a2ec <_realloc_r+0x2c8>
 800a060:	f023 0b03 	bic.w	fp, r3, #3
 800a064:	4593      	cmp	fp, r2
 800a066:	bfa4      	itt	ge
 800a068:	f10a 0808 	addge.w	r8, sl, #8
 800a06c:	465e      	movge	r6, fp
 800a06e:	da6e      	bge.n	800a14e <_realloc_r+0x12a>
 800a070:	f240 3960 	movw	r9, #864	; 0x360
 800a074:	eb0a 010b 	add.w	r1, sl, fp
 800a078:	f2c2 0900 	movt	r9, #8192	; 0x2000
 800a07c:	f8d9 e008 	ldr.w	lr, [r9, #8]
 800a080:	458e      	cmp	lr, r1
 800a082:	f000 8138 	beq.w	800a2f6 <_realloc_r+0x2d2>
 800a086:	684e      	ldr	r6, [r1, #4]
 800a088:	f026 0c01 	bic.w	ip, r6, #1
 800a08c:	448c      	add	ip, r1
 800a08e:	f8dc c004 	ldr.w	ip, [ip, #4]
 800a092:	f01c 0f01 	tst.w	ip, #1
 800a096:	bf18      	it	ne
 800a098:	4601      	movne	r1, r0
 800a09a:	d073      	beq.n	800a184 <_realloc_r+0x160>
 800a09c:	f013 0f01 	tst.w	r3, #1
 800a0a0:	f040 8092 	bne.w	800a1c8 <_realloc_r+0x1a4>
 800a0a4:	f855 3c08 	ldr.w	r3, [r5, #-8]
 800a0a8:	ebc3 0c0a 	rsb	ip, r3, sl
 800a0ac:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800a0b0:	f023 0303 	bic.w	r3, r3, #3
 800a0b4:	2900      	cmp	r1, #0
 800a0b6:	f000 80d1 	beq.w	800a25c <_realloc_r+0x238>
 800a0ba:	4571      	cmp	r1, lr
 800a0bc:	f000 814f 	beq.w	800a35e <_realloc_r+0x33a>
 800a0c0:	445b      	add	r3, fp
 800a0c2:	18c6      	adds	r6, r0, r3
 800a0c4:	42b2      	cmp	r2, r6
 800a0c6:	f300 80ca 	bgt.w	800a25e <_realloc_r+0x23a>
 800a0ca:	68cb      	ldr	r3, [r1, #12]
 800a0cc:	46e0      	mov	r8, ip
 800a0ce:	6889      	ldr	r1, [r1, #8]
 800a0d0:	f1ab 0204 	sub.w	r2, fp, #4
 800a0d4:	2a24      	cmp	r2, #36	; 0x24
 800a0d6:	60cb      	str	r3, [r1, #12]
 800a0d8:	6099      	str	r1, [r3, #8]
 800a0da:	f8dc 300c 	ldr.w	r3, [ip, #12]
 800a0de:	f858 1f08 	ldr.w	r1, [r8, #8]!
 800a0e2:	60cb      	str	r3, [r1, #12]
 800a0e4:	6099      	str	r1, [r3, #8]
 800a0e6:	f200 8196 	bhi.w	800a416 <_realloc_r+0x3f2>
 800a0ea:	2a13      	cmp	r2, #19
 800a0ec:	4641      	mov	r1, r8
 800a0ee:	d921      	bls.n	800a134 <_realloc_r+0x110>
 800a0f0:	462b      	mov	r3, r5
 800a0f2:	f10c 0110 	add.w	r1, ip, #16
 800a0f6:	f853 0b04 	ldr.w	r0, [r3], #4
 800a0fa:	f8cc 0008 	str.w	r0, [ip, #8]
 800a0fe:	6868      	ldr	r0, [r5, #4]
 800a100:	1d1d      	adds	r5, r3, #4
 800a102:	2a1b      	cmp	r2, #27
 800a104:	f8cc 000c 	str.w	r0, [ip, #12]
 800a108:	d914      	bls.n	800a134 <_realloc_r+0x110>
 800a10a:	6858      	ldr	r0, [r3, #4]
 800a10c:	1d2b      	adds	r3, r5, #4
 800a10e:	f10c 0118 	add.w	r1, ip, #24
 800a112:	f8cc 0010 	str.w	r0, [ip, #16]
 800a116:	6868      	ldr	r0, [r5, #4]
 800a118:	3508      	adds	r5, #8
 800a11a:	2a24      	cmp	r2, #36	; 0x24
 800a11c:	f8cc 0014 	str.w	r0, [ip, #20]
 800a120:	d108      	bne.n	800a134 <_realloc_r+0x110>
 800a122:	685b      	ldr	r3, [r3, #4]
 800a124:	f10c 0120 	add.w	r1, ip, #32
 800a128:	f8cc 3018 	str.w	r3, [ip, #24]
 800a12c:	686b      	ldr	r3, [r5, #4]
 800a12e:	3508      	adds	r5, #8
 800a130:	f8cc 301c 	str.w	r3, [ip, #28]
 800a134:	462a      	mov	r2, r5
 800a136:	460b      	mov	r3, r1
 800a138:	46e2      	mov	sl, ip
 800a13a:	f852 0b04 	ldr.w	r0, [r2], #4
 800a13e:	f843 0b04 	str.w	r0, [r3], #4
 800a142:	6868      	ldr	r0, [r5, #4]
 800a144:	6048      	str	r0, [r1, #4]
 800a146:	6852      	ldr	r2, [r2, #4]
 800a148:	605a      	str	r2, [r3, #4]
 800a14a:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800a14e:	1b30      	subs	r0, r6, r4
 800a150:	280f      	cmp	r0, #15
 800a152:	d824      	bhi.n	800a19e <_realloc_r+0x17a>
 800a154:	eb0a 0206 	add.w	r2, sl, r6
 800a158:	f003 0301 	and.w	r3, r3, #1
 800a15c:	ea43 0606 	orr.w	r6, r3, r6
 800a160:	f8ca 6004 	str.w	r6, [sl, #4]
 800a164:	6853      	ldr	r3, [r2, #4]
 800a166:	f043 0301 	orr.w	r3, r3, #1
 800a16a:	6053      	str	r3, [r2, #4]
 800a16c:	4638      	mov	r0, r7
 800a16e:	f7fb f857 	bl	8005220 <__malloc_unlock>
 800a172:	4640      	mov	r0, r8
 800a174:	b003      	add	sp, #12
 800a176:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a17a:	f024 0407 	bic.w	r4, r4, #7
 800a17e:	4622      	mov	r2, r4
 800a180:	0fe0      	lsrs	r0, r4, #31
 800a182:	e766      	b.n	800a052 <_realloc_r+0x2e>
 800a184:	f026 0003 	bic.w	r0, r6, #3
 800a188:	eb00 060b 	add.w	r6, r0, fp
 800a18c:	42b2      	cmp	r2, r6
 800a18e:	dc85      	bgt.n	800a09c <_realloc_r+0x78>
 800a190:	68ca      	ldr	r2, [r1, #12]
 800a192:	f10a 0808 	add.w	r8, sl, #8
 800a196:	6889      	ldr	r1, [r1, #8]
 800a198:	60ca      	str	r2, [r1, #12]
 800a19a:	6091      	str	r1, [r2, #8]
 800a19c:	e7d7      	b.n	800a14e <_realloc_r+0x12a>
 800a19e:	eb0a 0104 	add.w	r1, sl, r4
 800a1a2:	f003 0301 	and.w	r3, r3, #1
 800a1a6:	180a      	adds	r2, r1, r0
 800a1a8:	ea43 0404 	orr.w	r4, r3, r4
 800a1ac:	f040 0001 	orr.w	r0, r0, #1
 800a1b0:	f8ca 4004 	str.w	r4, [sl, #4]
 800a1b4:	6048      	str	r0, [r1, #4]
 800a1b6:	4638      	mov	r0, r7
 800a1b8:	6853      	ldr	r3, [r2, #4]
 800a1ba:	3108      	adds	r1, #8
 800a1bc:	f043 0301 	orr.w	r3, r3, #1
 800a1c0:	6053      	str	r3, [r2, #4]
 800a1c2:	f7fb fc4f 	bl	8005a64 <_free_r>
 800a1c6:	e7d1      	b.n	800a16c <_realloc_r+0x148>
 800a1c8:	4641      	mov	r1, r8
 800a1ca:	4638      	mov	r0, r7
 800a1cc:	f7fa fd68 	bl	8004ca0 <_malloc_r>
 800a1d0:	4680      	mov	r8, r0
 800a1d2:	2800      	cmp	r0, #0
 800a1d4:	d0ca      	beq.n	800a16c <_realloc_r+0x148>
 800a1d6:	f8da 3004 	ldr.w	r3, [sl, #4]
 800a1da:	f1a0 0208 	sub.w	r2, r0, #8
 800a1de:	f023 0101 	bic.w	r1, r3, #1
 800a1e2:	4451      	add	r1, sl
 800a1e4:	428a      	cmp	r2, r1
 800a1e6:	f000 810e 	beq.w	800a406 <_realloc_r+0x3e2>
 800a1ea:	f1ab 0204 	sub.w	r2, fp, #4
 800a1ee:	2a24      	cmp	r2, #36	; 0x24
 800a1f0:	f200 80b1 	bhi.w	800a356 <_realloc_r+0x332>
 800a1f4:	2a13      	cmp	r2, #19
 800a1f6:	4629      	mov	r1, r5
 800a1f8:	4603      	mov	r3, r0
 800a1fa:	d91d      	bls.n	800a238 <_realloc_r+0x214>
 800a1fc:	462c      	mov	r4, r5
 800a1fe:	f854 3b04 	ldr.w	r3, [r4], #4
 800a202:	1d21      	adds	r1, r4, #4
 800a204:	f840 3b04 	str.w	r3, [r0], #4
 800a208:	1d03      	adds	r3, r0, #4
 800a20a:	686e      	ldr	r6, [r5, #4]
 800a20c:	2a1b      	cmp	r2, #27
 800a20e:	f8c8 6004 	str.w	r6, [r8, #4]
 800a212:	d911      	bls.n	800a238 <_realloc_r+0x214>
 800a214:	f8d4 e004 	ldr.w	lr, [r4, #4]
 800a218:	1d0e      	adds	r6, r1, #4
 800a21a:	1d1c      	adds	r4, r3, #4
 800a21c:	f8c0 e004 	str.w	lr, [r0, #4]
 800a220:	6848      	ldr	r0, [r1, #4]
 800a222:	3108      	adds	r1, #8
 800a224:	6058      	str	r0, [r3, #4]
 800a226:	3308      	adds	r3, #8
 800a228:	2a24      	cmp	r2, #36	; 0x24
 800a22a:	d105      	bne.n	800a238 <_realloc_r+0x214>
 800a22c:	6872      	ldr	r2, [r6, #4]
 800a22e:	6062      	str	r2, [r4, #4]
 800a230:	684a      	ldr	r2, [r1, #4]
 800a232:	3108      	adds	r1, #8
 800a234:	605a      	str	r2, [r3, #4]
 800a236:	3308      	adds	r3, #8
 800a238:	4608      	mov	r0, r1
 800a23a:	461a      	mov	r2, r3
 800a23c:	f850 4b04 	ldr.w	r4, [r0], #4
 800a240:	f842 4b04 	str.w	r4, [r2], #4
 800a244:	6849      	ldr	r1, [r1, #4]
 800a246:	6059      	str	r1, [r3, #4]
 800a248:	6843      	ldr	r3, [r0, #4]
 800a24a:	6053      	str	r3, [r2, #4]
 800a24c:	4638      	mov	r0, r7
 800a24e:	4629      	mov	r1, r5
 800a250:	f7fb fc08 	bl	8005a64 <_free_r>
 800a254:	4638      	mov	r0, r7
 800a256:	f7fa ffe3 	bl	8005220 <__malloc_unlock>
 800a25a:	e78a      	b.n	800a172 <_realloc_r+0x14e>
 800a25c:	445b      	add	r3, fp
 800a25e:	429a      	cmp	r2, r3
 800a260:	dcb2      	bgt.n	800a1c8 <_realloc_r+0x1a4>
 800a262:	46e0      	mov	r8, ip
 800a264:	f8dc 100c 	ldr.w	r1, [ip, #12]
 800a268:	f1ab 0204 	sub.w	r2, fp, #4
 800a26c:	f858 0f08 	ldr.w	r0, [r8, #8]!
 800a270:	2a24      	cmp	r2, #36	; 0x24
 800a272:	60c1      	str	r1, [r0, #12]
 800a274:	6088      	str	r0, [r1, #8]
 800a276:	d85f      	bhi.n	800a338 <_realloc_r+0x314>
 800a278:	2a13      	cmp	r2, #19
 800a27a:	4640      	mov	r0, r8
 800a27c:	d921      	bls.n	800a2c2 <_realloc_r+0x29e>
 800a27e:	4629      	mov	r1, r5
 800a280:	f10c 0010 	add.w	r0, ip, #16
 800a284:	f851 6b04 	ldr.w	r6, [r1], #4
 800a288:	f8cc 6008 	str.w	r6, [ip, #8]
 800a28c:	686e      	ldr	r6, [r5, #4]
 800a28e:	1d0d      	adds	r5, r1, #4
 800a290:	2a1b      	cmp	r2, #27
 800a292:	f8cc 600c 	str.w	r6, [ip, #12]
 800a296:	d914      	bls.n	800a2c2 <_realloc_r+0x29e>
 800a298:	684e      	ldr	r6, [r1, #4]
 800a29a:	1d29      	adds	r1, r5, #4
 800a29c:	f10c 0018 	add.w	r0, ip, #24
 800a2a0:	f8cc 6010 	str.w	r6, [ip, #16]
 800a2a4:	686e      	ldr	r6, [r5, #4]
 800a2a6:	3508      	adds	r5, #8
 800a2a8:	2a24      	cmp	r2, #36	; 0x24
 800a2aa:	f8cc 6014 	str.w	r6, [ip, #20]
 800a2ae:	d108      	bne.n	800a2c2 <_realloc_r+0x29e>
 800a2b0:	684a      	ldr	r2, [r1, #4]
 800a2b2:	f10c 0020 	add.w	r0, ip, #32
 800a2b6:	f8cc 2018 	str.w	r2, [ip, #24]
 800a2ba:	686a      	ldr	r2, [r5, #4]
 800a2bc:	3508      	adds	r5, #8
 800a2be:	f8cc 201c 	str.w	r2, [ip, #28]
 800a2c2:	4629      	mov	r1, r5
 800a2c4:	461e      	mov	r6, r3
 800a2c6:	4602      	mov	r2, r0
 800a2c8:	46e2      	mov	sl, ip
 800a2ca:	f851 3b04 	ldr.w	r3, [r1], #4
 800a2ce:	f842 3b04 	str.w	r3, [r2], #4
 800a2d2:	686b      	ldr	r3, [r5, #4]
 800a2d4:	6043      	str	r3, [r0, #4]
 800a2d6:	684b      	ldr	r3, [r1, #4]
 800a2d8:	6053      	str	r3, [r2, #4]
 800a2da:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800a2de:	e736      	b.n	800a14e <_realloc_r+0x12a>
 800a2e0:	4611      	mov	r1, r2
 800a2e2:	b003      	add	sp, #12
 800a2e4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a2e8:	f7fa bcda 	b.w	8004ca0 <_malloc_r>
 800a2ec:	230c      	movs	r3, #12
 800a2ee:	f04f 0800 	mov.w	r8, #0
 800a2f2:	603b      	str	r3, [r7, #0]
 800a2f4:	e73d      	b.n	800a172 <_realloc_r+0x14e>
 800a2f6:	f8de 0004 	ldr.w	r0, [lr, #4]
 800a2fa:	f104 0c10 	add.w	ip, r4, #16
 800a2fe:	f020 0003 	bic.w	r0, r0, #3
 800a302:	eb00 010b 	add.w	r1, r0, fp
 800a306:	4561      	cmp	r1, ip
 800a308:	bfb8      	it	lt
 800a30a:	4671      	movlt	r1, lr
 800a30c:	f6ff aec6 	blt.w	800a09c <_realloc_r+0x78>
 800a310:	eb0a 0304 	add.w	r3, sl, r4
 800a314:	1b0a      	subs	r2, r1, r4
 800a316:	f042 0201 	orr.w	r2, r2, #1
 800a31a:	f8c9 3008 	str.w	r3, [r9, #8]
 800a31e:	605a      	str	r2, [r3, #4]
 800a320:	4638      	mov	r0, r7
 800a322:	f8da 2004 	ldr.w	r2, [sl, #4]
 800a326:	46a8      	mov	r8, r5
 800a328:	f002 0301 	and.w	r3, r2, #1
 800a32c:	431c      	orrs	r4, r3
 800a32e:	f8ca 4004 	str.w	r4, [sl, #4]
 800a332:	f7fa ff75 	bl	8005220 <__malloc_unlock>
 800a336:	e71c      	b.n	800a172 <_realloc_r+0x14e>
 800a338:	4640      	mov	r0, r8
 800a33a:	4629      	mov	r1, r5
 800a33c:	9301      	str	r3, [sp, #4]
 800a33e:	f8cd c000 	str.w	ip, [sp]
 800a342:	f7ff fe15 	bl	8009f70 <memmove>
 800a346:	f8dd c000 	ldr.w	ip, [sp]
 800a34a:	9b01      	ldr	r3, [sp, #4]
 800a34c:	46e2      	mov	sl, ip
 800a34e:	461e      	mov	r6, r3
 800a350:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800a354:	e6fb      	b.n	800a14e <_realloc_r+0x12a>
 800a356:	4629      	mov	r1, r5
 800a358:	f7ff fe0a 	bl	8009f70 <memmove>
 800a35c:	e776      	b.n	800a24c <_realloc_r+0x228>
 800a35e:	445b      	add	r3, fp
 800a360:	f104 0110 	add.w	r1, r4, #16
 800a364:	18c6      	adds	r6, r0, r3
 800a366:	428e      	cmp	r6, r1
 800a368:	f6ff af79 	blt.w	800a25e <_realloc_r+0x23a>
 800a36c:	46e0      	mov	r8, ip
 800a36e:	f8dc 300c 	ldr.w	r3, [ip, #12]
 800a372:	f1ab 0204 	sub.w	r2, fp, #4
 800a376:	f858 1f08 	ldr.w	r1, [r8, #8]!
 800a37a:	2a24      	cmp	r2, #36	; 0x24
 800a37c:	60cb      	str	r3, [r1, #12]
 800a37e:	6099      	str	r1, [r3, #8]
 800a380:	d855      	bhi.n	800a42e <_realloc_r+0x40a>
 800a382:	2a13      	cmp	r2, #19
 800a384:	4641      	mov	r1, r8
 800a386:	d921      	bls.n	800a3cc <_realloc_r+0x3a8>
 800a388:	462b      	mov	r3, r5
 800a38a:	f10c 0110 	add.w	r1, ip, #16
 800a38e:	f853 0b04 	ldr.w	r0, [r3], #4
 800a392:	f8cc 0008 	str.w	r0, [ip, #8]
 800a396:	6868      	ldr	r0, [r5, #4]
 800a398:	1d1d      	adds	r5, r3, #4
 800a39a:	2a1b      	cmp	r2, #27
 800a39c:	f8cc 000c 	str.w	r0, [ip, #12]
 800a3a0:	d914      	bls.n	800a3cc <_realloc_r+0x3a8>
 800a3a2:	6858      	ldr	r0, [r3, #4]
 800a3a4:	1d2b      	adds	r3, r5, #4
 800a3a6:	f10c 0118 	add.w	r1, ip, #24
 800a3aa:	f8cc 0010 	str.w	r0, [ip, #16]
 800a3ae:	6868      	ldr	r0, [r5, #4]
 800a3b0:	3508      	adds	r5, #8
 800a3b2:	2a24      	cmp	r2, #36	; 0x24
 800a3b4:	f8cc 0014 	str.w	r0, [ip, #20]
 800a3b8:	d108      	bne.n	800a3cc <_realloc_r+0x3a8>
 800a3ba:	685b      	ldr	r3, [r3, #4]
 800a3bc:	f10c 0120 	add.w	r1, ip, #32
 800a3c0:	f8cc 3018 	str.w	r3, [ip, #24]
 800a3c4:	686b      	ldr	r3, [r5, #4]
 800a3c6:	3508      	adds	r5, #8
 800a3c8:	f8cc 301c 	str.w	r3, [ip, #28]
 800a3cc:	462a      	mov	r2, r5
 800a3ce:	460b      	mov	r3, r1
 800a3d0:	f852 0b04 	ldr.w	r0, [r2], #4
 800a3d4:	f843 0b04 	str.w	r0, [r3], #4
 800a3d8:	6868      	ldr	r0, [r5, #4]
 800a3da:	6048      	str	r0, [r1, #4]
 800a3dc:	6852      	ldr	r2, [r2, #4]
 800a3de:	605a      	str	r2, [r3, #4]
 800a3e0:	eb0c 0304 	add.w	r3, ip, r4
 800a3e4:	1b32      	subs	r2, r6, r4
 800a3e6:	f042 0201 	orr.w	r2, r2, #1
 800a3ea:	f8c9 3008 	str.w	r3, [r9, #8]
 800a3ee:	605a      	str	r2, [r3, #4]
 800a3f0:	4638      	mov	r0, r7
 800a3f2:	f8dc 2004 	ldr.w	r2, [ip, #4]
 800a3f6:	f002 0301 	and.w	r3, r2, #1
 800a3fa:	431c      	orrs	r4, r3
 800a3fc:	f8cc 4004 	str.w	r4, [ip, #4]
 800a400:	f7fa ff0e 	bl	8005220 <__malloc_unlock>
 800a404:	e6b5      	b.n	800a172 <_realloc_r+0x14e>
 800a406:	f850 6c04 	ldr.w	r6, [r0, #-4]
 800a40a:	f10a 0808 	add.w	r8, sl, #8
 800a40e:	f026 0603 	bic.w	r6, r6, #3
 800a412:	445e      	add	r6, fp
 800a414:	e69b      	b.n	800a14e <_realloc_r+0x12a>
 800a416:	4640      	mov	r0, r8
 800a418:	4629      	mov	r1, r5
 800a41a:	f8cd c000 	str.w	ip, [sp]
 800a41e:	f7ff fda7 	bl	8009f70 <memmove>
 800a422:	f8dd c000 	ldr.w	ip, [sp]
 800a426:	46e2      	mov	sl, ip
 800a428:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800a42c:	e68f      	b.n	800a14e <_realloc_r+0x12a>
 800a42e:	4640      	mov	r0, r8
 800a430:	4629      	mov	r1, r5
 800a432:	f8cd c000 	str.w	ip, [sp]
 800a436:	f7ff fd9b 	bl	8009f70 <memmove>
 800a43a:	f8dd c000 	ldr.w	ip, [sp]
 800a43e:	e7cf      	b.n	800a3e0 <_realloc_r+0x3bc>

0800a440 <__aeabi_uidiv>:
 800a440:	1e4a      	subs	r2, r1, #1
 800a442:	bf08      	it	eq
 800a444:	4770      	bxeq	lr
 800a446:	f0c0 8124 	bcc.w	800a692 <__aeabi_uidiv+0x252>
 800a44a:	4288      	cmp	r0, r1
 800a44c:	f240 8116 	bls.w	800a67c <__aeabi_uidiv+0x23c>
 800a450:	4211      	tst	r1, r2
 800a452:	f000 8117 	beq.w	800a684 <__aeabi_uidiv+0x244>
 800a456:	fab0 f380 	clz	r3, r0
 800a45a:	fab1 f281 	clz	r2, r1
 800a45e:	eba2 0303 	sub.w	r3, r2, r3
 800a462:	f1c3 031f 	rsb	r3, r3, #31
 800a466:	a204      	add	r2, pc, #16	; (adr r2, 800a478 <__aeabi_uidiv+0x38>)
 800a468:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800a46c:	f04f 0200 	mov.w	r2, #0
 800a470:	469f      	mov	pc, r3
 800a472:	bf00      	nop
 800a474:	f3af 8000 	nop.w
 800a478:	ebb0 7fc1 	cmp.w	r0, r1, lsl #31
 800a47c:	bf00      	nop
 800a47e:	eb42 0202 	adc.w	r2, r2, r2
 800a482:	bf28      	it	cs
 800a484:	eba0 70c1 	subcs.w	r0, r0, r1, lsl #31
 800a488:	ebb0 7f81 	cmp.w	r0, r1, lsl #30
 800a48c:	bf00      	nop
 800a48e:	eb42 0202 	adc.w	r2, r2, r2
 800a492:	bf28      	it	cs
 800a494:	eba0 7081 	subcs.w	r0, r0, r1, lsl #30
 800a498:	ebb0 7f41 	cmp.w	r0, r1, lsl #29
 800a49c:	bf00      	nop
 800a49e:	eb42 0202 	adc.w	r2, r2, r2
 800a4a2:	bf28      	it	cs
 800a4a4:	eba0 7041 	subcs.w	r0, r0, r1, lsl #29
 800a4a8:	ebb0 7f01 	cmp.w	r0, r1, lsl #28
 800a4ac:	bf00      	nop
 800a4ae:	eb42 0202 	adc.w	r2, r2, r2
 800a4b2:	bf28      	it	cs
 800a4b4:	eba0 7001 	subcs.w	r0, r0, r1, lsl #28
 800a4b8:	ebb0 6fc1 	cmp.w	r0, r1, lsl #27
 800a4bc:	bf00      	nop
 800a4be:	eb42 0202 	adc.w	r2, r2, r2
 800a4c2:	bf28      	it	cs
 800a4c4:	eba0 60c1 	subcs.w	r0, r0, r1, lsl #27
 800a4c8:	ebb0 6f81 	cmp.w	r0, r1, lsl #26
 800a4cc:	bf00      	nop
 800a4ce:	eb42 0202 	adc.w	r2, r2, r2
 800a4d2:	bf28      	it	cs
 800a4d4:	eba0 6081 	subcs.w	r0, r0, r1, lsl #26
 800a4d8:	ebb0 6f41 	cmp.w	r0, r1, lsl #25
 800a4dc:	bf00      	nop
 800a4de:	eb42 0202 	adc.w	r2, r2, r2
 800a4e2:	bf28      	it	cs
 800a4e4:	eba0 6041 	subcs.w	r0, r0, r1, lsl #25
 800a4e8:	ebb0 6f01 	cmp.w	r0, r1, lsl #24
 800a4ec:	bf00      	nop
 800a4ee:	eb42 0202 	adc.w	r2, r2, r2
 800a4f2:	bf28      	it	cs
 800a4f4:	eba0 6001 	subcs.w	r0, r0, r1, lsl #24
 800a4f8:	ebb0 5fc1 	cmp.w	r0, r1, lsl #23
 800a4fc:	bf00      	nop
 800a4fe:	eb42 0202 	adc.w	r2, r2, r2
 800a502:	bf28      	it	cs
 800a504:	eba0 50c1 	subcs.w	r0, r0, r1, lsl #23
 800a508:	ebb0 5f81 	cmp.w	r0, r1, lsl #22
 800a50c:	bf00      	nop
 800a50e:	eb42 0202 	adc.w	r2, r2, r2
 800a512:	bf28      	it	cs
 800a514:	eba0 5081 	subcs.w	r0, r0, r1, lsl #22
 800a518:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
 800a51c:	bf00      	nop
 800a51e:	eb42 0202 	adc.w	r2, r2, r2
 800a522:	bf28      	it	cs
 800a524:	eba0 5041 	subcs.w	r0, r0, r1, lsl #21
 800a528:	ebb0 5f01 	cmp.w	r0, r1, lsl #20
 800a52c:	bf00      	nop
 800a52e:	eb42 0202 	adc.w	r2, r2, r2
 800a532:	bf28      	it	cs
 800a534:	eba0 5001 	subcs.w	r0, r0, r1, lsl #20
 800a538:	ebb0 4fc1 	cmp.w	r0, r1, lsl #19
 800a53c:	bf00      	nop
 800a53e:	eb42 0202 	adc.w	r2, r2, r2
 800a542:	bf28      	it	cs
 800a544:	eba0 40c1 	subcs.w	r0, r0, r1, lsl #19
 800a548:	ebb0 4f81 	cmp.w	r0, r1, lsl #18
 800a54c:	bf00      	nop
 800a54e:	eb42 0202 	adc.w	r2, r2, r2
 800a552:	bf28      	it	cs
 800a554:	eba0 4081 	subcs.w	r0, r0, r1, lsl #18
 800a558:	ebb0 4f41 	cmp.w	r0, r1, lsl #17
 800a55c:	bf00      	nop
 800a55e:	eb42 0202 	adc.w	r2, r2, r2
 800a562:	bf28      	it	cs
 800a564:	eba0 4041 	subcs.w	r0, r0, r1, lsl #17
 800a568:	ebb0 4f01 	cmp.w	r0, r1, lsl #16
 800a56c:	bf00      	nop
 800a56e:	eb42 0202 	adc.w	r2, r2, r2
 800a572:	bf28      	it	cs
 800a574:	eba0 4001 	subcs.w	r0, r0, r1, lsl #16
 800a578:	ebb0 3fc1 	cmp.w	r0, r1, lsl #15
 800a57c:	bf00      	nop
 800a57e:	eb42 0202 	adc.w	r2, r2, r2
 800a582:	bf28      	it	cs
 800a584:	eba0 30c1 	subcs.w	r0, r0, r1, lsl #15
 800a588:	ebb0 3f81 	cmp.w	r0, r1, lsl #14
 800a58c:	bf00      	nop
 800a58e:	eb42 0202 	adc.w	r2, r2, r2
 800a592:	bf28      	it	cs
 800a594:	eba0 3081 	subcs.w	r0, r0, r1, lsl #14
 800a598:	ebb0 3f41 	cmp.w	r0, r1, lsl #13
 800a59c:	bf00      	nop
 800a59e:	eb42 0202 	adc.w	r2, r2, r2
 800a5a2:	bf28      	it	cs
 800a5a4:	eba0 3041 	subcs.w	r0, r0, r1, lsl #13
 800a5a8:	ebb0 3f01 	cmp.w	r0, r1, lsl #12
 800a5ac:	bf00      	nop
 800a5ae:	eb42 0202 	adc.w	r2, r2, r2
 800a5b2:	bf28      	it	cs
 800a5b4:	eba0 3001 	subcs.w	r0, r0, r1, lsl #12
 800a5b8:	ebb0 2fc1 	cmp.w	r0, r1, lsl #11
 800a5bc:	bf00      	nop
 800a5be:	eb42 0202 	adc.w	r2, r2, r2
 800a5c2:	bf28      	it	cs
 800a5c4:	eba0 20c1 	subcs.w	r0, r0, r1, lsl #11
 800a5c8:	ebb0 2f81 	cmp.w	r0, r1, lsl #10
 800a5cc:	bf00      	nop
 800a5ce:	eb42 0202 	adc.w	r2, r2, r2
 800a5d2:	bf28      	it	cs
 800a5d4:	eba0 2081 	subcs.w	r0, r0, r1, lsl #10
 800a5d8:	ebb0 2f41 	cmp.w	r0, r1, lsl #9
 800a5dc:	bf00      	nop
 800a5de:	eb42 0202 	adc.w	r2, r2, r2
 800a5e2:	bf28      	it	cs
 800a5e4:	eba0 2041 	subcs.w	r0, r0, r1, lsl #9
 800a5e8:	ebb0 2f01 	cmp.w	r0, r1, lsl #8
 800a5ec:	bf00      	nop
 800a5ee:	eb42 0202 	adc.w	r2, r2, r2
 800a5f2:	bf28      	it	cs
 800a5f4:	eba0 2001 	subcs.w	r0, r0, r1, lsl #8
 800a5f8:	ebb0 1fc1 	cmp.w	r0, r1, lsl #7
 800a5fc:	bf00      	nop
 800a5fe:	eb42 0202 	adc.w	r2, r2, r2
 800a602:	bf28      	it	cs
 800a604:	eba0 10c1 	subcs.w	r0, r0, r1, lsl #7
 800a608:	ebb0 1f81 	cmp.w	r0, r1, lsl #6
 800a60c:	bf00      	nop
 800a60e:	eb42 0202 	adc.w	r2, r2, r2
 800a612:	bf28      	it	cs
 800a614:	eba0 1081 	subcs.w	r0, r0, r1, lsl #6
 800a618:	ebb0 1f41 	cmp.w	r0, r1, lsl #5
 800a61c:	bf00      	nop
 800a61e:	eb42 0202 	adc.w	r2, r2, r2
 800a622:	bf28      	it	cs
 800a624:	eba0 1041 	subcs.w	r0, r0, r1, lsl #5
 800a628:	ebb0 1f01 	cmp.w	r0, r1, lsl #4
 800a62c:	bf00      	nop
 800a62e:	eb42 0202 	adc.w	r2, r2, r2
 800a632:	bf28      	it	cs
 800a634:	eba0 1001 	subcs.w	r0, r0, r1, lsl #4
 800a638:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
 800a63c:	bf00      	nop
 800a63e:	eb42 0202 	adc.w	r2, r2, r2
 800a642:	bf28      	it	cs
 800a644:	eba0 00c1 	subcs.w	r0, r0, r1, lsl #3
 800a648:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
 800a64c:	bf00      	nop
 800a64e:	eb42 0202 	adc.w	r2, r2, r2
 800a652:	bf28      	it	cs
 800a654:	eba0 0081 	subcs.w	r0, r0, r1, lsl #2
 800a658:	ebb0 0f41 	cmp.w	r0, r1, lsl #1
 800a65c:	bf00      	nop
 800a65e:	eb42 0202 	adc.w	r2, r2, r2
 800a662:	bf28      	it	cs
 800a664:	eba0 0041 	subcs.w	r0, r0, r1, lsl #1
 800a668:	ebb0 0f01 	cmp.w	r0, r1
 800a66c:	bf00      	nop
 800a66e:	eb42 0202 	adc.w	r2, r2, r2
 800a672:	bf28      	it	cs
 800a674:	eba0 0001 	subcs.w	r0, r0, r1
 800a678:	4610      	mov	r0, r2
 800a67a:	4770      	bx	lr
 800a67c:	bf0c      	ite	eq
 800a67e:	2001      	moveq	r0, #1
 800a680:	2000      	movne	r0, #0
 800a682:	4770      	bx	lr
 800a684:	fab1 f281 	clz	r2, r1
 800a688:	f1c2 021f 	rsb	r2, r2, #31
 800a68c:	fa20 f002 	lsr.w	r0, r0, r2
 800a690:	4770      	bx	lr
 800a692:	b108      	cbz	r0, 800a698 <__aeabi_uidiv+0x258>
 800a694:	f04f 30ff 	mov.w	r0, #4294967295
 800a698:	f000 b80e 	b.w	800a6b8 <__aeabi_idiv0>

0800a69c <__aeabi_uidivmod>:
 800a69c:	2900      	cmp	r1, #0
 800a69e:	d0f8      	beq.n	800a692 <__aeabi_uidiv+0x252>
 800a6a0:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
 800a6a4:	f7ff fecc 	bl	800a440 <__aeabi_uidiv>
 800a6a8:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
 800a6ac:	fb02 f300 	mul.w	r3, r2, r0
 800a6b0:	eba1 0103 	sub.w	r1, r1, r3
 800a6b4:	4770      	bx	lr
 800a6b6:	bf00      	nop

0800a6b8 <__aeabi_idiv0>:
 800a6b8:	4770      	bx	lr
 800a6ba:	bf00      	nop

0800a6bc <__aeabi_drsub>:
 800a6bc:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 800a6c0:	e002      	b.n	800a6c8 <__adddf3>
 800a6c2:	bf00      	nop

0800a6c4 <__aeabi_dsub>:
 800a6c4:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800a6c8 <__adddf3>:
 800a6c8:	b530      	push	{r4, r5, lr}
 800a6ca:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800a6ce:	ea4f 0543 	mov.w	r5, r3, lsl #1
 800a6d2:	ea94 0f05 	teq	r4, r5
 800a6d6:	bf08      	it	eq
 800a6d8:	ea90 0f02 	teqeq	r0, r2
 800a6dc:	bf1f      	itttt	ne
 800a6de:	ea54 0c00 	orrsne.w	ip, r4, r0
 800a6e2:	ea55 0c02 	orrsne.w	ip, r5, r2
 800a6e6:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800a6ea:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800a6ee:	f000 80e2 	beq.w	800a8b6 <__adddf3+0x1ee>
 800a6f2:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800a6f6:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800a6fa:	bfb8      	it	lt
 800a6fc:	426d      	neglt	r5, r5
 800a6fe:	dd0c      	ble.n	800a71a <__adddf3+0x52>
 800a700:	442c      	add	r4, r5
 800a702:	ea80 0202 	eor.w	r2, r0, r2
 800a706:	ea81 0303 	eor.w	r3, r1, r3
 800a70a:	ea82 0000 	eor.w	r0, r2, r0
 800a70e:	ea83 0101 	eor.w	r1, r3, r1
 800a712:	ea80 0202 	eor.w	r2, r0, r2
 800a716:	ea81 0303 	eor.w	r3, r1, r3
 800a71a:	2d36      	cmp	r5, #54	; 0x36
 800a71c:	bf88      	it	hi
 800a71e:	bd30      	pophi	{r4, r5, pc}
 800a720:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800a724:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800a728:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 800a72c:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800a730:	d002      	beq.n	800a738 <__adddf3+0x70>
 800a732:	4240      	negs	r0, r0
 800a734:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800a738:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 800a73c:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800a740:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 800a744:	d002      	beq.n	800a74c <__adddf3+0x84>
 800a746:	4252      	negs	r2, r2
 800a748:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800a74c:	ea94 0f05 	teq	r4, r5
 800a750:	f000 80a7 	beq.w	800a8a2 <__adddf3+0x1da>
 800a754:	f1a4 0401 	sub.w	r4, r4, #1
 800a758:	f1d5 0e20 	rsbs	lr, r5, #32
 800a75c:	db0d      	blt.n	800a77a <__adddf3+0xb2>
 800a75e:	fa02 fc0e 	lsl.w	ip, r2, lr
 800a762:	fa22 f205 	lsr.w	r2, r2, r5
 800a766:	1880      	adds	r0, r0, r2
 800a768:	f141 0100 	adc.w	r1, r1, #0
 800a76c:	fa03 f20e 	lsl.w	r2, r3, lr
 800a770:	1880      	adds	r0, r0, r2
 800a772:	fa43 f305 	asr.w	r3, r3, r5
 800a776:	4159      	adcs	r1, r3
 800a778:	e00e      	b.n	800a798 <__adddf3+0xd0>
 800a77a:	f1a5 0520 	sub.w	r5, r5, #32
 800a77e:	f10e 0e20 	add.w	lr, lr, #32
 800a782:	2a01      	cmp	r2, #1
 800a784:	fa03 fc0e 	lsl.w	ip, r3, lr
 800a788:	bf28      	it	cs
 800a78a:	f04c 0c02 	orrcs.w	ip, ip, #2
 800a78e:	fa43 f305 	asr.w	r3, r3, r5
 800a792:	18c0      	adds	r0, r0, r3
 800a794:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800a798:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800a79c:	d507      	bpl.n	800a7ae <__adddf3+0xe6>
 800a79e:	f04f 0e00 	mov.w	lr, #0
 800a7a2:	f1dc 0c00 	rsbs	ip, ip, #0
 800a7a6:	eb7e 0000 	sbcs.w	r0, lr, r0
 800a7aa:	eb6e 0101 	sbc.w	r1, lr, r1
 800a7ae:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 800a7b2:	d31b      	bcc.n	800a7ec <__adddf3+0x124>
 800a7b4:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800a7b8:	d30c      	bcc.n	800a7d4 <__adddf3+0x10c>
 800a7ba:	0849      	lsrs	r1, r1, #1
 800a7bc:	ea5f 0030 	movs.w	r0, r0, rrx
 800a7c0:	ea4f 0c3c 	mov.w	ip, ip, rrx
 800a7c4:	f104 0401 	add.w	r4, r4, #1
 800a7c8:	ea4f 5244 	mov.w	r2, r4, lsl #21
 800a7cc:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 800a7d0:	f080 809a 	bcs.w	800a908 <__adddf3+0x240>
 800a7d4:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800a7d8:	bf08      	it	eq
 800a7da:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800a7de:	f150 0000 	adcs.w	r0, r0, #0
 800a7e2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800a7e6:	ea41 0105 	orr.w	r1, r1, r5
 800a7ea:	bd30      	pop	{r4, r5, pc}
 800a7ec:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800a7f0:	4140      	adcs	r0, r0
 800a7f2:	eb41 0101 	adc.w	r1, r1, r1
 800a7f6:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800a7fa:	f1a4 0401 	sub.w	r4, r4, #1
 800a7fe:	d1e9      	bne.n	800a7d4 <__adddf3+0x10c>
 800a800:	f091 0f00 	teq	r1, #0
 800a804:	bf04      	itt	eq
 800a806:	4601      	moveq	r1, r0
 800a808:	2000      	moveq	r0, #0
 800a80a:	fab1 f381 	clz	r3, r1
 800a80e:	bf08      	it	eq
 800a810:	3320      	addeq	r3, #32
 800a812:	f1a3 030b 	sub.w	r3, r3, #11
 800a816:	f1b3 0220 	subs.w	r2, r3, #32
 800a81a:	da0c      	bge.n	800a836 <__adddf3+0x16e>
 800a81c:	320c      	adds	r2, #12
 800a81e:	dd08      	ble.n	800a832 <__adddf3+0x16a>
 800a820:	f102 0c14 	add.w	ip, r2, #20
 800a824:	f1c2 020c 	rsb	r2, r2, #12
 800a828:	fa01 f00c 	lsl.w	r0, r1, ip
 800a82c:	fa21 f102 	lsr.w	r1, r1, r2
 800a830:	e00c      	b.n	800a84c <__adddf3+0x184>
 800a832:	f102 0214 	add.w	r2, r2, #20
 800a836:	bfd8      	it	le
 800a838:	f1c2 0c20 	rsble	ip, r2, #32
 800a83c:	fa01 f102 	lsl.w	r1, r1, r2
 800a840:	fa20 fc0c 	lsr.w	ip, r0, ip
 800a844:	bfdc      	itt	le
 800a846:	ea41 010c 	orrle.w	r1, r1, ip
 800a84a:	4090      	lslle	r0, r2
 800a84c:	1ae4      	subs	r4, r4, r3
 800a84e:	bfa2      	ittt	ge
 800a850:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 800a854:	4329      	orrge	r1, r5
 800a856:	bd30      	popge	{r4, r5, pc}
 800a858:	ea6f 0404 	mvn.w	r4, r4
 800a85c:	3c1f      	subs	r4, #31
 800a85e:	da1c      	bge.n	800a89a <__adddf3+0x1d2>
 800a860:	340c      	adds	r4, #12
 800a862:	dc0e      	bgt.n	800a882 <__adddf3+0x1ba>
 800a864:	f104 0414 	add.w	r4, r4, #20
 800a868:	f1c4 0220 	rsb	r2, r4, #32
 800a86c:	fa20 f004 	lsr.w	r0, r0, r4
 800a870:	fa01 f302 	lsl.w	r3, r1, r2
 800a874:	ea40 0003 	orr.w	r0, r0, r3
 800a878:	fa21 f304 	lsr.w	r3, r1, r4
 800a87c:	ea45 0103 	orr.w	r1, r5, r3
 800a880:	bd30      	pop	{r4, r5, pc}
 800a882:	f1c4 040c 	rsb	r4, r4, #12
 800a886:	f1c4 0220 	rsb	r2, r4, #32
 800a88a:	fa20 f002 	lsr.w	r0, r0, r2
 800a88e:	fa01 f304 	lsl.w	r3, r1, r4
 800a892:	ea40 0003 	orr.w	r0, r0, r3
 800a896:	4629      	mov	r1, r5
 800a898:	bd30      	pop	{r4, r5, pc}
 800a89a:	fa21 f004 	lsr.w	r0, r1, r4
 800a89e:	4629      	mov	r1, r5
 800a8a0:	bd30      	pop	{r4, r5, pc}
 800a8a2:	f094 0f00 	teq	r4, #0
 800a8a6:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800a8aa:	bf06      	itte	eq
 800a8ac:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 800a8b0:	3401      	addeq	r4, #1
 800a8b2:	3d01      	subne	r5, #1
 800a8b4:	e74e      	b.n	800a754 <__adddf3+0x8c>
 800a8b6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800a8ba:	bf18      	it	ne
 800a8bc:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800a8c0:	d029      	beq.n	800a916 <__adddf3+0x24e>
 800a8c2:	ea94 0f05 	teq	r4, r5
 800a8c6:	bf08      	it	eq
 800a8c8:	ea90 0f02 	teqeq	r0, r2
 800a8cc:	d005      	beq.n	800a8da <__adddf3+0x212>
 800a8ce:	ea54 0c00 	orrs.w	ip, r4, r0
 800a8d2:	bf04      	itt	eq
 800a8d4:	4619      	moveq	r1, r3
 800a8d6:	4610      	moveq	r0, r2
 800a8d8:	bd30      	pop	{r4, r5, pc}
 800a8da:	ea91 0f03 	teq	r1, r3
 800a8de:	bf1e      	ittt	ne
 800a8e0:	2100      	movne	r1, #0
 800a8e2:	2000      	movne	r0, #0
 800a8e4:	bd30      	popne	{r4, r5, pc}
 800a8e6:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800a8ea:	d105      	bne.n	800a8f8 <__adddf3+0x230>
 800a8ec:	0040      	lsls	r0, r0, #1
 800a8ee:	4149      	adcs	r1, r1
 800a8f0:	bf28      	it	cs
 800a8f2:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800a8f6:	bd30      	pop	{r4, r5, pc}
 800a8f8:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 800a8fc:	bf3c      	itt	cc
 800a8fe:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800a902:	bd30      	popcc	{r4, r5, pc}
 800a904:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800a908:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 800a90c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800a910:	f04f 0000 	mov.w	r0, #0
 800a914:	bd30      	pop	{r4, r5, pc}
 800a916:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800a91a:	bf1a      	itte	ne
 800a91c:	4619      	movne	r1, r3
 800a91e:	4610      	movne	r0, r2
 800a920:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 800a924:	bf1c      	itt	ne
 800a926:	460b      	movne	r3, r1
 800a928:	4602      	movne	r2, r0
 800a92a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800a92e:	bf06      	itte	eq
 800a930:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 800a934:	ea91 0f03 	teqeq	r1, r3
 800a938:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 800a93c:	bd30      	pop	{r4, r5, pc}
 800a93e:	bf00      	nop

0800a940 <__aeabi_ui2d>:
 800a940:	f090 0f00 	teq	r0, #0
 800a944:	bf04      	itt	eq
 800a946:	2100      	moveq	r1, #0
 800a948:	4770      	bxeq	lr
 800a94a:	b530      	push	{r4, r5, lr}
 800a94c:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800a950:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800a954:	f04f 0500 	mov.w	r5, #0
 800a958:	f04f 0100 	mov.w	r1, #0
 800a95c:	e750      	b.n	800a800 <__adddf3+0x138>
 800a95e:	bf00      	nop

0800a960 <__aeabi_i2d>:
 800a960:	f090 0f00 	teq	r0, #0
 800a964:	bf04      	itt	eq
 800a966:	2100      	moveq	r1, #0
 800a968:	4770      	bxeq	lr
 800a96a:	b530      	push	{r4, r5, lr}
 800a96c:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800a970:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800a974:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800a978:	bf48      	it	mi
 800a97a:	4240      	negmi	r0, r0
 800a97c:	f04f 0100 	mov.w	r1, #0
 800a980:	e73e      	b.n	800a800 <__adddf3+0x138>
 800a982:	bf00      	nop

0800a984 <__aeabi_f2d>:
 800a984:	0042      	lsls	r2, r0, #1
 800a986:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800a98a:	ea4f 0131 	mov.w	r1, r1, rrx
 800a98e:	ea4f 7002 	mov.w	r0, r2, lsl #28
 800a992:	bf1f      	itttt	ne
 800a994:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800a998:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800a99c:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 800a9a0:	4770      	bxne	lr
 800a9a2:	f092 0f00 	teq	r2, #0
 800a9a6:	bf14      	ite	ne
 800a9a8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800a9ac:	4770      	bxeq	lr
 800a9ae:	b530      	push	{r4, r5, lr}
 800a9b0:	f44f 7460 	mov.w	r4, #896	; 0x380
 800a9b4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800a9b8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800a9bc:	e720      	b.n	800a800 <__adddf3+0x138>
 800a9be:	bf00      	nop

0800a9c0 <__aeabi_ul2d>:
 800a9c0:	ea50 0201 	orrs.w	r2, r0, r1
 800a9c4:	bf08      	it	eq
 800a9c6:	4770      	bxeq	lr
 800a9c8:	b530      	push	{r4, r5, lr}
 800a9ca:	f04f 0500 	mov.w	r5, #0
 800a9ce:	e00a      	b.n	800a9e6 <__aeabi_l2d+0x16>

0800a9d0 <__aeabi_l2d>:
 800a9d0:	ea50 0201 	orrs.w	r2, r0, r1
 800a9d4:	bf08      	it	eq
 800a9d6:	4770      	bxeq	lr
 800a9d8:	b530      	push	{r4, r5, lr}
 800a9da:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800a9de:	d502      	bpl.n	800a9e6 <__aeabi_l2d+0x16>
 800a9e0:	4240      	negs	r0, r0
 800a9e2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800a9e6:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800a9ea:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800a9ee:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800a9f2:	f43f aedc 	beq.w	800a7ae <__adddf3+0xe6>
 800a9f6:	f04f 0203 	mov.w	r2, #3
 800a9fa:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800a9fe:	bf18      	it	ne
 800aa00:	3203      	addne	r2, #3
 800aa02:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800aa06:	bf18      	it	ne
 800aa08:	3203      	addne	r2, #3
 800aa0a:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800aa0e:	f1c2 0320 	rsb	r3, r2, #32
 800aa12:	fa00 fc03 	lsl.w	ip, r0, r3
 800aa16:	fa20 f002 	lsr.w	r0, r0, r2
 800aa1a:	fa01 fe03 	lsl.w	lr, r1, r3
 800aa1e:	ea40 000e 	orr.w	r0, r0, lr
 800aa22:	fa21 f102 	lsr.w	r1, r1, r2
 800aa26:	4414      	add	r4, r2
 800aa28:	e6c1      	b.n	800a7ae <__adddf3+0xe6>
 800aa2a:	bf00      	nop

0800aa2c <__aeabi_dmul>:
 800aa2c:	b570      	push	{r4, r5, r6, lr}
 800aa2e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800aa32:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800aa36:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800aa3a:	bf1d      	ittte	ne
 800aa3c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800aa40:	ea94 0f0c 	teqne	r4, ip
 800aa44:	ea95 0f0c 	teqne	r5, ip
 800aa48:	f000 f8de 	bleq	800ac08 <__aeabi_dmul+0x1dc>
 800aa4c:	442c      	add	r4, r5
 800aa4e:	ea81 0603 	eor.w	r6, r1, r3
 800aa52:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800aa56:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800aa5a:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800aa5e:	bf18      	it	ne
 800aa60:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 800aa64:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800aa68:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800aa6c:	d038      	beq.n	800aae0 <__aeabi_dmul+0xb4>
 800aa6e:	fba0 ce02 	umull	ip, lr, r0, r2
 800aa72:	f04f 0500 	mov.w	r5, #0
 800aa76:	fbe1 e502 	umlal	lr, r5, r1, r2
 800aa7a:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800aa7e:	fbe0 e503 	umlal	lr, r5, r0, r3
 800aa82:	f04f 0600 	mov.w	r6, #0
 800aa86:	fbe1 5603 	umlal	r5, r6, r1, r3
 800aa8a:	f09c 0f00 	teq	ip, #0
 800aa8e:	bf18      	it	ne
 800aa90:	f04e 0e01 	orrne.w	lr, lr, #1
 800aa94:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800aa98:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 800aa9c:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 800aaa0:	d204      	bcs.n	800aaac <__aeabi_dmul+0x80>
 800aaa2:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800aaa6:	416d      	adcs	r5, r5
 800aaa8:	eb46 0606 	adc.w	r6, r6, r6
 800aaac:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800aab0:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 800aab4:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800aab8:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 800aabc:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800aac0:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800aac4:	bf88      	it	hi
 800aac6:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800aaca:	d81e      	bhi.n	800ab0a <__aeabi_dmul+0xde>
 800aacc:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 800aad0:	bf08      	it	eq
 800aad2:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800aad6:	f150 0000 	adcs.w	r0, r0, #0
 800aada:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800aade:	bd70      	pop	{r4, r5, r6, pc}
 800aae0:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 800aae4:	ea46 0101 	orr.w	r1, r6, r1
 800aae8:	ea40 0002 	orr.w	r0, r0, r2
 800aaec:	ea81 0103 	eor.w	r1, r1, r3
 800aaf0:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 800aaf4:	bfc2      	ittt	gt
 800aaf6:	ebd4 050c 	rsbsgt	r5, r4, ip
 800aafa:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800aafe:	bd70      	popgt	{r4, r5, r6, pc}
 800ab00:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800ab04:	f04f 0e00 	mov.w	lr, #0
 800ab08:	3c01      	subs	r4, #1
 800ab0a:	f300 80ab 	bgt.w	800ac64 <__aeabi_dmul+0x238>
 800ab0e:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800ab12:	bfde      	ittt	le
 800ab14:	2000      	movle	r0, #0
 800ab16:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800ab1a:	bd70      	pople	{r4, r5, r6, pc}
 800ab1c:	f1c4 0400 	rsb	r4, r4, #0
 800ab20:	3c20      	subs	r4, #32
 800ab22:	da35      	bge.n	800ab90 <__aeabi_dmul+0x164>
 800ab24:	340c      	adds	r4, #12
 800ab26:	dc1b      	bgt.n	800ab60 <__aeabi_dmul+0x134>
 800ab28:	f104 0414 	add.w	r4, r4, #20
 800ab2c:	f1c4 0520 	rsb	r5, r4, #32
 800ab30:	fa00 f305 	lsl.w	r3, r0, r5
 800ab34:	fa20 f004 	lsr.w	r0, r0, r4
 800ab38:	fa01 f205 	lsl.w	r2, r1, r5
 800ab3c:	ea40 0002 	orr.w	r0, r0, r2
 800ab40:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 800ab44:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800ab48:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800ab4c:	fa21 f604 	lsr.w	r6, r1, r4
 800ab50:	eb42 0106 	adc.w	r1, r2, r6
 800ab54:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800ab58:	bf08      	it	eq
 800ab5a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800ab5e:	bd70      	pop	{r4, r5, r6, pc}
 800ab60:	f1c4 040c 	rsb	r4, r4, #12
 800ab64:	f1c4 0520 	rsb	r5, r4, #32
 800ab68:	fa00 f304 	lsl.w	r3, r0, r4
 800ab6c:	fa20 f005 	lsr.w	r0, r0, r5
 800ab70:	fa01 f204 	lsl.w	r2, r1, r4
 800ab74:	ea40 0002 	orr.w	r0, r0, r2
 800ab78:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800ab7c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800ab80:	f141 0100 	adc.w	r1, r1, #0
 800ab84:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800ab88:	bf08      	it	eq
 800ab8a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800ab8e:	bd70      	pop	{r4, r5, r6, pc}
 800ab90:	f1c4 0520 	rsb	r5, r4, #32
 800ab94:	fa00 f205 	lsl.w	r2, r0, r5
 800ab98:	ea4e 0e02 	orr.w	lr, lr, r2
 800ab9c:	fa20 f304 	lsr.w	r3, r0, r4
 800aba0:	fa01 f205 	lsl.w	r2, r1, r5
 800aba4:	ea43 0302 	orr.w	r3, r3, r2
 800aba8:	fa21 f004 	lsr.w	r0, r1, r4
 800abac:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800abb0:	fa21 f204 	lsr.w	r2, r1, r4
 800abb4:	ea20 0002 	bic.w	r0, r0, r2
 800abb8:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 800abbc:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800abc0:	bf08      	it	eq
 800abc2:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800abc6:	bd70      	pop	{r4, r5, r6, pc}
 800abc8:	f094 0f00 	teq	r4, #0
 800abcc:	d10f      	bne.n	800abee <__aeabi_dmul+0x1c2>
 800abce:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800abd2:	0040      	lsls	r0, r0, #1
 800abd4:	eb41 0101 	adc.w	r1, r1, r1
 800abd8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800abdc:	bf08      	it	eq
 800abde:	3c01      	subeq	r4, #1
 800abe0:	d0f7      	beq.n	800abd2 <__aeabi_dmul+0x1a6>
 800abe2:	ea41 0106 	orr.w	r1, r1, r6
 800abe6:	f095 0f00 	teq	r5, #0
 800abea:	bf18      	it	ne
 800abec:	4770      	bxne	lr
 800abee:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800abf2:	0052      	lsls	r2, r2, #1
 800abf4:	eb43 0303 	adc.w	r3, r3, r3
 800abf8:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800abfc:	bf08      	it	eq
 800abfe:	3d01      	subeq	r5, #1
 800ac00:	d0f7      	beq.n	800abf2 <__aeabi_dmul+0x1c6>
 800ac02:	ea43 0306 	orr.w	r3, r3, r6
 800ac06:	4770      	bx	lr
 800ac08:	ea94 0f0c 	teq	r4, ip
 800ac0c:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800ac10:	bf18      	it	ne
 800ac12:	ea95 0f0c 	teqne	r5, ip
 800ac16:	d00c      	beq.n	800ac32 <__aeabi_dmul+0x206>
 800ac18:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800ac1c:	bf18      	it	ne
 800ac1e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800ac22:	d1d1      	bne.n	800abc8 <__aeabi_dmul+0x19c>
 800ac24:	ea81 0103 	eor.w	r1, r1, r3
 800ac28:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800ac2c:	f04f 0000 	mov.w	r0, #0
 800ac30:	bd70      	pop	{r4, r5, r6, pc}
 800ac32:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800ac36:	bf06      	itte	eq
 800ac38:	4610      	moveq	r0, r2
 800ac3a:	4619      	moveq	r1, r3
 800ac3c:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800ac40:	d019      	beq.n	800ac76 <__aeabi_dmul+0x24a>
 800ac42:	ea94 0f0c 	teq	r4, ip
 800ac46:	d102      	bne.n	800ac4e <__aeabi_dmul+0x222>
 800ac48:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 800ac4c:	d113      	bne.n	800ac76 <__aeabi_dmul+0x24a>
 800ac4e:	ea95 0f0c 	teq	r5, ip
 800ac52:	d105      	bne.n	800ac60 <__aeabi_dmul+0x234>
 800ac54:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800ac58:	bf1c      	itt	ne
 800ac5a:	4610      	movne	r0, r2
 800ac5c:	4619      	movne	r1, r3
 800ac5e:	d10a      	bne.n	800ac76 <__aeabi_dmul+0x24a>
 800ac60:	ea81 0103 	eor.w	r1, r1, r3
 800ac64:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800ac68:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800ac6c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800ac70:	f04f 0000 	mov.w	r0, #0
 800ac74:	bd70      	pop	{r4, r5, r6, pc}
 800ac76:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800ac7a:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800ac7e:	bd70      	pop	{r4, r5, r6, pc}

0800ac80 <__aeabi_ddiv>:
 800ac80:	b570      	push	{r4, r5, r6, lr}
 800ac82:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800ac86:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800ac8a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800ac8e:	bf1d      	ittte	ne
 800ac90:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800ac94:	ea94 0f0c 	teqne	r4, ip
 800ac98:	ea95 0f0c 	teqne	r5, ip
 800ac9c:	f000 f8a7 	bleq	800adee <__aeabi_ddiv+0x16e>
 800aca0:	eba4 0405 	sub.w	r4, r4, r5
 800aca4:	ea81 0e03 	eor.w	lr, r1, r3
 800aca8:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800acac:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800acb0:	f000 8088 	beq.w	800adc4 <__aeabi_ddiv+0x144>
 800acb4:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800acb8:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800acbc:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800acc0:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800acc4:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800acc8:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 800accc:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800acd0:	ea4f 2600 	mov.w	r6, r0, lsl #8
 800acd4:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800acd8:	429d      	cmp	r5, r3
 800acda:	bf08      	it	eq
 800acdc:	4296      	cmpeq	r6, r2
 800acde:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 800ace2:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800ace6:	d202      	bcs.n	800acee <__aeabi_ddiv+0x6e>
 800ace8:	085b      	lsrs	r3, r3, #1
 800acea:	ea4f 0232 	mov.w	r2, r2, rrx
 800acee:	1ab6      	subs	r6, r6, r2
 800acf0:	eb65 0503 	sbc.w	r5, r5, r3
 800acf4:	085b      	lsrs	r3, r3, #1
 800acf6:	ea4f 0232 	mov.w	r2, r2, rrx
 800acfa:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800acfe:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800ad02:	ebb6 0e02 	subs.w	lr, r6, r2
 800ad06:	eb75 0e03 	sbcs.w	lr, r5, r3
 800ad0a:	bf22      	ittt	cs
 800ad0c:	1ab6      	subcs	r6, r6, r2
 800ad0e:	4675      	movcs	r5, lr
 800ad10:	ea40 000c 	orrcs.w	r0, r0, ip
 800ad14:	085b      	lsrs	r3, r3, #1
 800ad16:	ea4f 0232 	mov.w	r2, r2, rrx
 800ad1a:	ebb6 0e02 	subs.w	lr, r6, r2
 800ad1e:	eb75 0e03 	sbcs.w	lr, r5, r3
 800ad22:	bf22      	ittt	cs
 800ad24:	1ab6      	subcs	r6, r6, r2
 800ad26:	4675      	movcs	r5, lr
 800ad28:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 800ad2c:	085b      	lsrs	r3, r3, #1
 800ad2e:	ea4f 0232 	mov.w	r2, r2, rrx
 800ad32:	ebb6 0e02 	subs.w	lr, r6, r2
 800ad36:	eb75 0e03 	sbcs.w	lr, r5, r3
 800ad3a:	bf22      	ittt	cs
 800ad3c:	1ab6      	subcs	r6, r6, r2
 800ad3e:	4675      	movcs	r5, lr
 800ad40:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 800ad44:	085b      	lsrs	r3, r3, #1
 800ad46:	ea4f 0232 	mov.w	r2, r2, rrx
 800ad4a:	ebb6 0e02 	subs.w	lr, r6, r2
 800ad4e:	eb75 0e03 	sbcs.w	lr, r5, r3
 800ad52:	bf22      	ittt	cs
 800ad54:	1ab6      	subcs	r6, r6, r2
 800ad56:	4675      	movcs	r5, lr
 800ad58:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 800ad5c:	ea55 0e06 	orrs.w	lr, r5, r6
 800ad60:	d018      	beq.n	800ad94 <__aeabi_ddiv+0x114>
 800ad62:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800ad66:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800ad6a:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800ad6e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800ad72:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800ad76:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800ad7a:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800ad7e:	d1c0      	bne.n	800ad02 <__aeabi_ddiv+0x82>
 800ad80:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800ad84:	d10b      	bne.n	800ad9e <__aeabi_ddiv+0x11e>
 800ad86:	ea41 0100 	orr.w	r1, r1, r0
 800ad8a:	f04f 0000 	mov.w	r0, #0
 800ad8e:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800ad92:	e7b6      	b.n	800ad02 <__aeabi_ddiv+0x82>
 800ad94:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800ad98:	bf04      	itt	eq
 800ad9a:	4301      	orreq	r1, r0
 800ad9c:	2000      	moveq	r0, #0
 800ad9e:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800ada2:	bf88      	it	hi
 800ada4:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800ada8:	f63f aeaf 	bhi.w	800ab0a <__aeabi_dmul+0xde>
 800adac:	ebb5 0c03 	subs.w	ip, r5, r3
 800adb0:	bf04      	itt	eq
 800adb2:	ebb6 0c02 	subseq.w	ip, r6, r2
 800adb6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800adba:	f150 0000 	adcs.w	r0, r0, #0
 800adbe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800adc2:	bd70      	pop	{r4, r5, r6, pc}
 800adc4:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800adc8:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 800adcc:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 800add0:	bfc2      	ittt	gt
 800add2:	ebd4 050c 	rsbsgt	r5, r4, ip
 800add6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800adda:	bd70      	popgt	{r4, r5, r6, pc}
 800addc:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800ade0:	f04f 0e00 	mov.w	lr, #0
 800ade4:	3c01      	subs	r4, #1
 800ade6:	e690      	b.n	800ab0a <__aeabi_dmul+0xde>
 800ade8:	ea45 0e06 	orr.w	lr, r5, r6
 800adec:	e68d      	b.n	800ab0a <__aeabi_dmul+0xde>
 800adee:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800adf2:	ea94 0f0c 	teq	r4, ip
 800adf6:	bf08      	it	eq
 800adf8:	ea95 0f0c 	teqeq	r5, ip
 800adfc:	f43f af3b 	beq.w	800ac76 <__aeabi_dmul+0x24a>
 800ae00:	ea94 0f0c 	teq	r4, ip
 800ae04:	d10a      	bne.n	800ae1c <__aeabi_ddiv+0x19c>
 800ae06:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800ae0a:	f47f af34 	bne.w	800ac76 <__aeabi_dmul+0x24a>
 800ae0e:	ea95 0f0c 	teq	r5, ip
 800ae12:	f47f af25 	bne.w	800ac60 <__aeabi_dmul+0x234>
 800ae16:	4610      	mov	r0, r2
 800ae18:	4619      	mov	r1, r3
 800ae1a:	e72c      	b.n	800ac76 <__aeabi_dmul+0x24a>
 800ae1c:	ea95 0f0c 	teq	r5, ip
 800ae20:	d106      	bne.n	800ae30 <__aeabi_ddiv+0x1b0>
 800ae22:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800ae26:	f43f aefd 	beq.w	800ac24 <__aeabi_dmul+0x1f8>
 800ae2a:	4610      	mov	r0, r2
 800ae2c:	4619      	mov	r1, r3
 800ae2e:	e722      	b.n	800ac76 <__aeabi_dmul+0x24a>
 800ae30:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800ae34:	bf18      	it	ne
 800ae36:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800ae3a:	f47f aec5 	bne.w	800abc8 <__aeabi_dmul+0x19c>
 800ae3e:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 800ae42:	f47f af0d 	bne.w	800ac60 <__aeabi_dmul+0x234>
 800ae46:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800ae4a:	f47f aeeb 	bne.w	800ac24 <__aeabi_dmul+0x1f8>
 800ae4e:	e712      	b.n	800ac76 <__aeabi_dmul+0x24a>

0800ae50 <__gedf2>:
 800ae50:	f04f 3cff 	mov.w	ip, #4294967295
 800ae54:	e006      	b.n	800ae64 <__cmpdf2+0x4>
 800ae56:	bf00      	nop

0800ae58 <__ledf2>:
 800ae58:	f04f 0c01 	mov.w	ip, #1
 800ae5c:	e002      	b.n	800ae64 <__cmpdf2+0x4>
 800ae5e:	bf00      	nop

0800ae60 <__cmpdf2>:
 800ae60:	f04f 0c01 	mov.w	ip, #1
 800ae64:	f84d cd04 	str.w	ip, [sp, #-4]!
 800ae68:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800ae6c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800ae70:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800ae74:	bf18      	it	ne
 800ae76:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 800ae7a:	d01b      	beq.n	800aeb4 <__cmpdf2+0x54>
 800ae7c:	b001      	add	sp, #4
 800ae7e:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 800ae82:	bf0c      	ite	eq
 800ae84:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 800ae88:	ea91 0f03 	teqne	r1, r3
 800ae8c:	bf02      	ittt	eq
 800ae8e:	ea90 0f02 	teqeq	r0, r2
 800ae92:	2000      	moveq	r0, #0
 800ae94:	4770      	bxeq	lr
 800ae96:	f110 0f00 	cmn.w	r0, #0
 800ae9a:	ea91 0f03 	teq	r1, r3
 800ae9e:	bf58      	it	pl
 800aea0:	4299      	cmppl	r1, r3
 800aea2:	bf08      	it	eq
 800aea4:	4290      	cmpeq	r0, r2
 800aea6:	bf2c      	ite	cs
 800aea8:	17d8      	asrcs	r0, r3, #31
 800aeaa:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 800aeae:	f040 0001 	orr.w	r0, r0, #1
 800aeb2:	4770      	bx	lr
 800aeb4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800aeb8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800aebc:	d102      	bne.n	800aec4 <__cmpdf2+0x64>
 800aebe:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800aec2:	d107      	bne.n	800aed4 <__cmpdf2+0x74>
 800aec4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800aec8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800aecc:	d1d6      	bne.n	800ae7c <__cmpdf2+0x1c>
 800aece:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800aed2:	d0d3      	beq.n	800ae7c <__cmpdf2+0x1c>
 800aed4:	f85d 0b04 	ldr.w	r0, [sp], #4
 800aed8:	4770      	bx	lr
 800aeda:	bf00      	nop

0800aedc <__aeabi_cdrcmple>:
 800aedc:	4684      	mov	ip, r0
 800aede:	4610      	mov	r0, r2
 800aee0:	4662      	mov	r2, ip
 800aee2:	468c      	mov	ip, r1
 800aee4:	4619      	mov	r1, r3
 800aee6:	4663      	mov	r3, ip
 800aee8:	e000      	b.n	800aeec <__aeabi_cdcmpeq>
 800aeea:	bf00      	nop

0800aeec <__aeabi_cdcmpeq>:
 800aeec:	b501      	push	{r0, lr}
 800aeee:	f7ff ffb7 	bl	800ae60 <__cmpdf2>
 800aef2:	2800      	cmp	r0, #0
 800aef4:	bf48      	it	mi
 800aef6:	f110 0f00 	cmnmi.w	r0, #0
 800aefa:	bd01      	pop	{r0, pc}

0800aefc <__aeabi_dcmpeq>:
 800aefc:	f84d ed08 	str.w	lr, [sp, #-8]!
 800af00:	f7ff fff4 	bl	800aeec <__aeabi_cdcmpeq>
 800af04:	bf0c      	ite	eq
 800af06:	2001      	moveq	r0, #1
 800af08:	2000      	movne	r0, #0
 800af0a:	f85d fb08 	ldr.w	pc, [sp], #8
 800af0e:	bf00      	nop

0800af10 <__aeabi_dcmplt>:
 800af10:	f84d ed08 	str.w	lr, [sp, #-8]!
 800af14:	f7ff ffea 	bl	800aeec <__aeabi_cdcmpeq>
 800af18:	bf34      	ite	cc
 800af1a:	2001      	movcc	r0, #1
 800af1c:	2000      	movcs	r0, #0
 800af1e:	f85d fb08 	ldr.w	pc, [sp], #8
 800af22:	bf00      	nop

0800af24 <__aeabi_dcmple>:
 800af24:	f84d ed08 	str.w	lr, [sp, #-8]!
 800af28:	f7ff ffe0 	bl	800aeec <__aeabi_cdcmpeq>
 800af2c:	bf94      	ite	ls
 800af2e:	2001      	movls	r0, #1
 800af30:	2000      	movhi	r0, #0
 800af32:	f85d fb08 	ldr.w	pc, [sp], #8
 800af36:	bf00      	nop

0800af38 <__aeabi_dcmpge>:
 800af38:	f84d ed08 	str.w	lr, [sp, #-8]!
 800af3c:	f7ff ffce 	bl	800aedc <__aeabi_cdrcmple>
 800af40:	bf94      	ite	ls
 800af42:	2001      	movls	r0, #1
 800af44:	2000      	movhi	r0, #0
 800af46:	f85d fb08 	ldr.w	pc, [sp], #8
 800af4a:	bf00      	nop

0800af4c <__aeabi_dcmpgt>:
 800af4c:	f84d ed08 	str.w	lr, [sp, #-8]!
 800af50:	f7ff ffc4 	bl	800aedc <__aeabi_cdrcmple>
 800af54:	bf34      	ite	cc
 800af56:	2001      	movcc	r0, #1
 800af58:	2000      	movcs	r0, #0
 800af5a:	f85d fb08 	ldr.w	pc, [sp], #8
 800af5e:	bf00      	nop

0800af60 <__aeabi_d2iz>:
 800af60:	ea4f 0241 	mov.w	r2, r1, lsl #1
 800af64:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 800af68:	d215      	bcs.n	800af96 <__aeabi_d2iz+0x36>
 800af6a:	d511      	bpl.n	800af90 <__aeabi_d2iz+0x30>
 800af6c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 800af70:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 800af74:	d912      	bls.n	800af9c <__aeabi_d2iz+0x3c>
 800af76:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800af7a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800af7e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 800af82:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800af86:	fa23 f002 	lsr.w	r0, r3, r2
 800af8a:	bf18      	it	ne
 800af8c:	4240      	negne	r0, r0
 800af8e:	4770      	bx	lr
 800af90:	f04f 0000 	mov.w	r0, #0
 800af94:	4770      	bx	lr
 800af96:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 800af9a:	d105      	bne.n	800afa8 <__aeabi_d2iz+0x48>
 800af9c:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 800afa0:	bf08      	it	eq
 800afa2:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 800afa6:	4770      	bx	lr
 800afa8:	f04f 0000 	mov.w	r0, #0
 800afac:	4770      	bx	lr
 800afae:	bf00      	nop

0800afb0 <__aeabi_uldivmod>:
 800afb0:	b94b      	cbnz	r3, 800afc6 <__aeabi_uldivmod+0x16>
 800afb2:	b942      	cbnz	r2, 800afc6 <__aeabi_uldivmod+0x16>
 800afb4:	2900      	cmp	r1, #0
 800afb6:	bf08      	it	eq
 800afb8:	2800      	cmpeq	r0, #0
 800afba:	d002      	beq.n	800afc2 <__aeabi_uldivmod+0x12>
 800afbc:	f04f 31ff 	mov.w	r1, #4294967295
 800afc0:	4608      	mov	r0, r1
 800afc2:	f7ff bb79 	b.w	800a6b8 <__aeabi_idiv0>
 800afc6:	b082      	sub	sp, #8
 800afc8:	46ec      	mov	ip, sp
 800afca:	e92d 5000 	stmdb	sp!, {ip, lr}
 800afce:	f000 f81d 	bl	800b00c <__gnu_uldivmod_helper>
 800afd2:	f8dd e004 	ldr.w	lr, [sp, #4]
 800afd6:	b002      	add	sp, #8
 800afd8:	bc0c      	pop	{r2, r3}
 800afda:	4770      	bx	lr

0800afdc <__gnu_ldivmod_helper>:
 800afdc:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 800afe0:	4616      	mov	r6, r2
 800afe2:	4680      	mov	r8, r0
 800afe4:	4689      	mov	r9, r1
 800afe6:	461d      	mov	r5, r3
 800afe8:	f000 f828 	bl	800b03c <__divdi3>
 800afec:	fb00 f305 	mul.w	r3, r0, r5
 800aff0:	fba0 4506 	umull	r4, r5, r0, r6
 800aff4:	fb06 3601 	mla	r6, r6, r1, r3
 800aff8:	9b06      	ldr	r3, [sp, #24]
 800affa:	1975      	adds	r5, r6, r5
 800affc:	ebb8 0404 	subs.w	r4, r8, r4
 800b000:	eb69 0505 	sbc.w	r5, r9, r5
 800b004:	e9c3 4500 	strd	r4, r5, [r3]
 800b008:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

0800b00c <__gnu_uldivmod_helper>:
 800b00c:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 800b010:	4616      	mov	r6, r2
 800b012:	4680      	mov	r8, r0
 800b014:	4689      	mov	r9, r1
 800b016:	461d      	mov	r5, r3
 800b018:	f000 f9c0 	bl	800b39c <__udivdi3>
 800b01c:	fb00 f305 	mul.w	r3, r0, r5
 800b020:	fba0 4506 	umull	r4, r5, r0, r6
 800b024:	fb06 3601 	mla	r6, r6, r1, r3
 800b028:	9b06      	ldr	r3, [sp, #24]
 800b02a:	1975      	adds	r5, r6, r5
 800b02c:	ebb8 0404 	subs.w	r4, r8, r4
 800b030:	eb69 0505 	sbc.w	r5, r9, r5
 800b034:	e9c3 4500 	strd	r4, r5, [r3]
 800b038:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

0800b03c <__divdi3>:
 800b03c:	2900      	cmp	r1, #0
 800b03e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b042:	461c      	mov	r4, r3
 800b044:	b085      	sub	sp, #20
 800b046:	f2c0 80cb 	blt.w	800b1e0 <__divdi3+0x1a4>
 800b04a:	2600      	movs	r6, #0
 800b04c:	2c00      	cmp	r4, #0
 800b04e:	f2c0 80c2 	blt.w	800b1d6 <__divdi3+0x19a>
 800b052:	468c      	mov	ip, r1
 800b054:	4617      	mov	r7, r2
 800b056:	4614      	mov	r4, r2
 800b058:	4605      	mov	r5, r0
 800b05a:	4688      	mov	r8, r1
 800b05c:	469a      	mov	sl, r3
 800b05e:	2b00      	cmp	r3, #0
 800b060:	d14a      	bne.n	800b0f8 <__divdi3+0xbc>
 800b062:	428a      	cmp	r2, r1
 800b064:	d96e      	bls.n	800b144 <__divdi3+0x108>
 800b066:	fab2 f382 	clz	r3, r2
 800b06a:	b15b      	cbz	r3, 800b084 <__divdi3+0x48>
 800b06c:	f1c3 0420 	rsb	r4, r3, #32
 800b070:	fa01 f803 	lsl.w	r8, r1, r3
 800b074:	fa30 f204 	lsrs.w	r2, r0, r4
 800b078:	fa10 f503 	lsls.w	r5, r0, r3
 800b07c:	fa17 f403 	lsls.w	r4, r7, r3
 800b080:	ea42 0808 	orr.w	r8, r2, r8
 800b084:	ea4f 4a14 	mov.w	sl, r4, lsr #16
 800b088:	4640      	mov	r0, r8
 800b08a:	4651      	mov	r1, sl
 800b08c:	fa1f fb84 	uxth.w	fp, r4
 800b090:	f7ff f9d6 	bl	800a440 <__aeabi_uidiv>
 800b094:	4651      	mov	r1, sl
 800b096:	4681      	mov	r9, r0
 800b098:	4640      	mov	r0, r8
 800b09a:	f7ff faff 	bl	800a69c <__aeabi_uidivmod>
 800b09e:	0c28      	lsrs	r0, r5, #16
 800b0a0:	fb0b f309 	mul.w	r3, fp, r9
 800b0a4:	ea40 4801 	orr.w	r8, r0, r1, lsl #16
 800b0a8:	4543      	cmp	r3, r8
 800b0aa:	d909      	bls.n	800b0c0 <__divdi3+0x84>
 800b0ac:	eb18 0804 	adds.w	r8, r8, r4
 800b0b0:	f109 39ff 	add.w	r9, r9, #4294967295
 800b0b4:	d204      	bcs.n	800b0c0 <__divdi3+0x84>
 800b0b6:	4543      	cmp	r3, r8
 800b0b8:	bf84      	itt	hi
 800b0ba:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800b0be:	44a0      	addhi	r8, r4
 800b0c0:	ebc3 0808 	rsb	r8, r3, r8
 800b0c4:	4651      	mov	r1, sl
 800b0c6:	4640      	mov	r0, r8
 800b0c8:	b2ad      	uxth	r5, r5
 800b0ca:	f7ff f9b9 	bl	800a440 <__aeabi_uidiv>
 800b0ce:	4651      	mov	r1, sl
 800b0d0:	4607      	mov	r7, r0
 800b0d2:	4640      	mov	r0, r8
 800b0d4:	f7ff fae2 	bl	800a69c <__aeabi_uidivmod>
 800b0d8:	fb0b fb07 	mul.w	fp, fp, r7
 800b0dc:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
 800b0e0:	45ab      	cmp	fp, r5
 800b0e2:	d905      	bls.n	800b0f0 <__divdi3+0xb4>
 800b0e4:	3f01      	subs	r7, #1
 800b0e6:	192d      	adds	r5, r5, r4
 800b0e8:	d202      	bcs.n	800b0f0 <__divdi3+0xb4>
 800b0ea:	45ab      	cmp	fp, r5
 800b0ec:	bf88      	it	hi
 800b0ee:	3f01      	subhi	r7, #1
 800b0f0:	ea47 4909 	orr.w	r9, r7, r9, lsl #16
 800b0f4:	2400      	movs	r4, #0
 800b0f6:	e003      	b.n	800b100 <__divdi3+0xc4>
 800b0f8:	428b      	cmp	r3, r1
 800b0fa:	d90c      	bls.n	800b116 <__divdi3+0xda>
 800b0fc:	2400      	movs	r4, #0
 800b0fe:	46a1      	mov	r9, r4
 800b100:	464a      	mov	r2, r9
 800b102:	4623      	mov	r3, r4
 800b104:	b116      	cbz	r6, 800b10c <__divdi3+0xd0>
 800b106:	4252      	negs	r2, r2
 800b108:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800b10c:	4610      	mov	r0, r2
 800b10e:	4619      	mov	r1, r3
 800b110:	b005      	add	sp, #20
 800b112:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b116:	fab3 f483 	clz	r4, r3
 800b11a:	2c00      	cmp	r4, #0
 800b11c:	f040 80b3 	bne.w	800b286 <__divdi3+0x24a>
 800b120:	428b      	cmp	r3, r1
 800b122:	f04f 0901 	mov.w	r9, #1
 800b126:	bf2c      	ite	cs
 800b128:	f04f 0c00 	movcs.w	ip, #0
 800b12c:	f04f 0c01 	movcc.w	ip, #1
 800b130:	4282      	cmp	r2, r0
 800b132:	bf8c      	ite	hi
 800b134:	4667      	movhi	r7, ip
 800b136:	f04c 0701 	orrls.w	r7, ip, #1
 800b13a:	2f00      	cmp	r7, #0
 800b13c:	d1e0      	bne.n	800b100 <__divdi3+0xc4>
 800b13e:	463c      	mov	r4, r7
 800b140:	46b9      	mov	r9, r7
 800b142:	e7dd      	b.n	800b100 <__divdi3+0xc4>
 800b144:	b922      	cbnz	r2, 800b150 <__divdi3+0x114>
 800b146:	2001      	movs	r0, #1
 800b148:	4611      	mov	r1, r2
 800b14a:	f7ff f979 	bl	800a440 <__aeabi_uidiv>
 800b14e:	4604      	mov	r4, r0
 800b150:	fab4 f384 	clz	r3, r4
 800b154:	2b00      	cmp	r3, #0
 800b156:	d149      	bne.n	800b1ec <__divdi3+0x1b0>
 800b158:	ebc4 0808 	rsb	r8, r4, r8
 800b15c:	0c27      	lsrs	r7, r4, #16
 800b15e:	fa1f fa84 	uxth.w	sl, r4
 800b162:	2101      	movs	r1, #1
 800b164:	9102      	str	r1, [sp, #8]
 800b166:	4639      	mov	r1, r7
 800b168:	4640      	mov	r0, r8
 800b16a:	f7ff f969 	bl	800a440 <__aeabi_uidiv>
 800b16e:	4639      	mov	r1, r7
 800b170:	4681      	mov	r9, r0
 800b172:	4640      	mov	r0, r8
 800b174:	f7ff fa92 	bl	800a69c <__aeabi_uidivmod>
 800b178:	0c2a      	lsrs	r2, r5, #16
 800b17a:	fb0a f309 	mul.w	r3, sl, r9
 800b17e:	ea42 4b01 	orr.w	fp, r2, r1, lsl #16
 800b182:	455b      	cmp	r3, fp
 800b184:	d909      	bls.n	800b19a <__divdi3+0x15e>
 800b186:	eb1b 0b04 	adds.w	fp, fp, r4
 800b18a:	f109 39ff 	add.w	r9, r9, #4294967295
 800b18e:	d204      	bcs.n	800b19a <__divdi3+0x15e>
 800b190:	455b      	cmp	r3, fp
 800b192:	bf84      	itt	hi
 800b194:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800b198:	44a3      	addhi	fp, r4
 800b19a:	ebc3 0b0b 	rsb	fp, r3, fp
 800b19e:	4639      	mov	r1, r7
 800b1a0:	4658      	mov	r0, fp
 800b1a2:	b2ad      	uxth	r5, r5
 800b1a4:	f7ff f94c 	bl	800a440 <__aeabi_uidiv>
 800b1a8:	4639      	mov	r1, r7
 800b1aa:	4680      	mov	r8, r0
 800b1ac:	4658      	mov	r0, fp
 800b1ae:	f7ff fa75 	bl	800a69c <__aeabi_uidivmod>
 800b1b2:	fb0a fa08 	mul.w	sl, sl, r8
 800b1b6:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
 800b1ba:	45aa      	cmp	sl, r5
 800b1bc:	d907      	bls.n	800b1ce <__divdi3+0x192>
 800b1be:	192d      	adds	r5, r5, r4
 800b1c0:	f108 38ff 	add.w	r8, r8, #4294967295
 800b1c4:	d203      	bcs.n	800b1ce <__divdi3+0x192>
 800b1c6:	45aa      	cmp	sl, r5
 800b1c8:	bf88      	it	hi
 800b1ca:	f108 38ff 	addhi.w	r8, r8, #4294967295
 800b1ce:	ea48 4909 	orr.w	r9, r8, r9, lsl #16
 800b1d2:	9c02      	ldr	r4, [sp, #8]
 800b1d4:	e794      	b.n	800b100 <__divdi3+0xc4>
 800b1d6:	43f6      	mvns	r6, r6
 800b1d8:	4252      	negs	r2, r2
 800b1da:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800b1de:	e738      	b.n	800b052 <__divdi3+0x16>
 800b1e0:	4240      	negs	r0, r0
 800b1e2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800b1e6:	f04f 36ff 	mov.w	r6, #4294967295
 800b1ea:	e72f      	b.n	800b04c <__divdi3+0x10>
 800b1ec:	409c      	lsls	r4, r3
 800b1ee:	f1c3 0720 	rsb	r7, r3, #32
 800b1f2:	fa28 fa07 	lsr.w	sl, r8, r7
 800b1f6:	fa35 f207 	lsrs.w	r2, r5, r7
 800b1fa:	0c27      	lsrs	r7, r4, #16
 800b1fc:	fa08 fb03 	lsl.w	fp, r8, r3
 800b200:	4639      	mov	r1, r7
 800b202:	4650      	mov	r0, sl
 800b204:	ea42 020b 	orr.w	r2, r2, fp
 800b208:	409d      	lsls	r5, r3
 800b20a:	9202      	str	r2, [sp, #8]
 800b20c:	f7ff f918 	bl	800a440 <__aeabi_uidiv>
 800b210:	4639      	mov	r1, r7
 800b212:	4683      	mov	fp, r0
 800b214:	4650      	mov	r0, sl
 800b216:	f7ff fa41 	bl	800a69c <__aeabi_uidivmod>
 800b21a:	9b02      	ldr	r3, [sp, #8]
 800b21c:	fa1f fa84 	uxth.w	sl, r4
 800b220:	ea4f 4913 	mov.w	r9, r3, lsr #16
 800b224:	fb0a f30b 	mul.w	r3, sl, fp
 800b228:	ea49 4801 	orr.w	r8, r9, r1, lsl #16
 800b22c:	4543      	cmp	r3, r8
 800b22e:	d905      	bls.n	800b23c <__divdi3+0x200>
 800b230:	eb18 0804 	adds.w	r8, r8, r4
 800b234:	f10b 3bff 	add.w	fp, fp, #4294967295
 800b238:	f0c0 80aa 	bcc.w	800b390 <__divdi3+0x354>
 800b23c:	ebc3 0808 	rsb	r8, r3, r8
 800b240:	4639      	mov	r1, r7
 800b242:	4640      	mov	r0, r8
 800b244:	f7ff f8fc 	bl	800a440 <__aeabi_uidiv>
 800b248:	4639      	mov	r1, r7
 800b24a:	4681      	mov	r9, r0
 800b24c:	4640      	mov	r0, r8
 800b24e:	f7ff fa25 	bl	800a69c <__aeabi_uidivmod>
 800b252:	9802      	ldr	r0, [sp, #8]
 800b254:	fb0a f309 	mul.w	r3, sl, r9
 800b258:	fa1f fc80 	uxth.w	ip, r0
 800b25c:	ea4c 4801 	orr.w	r8, ip, r1, lsl #16
 800b260:	4543      	cmp	r3, r8
 800b262:	d909      	bls.n	800b278 <__divdi3+0x23c>
 800b264:	eb18 0804 	adds.w	r8, r8, r4
 800b268:	f109 39ff 	add.w	r9, r9, #4294967295
 800b26c:	d204      	bcs.n	800b278 <__divdi3+0x23c>
 800b26e:	4543      	cmp	r3, r8
 800b270:	bf84      	itt	hi
 800b272:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800b276:	44a0      	addhi	r8, r4
 800b278:	ea49 4e0b 	orr.w	lr, r9, fp, lsl #16
 800b27c:	ebc3 0808 	rsb	r8, r3, r8
 800b280:	f8cd e008 	str.w	lr, [sp, #8]
 800b284:	e76f      	b.n	800b166 <__divdi3+0x12a>
 800b286:	f1c4 0320 	rsb	r3, r4, #32
 800b28a:	fa0a fa04 	lsl.w	sl, sl, r4
 800b28e:	40da      	lsrs	r2, r3
 800b290:	fa21 f803 	lsr.w	r8, r1, r3
 800b294:	ea42 0a0a 	orr.w	sl, r2, sl
 800b298:	fa01 f904 	lsl.w	r9, r1, r4
 800b29c:	fa30 f203 	lsrs.w	r2, r0, r3
 800b2a0:	4640      	mov	r0, r8
 800b2a2:	ea4f 4b1a 	mov.w	fp, sl, lsr #16
 800b2a6:	ea42 0109 	orr.w	r1, r2, r9
 800b2aa:	9103      	str	r1, [sp, #12]
 800b2ac:	4659      	mov	r1, fp
 800b2ae:	fa17 f304 	lsls.w	r3, r7, r4
 800b2b2:	9302      	str	r3, [sp, #8]
 800b2b4:	f7ff f8c4 	bl	800a440 <__aeabi_uidiv>
 800b2b8:	4659      	mov	r1, fp
 800b2ba:	4681      	mov	r9, r0
 800b2bc:	4640      	mov	r0, r8
 800b2be:	f7ff f9ed 	bl	800a69c <__aeabi_uidivmod>
 800b2c2:	fa1f f38a 	uxth.w	r3, sl
 800b2c6:	9803      	ldr	r0, [sp, #12]
 800b2c8:	fb03 f209 	mul.w	r2, r3, r9
 800b2cc:	0c07      	lsrs	r7, r0, #16
 800b2ce:	ea47 4801 	orr.w	r8, r7, r1, lsl #16
 800b2d2:	4542      	cmp	r2, r8
 800b2d4:	d904      	bls.n	800b2e0 <__divdi3+0x2a4>
 800b2d6:	eb18 080a 	adds.w	r8, r8, sl
 800b2da:	f109 39ff 	add.w	r9, r9, #4294967295
 800b2de:	d351      	bcc.n	800b384 <__divdi3+0x348>
 800b2e0:	ebc2 0808 	rsb	r8, r2, r8
 800b2e4:	4659      	mov	r1, fp
 800b2e6:	4640      	mov	r0, r8
 800b2e8:	9301      	str	r3, [sp, #4]
 800b2ea:	f7ff f8a9 	bl	800a440 <__aeabi_uidiv>
 800b2ee:	4659      	mov	r1, fp
 800b2f0:	4607      	mov	r7, r0
 800b2f2:	4640      	mov	r0, r8
 800b2f4:	f7ff f9d2 	bl	800a69c <__aeabi_uidivmod>
 800b2f8:	9b01      	ldr	r3, [sp, #4]
 800b2fa:	9803      	ldr	r0, [sp, #12]
 800b2fc:	fb03 f307 	mul.w	r3, r3, r7
 800b300:	fa1f fc80 	uxth.w	ip, r0
 800b304:	ea4c 4c01 	orr.w	ip, ip, r1, lsl #16
 800b308:	4563      	cmp	r3, ip
 800b30a:	d907      	bls.n	800b31c <__divdi3+0x2e0>
 800b30c:	3f01      	subs	r7, #1
 800b30e:	eb1c 0c0a 	adds.w	ip, ip, sl
 800b312:	d203      	bcs.n	800b31c <__divdi3+0x2e0>
 800b314:	4563      	cmp	r3, ip
 800b316:	d901      	bls.n	800b31c <__divdi3+0x2e0>
 800b318:	3f01      	subs	r7, #1
 800b31a:	44d4      	add	ip, sl
 800b31c:	ea47 4909 	orr.w	r9, r7, r9, lsl #16
 800b320:	9f02      	ldr	r7, [sp, #8]
 800b322:	ebc3 0c0c 	rsb	ip, r3, ip
 800b326:	fa1f fe89 	uxth.w	lr, r9
 800b32a:	ea4f 4319 	mov.w	r3, r9, lsr #16
 800b32e:	b2b8      	uxth	r0, r7
 800b330:	0c3f      	lsrs	r7, r7, #16
 800b332:	fb00 f80e 	mul.w	r8, r0, lr
 800b336:	fb00 f103 	mul.w	r1, r0, r3
 800b33a:	fb07 120e 	mla	r2, r7, lr, r1
 800b33e:	fb07 f003 	mul.w	r0, r7, r3
 800b342:	eb02 4218 	add.w	r2, r2, r8, lsr #16
 800b346:	4291      	cmp	r1, r2
 800b348:	bf88      	it	hi
 800b34a:	f500 3080 	addhi.w	r0, r0, #65536	; 0x10000
 800b34e:	eb00 4e12 	add.w	lr, r0, r2, lsr #16
 800b352:	45f4      	cmp	ip, lr
 800b354:	d312      	bcc.n	800b37c <__divdi3+0x340>
 800b356:	ea4f 4202 	mov.w	r2, r2, lsl #16
 800b35a:	fa1f f888 	uxth.w	r8, r8
 800b35e:	bf14      	ite	ne
 800b360:	2100      	movne	r1, #0
 800b362:	2101      	moveq	r1, #1
 800b364:	eb02 0c08 	add.w	ip, r2, r8
 800b368:	fa15 f404 	lsls.w	r4, r5, r4
 800b36c:	4564      	cmp	r4, ip
 800b36e:	bf2c      	ite	cs
 800b370:	2400      	movcs	r4, #0
 800b372:	f001 0401 	andcc.w	r4, r1, #1
 800b376:	2c00      	cmp	r4, #0
 800b378:	f43f aec2 	beq.w	800b100 <__divdi3+0xc4>
 800b37c:	f109 39ff 	add.w	r9, r9, #4294967295
 800b380:	2400      	movs	r4, #0
 800b382:	e6bd      	b.n	800b100 <__divdi3+0xc4>
 800b384:	4542      	cmp	r2, r8
 800b386:	bf84      	itt	hi
 800b388:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800b38c:	44d0      	addhi	r8, sl
 800b38e:	e7a7      	b.n	800b2e0 <__divdi3+0x2a4>
 800b390:	4543      	cmp	r3, r8
 800b392:	bf84      	itt	hi
 800b394:	f10b 3bff 	addhi.w	fp, fp, #4294967295
 800b398:	44a0      	addhi	r8, r4
 800b39a:	e74f      	b.n	800b23c <__divdi3+0x200>

0800b39c <__udivdi3>:
 800b39c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b3a0:	4605      	mov	r5, r0
 800b3a2:	b083      	sub	sp, #12
 800b3a4:	460c      	mov	r4, r1
 800b3a6:	4617      	mov	r7, r2
 800b3a8:	4680      	mov	r8, r0
 800b3aa:	460e      	mov	r6, r1
 800b3ac:	2b00      	cmp	r3, #0
 800b3ae:	d14d      	bne.n	800b44c <__udivdi3+0xb0>
 800b3b0:	428a      	cmp	r2, r1
 800b3b2:	d961      	bls.n	800b478 <__udivdi3+0xdc>
 800b3b4:	fab2 f382 	clz	r3, r2
 800b3b8:	b153      	cbz	r3, 800b3d0 <__udivdi3+0x34>
 800b3ba:	f1c3 0420 	rsb	r4, r3, #32
 800b3be:	fa11 f603 	lsls.w	r6, r1, r3
 800b3c2:	fa30 f204 	lsrs.w	r2, r0, r4
 800b3c6:	409f      	lsls	r7, r3
 800b3c8:	ea42 0606 	orr.w	r6, r2, r6
 800b3cc:	fa00 f803 	lsl.w	r8, r0, r3
 800b3d0:	0c3c      	lsrs	r4, r7, #16
 800b3d2:	4630      	mov	r0, r6
 800b3d4:	4621      	mov	r1, r4
 800b3d6:	fa1f fa87 	uxth.w	sl, r7
 800b3da:	f7ff f831 	bl	800a440 <__aeabi_uidiv>
 800b3de:	4621      	mov	r1, r4
 800b3e0:	4681      	mov	r9, r0
 800b3e2:	4630      	mov	r0, r6
 800b3e4:	f7ff f95a 	bl	800a69c <__aeabi_uidivmod>
 800b3e8:	ea4f 4018 	mov.w	r0, r8, lsr #16
 800b3ec:	fb0a f309 	mul.w	r3, sl, r9
 800b3f0:	ea40 4601 	orr.w	r6, r0, r1, lsl #16
 800b3f4:	42b3      	cmp	r3, r6
 800b3f6:	d908      	bls.n	800b40a <__udivdi3+0x6e>
 800b3f8:	19f6      	adds	r6, r6, r7
 800b3fa:	f109 39ff 	add.w	r9, r9, #4294967295
 800b3fe:	d204      	bcs.n	800b40a <__udivdi3+0x6e>
 800b400:	42b3      	cmp	r3, r6
 800b402:	bf84      	itt	hi
 800b404:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800b408:	19f6      	addhi	r6, r6, r7
 800b40a:	1af6      	subs	r6, r6, r3
 800b40c:	4621      	mov	r1, r4
 800b40e:	4630      	mov	r0, r6
 800b410:	fa1f f888 	uxth.w	r8, r8
 800b414:	f7ff f814 	bl	800a440 <__aeabi_uidiv>
 800b418:	4621      	mov	r1, r4
 800b41a:	4605      	mov	r5, r0
 800b41c:	4630      	mov	r0, r6
 800b41e:	f7ff f93d 	bl	800a69c <__aeabi_uidivmod>
 800b422:	fb0a fa05 	mul.w	sl, sl, r5
 800b426:	ea48 4801 	orr.w	r8, r8, r1, lsl #16
 800b42a:	45c2      	cmp	sl, r8
 800b42c:	d906      	bls.n	800b43c <__udivdi3+0xa0>
 800b42e:	3d01      	subs	r5, #1
 800b430:	eb18 0807 	adds.w	r8, r8, r7
 800b434:	d202      	bcs.n	800b43c <__udivdi3+0xa0>
 800b436:	45c2      	cmp	sl, r8
 800b438:	bf88      	it	hi
 800b43a:	3d01      	subhi	r5, #1
 800b43c:	ea45 4a09 	orr.w	sl, r5, r9, lsl #16
 800b440:	2600      	movs	r6, #0
 800b442:	4631      	mov	r1, r6
 800b444:	4650      	mov	r0, sl
 800b446:	b003      	add	sp, #12
 800b448:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b44c:	428b      	cmp	r3, r1
 800b44e:	d85b      	bhi.n	800b508 <__udivdi3+0x16c>
 800b450:	fab3 f683 	clz	r6, r3
 800b454:	2e00      	cmp	r6, #0
 800b456:	d15a      	bne.n	800b50e <__udivdi3+0x172>
 800b458:	428b      	cmp	r3, r1
 800b45a:	f04f 0a01 	mov.w	sl, #1
 800b45e:	bf2c      	ite	cs
 800b460:	2400      	movcs	r4, #0
 800b462:	2401      	movcc	r4, #1
 800b464:	4282      	cmp	r2, r0
 800b466:	bf8c      	ite	hi
 800b468:	4625      	movhi	r5, r4
 800b46a:	f044 0501 	orrls.w	r5, r4, #1
 800b46e:	2d00      	cmp	r5, #0
 800b470:	d1e7      	bne.n	800b442 <__udivdi3+0xa6>
 800b472:	462e      	mov	r6, r5
 800b474:	46aa      	mov	sl, r5
 800b476:	e7e4      	b.n	800b442 <__udivdi3+0xa6>
 800b478:	b922      	cbnz	r2, 800b484 <__udivdi3+0xe8>
 800b47a:	2001      	movs	r0, #1
 800b47c:	4611      	mov	r1, r2
 800b47e:	f7fe ffdf 	bl	800a440 <__aeabi_uidiv>
 800b482:	4607      	mov	r7, r0
 800b484:	fab7 f387 	clz	r3, r7
 800b488:	2b00      	cmp	r3, #0
 800b48a:	f040 80b6 	bne.w	800b5fa <__udivdi3+0x25e>
 800b48e:	1be4      	subs	r4, r4, r7
 800b490:	ea4f 4b17 	mov.w	fp, r7, lsr #16
 800b494:	b2bd      	uxth	r5, r7
 800b496:	2601      	movs	r6, #1
 800b498:	4659      	mov	r1, fp
 800b49a:	4620      	mov	r0, r4
 800b49c:	f7fe ffd0 	bl	800a440 <__aeabi_uidiv>
 800b4a0:	4659      	mov	r1, fp
 800b4a2:	ea4f 4918 	mov.w	r9, r8, lsr #16
 800b4a6:	4682      	mov	sl, r0
 800b4a8:	4620      	mov	r0, r4
 800b4aa:	f7ff f8f7 	bl	800a69c <__aeabi_uidivmod>
 800b4ae:	fb05 f30a 	mul.w	r3, r5, sl
 800b4b2:	ea49 4401 	orr.w	r4, r9, r1, lsl #16
 800b4b6:	42a3      	cmp	r3, r4
 800b4b8:	d908      	bls.n	800b4cc <__udivdi3+0x130>
 800b4ba:	19e4      	adds	r4, r4, r7
 800b4bc:	f10a 3aff 	add.w	sl, sl, #4294967295
 800b4c0:	d204      	bcs.n	800b4cc <__udivdi3+0x130>
 800b4c2:	42a3      	cmp	r3, r4
 800b4c4:	bf84      	itt	hi
 800b4c6:	f10a 3aff 	addhi.w	sl, sl, #4294967295
 800b4ca:	19e4      	addhi	r4, r4, r7
 800b4cc:	1ae4      	subs	r4, r4, r3
 800b4ce:	4659      	mov	r1, fp
 800b4d0:	4620      	mov	r0, r4
 800b4d2:	f7fe ffb5 	bl	800a440 <__aeabi_uidiv>
 800b4d6:	4659      	mov	r1, fp
 800b4d8:	4681      	mov	r9, r0
 800b4da:	4620      	mov	r0, r4
 800b4dc:	f7ff f8de 	bl	800a69c <__aeabi_uidivmod>
 800b4e0:	fa1f f388 	uxth.w	r3, r8
 800b4e4:	fb05 f509 	mul.w	r5, r5, r9
 800b4e8:	ea43 4801 	orr.w	r8, r3, r1, lsl #16
 800b4ec:	4545      	cmp	r5, r8
 800b4ee:	d908      	bls.n	800b502 <__udivdi3+0x166>
 800b4f0:	eb18 0807 	adds.w	r8, r8, r7
 800b4f4:	f109 39ff 	add.w	r9, r9, #4294967295
 800b4f8:	d203      	bcs.n	800b502 <__udivdi3+0x166>
 800b4fa:	4545      	cmp	r5, r8
 800b4fc:	bf88      	it	hi
 800b4fe:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800b502:	ea49 4a0a 	orr.w	sl, r9, sl, lsl #16
 800b506:	e79c      	b.n	800b442 <__udivdi3+0xa6>
 800b508:	2600      	movs	r6, #0
 800b50a:	46b2      	mov	sl, r6
 800b50c:	e799      	b.n	800b442 <__udivdi3+0xa6>
 800b50e:	f1c6 0120 	rsb	r1, r6, #32
 800b512:	40b3      	lsls	r3, r6
 800b514:	fa32 f701 	lsrs.w	r7, r2, r1
 800b518:	fa24 f901 	lsr.w	r9, r4, r1
 800b51c:	431f      	orrs	r7, r3
 800b51e:	40b4      	lsls	r4, r6
 800b520:	fa30 f301 	lsrs.w	r3, r0, r1
 800b524:	4648      	mov	r0, r9
 800b526:	ea4f 4817 	mov.w	r8, r7, lsr #16
 800b52a:	ea43 0104 	orr.w	r1, r3, r4
 800b52e:	9101      	str	r1, [sp, #4]
 800b530:	4641      	mov	r1, r8
 800b532:	40b2      	lsls	r2, r6
 800b534:	9200      	str	r2, [sp, #0]
 800b536:	f7fe ff83 	bl	800a440 <__aeabi_uidiv>
 800b53a:	4641      	mov	r1, r8
 800b53c:	b2bc      	uxth	r4, r7
 800b53e:	4682      	mov	sl, r0
 800b540:	4648      	mov	r0, r9
 800b542:	f7ff f8ab 	bl	800a69c <__aeabi_uidivmod>
 800b546:	9801      	ldr	r0, [sp, #4]
 800b548:	fb04 f30a 	mul.w	r3, r4, sl
 800b54c:	ea4f 4b10 	mov.w	fp, r0, lsr #16
 800b550:	ea4b 4b01 	orr.w	fp, fp, r1, lsl #16
 800b554:	455b      	cmp	r3, fp
 800b556:	d905      	bls.n	800b564 <__udivdi3+0x1c8>
 800b558:	eb1b 0b07 	adds.w	fp, fp, r7
 800b55c:	f10a 3aff 	add.w	sl, sl, #4294967295
 800b560:	f0c0 8093 	bcc.w	800b68a <__udivdi3+0x2ee>
 800b564:	ebc3 0b0b 	rsb	fp, r3, fp
 800b568:	4641      	mov	r1, r8
 800b56a:	4658      	mov	r0, fp
 800b56c:	f7fe ff68 	bl	800a440 <__aeabi_uidiv>
 800b570:	4641      	mov	r1, r8
 800b572:	4681      	mov	r9, r0
 800b574:	4658      	mov	r0, fp
 800b576:	f7ff f891 	bl	800a69c <__aeabi_uidivmod>
 800b57a:	9801      	ldr	r0, [sp, #4]
 800b57c:	fb04 f409 	mul.w	r4, r4, r9
 800b580:	fa1f fc80 	uxth.w	ip, r0
 800b584:	ea4c 4301 	orr.w	r3, ip, r1, lsl #16
 800b588:	429c      	cmp	r4, r3
 800b58a:	d903      	bls.n	800b594 <__udivdi3+0x1f8>
 800b58c:	19db      	adds	r3, r3, r7
 800b58e:	f109 39ff 	add.w	r9, r9, #4294967295
 800b592:	d374      	bcc.n	800b67e <__udivdi3+0x2e2>
 800b594:	9f00      	ldr	r7, [sp, #0]
 800b596:	ea49 4a0a 	orr.w	sl, r9, sl, lsl #16
 800b59a:	1b1c      	subs	r4, r3, r4
 800b59c:	fa1f fe8a 	uxth.w	lr, sl
 800b5a0:	b2b8      	uxth	r0, r7
 800b5a2:	0c3a      	lsrs	r2, r7, #16
 800b5a4:	ea4f 471a 	mov.w	r7, sl, lsr #16
 800b5a8:	fb00 fc0e 	mul.w	ip, r0, lr
 800b5ac:	fb00 f307 	mul.w	r3, r0, r7
 800b5b0:	fb02 310e 	mla	r1, r2, lr, r3
 800b5b4:	fb02 f207 	mul.w	r2, r2, r7
 800b5b8:	eb01 411c 	add.w	r1, r1, ip, lsr #16
 800b5bc:	428b      	cmp	r3, r1
 800b5be:	bf88      	it	hi
 800b5c0:	f502 3280 	addhi.w	r2, r2, #65536	; 0x10000
 800b5c4:	eb02 4e11 	add.w	lr, r2, r1, lsr #16
 800b5c8:	4574      	cmp	r4, lr
 800b5ca:	d312      	bcc.n	800b5f2 <__udivdi3+0x256>
 800b5cc:	ea4f 4101 	mov.w	r1, r1, lsl #16
 800b5d0:	fa1f f28c 	uxth.w	r2, ip
 800b5d4:	bf14      	ite	ne
 800b5d6:	2300      	movne	r3, #0
 800b5d8:	2301      	moveq	r3, #1
 800b5da:	eb01 0c02 	add.w	ip, r1, r2
 800b5de:	fa15 f606 	lsls.w	r6, r5, r6
 800b5e2:	4566      	cmp	r6, ip
 800b5e4:	bf2c      	ite	cs
 800b5e6:	2600      	movcs	r6, #0
 800b5e8:	f003 0601 	andcc.w	r6, r3, #1
 800b5ec:	2e00      	cmp	r6, #0
 800b5ee:	f43f af28 	beq.w	800b442 <__udivdi3+0xa6>
 800b5f2:	f10a 3aff 	add.w	sl, sl, #4294967295
 800b5f6:	2600      	movs	r6, #0
 800b5f8:	e723      	b.n	800b442 <__udivdi3+0xa6>
 800b5fa:	409f      	lsls	r7, r3
 800b5fc:	f1c3 0120 	rsb	r1, r3, #32
 800b600:	fa34 f601 	lsrs.w	r6, r4, r1
 800b604:	fa14 f203 	lsls.w	r2, r4, r3
 800b608:	ea4f 4b17 	mov.w	fp, r7, lsr #16
 800b60c:	fa25 fa01 	lsr.w	sl, r5, r1
 800b610:	4630      	mov	r0, r6
 800b612:	4659      	mov	r1, fp
 800b614:	fa05 f803 	lsl.w	r8, r5, r3
 800b618:	ea4a 0a02 	orr.w	sl, sl, r2
 800b61c:	f7fe ff10 	bl	800a440 <__aeabi_uidiv>
 800b620:	4659      	mov	r1, fp
 800b622:	b2bd      	uxth	r5, r7
 800b624:	4681      	mov	r9, r0
 800b626:	4630      	mov	r0, r6
 800b628:	f7ff f838 	bl	800a69c <__aeabi_uidivmod>
 800b62c:	ea4f 4c1a 	mov.w	ip, sl, lsr #16
 800b630:	fb05 f309 	mul.w	r3, r5, r9
 800b634:	ea4c 4401 	orr.w	r4, ip, r1, lsl #16
 800b638:	42a3      	cmp	r3, r4
 800b63a:	d903      	bls.n	800b644 <__udivdi3+0x2a8>
 800b63c:	19e4      	adds	r4, r4, r7
 800b63e:	f109 39ff 	add.w	r9, r9, #4294967295
 800b642:	d328      	bcc.n	800b696 <__udivdi3+0x2fa>
 800b644:	1ae4      	subs	r4, r4, r3
 800b646:	4659      	mov	r1, fp
 800b648:	4620      	mov	r0, r4
 800b64a:	f7fe fef9 	bl	800a440 <__aeabi_uidiv>
 800b64e:	4659      	mov	r1, fp
 800b650:	4606      	mov	r6, r0
 800b652:	4620      	mov	r0, r4
 800b654:	f7ff f822 	bl	800a69c <__aeabi_uidivmod>
 800b658:	fa1f f48a 	uxth.w	r4, sl
 800b65c:	fb05 f306 	mul.w	r3, r5, r6
 800b660:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 800b664:	42a3      	cmp	r3, r4
 800b666:	d906      	bls.n	800b676 <__udivdi3+0x2da>
 800b668:	3e01      	subs	r6, #1
 800b66a:	19e4      	adds	r4, r4, r7
 800b66c:	d203      	bcs.n	800b676 <__udivdi3+0x2da>
 800b66e:	42a3      	cmp	r3, r4
 800b670:	d901      	bls.n	800b676 <__udivdi3+0x2da>
 800b672:	3e01      	subs	r6, #1
 800b674:	19e4      	adds	r4, r4, r7
 800b676:	1ae4      	subs	r4, r4, r3
 800b678:	ea46 4609 	orr.w	r6, r6, r9, lsl #16
 800b67c:	e70c      	b.n	800b498 <__udivdi3+0xfc>
 800b67e:	429c      	cmp	r4, r3
 800b680:	bf84      	itt	hi
 800b682:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800b686:	19db      	addhi	r3, r3, r7
 800b688:	e784      	b.n	800b594 <__udivdi3+0x1f8>
 800b68a:	455b      	cmp	r3, fp
 800b68c:	bf84      	itt	hi
 800b68e:	f10a 3aff 	addhi.w	sl, sl, #4294967295
 800b692:	44bb      	addhi	fp, r7
 800b694:	e766      	b.n	800b564 <__udivdi3+0x1c8>
 800b696:	42a3      	cmp	r3, r4
 800b698:	bf84      	itt	hi
 800b69a:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800b69e:	19e4      	addhi	r4, r4, r7
 800b6a0:	e7d0      	b.n	800b644 <__udivdi3+0x2a8>
 800b6a2:	bf00      	nop

0800b6a4 <Reset_Handler>:
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
 800b6a4:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800b6a6:	e003      	b.n	800b6b0 <LoopCopyDataInit>

0800b6a8 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800b6a8:	4b0b      	ldr	r3, [pc, #44]	; (800b6d8 <LoopFillZerobss+0x14>)
  ldr  r3, [r3, r1]
 800b6aa:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800b6ac:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800b6ae:	3104      	adds	r1, #4

0800b6b0 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr  r0, =_sdata
 800b6b0:	480a      	ldr	r0, [pc, #40]	; (800b6dc <LoopFillZerobss+0x18>)
  ldr  r3, =_edata
 800b6b2:	4b0b      	ldr	r3, [pc, #44]	; (800b6e0 <LoopFillZerobss+0x1c>)
  adds  r2, r0, r1
 800b6b4:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800b6b6:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800b6b8:	d3f6      	bcc.n	800b6a8 <CopyDataInit>
  ldr  r2, =_sbss
 800b6ba:	4a0a      	ldr	r2, [pc, #40]	; (800b6e4 <LoopFillZerobss+0x20>)
  b  LoopFillZerobss
 800b6bc:	e002      	b.n	800b6c4 <LoopFillZerobss>

0800b6be <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs  r3, #0
 800b6be:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800b6c0:	f842 3b04 	str.w	r3, [r2], #4

0800b6c4 <LoopFillZerobss>:

LoopFillZerobss:
  ldr  r3, = _ebss
 800b6c4:	4b08      	ldr	r3, [pc, #32]	; (800b6e8 <LoopFillZerobss+0x24>)
  cmp  r2, r3
 800b6c6:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800b6c8:	d3f9      	bcc.n	800b6be <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 800b6ca:	f7f5 fad9 	bl	8000c80 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 800b6ce:	f7f9 faaf 	bl	8004c30 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800b6d2:	f7f5 f87f 	bl	80007d4 <main>
  bx  lr
 800b6d6:	4770      	bx	lr
 800b6d8:	0800bbac 	.word	0x0800bbac
 800b6dc:	20000000 	.word	0x20000000
 800b6e0:	200007ec 	.word	0x200007ec
 800b6e4:	200007ec 	.word	0x200007ec
 800b6e8:	20001ae8 	.word	0x20001ae8

0800b6ec <Default_Handler2>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler2:
Infinite_Loop:
  b  Infinite_Loop
 800b6ec:	e7fe      	b.n	800b6ec <Default_Handler2>
	...

0800b6f0 <clocks>:
 800b6f0:	0101 0405 0000 0000 1200 007a 0007 0000     ..........z.....
 800b700:	0054 0002                                   T...

0800b704 <outpp>:
 800b704:	0001 0003 5500                                   .....

0800b709 <C.5.7763>:
 800b709:	aa55 0200                                        U..

0800b70c <CSWTCH.6>:
 800b70c:	0102 0002                                   ....

0800b710 <outputcs>:
 800b710:	0001 0003 0200                                   .....

0800b715 <outputaf>:
 800b715:	0002 0003 0205                                   .....

0800b71a <inputaf>:
 800b71a:	0002 0100 0005                              ......

0800b720 <ahbtbl>:
 800b720:	0001 0001 0001 0001 0001 0001 0001 0001     ................
 800b730:	0002 0004 0008 0010 0040 0080 0100 0200     ........@.......

0800b740 <tcif_tbl>:
 800b740:	0600 1610                                   ....

0800b744 <open_name>:
 800b744:	bb18 0800 bb1d 0800 bb22 0800 bb27 0800     ........"...'...
 800b754:	bb2c 0800 bb31 0800 bb36 0800 bb3b 0800     ,...1...6...;...

0800b764 <C.0.4985>:
 800b764:	0002 0003 0200                                   .....

0800b769 <C.1.4986>:
 800b769:	0002 0100 0000 7000                              .......

0800b770 <_global_impure_ptr>:
 800b770:	0270 2000                                   p.. 

0800b774 <__sf_fake_stdin>:
	...

0800b794 <__sf_fake_stdout>:
	...

0800b7b4 <__sf_fake_stderr>:
	...

0800b7d4 <blanks.6598>:
 800b7d4:	2020 2020 2020 2020 2020 2020 2020 2020                     

0800b7e4 <zeroes.6599>:
 800b7e4:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000
 800b7f4:	0000 0000                                   ....

0800b7f8 <p05.5124>:
 800b7f8:	0005 0000 0019 0000 007d 0000 0000 0000     ........}.......

0800b808 <__mprec_tens>:
 800b808:	0000 0000 0000 3ff0 0000 0000 0000 4024     .......?......$@
 800b818:	0000 0000 0000 4059 0000 0000 4000 408f     ......Y@.....@.@
 800b828:	0000 0000 8800 40c3 0000 0000 6a00 40f8     .......@.....j.@
 800b838:	0000 0000 8480 412e 0000 0000 12d0 4163     .......A......cA
 800b848:	0000 0000 d784 4197 0000 0000 cd65 41cd     .......A....e..A
 800b858:	0000 2000 a05f 4202 0000 e800 4876 4237     ... _..B....vH7B
 800b868:	0000 a200 1a94 426d 0000 e540 309c 42a2     ......mB..@..0.B
 800b878:	0000 1e90 bcc4 42d6 0000 2634 6bf5 430c     .......B..4&.k.C
 800b888:	8000 37e0 c379 4341 a000 85d8 3457 4376     ...7y.AC....W4vC
 800b898:	c800 674e c16d 43ab 3d00 6091 58e4 43e1     ..Ngm..C.=.`.X.C
 800b8a8:	8c40 78b5 af1d 4415 ef50 d6e2 1ae4 444b     @..x...DP.....KD
 800b8b8:	d592 064d f0cf 4480 4af6 c7e1 2d02 44b5     ..M....D.J...-.D
 800b8c8:	9db4 79d9 7843 44ea                         ...yCx.D

0800b8d0 <__mprec_bigtens>:
 800b8d0:	8000 37e0 c379 4341 6e17 b505 b8b5 4693     ...7y.AC.n.....F
 800b8e0:	f9f5 e93f 4f03 4d38 1d32 f930 7748 5a82     ..?..O8M2.0.Hw.Z
 800b8f0:	bf3c 7f73 4fdd 7515                         <.s..O.u

0800b8f8 <__mprec_tinytens>:
 800b8f8:	89bc 97d8 d2b2 3c9c a733 d5a8 f623 3949     .......<3...#.I9
 800b908:	a73d 44f4 0ffd 32a5 979d cf8c ba08 255b     =..D...2......[%
 800b918:	6f43 64ac 0628 0ac8                         Co.d(...

0800b920 <blanks.6542>:
 800b920:	2020 2020 2020 2020 2020 2020 2020 2020                     

0800b930 <zeroes.6543>:
 800b930:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000
 800b940:	6325 2000 0d0a 4944 4353 564f 5245 2059     %c. ..DISCOVERY 
 800b950:	3446 5320 4950 5432 5345 3a54 3020 2d32     F4 SPI2TEST: 02-
 800b960:	3630 322d 3130 2034 7620 0a30 000d 2020     06-2014  v0...  
 800b970:	6820 6c63 5f6b 7266 7165 2820 484d 297a      hclk_freq (MHz)
 800b980:	3a20 2520 7539 2e2e 2e2e 2e2e 2e2e 2e2e      : %9u..........
 800b990:	2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e     ................
 800b9a0:	2e2e 2e2e 0a2e 000d 2020 6370 6b6c 5f31     ........  pclk1_
 800b9b0:	7266 7165 2820 484d 297a 3a20 2520 7539     freq (MHz) : %9u
 800b9c0:	2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e     ................
 800b9d0:	2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 0a2e     ................
 800b9e0:	000d 2020 6370 6b6c 5f32 7266 7165 2820     ..  pclk2_freq (
 800b9f0:	484d 297a 3a20 2520 7539 2e2e 2e2e 2e2e     MHz) : %9u......
 800ba00:	2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e     ................
 800ba10:	2e2e 2e2e 2e2e 2e2e 0a2e 000d 7320 7379     ............ sys
 800ba20:	6c63 5f6b 7266 7165 2820 484d 297a 3a20     clk_freq (MHz) :
 800ba30:	2520 7539 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e      %9u............
 800ba40:	2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e     ................
 800ba50:	2e2e 0a2e 000d 0d0a 754f 7074 7475 7020     ........Output p
 800ba60:	7461 6574 6e72 6220 7469 0a73 000d 0d0a     attern bits.....
 800ba70:	6e49 6f63 696d 676e 6220 7469 7020 7461     Incoming bit pat
 800ba80:	6574 6e72 0d0a 2500 7535 2520 7535 0020     tern...%5u %5u .
 800ba90:	4356 2050 6e49 6574 6672 6361 0065 4356     VCP Interface.VC
 800baa0:	2050 6f43 666e 6769 3000 3030 3030 3030     P Config.0000000
 800bab0:	3030 3035 0042 3030 3030 3030 3030 3530     0050B.0000000005
 800bac0:	4330 5300 4d54 6369 6f72 6c65 6365 7274     0C.STMicroelectr
 800bad0:	6e6f 6369 0073 5453 334d 2032 6956 7472     onics.STM32 Virt
 800bae0:	6175 206c 6f43 506d 726f 2074 6e69 4820     ual ComPort in H
 800baf0:	2053 6f6d 6564 5300 4d54 3233 5620 7269     S mode.STM32 Vir
 800bb00:	7574 6c61 4320 6d6f 6f50 7472 6920 206e     tual ComPort in 
 800bb10:	5346 4d20 646f 0065 7474 3179 7400 7974     FS Mode.tty1.tty
 800bb20:	0032 7474 3379 7400 7974 0034 7474 3579     2.tty3.tty4.tty5
 800bb30:	7400 7974 0036 7474 3779 7400 7974 0038     .tty6.tty7.tty8.
 800bb40:	0043 0000 4e49 0046 6e69 0066 414e 004e     C...INF.inf.NAN.
 800bb50:	616e 006e 3130 3332 3534 3736 3938 4241     nan.0123456789AB
 800bb60:	4443 4645 0000 0000 3130 3332 3534 3736     CDEF....01234567
 800bb70:	3938 6261 6463 6665 0000 0000 6e28 6c75     89abcdef....(nul
 800bb80:	296c 0000 0030 0000 6e49 6966 696e 7974     l)..0...Infinity
 800bb90:	0000 0000 614e 004e 4f50 4953 0058 0000     ....NaN.POSIX...
 800bba0:	002e 0000                                   ....
