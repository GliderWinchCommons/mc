
spi2test.elf:     file format elf32-littlearm


Disassembly of section .text:

08000188 <Default_Handler08>:
int _read(int file, char *ptr, int len);

/* --------------- For debugging...(usb) ------------------------------ */
int Default_HandlerCode = 999;
u32 DH08;
void Default_Handler08(void) {DH08 += 1; return;}
 8000188:	4b02      	ldr	r3, [pc, #8]	; (8000194 <Default_Handler08+0xc>)
 800018a:	681a      	ldr	r2, [r3, #0]
 800018c:	3201      	adds	r2, #1
 800018e:	601a      	str	r2, [r3, #0]
 8000190:	4770      	bx	lr
 8000192:	bf00      	nop
 8000194:	20000b34 	.word	0x20000b34

08000198 <Default_Handler76>:

void OTG_FS_IRQHandler(void);
void Default_Handler76(void) {	OTG_FS_IRQHandler(); return; }
 8000198:	f000 bd66 	b.w	8000c68 <OTG_FS_IRQHandler>

0800019c <Default_Handler00>:

void Default_Handler00(void) { Default_HandlerCode =  0; panic_leds(5); }
 800019c:	4b02      	ldr	r3, [pc, #8]	; (80001a8 <Default_Handler00+0xc>)
 800019e:	2200      	movs	r2, #0
 80001a0:	2005      	movs	r0, #5
 80001a2:	601a      	str	r2, [r3, #0]
 80001a4:	f003 bcc7 	b.w	8003b36 <panic_leds>
 80001a8:	20000000 	.word	0x20000000

080001ac <Default_Handler01>:
void Default_Handler01(void) { Default_HandlerCode =  1; panic_leds(5); }
 80001ac:	4b02      	ldr	r3, [pc, #8]	; (80001b8 <Default_Handler01+0xc>)
 80001ae:	2201      	movs	r2, #1
 80001b0:	2005      	movs	r0, #5
 80001b2:	601a      	str	r2, [r3, #0]
 80001b4:	f003 bcbf 	b.w	8003b36 <panic_leds>
 80001b8:	20000000 	.word	0x20000000

080001bc <Default_Handler02>:
void Default_Handler02(void) { Default_HandlerCode =  2; panic_leds(5); }
 80001bc:	4b02      	ldr	r3, [pc, #8]	; (80001c8 <Default_Handler02+0xc>)
 80001be:	2202      	movs	r2, #2
 80001c0:	2005      	movs	r0, #5
 80001c2:	601a      	str	r2, [r3, #0]
 80001c4:	f003 bcb7 	b.w	8003b36 <panic_leds>
 80001c8:	20000000 	.word	0x20000000

080001cc <Default_Handler03>:
void Default_Handler03(void) { Default_HandlerCode =  3; panic_leds(5); }
 80001cc:	4b02      	ldr	r3, [pc, #8]	; (80001d8 <Default_Handler03+0xc>)
 80001ce:	2203      	movs	r2, #3
 80001d0:	2005      	movs	r0, #5
 80001d2:	601a      	str	r2, [r3, #0]
 80001d4:	f003 bcaf 	b.w	8003b36 <panic_leds>
 80001d8:	20000000 	.word	0x20000000

080001dc <Default_Handler04>:
void Default_Handler04(void) { Default_HandlerCode =  4; panic_leds(5); }
 80001dc:	4b02      	ldr	r3, [pc, #8]	; (80001e8 <Default_Handler04+0xc>)
 80001de:	2204      	movs	r2, #4
 80001e0:	2005      	movs	r0, #5
 80001e2:	601a      	str	r2, [r3, #0]
 80001e4:	f003 bca7 	b.w	8003b36 <panic_leds>
 80001e8:	20000000 	.word	0x20000000

080001ec <Default_Handler05>:
void Default_Handler05(void) { Default_HandlerCode =  5; panic_leds(5); }
 80001ec:	4b02      	ldr	r3, [pc, #8]	; (80001f8 <Default_Handler05+0xc>)
 80001ee:	2005      	movs	r0, #5
 80001f0:	6018      	str	r0, [r3, #0]
 80001f2:	f003 bca0 	b.w	8003b36 <panic_leds>
 80001f6:	bf00      	nop
 80001f8:	20000000 	.word	0x20000000

080001fc <Default_Handler06>:
void Default_Handler06(void) { Default_HandlerCode =  6; panic_leds(5); }
 80001fc:	4b02      	ldr	r3, [pc, #8]	; (8000208 <Default_Handler06+0xc>)
 80001fe:	2206      	movs	r2, #6
 8000200:	2005      	movs	r0, #5
 8000202:	601a      	str	r2, [r3, #0]
 8000204:	f003 bc97 	b.w	8003b36 <panic_leds>
 8000208:	20000000 	.word	0x20000000

0800020c <Default_Handler07>:
void Default_Handler07(void) { Default_HandlerCode =  7; panic_leds(5); }
 800020c:	4b02      	ldr	r3, [pc, #8]	; (8000218 <Default_Handler07+0xc>)
 800020e:	2207      	movs	r2, #7
 8000210:	2005      	movs	r0, #5
 8000212:	601a      	str	r2, [r3, #0]
 8000214:	f003 bc8f 	b.w	8003b36 <panic_leds>
 8000218:	20000000 	.word	0x20000000

0800021c <Default_Handler09>:
//void Default_Handler08(void) { Default_HandlerCode =  8; panic_leds(5); }
void Default_Handler09(void) { Default_HandlerCode =  9; panic_leds(5); }
 800021c:	4b02      	ldr	r3, [pc, #8]	; (8000228 <Default_Handler09+0xc>)
 800021e:	2209      	movs	r2, #9
 8000220:	2005      	movs	r0, #5
 8000222:	601a      	str	r2, [r3, #0]
 8000224:	f003 bc87 	b.w	8003b36 <panic_leds>
 8000228:	20000000 	.word	0x20000000

0800022c <Default_Handler10>:
void Default_Handler10(void) { Default_HandlerCode = 10; panic_leds(5); }
 800022c:	4b02      	ldr	r3, [pc, #8]	; (8000238 <Default_Handler10+0xc>)
 800022e:	220a      	movs	r2, #10
 8000230:	2005      	movs	r0, #5
 8000232:	601a      	str	r2, [r3, #0]
 8000234:	f003 bc7f 	b.w	8003b36 <panic_leds>
 8000238:	20000000 	.word	0x20000000

0800023c <Default_Handler11>:
void Default_Handler11(void) { Default_HandlerCode = 11; panic_leds(5); }
 800023c:	4b02      	ldr	r3, [pc, #8]	; (8000248 <Default_Handler11+0xc>)
 800023e:	220b      	movs	r2, #11
 8000240:	2005      	movs	r0, #5
 8000242:	601a      	str	r2, [r3, #0]
 8000244:	f003 bc77 	b.w	8003b36 <panic_leds>
 8000248:	20000000 	.word	0x20000000

0800024c <Default_Handler12>:
void Default_Handler12(void) { Default_HandlerCode = 12; panic_leds(5); }
 800024c:	4b02      	ldr	r3, [pc, #8]	; (8000258 <Default_Handler12+0xc>)
 800024e:	220c      	movs	r2, #12
 8000250:	2005      	movs	r0, #5
 8000252:	601a      	str	r2, [r3, #0]
 8000254:	f003 bc6f 	b.w	8003b36 <panic_leds>
 8000258:	20000000 	.word	0x20000000

0800025c <Default_Handler13>:
void Default_Handler13(void) { Default_HandlerCode = 13; panic_leds(5); }
 800025c:	4b02      	ldr	r3, [pc, #8]	; (8000268 <Default_Handler13+0xc>)
 800025e:	220d      	movs	r2, #13
 8000260:	2005      	movs	r0, #5
 8000262:	601a      	str	r2, [r3, #0]
 8000264:	f003 bc67 	b.w	8003b36 <panic_leds>
 8000268:	20000000 	.word	0x20000000

0800026c <Default_Handler14>:
void Default_Handler14(void) { Default_HandlerCode = 14; panic_leds(5); }
 800026c:	4b02      	ldr	r3, [pc, #8]	; (8000278 <Default_Handler14+0xc>)
 800026e:	220e      	movs	r2, #14
 8000270:	2005      	movs	r0, #5
 8000272:	601a      	str	r2, [r3, #0]
 8000274:	f003 bc5f 	b.w	8003b36 <panic_leds>
 8000278:	20000000 	.word	0x20000000

0800027c <Default_Handler15>:
void Default_Handler15(void) { Default_HandlerCode = 15; panic_leds(5); }
 800027c:	4b02      	ldr	r3, [pc, #8]	; (8000288 <Default_Handler15+0xc>)
 800027e:	220f      	movs	r2, #15
 8000280:	2005      	movs	r0, #5
 8000282:	601a      	str	r2, [r3, #0]
 8000284:	f003 bc57 	b.w	8003b36 <panic_leds>
 8000288:	20000000 	.word	0x20000000

0800028c <Default_Handler16>:
void Default_Handler16(void) { Default_HandlerCode = 16; panic_leds(5); }
 800028c:	4b02      	ldr	r3, [pc, #8]	; (8000298 <Default_Handler16+0xc>)
 800028e:	2210      	movs	r2, #16
 8000290:	2005      	movs	r0, #5
 8000292:	601a      	str	r2, [r3, #0]
 8000294:	f003 bc4f 	b.w	8003b36 <panic_leds>
 8000298:	20000000 	.word	0x20000000

0800029c <Default_Handler17>:
void Default_Handler17(void) { Default_HandlerCode = 17; panic_leds(5); }
 800029c:	4b02      	ldr	r3, [pc, #8]	; (80002a8 <Default_Handler17+0xc>)
 800029e:	2211      	movs	r2, #17
 80002a0:	2005      	movs	r0, #5
 80002a2:	601a      	str	r2, [r3, #0]
 80002a4:	f003 bc47 	b.w	8003b36 <panic_leds>
 80002a8:	20000000 	.word	0x20000000

080002ac <Default_Handler18>:
void Default_Handler18(void) { Default_HandlerCode = 18; panic_leds(5); }
 80002ac:	4b02      	ldr	r3, [pc, #8]	; (80002b8 <Default_Handler18+0xc>)
 80002ae:	2212      	movs	r2, #18
 80002b0:	2005      	movs	r0, #5
 80002b2:	601a      	str	r2, [r3, #0]
 80002b4:	f003 bc3f 	b.w	8003b36 <panic_leds>
 80002b8:	20000000 	.word	0x20000000

080002bc <Default_Handler19>:
void Default_Handler19(void) { Default_HandlerCode = 19; panic_leds(5); }
 80002bc:	4b02      	ldr	r3, [pc, #8]	; (80002c8 <Default_Handler19+0xc>)
 80002be:	2213      	movs	r2, #19
 80002c0:	2005      	movs	r0, #5
 80002c2:	601a      	str	r2, [r3, #0]
 80002c4:	f003 bc37 	b.w	8003b36 <panic_leds>
 80002c8:	20000000 	.word	0x20000000

080002cc <Default_Handler20>:
void Default_Handler20(void) { Default_HandlerCode = 20; panic_leds(5); }
 80002cc:	4b02      	ldr	r3, [pc, #8]	; (80002d8 <Default_Handler20+0xc>)
 80002ce:	2214      	movs	r2, #20
 80002d0:	2005      	movs	r0, #5
 80002d2:	601a      	str	r2, [r3, #0]
 80002d4:	f003 bc2f 	b.w	8003b36 <panic_leds>
 80002d8:	20000000 	.word	0x20000000

080002dc <Default_Handler21>:
void Default_Handler21(void) { Default_HandlerCode = 21; panic_leds(5); }
 80002dc:	4b02      	ldr	r3, [pc, #8]	; (80002e8 <Default_Handler21+0xc>)
 80002de:	2215      	movs	r2, #21
 80002e0:	2005      	movs	r0, #5
 80002e2:	601a      	str	r2, [r3, #0]
 80002e4:	f003 bc27 	b.w	8003b36 <panic_leds>
 80002e8:	20000000 	.word	0x20000000

080002ec <Default_Handler22>:
void Default_Handler22(void) { Default_HandlerCode = 22; panic_leds(5); }
 80002ec:	4b02      	ldr	r3, [pc, #8]	; (80002f8 <Default_Handler22+0xc>)
 80002ee:	2216      	movs	r2, #22
 80002f0:	2005      	movs	r0, #5
 80002f2:	601a      	str	r2, [r3, #0]
 80002f4:	f003 bc1f 	b.w	8003b36 <panic_leds>
 80002f8:	20000000 	.word	0x20000000

080002fc <Default_Handler23>:
void Default_Handler23(void) { Default_HandlerCode = 23; panic_leds(5); }
 80002fc:	4b02      	ldr	r3, [pc, #8]	; (8000308 <Default_Handler23+0xc>)
 80002fe:	2217      	movs	r2, #23
 8000300:	2005      	movs	r0, #5
 8000302:	601a      	str	r2, [r3, #0]
 8000304:	f003 bc17 	b.w	8003b36 <panic_leds>
 8000308:	20000000 	.word	0x20000000

0800030c <Default_Handler24>:
void Default_Handler24(void) { Default_HandlerCode = 24; panic_leds(5); }
 800030c:	4b02      	ldr	r3, [pc, #8]	; (8000318 <Default_Handler24+0xc>)
 800030e:	2218      	movs	r2, #24
 8000310:	2005      	movs	r0, #5
 8000312:	601a      	str	r2, [r3, #0]
 8000314:	f003 bc0f 	b.w	8003b36 <panic_leds>
 8000318:	20000000 	.word	0x20000000

0800031c <Default_Handler25>:
void Default_Handler25(void) { Default_HandlerCode = 25; panic_leds(5); }
 800031c:	4b02      	ldr	r3, [pc, #8]	; (8000328 <Default_Handler25+0xc>)
 800031e:	2219      	movs	r2, #25
 8000320:	2005      	movs	r0, #5
 8000322:	601a      	str	r2, [r3, #0]
 8000324:	f003 bc07 	b.w	8003b36 <panic_leds>
 8000328:	20000000 	.word	0x20000000

0800032c <Default_Handler26>:
void Default_Handler26(void) { Default_HandlerCode = 26; panic_leds(5); }
 800032c:	4b02      	ldr	r3, [pc, #8]	; (8000338 <Default_Handler26+0xc>)
 800032e:	221a      	movs	r2, #26
 8000330:	2005      	movs	r0, #5
 8000332:	601a      	str	r2, [r3, #0]
 8000334:	f003 bbff 	b.w	8003b36 <panic_leds>
 8000338:	20000000 	.word	0x20000000

0800033c <Default_Handler27>:
void Default_Handler27(void) { Default_HandlerCode = 27; panic_leds(5); }
 800033c:	4b02      	ldr	r3, [pc, #8]	; (8000348 <Default_Handler27+0xc>)
 800033e:	221b      	movs	r2, #27
 8000340:	2005      	movs	r0, #5
 8000342:	601a      	str	r2, [r3, #0]
 8000344:	f003 bbf7 	b.w	8003b36 <panic_leds>
 8000348:	20000000 	.word	0x20000000

0800034c <Default_Handler28>:
void Default_Handler28(void) { Default_HandlerCode = 28; panic_leds(5); }
 800034c:	4b02      	ldr	r3, [pc, #8]	; (8000358 <Default_Handler28+0xc>)
 800034e:	221c      	movs	r2, #28
 8000350:	2005      	movs	r0, #5
 8000352:	601a      	str	r2, [r3, #0]
 8000354:	f003 bbef 	b.w	8003b36 <panic_leds>
 8000358:	20000000 	.word	0x20000000

0800035c <Default_Handler29>:
void Default_Handler29(void) { Default_HandlerCode = 29; panic_leds(5); }
 800035c:	4b02      	ldr	r3, [pc, #8]	; (8000368 <Default_Handler29+0xc>)
 800035e:	221d      	movs	r2, #29
 8000360:	2005      	movs	r0, #5
 8000362:	601a      	str	r2, [r3, #0]
 8000364:	f003 bbe7 	b.w	8003b36 <panic_leds>
 8000368:	20000000 	.word	0x20000000

0800036c <Default_Handler30>:
void Default_Handler30(void) { Default_HandlerCode = 30; panic_leds(5); }
 800036c:	4b02      	ldr	r3, [pc, #8]	; (8000378 <Default_Handler30+0xc>)
 800036e:	221e      	movs	r2, #30
 8000370:	2005      	movs	r0, #5
 8000372:	601a      	str	r2, [r3, #0]
 8000374:	f003 bbdf 	b.w	8003b36 <panic_leds>
 8000378:	20000000 	.word	0x20000000

0800037c <Default_Handler31>:
void Default_Handler31(void) { Default_HandlerCode = 31; panic_leds(5); }
 800037c:	4b02      	ldr	r3, [pc, #8]	; (8000388 <Default_Handler31+0xc>)
 800037e:	221f      	movs	r2, #31
 8000380:	2005      	movs	r0, #5
 8000382:	601a      	str	r2, [r3, #0]
 8000384:	f003 bbd7 	b.w	8003b36 <panic_leds>
 8000388:	20000000 	.word	0x20000000

0800038c <Default_Handler32>:
void Default_Handler32(void) { Default_HandlerCode = 32; panic_leds(5); }
 800038c:	4b02      	ldr	r3, [pc, #8]	; (8000398 <Default_Handler32+0xc>)
 800038e:	2220      	movs	r2, #32
 8000390:	2005      	movs	r0, #5
 8000392:	601a      	str	r2, [r3, #0]
 8000394:	f003 bbcf 	b.w	8003b36 <panic_leds>
 8000398:	20000000 	.word	0x20000000

0800039c <Default_Handler33>:
void Default_Handler33(void) { Default_HandlerCode = 33; panic_leds(5); }
 800039c:	4b02      	ldr	r3, [pc, #8]	; (80003a8 <Default_Handler33+0xc>)
 800039e:	2221      	movs	r2, #33	; 0x21
 80003a0:	2005      	movs	r0, #5
 80003a2:	601a      	str	r2, [r3, #0]
 80003a4:	f003 bbc7 	b.w	8003b36 <panic_leds>
 80003a8:	20000000 	.word	0x20000000

080003ac <Default_Handler34>:
void Default_Handler34(void) { Default_HandlerCode = 34; panic_leds(5); }
 80003ac:	4b02      	ldr	r3, [pc, #8]	; (80003b8 <Default_Handler34+0xc>)
 80003ae:	2222      	movs	r2, #34	; 0x22
 80003b0:	2005      	movs	r0, #5
 80003b2:	601a      	str	r2, [r3, #0]
 80003b4:	f003 bbbf 	b.w	8003b36 <panic_leds>
 80003b8:	20000000 	.word	0x20000000

080003bc <Default_Handler35>:
void Default_Handler35(void) { Default_HandlerCode = 35; panic_leds(5); }
 80003bc:	4b02      	ldr	r3, [pc, #8]	; (80003c8 <Default_Handler35+0xc>)
 80003be:	2223      	movs	r2, #35	; 0x23
 80003c0:	2005      	movs	r0, #5
 80003c2:	601a      	str	r2, [r3, #0]
 80003c4:	f003 bbb7 	b.w	8003b36 <panic_leds>
 80003c8:	20000000 	.word	0x20000000

080003cc <Default_Handler36>:
void Default_Handler36(void) { Default_HandlerCode = 36; panic_leds(5); }
 80003cc:	4b02      	ldr	r3, [pc, #8]	; (80003d8 <Default_Handler36+0xc>)
 80003ce:	2224      	movs	r2, #36	; 0x24
 80003d0:	2005      	movs	r0, #5
 80003d2:	601a      	str	r2, [r3, #0]
 80003d4:	f003 bbaf 	b.w	8003b36 <panic_leds>
 80003d8:	20000000 	.word	0x20000000

080003dc <Default_Handler37>:
void Default_Handler37(void) { Default_HandlerCode = 37; panic_leds(5); }
 80003dc:	4b02      	ldr	r3, [pc, #8]	; (80003e8 <Default_Handler37+0xc>)
 80003de:	2225      	movs	r2, #37	; 0x25
 80003e0:	2005      	movs	r0, #5
 80003e2:	601a      	str	r2, [r3, #0]
 80003e4:	f003 bba7 	b.w	8003b36 <panic_leds>
 80003e8:	20000000 	.word	0x20000000

080003ec <Default_Handler38>:
void Default_Handler38(void) { Default_HandlerCode = 38; panic_leds(5); }
 80003ec:	4b02      	ldr	r3, [pc, #8]	; (80003f8 <Default_Handler38+0xc>)
 80003ee:	2226      	movs	r2, #38	; 0x26
 80003f0:	2005      	movs	r0, #5
 80003f2:	601a      	str	r2, [r3, #0]
 80003f4:	f003 bb9f 	b.w	8003b36 <panic_leds>
 80003f8:	20000000 	.word	0x20000000

080003fc <Default_Handler39>:
void Default_Handler39(void) { Default_HandlerCode = 39; panic_leds(5); }
 80003fc:	4b02      	ldr	r3, [pc, #8]	; (8000408 <Default_Handler39+0xc>)
 80003fe:	2227      	movs	r2, #39	; 0x27
 8000400:	2005      	movs	r0, #5
 8000402:	601a      	str	r2, [r3, #0]
 8000404:	f003 bb97 	b.w	8003b36 <panic_leds>
 8000408:	20000000 	.word	0x20000000

0800040c <Default_Handler40>:
void Default_Handler40(void) { Default_HandlerCode = 40; panic_leds(5); }
 800040c:	4b02      	ldr	r3, [pc, #8]	; (8000418 <Default_Handler40+0xc>)
 800040e:	2228      	movs	r2, #40	; 0x28
 8000410:	2005      	movs	r0, #5
 8000412:	601a      	str	r2, [r3, #0]
 8000414:	f003 bb8f 	b.w	8003b36 <panic_leds>
 8000418:	20000000 	.word	0x20000000

0800041c <Default_Handler41>:
void Default_Handler41(void) { Default_HandlerCode = 41; panic_leds(5); }
 800041c:	4b02      	ldr	r3, [pc, #8]	; (8000428 <Default_Handler41+0xc>)
 800041e:	2229      	movs	r2, #41	; 0x29
 8000420:	2005      	movs	r0, #5
 8000422:	601a      	str	r2, [r3, #0]
 8000424:	f003 bb87 	b.w	8003b36 <panic_leds>
 8000428:	20000000 	.word	0x20000000

0800042c <Default_Handler42>:
void Default_Handler42(void) { Default_HandlerCode = 42; panic_leds(5); }
 800042c:	4b02      	ldr	r3, [pc, #8]	; (8000438 <Default_Handler42+0xc>)
 800042e:	222a      	movs	r2, #42	; 0x2a
 8000430:	2005      	movs	r0, #5
 8000432:	601a      	str	r2, [r3, #0]
 8000434:	f003 bb7f 	b.w	8003b36 <panic_leds>
 8000438:	20000000 	.word	0x20000000

0800043c <Default_Handler43>:
void Default_Handler43(void) { Default_HandlerCode = 43; panic_leds(5); }
 800043c:	4b02      	ldr	r3, [pc, #8]	; (8000448 <Default_Handler43+0xc>)
 800043e:	222b      	movs	r2, #43	; 0x2b
 8000440:	2005      	movs	r0, #5
 8000442:	601a      	str	r2, [r3, #0]
 8000444:	f003 bb77 	b.w	8003b36 <panic_leds>
 8000448:	20000000 	.word	0x20000000

0800044c <Default_Handler44>:
void Default_Handler44(void) { Default_HandlerCode = 44; panic_leds(5); }
 800044c:	4b02      	ldr	r3, [pc, #8]	; (8000458 <Default_Handler44+0xc>)
 800044e:	222c      	movs	r2, #44	; 0x2c
 8000450:	2005      	movs	r0, #5
 8000452:	601a      	str	r2, [r3, #0]
 8000454:	f003 bb6f 	b.w	8003b36 <panic_leds>
 8000458:	20000000 	.word	0x20000000

0800045c <Default_Handler45>:
void Default_Handler45(void) { Default_HandlerCode = 45; panic_leds(5); }
 800045c:	4b02      	ldr	r3, [pc, #8]	; (8000468 <Default_Handler45+0xc>)
 800045e:	222d      	movs	r2, #45	; 0x2d
 8000460:	2005      	movs	r0, #5
 8000462:	601a      	str	r2, [r3, #0]
 8000464:	f003 bb67 	b.w	8003b36 <panic_leds>
 8000468:	20000000 	.word	0x20000000

0800046c <Default_Handler46>:
void Default_Handler46(void) { Default_HandlerCode = 46; panic_leds(5); }
 800046c:	4b02      	ldr	r3, [pc, #8]	; (8000478 <Default_Handler46+0xc>)
 800046e:	222e      	movs	r2, #46	; 0x2e
 8000470:	2005      	movs	r0, #5
 8000472:	601a      	str	r2, [r3, #0]
 8000474:	f003 bb5f 	b.w	8003b36 <panic_leds>
 8000478:	20000000 	.word	0x20000000

0800047c <Default_Handler47>:
void Default_Handler47(void) { Default_HandlerCode = 47; panic_leds(5); }
 800047c:	4b02      	ldr	r3, [pc, #8]	; (8000488 <Default_Handler47+0xc>)
 800047e:	222f      	movs	r2, #47	; 0x2f
 8000480:	2005      	movs	r0, #5
 8000482:	601a      	str	r2, [r3, #0]
 8000484:	f003 bb57 	b.w	8003b36 <panic_leds>
 8000488:	20000000 	.word	0x20000000

0800048c <Default_Handler48>:
void Default_Handler48(void) { Default_HandlerCode = 48; panic_leds(5); }
 800048c:	4b02      	ldr	r3, [pc, #8]	; (8000498 <Default_Handler48+0xc>)
 800048e:	2230      	movs	r2, #48	; 0x30
 8000490:	2005      	movs	r0, #5
 8000492:	601a      	str	r2, [r3, #0]
 8000494:	f003 bb4f 	b.w	8003b36 <panic_leds>
 8000498:	20000000 	.word	0x20000000

0800049c <Default_Handler49>:
void Default_Handler49(void) { Default_HandlerCode = 49; panic_leds(5); }
 800049c:	4b02      	ldr	r3, [pc, #8]	; (80004a8 <Default_Handler49+0xc>)
 800049e:	2231      	movs	r2, #49	; 0x31
 80004a0:	2005      	movs	r0, #5
 80004a2:	601a      	str	r2, [r3, #0]
 80004a4:	f003 bb47 	b.w	8003b36 <panic_leds>
 80004a8:	20000000 	.word	0x20000000

080004ac <Default_Handler50>:
void Default_Handler50(void) { Default_HandlerCode = 50; panic_leds(5); }
 80004ac:	4b02      	ldr	r3, [pc, #8]	; (80004b8 <Default_Handler50+0xc>)
 80004ae:	2232      	movs	r2, #50	; 0x32
 80004b0:	2005      	movs	r0, #5
 80004b2:	601a      	str	r2, [r3, #0]
 80004b4:	f003 bb3f 	b.w	8003b36 <panic_leds>
 80004b8:	20000000 	.word	0x20000000

080004bc <Default_Handler51>:
void Default_Handler51(void) { Default_HandlerCode = 51; panic_leds(5); }
 80004bc:	4b02      	ldr	r3, [pc, #8]	; (80004c8 <Default_Handler51+0xc>)
 80004be:	2233      	movs	r2, #51	; 0x33
 80004c0:	2005      	movs	r0, #5
 80004c2:	601a      	str	r2, [r3, #0]
 80004c4:	f003 bb37 	b.w	8003b36 <panic_leds>
 80004c8:	20000000 	.word	0x20000000

080004cc <Default_Handler52>:
void Default_Handler52(void) { Default_HandlerCode = 52; panic_leds(5); }
 80004cc:	4b02      	ldr	r3, [pc, #8]	; (80004d8 <Default_Handler52+0xc>)
 80004ce:	2234      	movs	r2, #52	; 0x34
 80004d0:	2005      	movs	r0, #5
 80004d2:	601a      	str	r2, [r3, #0]
 80004d4:	f003 bb2f 	b.w	8003b36 <panic_leds>
 80004d8:	20000000 	.word	0x20000000

080004dc <Default_Handler53>:
void Default_Handler53(void) { Default_HandlerCode = 53; panic_leds(5); }
 80004dc:	4b02      	ldr	r3, [pc, #8]	; (80004e8 <Default_Handler53+0xc>)
 80004de:	2235      	movs	r2, #53	; 0x35
 80004e0:	2005      	movs	r0, #5
 80004e2:	601a      	str	r2, [r3, #0]
 80004e4:	f003 bb27 	b.w	8003b36 <panic_leds>
 80004e8:	20000000 	.word	0x20000000

080004ec <Default_Handler54>:
void Default_Handler54(void) { Default_HandlerCode = 54; panic_leds(5); }
 80004ec:	4b02      	ldr	r3, [pc, #8]	; (80004f8 <Default_Handler54+0xc>)
 80004ee:	2236      	movs	r2, #54	; 0x36
 80004f0:	2005      	movs	r0, #5
 80004f2:	601a      	str	r2, [r3, #0]
 80004f4:	f003 bb1f 	b.w	8003b36 <panic_leds>
 80004f8:	20000000 	.word	0x20000000

080004fc <Default_Handler55>:
void Default_Handler55(void) { Default_HandlerCode = 55; panic_leds(5); }
 80004fc:	4b02      	ldr	r3, [pc, #8]	; (8000508 <Default_Handler55+0xc>)
 80004fe:	2237      	movs	r2, #55	; 0x37
 8000500:	2005      	movs	r0, #5
 8000502:	601a      	str	r2, [r3, #0]
 8000504:	f003 bb17 	b.w	8003b36 <panic_leds>
 8000508:	20000000 	.word	0x20000000

0800050c <Default_Handler56>:
void Default_Handler56(void) { Default_HandlerCode = 56; panic_leds(5); }
 800050c:	4b02      	ldr	r3, [pc, #8]	; (8000518 <Default_Handler56+0xc>)
 800050e:	2238      	movs	r2, #56	; 0x38
 8000510:	2005      	movs	r0, #5
 8000512:	601a      	str	r2, [r3, #0]
 8000514:	f003 bb0f 	b.w	8003b36 <panic_leds>
 8000518:	20000000 	.word	0x20000000

0800051c <Default_Handler57>:
void Default_Handler57(void) { Default_HandlerCode = 57; panic_leds(5); }
 800051c:	4b02      	ldr	r3, [pc, #8]	; (8000528 <Default_Handler57+0xc>)
 800051e:	2239      	movs	r2, #57	; 0x39
 8000520:	2005      	movs	r0, #5
 8000522:	601a      	str	r2, [r3, #0]
 8000524:	f003 bb07 	b.w	8003b36 <panic_leds>
 8000528:	20000000 	.word	0x20000000

0800052c <Default_Handler58>:
void Default_Handler58(void) { Default_HandlerCode = 58; panic_leds(5); }
 800052c:	4b02      	ldr	r3, [pc, #8]	; (8000538 <Default_Handler58+0xc>)
 800052e:	223a      	movs	r2, #58	; 0x3a
 8000530:	2005      	movs	r0, #5
 8000532:	601a      	str	r2, [r3, #0]
 8000534:	f003 baff 	b.w	8003b36 <panic_leds>
 8000538:	20000000 	.word	0x20000000

0800053c <Default_Handler59>:
void Default_Handler59(void) { Default_HandlerCode = 59; panic_leds(5); }
 800053c:	4b02      	ldr	r3, [pc, #8]	; (8000548 <Default_Handler59+0xc>)
 800053e:	223b      	movs	r2, #59	; 0x3b
 8000540:	2005      	movs	r0, #5
 8000542:	601a      	str	r2, [r3, #0]
 8000544:	f003 baf7 	b.w	8003b36 <panic_leds>
 8000548:	20000000 	.word	0x20000000

0800054c <Default_Handler60>:
void Default_Handler60(void) { Default_HandlerCode = 60; panic_leds(5); }
 800054c:	4b02      	ldr	r3, [pc, #8]	; (8000558 <Default_Handler60+0xc>)
 800054e:	223c      	movs	r2, #60	; 0x3c
 8000550:	2005      	movs	r0, #5
 8000552:	601a      	str	r2, [r3, #0]
 8000554:	f003 baef 	b.w	8003b36 <panic_leds>
 8000558:	20000000 	.word	0x20000000

0800055c <Default_Handler61>:
void Default_Handler61(void) { Default_HandlerCode = 61; panic_leds(5); }
 800055c:	4b02      	ldr	r3, [pc, #8]	; (8000568 <Default_Handler61+0xc>)
 800055e:	223d      	movs	r2, #61	; 0x3d
 8000560:	2005      	movs	r0, #5
 8000562:	601a      	str	r2, [r3, #0]
 8000564:	f003 bae7 	b.w	8003b36 <panic_leds>
 8000568:	20000000 	.word	0x20000000

0800056c <Default_Handler62>:
void Default_Handler62(void) { Default_HandlerCode = 62; panic_leds(5); }
 800056c:	4b02      	ldr	r3, [pc, #8]	; (8000578 <Default_Handler62+0xc>)
 800056e:	223e      	movs	r2, #62	; 0x3e
 8000570:	2005      	movs	r0, #5
 8000572:	601a      	str	r2, [r3, #0]
 8000574:	f003 badf 	b.w	8003b36 <panic_leds>
 8000578:	20000000 	.word	0x20000000

0800057c <Default_Handler63>:
void Default_Handler63(void) { Default_HandlerCode = 63; panic_leds(5); }
 800057c:	4b02      	ldr	r3, [pc, #8]	; (8000588 <Default_Handler63+0xc>)
 800057e:	223f      	movs	r2, #63	; 0x3f
 8000580:	2005      	movs	r0, #5
 8000582:	601a      	str	r2, [r3, #0]
 8000584:	f003 bad7 	b.w	8003b36 <panic_leds>
 8000588:	20000000 	.word	0x20000000

0800058c <Default_Handler64>:
void Default_Handler64(void) { Default_HandlerCode = 64; panic_leds(5); }
 800058c:	4b02      	ldr	r3, [pc, #8]	; (8000598 <Default_Handler64+0xc>)
 800058e:	2240      	movs	r2, #64	; 0x40
 8000590:	2005      	movs	r0, #5
 8000592:	601a      	str	r2, [r3, #0]
 8000594:	f003 bacf 	b.w	8003b36 <panic_leds>
 8000598:	20000000 	.word	0x20000000

0800059c <Default_Handler65>:
void Default_Handler65(void) { Default_HandlerCode = 65; panic_leds(5); }
 800059c:	4b02      	ldr	r3, [pc, #8]	; (80005a8 <Default_Handler65+0xc>)
 800059e:	2241      	movs	r2, #65	; 0x41
 80005a0:	2005      	movs	r0, #5
 80005a2:	601a      	str	r2, [r3, #0]
 80005a4:	f003 bac7 	b.w	8003b36 <panic_leds>
 80005a8:	20000000 	.word	0x20000000

080005ac <Default_Handler66>:
void Default_Handler66(void) { Default_HandlerCode = 66; panic_leds(5); }
 80005ac:	4b02      	ldr	r3, [pc, #8]	; (80005b8 <Default_Handler66+0xc>)
 80005ae:	2242      	movs	r2, #66	; 0x42
 80005b0:	2005      	movs	r0, #5
 80005b2:	601a      	str	r2, [r3, #0]
 80005b4:	f003 babf 	b.w	8003b36 <panic_leds>
 80005b8:	20000000 	.word	0x20000000

080005bc <Default_Handler67>:
void Default_Handler67(void) { Default_HandlerCode = 67; panic_leds(5); }
 80005bc:	4b02      	ldr	r3, [pc, #8]	; (80005c8 <Default_Handler67+0xc>)
 80005be:	2243      	movs	r2, #67	; 0x43
 80005c0:	2005      	movs	r0, #5
 80005c2:	601a      	str	r2, [r3, #0]
 80005c4:	f003 bab7 	b.w	8003b36 <panic_leds>
 80005c8:	20000000 	.word	0x20000000

080005cc <Default_Handler68>:
void Default_Handler68(void) { Default_HandlerCode = 68; panic_leds(5); }
 80005cc:	4b02      	ldr	r3, [pc, #8]	; (80005d8 <Default_Handler68+0xc>)
 80005ce:	2244      	movs	r2, #68	; 0x44
 80005d0:	2005      	movs	r0, #5
 80005d2:	601a      	str	r2, [r3, #0]
 80005d4:	f003 baaf 	b.w	8003b36 <panic_leds>
 80005d8:	20000000 	.word	0x20000000

080005dc <Default_Handler69>:
void Default_Handler69(void) { Default_HandlerCode = 69; panic_leds(5); }
 80005dc:	4b02      	ldr	r3, [pc, #8]	; (80005e8 <Default_Handler69+0xc>)
 80005de:	2245      	movs	r2, #69	; 0x45
 80005e0:	2005      	movs	r0, #5
 80005e2:	601a      	str	r2, [r3, #0]
 80005e4:	f003 baa7 	b.w	8003b36 <panic_leds>
 80005e8:	20000000 	.word	0x20000000

080005ec <Default_Handler70>:
void Default_Handler70(void) { Default_HandlerCode = 70; panic_leds(5); }
 80005ec:	4b02      	ldr	r3, [pc, #8]	; (80005f8 <Default_Handler70+0xc>)
 80005ee:	2246      	movs	r2, #70	; 0x46
 80005f0:	2005      	movs	r0, #5
 80005f2:	601a      	str	r2, [r3, #0]
 80005f4:	f003 ba9f 	b.w	8003b36 <panic_leds>
 80005f8:	20000000 	.word	0x20000000

080005fc <Default_Handler71>:
void Default_Handler71(void) { Default_HandlerCode = 71; panic_leds(5); }
 80005fc:	4b02      	ldr	r3, [pc, #8]	; (8000608 <Default_Handler71+0xc>)
 80005fe:	2247      	movs	r2, #71	; 0x47
 8000600:	2005      	movs	r0, #5
 8000602:	601a      	str	r2, [r3, #0]
 8000604:	f003 ba97 	b.w	8003b36 <panic_leds>
 8000608:	20000000 	.word	0x20000000

0800060c <Default_Handler72>:
void Default_Handler72(void) { Default_HandlerCode = 72; panic_leds(5); }
 800060c:	4b02      	ldr	r3, [pc, #8]	; (8000618 <Default_Handler72+0xc>)
 800060e:	2248      	movs	r2, #72	; 0x48
 8000610:	2005      	movs	r0, #5
 8000612:	601a      	str	r2, [r3, #0]
 8000614:	f003 ba8f 	b.w	8003b36 <panic_leds>
 8000618:	20000000 	.word	0x20000000

0800061c <Default_Handler73>:
void Default_Handler73(void) { Default_HandlerCode = 73; panic_leds(5); }
 800061c:	4b02      	ldr	r3, [pc, #8]	; (8000628 <Default_Handler73+0xc>)
 800061e:	2249      	movs	r2, #73	; 0x49
 8000620:	2005      	movs	r0, #5
 8000622:	601a      	str	r2, [r3, #0]
 8000624:	f003 ba87 	b.w	8003b36 <panic_leds>
 8000628:	20000000 	.word	0x20000000

0800062c <Default_Handler74>:
void Default_Handler74(void) { Default_HandlerCode = 74; panic_leds(5); }
 800062c:	4b02      	ldr	r3, [pc, #8]	; (8000638 <Default_Handler74+0xc>)
 800062e:	224a      	movs	r2, #74	; 0x4a
 8000630:	2005      	movs	r0, #5
 8000632:	601a      	str	r2, [r3, #0]
 8000634:	f003 ba7f 	b.w	8003b36 <panic_leds>
 8000638:	20000000 	.word	0x20000000

0800063c <Default_Handler75>:
void Default_Handler75(void) { Default_HandlerCode = 75; panic_leds(5); }
 800063c:	4b02      	ldr	r3, [pc, #8]	; (8000648 <Default_Handler75+0xc>)
 800063e:	224b      	movs	r2, #75	; 0x4b
 8000640:	2005      	movs	r0, #5
 8000642:	601a      	str	r2, [r3, #0]
 8000644:	f003 ba77 	b.w	8003b36 <panic_leds>
 8000648:	20000000 	.word	0x20000000

0800064c <Default_Handler77>:
//void Default_Handler76(void) { Default_HandlerCode = 76; panic_leds(5); }
void Default_Handler77(void) { Default_HandlerCode = 77; panic_leds(5); }
 800064c:	4b02      	ldr	r3, [pc, #8]	; (8000658 <Default_Handler77+0xc>)
 800064e:	224d      	movs	r2, #77	; 0x4d
 8000650:	2005      	movs	r0, #5
 8000652:	601a      	str	r2, [r3, #0]
 8000654:	f003 ba6f 	b.w	8003b36 <panic_leds>
 8000658:	20000000 	.word	0x20000000

0800065c <Default_Handler78>:
void Default_Handler78(void) { Default_HandlerCode = 78; panic_leds(5); }
 800065c:	4b02      	ldr	r3, [pc, #8]	; (8000668 <Default_Handler78+0xc>)
 800065e:	224e      	movs	r2, #78	; 0x4e
 8000660:	2005      	movs	r0, #5
 8000662:	601a      	str	r2, [r3, #0]
 8000664:	f003 ba67 	b.w	8003b36 <panic_leds>
 8000668:	20000000 	.word	0x20000000

0800066c <Default_Handler79>:
void Default_Handler79(void) { Default_HandlerCode = 79; panic_leds(5); }
 800066c:	4b02      	ldr	r3, [pc, #8]	; (8000678 <Default_Handler79+0xc>)
 800066e:	224f      	movs	r2, #79	; 0x4f
 8000670:	2005      	movs	r0, #5
 8000672:	601a      	str	r2, [r3, #0]
 8000674:	f003 ba5f 	b.w	8003b36 <panic_leds>
 8000678:	20000000 	.word	0x20000000

0800067c <Default_Handler80>:
void Default_Handler80(void) { Default_HandlerCode = 80; panic_leds(5); }
 800067c:	4b02      	ldr	r3, [pc, #8]	; (8000688 <Default_Handler80+0xc>)
 800067e:	2250      	movs	r2, #80	; 0x50
 8000680:	2005      	movs	r0, #5
 8000682:	601a      	str	r2, [r3, #0]
 8000684:	f003 ba57 	b.w	8003b36 <panic_leds>
 8000688:	20000000 	.word	0x20000000

0800068c <Default_Handler81>:
void Default_Handler81(void) { Default_HandlerCode = 81; panic_leds(5); }
 800068c:	4b02      	ldr	r3, [pc, #8]	; (8000698 <Default_Handler81+0xc>)
 800068e:	2251      	movs	r2, #81	; 0x51
 8000690:	2005      	movs	r0, #5
 8000692:	601a      	str	r2, [r3, #0]
 8000694:	f003 ba4f 	b.w	8003b36 <panic_leds>
 8000698:	20000000 	.word	0x20000000

0800069c <Default_Handler82>:
void Default_Handler82(void) { Default_HandlerCode = 82; panic_leds(5); }
 800069c:	4b02      	ldr	r3, [pc, #8]	; (80006a8 <Default_Handler82+0xc>)
 800069e:	2252      	movs	r2, #82	; 0x52
 80006a0:	2005      	movs	r0, #5
 80006a2:	601a      	str	r2, [r3, #0]
 80006a4:	f003 ba47 	b.w	8003b36 <panic_leds>
 80006a8:	20000000 	.word	0x20000000

080006ac <Default_Handler83>:
void Default_Handler83(void) { Default_HandlerCode = 83; panic_leds(5); }
 80006ac:	4b02      	ldr	r3, [pc, #8]	; (80006b8 <Default_Handler83+0xc>)
 80006ae:	2253      	movs	r2, #83	; 0x53
 80006b0:	2005      	movs	r0, #5
 80006b2:	601a      	str	r2, [r3, #0]
 80006b4:	f003 ba3f 	b.w	8003b36 <panic_leds>
 80006b8:	20000000 	.word	0x20000000

080006bc <Default_Handler84>:
void Default_Handler84(void) { Default_HandlerCode = 84; panic_leds(5); }
 80006bc:	4b02      	ldr	r3, [pc, #8]	; (80006c8 <Default_Handler84+0xc>)
 80006be:	2254      	movs	r2, #84	; 0x54
 80006c0:	2005      	movs	r0, #5
 80006c2:	601a      	str	r2, [r3, #0]
 80006c4:	f003 ba37 	b.w	8003b36 <panic_leds>
 80006c8:	20000000 	.word	0x20000000

080006cc <Default_Handler85>:
void Default_Handler85(void) { Default_HandlerCode = 85; panic_leds(5); }
 80006cc:	4b02      	ldr	r3, [pc, #8]	; (80006d8 <Default_Handler85+0xc>)
 80006ce:	2255      	movs	r2, #85	; 0x55
 80006d0:	2005      	movs	r0, #5
 80006d2:	601a      	str	r2, [r3, #0]
 80006d4:	f003 ba2f 	b.w	8003b36 <panic_leds>
 80006d8:	20000000 	.word	0x20000000

080006dc <Default_Handler86>:
void Default_Handler86(void) { Default_HandlerCode = 86; panic_leds(5); }
 80006dc:	4b02      	ldr	r3, [pc, #8]	; (80006e8 <Default_Handler86+0xc>)
 80006de:	2256      	movs	r2, #86	; 0x56
 80006e0:	2005      	movs	r0, #5
 80006e2:	601a      	str	r2, [r3, #0]
 80006e4:	f003 ba27 	b.w	8003b36 <panic_leds>
 80006e8:	20000000 	.word	0x20000000

080006ec <Default_Handler87>:
void Default_Handler87(void) { Default_HandlerCode = 87; panic_leds(5); }
 80006ec:	4b02      	ldr	r3, [pc, #8]	; (80006f8 <Default_Handler87+0xc>)
 80006ee:	2257      	movs	r2, #87	; 0x57
 80006f0:	2005      	movs	r0, #5
 80006f2:	601a      	str	r2, [r3, #0]
 80006f4:	f003 ba1f 	b.w	8003b36 <panic_leds>
 80006f8:	20000000 	.word	0x20000000

080006fc <Default_Handler88>:
void Default_Handler88(void) { Default_HandlerCode = 88; panic_leds(5); }
 80006fc:	4b02      	ldr	r3, [pc, #8]	; (8000708 <Default_Handler88+0xc>)
 80006fe:	2258      	movs	r2, #88	; 0x58
 8000700:	2005      	movs	r0, #5
 8000702:	601a      	str	r2, [r3, #0]
 8000704:	f003 ba17 	b.w	8003b36 <panic_leds>
 8000708:	20000000 	.word	0x20000000

0800070c <Default_Handler89>:
void Default_Handler89(void) { Default_HandlerCode = 89; panic_leds(5); }
 800070c:	4b02      	ldr	r3, [pc, #8]	; (8000718 <Default_Handler89+0xc>)
 800070e:	2259      	movs	r2, #89	; 0x59
 8000710:	2005      	movs	r0, #5
 8000712:	601a      	str	r2, [r3, #0]
 8000714:	f003 ba0f 	b.w	8003b36 <panic_leds>
 8000718:	20000000 	.word	0x20000000

0800071c <Default_Handler90>:
void Default_Handler90(void) { Default_HandlerCode = 90; panic_leds(5); }
 800071c:	4b02      	ldr	r3, [pc, #8]	; (8000728 <Default_Handler90+0xc>)
 800071e:	225a      	movs	r2, #90	; 0x5a
 8000720:	2005      	movs	r0, #5
 8000722:	601a      	str	r2, [r3, #0]
 8000724:	f003 ba07 	b.w	8003b36 <panic_leds>
 8000728:	20000000 	.word	0x20000000

0800072c <toggle_4leds>:
Turn the LEDs on in sequence, then turn them back off 
***************************************************************/
static int lednum = 12;	// Lowest port bit numbered LED
void toggle_4leds (void)
{
	if ((GPIO_ODR(GPIOD) & (1<<lednum)) == 0)
 800072c:	4a0c      	ldr	r2, [pc, #48]	; (8000760 <toggle_4leds+0x34>)
 800072e:	4b0d      	ldr	r3, [pc, #52]	; (8000764 <toggle_4leds+0x38>)
/* ************************************************************
Turn the LEDs on in sequence, then turn them back off 
***************************************************************/
static int lednum = 12;	// Lowest port bit numbered LED
void toggle_4leds (void)
{
 8000730:	b510      	push	{r4, lr}
	if ((GPIO_ODR(GPIOD) & (1<<lednum)) == 0)
 8000732:	681c      	ldr	r4, [r3, #0]
 8000734:	6853      	ldr	r3, [r2, #4]
 8000736:	2101      	movs	r1, #1
 8000738:	fa11 f003 	lsls.w	r0, r1, r3
 800073c:	4220      	tst	r0, r4
 800073e:	4614      	mov	r4, r2
 8000740:	4a09      	ldr	r2, [pc, #36]	; (8000768 <toggle_4leds+0x3c>)
 8000742:	d101      	bne.n	8000748 <toggle_4leds+0x1c>
	{ // Here, LED bit was off
		GPIO_BSRR(GPIOD) = (1<<lednum);	// Set bit
 8000744:	6010      	str	r0, [r2, #0]
 8000746:	e003      	b.n	8000750 <toggle_4leds+0x24>
	}
	else
	{ // HEre, LED bit was on
		GPIO_BSRR(GPIOD) = (1<<(lednum+16));	// Reset bit
 8000748:	f103 0010 	add.w	r0, r3, #16
 800074c:	4081      	lsls	r1, r0
 800074e:	6011      	str	r1, [r2, #0]
	}
	lednum += 1;		// Step through all four LEDs
 8000750:	3301      	adds	r3, #1
	if (lednum > 15) lednum = 12;
 8000752:	2b0f      	cmp	r3, #15
	}
	else
	{ // HEre, LED bit was on
		GPIO_BSRR(GPIOD) = (1<<(lednum+16));	// Reset bit
	}
	lednum += 1;		// Step through all four LEDs
 8000754:	6063      	str	r3, [r4, #4]
	if (lednum > 15) lednum = 12;
 8000756:	dd02      	ble.n	800075e <toggle_4leds+0x32>
 8000758:	4b01      	ldr	r3, [pc, #4]	; (8000760 <toggle_4leds+0x34>)
 800075a:	220c      	movs	r2, #12
 800075c:	605a      	str	r2, [r3, #4]
 800075e:	bd10      	pop	{r4, pc}
 8000760:	20000000 	.word	0x20000000
 8000764:	40020c14 	.word	0x40020c14
 8000768:	40020c18 	.word	0x40020c18

0800076c <toggle_led>:
/* ************************************************************
Turn the LEDs on in sequence, then turn them back off 
***************************************************************/
void toggle_led (int lednum)
{
	if ((GPIO_ODR(GPIOD) & (1<<lednum)) == 0)
 800076c:	4b06      	ldr	r3, [pc, #24]	; (8000788 <toggle_led+0x1c>)
 800076e:	2201      	movs	r2, #1
 8000770:	681b      	ldr	r3, [r3, #0]
 8000772:	fa12 f100 	lsls.w	r1, r2, r0
 8000776:	4219      	tst	r1, r3
 8000778:	4b04      	ldr	r3, [pc, #16]	; (800078c <toggle_led+0x20>)
 800077a:	d101      	bne.n	8000780 <toggle_led+0x14>
	{ // Here, LED bit was off
		GPIO_BSRR(GPIOD) = (1<<lednum);	// Set bit
 800077c:	6019      	str	r1, [r3, #0]
 800077e:	4770      	bx	lr
	}
	else
	{ // HEre, LED bit was on
		GPIO_BSRR(GPIOD) = (1<<(lednum+16));	// Reset bit
 8000780:	3010      	adds	r0, #16
 8000782:	4082      	lsls	r2, r0
 8000784:	601a      	str	r2, [r3, #0]
 8000786:	4770      	bx	lr
 8000788:	40020c14 	.word	0x40020c14
 800078c:	40020c18 	.word	0x40020c18

08000790 <printbits>:
}
/******************************************************************************
 * Print out the bits for the array
 ******************************************************************************/
void printbits(char* p)
{
 8000790:	b570      	push	{r4, r5, r6, lr}
 8000792:	4606      	mov	r6, r0
	int i,j;
	char c;

	/* Print out the bits for the incoming bytes */
	for (j = 0; j < SPI2SIZE; j++) // For each byte in the cycle
 8000794:	2400      	movs	r4, #0
 8000796:	e011      	b.n	80007bc <printbits+0x2c>
	{
		for (i = 0; i < 8; i++) // For each bit within a byte
		{
			if ( (*p & (1<<i)) == 0) 
 8000798:	5d32      	ldrb	r2, [r6, r4]
				c = '.';	// Symbol for "zero"
			else
				c = '1';	// Symbol for "one"
			xprintf (UXPRT,"%c",c);
 800079a:	490c      	ldr	r1, [pc, #48]	; (80007cc <printbits+0x3c>)
	/* Print out the bits for the incoming bytes */
	for (j = 0; j < SPI2SIZE; j++) // For each byte in the cycle
	{
		for (i = 0; i < 8; i++) // For each bit within a byte
		{
			if ( (*p & (1<<i)) == 0) 
 800079c:	412a      	asrs	r2, r5
 800079e:	f002 0201 	and.w	r2, r2, #1
				c = '.';	// Symbol for "zero"
			else
				c = '1';	// Symbol for "one"
			xprintf (UXPRT,"%c",c);
 80007a2:	2006      	movs	r0, #6
 80007a4:	2a00      	cmp	r2, #0
 80007a6:	bf14      	ite	ne
 80007a8:	2231      	movne	r2, #49	; 0x31
 80007aa:	222e      	moveq	r2, #46	; 0x2e
	char c;

	/* Print out the bits for the incoming bytes */
	for (j = 0; j < SPI2SIZE; j++) // For each byte in the cycle
	{
		for (i = 0; i < 8; i++) // For each bit within a byte
 80007ac:	3501      	adds	r5, #1
		{
			if ( (*p & (1<<i)) == 0) 
				c = '.';	// Symbol for "zero"
			else
				c = '1';	// Symbol for "one"
			xprintf (UXPRT,"%c",c);
 80007ae:	f004 f943 	bl	8004a38 <xprintf>
	char c;

	/* Print out the bits for the incoming bytes */
	for (j = 0; j < SPI2SIZE; j++) // For each byte in the cycle
	{
		for (i = 0; i < 8; i++) // For each bit within a byte
 80007b2:	2d08      	cmp	r5, #8
 80007b4:	d1f0      	bne.n	8000798 <printbits+0x8>
{
	int i,j;
	char c;

	/* Print out the bits for the incoming bytes */
	for (j = 0; j < SPI2SIZE; j++) // For each byte in the cycle
 80007b6:	3401      	adds	r4, #1
 80007b8:	2c03      	cmp	r4, #3
 80007ba:	d001      	beq.n	80007c0 <printbits+0x30>
}
/******************************************************************************
 * Print out the bits for the array
 ******************************************************************************/
void printbits(char* p)
{
 80007bc:	2500      	movs	r5, #0
 80007be:	e7eb      	b.n	8000798 <printbits+0x8>
			xprintf (UXPRT,"%c",c);
		}
		p++;
	}

	xprintf (UXPRT,"\n\r");
 80007c0:	4903      	ldr	r1, [pc, #12]	; (80007d0 <printbits+0x40>)
 80007c2:	2006      	movs	r0, #6
	return;
}
 80007c4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			xprintf (UXPRT,"%c",c);
		}
		p++;
	}

	xprintf (UXPRT,"\n\r");
 80007c8:	f004 b936 	b.w	8004a38 <xprintf>
 80007cc:	0800b938 	.word	0x0800b938
 80007d0:	0800b9d7 	.word	0x0800b9d7

080007d4 <main>:

/*#################################################################################################
  main routine 
  #################################################################################################*/
int main(void)
{
 80007d4:	b530      	push	{r4, r5, lr}
	int i;
/* --------------------- Begin setting things up -------------------------------------------------- */ 
	clockspecifysetup((struct CLOCKS*)&clocks);		// Get the system clock and bus clocks running
 80007d6:	484a      	ldr	r0, [pc, #296]	; (8000900 <main+0x12c>)

/* ---------------------- Let the hapless Op know it is alive ------------------------------------ */
	/* Announce who we are. ('xprintf' uses uart number to deliver the output.) */
	xprintf(UXPRT,  " \n\rDISCOVERY F4 SPI2TEST: 02-06-2014  v0\n\r");
	/* Make sure we have the correct bus frequencies */
	xprintf (UXPRT, "   hclk_freq (MHz) : %9u...............................\n\r",  hclk_freq/1000000);	
 80007d8:	4c4a      	ldr	r4, [pc, #296]	; (8000904 <main+0x130>)

/*#################################################################################################
  main routine 
  #################################################################################################*/
int main(void)
{
 80007da:	b085      	sub	sp, #20
	int i;
/* --------------------- Begin setting things up -------------------------------------------------- */ 
	clockspecifysetup((struct CLOCKS*)&clocks);		// Get the system clock and bus clocks running
 80007dc:	f003 fa9a 	bl	8003d14 <clockspecifysetup>
/* ---------------------- Set up pins ------------------------------------------------------------- */
	/* Configure pins */
	DISCgpiopins_Config();	// Configure pins
 80007e0:	f003 f922 	bl	8003a28 <DISCgpiopins_Config>
/* ---------------------- Set usb ----------------------------------------------------------------- */
//	usb1_init();	// Initialization for USB (STM32F4_USB_CDC demo package)
	setbuf(stdout, NULL);
 80007e4:	4b48      	ldr	r3, [pc, #288]	; (8000908 <main+0x134>)
 80007e6:	681b      	ldr	r3, [r3, #0]
 80007e8:	2100      	movs	r1, #0
 80007ea:	6898      	ldr	r0, [r3, #8]
 80007ec:	f004 fd16 	bl	800521c <setbuf>
/*	CHAR-BY-CHAR INTERRUPT DRIVEN  */
// int bsp_uart_init_number(u32 iuart, u32 baud, u32 txbuffsize, u32 rxbuffsize,  u32 uart_int_priority);
//	bsp_uart_int_init_number(2, 460800, 256, 256, 0x30);
//	bsp_uart_int_init_number(USTDO, 230400, 256, 256, 0x40);
//	bsp_uart_int_init_number(USTDO, 115200, 256, 256, 0x10);
	bsp_uart_int_init_number(UXPRT, 115200, 256, 256, 0x30);
 80007f0:	f44f 7280 	mov.w	r2, #256	; 0x100
 80007f4:	2330      	movs	r3, #48	; 0x30
 80007f6:	9300      	str	r3, [sp, #0]
 80007f8:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
 80007fc:	4613      	mov	r3, r2
 80007fe:	2006      	movs	r0, #6
 8000800:	f004 f8c0 	bl	8004984 <bsp_uart_int_init_number>
/* ---------------------- DTW sys counter -------------------------------------------------------- */

	/* Use DTW_CYCCNT counter (driven by sysclk) for polling type timing */
/* CYCCNT counter is in the Cortex-M-series core.  See the following for details 
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html */
	*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
 8000804:	4b41      	ldr	r3, [pc, #260]	; (800090c <main+0x138>)
	*(volatile unsigned int*)0xE0001000 |= 0x1;	// Enable DTW_CYCCNT (Data Watch cycle counter)

/* ---------------------- Let the hapless Op know it is alive ------------------------------------ */
	/* Announce who we are. ('xprintf' uses uart number to deliver the output.) */
	xprintf(UXPRT,  " \n\rDISCOVERY F4 SPI2TEST: 02-06-2014  v0\n\r");
 8000806:	4942      	ldr	r1, [pc, #264]	; (8000910 <main+0x13c>)
/* ---------------------- DTW sys counter -------------------------------------------------------- */

	/* Use DTW_CYCCNT counter (driven by sysclk) for polling type timing */
/* CYCCNT counter is in the Cortex-M-series core.  See the following for details 
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html */
	*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
 8000808:	681a      	ldr	r2, [r3, #0]
 800080a:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800080e:	601a      	str	r2, [r3, #0]
	*(volatile unsigned int*)0xE0001000 |= 0x1;	// Enable DTW_CYCCNT (Data Watch cycle counter)
 8000810:	4b40      	ldr	r3, [pc, #256]	; (8000914 <main+0x140>)
 8000812:	681a      	ldr	r2, [r3, #0]
 8000814:	f042 0201 	orr.w	r2, r2, #1
 8000818:	601a      	str	r2, [r3, #0]

/* ---------------------- Let the hapless Op know it is alive ------------------------------------ */
	/* Announce who we are. ('xprintf' uses uart number to deliver the output.) */
	xprintf(UXPRT,  " \n\rDISCOVERY F4 SPI2TEST: 02-06-2014  v0\n\r");
 800081a:	2006      	movs	r0, #6
 800081c:	f004 f90c 	bl	8004a38 <xprintf>
	/* Make sure we have the correct bus frequencies */
	xprintf (UXPRT, "   hclk_freq (MHz) : %9u...............................\n\r",  hclk_freq/1000000);	
 8000820:	4b3d      	ldr	r3, [pc, #244]	; (8000918 <main+0x144>)
 8000822:	493e      	ldr	r1, [pc, #248]	; (800091c <main+0x148>)
 8000824:	681a      	ldr	r2, [r3, #0]
 8000826:	2006      	movs	r0, #6
 8000828:	fbb2 f2f4 	udiv	r2, r2, r4
 800082c:	f004 f904 	bl	8004a38 <xprintf>
	xprintf (UXPRT, "  pclk1_freq (MHz) : %9u...............................\n\r", pclk1_freq/1000000);	
 8000830:	4b3b      	ldr	r3, [pc, #236]	; (8000920 <main+0x14c>)
 8000832:	493c      	ldr	r1, [pc, #240]	; (8000924 <main+0x150>)
 8000834:	681a      	ldr	r2, [r3, #0]
 8000836:	2006      	movs	r0, #6
 8000838:	fbb2 f2f4 	udiv	r2, r2, r4
 800083c:	f004 f8fc 	bl	8004a38 <xprintf>
	xprintf (UXPRT, "  pclk2_freq (MHz) : %9u...............................\n\r", pclk2_freq/1000000);	
 8000840:	4b39      	ldr	r3, [pc, #228]	; (8000928 <main+0x154>)
 8000842:	493a      	ldr	r1, [pc, #232]	; (800092c <main+0x158>)
 8000844:	681a      	ldr	r2, [r3, #0]
 8000846:	2006      	movs	r0, #6
 8000848:	fbb2 f2f4 	udiv	r2, r2, r4
 800084c:	f004 f8f4 	bl	8004a38 <xprintf>
	xprintf (UXPRT, " sysclk_freq (MHz) : %9u...............................\n\r",sysclk_freq/1000000);
 8000850:	4b37      	ldr	r3, [pc, #220]	; (8000930 <main+0x15c>)
 8000852:	4938      	ldr	r1, [pc, #224]	; (8000934 <main+0x160>)
 8000854:	681a      	ldr	r2, [r3, #0]
 8000856:	2006      	movs	r0, #6
 8000858:	fbb2 f2f4 	udiv	r2, r2, r4
 800085c:	f004 f8ec 	bl	8004a38 <xprintf>
 8000860:	240c      	movs	r4, #12

/* --------------------- Onboard LED setup ----------------------------------------------------------------------------- */
	for (i = 0; i < 4; i++)  f4gpiopins_Config ((volatile u32 *)GPIOD, (12+i), (struct PINCONFIG*)&outpp);
 8000862:	4621      	mov	r1, r4
 8000864:	3401      	adds	r4, #1
 8000866:	4834      	ldr	r0, [pc, #208]	; (8000938 <main+0x164>)
 8000868:	4a34      	ldr	r2, [pc, #208]	; (800093c <main+0x168>)
 800086a:	b2a4      	uxth	r4, r4
 800086c:	f003 f8fd 	bl	8003a6a <f4gpiopins_Config>
 8000870:	2c10      	cmp	r4, #16
 8000872:	d1f6      	bne.n	8000862 <main+0x8e>
	/* Initialize the DTW_CYCCNT counter if it is used for timing.  This is a Cortex-Mx core function
           sometimes used in a debugger, and not a STM32 peripheral timer.  It is 32b and runs off the
	   system clock (168MHz in this demo). */
/* CYCCNT counter is in the Cortex-M-series core.  See the following for details 
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html */
	*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
 8000874:	4b25      	ldr	r3, [pc, #148]	; (800090c <main+0x138>)
/* --------------------- Initialize SPI2 ------------------------------------------------------------------------------- */
	spi2rw_init();

/* --------------------- Endless loop follows -------------------------------------------------------------------------- */
#define PACECOUNT (168000000/2);	// Pace the output loop
u32	t_led = *(volatile unsigned int *)0xE0001004 + PACECOUNT;
 8000876:	4c32      	ldr	r4, [pc, #200]	; (8000940 <main+0x16c>)
	/* Initialize the DTW_CYCCNT counter if it is used for timing.  This is a Cortex-Mx core function
           sometimes used in a debugger, and not a STM32 peripheral timer.  It is 32b and runs off the
	   system clock (168MHz in this demo). */
/* CYCCNT counter is in the Cortex-M-series core.  See the following for details 
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html */
	*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
 8000878:	681a      	ldr	r2, [r3, #0]
 800087a:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800087e:	601a      	str	r2, [r3, #0]
	*(volatile unsigned int*)0xE0001000 |= 0x1;	// Enable DTW_CYCCNT (Data Watch cycle counter)
 8000880:	4b24      	ldr	r3, [pc, #144]	; (8000914 <main+0x140>)
 8000882:	681a      	ldr	r2, [r3, #0]
 8000884:	f042 0201 	orr.w	r2, r2, #1
 8000888:	601a      	str	r2, [r3, #0]

/* --------------------- Initialize SPI2 ------------------------------------------------------------------------------- */
	spi2rw_init();
 800088a:	f003 f99d 	bl	8003bc8 <spi2rw_init>

/* --------------------- Endless loop follows -------------------------------------------------------------------------- */
#define PACECOUNT (168000000/2);	// Pace the output loop
u32	t_led = *(volatile unsigned int *)0xE0001004 + PACECOUNT;
 800088e:	4b2d      	ldr	r3, [pc, #180]	; (8000944 <main+0x170>)
   that the bits that are not changing appear stationary.  Changing the "switches" for the input its will
   show up in the print out.  The speed of the printout update is primarily limited by the speed of the
   printf and loop overhead.  The SPI update is approximately 50 us per byte. */


	xprintf (UXPRT,"\n\rOutput pattern bits\n\r");
 8000890:	492d      	ldr	r1, [pc, #180]	; (8000948 <main+0x174>)
/* --------------------- Initialize SPI2 ------------------------------------------------------------------------------- */
	spi2rw_init();

/* --------------------- Endless loop follows -------------------------------------------------------------------------- */
#define PACECOUNT (168000000/2);	// Pace the output loop
u32	t_led = *(volatile unsigned int *)0xE0001004 + PACECOUNT;
 8000892:	681b      	ldr	r3, [r3, #0]
 8000894:	191c      	adds	r4, r3, r4
#define SPI2SIZE 3 	// Number of bytes in the transfer	
char bout[SPI2SIZE] = {0xAA,0x55,0x31};	// Initial outgoing pattern
 8000896:	4b2d      	ldr	r3, [pc, #180]	; (800094c <main+0x178>)
 8000898:	881a      	ldrh	r2, [r3, #0]
 800089a:	789b      	ldrb	r3, [r3, #2]
 800089c:	f8ad 200c 	strh.w	r2, [sp, #12]
   that the bits that are not changing appear stationary.  Changing the "switches" for the input its will
   show up in the print out.  The speed of the printout update is primarily limited by the speed of the
   printf and loop overhead.  The SPI update is approximately 50 us per byte. */


	xprintf (UXPRT,"\n\rOutput pattern bits\n\r");
 80008a0:	2006      	movs	r0, #6

/* --------------------- Endless loop follows -------------------------------------------------------------------------- */
#define PACECOUNT (168000000/2);	// Pace the output loop
u32	t_led = *(volatile unsigned int *)0xE0001004 + PACECOUNT;
#define SPI2SIZE 3 	// Number of bytes in the transfer	
char bout[SPI2SIZE] = {0xAA,0x55,0x31};	// Initial outgoing pattern
 80008a2:	f88d 300e 	strb.w	r3, [sp, #14]
   that the bits that are not changing appear stationary.  Changing the "switches" for the input its will
   show up in the print out.  The speed of the printout update is primarily limited by the speed of the
   printf and loop overhead.  The SPI update is approximately 50 us per byte. */


	xprintf (UXPRT,"\n\rOutput pattern bits\n\r");
 80008a6:	f004 f8c7 	bl	8004a38 <xprintf>
	printbits(bout); // Print output line
 80008aa:	a803      	add	r0, sp, #12
 80008ac:	f7ff ff70 	bl	8000790 <printbits>
	xprintf (UXPRT,"\n\rIncoming bit pattern\n\r");
 80008b0:	2006      	movs	r0, #6
 80008b2:	4927      	ldr	r1, [pc, #156]	; (8000950 <main+0x17c>)
 80008b4:	f004 f8c0 	bl	8004a38 <xprintf>


void printbits(char* p);


int x = 0;
 80008b8:	2500      	movs	r5, #0
	xprintf (UXPRT,"\n\rIncoming bit pattern\n\r");

	while(1==1)
	{
		/* Flash the LED's to amuse the hapless Op */
		if ( ( (int)(*(volatile unsigned int *)0xE0001004 - t_led) ) > 0)
 80008ba:	4b22      	ldr	r3, [pc, #136]	; (8000944 <main+0x170>)
 80008bc:	681b      	ldr	r3, [r3, #0]
 80008be:	1b1b      	subs	r3, r3, r4
 80008c0:	2b00      	cmp	r3, #0
 80008c2:	ddfa      	ble.n	80008ba <main+0xe6>
		{
			t_led += PACECOUNT;
 80008c4:	f104 64a0 	add.w	r4, r4, #83886080	; 0x5000000
 80008c8:	f504 34de 	add.w	r4, r4, #113664	; 0x1bc00
				toggle_led(12);
 80008cc:	200c      	movs	r0, #12
	while(1==1)
	{
		/* Flash the LED's to amuse the hapless Op */
		if ( ( (int)(*(volatile unsigned int *)0xE0001004 - t_led) ) > 0)
		{
			t_led += PACECOUNT;
 80008ce:	f504 7480 	add.w	r4, r4, #256	; 0x100
				toggle_led(12);
 80008d2:	f7ff ff4b 	bl	800076c <toggle_led>
y += 1;
			if (spi2_busy() != 0) // Is SPI2 busy?
 80008d6:	f003 f9b5 	bl	8003c44 <spi2_busy>
 80008da:	b128      	cbz	r0, 80008e8 <main+0x114>
			{ // Here, no.  
				spi2_rw(bout, bin, SPI2SIZE); // Send/rcv three bytes
 80008dc:	a803      	add	r0, sp, #12
 80008de:	a902      	add	r1, sp, #8
 80008e0:	2203      	movs	r2, #3
 80008e2:	f003 f9b7 	bl	8003c54 <spi2_rw>
//			spi2_rw(bout, bin, 3); // Send/rcv three bytes
x += 1; // Debugging counter
 80008e6:	3501      	adds	r5, #1
			}
			xprintf(UXPRT,"%5u %5u ",x, spidebug1);
 80008e8:	4b1a      	ldr	r3, [pc, #104]	; (8000954 <main+0x180>)
 80008ea:	491b      	ldr	r1, [pc, #108]	; (8000958 <main+0x184>)
 80008ec:	681b      	ldr	r3, [r3, #0]
 80008ee:	2006      	movs	r0, #6
 80008f0:	462a      	mov	r2, r5
 80008f2:	f004 f8a1 	bl	8004a38 <xprintf>
			printbits(bin); // Print the bits
 80008f6:	a802      	add	r0, sp, #8
 80008f8:	f7ff ff4a 	bl	8000790 <printbits>
 80008fc:	e7dd      	b.n	80008ba <main+0xe6>
 80008fe:	bf00      	nop
 8000900:	0800b6e8 	.word	0x0800b6e8
 8000904:	000f4240 	.word	0x000f4240
 8000908:	2000026c 	.word	0x2000026c
 800090c:	e000edfc 	.word	0xe000edfc
 8000910:	0800b93b 	.word	0x0800b93b
 8000914:	e0001000 	.word	0xe0001000
 8000918:	20000834 	.word	0x20000834
 800091c:	0800b966 	.word	0x0800b966
 8000920:	20000838 	.word	0x20000838
 8000924:	0800b9a0 	.word	0x0800b9a0
 8000928:	2000083c 	.word	0x2000083c
 800092c:	0800b9da 	.word	0x0800b9da
 8000930:	20000840 	.word	0x20000840
 8000934:	0800ba14 	.word	0x0800ba14
 8000938:	40020c00 	.word	0x40020c00
 800093c:	0800b6fc 	.word	0x0800b6fc
 8000940:	0501bd00 	.word	0x0501bd00
 8000944:	e0001004 	.word	0xe0001004
 8000948:	0800ba4e 	.word	0x0800ba4e
 800094c:	0800b701 	.word	0x0800b701
 8000950:	0800ba66 	.word	0x0800ba66
 8000954:	20000830 	.word	0x20000830
 8000958:	0800ba7f 	.word	0x0800ba7f
 800095c:	0800bba4 	.word	0x0800bba4
 8000960:	20000000 	.word	0x20000000
 8000964:	200007ec 	.word	0x200007ec
 8000968:	200007ec 	.word	0x200007ec
 800096c:	20001ae8 	.word	0x20001ae8

08000970 <_close>:

int __errno;

int _close(int file) {
	return 0;
}
 8000970:	2000      	movs	r0, #0
 8000972:	4770      	bx	lr

08000974 <_fstat>:

int _fstat(int file, struct stat *st) {
	return 0;
}
 8000974:	2000      	movs	r0, #0
 8000976:	4770      	bx	lr

08000978 <_isatty>:

int _isatty(int file) {
	return 1;
}
 8000978:	2001      	movs	r0, #1
 800097a:	4770      	bx	lr

0800097c <_lseek>:

int _lseek(int file, int ptr, int dir) {
	return 0;
}
 800097c:	2000      	movs	r0, #0
 800097e:	4770      	bx	lr

08000980 <_open>:



int _open(const char *name, int flags, int mode) {
 8000980:	b538      	push	{r3, r4, r5, lr}
	void* pret;
	int i;

	if (i_cur >= FD_OPNMAX) return -1;// No free slots check
 8000982:	4d0b      	ldr	r5, [pc, #44]	; (80009b0 <_open+0x30>)
 8000984:	682c      	ldr	r4, [r5, #0]
 8000986:	2c0b      	cmp	r4, #11
 8000988:	dc0d      	bgt.n	80009a6 <_open+0x26>

	i = i_cur;

	/* Check if there is someone out there with this name */
	pret = (struct CB_UART*)bsp_uart_open(name); // Check USART/UARTs
 800098a:	f003 fd1d 	bl	80043c8 <bsp_uart_open>
	if (pret != 0) 
 800098e:	b150      	cbz	r0, 80009a6 <_open+0x26>
	{ // Here, bsp_uart found the name and returned a control blk ptr
		fd_opn[i].pv = pret;
 8000990:	4b08      	ldr	r3, [pc, #32]	; (80009b4 <_open+0x34>)
 8000992:	f843 0034 	str.w	r0, [r3, r4, lsl #3]
		fd_opn[i].dev = 0;	// USART/UART group
 8000996:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 800099a:	2200      	movs	r2, #0
 800099c:	605a      	str	r2, [r3, #4]
		i_cur += 1;
 800099e:	682b      	ldr	r3, [r5, #0]
 80009a0:	3301      	adds	r3, #1
 80009a2:	602b      	str	r3, [r5, #0]
		return (i);
 80009a4:	e001      	b.n	80009aa <_open+0x2a>
	}
	// Place calls for others here, e.g. usb (device code 0)
	return -1;		// Nobody recognizes this name
 80009a6:	f04f 34ff 	mov.w	r4, #4294967295
}
 80009aa:	4620      	mov	r0, r4
 80009ac:	bd38      	pop	{r3, r4, r5, pc}
 80009ae:	bf00      	nop
 80009b0:	20000008 	.word	0x20000008
 80009b4:	20000b38 	.word	0x20000b38

080009b8 <_read>:

int _read(int fd, char *ptr, int len) {
	char* p = ptr;
	if (fd > FD_OPNMAX) return -1;
 80009b8:	280c      	cmp	r0, #12
	}
	// Place calls for others here, e.g. usb (device code 0)
	return -1;		// Nobody recognizes this name
}

int _read(int fd, char *ptr, int len) {
 80009ba:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80009be:	460c      	mov	r4, r1
 80009c0:	4615      	mov	r5, r2
	char* p = ptr;
	if (fd > FD_OPNMAX) return -1;
 80009c2:	dc23      	bgt.n	8000a0c <_read+0x54>
	if (fd < 0) return -1;
 80009c4:	2800      	cmp	r0, #0
 80009c6:	db25      	blt.n	8000a14 <_read+0x5c>

	if (fd_opn[fd].dev == 0) // Is it a USART/UART?
 80009c8:	4e14      	ldr	r6, [pc, #80]	; (8000a1c <_read+0x64>)
 80009ca:	eb06 03c0 	add.w	r3, r6, r0, lsl #3
 80009ce:	685b      	ldr	r3, [r3, #4]
 80009d0:	b92b      	cbnz	r3, 80009de <_read+0x26>
		return bsp_uart_getn_ptr((struct CB_UART*)fd_opn[fd].pv, ptr, len);
 80009d2:	f856 0030 	ldr.w	r0, [r6, r0, lsl #3]
		while(VCP_get_char_test()  &&  len > 0) 
		{VCP_get_char((u8*)p++); len -= 1;}
	}
	
	return p - ptr;
}
 80009d6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	char* p = ptr;
	if (fd > FD_OPNMAX) return -1;
	if (fd < 0) return -1;

	if (fd_opn[fd].dev == 0) // Is it a USART/UART?
		return bsp_uart_getn_ptr((struct CB_UART*)fd_opn[fd].pv, ptr, len);
 80009da:	f003 bec5 	b.w	8004768 <bsp_uart_getn_ptr>
	if (fd_opn[fd].dev == 1) // Is it a USB?
 80009de:	2b01      	cmp	r3, #1
 80009e0:	d110      	bne.n	8000a04 <_read+0x4c>
	{	
		/* Assumes the USB is on STDIN, STDOUT */
		if (!VCP_get_char_test()) {
 80009e2:	f000 f8ac 	bl	8000b3e <VCP_get_char_test>
 80009e6:	b1b8      	cbz	r0, 8000a18 <_read+0x60>
 80009e8:	4626      	mov	r6, r4
 80009ea:	e005      	b.n	80009f8 <_read+0x40>
			return 0;
		}
	
		while(VCP_get_char_test()  &&  len > 0) 
		{VCP_get_char((u8*)p++); len -= 1;}
 80009ec:	4630      	mov	r0, r6
 80009ee:	f000 f8b3 	bl	8000b58 <VCP_get_char>
 80009f2:	1c77      	adds	r7, r6, #1
 80009f4:	3d01      	subs	r5, #1
 80009f6:	463e      	mov	r6, r7
		/* Assumes the USB is on STDIN, STDOUT */
		if (!VCP_get_char_test()) {
			return 0;
		}
	
		while(VCP_get_char_test()  &&  len > 0) 
 80009f8:	f000 f8a1 	bl	8000b3e <VCP_get_char_test>
 80009fc:	b118      	cbz	r0, 8000a06 <_read+0x4e>
 80009fe:	2d00      	cmp	r5, #0
 8000a00:	dcf4      	bgt.n	80009ec <_read+0x34>
 8000a02:	e000      	b.n	8000a06 <_read+0x4e>
	// Place calls for others here, e.g. usb (device code 0)
	return -1;		// Nobody recognizes this name
}

int _read(int fd, char *ptr, int len) {
	char* p = ptr;
 8000a04:	460e      	mov	r6, r1
	
		while(VCP_get_char_test()  &&  len > 0) 
		{VCP_get_char((u8*)p++); len -= 1;}
	}
	
	return p - ptr;
 8000a06:	1b30      	subs	r0, r6, r4
 8000a08:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return -1;		// Nobody recognizes this name
}

int _read(int fd, char *ptr, int len) {
	char* p = ptr;
	if (fd > FD_OPNMAX) return -1;
 8000a0c:	f04f 30ff 	mov.w	r0, #4294967295
 8000a10:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fd < 0) return -1;
 8000a14:	f04f 30ff 	mov.w	r0, #4294967295
		while(VCP_get_char_test()  &&  len > 0) 
		{VCP_get_char((u8*)p++); len -= 1;}
	}
	
	return p - ptr;
}
 8000a18:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000a1c:	20000b38 	.word	0x20000b38

08000a20 <_sbrk_r>:
caddr_t _sbrk_r (struct _reent *r, int incr) {
	extern char   end asm ("end"); /* Defined by the linker.  */
	static char * heap_end;
	char *        prev_heap_end;

	if (heap_end == NULL)
 8000a20:	4b07      	ldr	r3, [pc, #28]	; (8000a40 <_sbrk_r+0x20>)
 8000a22:	681a      	ldr	r2, [r3, #0]
 8000a24:	b90a      	cbnz	r2, 8000a2a <_sbrk_r+0xa>
		heap_end = & end;
 8000a26:	4a07      	ldr	r2, [pc, #28]	; (8000a44 <_sbrk_r+0x24>)
 8000a28:	601a      	str	r2, [r3, #0]

	prev_heap_end = heap_end;
 8000a2a:	6818      	ldr	r0, [r3, #0]

	if (heap_end + incr > stack_ptr) {
 8000a2c:	466b      	mov	r3, sp
 8000a2e:	1841      	adds	r1, r0, r1
 8000a30:	4299      	cmp	r1, r3
		//errno = ENOMEM;
		return (caddr_t) -1;
	}

	heap_end += incr;
 8000a32:	bf96      	itet	ls
 8000a34:	4b02      	ldrls	r3, [pc, #8]	; (8000a40 <_sbrk_r+0x20>)

	prev_heap_end = heap_end;

	if (heap_end + incr > stack_ptr) {
		//errno = ENOMEM;
		return (caddr_t) -1;
 8000a36:	f04f 30ff 	movhi.w	r0, #4294967295
	}

	heap_end += incr;
 8000a3a:	6019      	strls	r1, [r3, #0]

	return (caddr_t) prev_heap_end;
}
 8000a3c:	4770      	bx	lr
 8000a3e:	bf00      	nop
 8000a40:	200007ec 	.word	0x200007ec
 8000a44:	20001ae8 	.word	0x20001ae8

08000a48 <_write>:

int _write(int fd, char *ptr, int len) 
{
 8000a48:	4603      	mov	r3, r0
	if (fd > 2)
 8000a4a:	2b02      	cmp	r3, #2

	return (caddr_t) prev_heap_end;
}

int _write(int fd, char *ptr, int len) 
{
 8000a4c:	b570      	push	{r4, r5, r6, lr}
 8000a4e:	4608      	mov	r0, r1
 8000a50:	4614      	mov	r4, r2
	if (fd > 2)
 8000a52:	dd0a      	ble.n	8000a6a <_write+0x22>
	{

		if (fd_opn[fd].dev == 0) // Is it a USART/UART?
 8000a54:	4d07      	ldr	r5, [pc, #28]	; (8000a74 <_write+0x2c>)
 8000a56:	eb05 06c3 	add.w	r6, r5, r3, lsl #3
 8000a5a:	6876      	ldr	r6, [r6, #4]
 8000a5c:	b92e      	cbnz	r6, 8000a6a <_write+0x22>
		{return bsp_uart_putn_ptr((struct CB_UART*)fd_opn[fd].pv, ptr, len);}
 8000a5e:	f855 0033 	ldr.w	r0, [r5, r3, lsl #3]
	}	
		// USB equivalent goes here-----
	VCP_send_buffer((u8*)ptr, len); 
	return len;
}
 8000a62:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
{
	if (fd > 2)
	{

		if (fd_opn[fd].dev == 0) // Is it a USART/UART?
		{return bsp_uart_putn_ptr((struct CB_UART*)fd_opn[fd].pv, ptr, len);}
 8000a66:	f003 bf0d 	b.w	8004884 <bsp_uart_putn_ptr>
	}	
		// USB equivalent goes here-----
	VCP_send_buffer((u8*)ptr, len); 
 8000a6a:	4621      	mov	r1, r4
 8000a6c:	f000 f866 	bl	8000b3c <VCP_send_buffer>
	return len;
}
 8000a70:	4620      	mov	r0, r4
 8000a72:	bd70      	pop	{r4, r5, r6, pc}
 8000a74:	20000b38 	.word	0x20000b38

08000a78 <VCP_Init>:
 * @param  None
 * @retval Result of the opeartion (USBD_OK in all cases)
 */
static uint16_t VCP_Init(void) {
	return USBD_OK;
}
 8000a78:	2000      	movs	r0, #0
 8000a7a:	4770      	bx	lr

08000a7c <VCP_DeInit>:
 * @param  None
 * @retval Result of the opeartion (USBD_OK in all cases)
 */
static uint16_t VCP_DeInit(void) {
	return USBD_OK;
}
 8000a7c:	2000      	movs	r0, #0
 8000a7e:	4770      	bx	lr

08000a80 <VCP_Ctrl>:
 * @param  Buf: Buffer containing command data (request parameters)
 * @param  Len: Number of data to be sent (in bytes)
 * @retval Result of the opeartion (USBD_OK in all cases)
 */
static uint16_t VCP_Ctrl(uint32_t Cmd, uint8_t* Buf, uint32_t Len) {
	switch (Cmd) {
 8000a80:	2821      	cmp	r0, #33	; 0x21
 8000a82:	d10f      	bne.n	8000aa4 <VCP_Ctrl+0x24>
	case SET_LINE_CODING:
		/* Not  needed for this driver */
		break;

	case GET_LINE_CODING:
		Buf[0] = (uint8_t) (linecoding.bitrate);
 8000a84:	4b08      	ldr	r3, [pc, #32]	; (8000aa8 <VCP_Ctrl+0x28>)
 8000a86:	681a      	ldr	r2, [r3, #0]
 8000a88:	700a      	strb	r2, [r1, #0]
		Buf[1] = (uint8_t) (linecoding.bitrate >> 8);
 8000a8a:	681a      	ldr	r2, [r3, #0]
 8000a8c:	0a12      	lsrs	r2, r2, #8
 8000a8e:	704a      	strb	r2, [r1, #1]
		Buf[2] = (uint8_t) (linecoding.bitrate >> 16);
 8000a90:	885a      	ldrh	r2, [r3, #2]
 8000a92:	708a      	strb	r2, [r1, #2]
		Buf[3] = (uint8_t) (linecoding.bitrate >> 24);
 8000a94:	78da      	ldrb	r2, [r3, #3]
 8000a96:	70ca      	strb	r2, [r1, #3]
		Buf[4] = linecoding.format;
 8000a98:	791a      	ldrb	r2, [r3, #4]
 8000a9a:	710a      	strb	r2, [r1, #4]
		Buf[5] = linecoding.paritytype;
 8000a9c:	795a      	ldrb	r2, [r3, #5]
 8000a9e:	714a      	strb	r2, [r1, #5]
		Buf[6] = linecoding.datatype;
 8000aa0:	799b      	ldrb	r3, [r3, #6]
 8000aa2:	718b      	strb	r3, [r1, #6]
	default:
		break;
	}

	return USBD_OK;
}
 8000aa4:	2000      	movs	r0, #0
 8000aa6:	4770      	bx	lr
 8000aa8:	2000000c 	.word	0x2000000c

08000aac <VCP_DataTx>:
 *         this function.
 * @param  Buf: Buffer of data to be sent
 * @param  Len: Number of data to be sent (in bytes)
 * @retval Result of the opeartion: USBD_OK if all operations are OK else VCP_FAIL
 */
static uint16_t VCP_DataTx(uint8_t* Buf, uint32_t Len) {
 8000aac:	b570      	push	{r4, r5, r6, lr}
	uint32_t i = 0;
 8000aae:	2300      	movs	r3, #0
	while (i < Len) {
 8000ab0:	e00c      	b.n	8000acc <VCP_DataTx+0x20>
		APP_Rx_Buffer[APP_Rx_ptr_in] = *(Buf + i);
 8000ab2:	4a08      	ldr	r2, [pc, #32]	; (8000ad4 <VCP_DataTx+0x28>)
 8000ab4:	5cc6      	ldrb	r6, [r0, r3]
 8000ab6:	6814      	ldr	r4, [r2, #0]
 8000ab8:	4d07      	ldr	r5, [pc, #28]	; (8000ad8 <VCP_DataTx+0x2c>)
 8000aba:	552e      	strb	r6, [r5, r4]
		APP_Rx_ptr_in++;
 8000abc:	3401      	adds	r4, #1
		i++;
 8000abe:	3301      	adds	r3, #1
		/* To avoid buffer overflow */
		if (APP_Rx_ptr_in == APP_RX_DATA_SIZE) {
 8000ac0:	f5b4 6f00 	cmp.w	r4, #2048	; 0x800
 */
static uint16_t VCP_DataTx(uint8_t* Buf, uint32_t Len) {
	uint32_t i = 0;
	while (i < Len) {
		APP_Rx_Buffer[APP_Rx_ptr_in] = *(Buf + i);
		APP_Rx_ptr_in++;
 8000ac4:	6014      	str	r4, [r2, #0]
		i++;
		/* To avoid buffer overflow */
		if (APP_Rx_ptr_in == APP_RX_DATA_SIZE) {
 8000ac6:	d101      	bne.n	8000acc <VCP_DataTx+0x20>
			APP_Rx_ptr_in = 0;
 8000ac8:	2400      	movs	r4, #0
 8000aca:	6014      	str	r4, [r2, #0]
 * @param  Len: Number of data to be sent (in bytes)
 * @retval Result of the opeartion: USBD_OK if all operations are OK else VCP_FAIL
 */
static uint16_t VCP_DataTx(uint8_t* Buf, uint32_t Len) {
	uint32_t i = 0;
	while (i < Len) {
 8000acc:	428b      	cmp	r3, r1
 8000ace:	d1f0      	bne.n	8000ab2 <VCP_DataTx+0x6>
			APP_Rx_ptr_in = 0;
		}
	}

	return USBD_OK;
}
 8000ad0:	2000      	movs	r0, #0
 8000ad2:	bd70      	pop	{r4, r5, r6, pc}
 8000ad4:	20000800 	.word	0x20000800
 8000ad8:	200012b0 	.word	0x200012b0

08000adc <VCP_DataRx>:
		APP_Tx_Buffer[APP_tx_ptr_head] = *(Buf + i);
		APP_tx_ptr_head++;
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
			APP_tx_ptr_head = 0;

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8000adc:	4b0c      	ldr	r3, [pc, #48]	; (8000b10 <VCP_DataRx+0x34>)
#define APP_TX_BUF_SIZE 128
uint8_t APP_Tx_Buffer[APP_TX_BUF_SIZE];
uint32_t APP_tx_ptr_head;
uint32_t APP_tx_ptr_tail;

static uint16_t VCP_DataRx(uint8_t* Buf, uint32_t Len) {
 8000ade:	b5f0      	push	{r4, r5, r6, r7, lr}
		APP_Tx_Buffer[APP_tx_ptr_head] = *(Buf + i);
		APP_tx_ptr_head++;
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
			APP_tx_ptr_head = 0;

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8000ae0:	681d      	ldr	r5, [r3, #0]
uint32_t APP_tx_ptr_tail;

static uint16_t VCP_DataRx(uint8_t* Buf, uint32_t Len) {
	uint32_t i;

	for (i = 0; i < Len; i++) {
 8000ae2:	2300      	movs	r3, #0
 8000ae4:	e00e      	b.n	8000b04 <VCP_DataRx+0x28>
		APP_Tx_Buffer[APP_tx_ptr_head] = *(Buf + i);
 8000ae6:	4a0b      	ldr	r2, [pc, #44]	; (8000b14 <VCP_DataRx+0x38>)
 8000ae8:	5cc7      	ldrb	r7, [r0, r3]
 8000aea:	6814      	ldr	r4, [r2, #0]
 8000aec:	4e0a      	ldr	r6, [pc, #40]	; (8000b18 <VCP_DataRx+0x3c>)
 8000aee:	5537      	strb	r7, [r6, r4]
		APP_tx_ptr_head++;
 8000af0:	3401      	adds	r4, #1
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
 8000af2:	2c80      	cmp	r4, #128	; 0x80
static uint16_t VCP_DataRx(uint8_t* Buf, uint32_t Len) {
	uint32_t i;

	for (i = 0; i < Len; i++) {
		APP_Tx_Buffer[APP_tx_ptr_head] = *(Buf + i);
		APP_tx_ptr_head++;
 8000af4:	6014      	str	r4, [r2, #0]
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
 8000af6:	d101      	bne.n	8000afc <VCP_DataRx+0x20>
			APP_tx_ptr_head = 0;
 8000af8:	3c80      	subs	r4, #128	; 0x80
 8000afa:	6014      	str	r4, [r2, #0]

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8000afc:	6812      	ldr	r2, [r2, #0]
 8000afe:	42aa      	cmp	r2, r5
 8000b00:	d004      	beq.n	8000b0c <VCP_DataRx+0x30>
uint32_t APP_tx_ptr_tail;

static uint16_t VCP_DataRx(uint8_t* Buf, uint32_t Len) {
	uint32_t i;

	for (i = 0; i < Len; i++) {
 8000b02:	3301      	adds	r3, #1
 8000b04:	428b      	cmp	r3, r1
 8000b06:	d1ee      	bne.n	8000ae6 <VCP_DataRx+0xa>

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
			return USBD_FAIL;
	}

	return USBD_OK;
 8000b08:	2000      	movs	r0, #0
 8000b0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		APP_tx_ptr_head++;
		if (APP_tx_ptr_head == APP_TX_BUF_SIZE)
			APP_tx_ptr_head = 0;

		if (APP_tx_ptr_head == APP_tx_ptr_tail)
			return USBD_FAIL;
 8000b0c:	2002      	movs	r0, #2
	}

	return USBD_OK;
}
 8000b0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000b10:	20000c1c 	.word	0x20000c1c
 8000b14:	20000c30 	.word	0x20000c30
 8000b18:	20000b9c 	.word	0x20000b9c

08000b1c <VCP_put_char>:
 *         Sends one char over the USB serial link.
 * @param  buf: char to be sent
 * @retval none
 */

void VCP_put_char(uint8_t buf) {
 8000b1c:	b507      	push	{r0, r1, r2, lr}
 8000b1e:	ab02      	add	r3, sp, #8
	VCP_DataTx(&buf, 1);
 8000b20:	2101      	movs	r1, #1
 *         Sends one char over the USB serial link.
 * @param  buf: char to be sent
 * @retval none
 */

void VCP_put_char(uint8_t buf) {
 8000b22:	f803 0d01 	strb.w	r0, [r3, #-1]!
	VCP_DataTx(&buf, 1);
 8000b26:	4618      	mov	r0, r3
 8000b28:	f7ff ffc0 	bl	8000aac <VCP_DataTx>
}
 8000b2c:	bd0e      	pop	{r1, r2, r3, pc}

08000b2e <VCP_send_str>:

void VCP_send_str(uint8_t* buf) {
	uint32_t i = 0;
 8000b2e:	2100      	movs	r1, #0
	while (*(buf + i)) {
 8000b30:	e000      	b.n	8000b34 <VCP_send_str+0x6>
		i++;
 8000b32:	3101      	adds	r1, #1
	VCP_DataTx(&buf, 1);
}

void VCP_send_str(uint8_t* buf) {
	uint32_t i = 0;
	while (*(buf + i)) {
 8000b34:	5c43      	ldrb	r3, [r0, r1]
 8000b36:	2b00      	cmp	r3, #0
 8000b38:	d1fb      	bne.n	8000b32 <VCP_send_str+0x4>
		i++;
	}
	VCP_DataTx(buf, i);
 8000b3a:	e7b7      	b.n	8000aac <VCP_DataTx>

08000b3c <VCP_send_buffer>:
}

void VCP_send_buffer(uint8_t* buf, int len) {
	VCP_DataTx(buf, len);
 8000b3c:	e7b6      	b.n	8000aac <VCP_DataTx>

08000b3e <VCP_get_char_test>:

	return USBD_OK;
}

int VCP_get_char_test(void) {
	return APP_tx_ptr_head != APP_tx_ptr_tail;
 8000b3e:	4b04      	ldr	r3, [pc, #16]	; (8000b50 <VCP_get_char_test+0x12>)
 8000b40:	6818      	ldr	r0, [r3, #0]
 8000b42:	4b04      	ldr	r3, [pc, #16]	; (8000b54 <VCP_get_char_test+0x16>)
 8000b44:	681b      	ldr	r3, [r3, #0]
}
 8000b46:	1ac0      	subs	r0, r0, r3
 8000b48:	bf18      	it	ne
 8000b4a:	2001      	movne	r0, #1
 8000b4c:	4770      	bx	lr
 8000b4e:	bf00      	nop
 8000b50:	20000c30 	.word	0x20000c30
 8000b54:	20000c1c 	.word	0x20000c1c

08000b58 <VCP_get_char>:

int VCP_get_char(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8000b58:	4b0a      	ldr	r3, [pc, #40]	; (8000b84 <VCP_get_char+0x2c>)
 8000b5a:	490b      	ldr	r1, [pc, #44]	; (8000b88 <VCP_get_char+0x30>)
 8000b5c:	681a      	ldr	r2, [r3, #0]
 8000b5e:	6809      	ldr	r1, [r1, #0]
 8000b60:	4291      	cmp	r1, r2
 8000b62:	d00b      	beq.n	8000b7c <VCP_get_char+0x24>
		return 0;

	*buf = APP_Tx_Buffer[APP_tx_ptr_tail];
 8000b64:	4909      	ldr	r1, [pc, #36]	; (8000b8c <VCP_get_char+0x34>)
 8000b66:	5c8a      	ldrb	r2, [r1, r2]
 8000b68:	7002      	strb	r2, [r0, #0]
	APP_tx_ptr_tail++;
 8000b6a:	681a      	ldr	r2, [r3, #0]
 8000b6c:	3201      	adds	r2, #1
	if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
 8000b6e:	2a80      	cmp	r2, #128	; 0x80
int VCP_get_char(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
		return 0;

	*buf = APP_Tx_Buffer[APP_tx_ptr_tail];
	APP_tx_ptr_tail++;
 8000b70:	601a      	str	r2, [r3, #0]
	if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
 8000b72:	d105      	bne.n	8000b80 <VCP_get_char+0x28>
		APP_tx_ptr_tail = 0;
 8000b74:	3a80      	subs	r2, #128	; 0x80
 8000b76:	601a      	str	r2, [r3, #0]

	return 1;
 8000b78:	2001      	movs	r0, #1
 8000b7a:	4770      	bx	lr
	return APP_tx_ptr_head != APP_tx_ptr_tail;
}

int VCP_get_char(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
		return 0;
 8000b7c:	2000      	movs	r0, #0
 8000b7e:	4770      	bx	lr
	*buf = APP_Tx_Buffer[APP_tx_ptr_tail];
	APP_tx_ptr_tail++;
	if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
		APP_tx_ptr_tail = 0;

	return 1;
 8000b80:	2001      	movs	r0, #1
}
 8000b82:	4770      	bx	lr
 8000b84:	20000c1c 	.word	0x20000c1c
 8000b88:	20000c30 	.word	0x20000c30
 8000b8c:	20000b9c 	.word	0x20000b9c

08000b90 <VCP_get_string>:

int VCP_get_string(uint8_t *buf) {
 8000b90:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8000b92:	4a1f      	ldr	r2, [pc, #124]	; (8000c10 <VCP_get_string+0x80>)
 8000b94:	4c1f      	ldr	r4, [pc, #124]	; (8000c14 <VCP_get_string+0x84>)
 8000b96:	6813      	ldr	r3, [r2, #0]
 8000b98:	6821      	ldr	r1, [r4, #0]
 8000b9a:	4299      	cmp	r1, r3
 8000b9c:	4626      	mov	r6, r4
 8000b9e:	d108      	bne.n	8000bb2 <VCP_get_string+0x22>
 8000ba0:	e033      	b.n	8000c0a <VCP_get_string+0x7a>
		return 0;

	while (!APP_Tx_Buffer[APP_tx_ptr_tail]
			|| APP_Tx_Buffer[APP_tx_ptr_tail] == '\n'
			|| APP_Tx_Buffer[APP_tx_ptr_tail] == '\r') {
		APP_tx_ptr_tail++;
 8000ba2:	3301      	adds	r3, #1
		if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
			APP_tx_ptr_tail = 0;
 8000ba4:	2b80      	cmp	r3, #128	; 0x80
 8000ba6:	bf08      	it	eq
 8000ba8:	2300      	moveq	r3, #0
		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8000baa:	4299      	cmp	r1, r3
 8000bac:	d101      	bne.n	8000bb2 <VCP_get_string+0x22>
 8000bae:	6011      	str	r1, [r2, #0]
 8000bb0:	e02b      	b.n	8000c0a <VCP_get_string+0x7a>

int VCP_get_string(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
		return 0;

	while (!APP_Tx_Buffer[APP_tx_ptr_tail]
 8000bb2:	4c19      	ldr	r4, [pc, #100]	; (8000c18 <VCP_get_string+0x88>)
			|| APP_Tx_Buffer[APP_tx_ptr_tail] == '\n'
			|| APP_Tx_Buffer[APP_tx_ptr_tail] == '\r') {
		APP_tx_ptr_tail++;
		if (APP_tx_ptr_tail == APP_TX_BUF_SIZE)
			APP_tx_ptr_tail = 0;
		if (APP_tx_ptr_head == APP_tx_ptr_tail)
 8000bb4:	5ce5      	ldrb	r5, [r4, r3]
 8000bb6:	2d0d      	cmp	r5, #13
 8000bb8:	4625      	mov	r5, r4
 8000bba:	d803      	bhi.n	8000bc4 <VCP_get_string+0x34>
 8000bbc:	56e4      	ldrsb	r4, [r4, r3]
 8000bbe:	4f17      	ldr	r7, [pc, #92]	; (8000c1c <VCP_get_string+0x8c>)
 8000bc0:	40a7      	lsls	r7, r4
 8000bc2:	d4ee      	bmi.n	8000ba2 <VCP_get_string+0x12>
 8000bc4:	6013      	str	r3, [r2, #0]

int VCP_get_string(uint8_t *buf) {
	if (APP_tx_ptr_head == APP_tx_ptr_tail)
		return 0;

	while (!APP_Tx_Buffer[APP_tx_ptr_tail]
 8000bc6:	2300      	movs	r3, #0
			return 0;
	}

	int i = 0;
	do {
		*(buf + i) = APP_Tx_Buffer[i + APP_tx_ptr_tail];
 8000bc8:	18ec      	adds	r4, r5, r3
 8000bca:	6811      	ldr	r1, [r2, #0]
 8000bcc:	5c61      	ldrb	r1, [r4, r1]
 8000bce:	54c1      	strb	r1, [r0, r3]
		i++;

		if ((APP_tx_ptr_tail + i) == APP_TX_BUF_SIZE)
 8000bd0:	6811      	ldr	r1, [r2, #0]
	}

	int i = 0;
	do {
		*(buf + i) = APP_Tx_Buffer[i + APP_tx_ptr_tail];
		i++;
 8000bd2:	3301      	adds	r3, #1

		if ((APP_tx_ptr_tail + i) == APP_TX_BUF_SIZE)
 8000bd4:	185c      	adds	r4, r3, r1
 8000bd6:	2c80      	cmp	r4, #128	; 0x80
			i = -APP_tx_ptr_tail;
 8000bd8:	bf08      	it	eq
 8000bda:	424b      	negeq	r3, r1
		if (APP_tx_ptr_head == (APP_tx_ptr_tail + i))
 8000bdc:	6834      	ldr	r4, [r6, #0]
 8000bde:	1859      	adds	r1, r3, r1
 8000be0:	428c      	cmp	r4, r1
 8000be2:	d012      	beq.n	8000c0a <VCP_get_string+0x7a>
 8000be4:	5c6c      	ldrb	r4, [r5, r1]
 8000be6:	2c0d      	cmp	r4, #13
 8000be8:	d8ee      	bhi.n	8000bc8 <VCP_get_string+0x38>
 8000bea:	4c0b      	ldr	r4, [pc, #44]	; (8000c18 <VCP_get_string+0x88>)
 8000bec:	5661      	ldrsb	r1, [r4, r1]
 8000bee:	4c0b      	ldr	r4, [pc, #44]	; (8000c1c <VCP_get_string+0x8c>)
 8000bf0:	408c      	lsls	r4, r1
 8000bf2:	d5e9      	bpl.n	8000bc8 <VCP_get_string+0x38>

	} while (APP_Tx_Buffer[APP_tx_ptr_tail + i]
			&& APP_Tx_Buffer[APP_tx_ptr_tail + i] != '\n'
			&& APP_Tx_Buffer[APP_tx_ptr_tail + i] != '\r');

	*(buf + i) = 0;
 8000bf4:	2100      	movs	r1, #0
 8000bf6:	54c1      	strb	r1, [r0, r3]
	APP_tx_ptr_tail += i;
 8000bf8:	6811      	ldr	r1, [r2, #0]
 8000bfa:	1859      	adds	r1, r3, r1
	if (APP_tx_ptr_tail >= APP_TX_BUF_SIZE)
 8000bfc:	297f      	cmp	r1, #127	; 0x7f
	} while (APP_Tx_Buffer[APP_tx_ptr_tail + i]
			&& APP_Tx_Buffer[APP_tx_ptr_tail + i] != '\n'
			&& APP_Tx_Buffer[APP_tx_ptr_tail + i] != '\r');

	*(buf + i) = 0;
	APP_tx_ptr_tail += i;
 8000bfe:	6011      	str	r1, [r2, #0]
	if (APP_tx_ptr_tail >= APP_TX_BUF_SIZE)
 8000c00:	d904      	bls.n	8000c0c <VCP_get_string+0x7c>
		APP_tx_ptr_tail -= APP_TX_BUF_SIZE;
 8000c02:	4a03      	ldr	r2, [pc, #12]	; (8000c10 <VCP_get_string+0x80>)
 8000c04:	3980      	subs	r1, #128	; 0x80
 8000c06:	6011      	str	r1, [r2, #0]
 8000c08:	e000      	b.n	8000c0c <VCP_get_string+0x7c>
		i++;

		if ((APP_tx_ptr_tail + i) == APP_TX_BUF_SIZE)
			i = -APP_tx_ptr_tail;
		if (APP_tx_ptr_head == (APP_tx_ptr_tail + i))
			return 0;
 8000c0a:	2300      	movs	r3, #0
	*(buf + i) = 0;
	APP_tx_ptr_tail += i;
	if (APP_tx_ptr_tail >= APP_TX_BUF_SIZE)
		APP_tx_ptr_tail -= APP_TX_BUF_SIZE;
	return i;
}
 8000c0c:	4618      	mov	r0, r3
 8000c0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000c10:	20000c1c 	.word	0x20000c1c
 8000c14:	20000c30 	.word	0x20000c30
 8000c18:	20000b9c 	.word	0x20000b9c
 8000c1c:	80240000 	.word	0x80240000

08000c20 <EVAL_COM_IRQHandler>:
 * @param  None.
 * @retval None.
 */
void EVAL_COM_IRQHandler(void) {

}
 8000c20:	4770      	bx	lr
 8000c22:	bf00      	nop

08000c24 <NMI_Handler>:
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}
 8000c24:	4770      	bx	lr

08000c26 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8000c26:	e7fe      	b.n	8000c26 <HardFault_Handler>

08000c28 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8000c28:	e7fe      	b.n	8000c28 <MemManage_Handler>

08000c2a <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 8000c2a:	e7fe      	b.n	8000c2a <BusFault_Handler>

08000c2c <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8000c2c:	e7fe      	b.n	8000c2c <UsageFault_Handler>

08000c2e <SVC_Handler>:
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
}
 8000c2e:	4770      	bx	lr

08000c30 <DebugMon_Handler>:
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
}
 8000c30:	4770      	bx	lr

08000c32 <PendSV_Handler>:
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
}
 8000c32:	4770      	bx	lr

08000c34 <SysTick_Handler>:
  * @retval None
  */
void SysTick_Handler(void)
{

	timing_handler();
 8000c34:	f000 b91e 	b.w	8000e74 <timing_handler>

08000c38 <OTG_FS_WKUP_IRQHandler>:
/*  file (startup_stm32f4xx.s).                                               */
/******************************************************************************/

#ifdef USE_USB_OTG_FS
void OTG_FS_WKUP_IRQHandler(void)
{
 8000c38:	b510      	push	{r4, lr}
  if(USB_OTG_dev.cfg.low_power)
 8000c3a:	4c09      	ldr	r4, [pc, #36]	; (8000c60 <OTG_FS_WKUP_IRQHandler+0x28>)
 8000c3c:	7aa3      	ldrb	r3, [r4, #10]
 8000c3e:	b14b      	cbz	r3, 8000c54 <OTG_FS_WKUP_IRQHandler+0x1c>
  {
    *(uint32_t *)(0xE000ED10) &= 0xFFFFFFF9 ;
 8000c40:	4b08      	ldr	r3, [pc, #32]	; (8000c64 <OTG_FS_WKUP_IRQHandler+0x2c>)
 8000c42:	681a      	ldr	r2, [r3, #0]
 8000c44:	f022 0206 	bic.w	r2, r2, #6
 8000c48:	601a      	str	r2, [r3, #0]
    SystemInit();
 8000c4a:	f000 f813 	bl	8000c74 <SystemInit>
    USB_OTG_UngateClock(&USB_OTG_dev);
 8000c4e:	4620      	mov	r0, r4
 8000c50:	f001 fcee 	bl	8002630 <USB_OTG_UngateClock>
  }
  EXTI_ClearITPendingBit(EXTI_Line18);
 8000c54:	f44f 2080 	mov.w	r0, #262144	; 0x40000
}
 8000c58:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  {
    *(uint32_t *)(0xE000ED10) &= 0xFFFFFFF9 ;
    SystemInit();
    USB_OTG_UngateClock(&USB_OTG_dev);
  }
  EXTI_ClearITPendingBit(EXTI_Line18);
 8000c5c:	f000 bc48 	b.w	80014f0 <EXTI_ClearITPendingBit>
 8000c60:	20000c34 	.word	0x20000c34
 8000c64:	e000ed10 	.word	0xe000ed10

08000c68 <OTG_FS_IRQHandler>:
void OTG_HS_IRQHandler(void)
#else
void OTG_FS_IRQHandler(void)
#endif
{
  USBD_OTG_ISR_Handler (&USB_OTG_dev);
 8000c68:	4801      	ldr	r0, [pc, #4]	; (8000c70 <OTG_FS_IRQHandler+0x8>)
 8000c6a:	f001 bf55 	b.w	8002b18 <USBD_OTG_ISR_Handler>
 8000c6e:	bf00      	nop
 8000c70:	20000c34 	.word	0x20000c34

08000c74 <SystemInit>:
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
	SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
#endif
	/* Reset the RCC clock configuration to the default reset state ------------*/
	/* Set HSION bit */
	RCC->CR |= (uint32_t)0x00000001;
 8000c74:	4b34      	ldr	r3, [pc, #208]	; (8000d48 <SystemInit+0xd4>)
 8000c76:	681a      	ldr	r2, [r3, #0]
 8000c78:	f042 0201 	orr.w	r2, r2, #1
 8000c7c:	601a      	str	r2, [r3, #0]

	/* Reset CFGR register */
	RCC->CFGR = 0x00000000;
 8000c7e:	2200      	movs	r2, #0
 8000c80:	609a      	str	r2, [r3, #8]

	/* Reset HSEON, CSSON and PLLON bits */
	RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000c82:	6819      	ldr	r1, [r3, #0]
 8000c84:	f021 7184 	bic.w	r1, r1, #17301504	; 0x1080000
 8000c88:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 8000c8c:	6019      	str	r1, [r3, #0]

	/* Reset PLLCFGR register */
	RCC->PLLCFGR = 0x24003010;
 8000c8e:	492f      	ldr	r1, [pc, #188]	; (8000d4c <SystemInit+0xd8>)
 8000c90:	6059      	str	r1, [r3, #4]

	/* Reset HSEBYP bit */
	RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000c92:	6819      	ldr	r1, [r3, #0]
 *         SystemFrequency variable.
 * @param  None
 * @retval None
 */
void SystemInit(void)
{
 8000c94:	b082      	sub	sp, #8

	/* Reset PLLCFGR register */
	RCC->PLLCFGR = 0x24003010;

	/* Reset HSEBYP bit */
	RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000c96:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 8000c9a:	6019      	str	r1, [r3, #0]

	/* Disable all interrupts */
	RCC->CIR = 0x00000000;
 8000c9c:	60da      	str	r2, [r3, #12]
static void SetSysClock(void)
{
	/******************************************************************************/
	/*            PLL (clocked by HSE) used as System clock source                */
	/******************************************************************************/
	__IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 8000c9e:	9201      	str	r2, [sp, #4]
 8000ca0:	9200      	str	r2, [sp, #0]

	/* Enable HSE */
	RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8000ca2:	681a      	ldr	r2, [r3, #0]
 8000ca4:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8000ca8:	601a      	str	r2, [r3, #0]

	/* Wait till HSE is ready and if Time out is reached exit */
	do
	{
		HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8000caa:	4b27      	ldr	r3, [pc, #156]	; (8000d48 <SystemInit+0xd4>)
 8000cac:	681a      	ldr	r2, [r3, #0]
 8000cae:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 8000cb2:	9200      	str	r2, [sp, #0]
		StartUpCounter++;
 8000cb4:	9a01      	ldr	r2, [sp, #4]
 8000cb6:	3201      	adds	r2, #1
 8000cb8:	9201      	str	r2, [sp, #4]
	} while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8000cba:	9a00      	ldr	r2, [sp, #0]
 8000cbc:	b91a      	cbnz	r2, 8000cc6 <SystemInit+0x52>
 8000cbe:	9a01      	ldr	r2, [sp, #4]
 8000cc0:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 8000cc4:	d1f1      	bne.n	8000caa <SystemInit+0x36>

	if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8000cc6:	681b      	ldr	r3, [r3, #0]
 8000cc8:	f413 3300 	ands.w	r3, r3, #131072	; 0x20000
	{
		HSEStatus = (uint32_t)0x01;
 8000ccc:	bf18      	it	ne
 8000cce:	2301      	movne	r3, #1
	}
	else
	{
		HSEStatus = (uint32_t)0x00;
 8000cd0:	9300      	str	r3, [sp, #0]
	}

	if (HSEStatus == (uint32_t)0x01)
 8000cd2:	9b00      	ldr	r3, [sp, #0]
 8000cd4:	2b01      	cmp	r3, #1
 8000cd6:	d130      	bne.n	8000d3a <SystemInit+0xc6>
	{
		/* Select regulator voltage output Scale 1 mode, System frequency up to 168 MHz */
		RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 8000cd8:	4b1b      	ldr	r3, [pc, #108]	; (8000d48 <SystemInit+0xd4>)
 8000cda:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000cdc:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000ce0:	641a      	str	r2, [r3, #64]	; 0x40
		PWR->CR |= PWR_CR_VOS;
 8000ce2:	4a1b      	ldr	r2, [pc, #108]	; (8000d50 <SystemInit+0xdc>)
 8000ce4:	6811      	ldr	r1, [r2, #0]
 8000ce6:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 8000cea:	6011      	str	r1, [r2, #0]

		/* HCLK = SYSCLK / 1*/
		RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 8000cec:	689a      	ldr	r2, [r3, #8]
 8000cee:	609a      	str	r2, [r3, #8]

		/* PCLK2 = HCLK / 2*/
		RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 8000cf0:	689a      	ldr	r2, [r3, #8]
 8000cf2:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8000cf6:	609a      	str	r2, [r3, #8]

		/* PCLK1 = HCLK / 4*/
		RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 8000cf8:	689a      	ldr	r2, [r3, #8]
 8000cfa:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 8000cfe:	609a      	str	r2, [r3, #8]

		/* Configure the main PLL */
		RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8000d00:	4a14      	ldr	r2, [pc, #80]	; (8000d54 <SystemInit+0xe0>)
 8000d02:	605a      	str	r2, [r3, #4]
				(RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

		/* Enable the main PLL */
		RCC->CR |= RCC_CR_PLLON;
 8000d04:	681a      	ldr	r2, [r3, #0]
 8000d06:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000d0a:	601a      	str	r2, [r3, #0]

		/* Wait till the main PLL is ready */
		while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8000d0c:	4b0e      	ldr	r3, [pc, #56]	; (8000d48 <SystemInit+0xd4>)
 8000d0e:	681a      	ldr	r2, [r3, #0]
 8000d10:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8000d14:	d0fa      	beq.n	8000d0c <SystemInit+0x98>
		{
		}

		/* Configure Flash prefetch, Instruction cache, Data cache and wait state */
		FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 8000d16:	4a10      	ldr	r2, [pc, #64]	; (8000d58 <SystemInit+0xe4>)
 8000d18:	f240 6105 	movw	r1, #1541	; 0x605
 8000d1c:	6011      	str	r1, [r2, #0]

		/* Select the main PLL as system clock source */
		RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8000d1e:	689a      	ldr	r2, [r3, #8]
 8000d20:	f022 0203 	bic.w	r2, r2, #3
 8000d24:	609a      	str	r2, [r3, #8]
		RCC->CFGR |= RCC_CFGR_SW_PLL;
 8000d26:	689a      	ldr	r2, [r3, #8]
 8000d28:	f042 0202 	orr.w	r2, r2, #2
 8000d2c:	609a      	str	r2, [r3, #8]

		/* Wait till the main PLL is used as system clock source */
		while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 8000d2e:	4b06      	ldr	r3, [pc, #24]	; (8000d48 <SystemInit+0xd4>)
 8000d30:	689b      	ldr	r3, [r3, #8]
 8000d32:	f003 030c 	and.w	r3, r3, #12
 8000d36:	2b08      	cmp	r3, #8
 8000d38:	d1f9      	bne.n	8000d2e <SystemInit+0xba>

	/* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
	SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
	SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8000d3a:	4b08      	ldr	r3, [pc, #32]	; (8000d5c <SystemInit+0xe8>)
 8000d3c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8000d40:	609a      	str	r2, [r3, #8]
#endif
}
 8000d42:	b002      	add	sp, #8
 8000d44:	4770      	bx	lr
 8000d46:	bf00      	nop
 8000d48:	40023800 	.word	0x40023800
 8000d4c:	24003010 	.word	0x24003010
 8000d50:	40007000 	.word	0x40007000
 8000d54:	07405408 	.word	0x07405408
 8000d58:	40023c00 	.word	0x40023c00
 8000d5c:	e000ed00 	.word	0xe000ed00

08000d60 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate(void)
{
	uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

	/* Get SYSCLK source -------------------------------------------------------*/
	tmp = RCC->CFGR & RCC_CFGR_SWS;
 8000d60:	4a1e      	ldr	r2, [pc, #120]	; (8000ddc <SystemCoreClockUpdate+0x7c>)
 8000d62:	4b1f      	ldr	r3, [pc, #124]	; (8000de0 <SystemCoreClockUpdate+0x80>)
 8000d64:	6891      	ldr	r1, [r2, #8]
 8000d66:	f001 010c 	and.w	r1, r1, #12

	switch (tmp)
 8000d6a:	2904      	cmp	r1, #4
 8000d6c:	d003      	beq.n	8000d76 <SystemCoreClockUpdate+0x16>
 8000d6e:	2908      	cmp	r1, #8
 8000d70:	d003      	beq.n	8000d7a <SystemCoreClockUpdate+0x1a>
 8000d72:	4a1c      	ldr	r2, [pc, #112]	; (8000de4 <SystemCoreClockUpdate+0x84>)
 8000d74:	e025      	b.n	8000dc2 <SystemCoreClockUpdate+0x62>
	{
	case 0x00:  /* HSI used as system clock source */
		SystemCoreClock = HSI_VALUE;
		break;
	case 0x04:  /* HSE used as system clock source */
		SystemCoreClock = HSE_VALUE;
 8000d76:	4a1c      	ldr	r2, [pc, #112]	; (8000de8 <SystemCoreClockUpdate+0x88>)
 8000d78:	e023      	b.n	8000dc2 <SystemCoreClockUpdate+0x62>
	case 0x08:  /* PLL used as system clock source */

		/* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
		 */
		pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8000d7a:	6851      	ldr	r1, [r2, #4]
		pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8000d7c:	6850      	ldr	r0, [r2, #4]

		if (pllsource != 0)
 8000d7e:	f411 0f80 	tst.w	r1, #4194304	; 0x400000

		/* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
		 */
		pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
		pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8000d82:	f000 003f 	and.w	r0, r0, #63	; 0x3f

		if (pllsource != 0)
 8000d86:	d00a      	beq.n	8000d9e <SystemCoreClockUpdate+0x3e>
		{
			/* HSE used as PLL clock source */
			pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8000d88:	6852      	ldr	r2, [r2, #4]
 8000d8a:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 8000d8e:	ea02 0101 	and.w	r1, r2, r1
 8000d92:	4a15      	ldr	r2, [pc, #84]	; (8000de8 <SystemCoreClockUpdate+0x88>)
 8000d94:	0989      	lsrs	r1, r1, #6
 8000d96:	fbb2 f2f0 	udiv	r2, r2, r0
 8000d9a:	434a      	muls	r2, r1
 8000d9c:	e009      	b.n	8000db2 <SystemCoreClockUpdate+0x52>
		}
		else
		{
			/* HSI used as PLL clock source */
			pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8000d9e:	6851      	ldr	r1, [r2, #4]
 8000da0:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 8000da4:	ea01 0202 	and.w	r2, r1, r2
 8000da8:	490e      	ldr	r1, [pc, #56]	; (8000de4 <SystemCoreClockUpdate+0x84>)
 8000daa:	0992      	lsrs	r2, r2, #6
 8000dac:	fbb1 f0f0 	udiv	r0, r1, r0
 8000db0:	4342      	muls	r2, r0
		}

		pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8000db2:	490a      	ldr	r1, [pc, #40]	; (8000ddc <SystemCoreClockUpdate+0x7c>)
 8000db4:	6849      	ldr	r1, [r1, #4]
 8000db6:	f401 3140 	and.w	r1, r1, #196608	; 0x30000
 8000dba:	0bc9      	lsrs	r1, r1, #15
 8000dbc:	3102      	adds	r1, #2
		SystemCoreClock = pllvco/pllp;
 8000dbe:	fbb2 f2f1 	udiv	r2, r2, r1
 8000dc2:	601a      	str	r2, [r3, #0]
		SystemCoreClock = HSI_VALUE;
		break;
	}
	/* Compute HCLK frequency --------------------------------------------------*/
	/* Get HCLK prescaler */
	tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8000dc4:	4a05      	ldr	r2, [pc, #20]	; (8000ddc <SystemCoreClockUpdate+0x7c>)
	/* HCLK frequency */
	SystemCoreClock >>= tmp;
 8000dc6:	6819      	ldr	r1, [r3, #0]
		SystemCoreClock = HSI_VALUE;
		break;
	}
	/* Compute HCLK frequency --------------------------------------------------*/
	/* Get HCLK prescaler */
	tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8000dc8:	6892      	ldr	r2, [r2, #8]
 8000dca:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8000dce:	eb03 1212 	add.w	r2, r3, r2, lsr #4
 8000dd2:	7912      	ldrb	r2, [r2, #4]
	/* HCLK frequency */
	SystemCoreClock >>= tmp;
 8000dd4:	fa31 f202 	lsrs.w	r2, r1, r2
 8000dd8:	601a      	str	r2, [r3, #0]
}
 8000dda:	4770      	bx	lr
 8000ddc:	40023800 	.word	0x40023800
 8000de0:	20000028 	.word	0x20000028
 8000de4:	00f42400 	.word	0x00f42400
 8000de8:	017d7840 	.word	0x017d7840

08000dec <usb1_init>:
void usb1_init(void)
{
	GPIO_InitTypeDef  GPIO_InitStructure;

	// ---------- SysTick timer -------- //
	if (SysTick_Config(SystemCoreClock / 1000)) {
 8000dec:	4b19      	ldr	r3, [pc, #100]	; (8000e54 <usb1_init+0x68>)
 8000dee:	681a      	ldr	r2, [r3, #0]
 8000df0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000df4:	fbb2 f2f3 	udiv	r2, r2, r3
__ALIGN_BEGIN USB_OTG_CORE_HANDLE  USB_OTG_dev __ALIGN_END;

// Private function prototypes

void usb1_init(void)
{
 8000df8:	b530      	push	{r4, r5, lr}
 */
static __INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
 8000dfa:	4b17      	ldr	r3, [pc, #92]	; (8000e58 <usb1_init+0x6c>)
 8000dfc:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8000e00:	3a01      	subs	r2, #1
 8000e02:	605a      	str	r2, [r3, #4]
    \param [in]  priority  Priority to set
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8000e04:	4a15      	ldr	r2, [pc, #84]	; (8000e5c <usb1_init+0x70>)
 8000e06:	21f0      	movs	r1, #240	; 0xf0
 8000e08:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 8000e0c:	2400      	movs	r4, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000e0e:	2207      	movs	r2, #7
 8000e10:	b085      	sub	sp, #20
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 8000e12:	609c      	str	r4, [r3, #8]
		while (1){};
	}

	// ---------- GPIO -------- //
	// GPIOD Periph clock enable
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 8000e14:	2008      	movs	r0, #8
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000e16:	601a      	str	r2, [r3, #0]
 8000e18:	39ef      	subs	r1, #239	; 0xef
 8000e1a:	f000 f9bb 	bl	8001194 <RCC_AHB1PeriphClockCmd>

	// Configure PD12, PD13, PD14 and PD15 in output pushpull mode
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15;
 8000e1e:	f44f 4370 	mov.w	r3, #61440	; 0xf000
 8000e22:	9302      	str	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8000e24:	2501      	movs	r5, #1
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8000e26:	2303      	movs	r3, #3
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 8000e28:	a902      	add	r1, sp, #8
 8000e2a:	480d      	ldr	r0, [pc, #52]	; (8000e60 <usb1_init+0x74>)

	// Configure PD12, PD13, PD14 and PD15 in output pushpull mode
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8000e2c:	f88d 300d 	strb.w	r3, [sp, #13]
	// GPIOD Periph clock enable
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);

	// Configure PD12, PD13, PD14 and PD15 in output pushpull mode
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8000e30:	f88d 500c 	strb.w	r5, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000e34:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8000e38:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 8000e3c:	f000 fbea 	bl	8001614 <GPIO_Init>

	// ------------- USB -------------- //
	USBD_Init(&USB_OTG_dev,
 8000e40:	4b08      	ldr	r3, [pc, #32]	; (8000e64 <usb1_init+0x78>)
 8000e42:	4809      	ldr	r0, [pc, #36]	; (8000e68 <usb1_init+0x7c>)
 8000e44:	9300      	str	r3, [sp, #0]
 8000e46:	4629      	mov	r1, r5
 8000e48:	4a08      	ldr	r2, [pc, #32]	; (8000e6c <usb1_init+0x80>)
 8000e4a:	4b09      	ldr	r3, [pc, #36]	; (8000e70 <usb1_init+0x84>)
 8000e4c:	f002 fa06 	bl	800325c <USBD_Init>
	            &USR_desc,
	            &USBD_CDC_cb,
	            &USR_cb);

	return;
}
 8000e50:	b005      	add	sp, #20
 8000e52:	bd30      	pop	{r4, r5, pc}
 8000e54:	20000028 	.word	0x20000028
 8000e58:	e000e010 	.word	0xe000e010
 8000e5c:	e000ed00 	.word	0xe000ed00
 8000e60:	40020c00 	.word	0x40020c00
 8000e64:	2000003c 	.word	0x2000003c
 8000e68:	20000c34 	.word	0x20000c34
 8000e6c:	20000070 	.word	0x20000070
 8000e70:	200000f0 	.word	0x200000f0

08000e74 <timing_handler>:
/*
 * Called from systick handler.  Call his ticker.
 */
void timing_handler()
{
}
 8000e74:	4770      	bx	lr

08000e76 <_init>:

/*
 * Dummy function to avoid compiler error
 */
void _init() {}
 8000e76:	4770      	bx	lr

08000e78 <USBD_USR_Init>:
* @retval None
*/
void USBD_USR_Init(void)
{   

}
 8000e78:	4770      	bx	lr

08000e7a <USBD_USR_DeviceReset>:
     break;
 default:
     break;
     
 }
}
 8000e7a:	4770      	bx	lr

08000e7c <USBD_USR_DeviceConfigured>:
* @param  None
* @retval Staus
*/
void USBD_USR_DeviceConfigured (void)
{
}
 8000e7c:	4770      	bx	lr

08000e7e <USBD_USR_DeviceConnected>:
* @param  None
* @retval Staus
*/
void USBD_USR_DeviceConnected (void)
{
}
 8000e7e:	4770      	bx	lr

08000e80 <USBD_USR_DeviceDisconnected>:
* @param  None
* @retval Staus
*/
void USBD_USR_DeviceDisconnected (void)
{
}
 8000e80:	4770      	bx	lr

08000e82 <USBD_USR_DeviceSuspended>:
* @retval None
*/
void USBD_USR_DeviceSuspended(void)
{
  /* Users can do their application actions here for the USB-Reset */
}
 8000e82:	4770      	bx	lr

08000e84 <USBD_USR_DeviceResumed>:
* @retval None
*/
void USBD_USR_DeviceResumed(void)
{
  /* Users can do their application actions here for the USB-Reset */
}
 8000e84:	4770      	bx	lr
	...

08000e88 <USBD_USR_DeviceDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_DeviceDescriptor( uint8_t speed , uint16_t *length)
{
  *length = sizeof(USBD_DeviceDesc);
 8000e88:	2312      	movs	r3, #18
 8000e8a:	800b      	strh	r3, [r1, #0]
  return USBD_DeviceDesc;
}
 8000e8c:	4800      	ldr	r0, [pc, #0]	; (8000e90 <USBD_USR_DeviceDescriptor+0x8>)
 8000e8e:	4770      	bx	lr
 8000e90:	20000058 	.word	0x20000058

08000e94 <USBD_USR_LangIDStrDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_LangIDStrDescriptor( uint8_t speed , uint16_t *length)
{
  *length =  sizeof(USBD_LangIDDesc);  
 8000e94:	2304      	movs	r3, #4
 8000e96:	800b      	strh	r3, [r1, #0]
  return USBD_LangIDDesc;
}
 8000e98:	4800      	ldr	r0, [pc, #0]	; (8000e9c <USBD_USR_LangIDStrDescriptor+0x8>)
 8000e9a:	4770      	bx	lr
 8000e9c:	2000006a 	.word	0x2000006a

08000ea0 <USBD_USR_InterfaceStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_InterfaceStrDescriptor( uint8_t speed , uint16_t *length)
{
 8000ea0:	460a      	mov	r2, r1
 8000ea2:	b508      	push	{r3, lr}
  {
    USBD_GetString ((uint8_t*)USBD_INTERFACE_HS_STRING, USBD_StrDesc, length);
  }
  else
  {
    USBD_GetString ((uint8_t*)USBD_INTERFACE_FS_STRING, USBD_StrDesc, length);
 8000ea4:	4802      	ldr	r0, [pc, #8]	; (8000eb0 <USBD_USR_InterfaceStrDescriptor+0x10>)
 8000ea6:	4903      	ldr	r1, [pc, #12]	; (8000eb4 <USBD_USR_InterfaceStrDescriptor+0x14>)
 8000ea8:	f002 fcb2 	bl	8003810 <USBD_GetString>
  }
  return USBD_StrDesc;  
}
 8000eac:	4801      	ldr	r0, [pc, #4]	; (8000eb4 <USBD_USR_InterfaceStrDescriptor+0x14>)
 8000eae:	bd08      	pop	{r3, pc}
 8000eb0:	0800ba88 	.word	0x0800ba88
 8000eb4:	20001ab0 	.word	0x20001ab0

08000eb8 <USBD_USR_ConfigStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_ConfigStrDescriptor( uint8_t speed , uint16_t *length)
{
 8000eb8:	460a      	mov	r2, r1
 8000eba:	b508      	push	{r3, lr}
  {  
    USBD_GetString ((uint8_t*)USBD_CONFIGURATION_HS_STRING, USBD_StrDesc, length);
  }
  else
  {
    USBD_GetString ((uint8_t*)USBD_CONFIGURATION_FS_STRING, USBD_StrDesc, length);
 8000ebc:	4802      	ldr	r0, [pc, #8]	; (8000ec8 <USBD_USR_ConfigStrDescriptor+0x10>)
 8000ebe:	4903      	ldr	r1, [pc, #12]	; (8000ecc <USBD_USR_ConfigStrDescriptor+0x14>)
 8000ec0:	f002 fca6 	bl	8003810 <USBD_GetString>
  }
  return USBD_StrDesc;  
}
 8000ec4:	4801      	ldr	r0, [pc, #4]	; (8000ecc <USBD_USR_ConfigStrDescriptor+0x14>)
 8000ec6:	bd08      	pop	{r3, pc}
 8000ec8:	0800ba96 	.word	0x0800ba96
 8000ecc:	20001ab0 	.word	0x20001ab0

08000ed0 <USBD_USR_SerialStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_SerialStrDescriptor( uint8_t speed , uint16_t *length)
{
 8000ed0:	b508      	push	{r3, lr}
 8000ed2:	460a      	mov	r2, r1
  if(speed  == USB_OTG_SPEED_HIGH)
 8000ed4:	b908      	cbnz	r0, 8000eda <USBD_USR_SerialStrDescriptor+0xa>
  {    
    USBD_GetString ((uint8_t*)USBD_SERIALNUMBER_HS_STRING, USBD_StrDesc, length);
 8000ed6:	4804      	ldr	r0, [pc, #16]	; (8000ee8 <USBD_USR_SerialStrDescriptor+0x18>)
 8000ed8:	e000      	b.n	8000edc <USBD_USR_SerialStrDescriptor+0xc>
  }
  else
  {
    USBD_GetString ((uint8_t*)USBD_SERIALNUMBER_FS_STRING, USBD_StrDesc, length);
 8000eda:	4804      	ldr	r0, [pc, #16]	; (8000eec <USBD_USR_SerialStrDescriptor+0x1c>)
 8000edc:	4904      	ldr	r1, [pc, #16]	; (8000ef0 <USBD_USR_SerialStrDescriptor+0x20>)
 8000ede:	f002 fc97 	bl	8003810 <USBD_GetString>
  }
  return USBD_StrDesc;
}
 8000ee2:	4803      	ldr	r0, [pc, #12]	; (8000ef0 <USBD_USR_SerialStrDescriptor+0x20>)
 8000ee4:	bd08      	pop	{r3, pc}
 8000ee6:	bf00      	nop
 8000ee8:	0800baa1 	.word	0x0800baa1
 8000eec:	0800baae 	.word	0x0800baae
 8000ef0:	20001ab0 	.word	0x20001ab0

08000ef4 <USBD_USR_ManufacturerStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_ManufacturerStrDescriptor( uint8_t speed , uint16_t *length)
{
 8000ef4:	460a      	mov	r2, r1
 8000ef6:	b508      	push	{r3, lr}
  USBD_GetString ((uint8_t*)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8000ef8:	4802      	ldr	r0, [pc, #8]	; (8000f04 <USBD_USR_ManufacturerStrDescriptor+0x10>)
 8000efa:	4903      	ldr	r1, [pc, #12]	; (8000f08 <USBD_USR_ManufacturerStrDescriptor+0x14>)
 8000efc:	f002 fc88 	bl	8003810 <USBD_GetString>
  return USBD_StrDesc;
}
 8000f00:	4801      	ldr	r0, [pc, #4]	; (8000f08 <USBD_USR_ManufacturerStrDescriptor+0x14>)
 8000f02:	bd08      	pop	{r3, pc}
 8000f04:	0800babb 	.word	0x0800babb
 8000f08:	20001ab0 	.word	0x20001ab0

08000f0c <USBD_USR_ProductStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_ProductStrDescriptor( uint8_t speed , uint16_t *length)
{
 8000f0c:	b508      	push	{r3, lr}
 8000f0e:	460a      	mov	r2, r1
 
  
  if(speed == 0)
 8000f10:	b908      	cbnz	r0, 8000f16 <USBD_USR_ProductStrDescriptor+0xa>
  {   
    USBD_GetString ((uint8_t*)USBD_PRODUCT_HS_STRING, USBD_StrDesc, length);
 8000f12:	4804      	ldr	r0, [pc, #16]	; (8000f24 <USBD_USR_ProductStrDescriptor+0x18>)
 8000f14:	e000      	b.n	8000f18 <USBD_USR_ProductStrDescriptor+0xc>
  }
  else
  {
    USBD_GetString ((uint8_t*)USBD_PRODUCT_FS_STRING, USBD_StrDesc, length);
 8000f16:	4804      	ldr	r0, [pc, #16]	; (8000f28 <USBD_USR_ProductStrDescriptor+0x1c>)
 8000f18:	4904      	ldr	r1, [pc, #16]	; (8000f2c <USBD_USR_ProductStrDescriptor+0x20>)
 8000f1a:	f002 fc79 	bl	8003810 <USBD_GetString>
  }
  return USBD_StrDesc;
}
 8000f1e:	4803      	ldr	r0, [pc, #12]	; (8000f2c <USBD_USR_ProductStrDescriptor+0x20>)
 8000f20:	bd08      	pop	{r3, pc}
 8000f22:	bf00      	nop
 8000f24:	0800bace 	.word	0x0800bace
 8000f28:	0800baef 	.word	0x0800baef
 8000f2c:	20001ab0 	.word	0x20001ab0

08000f30 <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000f30:	4b0a      	ldr	r3, [pc, #40]	; (8000f5c <RCC_DeInit+0x2c>)
 8000f32:	6819      	ldr	r1, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000f34:	2200      	movs	r2, #0
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000f36:	f041 0001 	orr.w	r0, r1, #1
 8000f3a:	6018      	str	r0, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000f3c:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000f3e:	6819      	ldr	r1, [r3, #0]
 8000f40:	f021 7c84 	bic.w	ip, r1, #17301504	; 0x1080000

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8000f44:	4906      	ldr	r1, [pc, #24]	; (8000f60 <RCC_DeInit+0x30>)

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000f46:	f42c 3080 	bic.w	r0, ip, #65536	; 0x10000
 8000f4a:	6018      	str	r0, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8000f4c:	6059      	str	r1, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000f4e:	6818      	ldr	r0, [r3, #0]
 8000f50:	f420 2180 	bic.w	r1, r0, #262144	; 0x40000
 8000f54:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8000f56:	60da      	str	r2, [r3, #12]
}
 8000f58:	4770      	bx	lr
 8000f5a:	bf00      	nop
 8000f5c:	40023800 	.word	0x40023800
 8000f60:	24003010 	.word	0x24003010

08000f64 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
 8000f64:	4b02      	ldr	r3, [pc, #8]	; (8000f70 <RCC_HSEConfig+0xc>)
 8000f66:	2200      	movs	r2, #0
 8000f68:	701a      	strb	r2, [r3, #0]

  /* Set the new HSE configuration -------------------------------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
 8000f6a:	7018      	strb	r0, [r3, #0]
}
 8000f6c:	4770      	bx	lr
 8000f6e:	bf00      	nop
 8000f70:	40023802 	.word	0x40023802

08000f74 <RCC_AdjustHSICalibrationValue>:
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));

  tmpreg = RCC->CR;
 8000f74:	4b03      	ldr	r3, [pc, #12]	; (8000f84 <RCC_AdjustHSICalibrationValue+0x10>)
 8000f76:	681a      	ldr	r2, [r3, #0]

  /* Clear HSITRIM[4:0] bits */
  tmpreg &= ~RCC_CR_HSITRIM;
 8000f78:	f022 01f8 	bic.w	r1, r2, #248	; 0xf8

  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 8000f7c:	ea41 02c0 	orr.w	r2, r1, r0, lsl #3

  /* Store the new value */
  RCC->CR = tmpreg;
 8000f80:	601a      	str	r2, [r3, #0]
}
 8000f82:	4770      	bx	lr
 8000f84:	40023800 	.word	0x40023800

08000f88 <RCC_HSICmd>:
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 8000f88:	4b01      	ldr	r3, [pc, #4]	; (8000f90 <RCC_HSICmd+0x8>)
 8000f8a:	6018      	str	r0, [r3, #0]
}
 8000f8c:	4770      	bx	lr
 8000f8e:	bf00      	nop
 8000f90:	42470000 	.word	0x42470000

08000f94 <RCC_LSEConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8000f94:	4b06      	ldr	r3, [pc, #24]	; (8000fb0 <RCC_LSEConfig+0x1c>)
 8000f96:	2200      	movs	r2, #0

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
 8000f98:	2801      	cmp	r0, #1
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8000f9a:	701a      	strb	r2, [r3, #0]

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8000f9c:	701a      	strb	r2, [r3, #0]

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
 8000f9e:	d004      	beq.n	8000faa <RCC_LSEConfig+0x16>
 8000fa0:	2804      	cmp	r0, #4
 8000fa2:	d101      	bne.n	8000fa8 <RCC_LSEConfig+0x14>
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
      break;
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 8000fa4:	2005      	movs	r0, #5
 8000fa6:	7018      	strb	r0, [r3, #0]
 8000fa8:	4770      	bx	lr
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 8000faa:	7018      	strb	r0, [r3, #0]
      break;
 8000fac:	4770      	bx	lr
 8000fae:	bf00      	nop
 8000fb0:	40023870 	.word	0x40023870

08000fb4 <RCC_LSICmd>:
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 8000fb4:	4b01      	ldr	r3, [pc, #4]	; (8000fbc <RCC_LSICmd+0x8>)
 8000fb6:	6018      	str	r0, [r3, #0]
}
 8000fb8:	4770      	bx	lr
 8000fba:	bf00      	nop
 8000fbc:	42470e80 	.word	0x42470e80

08000fc0 <RCC_PLLConfig>:
  assert_param(IS_RCC_PLLM_VALUE(PLLM));
  assert_param(IS_RCC_PLLN_VALUE(PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLP));
  assert_param(IS_RCC_PLLQ_VALUE(PLLQ));

  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
 8000fc0:	ea41 0000 	orr.w	r0, r1, r0
 8000fc4:	ea40 1c82 	orr.w	ip, r0, r2, lsl #6
 8000fc8:	9a00      	ldr	r2, [sp, #0]
 8000fca:	085b      	lsrs	r3, r3, #1
 8000fcc:	1e59      	subs	r1, r3, #1
 8000fce:	ea4c 6002 	orr.w	r0, ip, r2, lsl #24
 8000fd2:	4b02      	ldr	r3, [pc, #8]	; (8000fdc <RCC_PLLConfig+0x1c>)
 8000fd4:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
 8000fd8:	605a      	str	r2, [r3, #4]
                 (PLLQ << 24);
}
 8000fda:	4770      	bx	lr
 8000fdc:	40023800 	.word	0x40023800

08000fe0 <RCC_PLLCmd>:
  */
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8000fe0:	4b01      	ldr	r3, [pc, #4]	; (8000fe8 <RCC_PLLCmd+0x8>)
 8000fe2:	6018      	str	r0, [r3, #0]
}
 8000fe4:	4770      	bx	lr
 8000fe6:	bf00      	nop
 8000fe8:	42470060 	.word	0x42470060

08000fec <RCC_PLLI2SConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
  assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));

  RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
 8000fec:	0180      	lsls	r0, r0, #6
 8000fee:	4b03      	ldr	r3, [pc, #12]	; (8000ffc <RCC_PLLI2SConfig+0x10>)
 8000ff0:	ea40 7101 	orr.w	r1, r0, r1, lsl #28
 8000ff4:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
}
 8000ff8:	4770      	bx	lr
 8000ffa:	bf00      	nop
 8000ffc:	40023800 	.word	0x40023800

08001000 <RCC_PLLI2SCmd>:
  */
void RCC_PLLI2SCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
 8001000:	4b01      	ldr	r3, [pc, #4]	; (8001008 <RCC_PLLI2SCmd+0x8>)
 8001002:	6018      	str	r0, [r3, #0]
}
 8001004:	4770      	bx	lr
 8001006:	bf00      	nop
 8001008:	42470068 	.word	0x42470068

0800100c <RCC_ClockSecuritySystemCmd>:
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 800100c:	4b01      	ldr	r3, [pc, #4]	; (8001014 <RCC_ClockSecuritySystemCmd+0x8>)
 800100e:	6018      	str	r0, [r3, #0]
}
 8001010:	4770      	bx	lr
 8001012:	bf00      	nop
 8001014:	4247004c 	.word	0x4247004c

08001018 <RCC_MCO1Config>:
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
  assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  

  tmpreg = RCC->CFGR;
 8001018:	4b04      	ldr	r3, [pc, #16]	; (800102c <RCC_MCO1Config+0x14>)
 800101a:	689a      	ldr	r2, [r3, #8]

  /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
  tmpreg &= CFGR_MCO1_RESET_MASK;
 800101c:	f022 6cec 	bic.w	ip, r2, #123731968	; 0x7600000

  /* Select MCO1 clock source and prescaler */
  tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
 8001020:	ea40 000c 	orr.w	r0, r0, ip
 8001024:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 8001028:	609a      	str	r2, [r3, #8]
}
 800102a:	4770      	bx	lr
 800102c:	40023800 	.word	0x40023800

08001030 <RCC_MCO2Config>:
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
  assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
  
  tmpreg = RCC->CFGR;
 8001030:	4b04      	ldr	r3, [pc, #16]	; (8001044 <RCC_MCO2Config+0x14>)
 8001032:	689a      	ldr	r2, [r3, #8]
  
  /* Clear MCO2 and MCO2PRE[2:0] bits */
  tmpreg &= CFGR_MCO2_RESET_MASK;
 8001034:	f022 4c78 	bic.w	ip, r2, #4160749568	; 0xf8000000

  /* Select MCO2 clock source and prescaler */
  tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
 8001038:	ea40 000c 	orr.w	r0, r0, ip
 800103c:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 8001040:	609a      	str	r2, [r3, #8]
}
 8001042:	4770      	bx	lr
 8001044:	40023800 	.word	0x40023800

08001048 <RCC_SYSCLKConfig>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));

  tmpreg = RCC->CFGR;
 8001048:	4b03      	ldr	r3, [pc, #12]	; (8001058 <RCC_SYSCLKConfig+0x10>)
 800104a:	689a      	ldr	r2, [r3, #8]

  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
 800104c:	f022 0103 	bic.w	r1, r2, #3

  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 8001050:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8001054:	609a      	str	r2, [r3, #8]
}
 8001056:	4770      	bx	lr
 8001058:	40023800 	.word	0x40023800

0800105c <RCC_GetSYSCLKSource>:
  *              - 0x04: HSE used as system clock
  *              - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 800105c:	4b02      	ldr	r3, [pc, #8]	; (8001068 <RCC_GetSYSCLKSource+0xc>)
 800105e:	6898      	ldr	r0, [r3, #8]
}
 8001060:	f000 000c 	and.w	r0, r0, #12
 8001064:	4770      	bx	lr
 8001066:	bf00      	nop
 8001068:	40023800 	.word	0x40023800

0800106c <RCC_HCLKConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));

  tmpreg = RCC->CFGR;
 800106c:	4b03      	ldr	r3, [pc, #12]	; (800107c <RCC_HCLKConfig+0x10>)
 800106e:	689a      	ldr	r2, [r3, #8]

  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 8001070:	f022 01f0 	bic.w	r1, r2, #240	; 0xf0

  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8001074:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8001078:	609a      	str	r2, [r3, #8]
}
 800107a:	4770      	bx	lr
 800107c:	40023800 	.word	0x40023800

08001080 <RCC_PCLK1Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 8001080:	4b03      	ldr	r3, [pc, #12]	; (8001090 <RCC_PCLK1Config+0x10>)
 8001082:	689a      	ldr	r2, [r3, #8]

  /* Clear PPRE1[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE1;
 8001084:	f422 51e0 	bic.w	r1, r2, #7168	; 0x1c00

  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 8001088:	ea40 0201 	orr.w	r2, r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800108c:	609a      	str	r2, [r3, #8]
}
 800108e:	4770      	bx	lr
 8001090:	40023800 	.word	0x40023800

08001094 <RCC_PCLK2Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 8001094:	4b03      	ldr	r3, [pc, #12]	; (80010a4 <RCC_PCLK2Config+0x10>)
 8001096:	689a      	ldr	r2, [r3, #8]

  /* Clear PPRE2[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE2;
 8001098:	f422 4160 	bic.w	r1, r2, #57344	; 0xe000

  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 800109c:	ea41 02c0 	orr.w	r2, r1, r0, lsl #3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80010a0:	609a      	str	r2, [r3, #8]
}
 80010a2:	4770      	bx	lr
 80010a4:	40023800 	.word	0x40023800

080010a8 <RCC_GetClocksFreq>:
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 80010a8:	4a20      	ldr	r2, [pc, #128]	; (800112c <RCC_GetClocksFreq+0x84>)
 80010aa:	6893      	ldr	r3, [r2, #8]
 80010ac:	f003 030c 	and.w	r3, r3, #12

  switch (tmp)
 80010b0:	2b04      	cmp	r3, #4
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 80010b2:	b410      	push	{r4}
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;

  switch (tmp)
 80010b4:	d01d      	beq.n	80010f2 <RCC_GetClocksFreq+0x4a>
 80010b6:	2b08      	cmp	r3, #8
 80010b8:	d01e      	beq.n	80010f8 <RCC_GetClocksFreq+0x50>

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
      break;
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 80010ba:	4b1d      	ldr	r3, [pc, #116]	; (8001130 <RCC_GetClocksFreq+0x88>)
 80010bc:	6003      	str	r3, [r0, #0]
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 80010be:	491b      	ldr	r1, [pc, #108]	; (800112c <RCC_GetClocksFreq+0x84>)
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 80010c0:	4a1c      	ldr	r2, [pc, #112]	; (8001134 <RCC_GetClocksFreq+0x8c>)
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 80010c2:	688c      	ldr	r4, [r1, #8]
  tmp = tmp >> 4;
 80010c4:	f3c4 1c03 	ubfx	ip, r4, #4, #4
  presc = APBAHBPrescTable[tmp];
 80010c8:	f812 400c 	ldrb.w	r4, [r2, ip]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 80010cc:	40e3      	lsrs	r3, r4
 80010ce:	6043      	str	r3, [r0, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 80010d0:	688c      	ldr	r4, [r1, #8]
  tmp = tmp >> 10;
 80010d2:	f3c4 2c82 	ubfx	ip, r4, #10, #3
  presc = APBAHBPrescTable[tmp];
 80010d6:	f812 400c 	ldrb.w	r4, [r2, ip]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 80010da:	fa33 f404 	lsrs.w	r4, r3, r4
 80010de:	6084      	str	r4, [r0, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 80010e0:	6889      	ldr	r1, [r1, #8]
  tmp = tmp >> 13;
 80010e2:	f3c1 3c42 	ubfx	ip, r1, #13, #3
  presc = APBAHBPrescTable[tmp];
 80010e6:	f812 200c 	ldrb.w	r2, [r2, ip]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 80010ea:	40d3      	lsrs	r3, r2
 80010ec:	60c3      	str	r3, [r0, #12]
}
 80010ee:	bc10      	pop	{r4}
 80010f0:	4770      	bx	lr
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 80010f2:	4b11      	ldr	r3, [pc, #68]	; (8001138 <RCC_GetClocksFreq+0x90>)
 80010f4:	6003      	str	r3, [r0, #0]
      break;
 80010f6:	e7e2      	b.n	80010be <RCC_GetClocksFreq+0x16>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 80010f8:	6854      	ldr	r4, [r2, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80010fa:	6851      	ldr	r1, [r2, #4]
      
      if (pllsource != 0)
 80010fc:	f414 0f80 	tst.w	r4, #4194304	; 0x400000
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8001100:	6854      	ldr	r4, [r2, #4]
 8001102:	bf14      	ite	ne
 8001104:	4b0c      	ldrne	r3, [pc, #48]	; (8001138 <RCC_GetClocksFreq+0x90>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8001106:	4b0a      	ldreq	r3, [pc, #40]	; (8001130 <RCC_GetClocksFreq+0x88>)
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
      
      if (pllsource != 0)
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8001108:	f3c4 1288 	ubfx	r2, r4, #6, #9

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800110c:	f001 013f 	and.w	r1, r1, #63	; 0x3f
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8001110:	4c06      	ldr	r4, [pc, #24]	; (800112c <RCC_GetClocksFreq+0x84>)
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8001112:	fbb3 fcf1 	udiv	ip, r3, r1
 8001116:	fb0c f102 	mul.w	r1, ip, r2
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 800111a:	6862      	ldr	r2, [r4, #4]
 800111c:	f3c2 4301 	ubfx	r3, r2, #16, #2
 8001120:	1c5c      	adds	r4, r3, #1
 8001122:	0062      	lsls	r2, r4, #1
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 8001124:	fbb1 f3f2 	udiv	r3, r1, r2
 8001128:	6003      	str	r3, [r0, #0]
      break;
 800112a:	e7c8      	b.n	80010be <RCC_GetClocksFreq+0x16>
 800112c:	40023800 	.word	0x40023800
 8001130:	00f42400 	.word	0x00f42400
 8001134:	20000098 	.word	0x20000098
 8001138:	017d7840 	.word	0x017d7840

0800113c <RCC_RTCCLKConfig>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
 800113c:	f400 7340 	and.w	r3, r0, #768	; 0x300
 8001140:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8001144:	d10a      	bne.n	800115c <RCC_RTCCLKConfig+0x20>
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;
 8001146:	4b09      	ldr	r3, [pc, #36]	; (800116c <RCC_RTCCLKConfig+0x30>)
 8001148:	6899      	ldr	r1, [r3, #8]

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 800114a:	f020 4270 	bic.w	r2, r0, #4026531840	; 0xf0000000
  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;
 800114e:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 8001152:	f422 7c40 	bic.w	ip, r2, #768	; 0x300
 8001156:	ea4c 0201 	orr.w	r2, ip, r1

    /* Store the new value */
    RCC->CFGR = tmpreg;
 800115a:	609a      	str	r2, [r3, #8]
  }
    
  /* Select the RTC clock source */
  RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
 800115c:	4b03      	ldr	r3, [pc, #12]	; (800116c <RCC_RTCCLKConfig+0x30>)
 800115e:	0500      	lsls	r0, r0, #20
 8001160:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8001162:	0d01      	lsrs	r1, r0, #20
 8001164:	ea41 0002 	orr.w	r0, r1, r2
 8001168:	6718      	str	r0, [r3, #112]	; 0x70
}
 800116a:	4770      	bx	lr
 800116c:	40023800 	.word	0x40023800

08001170 <RCC_RTCCLKCmd>:
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 8001170:	4b01      	ldr	r3, [pc, #4]	; (8001178 <RCC_RTCCLKCmd+0x8>)
 8001172:	6018      	str	r0, [r3, #0]
}
 8001174:	4770      	bx	lr
 8001176:	bf00      	nop
 8001178:	42470e3c 	.word	0x42470e3c

0800117c <RCC_BackupResetCmd>:
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 800117c:	4b01      	ldr	r3, [pc, #4]	; (8001184 <RCC_BackupResetCmd+0x8>)
 800117e:	6018      	str	r0, [r3, #0]
}
 8001180:	4770      	bx	lr
 8001182:	bf00      	nop
 8001184:	42470e40 	.word	0x42470e40

08001188 <RCC_I2SCLKConfig>:
void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));

  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
 8001188:	4b01      	ldr	r3, [pc, #4]	; (8001190 <RCC_I2SCLKConfig+0x8>)
 800118a:	6018      	str	r0, [r3, #0]
}
 800118c:	4770      	bx	lr
 800118e:	bf00      	nop
 8001190:	4247015c 	.word	0x4247015c

08001194 <RCC_AHB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001194:	b929      	cbnz	r1, 80011a2 <RCC_AHB1PeriphClockCmd+0xe>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 8001196:	4b05      	ldr	r3, [pc, #20]	; (80011ac <RCC_AHB1PeriphClockCmd+0x18>)
 8001198:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800119a:	ea22 0100 	bic.w	r1, r2, r0
 800119e:	6319      	str	r1, [r3, #48]	; 0x30
 80011a0:	4770      	bx	lr
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 80011a2:	4b02      	ldr	r3, [pc, #8]	; (80011ac <RCC_AHB1PeriphClockCmd+0x18>)
 80011a4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80011a6:	4310      	orrs	r0, r2
 80011a8:	6318      	str	r0, [r3, #48]	; 0x30
 80011aa:	4770      	bx	lr
 80011ac:	40023800 	.word	0x40023800

080011b0 <RCC_AHB2PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80011b0:	b929      	cbnz	r1, 80011be <RCC_AHB2PeriphClockCmd+0xe>
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2ENR &= ~RCC_AHB2Periph;
 80011b2:	4b05      	ldr	r3, [pc, #20]	; (80011c8 <RCC_AHB2PeriphClockCmd+0x18>)
 80011b4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80011b6:	ea22 0100 	bic.w	r1, r2, r0
 80011ba:	6359      	str	r1, [r3, #52]	; 0x34
 80011bc:	4770      	bx	lr
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
 80011be:	4b02      	ldr	r3, [pc, #8]	; (80011c8 <RCC_AHB2PeriphClockCmd+0x18>)
 80011c0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80011c2:	4310      	orrs	r0, r2
 80011c4:	6358      	str	r0, [r3, #52]	; 0x34
 80011c6:	4770      	bx	lr
 80011c8:	40023800 	.word	0x40023800

080011cc <RCC_AHB3PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80011cc:	b929      	cbnz	r1, 80011da <RCC_AHB3PeriphClockCmd+0xe>
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3ENR &= ~RCC_AHB3Periph;
 80011ce:	4b05      	ldr	r3, [pc, #20]	; (80011e4 <RCC_AHB3PeriphClockCmd+0x18>)
 80011d0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80011d2:	ea22 0100 	bic.w	r1, r2, r0
 80011d6:	6399      	str	r1, [r3, #56]	; 0x38
 80011d8:	4770      	bx	lr
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
 80011da:	4b02      	ldr	r3, [pc, #8]	; (80011e4 <RCC_AHB3PeriphClockCmd+0x18>)
 80011dc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80011de:	4310      	orrs	r0, r2
 80011e0:	6398      	str	r0, [r3, #56]	; 0x38
 80011e2:	4770      	bx	lr
 80011e4:	40023800 	.word	0x40023800

080011e8 <RCC_APB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80011e8:	b929      	cbnz	r1, 80011f6 <RCC_APB1PeriphClockCmd+0xe>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 80011ea:	4b05      	ldr	r3, [pc, #20]	; (8001200 <RCC_APB1PeriphClockCmd+0x18>)
 80011ec:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80011ee:	ea22 0100 	bic.w	r1, r2, r0
 80011f2:	6419      	str	r1, [r3, #64]	; 0x40
 80011f4:	4770      	bx	lr
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 80011f6:	4b02      	ldr	r3, [pc, #8]	; (8001200 <RCC_APB1PeriphClockCmd+0x18>)
 80011f8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80011fa:	4310      	orrs	r0, r2
 80011fc:	6418      	str	r0, [r3, #64]	; 0x40
 80011fe:	4770      	bx	lr
 8001200:	40023800 	.word	0x40023800

08001204 <RCC_APB2PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001204:	b929      	cbnz	r1, 8001212 <RCC_APB2PeriphClockCmd+0xe>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8001206:	4b05      	ldr	r3, [pc, #20]	; (800121c <RCC_APB2PeriphClockCmd+0x18>)
 8001208:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800120a:	ea22 0100 	bic.w	r1, r2, r0
 800120e:	6459      	str	r1, [r3, #68]	; 0x44
 8001210:	4770      	bx	lr
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8001212:	4b02      	ldr	r3, [pc, #8]	; (800121c <RCC_APB2PeriphClockCmd+0x18>)
 8001214:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001216:	4310      	orrs	r0, r2
 8001218:	6458      	str	r0, [r3, #68]	; 0x44
 800121a:	4770      	bx	lr
 800121c:	40023800 	.word	0x40023800

08001220 <RCC_AHB1PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001220:	b929      	cbnz	r1, 800122e <RCC_AHB1PeriphResetCmd+0xe>
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
 8001222:	4b05      	ldr	r3, [pc, #20]	; (8001238 <RCC_AHB1PeriphResetCmd+0x18>)
 8001224:	691a      	ldr	r2, [r3, #16]
 8001226:	ea22 0100 	bic.w	r1, r2, r0
 800122a:	6119      	str	r1, [r3, #16]
 800122c:	4770      	bx	lr
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 800122e:	4b02      	ldr	r3, [pc, #8]	; (8001238 <RCC_AHB1PeriphResetCmd+0x18>)
 8001230:	691a      	ldr	r2, [r3, #16]
 8001232:	4310      	orrs	r0, r2
 8001234:	6118      	str	r0, [r3, #16]
 8001236:	4770      	bx	lr
 8001238:	40023800 	.word	0x40023800

0800123c <RCC_AHB2PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800123c:	b929      	cbnz	r1, 800124a <RCC_AHB2PeriphResetCmd+0xe>
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2RSTR &= ~RCC_AHB2Periph;
 800123e:	4b05      	ldr	r3, [pc, #20]	; (8001254 <RCC_AHB2PeriphResetCmd+0x18>)
 8001240:	695a      	ldr	r2, [r3, #20]
 8001242:	ea22 0100 	bic.w	r1, r2, r0
 8001246:	6159      	str	r1, [r3, #20]
 8001248:	4770      	bx	lr
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
 800124a:	4b02      	ldr	r3, [pc, #8]	; (8001254 <RCC_AHB2PeriphResetCmd+0x18>)
 800124c:	695a      	ldr	r2, [r3, #20]
 800124e:	4310      	orrs	r0, r2
 8001250:	6158      	str	r0, [r3, #20]
 8001252:	4770      	bx	lr
 8001254:	40023800 	.word	0x40023800

08001258 <RCC_AHB3PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001258:	b929      	cbnz	r1, 8001266 <RCC_AHB3PeriphResetCmd+0xe>
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3RSTR &= ~RCC_AHB3Periph;
 800125a:	4b05      	ldr	r3, [pc, #20]	; (8001270 <RCC_AHB3PeriphResetCmd+0x18>)
 800125c:	699a      	ldr	r2, [r3, #24]
 800125e:	ea22 0100 	bic.w	r1, r2, r0
 8001262:	6199      	str	r1, [r3, #24]
 8001264:	4770      	bx	lr
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
 8001266:	4b02      	ldr	r3, [pc, #8]	; (8001270 <RCC_AHB3PeriphResetCmd+0x18>)
 8001268:	699a      	ldr	r2, [r3, #24]
 800126a:	4310      	orrs	r0, r2
 800126c:	6198      	str	r0, [r3, #24]
 800126e:	4770      	bx	lr
 8001270:	40023800 	.word	0x40023800

08001274 <RCC_APB1PeriphResetCmd>:
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001274:	b929      	cbnz	r1, 8001282 <RCC_APB1PeriphResetCmd+0xe>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 8001276:	4b05      	ldr	r3, [pc, #20]	; (800128c <RCC_APB1PeriphResetCmd+0x18>)
 8001278:	6a1a      	ldr	r2, [r3, #32]
 800127a:	ea22 0100 	bic.w	r1, r2, r0
 800127e:	6219      	str	r1, [r3, #32]
 8001280:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 8001282:	4b02      	ldr	r3, [pc, #8]	; (800128c <RCC_APB1PeriphResetCmd+0x18>)
 8001284:	6a1a      	ldr	r2, [r3, #32]
 8001286:	4310      	orrs	r0, r2
 8001288:	6218      	str	r0, [r3, #32]
 800128a:	4770      	bx	lr
 800128c:	40023800 	.word	0x40023800

08001290 <RCC_APB2PeriphResetCmd>:
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001290:	b929      	cbnz	r1, 800129e <RCC_APB2PeriphResetCmd+0xe>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 8001292:	4b05      	ldr	r3, [pc, #20]	; (80012a8 <RCC_APB2PeriphResetCmd+0x18>)
 8001294:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001296:	ea22 0100 	bic.w	r1, r2, r0
 800129a:	6259      	str	r1, [r3, #36]	; 0x24
 800129c:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 800129e:	4b02      	ldr	r3, [pc, #8]	; (80012a8 <RCC_APB2PeriphResetCmd+0x18>)
 80012a0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80012a2:	4310      	orrs	r0, r2
 80012a4:	6258      	str	r0, [r3, #36]	; 0x24
 80012a6:	4770      	bx	lr
 80012a8:	40023800 	.word	0x40023800

080012ac <RCC_AHB1PeriphClockLPModeCmd>:
void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80012ac:	b929      	cbnz	r1, 80012ba <RCC_AHB1PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1LPENR &= ~RCC_AHB1Periph;
 80012ae:	4b05      	ldr	r3, [pc, #20]	; (80012c4 <RCC_AHB1PeriphClockLPModeCmd+0x18>)
 80012b0:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80012b2:	ea22 0100 	bic.w	r1, r2, r0
 80012b6:	6519      	str	r1, [r3, #80]	; 0x50
 80012b8:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
 80012ba:	4b02      	ldr	r3, [pc, #8]	; (80012c4 <RCC_AHB1PeriphClockLPModeCmd+0x18>)
 80012bc:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80012be:	4310      	orrs	r0, r2
 80012c0:	6518      	str	r0, [r3, #80]	; 0x50
 80012c2:	4770      	bx	lr
 80012c4:	40023800 	.word	0x40023800

080012c8 <RCC_AHB2PeriphClockLPModeCmd>:
void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80012c8:	b929      	cbnz	r1, 80012d6 <RCC_AHB2PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2LPENR &= ~RCC_AHB2Periph;
 80012ca:	4b05      	ldr	r3, [pc, #20]	; (80012e0 <RCC_AHB2PeriphClockLPModeCmd+0x18>)
 80012cc:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80012ce:	ea22 0100 	bic.w	r1, r2, r0
 80012d2:	6559      	str	r1, [r3, #84]	; 0x54
 80012d4:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
 80012d6:	4b02      	ldr	r3, [pc, #8]	; (80012e0 <RCC_AHB2PeriphClockLPModeCmd+0x18>)
 80012d8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80012da:	4310      	orrs	r0, r2
 80012dc:	6558      	str	r0, [r3, #84]	; 0x54
 80012de:	4770      	bx	lr
 80012e0:	40023800 	.word	0x40023800

080012e4 <RCC_AHB3PeriphClockLPModeCmd>:
void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80012e4:	b929      	cbnz	r1, 80012f2 <RCC_AHB3PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3LPENR &= ~RCC_AHB3Periph;
 80012e6:	4b05      	ldr	r3, [pc, #20]	; (80012fc <RCC_AHB3PeriphClockLPModeCmd+0x18>)
 80012e8:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80012ea:	ea22 0100 	bic.w	r1, r2, r0
 80012ee:	6599      	str	r1, [r3, #88]	; 0x58
 80012f0:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
 80012f2:	4b02      	ldr	r3, [pc, #8]	; (80012fc <RCC_AHB3PeriphClockLPModeCmd+0x18>)
 80012f4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80012f6:	4310      	orrs	r0, r2
 80012f8:	6598      	str	r0, [r3, #88]	; 0x58
 80012fa:	4770      	bx	lr
 80012fc:	40023800 	.word	0x40023800

08001300 <RCC_APB1PeriphClockLPModeCmd>:
void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001300:	b929      	cbnz	r1, 800130e <RCC_APB1PeriphClockLPModeCmd+0xe>
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1LPENR &= ~RCC_APB1Periph;
 8001302:	4b05      	ldr	r3, [pc, #20]	; (8001318 <RCC_APB1PeriphClockLPModeCmd+0x18>)
 8001304:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001306:	ea22 0100 	bic.w	r1, r2, r0
 800130a:	6619      	str	r1, [r3, #96]	; 0x60
 800130c:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
 800130e:	4b02      	ldr	r3, [pc, #8]	; (8001318 <RCC_APB1PeriphClockLPModeCmd+0x18>)
 8001310:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001312:	4310      	orrs	r0, r2
 8001314:	6618      	str	r0, [r3, #96]	; 0x60
 8001316:	4770      	bx	lr
 8001318:	40023800 	.word	0x40023800

0800131c <RCC_APB2PeriphClockLPModeCmd>:
void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800131c:	b929      	cbnz	r1, 800132a <RCC_APB2PeriphClockLPModeCmd+0xe>
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2LPENR &= ~RCC_APB2Periph;
 800131e:	4b05      	ldr	r3, [pc, #20]	; (8001334 <RCC_APB2PeriphClockLPModeCmd+0x18>)
 8001320:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8001322:	ea22 0100 	bic.w	r1, r2, r0
 8001326:	6659      	str	r1, [r3, #100]	; 0x64
 8001328:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
 800132a:	4b02      	ldr	r3, [pc, #8]	; (8001334 <RCC_APB2PeriphClockLPModeCmd+0x18>)
 800132c:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800132e:	4310      	orrs	r0, r2
 8001330:	6658      	str	r0, [r3, #100]	; 0x64
 8001332:	4770      	bx	lr
 8001334:	40023800 	.word	0x40023800

08001338 <RCC_ITConfig>:
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001338:	b931      	cbnz	r1, 8001348 <RCC_ITConfig+0x10>
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
  }
  else
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 800133a:	4b06      	ldr	r3, [pc, #24]	; (8001354 <RCC_ITConfig+0x1c>)
 800133c:	f893 c000 	ldrb.w	ip, [r3]
 8001340:	ea2c 0100 	bic.w	r1, ip, r0
 8001344:	7019      	strb	r1, [r3, #0]
 8001346:	4770      	bx	lr
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 8001348:	4b02      	ldr	r3, [pc, #8]	; (8001354 <RCC_ITConfig+0x1c>)
 800134a:	781a      	ldrb	r2, [r3, #0]
 800134c:	4310      	orrs	r0, r2
 800134e:	7018      	strb	r0, [r3, #0]
 8001350:	4770      	bx	lr
 8001352:	bf00      	nop
 8001354:	4002380d 	.word	0x4002380d

08001358 <RCC_GetFlagStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 8001358:	0943      	lsrs	r3, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 800135a:	2b01      	cmp	r3, #1
 800135c:	d00b      	beq.n	8001376 <RCC_GetFlagStatus+0x1e>
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 800135e:	2b02      	cmp	r3, #2
  {
    statusreg = RCC->BDCR;
 8001360:	4b09      	ldr	r3, [pc, #36]	; (8001388 <RCC_GetFlagStatus+0x30>)
 8001362:	bf0c      	ite	eq
 8001364:	6f1b      	ldreq	r3, [r3, #112]	; 0x70
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8001366:	6f5b      	ldrne	r3, [r3, #116]	; 0x74
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
 8001368:	f000 011f 	and.w	r1, r0, #31
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 800136c:	fa33 f001 	lsrs.w	r0, r3, r1
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 8001370:	f000 0001 	and.w	r0, r0, #1
 8001374:	4770      	bx	lr

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 8001376:	4b04      	ldr	r3, [pc, #16]	; (8001388 <RCC_GetFlagStatus+0x30>)
 8001378:	681b      	ldr	r3, [r3, #0]
  {
    statusreg = RCC->CSR;
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
 800137a:	f000 011f 	and.w	r1, r0, #31
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 800137e:	fa33 f001 	lsrs.w	r0, r3, r1
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 8001382:	f000 0001 	and.w	r0, r0, #1
 8001386:	4770      	bx	lr
 8001388:	40023800 	.word	0x40023800

0800138c <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 800138c:	b500      	push	{lr}
 800138e:	b083      	sub	sp, #12
  __IO uint32_t startupcounter = 0;
 8001390:	2300      	movs	r3, #0
 8001392:	9301      	str	r3, [sp, #4]
 8001394:	e000      	b.n	8001398 <RCC_WaitForHSEStartUp+0xc>
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    startupcounter++;
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 8001396:	b948      	cbnz	r0, 80013ac <RCC_WaitForHSEStartUp+0x20>
  ErrorStatus status = ERROR;
  FlagStatus hsestatus = RESET;
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 8001398:	2031      	movs	r0, #49	; 0x31
 800139a:	f7ff ffdd 	bl	8001358 <RCC_GetFlagStatus>
    startupcounter++;
 800139e:	9b01      	ldr	r3, [sp, #4]
 80013a0:	1c5a      	adds	r2, r3, #1
 80013a2:	9201      	str	r2, [sp, #4]
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 80013a4:	9901      	ldr	r1, [sp, #4]
 80013a6:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
 80013aa:	d1f4      	bne.n	8001396 <RCC_WaitForHSEStartUp+0xa>

  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 80013ac:	2031      	movs	r0, #49	; 0x31
 80013ae:	f7ff ffd3 	bl	8001358 <RCC_GetFlagStatus>
  else
  {
    status = ERROR;
  }
  return (status);
}
 80013b2:	3800      	subs	r0, #0
 80013b4:	bf18      	it	ne
 80013b6:	2001      	movne	r0, #1
 80013b8:	b003      	add	sp, #12
 80013ba:	bd00      	pop	{pc}

080013bc <RCC_ClearFlag>:
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= RCC_CSR_RMVF;
 80013bc:	4b02      	ldr	r3, [pc, #8]	; (80013c8 <RCC_ClearFlag+0xc>)
 80013be:	6f58      	ldr	r0, [r3, #116]	; 0x74
 80013c0:	f040 7280 	orr.w	r2, r0, #16777216	; 0x1000000
 80013c4:	675a      	str	r2, [r3, #116]	; 0x74
}
 80013c6:	4770      	bx	lr
 80013c8:	40023800 	.word	0x40023800

080013cc <RCC_GetITStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 80013cc:	4903      	ldr	r1, [pc, #12]	; (80013dc <RCC_GetITStatus+0x10>)
 80013ce:	68cb      	ldr	r3, [r1, #12]
  {
    bitstatus = SET;
 80013d0:	4218      	tst	r0, r3
  {
    bitstatus = RESET;
  }
  /* Return the RCC_IT status */
  return  bitstatus;
}
 80013d2:	bf0c      	ite	eq
 80013d4:	2000      	moveq	r0, #0
 80013d6:	2001      	movne	r0, #1
 80013d8:	4770      	bx	lr
 80013da:	bf00      	nop
 80013dc:	40023800 	.word	0x40023800

080013e0 <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 80013e0:	4b01      	ldr	r3, [pc, #4]	; (80013e8 <RCC_ClearITPendingBit+0x8>)
 80013e2:	7018      	strb	r0, [r3, #0]
}
 80013e4:	4770      	bx	lr
 80013e6:	bf00      	nop
 80013e8:	4002380e 	.word	0x4002380e

080013ec <EXTI_DeInit>:
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR = 0x00000000;
 80013ec:	4b04      	ldr	r3, [pc, #16]	; (8001400 <EXTI_DeInit+0x14>)
  EXTI->EMR = 0x00000000;
  EXTI->RTSR = 0x00000000;
  EXTI->FTSR = 0x00000000;
  EXTI->PR = 0x007FFFFF;
 80013ee:	4a05      	ldr	r2, [pc, #20]	; (8001404 <EXTI_DeInit+0x18>)
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR = 0x00000000;
 80013f0:	2000      	movs	r0, #0
 80013f2:	6018      	str	r0, [r3, #0]
  EXTI->EMR = 0x00000000;
 80013f4:	6058      	str	r0, [r3, #4]
  EXTI->RTSR = 0x00000000;
 80013f6:	6098      	str	r0, [r3, #8]
  EXTI->FTSR = 0x00000000;
 80013f8:	60d8      	str	r0, [r3, #12]
  EXTI->PR = 0x007FFFFF;
 80013fa:	615a      	str	r2, [r3, #20]
}
 80013fc:	4770      	bx	lr
 80013fe:	bf00      	nop
 8001400:	40013c00 	.word	0x40013c00
 8001404:	007fffff 	.word	0x007fffff

08001408 <EXTI_Init>:
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8001408:	7983      	ldrb	r3, [r0, #6]
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
  *         that contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 800140a:	b470      	push	{r4, r5, r6}
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 800140c:	b343      	cbz	r3, 8001460 <EXTI_Init+0x58>
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 800140e:	4b20      	ldr	r3, [pc, #128]	; (8001490 <EXTI_Init+0x88>)
 8001410:	6801      	ldr	r1, [r0, #0]
 8001412:	681e      	ldr	r6, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 8001414:	7902      	ldrb	r2, [r0, #4]
    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 8001416:	7945      	ldrb	r5, [r0, #5]
  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 8001418:	43cc      	mvns	r4, r1
 800141a:	ea04 0606 	and.w	r6, r4, r6
 800141e:	601e      	str	r6, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 8001420:	685e      	ldr	r6, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 8001422:	f102 4c80 	add.w	ip, r2, #1073741824	; 0x40000000
 8001426:	f50c 329e 	add.w	r2, ip, #80896	; 0x13c00
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 800142a:	4034      	ands	r4, r6
 800142c:	605c      	str	r4, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 800142e:	6814      	ldr	r4, [r2, #0]
 8001430:	ea44 0101 	orr.w	r1, r4, r1
 8001434:	6011      	str	r1, [r2, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 8001436:	6802      	ldr	r2, [r0, #0]
 8001438:	6898      	ldr	r0, [r3, #8]
 800143a:	43d1      	mvns	r1, r2
 800143c:	ea01 0000 	and.w	r0, r1, r0
 8001440:	6098      	str	r0, [r3, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 8001442:	68d8      	ldr	r0, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 8001444:	2d10      	cmp	r5, #16

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 8001446:	ea01 0100 	and.w	r1, r1, r0
 800144a:	60d9      	str	r1, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 800144c:	d016      	beq.n	800147c <EXTI_Init+0x74>
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
    }
    else
    {
      tmp = (uint32_t)EXTI_BASE;
      tmp += EXTI_InitStruct->EXTI_Trigger;
 800144e:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 8001452:	f505 359e 	add.w	r5, r5, #80896	; 0x13c00

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8001456:	6828      	ldr	r0, [r5, #0]
 8001458:	ea40 0302 	orr.w	r3, r0, r2
 800145c:	602b      	str	r3, [r5, #0]
 800145e:	e00b      	b.n	8001478 <EXTI_Init+0x70>
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 8001460:	7902      	ldrb	r2, [r0, #4]

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 8001462:	6801      	ldr	r1, [r0, #0]
      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 8001464:	f102 4080 	add.w	r0, r2, #1073741824	; 0x40000000
 8001468:	f500 3c9e 	add.w	ip, r0, #80896	; 0x13c00

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 800146c:	f8dc 3000 	ldr.w	r3, [ip]
 8001470:	ea23 0201 	bic.w	r2, r3, r1
 8001474:	f8cc 2000 	str.w	r2, [ip]
  }
}
 8001478:	bc70      	pop	{r4, r5, r6}
 800147a:	4770      	bx	lr
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 800147c:	6899      	ldr	r1, [r3, #8]
 800147e:	ea41 0002 	orr.w	r0, r1, r2
 8001482:	6098      	str	r0, [r3, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 8001484:	68d9      	ldr	r1, [r3, #12]
 8001486:	ea41 0002 	orr.w	r0, r1, r2
 800148a:	60d8      	str	r0, [r3, #12]
 800148c:	e7f4      	b.n	8001478 <EXTI_Init+0x70>
 800148e:	bf00      	nop
 8001490:	40013c00 	.word	0x40013c00

08001494 <EXTI_StructInit>:
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 8001494:	2300      	movs	r3, #0
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 8001496:	220c      	movs	r2, #12
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 8001498:	6003      	str	r3, [r0, #0]
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
 800149a:	7103      	strb	r3, [r0, #4]
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 800149c:	7142      	strb	r2, [r0, #5]
  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
 800149e:	7183      	strb	r3, [r0, #6]
}
 80014a0:	4770      	bx	lr
 80014a2:	bf00      	nop

080014a4 <EXTI_GenerateSWInterrupt>:
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->SWIER |= EXTI_Line;
 80014a4:	4b02      	ldr	r3, [pc, #8]	; (80014b0 <EXTI_GenerateSWInterrupt+0xc>)
 80014a6:	6919      	ldr	r1, [r3, #16]
 80014a8:	ea40 0201 	orr.w	r2, r0, r1
 80014ac:	611a      	str	r2, [r3, #16]
}
 80014ae:	4770      	bx	lr
 80014b0:	40013c00 	.word	0x40013c00

080014b4 <EXTI_GetFlagStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
 80014b4:	4903      	ldr	r1, [pc, #12]	; (80014c4 <EXTI_GetFlagStatus+0x10>)
 80014b6:	694b      	ldr	r3, [r1, #20]
  {
    bitstatus = SET;
 80014b8:	4218      	tst	r0, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80014ba:	bf0c      	ite	eq
 80014bc:	2000      	moveq	r0, #0
 80014be:	2001      	movne	r0, #1
 80014c0:	4770      	bx	lr
 80014c2:	bf00      	nop
 80014c4:	40013c00 	.word	0x40013c00

080014c8 <EXTI_ClearFlag>:
void EXTI_ClearFlag(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 80014c8:	4b01      	ldr	r3, [pc, #4]	; (80014d0 <EXTI_ClearFlag+0x8>)
 80014ca:	6158      	str	r0, [r3, #20]
}
 80014cc:	4770      	bx	lr
 80014ce:	bf00      	nop
 80014d0:	40013c00 	.word	0x40013c00

080014d4 <EXTI_GetITStatus>:
  ITStatus bitstatus = RESET;
  uint32_t enablestatus = 0;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  EXTI->IMR & EXTI_Line;
 80014d4:	4905      	ldr	r1, [pc, #20]	; (80014ec <EXTI_GetITStatus+0x18>)
 80014d6:	680a      	ldr	r2, [r1, #0]
  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 80014d8:	694b      	ldr	r3, [r1, #20]
 80014da:	4003      	ands	r3, r0
 80014dc:	d004      	beq.n	80014e8 <EXTI_GetITStatus+0x14>
  {
    bitstatus = SET;
 80014de:	4210      	tst	r0, r2
 80014e0:	bf0c      	ite	eq
 80014e2:	2000      	moveq	r0, #0
 80014e4:	2001      	movne	r0, #1
 80014e6:	4770      	bx	lr
  }
  else
  {
    bitstatus = RESET;
 80014e8:	4618      	mov	r0, r3
  }
  return bitstatus;
}
 80014ea:	4770      	bx	lr
 80014ec:	40013c00 	.word	0x40013c00

080014f0 <EXTI_ClearITPendingBit>:
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 80014f0:	4b01      	ldr	r3, [pc, #4]	; (80014f8 <EXTI_ClearITPendingBit+0x8>)
 80014f2:	6158      	str	r0, [r3, #20]
}
 80014f4:	4770      	bx	lr
 80014f6:	bf00      	nop
 80014f8:	40013c00 	.word	0x40013c00

080014fc <GPIO_DeInit>:
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
 80014fc:	4b3c      	ldr	r3, [pc, #240]	; (80015f0 <GPIO_DeInit+0xf4>)
 80014fe:	4298      	cmp	r0, r3
  * @note   By default, The GPIO pins are configured in input floating mode (except JTAG pins).
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 8001500:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
 8001502:	d024      	beq.n	800154e <GPIO_DeInit+0x52>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
 8001504:	493b      	ldr	r1, [pc, #236]	; (80015f4 <GPIO_DeInit+0xf8>)
 8001506:	4288      	cmp	r0, r1
 8001508:	d02b      	beq.n	8001562 <GPIO_DeInit+0x66>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
 800150a:	4a3b      	ldr	r2, [pc, #236]	; (80015f8 <GPIO_DeInit+0xfc>)
 800150c:	4290      	cmp	r0, r2
 800150e:	d032      	beq.n	8001576 <GPIO_DeInit+0x7a>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
 8001510:	4b3a      	ldr	r3, [pc, #232]	; (80015fc <GPIO_DeInit+0x100>)
 8001512:	4298      	cmp	r0, r3
 8001514:	d039      	beq.n	800158a <GPIO_DeInit+0x8e>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
  }
  else if (GPIOx == GPIOE)
 8001516:	493a      	ldr	r1, [pc, #232]	; (8001600 <GPIO_DeInit+0x104>)
 8001518:	4288      	cmp	r0, r1
 800151a:	d040      	beq.n	800159e <GPIO_DeInit+0xa2>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
  }
  else if (GPIOx == GPIOF)
 800151c:	4a39      	ldr	r2, [pc, #228]	; (8001604 <GPIO_DeInit+0x108>)
 800151e:	4290      	cmp	r0, r2
 8001520:	d047      	beq.n	80015b2 <GPIO_DeInit+0xb6>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
  }
  else if (GPIOx == GPIOG)
 8001522:	4b39      	ldr	r3, [pc, #228]	; (8001608 <GPIO_DeInit+0x10c>)
 8001524:	4298      	cmp	r0, r3
 8001526:	d04e      	beq.n	80015c6 <GPIO_DeInit+0xca>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
  }
  else if (GPIOx == GPIOH)
 8001528:	4938      	ldr	r1, [pc, #224]	; (800160c <GPIO_DeInit+0x110>)
 800152a:	4288      	cmp	r0, r1
 800152c:	d055      	beq.n	80015da <GPIO_DeInit+0xde>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
  }
  else
  {
    if (GPIOx == GPIOI)
 800152e:	4a38      	ldr	r2, [pc, #224]	; (8001610 <GPIO_DeInit+0x114>)
 8001530:	4290      	cmp	r0, r2
 8001532:	d000      	beq.n	8001536 <GPIO_DeInit+0x3a>
 8001534:	bd10      	pop	{r4, pc}
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
 8001536:	2101      	movs	r1, #1
 8001538:	f44f 7080 	mov.w	r0, #256	; 0x100
 800153c:	f7ff fe70 	bl	8001220 <RCC_AHB1PeriphResetCmd>
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 8001540:	f44f 7080 	mov.w	r0, #256	; 0x100
 8001544:	2100      	movs	r1, #0
    }
  }
}
 8001546:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  else
  {
    if (GPIOx == GPIOI)
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 800154a:	f7ff be69 	b.w	8001220 <RCC_AHB1PeriphResetCmd>
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 800154e:	2001      	movs	r0, #1
 8001550:	4601      	mov	r1, r0
 8001552:	f7ff fe65 	bl	8001220 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
 8001556:	2001      	movs	r0, #1
 8001558:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 800155a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
 800155e:	f7ff be5f 	b.w	8001220 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOB)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 8001562:	2002      	movs	r0, #2
 8001564:	2101      	movs	r1, #1
 8001566:	f7ff fe5b 	bl	8001220 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
 800156a:	2002      	movs	r0, #2
 800156c:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 800156e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
 8001572:	f7ff be55 	b.w	8001220 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOC)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 8001576:	2004      	movs	r0, #4
 8001578:	2101      	movs	r1, #1
 800157a:	f7ff fe51 	bl	8001220 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
 800157e:	2004      	movs	r0, #4
 8001580:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 8001582:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
 8001586:	f7ff be4b 	b.w	8001220 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOD)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 800158a:	2008      	movs	r0, #8
 800158c:	2101      	movs	r1, #1
 800158e:	f7ff fe47 	bl	8001220 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
 8001592:	2008      	movs	r0, #8
 8001594:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 8001596:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
 800159a:	f7ff be41 	b.w	8001220 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOE)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
 800159e:	2010      	movs	r0, #16
 80015a0:	2101      	movs	r1, #1
 80015a2:	f7ff fe3d 	bl	8001220 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
 80015a6:	2010      	movs	r0, #16
 80015a8:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80015aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
  }
  else if (GPIOx == GPIOE)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
 80015ae:	f7ff be37 	b.w	8001220 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOF)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
 80015b2:	2020      	movs	r0, #32
 80015b4:	2101      	movs	r1, #1
 80015b6:	f7ff fe33 	bl	8001220 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
 80015ba:	2020      	movs	r0, #32
 80015bc:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80015be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
  }
  else if (GPIOx == GPIOF)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
 80015c2:	f7ff be2d 	b.w	8001220 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOG)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
 80015c6:	2040      	movs	r0, #64	; 0x40
 80015c8:	2101      	movs	r1, #1
 80015ca:	f7ff fe29 	bl	8001220 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
 80015ce:	2040      	movs	r0, #64	; 0x40
 80015d0:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80015d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
  }
  else if (GPIOx == GPIOG)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
 80015d6:	f7ff be23 	b.w	8001220 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOH)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
 80015da:	2080      	movs	r0, #128	; 0x80
 80015dc:	2101      	movs	r1, #1
 80015de:	f7ff fe1f 	bl	8001220 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
 80015e2:	2080      	movs	r0, #128	; 0x80
 80015e4:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80015e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
  }
  else if (GPIOx == GPIOH)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
 80015ea:	f7ff be19 	b.w	8001220 <RCC_AHB1PeriphResetCmd>
 80015ee:	bf00      	nop
 80015f0:	40020000 	.word	0x40020000
 80015f4:	40020400 	.word	0x40020400
 80015f8:	40020800 	.word	0x40020800
 80015fc:	40020c00 	.word	0x40020c00
 8001600:	40021000 	.word	0x40021000
 8001604:	40021400 	.word	0x40021400
 8001608:	40021800 	.word	0x40021800
 800160c:	40021c00 	.word	0x40021c00
 8001610:	40022000 	.word	0x40022000

08001614 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8001614:	2300      	movs	r3, #0
 8001616:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800161a:	680a      	ldr	r2, [r1, #0]
 800161c:	461c      	mov	r4, r3
  {
    pos = ((uint32_t)0x01) << pinpos;
 800161e:	2601      	movs	r6, #1
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8001620:	f04f 0c03 	mov.w	ip, #3
 8001624:	e00b      	b.n	800163e <GPIO_Init+0x2a>
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8001626:	3401      	adds	r4, #1
  {
    pos = ((uint32_t)0x01) << pinpos;
 8001628:	fa16 f504 	lsls.w	r5, r6, r4
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 800162c:	ea05 0702 	and.w	r7, r5, r2
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8001630:	3302      	adds	r3, #2
  {
    pos = ((uint32_t)0x01) << pinpos;
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
 8001632:	42af      	cmp	r7, r5
 8001634:	d035      	beq.n	80016a2 <GPIO_Init+0x8e>
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8001636:	3401      	adds	r4, #1
 8001638:	3302      	adds	r3, #2
 800163a:	2c10      	cmp	r4, #16
 800163c:	d05a      	beq.n	80016f4 <GPIO_Init+0xe0>
  {
    pos = ((uint32_t)0x01) << pinpos;
 800163e:	fa16 f504 	lsls.w	r5, r6, r4
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8001642:	ea05 0702 	and.w	r7, r5, r2

    if (currentpin == pos)
 8001646:	42af      	cmp	r7, r5
 8001648:	d1ed      	bne.n	8001626 <GPIO_Init+0x12>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 800164a:	f8d0 9000 	ldr.w	r9, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 800164e:	f891 8004 	ldrb.w	r8, [r1, #4]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8001652:	fa0c f503 	lsl.w	r5, ip, r3
 8001656:	43ed      	mvns	r5, r5
 8001658:	ea05 0a09 	and.w	sl, r5, r9
 800165c:	f8c0 a000 	str.w	sl, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8001660:	f8d0 9000 	ldr.w	r9, [r0]
 8001664:	fa08 fa03 	lsl.w	sl, r8, r3

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8001668:	f108 38ff 	add.w	r8, r8, #4294967295
 800166c:	fa5f f888 	uxtb.w	r8, r8
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8001670:	ea4a 0909 	orr.w	r9, sl, r9

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8001674:	f1b8 0f01 	cmp.w	r8, #1
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8001678:	f8c0 9000 	str.w	r9, [r0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 800167c:	d93d      	bls.n	80016fa <GPIO_Init+0xe6>
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 800167e:	68c7      	ldr	r7, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8001680:	f891 8007 	ldrb.w	r8, [r1, #7]
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8001684:	403d      	ands	r5, r7
 8001686:	60c5      	str	r5, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8001688:	68c7      	ldr	r7, [r0, #12]
 800168a:	fa08 f503 	lsl.w	r5, r8, r3
 800168e:	433d      	orrs	r5, r7
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8001690:	3401      	adds	r4, #1
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8001692:	60c5      	str	r5, [r0, #12]

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
  {
    pos = ((uint32_t)0x01) << pinpos;
 8001694:	fa16 f504 	lsls.w	r5, r6, r4
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8001698:	ea05 0702 	and.w	r7, r5, r2
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800169c:	3302      	adds	r3, #2
  {
    pos = ((uint32_t)0x01) << pinpos;
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
 800169e:	42af      	cmp	r7, r5
 80016a0:	d1c9      	bne.n	8001636 <GPIO_Init+0x22>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80016a2:	f8d0 9000 	ldr.w	r9, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80016a6:	f891 8004 	ldrb.w	r8, [r1, #4]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80016aa:	fa0c f503 	lsl.w	r5, ip, r3
 80016ae:	43ed      	mvns	r5, r5
 80016b0:	ea05 0a09 	and.w	sl, r5, r9
 80016b4:	f8c0 a000 	str.w	sl, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80016b8:	f8d0 9000 	ldr.w	r9, [r0]
 80016bc:	fa08 fa03 	lsl.w	sl, r8, r3

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80016c0:	f108 38ff 	add.w	r8, r8, #4294967295
 80016c4:	fa5f f888 	uxtb.w	r8, r8
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80016c8:	ea4a 0909 	orr.w	r9, sl, r9

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80016cc:	f1b8 0f01 	cmp.w	r8, #1
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80016d0:	f8c0 9000 	str.w	r9, [r0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80016d4:	d931      	bls.n	800173a <GPIO_Init+0x126>
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 80016d6:	68c7      	ldr	r7, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80016d8:	f891 8007 	ldrb.w	r8, [r1, #7]
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 80016dc:	ea05 0707 	and.w	r7, r5, r7
 80016e0:	60c7      	str	r7, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80016e2:	68c7      	ldr	r7, [r0, #12]
 80016e4:	fa08 f503 	lsl.w	r5, r8, r3
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80016e8:	3401      	adds	r4, #1
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80016ea:	433d      	orrs	r5, r7
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80016ec:	3302      	adds	r3, #2
 80016ee:	2c10      	cmp	r4, #16
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80016f0:	60c5      	str	r5, [r0, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80016f2:	d1a4      	bne.n	800163e <GPIO_Init+0x2a>
      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 80016f4:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 80016f8:	4770      	bx	lr
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 80016fa:	f8d0 a008 	ldr.w	sl, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 80016fe:	f891 9005 	ldrb.w	r9, [r1, #5]
        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8001702:	f891 8006 	ldrb.w	r8, [r1, #6]
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8001706:	ea05 0a0a 	and.w	sl, r5, sl
 800170a:	f8c0 a008 	str.w	sl, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 800170e:	f8d0 a008 	ldr.w	sl, [r0, #8]
 8001712:	fa09 f903 	lsl.w	r9, r9, r3
 8001716:	ea49 090a 	orr.w	r9, r9, sl
 800171a:	f8c0 9008 	str.w	r9, [r0, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 800171e:	f8d0 9004 	ldr.w	r9, [r0, #4]
 8001722:	ea29 0707 	bic.w	r7, r9, r7
 8001726:	6047      	str	r7, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8001728:	6847      	ldr	r7, [r0, #4]
 800172a:	fa08 f804 	lsl.w	r8, r8, r4
 800172e:	fa1f f888 	uxth.w	r8, r8
 8001732:	ea48 0707 	orr.w	r7, r8, r7
 8001736:	6047      	str	r7, [r0, #4]
 8001738:	e7a1      	b.n	800167e <GPIO_Init+0x6a>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 800173a:	f8d0 a008 	ldr.w	sl, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 800173e:	f891 9005 	ldrb.w	r9, [r1, #5]
        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8001742:	f891 8006 	ldrb.w	r8, [r1, #6]
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8001746:	ea05 0a0a 	and.w	sl, r5, sl
 800174a:	f8c0 a008 	str.w	sl, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 800174e:	f8d0 a008 	ldr.w	sl, [r0, #8]
 8001752:	fa09 f903 	lsl.w	r9, r9, r3
 8001756:	ea49 090a 	orr.w	r9, r9, sl
 800175a:	f8c0 9008 	str.w	r9, [r0, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 800175e:	f8d0 9004 	ldr.w	r9, [r0, #4]
 8001762:	ea29 0707 	bic.w	r7, r9, r7
 8001766:	6047      	str	r7, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8001768:	6847      	ldr	r7, [r0, #4]
 800176a:	fa08 f804 	lsl.w	r8, r8, r4
 800176e:	fa1f f888 	uxth.w	r8, r8
 8001772:	ea48 0707 	orr.w	r7, r8, r7
 8001776:	6047      	str	r7, [r0, #4]
 8001778:	e7ad      	b.n	80016d6 <GPIO_Init+0xc2>
 800177a:	bf00      	nop

0800177c <GPIO_StructInit>:
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 800177c:	2300      	movs	r3, #0
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 800177e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001782:	6002      	str	r2, [r0, #0]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 8001784:	7103      	strb	r3, [r0, #4]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8001786:	7143      	strb	r3, [r0, #5]
  GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
 8001788:	7183      	strb	r3, [r0, #6]
  GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
 800178a:	71c3      	strb	r3, [r0, #7]
}
 800178c:	4770      	bx	lr
 800178e:	bf00      	nop

08001790 <GPIO_PinLockConfig>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8001790:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0x00010000;
 8001792:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8001796:	9201      	str	r2, [sp, #4]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  tmp |= GPIO_Pin;
 8001798:	9b01      	ldr	r3, [sp, #4]
 800179a:	ea41 0203 	orr.w	r2, r1, r3
 800179e:	9201      	str	r2, [sp, #4]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 80017a0:	9b01      	ldr	r3, [sp, #4]
 80017a2:	61c3      	str	r3, [r0, #28]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 80017a4:	61c1      	str	r1, [r0, #28]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 80017a6:	9a01      	ldr	r2, [sp, #4]
 80017a8:	61c2      	str	r2, [r0, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 80017aa:	69c1      	ldr	r1, [r0, #28]
 80017ac:	9101      	str	r1, [sp, #4]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 80017ae:	69c3      	ldr	r3, [r0, #28]
 80017b0:	9301      	str	r3, [sp, #4]
}
 80017b2:	b002      	add	sp, #8
 80017b4:	4770      	bx	lr
 80017b6:	bf00      	nop

080017b8 <GPIO_ReadInputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 80017b8:	6903      	ldr	r3, [r0, #16]
  {
    bitstatus = (uint8_t)Bit_SET;
 80017ba:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 80017bc:	bf0c      	ite	eq
 80017be:	2000      	moveq	r0, #0
 80017c0:	2001      	movne	r0, #1
 80017c2:	4770      	bx	lr

080017c4 <GPIO_ReadInputData>:
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->IDR);
 80017c4:	6900      	ldr	r0, [r0, #16]
}
 80017c6:	b280      	uxth	r0, r0
 80017c8:	4770      	bx	lr
 80017ca:	bf00      	nop

080017cc <GPIO_ReadOutputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 80017cc:	6943      	ldr	r3, [r0, #20]
  {
    bitstatus = (uint8_t)Bit_SET;
 80017ce:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 80017d0:	bf0c      	ite	eq
 80017d2:	2000      	moveq	r0, #0
 80017d4:	2001      	movne	r0, #1
 80017d6:	4770      	bx	lr

080017d8 <GPIO_ReadOutputData>:
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->ODR);
 80017d8:	6940      	ldr	r0, [r0, #20]
}
 80017da:	b280      	uxth	r0, r0
 80017dc:	4770      	bx	lr
 80017de:	bf00      	nop

080017e0 <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRL = GPIO_Pin;
 80017e0:	8301      	strh	r1, [r0, #24]
}
 80017e2:	4770      	bx	lr

080017e4 <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRH = GPIO_Pin;
 80017e4:	8341      	strh	r1, [r0, #26]
}
 80017e6:	4770      	bx	lr

080017e8 <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
 80017e8:	b90a      	cbnz	r2, 80017ee <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRRL = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRRH = GPIO_Pin ;
 80017ea:	8341      	strh	r1, [r0, #26]
 80017ec:	4770      	bx	lr
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
  {
    GPIOx->BSRRL = GPIO_Pin;
 80017ee:	8301      	strh	r1, [r0, #24]
 80017f0:	4770      	bx	lr
 80017f2:	bf00      	nop

080017f4 <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR = PortVal;
 80017f4:	6141      	str	r1, [r0, #20]
}
 80017f6:	4770      	bx	lr

080017f8 <GPIO_ToggleBits>:
void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR ^= GPIO_Pin;
 80017f8:	6942      	ldr	r2, [r0, #20]
 80017fa:	ea81 0302 	eor.w	r3, r1, r2
 80017fe:	6143      	str	r3, [r0, #20]
}
 8001800:	4770      	bx	lr
 8001802:	bf00      	nop

08001804 <GPIO_PinAFConfig>:
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8001804:	08cb      	lsrs	r3, r1, #3
 8001806:	3308      	adds	r3, #8
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8001808:	f001 0107 	and.w	r1, r1, #7
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 800180c:	b430      	push	{r4, r5}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 800180e:	0089      	lsls	r1, r1, #2
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8001810:	f850 5023 	ldr.w	r5, [r0, r3, lsl #2]
 8001814:	240f      	movs	r4, #15
 8001816:	408c      	lsls	r4, r1
 8001818:	ea25 0404 	bic.w	r4, r5, r4
 800181c:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8001820:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8001824:	fa12 f101 	lsls.w	r1, r2, r1
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8001828:	ea41 0404 	orr.w	r4, r1, r4
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 800182c:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
}
 8001830:	bc30      	pop	{r4, r5}
 8001832:	4770      	bx	lr

08001834 <usbd_cdc_EP0_RxReady>:
  *         Data received on control endpoint
  * @param  pdev: device device instance
  * @retval status
  */
static uint8_t  usbd_cdc_EP0_RxReady (void  *pdev)
{ 
 8001834:	b510      	push	{r4, lr}
  if (cdcCmd != NO_CMD)
 8001836:	4c07      	ldr	r4, [pc, #28]	; (8001854 <usbd_cdc_EP0_RxReady+0x20>)
 8001838:	6820      	ldr	r0, [r4, #0]
 800183a:	28ff      	cmp	r0, #255	; 0xff
 800183c:	d007      	beq.n	800184e <usbd_cdc_EP0_RxReady+0x1a>
  {
    /* Process the data */
    APP_FOPS.pIf_Ctrl(cdcCmd, CmdBuff, cdcLen);
 800183e:	4906      	ldr	r1, [pc, #24]	; (8001858 <usbd_cdc_EP0_RxReady+0x24>)
 8001840:	4a06      	ldr	r2, [pc, #24]	; (800185c <usbd_cdc_EP0_RxReady+0x28>)
 8001842:	688b      	ldr	r3, [r1, #8]
 8001844:	6812      	ldr	r2, [r2, #0]
 8001846:	4906      	ldr	r1, [pc, #24]	; (8001860 <usbd_cdc_EP0_RxReady+0x2c>)
 8001848:	4798      	blx	r3
    
    /* Reset the command variable to default value */
    cdcCmd = NO_CMD;
 800184a:	23ff      	movs	r3, #255	; 0xff
 800184c:	6023      	str	r3, [r4, #0]
  }
  
  return USBD_OK;
}
 800184e:	2000      	movs	r0, #0
 8001850:	bd10      	pop	{r4, pc}
 8001852:	bf00      	nop
 8001854:	200000a8 	.word	0x200000a8
 8001858:	20000014 	.word	0x20000014
 800185c:	200007f0 	.word	0x200007f0
 8001860:	200012a8 	.word	0x200012a8

08001864 <USBD_cdc_GetCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_cdc_GetCfgDesc (uint8_t speed, uint16_t *length)
{
  *length = sizeof (usbd_cdc_CfgDesc);
 8001864:	2343      	movs	r3, #67	; 0x43
 8001866:	800b      	strh	r3, [r1, #0]
  return usbd_cdc_CfgDesc;
}
 8001868:	4800      	ldr	r0, [pc, #0]	; (800186c <USBD_cdc_GetCfgDesc+0x8>)
 800186a:	4770      	bx	lr
 800186c:	200000ac 	.word	0x200000ac

08001870 <usbd_cdc_SOF>:
  * @param  pdev: instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  usbd_cdc_SOF (void *pdev)
{      
 8001870:	b538      	push	{r3, r4, r5, lr}
  static uint32_t FrameCount = 0;
  
  if (FrameCount++ == CDC_IN_FRAME_INTERVAL)
 8001872:	4c1f      	ldr	r4, [pc, #124]	; (80018f0 <usbd_cdc_SOF+0x80>)
 8001874:	6863      	ldr	r3, [r4, #4]
 8001876:	1c5a      	adds	r2, r3, #1
 8001878:	2b05      	cmp	r3, #5
 800187a:	6062      	str	r2, [r4, #4]
 800187c:	d001      	beq.n	8001882 <usbd_cdc_SOF+0x12>
    /* Check the data to be sent through IN pipe */
    Handle_USBAsynchXfer(pdev);
  }
  
  return USBD_OK;
}
 800187e:	2000      	movs	r0, #0
 8001880:	bd38      	pop	{r3, r4, r5, pc}
static void Handle_USBAsynchXfer (void *pdev)
{
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;
  
  if(USB_Tx_State != 1)
 8001882:	f894 c008 	ldrb.w	ip, [r4, #8]
  static uint32_t FrameCount = 0;
  
  if (FrameCount++ == CDC_IN_FRAME_INTERVAL)
  {
    /* Reset the frame counter */
    FrameCount = 0;
 8001886:	2300      	movs	r3, #0
static void Handle_USBAsynchXfer (void *pdev)
{
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;
  
  if(USB_Tx_State != 1)
 8001888:	f1bc 0f01 	cmp.w	ip, #1
  static uint32_t FrameCount = 0;
  
  if (FrameCount++ == CDC_IN_FRAME_INTERVAL)
  {
    /* Reset the frame counter */
    FrameCount = 0;
 800188c:	6063      	str	r3, [r4, #4]
static void Handle_USBAsynchXfer (void *pdev)
{
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;
  
  if(USB_Tx_State != 1)
 800188e:	d0f6      	beq.n	800187e <usbd_cdc_SOF+0xe>
  {
    if (APP_Rx_ptr_out == APP_RX_DATA_SIZE)
 8001890:	68e5      	ldr	r5, [r4, #12]
    {
      APP_Rx_ptr_out = 0;
    }
    
    if(APP_Rx_ptr_out == APP_Rx_ptr_in) 
 8001892:	4a17      	ldr	r2, [pc, #92]	; (80018f0 <usbd_cdc_SOF+0x80>)
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;
  
  if(USB_Tx_State != 1)
  {
    if (APP_Rx_ptr_out == APP_RX_DATA_SIZE)
 8001894:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
    {
      APP_Rx_ptr_out = 0;
 8001898:	bf04      	itt	eq
 800189a:	60e3      	streq	r3, [r4, #12]
 800189c:	461d      	moveq	r5, r3
    }
    
    if(APP_Rx_ptr_out == APP_Rx_ptr_in) 
 800189e:	6923      	ldr	r3, [r4, #16]
 80018a0:	42ab      	cmp	r3, r5
 80018a2:	d021      	beq.n	80018e8 <usbd_cdc_SOF+0x78>
      APP_Rx_length = APP_RX_DATA_SIZE - APP_Rx_ptr_out;
    
    }
    else 
    {
      APP_Rx_length = APP_Rx_ptr_in - APP_Rx_ptr_out;
 80018a4:	bf28      	it	cs
 80018a6:	ebc5 0103 	rsbcs	r1, r5, r3
    }
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     APP_Rx_length &= ~0x03;
#endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    
    if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE)
 80018aa:	f8d0 35ec 	ldr.w	r3, [r0, #1516]	; 0x5ec
 80018ae:	f8b3 3039 	ldrh.w	r3, [r3, #57]	; 0x39
      return;
    }
    
    if(APP_Rx_ptr_out > APP_Rx_ptr_in) /* rollback */
    { 
      APP_Rx_length = APP_RX_DATA_SIZE - APP_Rx_ptr_out;
 80018b2:	bf38      	it	cc
 80018b4:	f5c5 6100 	rsbcc	r1, r5, #2048	; 0x800
    }
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     APP_Rx_length &= ~0x03;
#endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    
    if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE)
 80018b8:	428b      	cmp	r3, r1
      APP_Rx_length = APP_RX_DATA_SIZE - APP_Rx_ptr_out;
    
    }
    else 
    {
      APP_Rx_length = APP_Rx_ptr_in - APP_Rx_ptr_out;
 80018ba:	6151      	str	r1, [r2, #20]
    }
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     APP_Rx_length &= ~0x03;
#endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    
    if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE)
 80018bc:	d20d      	bcs.n	80018da <usbd_cdc_SOF+0x6a>
    {
      USB_Tx_ptr = APP_Rx_ptr_out;
      USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
      
      APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;	
 80018be:	18ea      	adds	r2, r5, r3
      APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;
 80018c0:	1ac9      	subs	r1, r1, r3
     APP_Rx_length &= ~0x03;
#endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    
    if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE)
    {
      USB_Tx_ptr = APP_Rx_ptr_out;
 80018c2:	b2ad      	uxth	r5, r5
      USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
      
      APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;	
 80018c4:	60e2      	str	r2, [r4, #12]
      APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;
 80018c6:	6161      	str	r1, [r4, #20]
      APP_Rx_ptr_out += APP_Rx_length;
      APP_Rx_length = 0;
    }
    USB_Tx_State = 1; 

    DCD_EP_Tx (pdev,
 80018c8:	4a0a      	ldr	r2, [pc, #40]	; (80018f4 <usbd_cdc_SOF+0x84>)
 80018ca:	2181      	movs	r1, #129	; 0x81
 80018cc:	1952      	adds	r2, r2, r5
      USB_Tx_length = APP_Rx_length;
      
      APP_Rx_ptr_out += APP_Rx_length;
      APP_Rx_length = 0;
    }
    USB_Tx_State = 1; 
 80018ce:	2501      	movs	r5, #1
 80018d0:	7225      	strb	r5, [r4, #8]

    DCD_EP_Tx (pdev,
 80018d2:	f001 f871 	bl	80029b8 <DCD_EP_Tx>
    /* Check the data to be sent through IN pipe */
    Handle_USBAsynchXfer(pdev);
  }
  
  return USBD_OK;
}
 80018d6:	2000      	movs	r0, #0
 80018d8:	bd38      	pop	{r3, r4, r5, pc}
    else
    {
      USB_Tx_ptr = APP_Rx_ptr_out;
      USB_Tx_length = APP_Rx_length;
      
      APP_Rx_ptr_out += APP_Rx_length;
 80018da:	194a      	adds	r2, r1, r5
      APP_Rx_length = 0;
 80018dc:	2300      	movs	r3, #0
 80018de:	6163      	str	r3, [r4, #20]
      APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;	
      APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;
    }
    else
    {
      USB_Tx_ptr = APP_Rx_ptr_out;
 80018e0:	b2ad      	uxth	r5, r5
      USB_Tx_length = APP_Rx_length;
      
      APP_Rx_ptr_out += APP_Rx_length;
 80018e2:	60e2      	str	r2, [r4, #12]
      APP_Rx_length = 0;
 80018e4:	b28b      	uxth	r3, r1
 80018e6:	e7ef      	b.n	80018c8 <usbd_cdc_SOF+0x58>
      APP_Rx_ptr_out = 0;
    }
    
    if(APP_Rx_ptr_out == APP_Rx_ptr_in) 
    {
      USB_Tx_State = 0; 
 80018e8:	2000      	movs	r0, #0
 80018ea:	7210      	strb	r0, [r2, #8]
 80018ec:	e7c7      	b.n	800187e <usbd_cdc_SOF+0xe>
 80018ee:	bf00      	nop
 80018f0:	200007f0 	.word	0x200007f0
 80018f4:	200012b0 	.word	0x200012b0

080018f8 <usbd_cdc_DataIn>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  usbd_cdc_DataIn (void *pdev, uint8_t epnum)
{
 80018f8:	b538      	push	{r3, r4, r5, lr}
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;

  if (USB_Tx_State == 1)
 80018fa:	4913      	ldr	r1, [pc, #76]	; (8001948 <usbd_cdc_DataIn+0x50>)
 80018fc:	7a0b      	ldrb	r3, [r1, #8]
 80018fe:	2b01      	cmp	r3, #1
 8001900:	d001      	beq.n	8001906 <usbd_cdc_DataIn+0xe>
                 USB_Tx_length);
    }
  }  
  
  return USBD_OK;
}
 8001902:	2000      	movs	r0, #0
 8001904:	bd38      	pop	{r3, r4, r5, pc}
  uint16_t USB_Tx_ptr;
  uint16_t USB_Tx_length;

  if (USB_Tx_State == 1)
  {
    if (APP_Rx_length == 0) 
 8001906:	694c      	ldr	r4, [r1, #20]
 8001908:	b1d4      	cbz	r4, 8001940 <usbd_cdc_DataIn+0x48>
    {
      USB_Tx_State = 0;
    }
    else 
    {
      if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE){
 800190a:	f8d0 25ec 	ldr.w	r2, [r0, #1516]	; 0x5ec
 800190e:	f8b2 3039 	ldrh.w	r3, [r2, #57]	; 0x39
 8001912:	429c      	cmp	r4, r3
 8001914:	d80d      	bhi.n	8001932 <usbd_cdc_DataIn+0x3a>
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
        APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;    
      }
      else 
      {
        USB_Tx_ptr = APP_Rx_ptr_out;
 8001916:	68ca      	ldr	r2, [r1, #12]
        USB_Tx_length = APP_Rx_length;
        
        APP_Rx_ptr_out += APP_Rx_length;
 8001918:	1913      	adds	r3, r2, r4
 800191a:	60cb      	str	r3, [r1, #12]
        APP_Rx_length = 0;
 800191c:	2300      	movs	r3, #0
 800191e:	614b      	str	r3, [r1, #20]
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
        APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;    
      }
      else 
      {
        USB_Tx_ptr = APP_Rx_ptr_out;
 8001920:	b292      	uxth	r2, r2
        USB_Tx_length = APP_Rx_length;
        
        APP_Rx_ptr_out += APP_Rx_length;
        APP_Rx_length = 0;
 8001922:	b2a3      	uxth	r3, r4
      }
      
      /* Prepare the available data buffer to be sent on IN endpoint */
      DCD_EP_Tx (pdev,
 8001924:	4c09      	ldr	r4, [pc, #36]	; (800194c <usbd_cdc_DataIn+0x54>)
 8001926:	2181      	movs	r1, #129	; 0x81
 8001928:	18a2      	adds	r2, r4, r2
 800192a:	f001 f845 	bl	80029b8 <DCD_EP_Tx>
                 USB_Tx_length);
    }
  }  
  
  return USBD_OK;
}
 800192e:	2000      	movs	r0, #0
 8001930:	bd38      	pop	{r3, r4, r5, pc}
      USB_Tx_State = 0;
    }
    else 
    {
      if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE){
        USB_Tx_ptr = APP_Rx_ptr_out;
 8001932:	68ca      	ldr	r2, [r1, #12]
        USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
        
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
        APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;    
 8001934:	1ae4      	subs	r4, r4, r3
    {
      if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE){
        USB_Tx_ptr = APP_Rx_ptr_out;
        USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
        
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
 8001936:	189d      	adds	r5, r3, r2
 8001938:	60cd      	str	r5, [r1, #12]
      USB_Tx_State = 0;
    }
    else 
    {
      if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE){
        USB_Tx_ptr = APP_Rx_ptr_out;
 800193a:	b292      	uxth	r2, r2
        USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
        
        APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
        APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;    
 800193c:	614c      	str	r4, [r1, #20]
 800193e:	e7f1      	b.n	8001924 <usbd_cdc_DataIn+0x2c>

  if (USB_Tx_State == 1)
  {
    if (APP_Rx_length == 0) 
    {
      USB_Tx_State = 0;
 8001940:	720c      	strb	r4, [r1, #8]
                 USB_Tx_length);
    }
  }  
  
  return USBD_OK;
}
 8001942:	2000      	movs	r0, #0
 8001944:	bd38      	pop	{r3, r4, r5, pc}
 8001946:	bf00      	nop
 8001948:	200007f0 	.word	0x200007f0
 800194c:	200012b0 	.word	0x200012b0

08001950 <usbd_cdc_DataOut>:
static uint8_t  usbd_cdc_DataOut (void *pdev, uint8_t epnum)
{      
  uint16_t USB_Rx_Cnt;
  
  /* Get the received data buffer and update the counter */
  USB_Rx_Cnt = ((USB_OTG_CORE_HANDLE*)pdev)->dev.out_ep[epnum].xfer_count;
 8001950:	eb01 0c81 	add.w	ip, r1, r1, lsl #2
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  usbd_cdc_DataOut (void *pdev, uint8_t epnum)
{      
 8001954:	b538      	push	{r3, r4, r5, lr}
  uint16_t USB_Rx_Cnt;
  
  /* Get the received data buffer and update the counter */
  USB_Rx_Cnt = ((USB_OTG_CORE_HANDLE*)pdev)->dev.out_ep[epnum].xfer_count;
 8001956:	eb00 01cc 	add.w	r1, r0, ip, lsl #3
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  usbd_cdc_DataOut (void *pdev, uint8_t epnum)
{      
 800195a:	4604      	mov	r4, r0
  /* Get the received data buffer and update the counter */
  USB_Rx_Cnt = ((USB_OTG_CORE_HANDLE*)pdev)->dev.out_ep[epnum].xfer_count;
  
  /* USB data will be immediately processed, this allow next USB traffic being 
     NAKed till the end of the application Xfer */
  APP_FOPS.pIf_DataRx(USB_Rx_Buffer, USB_Rx_Cnt);
 800195c:	4d08      	ldr	r5, [pc, #32]	; (8001980 <usbd_cdc_DataOut+0x30>)
 800195e:	4809      	ldr	r0, [pc, #36]	; (8001984 <usbd_cdc_DataOut+0x34>)
 8001960:	f8b1 1388 	ldrh.w	r1, [r1, #904]	; 0x388
 8001964:	6902      	ldr	r2, [r0, #16]
 8001966:	4628      	mov	r0, r5
 8001968:	4790      	blx	r2
  
  /* Prepare Out endpoint to receive next packet */
  DCD_EP_PrepareRx(pdev,
 800196a:	f8d4 35ec 	ldr.w	r3, [r4, #1516]	; 0x5ec
 800196e:	4620      	mov	r0, r4
 8001970:	2101      	movs	r1, #1
 8001972:	462a      	mov	r2, r5
 8001974:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8001978:	f000 fff4 	bl	8002964 <DCD_EP_PrepareRx>
                   CDC_OUT_EP,
                   (uint8_t*)(USB_Rx_Buffer),
                   CDC_DATA_OUT_PACKET_SIZE);

  return USBD_OK;
}
 800197c:	2000      	movs	r0, #0
 800197e:	bd38      	pop	{r3, r4, r5, pc}
 8001980:	20001268 	.word	0x20001268
 8001984:	20000014 	.word	0x20000014

08001988 <usbd_cdc_Setup>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t  usbd_cdc_Setup (void  *pdev, 
                                USB_SETUP_REQ *req)
{
 8001988:	b570      	push	{r4, r5, r6, lr}
  uint16_t len;
  uint8_t  *pbuf;
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800198a:	780b      	ldrb	r3, [r1, #0]
 800198c:	f013 0560 	ands.w	r5, r3, #96	; 0x60
  * @param  req: usb requests
  * @retval status
  */
static uint8_t  usbd_cdc_Setup (void  *pdev, 
                                USB_SETUP_REQ *req)
{
 8001990:	460c      	mov	r4, r1
 8001992:	4606      	mov	r6, r0
  uint16_t len;
  uint8_t  *pbuf;
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8001994:	d108      	bne.n	80019a8 <usbd_cdc_Setup+0x20>
    
      
      
    /* Standard Requests -------------------------------*/
  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
 8001996:	784b      	ldrb	r3, [r1, #1]
 8001998:	2b0a      	cmp	r3, #10
 800199a:	d01c      	beq.n	80019d6 <usbd_cdc_Setup+0x4e>
 800199c:	2b0b      	cmp	r3, #11
 800199e:	d02d      	beq.n	80019fc <usbd_cdc_Setup+0x74>
 80019a0:	2b06      	cmp	r3, #6
 80019a2:	d031      	beq.n	8001a08 <usbd_cdc_Setup+0x80>
        USBD_CtlError (pdev, req);
      }
      break;
    }
  }
  return USBD_OK;
 80019a4:	4628      	mov	r0, r5
}
 80019a6:	bd70      	pop	{r4, r5, r6, pc}
                                USB_SETUP_REQ *req)
{
  uint16_t len;
  uint8_t  *pbuf;
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80019a8:	2d20      	cmp	r5, #32
 80019aa:	d003      	beq.n	80019b4 <usbd_cdc_Setup+0x2c>
      }
      
      return USBD_OK;
      
    default:
      USBD_CtlError (pdev, req);
 80019ac:	f001 fd0e 	bl	80033cc <USBD_CtlError>
      return USBD_FAIL;
 80019b0:	2002      	movs	r0, #2
 80019b2:	bd70      	pop	{r4, r5, r6, pc}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
  {
    /* CDC Class Requests -------------------------------*/
  case USB_REQ_TYPE_CLASS :
      /* Check if the request is a data setup packet */
      if (req->wLength)
 80019b4:	88cd      	ldrh	r5, [r1, #6]
 80019b6:	2d00      	cmp	r5, #0
 80019b8:	d034      	beq.n	8001a24 <usbd_cdc_Setup+0x9c>
      {
        /* Check if the request is Device-to-Host */
        if (req->bmRequest & 0x80)
 80019ba:	f013 0f80 	tst.w	r3, #128	; 0x80
 80019be:	d110      	bne.n	80019e2 <usbd_cdc_Setup+0x5a>
                            req->wLength);          
        }
        else /* Host-to-Device requeset */
        {
          /* Set the value of the current command to be processed */
          cdcCmd = req->bRequest;
 80019c0:	784a      	ldrb	r2, [r1, #1]
 80019c2:	4b1e      	ldr	r3, [pc, #120]	; (8001a3c <usbd_cdc_Setup+0xb4>)
          cdcLen = req->wLength;
          
          /* Prepare the reception of the buffer over EP0
          Next step: the received data will be managed in usbd_cdc_EP0_TxSent() 
          function. */
          USBD_CtlPrepareRx (pdev,
 80019c4:	491e      	ldr	r1, [pc, #120]	; (8001a40 <usbd_cdc_Setup+0xb8>)
                            req->wLength);          
        }
        else /* Host-to-Device requeset */
        {
          /* Set the value of the current command to be processed */
          cdcCmd = req->bRequest;
 80019c6:	601a      	str	r2, [r3, #0]
          cdcLen = req->wLength;
 80019c8:	4b1e      	ldr	r3, [pc, #120]	; (8001a44 <usbd_cdc_Setup+0xbc>)
          
          /* Prepare the reception of the buffer over EP0
          Next step: the received data will be managed in usbd_cdc_EP0_TxSent() 
          function. */
          USBD_CtlPrepareRx (pdev,
 80019ca:	462a      	mov	r2, r5
        }
        else /* Host-to-Device requeset */
        {
          /* Set the value of the current command to be processed */
          cdcCmd = req->bRequest;
          cdcLen = req->wLength;
 80019cc:	601d      	str	r5, [r3, #0]
          
          /* Prepare the reception of the buffer over EP0
          Next step: the received data will be managed in usbd_cdc_EP0_TxSent() 
          function. */
          USBD_CtlPrepareRx (pdev,
 80019ce:	f001 fc91 	bl	80032f4 <USBD_CtlPrepareRx>
      {
        /* Transfer the command to the interface layer */
        APP_FOPS.pIf_Ctrl(req->bRequest, NULL, 0);
      }
      
      return USBD_OK;
 80019d2:	2000      	movs	r0, #0
 80019d4:	bd70      	pop	{r4, r5, r6, pc}
                        pbuf,
                        len);
      break;
      
    case USB_REQ_GET_INTERFACE :
      USBD_CtlSendData (pdev,
 80019d6:	491c      	ldr	r1, [pc, #112]	; (8001a48 <usbd_cdc_Setup+0xc0>)
 80019d8:	2201      	movs	r2, #1
 80019da:	f001 fc71 	bl	80032c0 <USBD_CtlSendData>
        USBD_CtlError (pdev, req);
      }
      break;
    }
  }
  return USBD_OK;
 80019de:	4628      	mov	r0, r5
      
    case USB_REQ_GET_INTERFACE :
      USBD_CtlSendData (pdev,
                        (uint8_t *)&usbd_cdc_AltSet,
                        1);
      break;
 80019e0:	bd70      	pop	{r4, r5, r6, pc}
      {
        /* Check if the request is Device-to-Host */
        if (req->bmRequest & 0x80)
        {
          /* Get the data to be sent to Host from interface layer */
          APP_FOPS.pIf_Ctrl(req->bRequest, CmdBuff, req->wLength);
 80019e2:	481a      	ldr	r0, [pc, #104]	; (8001a4c <usbd_cdc_Setup+0xc4>)
 80019e4:	4916      	ldr	r1, [pc, #88]	; (8001a40 <usbd_cdc_Setup+0xb8>)
 80019e6:	6883      	ldr	r3, [r0, #8]
 80019e8:	7860      	ldrb	r0, [r4, #1]
 80019ea:	462a      	mov	r2, r5
 80019ec:	4798      	blx	r3
          
          /* Send the data to the host */
          USBD_CtlSendData (pdev, 
 80019ee:	4630      	mov	r0, r6
 80019f0:	4913      	ldr	r1, [pc, #76]	; (8001a40 <usbd_cdc_Setup+0xb8>)
 80019f2:	88e2      	ldrh	r2, [r4, #6]
 80019f4:	f001 fc64 	bl	80032c0 <USBD_CtlSendData>
      {
        /* Transfer the command to the interface layer */
        APP_FOPS.pIf_Ctrl(req->bRequest, NULL, 0);
      }
      
      return USBD_OK;
 80019f8:	2000      	movs	r0, #0
 80019fa:	bd70      	pop	{r4, r5, r6, pc}
                        (uint8_t *)&usbd_cdc_AltSet,
                        1);
      break;
      
    case USB_REQ_SET_INTERFACE :
      if ((uint8_t)(req->wValue) < USBD_ITF_MAX_NUM)
 80019fc:	788b      	ldrb	r3, [r1, #2]
 80019fe:	b9cb      	cbnz	r3, 8001a34 <usbd_cdc_Setup+0xac>
      {
        usbd_cdc_AltSet = (uint8_t)(req->wValue);
 8001a00:	4a10      	ldr	r2, [pc, #64]	; (8001a44 <usbd_cdc_Setup+0xbc>)
        USBD_CtlError (pdev, req);
      }
      break;
    }
  }
  return USBD_OK;
 8001a02:	4618      	mov	r0, r3
      break;
      
    case USB_REQ_SET_INTERFACE :
      if ((uint8_t)(req->wValue) < USBD_ITF_MAX_NUM)
      {
        usbd_cdc_AltSet = (uint8_t)(req->wValue);
 8001a04:	6193      	str	r3, [r2, #24]
 8001a06:	bd70      	pop	{r4, r5, r6, pc}
    /* Standard Requests -------------------------------*/
  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
    {
    case USB_REQ_GET_DESCRIPTOR: 
      if( (req->wValue >> 8) == CDC_DESCRIPTOR_TYPE)
 8001a08:	884b      	ldrh	r3, [r1, #2]
 8001a0a:	0a18      	lsrs	r0, r3, #8
 8001a0c:	2821      	cmp	r0, #33	; 0x21
 8001a0e:	d103      	bne.n	8001a18 <usbd_cdc_Setup+0x90>
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
        pbuf = usbd_cdc_Desc;   
#else
        pbuf = usbd_cdc_CfgDesc + 9 + (9 * USBD_ITF_MAX_NUM);
#endif 
        len = MIN(USB_CDC_DESC_SIZ , req->wLength);
 8001a10:	88ca      	ldrh	r2, [r1, #6]
 8001a12:	2a3a      	cmp	r2, #58	; 0x3a
 8001a14:	bf28      	it	cs
 8001a16:	223a      	movcs	r2, #58	; 0x3a
      }
      
      USBD_CtlSendData (pdev, 
 8001a18:	4630      	mov	r0, r6
 8001a1a:	490d      	ldr	r1, [pc, #52]	; (8001a50 <usbd_cdc_Setup+0xc8>)
 8001a1c:	f001 fc50 	bl	80032c0 <USBD_CtlSendData>
        USBD_CtlError (pdev, req);
      }
      break;
    }
  }
  return USBD_OK;
 8001a20:	2000      	movs	r0, #0
      }
      
      USBD_CtlSendData (pdev, 
                        pbuf,
                        len);
      break;
 8001a22:	bd70      	pop	{r4, r5, r6, pc}
        }
      }
      else /* No Data request */
      {
        /* Transfer the command to the interface layer */
        APP_FOPS.pIf_Ctrl(req->bRequest, NULL, 0);
 8001a24:	7848      	ldrb	r0, [r1, #1]
 8001a26:	4909      	ldr	r1, [pc, #36]	; (8001a4c <usbd_cdc_Setup+0xc4>)
 8001a28:	462a      	mov	r2, r5
 8001a2a:	688b      	ldr	r3, [r1, #8]
 8001a2c:	4629      	mov	r1, r5
 8001a2e:	4798      	blx	r3
      }
      
      return USBD_OK;
 8001a30:	4628      	mov	r0, r5
 8001a32:	bd70      	pop	{r4, r5, r6, pc}
        usbd_cdc_AltSet = (uint8_t)(req->wValue);
      }
      else
      {
        /* Call the error management function (command will be nacked */
        USBD_CtlError (pdev, req);
 8001a34:	f001 fcca 	bl	80033cc <USBD_CtlError>
      }
      break;
    }
  }
  return USBD_OK;
 8001a38:	4628      	mov	r0, r5
 8001a3a:	bd70      	pop	{r4, r5, r6, pc}
 8001a3c:	200000a8 	.word	0x200000a8
 8001a40:	200012a8 	.word	0x200012a8
 8001a44:	200007f0 	.word	0x200007f0
 8001a48:	20000808 	.word	0x20000808
 8001a4c:	20000014 	.word	0x20000014
 8001a50:	200000be 	.word	0x200000be

08001a54 <usbd_cdc_DeInit>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  usbd_cdc_DeInit (void  *pdev, 
                                 uint8_t cfgidx)
{
 8001a54:	b510      	push	{r4, lr}
  /* Open EP IN */
  DCD_EP_Close(pdev,
 8001a56:	2181      	movs	r1, #129	; 0x81
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  usbd_cdc_DeInit (void  *pdev, 
                                 uint8_t cfgidx)
{
 8001a58:	4604      	mov	r4, r0
  /* Open EP IN */
  DCD_EP_Close(pdev,
 8001a5a:	f000 ff6d 	bl	8002938 <DCD_EP_Close>
              CDC_IN_EP);
  
  /* Open EP OUT */
  DCD_EP_Close(pdev,
 8001a5e:	2101      	movs	r1, #1
 8001a60:	4620      	mov	r0, r4
 8001a62:	f000 ff69 	bl	8002938 <DCD_EP_Close>
              CDC_OUT_EP);
  
  /* Open Command IN EP */
  DCD_EP_Close(pdev,
 8001a66:	2182      	movs	r1, #130	; 0x82
 8001a68:	4620      	mov	r0, r4
 8001a6a:	f000 ff65 	bl	8002938 <DCD_EP_Close>
              CDC_CMD_EP);

  /* Restore default state of the Interface physical components */
  APP_FOPS.pIf_DeInit();
 8001a6e:	4802      	ldr	r0, [pc, #8]	; (8001a78 <usbd_cdc_DeInit+0x24>)
 8001a70:	6843      	ldr	r3, [r0, #4]
 8001a72:	4798      	blx	r3
  
  return USBD_OK;
}
 8001a74:	2000      	movs	r0, #0
 8001a76:	bd10      	pop	{r4, pc}
 8001a78:	20000014 	.word	0x20000014

08001a7c <usbd_cdc_Init>:
                               uint8_t cfgidx)
{
  uint8_t *pbuf;

  /* Open EP IN */
  DCD_EP_Open(pdev,
 8001a7c:	f8d0 25ec 	ldr.w	r2, [r0, #1516]	; 0x5ec
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  usbd_cdc_Init (void  *pdev, 
                               uint8_t cfgidx)
{
 8001a80:	b538      	push	{r3, r4, r5, lr}
 8001a82:	4604      	mov	r4, r0
  uint8_t *pbuf;

  /* Open EP IN */
  DCD_EP_Open(pdev,
 8001a84:	2181      	movs	r1, #129	; 0x81
 8001a86:	2302      	movs	r3, #2
 8001a88:	f8b2 2039 	ldrh.w	r2, [r2, #57]	; 0x39
 8001a8c:	f000 ff34 	bl	80028f8 <DCD_EP_Open>
              CDC_IN_EP,
              CDC_DATA_IN_PACKET_SIZE,
              USB_OTG_EP_BULK);
  
  /* Open EP OUT */
  DCD_EP_Open(pdev,
 8001a90:	f8d4 55ec 	ldr.w	r5, [r4, #1516]	; 0x5ec
 8001a94:	2101      	movs	r1, #1
 8001a96:	f8b5 2040 	ldrh.w	r2, [r5, #64]	; 0x40
 8001a9a:	2302      	movs	r3, #2
 8001a9c:	4620      	mov	r0, r4
 8001a9e:	f000 ff2b 	bl	80028f8 <DCD_EP_Open>
              CDC_OUT_EP,
              CDC_DATA_OUT_PACKET_SIZE,
              USB_OTG_EP_BULK);
  
  /* Open Command IN EP */
  DCD_EP_Open(pdev,
 8001aa2:	2182      	movs	r1, #130	; 0x82
 8001aa4:	2208      	movs	r2, #8
 8001aa6:	2303      	movs	r3, #3
 8001aa8:	4620      	mov	r0, r4
 8001aaa:	f000 ff25 	bl	80028f8 <DCD_EP_Open>
              CDC_CMD_EP,
              CDC_CMD_PACKET_SZE,
              USB_OTG_EP_INT);
  
  pbuf = (uint8_t *)USBD_DeviceDesc;
  pbuf[4] = DEVICE_CLASS_CDC;
 8001aae:	4b09      	ldr	r3, [pc, #36]	; (8001ad4 <usbd_cdc_Init+0x58>)
  pbuf[5] = DEVICE_SUBCLASS_CDC;
  
  /* Initialize the Interface physical components */
  APP_FOPS.pIf_Init();
 8001ab0:	4909      	ldr	r1, [pc, #36]	; (8001ad8 <usbd_cdc_Init+0x5c>)
              CDC_CMD_EP,
              CDC_CMD_PACKET_SZE,
              USB_OTG_EP_INT);
  
  pbuf = (uint8_t *)USBD_DeviceDesc;
  pbuf[4] = DEVICE_CLASS_CDC;
 8001ab2:	2202      	movs	r2, #2
  pbuf[5] = DEVICE_SUBCLASS_CDC;
 8001ab4:	2500      	movs	r5, #0
              CDC_CMD_EP,
              CDC_CMD_PACKET_SZE,
              USB_OTG_EP_INT);
  
  pbuf = (uint8_t *)USBD_DeviceDesc;
  pbuf[4] = DEVICE_CLASS_CDC;
 8001ab6:	711a      	strb	r2, [r3, #4]
  pbuf[5] = DEVICE_SUBCLASS_CDC;
 8001ab8:	715d      	strb	r5, [r3, #5]
  
  /* Initialize the Interface physical components */
  APP_FOPS.pIf_Init();
 8001aba:	6808      	ldr	r0, [r1, #0]
 8001abc:	4780      	blx	r0

  /* Prepare Out endpoint to receive next packet */
  DCD_EP_PrepareRx(pdev,
 8001abe:	f8d4 35ec 	ldr.w	r3, [r4, #1516]	; 0x5ec
 8001ac2:	4a06      	ldr	r2, [pc, #24]	; (8001adc <usbd_cdc_Init+0x60>)
 8001ac4:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8001ac8:	4620      	mov	r0, r4
 8001aca:	2101      	movs	r1, #1
 8001acc:	f000 ff4a 	bl	8002964 <DCD_EP_PrepareRx>
                   CDC_OUT_EP,
                   (uint8_t*)(USB_Rx_Buffer),
                   CDC_DATA_OUT_PACKET_SIZE);
  
  return USBD_OK;
}
 8001ad0:	4628      	mov	r0, r5
 8001ad2:	bd38      	pop	{r3, r4, r5, pc}
 8001ad4:	20000058 	.word	0x20000058
 8001ad8:	20000014 	.word	0x20000014
 8001adc:	20001268 	.word	0x20001268

08001ae0 <USB_OTG_CoreReset.clone.1>:
/**
* @brief  USB_OTG_CoreReset : Soft reset of the core
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
 8001ae0:	b530      	push	{r4, r5, lr}
 8001ae2:	4605      	mov	r5, r0
 8001ae4:	b083      	sub	sp, #12
{
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 8001ae6:	2300      	movs	r3, #0
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 8001ae8:	2003      	movs	r0, #3
{
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 8001aea:	9301      	str	r3, [sp, #4]
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 8001aec:	f001 ff21 	bl	8003932 <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001af0:	682b      	ldr	r3, [r5, #0]
 8001af2:	4c1b      	ldr	r4, [pc, #108]	; (8001b60 <USB_OTG_CoreReset.clone.1+0x80>)
 8001af4:	691a      	ldr	r2, [r3, #16]
 8001af6:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
    {
      return USB_OTG_OK;
    }
  }
  while (greset.b.ahbidle == 0);
 8001af8:	9a01      	ldr	r2, [sp, #4]
 8001afa:	2a00      	cmp	r2, #0
 8001afc:	db14      	blt.n	8001b28 <USB_OTG_CoreReset.clone.1+0x48>
  
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 8001afe:	2003      	movs	r0, #3
 8001b00:	f001 ff17 	bl	8003932 <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b04:	682b      	ldr	r3, [r5, #0]
 8001b06:	6919      	ldr	r1, [r3, #16]
 8001b08:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
    {
      return USB_OTG_OK;
    }
  }
  while (greset.b.ahbidle == 0);
 8001b0a:	9801      	ldr	r0, [sp, #4]
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b0c:	3c01      	subs	r4, #1
    if (++count > 200000)
    {
      return USB_OTG_OK;
    }
  }
  while (greset.b.ahbidle == 0);
 8001b0e:	2800      	cmp	r0, #0
 8001b10:	db0a      	blt.n	8001b28 <USB_OTG_CoreReset.clone.1+0x48>
  
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 8001b12:	2003      	movs	r0, #3
 8001b14:	f001 ff0d 	bl	8003932 <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b18:	682b      	ldr	r3, [r5, #0]
 8001b1a:	691a      	ldr	r2, [r3, #16]
    if (++count > 200000)
 8001b1c:	3c01      	subs	r4, #1
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b1e:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 8001b20:	d1ea      	bne.n	8001af8 <USB_OTG_CoreReset.clone.1+0x18>
  }
  while (greset.b.csftrst == 1);
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
  return status;
}
 8001b22:	2000      	movs	r0, #0
 8001b24:	b003      	add	sp, #12
 8001b26:	bd30      	pop	{r4, r5, pc}
    }
  }
  while (greset.b.ahbidle == 0);
  /* Core Soft Reset */
  count = 0;
  greset.b.csftrst = 1;
 8001b28:	9901      	ldr	r1, [sp, #4]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b2a:	4a0d      	ldr	r2, [pc, #52]	; (8001b60 <USB_OTG_CoreReset.clone.1+0x80>)
    }
  }
  while (greset.b.ahbidle == 0);
  /* Core Soft Reset */
  count = 0;
  greset.b.csftrst = 1;
 8001b2c:	f041 0001 	orr.w	r0, r1, #1
 8001b30:	9001      	str	r0, [sp, #4]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8001b32:	9901      	ldr	r1, [sp, #4]
 8001b34:	6119      	str	r1, [r3, #16]
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b36:	6918      	ldr	r0, [r3, #16]
 8001b38:	9001      	str	r0, [sp, #4]
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.csftrst == 1);
 8001b3a:	9801      	ldr	r0, [sp, #4]
 8001b3c:	f010 0f01 	tst.w	r0, #1
 8001b40:	d00a      	beq.n	8001b58 <USB_OTG_CoreReset.clone.1+0x78>
  count = 0;
  greset.b.csftrst = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b42:	6919      	ldr	r1, [r3, #16]
 8001b44:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.csftrst == 1);
 8001b46:	9801      	ldr	r0, [sp, #4]
  count = 0;
  greset.b.csftrst = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b48:	3a01      	subs	r2, #1
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.csftrst == 1);
 8001b4a:	f010 0f01 	tst.w	r0, #1
 8001b4e:	d003      	beq.n	8001b58 <USB_OTG_CoreReset.clone.1+0x78>
  count = 0;
  greset.b.csftrst = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b50:	6919      	ldr	r1, [r3, #16]
    if (++count > 200000)
 8001b52:	3a01      	subs	r2, #1
  count = 0;
  greset.b.csftrst = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8001b54:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
 8001b56:	d1f0      	bne.n	8001b3a <USB_OTG_CoreReset.clone.1+0x5a>
      break;
    }
  }
  while (greset.b.csftrst == 1);
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 8001b58:	2003      	movs	r0, #3
 8001b5a:	f001 feea 	bl	8003932 <USB_OTG_BSP_uDelay>
 8001b5e:	e7e0      	b.n	8001b22 <USB_OTG_CoreReset.clone.1+0x42>
 8001b60:	00030d40 	.word	0x00030d40

08001b64 <USB_OTG_WritePacket>:
*/
USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t             *src, 
                                uint8_t             ch_ep_num, 
                                uint16_t            len)
{
 8001b64:	b430      	push	{r4, r5}
  USB_OTG_STS status = USB_OTG_OK;
  if (pdev->cfg.dma_enable == 0)
 8001b66:	78c4      	ldrb	r4, [r0, #3]
 8001b68:	bb04      	cbnz	r4, 8001bac <USB_OTG_WritePacket+0x48>
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
 8001b6a:	eb00 0082 	add.w	r0, r0, r2, lsl #2
  if (pdev->cfg.dma_enable == 0)
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
 8001b6e:	3303      	adds	r3, #3
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001b70:	109b      	asrs	r3, r3, #2
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
 8001b72:	f8d0 40d0 	ldr.w	r4, [r0, #208]	; 0xd0
    for (i = 0; i < count32b; i++, src+=4)
 8001b76:	d019      	beq.n	8001bac <USB_OTG_WritePacket+0x48>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001b78:	f851 2b04 	ldr.w	r2, [r1], #4
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001b7c:	2001      	movs	r0, #1
 8001b7e:	1e5d      	subs	r5, r3, #1
 8001b80:	4283      	cmp	r3, r0
 8001b82:	f005 0501 	and.w	r5, r5, #1
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001b86:	6022      	str	r2, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001b88:	d010      	beq.n	8001bac <USB_OTG_WritePacket+0x48>
 8001b8a:	b12d      	cbz	r5, 8001b98 <USB_OTG_WritePacket+0x34>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001b8c:	f851 2b04 	ldr.w	r2, [r1], #4
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001b90:	2002      	movs	r0, #2
 8001b92:	4283      	cmp	r3, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001b94:	6022      	str	r2, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001b96:	d009      	beq.n	8001bac <USB_OTG_WritePacket+0x48>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001b98:	460a      	mov	r2, r1
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001b9a:	3002      	adds	r0, #2
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001b9c:	f852 5b04 	ldr.w	r5, [r2], #4
 8001ba0:	6025      	str	r5, [r4, #0]
 8001ba2:	684d      	ldr	r5, [r1, #4]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001ba4:	1d11      	adds	r1, r2, #4
 8001ba6:	4283      	cmp	r3, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8001ba8:	6025      	str	r5, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8001baa:	d1f5      	bne.n	8001b98 <USB_OTG_WritePacket+0x34>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
    }
  }
  return status;
}
 8001bac:	2000      	movs	r0, #0
 8001bae:	bc30      	pop	{r4, r5}
 8001bb0:	4770      	bx	lr
 8001bb2:	bf00      	nop

08001bb4 <USB_OTG_ReadPacket>:
void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
                         uint8_t *dest, 
                         uint16_t len)
{
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
 8001bb4:	3203      	adds	r2, #3
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001bb6:	1092      	asrs	r2, r2, #2
* @retval None
*/
void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
                         uint8_t *dest, 
                         uint16_t len)
{
 8001bb8:	b470      	push	{r4, r5, r6}
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
 8001bba:	f8d0 50d0 	ldr.w	r5, [r0, #208]	; 0xd0
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001bbe:	d01c      	beq.n	8001bfa <USB_OTG_ReadPacket+0x46>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001bc0:	682c      	ldr	r4, [r5, #0]
 8001bc2:	460b      	mov	r3, r1
 8001bc4:	1e50      	subs	r0, r2, #1
 8001bc6:	f843 4b04 	str.w	r4, [r3], #4
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001bca:	2401      	movs	r4, #1
 8001bcc:	42a2      	cmp	r2, r4
 8001bce:	f000 0001 	and.w	r0, r0, #1
 8001bd2:	d010      	beq.n	8001bf6 <USB_OTG_ReadPacket+0x42>
 8001bd4:	b128      	cbz	r0, 8001be2 <USB_OTG_ReadPacket+0x2e>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001bd6:	6828      	ldr	r0, [r5, #0]
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001bd8:	2402      	movs	r4, #2
 8001bda:	42a2      	cmp	r2, r4
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001bdc:	f843 0b04 	str.w	r0, [r3], #4
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001be0:	d009      	beq.n	8001bf6 <USB_OTG_ReadPacket+0x42>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001be2:	682e      	ldr	r6, [r5, #0]
 8001be4:	4618      	mov	r0, r3
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001be6:	3402      	adds	r4, #2
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8001be8:	f840 6b04 	str.w	r6, [r0], #4
 8001bec:	682e      	ldr	r6, [r5, #0]
 8001bee:	605e      	str	r6, [r3, #4]
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8001bf0:	1d03      	adds	r3, r0, #4
 8001bf2:	42a2      	cmp	r2, r4
 8001bf4:	d1f5      	bne.n	8001be2 <USB_OTG_ReadPacket+0x2e>
 8001bf6:	eb01 0182 	add.w	r1, r1, r2, lsl #2
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
    
  }
  return ((void *)dest);
}
 8001bfa:	4608      	mov	r0, r1
 8001bfc:	bc70      	pop	{r4, r5, r6}
 8001bfe:	4770      	bx	lr

08001c00 <USB_OTG_SelectCore>:
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
                               USB_OTG_CORE_ID_TypeDef coreID)
{
 8001c00:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  uint32_t i , baseAddress = 0;
  USB_OTG_STS status = USB_OTG_OK;
  
  pdev->cfg.dma_enable       = 0;
 8001c04:	2300      	movs	r3, #0
  
  /* at startup the core is in FS mode */
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8001c06:	2701      	movs	r7, #1
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
 8001c08:	2240      	movs	r2, #64	; 0x40
    
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
 8001c0a:	2901      	cmp	r1, #1
                               USB_OTG_CORE_ID_TypeDef coreID)
{
  uint32_t i , baseAddress = 0;
  USB_OTG_STS status = USB_OTG_OK;
  
  pdev->cfg.dma_enable       = 0;
 8001c0c:	70c3      	strb	r3, [r0, #3]
  
  /* at startup the core is in FS mode */
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8001c0e:	7087      	strb	r7, [r0, #2]
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
 8001c10:	8082      	strh	r2, [r0, #4]
    
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
 8001c12:	f000 80a6 	beq.w	8001d62 <USB_OTG_SelectCore+0x162>
    
#ifdef USB_OTG_FS_LOW_PWR_MGMT_SUPPORT    
    pdev->cfg.low_power        = 1;    
#endif     
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
 8001c16:	2900      	cmp	r1, #0
 8001c18:	f000 808c 	beq.w	8001d34 <USB_OTG_SelectCore+0x134>
 8001c1c:	7847      	ldrb	r7, [r0, #1]
 8001c1e:	f890 8000 	ldrb.w	r8, [r0]
    pdev->cfg.low_power        = 1;    
#endif 
    
  }
  
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
 8001c22:	60c3      	str	r3, [r0, #12]
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
 8001c24:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8001c28:	6102      	str	r2, [r0, #16]
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c2a:	2f00      	cmp	r7, #0
 8001c2c:	f000 80b0 	beq.w	8001d90 <USB_OTG_SelectCore+0x190>
 8001c30:	f44f 6a60 	mov.w	sl, #3584	; 0xe00
 8001c34:	f44f 6988 	mov.w	r9, #1088	; 0x440
 8001c38:	f44f 6b80 	mov.w	fp, #1024	; 0x400
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
                               USB_OTG_CORE_ID_TypeDef coreID)
{
  uint32_t i , baseAddress = 0;
 8001c3c:	469c      	mov	ip, r3
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001c3e:	4602      	mov	r2, r0
 8001c40:	f50c 6410 	add.w	r4, ip, #2304	; 0x900
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8001c44:	f842 4f18 	str.w	r4, [r2, #24]!
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c48:	2401      	movs	r4, #1
 8001c4a:	1e7b      	subs	r3, r7, #1
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001c4c:	f50c 6130 	add.w	r1, ip, #2816	; 0xb00
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c50:	42bc      	cmp	r4, r7
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8001c52:	63d1      	str	r1, [r2, #60]	; 0x3c
 8001c54:	ea03 0104 	and.w	r1, r3, r4
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c58:	f50c 6312 	add.w	r3, ip, #2336	; 0x920
 8001c5c:	d21c      	bcs.n	8001c98 <USB_OTG_SelectCore+0x98>
 8001c5e:	b151      	cbz	r1, 8001c76 <USB_OTG_SelectCore+0x76>
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001c60:	4602      	mov	r2, r0
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c62:	2402      	movs	r4, #2
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8001c64:	f842 3f1c 	str.w	r3, [r2, #28]!
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001c68:	f50c 6132 	add.w	r1, ip, #2848	; 0xb20
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c6c:	42bc      	cmp	r4, r7
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8001c6e:	63d1      	str	r1, [r2, #60]	; 0x3c
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c70:	f50c 6314 	add.w	r3, ip, #2368	; 0x940
 8001c74:	d210      	bcs.n	8001c98 <USB_OTG_SelectCore+0x98>
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001c76:	1d11      	adds	r1, r2, #4
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8001c78:	6053      	str	r3, [r2, #4]
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c7a:	3402      	adds	r4, #2
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001c7c:	3208      	adds	r2, #8
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c7e:	f103 0520 	add.w	r5, r3, #32
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001c82:	f503 7600 	add.w	r6, r3, #512	; 0x200
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c86:	42bc      	cmp	r4, r7
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001c88:	f503 7308 	add.w	r3, r3, #544	; 0x220
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8001c8c:	63ce      	str	r6, [r1, #60]	; 0x3c
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8001c8e:	604d      	str	r5, [r1, #4]
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8001c90:	63d3      	str	r3, [r2, #60]	; 0x3c
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001c92:	f105 0320 	add.w	r3, r5, #32
 8001c96:	d3ee      	bcc.n	8001c76 <USB_OTG_SelectCore+0x76>
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
 8001c98:	f8c0 b014 	str.w	fp, [r0, #20]
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
 8001c9c:	f8c0 90cc 	str.w	r9, [r0, #204]	; 0xcc
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001ca0:	f1b8 0f00 	cmp.w	r8, #0
 8001ca4:	d040      	beq.n	8001d28 <USB_OTG_SelectCore+0x128>
 8001ca6:	f50c 61a0 	add.w	r1, ip, #1280	; 0x500
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001caa:	ea4f 1548 	mov.w	r5, r8, lsl #5
 8001cae:	f1a5 0420 	sub.w	r4, r5, #32
 8001cb2:	4602      	mov	r2, r0
 8001cb4:	186d      	adds	r5, r5, r1
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8001cb6:	f50c 63a4 	add.w	r3, ip, #1312	; 0x520
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001cba:	42ab      	cmp	r3, r5
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8001cbc:	f842 1f90 	str.w	r1, [r2, #144]!
 8001cc0:	f3c4 1440 	ubfx	r4, r4, #5, #1
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001cc4:	d00f      	beq.n	8001ce6 <USB_OTG_SelectCore+0xe6>
 8001cc6:	b134      	cbz	r4, 8001cd6 <USB_OTG_SelectCore+0xd6>
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001cc8:	4602      	mov	r2, r0
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8001cca:	f842 3f94 	str.w	r3, [r2, #148]!
 8001cce:	f50c 63a8 	add.w	r3, ip, #1344	; 0x540
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001cd2:	42ab      	cmp	r3, r5
 8001cd4:	d007      	beq.n	8001ce6 <USB_OTG_SelectCore+0xe6>
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8001cd6:	f103 0420 	add.w	r4, r3, #32
 8001cda:	6053      	str	r3, [r2, #4]
 8001cdc:	3340      	adds	r3, #64	; 0x40
 8001cde:	6094      	str	r4, [r2, #8]
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001ce0:	3208      	adds	r2, #8
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001ce2:	42ab      	cmp	r3, r5
 8001ce4:	d1f7      	bne.n	8001cd6 <USB_OTG_SelectCore+0xd6>
 8001ce6:	f50c 5180 	add.w	r1, ip, #4096	; 0x1000
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001cea:	ea4f 3808 	mov.w	r8, r8, lsl #12
 8001cee:	f5a8 5480 	sub.w	r4, r8, #4096	; 0x1000
 8001cf2:	4602      	mov	r2, r0
 8001cf4:	4488      	add	r8, r1
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8001cf6:	f50c 5300 	add.w	r3, ip, #8192	; 0x2000
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001cfa:	4543      	cmp	r3, r8
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8001cfc:	f842 1fd0 	str.w	r1, [r2, #208]!
 8001d00:	f3c4 3400 	ubfx	r4, r4, #12, #1
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001d04:	d010      	beq.n	8001d28 <USB_OTG_SelectCore+0x128>
 8001d06:	b134      	cbz	r4, 8001d16 <USB_OTG_SelectCore+0x116>
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001d08:	4602      	mov	r2, r0
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8001d0a:	f842 3fd4 	str.w	r3, [r2, #212]!
 8001d0e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001d12:	4543      	cmp	r3, r8
 8001d14:	d008      	beq.n	8001d28 <USB_OTG_SelectCore+0x128>
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8001d16:	f503 5480 	add.w	r4, r3, #4096	; 0x1000
 8001d1a:	6053      	str	r3, [r2, #4]
 8001d1c:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8001d20:	6094      	str	r4, [r2, #8]
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8001d22:	3208      	adds	r2, #8
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8001d24:	4543      	cmp	r3, r8
 8001d26:	d1f6      	bne.n	8001d16 <USB_OTG_SelectCore+0x116>
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
      (i * USB_OTG_DATA_FIFO_SIZE));
  }
  pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
 8001d28:	f8c0 a10c 	str.w	sl, [r0, #268]	; 0x10c
  
  return status;
}
 8001d2c:	2000      	movs	r0, #0
 8001d2e:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001d32:	4770      	bx	lr
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001d34:	f44f 69a0 	mov.w	r9, #1280	; 0x500
 8001d38:	4b19      	ldr	r3, [pc, #100]	; (8001da0 <USB_OTG_SelectCore+0x1a0>)
 8001d3a:	f8a0 9006 	strh.w	r9, [r0, #6]
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
 8001d3e:	f04f 080c 	mov.w	r8, #12
    pdev->cfg.dev_endpoints    = 6 ;
 8001d42:	2706      	movs	r7, #6
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8001d44:	f8df a064 	ldr.w	sl, [pc, #100]	; 8001dac <USB_OTG_SelectCore+0x1ac>
 8001d48:	f8df 9064 	ldr.w	r9, [pc, #100]	; 8001db0 <USB_OTG_SelectCore+0x1b0>
 8001d4c:	f8df b064 	ldr.w	fp, [pc, #100]	; 8001db4 <USB_OTG_SelectCore+0x1b4>
 8001d50:	4a14      	ldr	r2, [pc, #80]	; (8001da4 <USB_OTG_SelectCore+0x1a4>)
#endif     
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
 8001d52:	72c1      	strb	r1, [r0, #11]
    pdev->cfg.host_channels    = 12 ;
 8001d54:	f880 8000 	strb.w	r8, [r0]
    pdev->cfg.dev_endpoints    = 6 ;
 8001d58:	7047      	strb	r7, [r0, #1]
    pdev->cfg.low_power        = 1;    
#endif     
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
 8001d5a:	469c      	mov	ip, r3
    pdev->cfg.low_power        = 1;    
#endif 
    
  }
  
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
 8001d5c:	60c3      	str	r3, [r0, #12]
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
 8001d5e:	6102      	str	r2, [r0, #16]
 8001d60:	e76d      	b.n	8001c3e <USB_OTG_SelectCore+0x3e>
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
    pdev->cfg.host_channels    = 8 ;
 8001d62:	f04f 0808 	mov.w	r8, #8
    pdev->cfg.dev_endpoints    = 4 ;
 8001d66:	2704      	movs	r7, #4
    pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
 8001d68:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
 8001d6c:	72c1      	strb	r1, [r0, #11]
    pdev->cfg.host_channels    = 8 ;
    pdev->cfg.dev_endpoints    = 4 ;
    pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
 8001d6e:	f44f 74a0 	mov.w	r4, #320	; 0x140
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
 8001d72:	2102      	movs	r1, #2
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
    pdev->cfg.host_channels    = 8 ;
 8001d74:	f880 8000 	strb.w	r8, [r0]
    pdev->cfg.dev_endpoints    = 4 ;
 8001d78:	7047      	strb	r7, [r0, #1]
    pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
 8001d7a:	80c4      	strh	r4, [r0, #6]
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
 8001d7c:	7201      	strb	r1, [r0, #8]
 8001d7e:	f8df a038 	ldr.w	sl, [pc, #56]	; 8001db8 <USB_OTG_SelectCore+0x1b8>
 8001d82:	f8df 9038 	ldr.w	r9, [pc, #56]	; 8001dbc <USB_OTG_SelectCore+0x1bc>
 8001d86:	f8df b038 	ldr.w	fp, [pc, #56]	; 8001dc0 <USB_OTG_SelectCore+0x1c0>
 8001d8a:	4a07      	ldr	r2, [pc, #28]	; (8001da8 <USB_OTG_SelectCore+0x1a8>)
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
    
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
 8001d8c:	469c      	mov	ip, r3
 8001d8e:	e7e5      	b.n	8001d5c <USB_OTG_SelectCore+0x15c>
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8001d90:	f44f 6a60 	mov.w	sl, #3584	; 0xe00
 8001d94:	f44f 6988 	mov.w	r9, #1088	; 0x440
 8001d98:	f44f 6b80 	mov.w	fp, #1024	; 0x400
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
                               USB_OTG_CORE_ID_TypeDef coreID)
{
  uint32_t i , baseAddress = 0;
 8001d9c:	46bc      	mov	ip, r7
 8001d9e:	e77b      	b.n	8001c98 <USB_OTG_SelectCore+0x98>
 8001da0:	40040000 	.word	0x40040000
 8001da4:	40040800 	.word	0x40040800
 8001da8:	50000800 	.word	0x50000800
 8001dac:	40040e00 	.word	0x40040e00
 8001db0:	40040440 	.word	0x40040440
 8001db4:	40040400 	.word	0x40040400
 8001db8:	50000e00 	.word	0x50000e00
 8001dbc:	50000440 	.word	0x50000440
 8001dc0:	50000400 	.word	0x50000400

08001dc4 <USB_OTG_CoreInit>:
*         device mode or host mode operation.
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
{
 8001dc4:	b538      	push	{r3, r4, r5, lr}
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8001dc6:	7a03      	ldrb	r3, [r0, #8]
  USB_OTG_GI2CCTL_TypeDef  i2cctl;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  
  usbcfg.d32 = 0;
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
 8001dc8:	2500      	movs	r5, #0
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8001dca:	2b01      	cmp	r3, #1
*         device mode or host mode operation.
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
{
 8001dcc:	4604      	mov	r4, r0
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8001dce:	d037      	beq.n	8001e40 <USB_OTG_CoreInit+0x7c>
    }    
  }
  else /* FS interface (embedded Phy or I2C Phy) */
  {
    
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
 8001dd0:	f850 3f0c 	ldr.w	r3, [r0, #12]!
 8001dd4:	68d9      	ldr	r1, [r3, #12]
    usbcfg.b.physel  = 1; /* FS Interface */
 8001dd6:	f041 0240 	orr.w	r2, r1, #64	; 0x40
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8001dda:	60da      	str	r2, [r3, #12]
    /* Reset after a PHY select and set Host mode */
    USB_OTG_CoreReset(pdev);
 8001ddc:	f7ff fe80 	bl	8001ae0 <USB_OTG_CoreReset.clone.1>
    /* Enable the I2C interface and deactivate the power down*/
    gccfg.d32 = 0;
    gccfg.b.pwdn = 1;
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 8001de0:	f894 c008 	ldrb.w	ip, [r4, #8]
    gccfg.b.vbussensingB = 1 ;     
#ifndef VBUS_SENSING_ENABLED
    gccfg.b.disablevbussensing = 1; 
#endif    
    
    if(pdev->cfg.Sof_output)
 8001de4:	7a61      	ldrb	r1, [r4, #9]
    gccfg.d32 = 0;
    gccfg.b.pwdn = 1;
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
    {
      gccfg.b.i2cifen = 1;
 8001de6:	f1bc 0f03 	cmp.w	ip, #3
 8001dea:	bf14      	ite	ne
 8001dec:	f44f 3280 	movne.w	r2, #65536	; 0x10000
 8001df0:	f44f 3240 	moveq.w	r2, #196608	; 0x30000
    }   
    gccfg.b.vbussensingA = 1 ;
    gccfg.b.vbussensingB = 1 ;     
#ifndef VBUS_SENSING_ENABLED
    gccfg.b.disablevbussensing = 1; 
 8001df4:	f442 1330 	orr.w	r3, r2, #2883584	; 0x2c0000
#endif    
    
    if(pdev->cfg.Sof_output)
 8001df8:	b109      	cbz	r1, 8001dfe <USB_OTG_CoreInit+0x3a>
    {
      gccfg.b.sofouten = 1;  
 8001dfa:	f442 1370 	orr.w	r3, r2, #3932160	; 0x3c0000
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 8001dfe:	68e1      	ldr	r1, [r4, #12]
    USB_OTG_BSP_mDelay(20);
 8001e00:	2014      	movs	r0, #20
    if(pdev->cfg.Sof_output)
    {
      gccfg.b.sofouten = 1;  
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 8001e02:	638b      	str	r3, [r1, #56]	; 0x38
    USB_OTG_BSP_mDelay(20);
 8001e04:	f001 fd9f 	bl	8003946 <USB_OTG_BSP_mDelay>
    /* Program GUSBCFG.OtgUtmifsSel to I2C*/
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8001e08:	68e3      	ldr	r3, [r4, #12]
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 8001e0a:	f894 c008 	ldrb.w	ip, [r4, #8]
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
    USB_OTG_BSP_mDelay(20);
    /* Program GUSBCFG.OtgUtmifsSel to I2C*/
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8001e0e:	68da      	ldr	r2, [r3, #12]
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 8001e10:	f1bc 0f03 	cmp.w	ip, #3
    {
      usbcfg.b.otgutmifssel = 1;
 8001e14:	bf08      	it	eq
 8001e16:	f442 3280 	orreq.w	r2, r2, #65536	; 0x10000
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8001e1a:	60da      	str	r2, [r3, #12]
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 8001e1c:	7a20      	ldrb	r0, [r4, #8]
 8001e1e:	2803      	cmp	r0, #3
 8001e20:	d03b      	beq.n	8001e9a <USB_OTG_CoreInit+0xd6>
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
      USB_OTG_BSP_mDelay(200);
    }
  }
  /* case the HS core is working in FS mode */
  if(pdev->cfg.dma_enable == 1)
 8001e22:	f894 e003 	ldrb.w	lr, [r4, #3]
 8001e26:	f1be 0f01 	cmp.w	lr, #1
 8001e2a:	d107      	bne.n	8001e3c <USB_OTG_CoreInit+0x78>
  {
    
    ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
 8001e2c:	68e3      	ldr	r3, [r4, #12]
 8001e2e:	689a      	ldr	r2, [r3, #8]
    ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 8001e30:	2105      	movs	r1, #5
 8001e32:	f361 0244 	bfi	r2, r1, #1, #4
    ahbcfg.b.dmaenable = 1;
 8001e36:	f042 0020 	orr.w	r0, r2, #32
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8001e3a:	6098      	str	r0, [r3, #8]
  usbcfg.b.srpcap = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
  USB_OTG_EnableCommonInt(pdev);
#endif
  return status;
}
 8001e3c:	2000      	movs	r0, #0
 8001e3e:	bd38      	pop	{r3, r4, r5, pc}
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
 8001e40:	68c2      	ldr	r2, [r0, #12]
    gccfg.b.pwdn = 0;
    
    if (pdev->cfg.Sof_output)
 8001e42:	7a41      	ldrb	r1, [r0, #9]
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
 8001e44:	6b93      	ldr	r3, [r2, #56]	; 0x38
    gccfg.b.pwdn = 0;
 8001e46:	f365 4310 	bfi	r3, r5, #16, #1
    
    if (pdev->cfg.Sof_output)
 8001e4a:	b109      	cbz	r1, 8001e50 <USB_OTG_CoreInit+0x8c>
    {
      gccfg.b.sofouten = 1;   
 8001e4c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    }
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 8001e50:	6393      	str	r3, [r2, #56]	; 0x38
    
    /* Init The ULPI Interface */
    usbcfg.d32 = 0;
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8001e52:	68d1      	ldr	r1, [r2, #12]
    
    usbcfg.b.physel            = 0; /* HS Interface */
 8001e54:	f36f 1186 	bfc	r1, #6, #1
#else
 #ifdef USB_OTG_EXTERNAL_VBUS_ENABLED    
    usbcfg.b.ulpi_ext_vbus_drv = 1; /* Use external VBUS */
 #endif
#endif 
    usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
 8001e58:	f36f 5196 	bfc	r1, #22, #1
    usbcfg.b.ulpi_utmi_sel     = 1; /* ULPI seleInterfacect */
 8001e5c:	f041 0310 	orr.w	r3, r1, #16
    
    usbcfg.b.phyif             = 0; /* 8 bits */
 8001e60:	f36f 03c3 	bfc	r3, #3, #1
    usbcfg.b.ddrsel            = 0; /* single data rate */
 8001e64:	f36f 13c7 	bfc	r3, #7, #1
    
    usbcfg.b.ulpi_fsls = 0;
 8001e68:	f36f 4351 	bfc	r3, #17, #1
    usbcfg.b.ulpi_clk_sus_m = 0;
 8001e6c:	f36f 43d3 	bfc	r3, #19, #1
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8001e70:	60d3      	str	r3, [r2, #12]
    
    /* Reset after a PHY select  */
    USB_OTG_CoreReset(pdev);
 8001e72:	f104 000c 	add.w	r0, r4, #12
 8001e76:	f7ff fe33 	bl	8001ae0 <USB_OTG_CoreReset.clone.1>
    
    if(pdev->cfg.dma_enable == 1)
 8001e7a:	78e0      	ldrb	r0, [r4, #3]
 8001e7c:	2801      	cmp	r0, #1
 8001e7e:	d1dd      	bne.n	8001e3c <USB_OTG_CoreInit+0x78>
    {
      
      ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 8001e80:	2005      	movs	r0, #5
 8001e82:	f360 0544 	bfi	r5, r0, #1, #4
      ahbcfg.b.dmaenable = 1;
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8001e86:	68e2      	ldr	r2, [r4, #12]
    
    if(pdev->cfg.dma_enable == 1)
    {
      
      ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
      ahbcfg.b.dmaenable = 1;
 8001e88:	f045 0520 	orr.w	r5, r5, #32
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8001e8c:	6095      	str	r5, [r2, #8]
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
      USB_OTG_BSP_mDelay(200);
    }
  }
  /* case the HS core is working in FS mode */
  if(pdev->cfg.dma_enable == 1)
 8001e8e:	f894 e003 	ldrb.w	lr, [r4, #3]
 8001e92:	f1be 0f01 	cmp.w	lr, #1
 8001e96:	d0c9      	beq.n	8001e2c <USB_OTG_CoreInit+0x68>
 8001e98:	e7d0      	b.n	8001e3c <USB_OTG_CoreInit+0x78>
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
    {
      /*Program GI2CCTL.I2CEn*/
      i2cctl.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GI2CCTL);
 8001e9a:	6b19      	ldr	r1, [r3, #48]	; 0x30
      i2cctl.b.i2cdevaddr = 1;
 8001e9c:	2201      	movs	r2, #1
 8001e9e:	f362 619b 	bfi	r1, r2, #26, #2
      i2cctl.b.i2cen = 0;
 8001ea2:	f36f 51d7 	bfc	r1, #23, #1
      i2cctl.b.dat_se0 = 1;
 8001ea6:	f041 5580 	orr.w	r5, r1, #268435456	; 0x10000000
      i2cctl.b.addr = 0x2D;
 8001eaa:	202d      	movs	r0, #45	; 0x2d
 8001eac:	f360 4516 	bfi	r5, r0, #16, #7
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
 8001eb0:	631d      	str	r5, [r3, #48]	; 0x30
      
      USB_OTG_BSP_mDelay(200);
 8001eb2:	20c8      	movs	r0, #200	; 0xc8
 8001eb4:	f001 fd47 	bl	8003946 <USB_OTG_BSP_mDelay>
      
      i2cctl.b.i2cen = 1;
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
 8001eb8:	68e3      	ldr	r3, [r4, #12]
      i2cctl.b.addr = 0x2D;
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
      
      USB_OTG_BSP_mDelay(200);
      
      i2cctl.b.i2cen = 1;
 8001eba:	f445 0500 	orr.w	r5, r5, #8388608	; 0x800000
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
 8001ebe:	631d      	str	r5, [r3, #48]	; 0x30
      USB_OTG_BSP_mDelay(200);
 8001ec0:	20c8      	movs	r0, #200	; 0xc8
 8001ec2:	f001 fd40 	bl	8003946 <USB_OTG_BSP_mDelay>
 8001ec6:	e7ac      	b.n	8001e22 <USB_OTG_CoreInit+0x5e>

08001ec8 <USB_OTG_EnableGlobalInt>:
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  
  ahbcfg.d32 = 0;
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
 8001ec8:	68c3      	ldr	r3, [r0, #12]
 8001eca:	6898      	ldr	r0, [r3, #8]
 8001ecc:	f040 0201 	orr.w	r2, r0, #1
 8001ed0:	609a      	str	r2, [r3, #8]
  return status;
}
 8001ed2:	2000      	movs	r0, #0
 8001ed4:	4770      	bx	lr
 8001ed6:	bf00      	nop

08001ed8 <USB_OTG_DisableGlobalInt>:
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  ahbcfg.d32 = 0;
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
 8001ed8:	68c3      	ldr	r3, [r0, #12]
 8001eda:	6898      	ldr	r0, [r3, #8]
 8001edc:	f020 0201 	bic.w	r2, r0, #1
 8001ee0:	609a      	str	r2, [r3, #8]
  return status;
}
 8001ee2:	2000      	movs	r0, #0
 8001ee4:	4770      	bx	lr
 8001ee6:	bf00      	nop

08001ee8 <USB_OTG_FlushTxFifo>:
* @param  pdev : Selected device
* @param  num : FO num
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
{
 8001ee8:	b500      	push	{lr}
 8001eea:	b083      	sub	sp, #12
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  
  uint32_t count = 0;
  greset.d32 = 0;
 8001eec:	2300      	movs	r3, #0
 8001eee:	9301      	str	r3, [sp, #4]
  greset.b.txfflsh = 1;
 8001ef0:	9a01      	ldr	r2, [sp, #4]
  greset.b.txfnum  = num;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001ef2:	4b11      	ldr	r3, [pc, #68]	; (8001f38 <USB_OTG_FlushTxFifo+0x50>)
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  
  uint32_t count = 0;
  greset.d32 = 0;
  greset.b.txfflsh = 1;
 8001ef4:	f042 0220 	orr.w	r2, r2, #32
 8001ef8:	9201      	str	r2, [sp, #4]
  greset.b.txfnum  = num;
 8001efa:	9a01      	ldr	r2, [sp, #4]
 8001efc:	f361 128a 	bfi	r2, r1, #6, #5
 8001f00:	9201      	str	r2, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8001f02:	9a01      	ldr	r2, [sp, #4]
 8001f04:	68c1      	ldr	r1, [r0, #12]
 8001f06:	610a      	str	r2, [r1, #16]
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001f08:	690a      	ldr	r2, [r1, #16]
 8001f0a:	9201      	str	r2, [sp, #4]
 8001f0c:	e00a      	b.n	8001f24 <USB_OTG_FlushTxFifo+0x3c>
 8001f0e:	690a      	ldr	r2, [r1, #16]
 8001f10:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.txfflsh == 1);
 8001f12:	9801      	ldr	r0, [sp, #4]
  greset.b.txfflsh = 1;
  greset.b.txfnum  = num;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001f14:	3b01      	subs	r3, #1
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.txfflsh == 1);
 8001f16:	f010 0f20 	tst.w	r0, #32
 8001f1a:	d007      	beq.n	8001f2c <USB_OTG_FlushTxFifo+0x44>
  greset.b.txfflsh = 1;
  greset.b.txfnum  = num;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001f1c:	690a      	ldr	r2, [r1, #16]
    if (++count > 200000)
 8001f1e:	3b01      	subs	r3, #1
  greset.b.txfflsh = 1;
  greset.b.txfnum  = num;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001f20:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 8001f22:	d003      	beq.n	8001f2c <USB_OTG_FlushTxFifo+0x44>
    {
      break;
    }
  }
  while (greset.b.txfflsh == 1);
 8001f24:	9801      	ldr	r0, [sp, #4]
 8001f26:	f010 0f20 	tst.w	r0, #32
 8001f2a:	d1f0      	bne.n	8001f0e <USB_OTG_FlushTxFifo+0x26>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 8001f2c:	2003      	movs	r0, #3
 8001f2e:	f001 fd00 	bl	8003932 <USB_OTG_BSP_uDelay>
  return status;
}
 8001f32:	2000      	movs	r0, #0
 8001f34:	b003      	add	sp, #12
 8001f36:	bd00      	pop	{pc}
 8001f38:	00030d40 	.word	0x00030d40

08001f3c <USB_OTG_FlushRxFifo>:
* @brief  USB_OTG_FlushRxFifo : Flush a Rx FIFO
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
{
 8001f3c:	b500      	push	{lr}
 8001f3e:	b083      	sub	sp, #12
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 8001f40:	2300      	movs	r3, #0
 8001f42:	9301      	str	r3, [sp, #4]
  greset.b.rxfflsh = 1;
 8001f44:	9a01      	ldr	r2, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001f46:	4b0f      	ldr	r3, [pc, #60]	; (8001f84 <USB_OTG_FlushRxFifo+0x48>)
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
  greset.b.rxfflsh = 1;
 8001f48:	f042 0110 	orr.w	r1, r2, #16
 8001f4c:	9101      	str	r1, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8001f4e:	9a01      	ldr	r2, [sp, #4]
 8001f50:	68c1      	ldr	r1, [r0, #12]
 8001f52:	610a      	str	r2, [r1, #16]
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001f54:	690a      	ldr	r2, [r1, #16]
 8001f56:	9201      	str	r2, [sp, #4]
 8001f58:	e00a      	b.n	8001f70 <USB_OTG_FlushRxFifo+0x34>
 8001f5a:	690a      	ldr	r2, [r1, #16]
 8001f5c:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.rxfflsh == 1);
 8001f5e:	9801      	ldr	r0, [sp, #4]
  greset.d32 = 0;
  greset.b.rxfflsh = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001f60:	3b01      	subs	r3, #1
    if (++count > 200000)
    {
      break;
    }
  }
  while (greset.b.rxfflsh == 1);
 8001f62:	f010 0f10 	tst.w	r0, #16
 8001f66:	d007      	beq.n	8001f78 <USB_OTG_FlushRxFifo+0x3c>
  greset.d32 = 0;
  greset.b.rxfflsh = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001f68:	690a      	ldr	r2, [r1, #16]
    if (++count > 200000)
 8001f6a:	3b01      	subs	r3, #1
  greset.d32 = 0;
  greset.b.rxfflsh = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8001f6c:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 8001f6e:	d003      	beq.n	8001f78 <USB_OTG_FlushRxFifo+0x3c>
    {
      break;
    }
  }
  while (greset.b.rxfflsh == 1);
 8001f70:	9801      	ldr	r0, [sp, #4]
 8001f72:	f010 0f10 	tst.w	r0, #16
 8001f76:	d1f0      	bne.n	8001f5a <USB_OTG_FlushRxFifo+0x1e>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 8001f78:	2003      	movs	r0, #3
 8001f7a:	f001 fcda 	bl	8003932 <USB_OTG_BSP_uDelay>
  return status;
}
 8001f7e:	2000      	movs	r0, #0
 8001f80:	b003      	add	sp, #12
 8001f82:	bd00      	pop	{pc}
 8001f84:	00030d40 	.word	0x00030d40

08001f88 <USB_OTG_SetCurrentMode>:
USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8001f88:	68c2      	ldr	r2, [r0, #12]
* @param  pdev : Selected device
* @param  mode :  (Host/device)
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
{
 8001f8a:	b508      	push	{r3, lr}
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8001f8c:	68d3      	ldr	r3, [r2, #12]
  
  usbcfg.b.force_host = 0;
  usbcfg.b.force_dev = 0;
  
  if ( mode == HOST_MODE)
 8001f8e:	2901      	cmp	r1, #1
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
  
  usbcfg.b.force_host = 0;
 8001f90:	f36f 735d 	bfc	r3, #29, #1
  usbcfg.b.force_dev = 0;
 8001f94:	f36f 739e 	bfc	r3, #30, #1
  
  if ( mode == HOST_MODE)
 8001f98:	d008      	beq.n	8001fac <USB_OTG_SetCurrentMode+0x24>
  {
    usbcfg.b.force_host = 1;
  }
  else if ( mode == DEVICE_MODE)
 8001f9a:	b909      	cbnz	r1, 8001fa0 <USB_OTG_SetCurrentMode+0x18>
  {
    usbcfg.b.force_dev = 1;
 8001f9c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
  USB_OTG_BSP_mDelay(50);
 8001fa0:	2032      	movs	r0, #50	; 0x32
  else if ( mode == DEVICE_MODE)
  {
    usbcfg.b.force_dev = 1;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8001fa2:	60d3      	str	r3, [r2, #12]
  USB_OTG_BSP_mDelay(50);
 8001fa4:	f001 fccf 	bl	8003946 <USB_OTG_BSP_mDelay>
  return status;
}
 8001fa8:	2000      	movs	r0, #0
 8001faa:	bd08      	pop	{r3, pc}
  usbcfg.b.force_host = 0;
  usbcfg.b.force_dev = 0;
  
  if ( mode == HOST_MODE)
  {
    usbcfg.b.force_host = 1;
 8001fac:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  {
    usbcfg.b.force_dev = 1;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
  USB_OTG_BSP_mDelay(50);
 8001fb0:	2032      	movs	r0, #50	; 0x32
  else if ( mode == DEVICE_MODE)
  {
    usbcfg.b.force_dev = 1;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8001fb2:	60d3      	str	r3, [r2, #12]
  USB_OTG_BSP_mDelay(50);
 8001fb4:	f001 fcc7 	bl	8003946 <USB_OTG_BSP_mDelay>
  return status;
}
 8001fb8:	2000      	movs	r0, #0
 8001fba:	bd08      	pop	{r3, pc}

08001fbc <USB_OTG_GetMode>:
* @param  pdev : Selected device
* @retval current mode
*/
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 8001fbc:	68c3      	ldr	r3, [r0, #12]
 8001fbe:	6958      	ldr	r0, [r3, #20]
}
 8001fc0:	f000 0001 	and.w	r0, r0, #1
 8001fc4:	4770      	bx	lr
 8001fc6:	bf00      	nop

08001fc8 <USB_OTG_IsDeviceMode>:
* @param  pdev : Selected device
* @retval current mode
*/
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 8001fc8:	68c0      	ldr	r0, [r0, #12]
 8001fca:	6943      	ldr	r3, [r0, #20]
* @param  pdev : Selected device
* @retval num_in_ep
*/
uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_GetMode(pdev) != HOST_MODE);
 8001fcc:	f013 0f01 	tst.w	r3, #1
}
 8001fd0:	bf14      	ite	ne
 8001fd2:	2000      	movne	r0, #0
 8001fd4:	2001      	moveq	r0, #1
 8001fd6:	4770      	bx	lr

08001fd8 <USB_OTG_IsHostMode>:
* @param  pdev : Selected device
* @retval current mode
*/
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 8001fd8:	68c3      	ldr	r3, [r0, #12]
 8001fda:	6958      	ldr	r0, [r3, #20]
* @retval num_in_ep
*/
uint8_t USB_OTG_IsHostMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_GetMode(pdev) == HOST_MODE);
}
 8001fdc:	f000 0001 	and.w	r0, r0, #1
 8001fe0:	4770      	bx	lr
 8001fe2:	bf00      	nop

08001fe4 <USB_OTG_ReadCoreItr>:
* @retval Status
*/
uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v = 0;
  v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
 8001fe4:	68c3      	ldr	r3, [r0, #12]
 8001fe6:	695a      	ldr	r2, [r3, #20]
  v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
 8001fe8:	6998      	ldr	r0, [r3, #24]
  return v;
}
 8001fea:	4010      	ands	r0, r2
 8001fec:	4770      	bx	lr
 8001fee:	bf00      	nop

08001ff0 <USB_OTG_ReadOtgItr>:
* @param  pdev : Selected device
* @retval Status
*/
uint32_t USB_OTG_ReadOtgItr (USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32 (&pdev->regs.GREGS->GOTGINT));
 8001ff0:	68c3      	ldr	r3, [r0, #12]
 8001ff2:	6858      	ldr	r0, [r3, #4]
}
 8001ff4:	4770      	bx	lr
 8001ff6:	bf00      	nop

08001ff8 <USB_OTG_InitDevSpeed>:
*/
void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
{
  USB_OTG_DCFG_TypeDef   dcfg;
  
  dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
 8001ff8:	6903      	ldr	r3, [r0, #16]
 8001ffa:	681a      	ldr	r2, [r3, #0]
  dcfg.b.devspd = speed;
 8001ffc:	f361 0201 	bfi	r2, r1, #0, #2
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCFG, dcfg.d32);
 8002000:	601a      	str	r2, [r3, #0]
}
 8002002:	4770      	bx	lr

08002004 <USB_OTG_EnableDevInt>:
  USB_OTG_GINTMSK_TypeDef  intmsk;
  
  intmsk.d32 = 0;
  
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
 8002004:	68c3      	ldr	r3, [r0, #12]
USB_OTG_STS USB_OTG_EnableDevInt(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GINTMSK_TypeDef  intmsk;
  
  intmsk.d32 = 0;
 8002006:	2200      	movs	r2, #0
  
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 8002008:	f04f 31ff 	mov.w	r1, #4294967295
  USB_OTG_GINTMSK_TypeDef  intmsk;
  
  intmsk.d32 = 0;
  
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
 800200c:	619a      	str	r2, [r3, #24]
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 800200e:	6159      	str	r1, [r3, #20]
  USB_OTG_GINTMSK_TypeDef  int_mask;
  
  int_mask.d32 = 0;
  /* Clear any pending USB_OTG Interrupts */
#ifndef USE_OTG_MODE
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GOTGINT, 0xFFFFFFFF);
 8002010:	6059      	str	r1, [r3, #4]
#endif
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 8002012:	6159      	str	r1, [r3, #20]
#ifdef USE_OTG_MODE
  int_mask.b.otgintr = 1;
  int_mask.b.sessreqintr = 1;
  int_mask.b.conidstschng = 1;
#endif
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
 8002014:	490a      	ldr	r1, [pc, #40]	; (8002040 <USB_OTG_EnableDevInt+0x3c>)
 8002016:	6199      	str	r1, [r3, #24]
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
  /* Enable the common interrupts */
  USB_OTG_EnableCommonInt(pdev);
  
  if (pdev->cfg.dma_enable == 0)
 8002018:	f890 c003 	ldrb.w	ip, [r0, #3]
  intmsk.b.incomplisoout    = 1;   
#ifdef VBUS_SENSING_ENABLED
  intmsk.b.sessreqintr    = 1; 
  intmsk.b.otgintr    = 1;    
#endif  
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 800201c:	6998      	ldr	r0, [r3, #24]
  /* Enable the common interrupts */
  USB_OTG_EnableCommonInt(pdev);
  
  if (pdev->cfg.dma_enable == 0)
  {
    intmsk.b.rxstsqlvl = 1;
 800201e:	4594      	cmp	ip, r2
 8002020:	bf14      	ite	ne
 8002022:	4611      	movne	r1, r2
 8002024:	2110      	moveq	r1, #16
  
  /* Enable interrupts matching to the Device mode ONLY */
  intmsk.b.usbsuspend = 1;
  intmsk.b.usbreset   = 1;
  intmsk.b.enumdone   = 1;
  intmsk.b.inepintr   = 1;
 8002026:	f441 2c87 	orr.w	ip, r1, #276480	; 0x43800
  intmsk.b.outepintr  = 1;
  intmsk.b.sofintr    = 1; 
 800202a:	f04c 1108 	orr.w	r1, ip, #524296	; 0x80008

  intmsk.b.incomplisoin    = 1; 
  intmsk.b.incomplisoout    = 1;   
 800202e:	f441 1c40 	orr.w	ip, r1, #3145728	; 0x300000
#ifdef VBUS_SENSING_ENABLED
  intmsk.b.sessreqintr    = 1; 
  intmsk.b.otgintr    = 1;    
#endif  
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 8002032:	ea20 000c 	bic.w	r0, r0, ip
 8002036:	ea40 010c 	orr.w	r1, r0, ip
 800203a:	6199      	str	r1, [r3, #24]
  return status;
}
 800203c:	4610      	mov	r0, r2
 800203e:	4770      	bx	lr
 8002040:	80000800 	.word	0x80000800

08002044 <USB_OTG_CoreInitDev>:
*         for device mode
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
{
 8002044:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  nptxfifosize.d32 = 0;
  txfifosize.d32 = 0;
  msk.d32 = 0;
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
 8002046:	f8d0 510c 	ldr.w	r5, [r0, #268]	; 0x10c
  /* Device configuration register */
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
 800204a:	6902      	ldr	r2, [r0, #16]
  USB_OTG_DIEPMSK_TypeDef msk;
  USB_OTG_DTHRCTL_TypeDef dthrctl;  
  
  depctl.d32 = 0;
  dcfg.d32 = 0;
  nptxfifosize.d32 = 0;
 800204c:	2100      	movs	r1, #0
  txfifosize.d32 = 0;
  msk.d32 = 0;
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
 800204e:	6029      	str	r1, [r5, #0]
*         for device mode
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
{
 8002050:	4604      	mov	r4, r0
  msk.d32 = 0;
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
  /* Device configuration register */
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
 8002052:	6810      	ldr	r0, [r2, #0]
  dcfg.b.perfrint = DCFG_FRAME_INTERVAL_80;
 8002054:	f361 20cc 	bfi	r0, r1, #11, #2
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32 );
 8002058:	6010      	str	r0, [r2, #0]
  USB_OTG_DTHRCTL_TypeDef dthrctl;  
  
  depctl.d32 = 0;
  dcfg.d32 = 0;
  nptxfifosize.d32 = 0;
  txfifosize.d32 = 0;
 800205a:	460b      	mov	r3, r1
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
  dcfg.b.perfrint = DCFG_FRAME_INTERVAL_80;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32 );
  
#ifdef USB_OTG_FS_CORE
  if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID  )
 800205c:	7ae1      	ldrb	r1, [r4, #11]
 800205e:	2901      	cmp	r1, #1
 8002060:	d058      	beq.n	8002114 <USB_OTG_CoreInitDev+0xd0>
    txfifosize.b.depth = TX5_FIFO_HS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[4], txfifosize.d32 );
  }
#endif  
  /* Flush the FIFOs */
  USB_OTG_FlushTxFifo(pdev , 0x10); /* all Tx FIFOs */
 8002062:	2110      	movs	r1, #16
 8002064:	4620      	mov	r0, r4
 8002066:	f7ff ff3f 	bl	8001ee8 <USB_OTG_FlushTxFifo>
  USB_OTG_FlushRxFifo(pdev);
 800206a:	4620      	mov	r0, r4
 800206c:	f7ff ff66 	bl	8001f3c <USB_OTG_FlushRxFifo>
  /* Clear all pending Device Interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 8002070:	6925      	ldr	r5, [r4, #16]
 8002072:	2200      	movs	r2, #0
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8002074:	f04f 30ff 	mov.w	r0, #4294967295
#endif  
  /* Flush the FIFOs */
  USB_OTG_FlushTxFifo(pdev , 0x10); /* all Tx FIFOs */
  USB_OTG_FlushRxFifo(pdev);
  /* Clear all pending Device Interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 8002078:	612a      	str	r2, [r5, #16]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
 800207a:	616a      	str	r2, [r5, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 800207c:	61a8      	str	r0, [r5, #24]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
 800207e:	61ea      	str	r2, [r5, #28]
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8002080:	7863      	ldrb	r3, [r4, #1]
 8002082:	2b00      	cmp	r3, #0
 8002084:	d031      	beq.n	80020ea <USB_OTG_CoreInitDev+0xa6>
* @brief  USB_OTG_CoreInitDev : Initializes the USB_OTG controller registers 
*         for device mode
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
 8002086:	f104 0014 	add.w	r0, r4, #20
    else
    {
      depctl.d32 = 0;
    }
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
 800208a:	4617      	mov	r7, r2
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 800208c:	26ff      	movs	r6, #255	; 0xff
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[i]->DIEPCTL);
 800208e:	f850 3f04 	ldr.w	r3, [r0, #4]!
 8002092:	6819      	ldr	r1, [r3, #0]
    if (depctl.b.epena)
 8002094:	f3c1 6e07 	ubfx	lr, r1, #24, #8
 8002098:	f00e 0c80 	and.w	ip, lr, #128	; 0x80
 800209c:	fa5f f18c 	uxtb.w	r1, ip
    {
      depctl.d32 = 0;
      depctl.b.epdis = 1;
      depctl.b.snak = 1;
 80020a0:	2900      	cmp	r1, #0
 80020a2:	bf18      	it	ne
 80020a4:	f04f 4190 	movne.w	r1, #1207959552	; 0x48000000
    }
    else
    {
      depctl.d32 = 0;
    }
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
 80020a8:	6019      	str	r1, [r3, #0]
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
 80020aa:	611f      	str	r7, [r3, #16]
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 80020ac:	609e      	str	r6, [r3, #8]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 80020ae:	7863      	ldrb	r3, [r4, #1]
 80020b0:	3201      	adds	r2, #1
 80020b2:	4293      	cmp	r3, r2
 80020b4:	d8eb      	bhi.n	800208e <USB_OTG_CoreInitDev+0x4a>
    }
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
  }
  for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
 80020b6:	b1c3      	cbz	r3, 80020ea <USB_OTG_CoreInitDev+0xa6>
* @brief  USB_OTG_CoreInitDev : Initializes the USB_OTG controller registers 
*         for device mode
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
 80020b8:	2200      	movs	r2, #0
 80020ba:	f104 0050 	add.w	r0, r4, #80	; 0x50
    else
    {
      depctl.d32 = 0;
    }
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPCTL, depctl.d32);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
 80020be:	4617      	mov	r7, r2
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 80020c0:	26ff      	movs	r6, #255	; 0xff
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
  }
  for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
  {
    USB_OTG_DEPCTL_TypeDef  depctl;
    depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[i]->DOEPCTL);
 80020c2:	f850 3f04 	ldr.w	r3, [r0, #4]!
 80020c6:	6819      	ldr	r1, [r3, #0]
    if (depctl.b.epena)
 80020c8:	f3c1 6e07 	ubfx	lr, r1, #24, #8
 80020cc:	f00e 0c80 	and.w	ip, lr, #128	; 0x80
 80020d0:	fa5f f18c 	uxtb.w	r1, ip
    {
      depctl.d32 = 0;
      depctl.b.epdis = 1;
      depctl.b.snak = 1;
 80020d4:	2900      	cmp	r1, #0
 80020d6:	bf18      	it	ne
 80020d8:	f04f 4190 	movne.w	r1, #1207959552	; 0x48000000
    }
    else
    {
      depctl.d32 = 0;
    }
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPCTL, depctl.d32);
 80020dc:	6019      	str	r1, [r3, #0]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
 80020de:	611f      	str	r7, [r3, #16]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 80020e0:	609e      	str	r6, [r3, #8]
    }
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
  }
  for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
 80020e2:	7863      	ldrb	r3, [r4, #1]
 80020e4:	3201      	adds	r2, #1
 80020e6:	4293      	cmp	r3, r2
 80020e8:	d8eb      	bhi.n	80020c2 <USB_OTG_CoreInitDev+0x7e>
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  msk.d32 = 0;
  msk.b.txfifoundrn = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPMSK, msk.d32, msk.d32);
 80020ea:	692b      	ldr	r3, [r5, #16]
 80020ec:	f443 7080 	orr.w	r0, r3, #256	; 0x100
 80020f0:	6128      	str	r0, [r5, #16]
  
  if (pdev->cfg.dma_enable == 1)
 80020f2:	78e2      	ldrb	r2, [r4, #3]
 80020f4:	2a01      	cmp	r2, #1
 80020f6:	d108      	bne.n	800210a <USB_OTG_CoreInitDev+0xc6>
  {
    dthrctl.d32 = 0;
    dthrctl.b.non_iso_thr_en = 1;
    dthrctl.b.iso_thr_en = 1;
    dthrctl.b.tx_thr_len = 64;
 80020f8:	2240      	movs	r2, #64	; 0x40
  
  if (pdev->cfg.dma_enable == 1)
  {
    dthrctl.d32 = 0;
    dthrctl.b.non_iso_thr_en = 1;
    dthrctl.b.iso_thr_en = 1;
 80020fa:	2003      	movs	r0, #3
    dthrctl.b.tx_thr_len = 64;
 80020fc:	f362 008a 	bfi	r0, r2, #2, #9
    dthrctl.b.rx_thr_en = 1;
 8002100:	f440 3180 	orr.w	r1, r0, #65536	; 0x10000
    dthrctl.b.rx_thr_len = 64;
 8002104:	f362 4159 	bfi	r1, r2, #17, #9
    USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DTHRCTL, dthrctl.d32);  
 8002108:	6329      	str	r1, [r5, #48]	; 0x30
  }
  USB_OTG_EnableDevInt(pdev);
 800210a:	4620      	mov	r0, r4
 800210c:	f7ff ff7a 	bl	8002004 <USB_OTG_EnableDevInt>
  return status;
}
 8002110:	2000      	movs	r0, #0
 8002112:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
*/
void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
{
  USB_OTG_DCFG_TypeDef   dcfg;
  
  dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
 8002114:	6816      	ldr	r6, [r2, #0]
    
    /* Set Full speed phy */
    USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
    
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 8002116:	68e0      	ldr	r0, [r4, #12]
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
    
    
    /* EP1 TX*/
    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
 8002118:	27c0      	movs	r7, #192	; 0xc0
    
    /* Set Full speed phy */
    USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
    
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 800211a:	2580      	movs	r5, #128	; 0x80
    
    /* EP0 TX*/
    nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
 800211c:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
    
    
    /* EP1 TX*/
    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
 8002120:	f367 030f 	bfi	r3, r7, #0, #16
void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
{
  USB_OTG_DCFG_TypeDef   dcfg;
  
  dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
  dcfg.b.devspd = speed;
 8002124:	f046 0603 	orr.w	r6, r6, #3
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCFG, dcfg.d32);
 8002128:	6016      	str	r6, [r2, #0]
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
    
    
    /* EP1 TX*/
    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
    txfifosize.b.depth = TX1_FIFO_FS_SIZE;
 800212a:	f365 431f 	bfi	r3, r5, #16, #16
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
    
    /* EP0 TX*/
    nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
 800212e:	f365 010f 	bfi	r1, r5, #0, #16
    txfifosize.b.depth = TX1_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
    
    
    /* EP2 TX*/
    txfifosize.b.startaddr += txfifosize.b.depth;
 8002132:	f44f 72a0 	mov.w	r2, #320	; 0x140
    
    /* Set Full speed phy */
    USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
    
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 8002136:	6245      	str	r5, [r0, #36]	; 0x24
    
    /* EP0 TX*/
    nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
 8002138:	6281      	str	r1, [r0, #40]	; 0x28
    
    
    /* EP1 TX*/
    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
    txfifosize.b.depth = TX1_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
 800213a:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
    
    
    /* EP2 TX*/
    txfifosize.b.startaddr += txfifosize.b.depth;
 800213e:	f362 030f 	bfi	r3, r2, #0, #16
    txfifosize.b.depth = TX2_FIFO_FS_SIZE;
 8002142:	f36f 431f 	bfc	r3, #16, #16
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[1], txfifosize.d32 );
 8002146:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
    
    
    /* EP3 TX*/  
    txfifosize.b.startaddr += txfifosize.b.depth;
    txfifosize.b.depth = TX3_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[2], txfifosize.d32 );
 800214a:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
 800214e:	e788      	b.n	8002062 <USB_OTG_CoreInitDev+0x1e>

08002150 <USB_OTG_GetDeviceSpeed>:
{
  USB_OTG_DSTS_TypeDef  dsts;
  enum USB_OTG_SPEED speed = USB_SPEED_UNKNOWN;
  
  
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8002150:	6900      	ldr	r0, [r0, #16]
 8002152:	6883      	ldr	r3, [r0, #8]
  
  switch (dsts.b.enumspd)
 8002154:	f3c3 0341 	ubfx	r3, r3, #1, #2
 8002158:	1e5a      	subs	r2, r3, #1
 800215a:	2a02      	cmp	r2, #2
 800215c:	d804      	bhi.n	8002168 <USB_OTG_GetDeviceSpeed+0x18>
 800215e:	4a03      	ldr	r2, [pc, #12]	; (800216c <USB_OTG_GetDeviceSpeed+0x1c>)
 8002160:	18d1      	adds	r1, r2, r3
 8002162:	f811 0c01 	ldrb.w	r0, [r1, #-1]
 8002166:	4770      	bx	lr
 8002168:	2003      	movs	r0, #3
    speed = USB_SPEED_LOW;
    break;
  }
  
  return speed;
}
 800216a:	4770      	bx	lr
 800216c:	0800b704 	.word	0x0800b704

08002170 <USB_OTG_EP0Activate>:
  USB_OTG_DEPCTL_TypeDef  diepctl;
  USB_OTG_DCTL_TypeDef    dctl;
  
  dctl.d32 = 0;
  /* Read the Device Status and Endpoint 0 Control registers */
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8002170:	6903      	ldr	r3, [r0, #16]
  diepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL);
 8002172:	6982      	ldr	r2, [r0, #24]
  USB_OTG_DEPCTL_TypeDef  diepctl;
  USB_OTG_DCTL_TypeDef    dctl;
  
  dctl.d32 = 0;
  /* Read the Device Status and Endpoint 0 Control registers */
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8002174:	6898      	ldr	r0, [r3, #8]
  diepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL);
 8002176:	6811      	ldr	r1, [r2, #0]
  /* Set the MPS of the IN EP based on the enumeration speed */
  switch (dsts.b.enumspd)
 8002178:	f3c0 0041 	ubfx	r0, r0, #1, #2
 800217c:	2802      	cmp	r0, #2
 800217e:	d008      	beq.n	8002192 <USB_OTG_EP0Activate+0x22>
  {
  case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
  case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
  case DSTS_ENUMSPD_FS_PHY_48MHZ:
    diepctl.b.mps = DEP0CTL_MPS_64;
 8002180:	f36f 010a 	bfc	r1, #0, #11
    break;
  case DSTS_ENUMSPD_LS_PHY_6MHZ:
    diepctl.b.mps = DEP0CTL_MPS_8;
    break;
  }
  USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL, diepctl.d32);
 8002184:	6011      	str	r1, [r2, #0]
  dctl.b.cgnpinnak = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, dctl.d32);
 8002186:	6859      	ldr	r1, [r3, #4]
 8002188:	f441 7280 	orr.w	r2, r1, #256	; 0x100
 800218c:	605a      	str	r2, [r3, #4]
  return status;
}
 800218e:	2000      	movs	r0, #0
 8002190:	4770      	bx	lr
  case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
  case DSTS_ENUMSPD_FS_PHY_48MHZ:
    diepctl.b.mps = DEP0CTL_MPS_64;
    break;
  case DSTS_ENUMSPD_LS_PHY_6MHZ:
    diepctl.b.mps = DEP0CTL_MPS_8;
 8002192:	2003      	movs	r0, #3
 8002194:	f360 010a 	bfi	r1, r0, #0, #11
    break;
  }
  USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL, diepctl.d32);
 8002198:	6011      	str	r1, [r2, #0]
  dctl.b.cgnpinnak = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, dctl.d32);
 800219a:	6859      	ldr	r1, [r3, #4]
 800219c:	f441 7280 	orr.w	r2, r1, #256	; 0x100
 80021a0:	605a      	str	r2, [r3, #4]
  return status;
}
 80021a2:	2000      	movs	r0, #0
 80021a4:	4770      	bx	lr
 80021a6:	bf00      	nop

080021a8 <USB_OTG_EPActivate>:
* @brief  USB_OTG_EPActivate : Activates an EP
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPActivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 80021a8:	b470      	push	{r4, r5, r6}
  
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 80021aa:	784b      	ldrb	r3, [r1, #1]
  USB_OTG_DAINT_TypeDef  daintmsk;
  __IO uint32_t *addr;
  
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;
 80021ac:	2200      	movs	r2, #0
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 80021ae:	2b01      	cmp	r3, #1
 80021b0:	d027      	beq.n	8002202 <USB_OTG_EPActivate+0x5a>
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 80021b2:	780c      	ldrb	r4, [r1, #0]
 80021b4:	eb00 0c84 	add.w	ip, r0, r4, lsl #2
    daintmsk.ep.out = 1 << ep->num;
 80021b8:	2501      	movs	r5, #1
 80021ba:	fa15 f304 	lsls.w	r3, r5, r4
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 80021be:	f8dc 4054 	ldr.w	r4, [ip, #84]	; 0x54
    daintmsk.ep.out = 1 << ep->num;
 80021c2:	f363 421f 	bfi	r2, r3, #16, #16
  }
  /* If the EP is already active don't change the EP Control
  * register. */
  depctl.d32 = USB_OTG_READ_REG32(addr);
 80021c6:	6823      	ldr	r3, [r4, #0]
  if (!depctl.b.usbactep)
 80021c8:	f3c3 2507 	ubfx	r5, r3, #8, #8
 80021cc:	f005 0c80 	and.w	ip, r5, #128	; 0x80
 80021d0:	fa5f f58c 	uxtb.w	r5, ip
 80021d4:	b975      	cbnz	r5, 80021f4 <USB_OTG_EPActivate+0x4c>
  {
    depctl.b.mps    = ep->maxpacket;
 80021d6:	688e      	ldr	r6, [r1, #8]
    depctl.b.eptype = ep->type;
 80021d8:	78cd      	ldrb	r5, [r1, #3]
    depctl.b.txfnum = ep->tx_fifo_num;
 80021da:	f8b1 c006 	ldrh.w	ip, [r1, #6]
  /* If the EP is already active don't change the EP Control
  * register. */
  depctl.d32 = USB_OTG_READ_REG32(addr);
  if (!depctl.b.usbactep)
  {
    depctl.b.mps    = ep->maxpacket;
 80021de:	f366 030a 	bfi	r3, r6, #0, #11
    depctl.b.eptype = ep->type;
 80021e2:	f365 4393 	bfi	r3, r5, #18, #2
    depctl.b.txfnum = ep->tx_fifo_num;
 80021e6:	f36c 5399 	bfi	r3, ip, #22, #4
    depctl.b.setd0pid = 1;
 80021ea:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    depctl.b.usbactep = 1;
 80021ee:	f443 4100 	orr.w	r1, r3, #32768	; 0x8000
    USB_OTG_WRITE_REG32(addr, depctl.d32);
 80021f2:	6021      	str	r1, [r4, #0]
  {
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, 0, daintmsk.d32);
  }
  else
#endif   
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, 0, daintmsk.d32);
 80021f4:	6900      	ldr	r0, [r0, #16]
 80021f6:	69c1      	ldr	r1, [r0, #28]
 80021f8:	430a      	orrs	r2, r1
 80021fa:	61c2      	str	r2, [r0, #28]
  return status;
}
 80021fc:	2000      	movs	r0, #0
 80021fe:	bc70      	pop	{r4, r5, r6}
 8002200:	4770      	bx	lr
  depctl.d32 = 0;
  daintmsk.d32 = 0;
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 8002202:	780c      	ldrb	r4, [r1, #0]
 8002204:	eb00 0584 	add.w	r5, r0, r4, lsl #2
    daintmsk.ep.in = 1 << ep->num;
 8002208:	40a3      	lsls	r3, r4
 800220a:	f363 020f 	bfi	r2, r3, #0, #16
  depctl.d32 = 0;
  daintmsk.d32 = 0;
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 800220e:	69ac      	ldr	r4, [r5, #24]
 8002210:	e7d9      	b.n	80021c6 <USB_OTG_EPActivate+0x1e>
 8002212:	bf00      	nop

08002214 <USB_OTG_EPDeactivate>:
* @brief  USB_OTG_EPDeactivate : Deactivates an EP
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPDeactivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 8002214:	b430      	push	{r4, r5}
  __IO uint32_t *addr;
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 8002216:	784a      	ldrb	r2, [r1, #1]
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_DEPCTL_TypeDef  depctl;
  USB_OTG_DAINT_TypeDef  daintmsk;
  __IO uint32_t *addr;
  
  depctl.d32 = 0;
 8002218:	2300      	movs	r3, #0
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 800221a:	2a01      	cmp	r2, #1
  USB_OTG_DEPCTL_TypeDef  depctl;
  USB_OTG_DAINT_TypeDef  daintmsk;
  __IO uint32_t *addr;
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
 800221c:	461c      	mov	r4, r3
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 800221e:	d014      	beq.n	800224a <USB_OTG_EPDeactivate+0x36>
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 8002220:	7809      	ldrb	r1, [r1, #0]
 8002222:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
    daintmsk.ep.out = 1 << ep->num;
 8002226:	2501      	movs	r5, #1
 8002228:	fa15 f201 	lsls.w	r2, r5, r1
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 800222c:	f8dc 1054 	ldr.w	r1, [ip, #84]	; 0x54
    daintmsk.ep.out = 1 << ep->num;
 8002230:	f362 441f 	bfi	r4, r2, #16, #16
  {
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, daintmsk.d32, 0);
  }
  else
#endif    
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, daintmsk.d32, 0);
 8002234:	6900      	ldr	r0, [r0, #16]
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
    daintmsk.ep.out = 1 << ep->num;
  }
  depctl.b.usbactep = 0;
 8002236:	f36f 33cf 	bfc	r3, #15, #1
  USB_OTG_WRITE_REG32(addr, depctl.d32);
 800223a:	600b      	str	r3, [r1, #0]
  {
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, daintmsk.d32, 0);
  }
  else
#endif    
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, daintmsk.d32, 0);
 800223c:	69c3      	ldr	r3, [r0, #28]
 800223e:	ea23 0404 	bic.w	r4, r3, r4
 8002242:	61c4      	str	r4, [r0, #28]
  return status;
}
 8002244:	2000      	movs	r0, #0
 8002246:	bc30      	pop	{r4, r5}
 8002248:	4770      	bx	lr
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 800224a:	7809      	ldrb	r1, [r1, #0]
 800224c:	eb00 0581 	add.w	r5, r0, r1, lsl #2
    daintmsk.ep.in = 1 << ep->num;
 8002250:	408a      	lsls	r2, r1
 8002252:	f362 040f 	bfi	r4, r2, #0, #16
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 8002256:	69a9      	ldr	r1, [r5, #24]
 8002258:	e7ec      	b.n	8002234 <USB_OTG_EPDeactivate+0x20>
 800225a:	bf00      	nop

0800225c <USB_OTG_EPStartXfer>:
*         starts the xfer
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPStartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 800225c:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t fifoemptymsk = 0;  
  
  depctl.d32 = 0;
  deptsiz.d32 = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
 800225e:	784b      	ldrb	r3, [r1, #1]
 8002260:	2b01      	cmp	r3, #1
 8002262:	d041      	beq.n	80022e8 <USB_OTG_EPStartXfer+0x8c>
    }    
  }
  else
  {
    /* OUT endpoint */
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL));
 8002264:	f891 c000 	ldrb.w	ip, [r1]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ));
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    if (ep->xfer_len == 0)
 8002268:	694e      	ldr	r6, [r1, #20]
    }    
  }
  else
  {
    /* OUT endpoint */
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL));
 800226a:	eb00 038c 	add.w	r3, r0, ip, lsl #2
 800226e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8002270:	681c      	ldr	r4, [r3, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ));
 8002272:	691a      	ldr	r2, [r3, #16]
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    if (ep->xfer_len == 0)
 8002274:	b1f6      	cbz	r6, 80022b4 <USB_OTG_EPStartXfer+0x58>
      deptsiz.b.xfersize = ep->maxpacket;
      deptsiz.b.pktcnt = 1;
    }
    else
    {
      deptsiz.b.pktcnt = (ep->xfer_len + (ep->maxpacket - 1)) / ep->maxpacket;
 8002276:	688f      	ldr	r7, [r1, #8]
 8002278:	19f5      	adds	r5, r6, r7
 800227a:	3d01      	subs	r5, #1
 800227c:	fbb5 f5f7 	udiv	r5, r5, r7
 8002280:	05ad      	lsls	r5, r5, #22
 8002282:	0dad      	lsrs	r5, r5, #22
 8002284:	f365 42dc 	bfi	r2, r5, #19, #10
      deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
 8002288:	fb07 f505 	mul.w	r5, r7, r5
 800228c:	f365 0212 	bfi	r2, r5, #0, #19
    }
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
 8002290:	611a      	str	r2, [r3, #16]
    
    if (pdev->cfg.dma_enable == 1)
 8002292:	78c2      	ldrb	r2, [r0, #3]
 8002294:	2a01      	cmp	r2, #1
 8002296:	d017      	beq.n	80022c8 <USB_OTG_EPStartXfer+0x6c>
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
    }
    
    if (ep->type == EP_TYPE_ISOC)
 8002298:	78ca      	ldrb	r2, [r1, #3]
 800229a:	2a01      	cmp	r2, #1
 800229c:	d01e      	beq.n	80022dc <USB_OTG_EPStartXfer+0x80>
      }
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL, depctl.d32);
 800229e:	f891 c000 	ldrb.w	ip, [r1]
 80022a2:	eb00 018c 	add.w	r1, r0, ip, lsl #2
        depctl.b.setd0pid = 1;
      }
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 80022a6:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL, depctl.d32);
 80022aa:	6d48      	ldr	r0, [r1, #84]	; 0x54
 80022ac:	6004      	str	r4, [r0, #0]
  }
  return status;
}
 80022ae:	2000      	movs	r0, #0
 80022b0:	bcf0      	pop	{r4, r5, r6, r7}
 80022b2:	4770      	bx	lr
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = ep->maxpacket;
 80022b4:	688d      	ldr	r5, [r1, #8]
 80022b6:	f365 0212 	bfi	r2, r5, #0, #19
      deptsiz.b.pktcnt = 1;
 80022ba:	2501      	movs	r5, #1
 80022bc:	f365 42dc 	bfi	r2, r5, #19, #10
    else
    {
      deptsiz.b.pktcnt = (ep->xfer_len + (ep->maxpacket - 1)) / ep->maxpacket;
      deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
    }
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
 80022c0:	611a      	str	r2, [r3, #16]
    
    if (pdev->cfg.dma_enable == 1)
 80022c2:	78c2      	ldrb	r2, [r0, #3]
 80022c4:	2a01      	cmp	r2, #1
 80022c6:	d1e7      	bne.n	8002298 <USB_OTG_EPStartXfer+0x3c>
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
 80022c8:	780b      	ldrb	r3, [r1, #0]
 80022ca:	690a      	ldr	r2, [r1, #16]
 80022cc:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
 80022d0:	f8dc 3054 	ldr.w	r3, [ip, #84]	; 0x54
 80022d4:	615a      	str	r2, [r3, #20]
    }
    
    if (ep->type == EP_TYPE_ISOC)
 80022d6:	78ca      	ldrb	r2, [r1, #3]
 80022d8:	2a01      	cmp	r2, #1
 80022da:	d1e0      	bne.n	800229e <USB_OTG_EPStartXfer+0x42>
    {
      if (ep->even_odd_frame)
 80022dc:	794b      	ldrb	r3, [r1, #5]
 80022de:	2b00      	cmp	r3, #0
 80022e0:	d072      	beq.n	80023c8 <USB_OTG_EPStartXfer+0x16c>
      {
        depctl.b.setd1pid = 1;
 80022e2:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
 80022e6:	e7da      	b.n	800229e <USB_OTG_EPStartXfer+0x42>
  depctl.d32 = 0;
  deptsiz.d32 = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
 80022e8:	780d      	ldrb	r5, [r1, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 80022ea:	694a      	ldr	r2, [r1, #20]
  depctl.d32 = 0;
  deptsiz.d32 = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
 80022ec:	eb00 0485 	add.w	r4, r0, r5, lsl #2
 80022f0:	69a5      	ldr	r5, [r4, #24]
 80022f2:	682e      	ldr	r6, [r5, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
 80022f4:	692c      	ldr	r4, [r5, #16]
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 80022f6:	2a00      	cmp	r2, #0
 80022f8:	d061      	beq.n	80023be <USB_OTG_EPStartXfer+0x162>
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      deptsiz.b.xfersize = ep->xfer_len;
      deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
 80022fa:	688b      	ldr	r3, [r1, #8]

      if (ep->type == EP_TYPE_ISOC)
 80022fc:	78cf      	ldrb	r7, [r1, #3]
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      deptsiz.b.xfersize = ep->xfer_len;
      deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
 80022fe:	eb02 0c03 	add.w	ip, r2, r3
 8002302:	f10c 3cff 	add.w	ip, ip, #4294967295
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      deptsiz.b.xfersize = ep->xfer_len;
 8002306:	f362 0412 	bfi	r4, r2, #0, #19
      deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
 800230a:	fbbc f3f3 	udiv	r3, ip, r3
 800230e:	f363 44dc 	bfi	r4, r3, #19, #10

      if (ep->type == EP_TYPE_ISOC)
 8002312:	2f01      	cmp	r7, #1
      {
        deptsiz.b.mc = 1;
 8002314:	bf08      	it	eq
 8002316:	f367 745e 	bfieq	r4, r7, #29, #2
      }       
    }
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ, deptsiz.d32);
 800231a:	612c      	str	r4, [r5, #16]
    
    if (pdev->cfg.dma_enable == 1)
 800231c:	78c5      	ldrb	r5, [r0, #3]
 800231e:	2d01      	cmp	r5, #1
 8002320:	d05f      	beq.n	80023e2 <USB_OTG_EPStartXfer+0x186>
    {
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);
    }
    else
    {
      if (ep->type != EP_TYPE_ISOC)
 8002322:	78cb      	ldrb	r3, [r1, #3]
 8002324:	2b01      	cmp	r3, #1
 8002326:	d052      	beq.n	80023ce <USB_OTG_EPStartXfer+0x172>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0)
 8002328:	b162      	cbz	r2, 8002344 <USB_OTG_EPStartXfer+0xe8>
        {
          fifoemptymsk = 1 << ep->num;
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 800232a:	6903      	ldr	r3, [r0, #16]
      if (ep->type != EP_TYPE_ISOC)
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0)
        {
          fifoemptymsk = 1 << ep->num;
 800232c:	780c      	ldrb	r4, [r1, #0]
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 800232e:	6b5d      	ldr	r5, [r3, #52]	; 0x34
      if (ep->type != EP_TYPE_ISOC)
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0)
        {
          fifoemptymsk = 1 << ep->num;
 8002330:	2701      	movs	r7, #1
 8002332:	fa17 f404 	lsls.w	r4, r7, r4
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 8002336:	432c      	orrs	r4, r5
 8002338:	635c      	str	r4, [r3, #52]	; 0x34
        }
      }
    }
    
    
    if (ep->type == EP_TYPE_ISOC)
 800233a:	f891 c003 	ldrb.w	ip, [r1, #3]
 800233e:	f1bc 0f01 	cmp.w	ip, #1
 8002342:	d044      	beq.n	80023ce <USB_OTG_EPStartXfer+0x172>
    } 
    
    /* EP enable, IN data in FIFO */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);
 8002344:	780d      	ldrb	r5, [r1, #0]
 8002346:	eb00 0c85 	add.w	ip, r0, r5, lsl #2
      }
    } 
    
    /* EP enable, IN data in FIFO */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 800234a:	f046 4604 	orr.w	r6, r6, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);
 800234e:	f8dc 3018 	ldr.w	r3, [ip, #24]
 8002352:	601e      	str	r6, [r3, #0]

    if (ep->type == EP_TYPE_ISOC)
 8002354:	78cd      	ldrb	r5, [r1, #3]
 8002356:	2d01      	cmp	r5, #1
 8002358:	d1a9      	bne.n	80022ae <USB_OTG_EPStartXfer+0x52>
                                uint8_t             *src, 
                                uint8_t             ch_ep_num, 
                                uint16_t            len)
{
  USB_OTG_STS status = USB_OTG_OK;
  if (pdev->cfg.dma_enable == 0)
 800235a:	78c4      	ldrb	r4, [r0, #3]
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);

    if (ep->type == EP_TYPE_ISOC)
    {
      USB_OTG_WritePacket(pdev, ep->xfer_buff, ep->num, ep->xfer_len);   
 800235c:	68cb      	ldr	r3, [r1, #12]
 800235e:	7809      	ldrb	r1, [r1, #0]
                                uint8_t             *src, 
                                uint8_t             ch_ep_num, 
                                uint16_t            len)
{
  USB_OTG_STS status = USB_OTG_OK;
  if (pdev->cfg.dma_enable == 0)
 8002360:	2c00      	cmp	r4, #0
 8002362:	d1a4      	bne.n	80022ae <USB_OTG_EPStartXfer+0x52>
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
 8002364:	b294      	uxth	r4, r2
 8002366:	1ce2      	adds	r2, r4, #3
    fifo = pdev->regs.DFIFO[ch_ep_num];
 8002368:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    for (i = 0; i < count32b; i++, src+=4)
 800236c:	1092      	asrs	r2, r2, #2
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
 800236e:	f8d0 40d0 	ldr.w	r4, [r0, #208]	; 0xd0
    for (i = 0; i < count32b; i++, src+=4)
 8002372:	d09c      	beq.n	80022ae <USB_OTG_EPStartXfer+0x52>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8002374:	f853 1b04 	ldr.w	r1, [r3], #4
 8002378:	1e56      	subs	r6, r2, #1
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 800237a:	2a01      	cmp	r2, #1
 800237c:	f006 0601 	and.w	r6, r6, #1
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8002380:	6021      	str	r1, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8002382:	4628      	mov	r0, r5
 8002384:	d093      	beq.n	80022ae <USB_OTG_EPStartXfer+0x52>
 8002386:	b12e      	cbz	r6, 8002394 <USB_OTG_EPStartXfer+0x138>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8002388:	f853 1b04 	ldr.w	r1, [r3], #4
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 800238c:	2002      	movs	r0, #2
 800238e:	4282      	cmp	r2, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8002390:	6021      	str	r1, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8002392:	d08c      	beq.n	80022ae <USB_OTG_EPStartXfer+0x52>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8002394:	4619      	mov	r1, r3
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8002396:	3002      	adds	r0, #2
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8002398:	f851 5b04 	ldr.w	r5, [r1], #4
 800239c:	6025      	str	r5, [r4, #0]
 800239e:	685d      	ldr	r5, [r3, #4]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 80023a0:	1d0b      	adds	r3, r1, #4
 80023a2:	4282      	cmp	r2, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 80023a4:	6025      	str	r5, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 80023a6:	d082      	beq.n	80022ae <USB_OTG_EPStartXfer+0x52>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 80023a8:	4619      	mov	r1, r3
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 80023aa:	3002      	adds	r0, #2
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 80023ac:	f851 5b04 	ldr.w	r5, [r1], #4
 80023b0:	6025      	str	r5, [r4, #0]
 80023b2:	685d      	ldr	r5, [r3, #4]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 80023b4:	1d0b      	adds	r3, r1, #4
 80023b6:	4282      	cmp	r2, r0
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 80023b8:	6025      	str	r5, [r4, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 80023ba:	d1eb      	bne.n	8002394 <USB_OTG_EPStartXfer+0x138>
 80023bc:	e777      	b.n	80022ae <USB_OTG_EPStartXfer+0x52>
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = 0;
 80023be:	f362 0412 	bfi	r4, r2, #0, #19
      deptsiz.b.pktcnt = 1;
 80023c2:	f363 44dc 	bfi	r4, r3, #19, #10
 80023c6:	e7a8      	b.n	800231a <USB_OTG_EPStartXfer+0xbe>
      {
        depctl.b.setd1pid = 1;
      }
      else
      {
        depctl.b.setd0pid = 1;
 80023c8:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
 80023cc:	e767      	b.n	800229e <USB_OTG_EPStartXfer+0x42>
    }
    
    
    if (ep->type == EP_TYPE_ISOC)
    {
      dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 80023ce:	6905      	ldr	r5, [r0, #16]
 80023d0:	68ab      	ldr	r3, [r5, #8]
      
      if (((dsts.b.soffn)&0x1) == 0)
 80023d2:	f413 7f80 	tst.w	r3, #256	; 0x100
      {
        depctl.b.setd1pid = 1;
 80023d6:	bf0c      	ite	eq
 80023d8:	f046 5600 	orreq.w	r6, r6, #536870912	; 0x20000000
      }
      else
      {
        depctl.b.setd0pid = 1;
 80023dc:	f046 5680 	orrne.w	r6, r6, #268435456	; 0x10000000
 80023e0:	e7b0      	b.n	8002344 <USB_OTG_EPStartXfer+0xe8>
    }
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ, deptsiz.d32);
    
    if (pdev->cfg.dma_enable == 1)
    {
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);
 80023e2:	780d      	ldrb	r5, [r1, #0]
 80023e4:	690c      	ldr	r4, [r1, #16]
 80023e6:	eb00 0c85 	add.w	ip, r0, r5, lsl #2
 80023ea:	f8dc 3018 	ldr.w	r3, [ip, #24]
 80023ee:	615c      	str	r4, [r3, #20]
 80023f0:	e7a3      	b.n	800233a <USB_OTG_EPStartXfer+0xde>
 80023f2:	bf00      	nop

080023f4 <USB_OTG_EP0StartXfer>:
*         starts the xfer
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EP0StartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 80023f4:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t fifoemptymsk = 0;
  
  depctl.d32   = 0;
  deptsiz.d32  = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
 80023f6:	784b      	ldrb	r3, [r1, #1]
 80023f8:	2b01      	cmp	r3, #1
*         starts the xfer
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EP0StartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 80023fa:	b082      	sub	sp, #8
  uint32_t fifoemptymsk = 0;
  
  depctl.d32   = 0;
  deptsiz.d32  = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
 80023fc:	d02f      	beq.n	800245e <USB_OTG_EP0StartXfer+0x6a>
    }
  }
  else
  {
    /* OUT endpoint */
    depctl.d32  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 80023fe:	f891 c000 	ldrb.w	ip, [r1]
    deptsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ);
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
 8002402:	694e      	ldr	r6, [r1, #20]
    }
  }
  else
  {
    /* OUT endpoint */
    depctl.d32  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 8002404:	eb00 048c 	add.w	r4, r0, ip, lsl #2
 8002408:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800240a:	681a      	ldr	r2, [r3, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ);
 800240c:	691d      	ldr	r5, [r3, #16]
 800240e:	9500      	str	r5, [sp, #0]
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
 8002410:	b1fe      	cbz	r6, 8002452 <USB_OTG_EP0StartXfer+0x5e>
      deptsiz.b.xfersize = ep->maxpacket;
      deptsiz.b.pktcnt = 1;
    }
    else
    {
      ep->xfer_len = ep->maxpacket;
 8002412:	688e      	ldr	r6, [r1, #8]
      deptsiz.b.xfersize = ep->maxpacket;
 8002414:	f89d 5000 	ldrb.w	r5, [sp]
      deptsiz.b.pktcnt = 1;
 8002418:	f89d 4002 	ldrb.w	r4, [sp, #2]
      deptsiz.b.xfersize = ep->maxpacket;
      deptsiz.b.pktcnt = 1;
    }
    else
    {
      ep->xfer_len = ep->maxpacket;
 800241c:	614e      	str	r6, [r1, #20]
      deptsiz.b.xfersize = ep->maxpacket;
 800241e:	f366 0506 	bfi	r5, r6, #0, #7
      deptsiz.b.pktcnt = 1;
 8002422:	2601      	movs	r6, #1
 8002424:	f366 04c4 	bfi	r4, r6, #3, #2
      deptsiz.b.pktcnt = 1;
    }
    else
    {
      ep->xfer_len = ep->maxpacket;
      deptsiz.b.xfersize = ep->maxpacket;
 8002428:	f88d 5000 	strb.w	r5, [sp]
      deptsiz.b.pktcnt = 1;
 800242c:	f88d 4002 	strb.w	r4, [sp, #2]
    }
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
 8002430:	9c00      	ldr	r4, [sp, #0]
 8002432:	611c      	str	r4, [r3, #16]
    if (pdev->cfg.dma_enable == 1)
 8002434:	78c3      	ldrb	r3, [r0, #3]
 8002436:	2b01      	cmp	r3, #1
 8002438:	d041      	beq.n	80024be <USB_OTG_EP0StartXfer+0xca>
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32 (&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL), depctl.d32);
 800243a:	f891 c000 	ldrb.w	ip, [r1]
 800243e:	eb00 008c 	add.w	r0, r0, ip, lsl #2
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 8002442:	f042 4104 	orr.w	r1, r2, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32 (&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL), depctl.d32);
 8002446:	6d42      	ldr	r2, [r0, #84]	; 0x54
 8002448:	6011      	str	r1, [r2, #0]
    
  }
  return status;
}
 800244a:	2000      	movs	r0, #0
 800244c:	b002      	add	sp, #8
 800244e:	bcf0      	pop	{r4, r5, r6, r7}
 8002450:	4770      	bx	lr
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = ep->maxpacket;
 8002452:	f89d 5000 	ldrb.w	r5, [sp]
      deptsiz.b.pktcnt = 1;
 8002456:	f89d 4002 	ldrb.w	r4, [sp, #2]
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = ep->maxpacket;
 800245a:	688e      	ldr	r6, [r1, #8]
 800245c:	e7df      	b.n	800241e <USB_OTG_EP0StartXfer+0x2a>
  depctl.d32   = 0;
  deptsiz.d32  = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    in_regs = pdev->regs.INEP_REGS[0];
 800245e:	6982      	ldr	r2, [r0, #24]
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 8002460:	694c      	ldr	r4, [r1, #20]
  deptsiz.d32  = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    in_regs = pdev->regs.INEP_REGS[0];
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
 8002462:	6815      	ldr	r5, [r2, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
 8002464:	6916      	ldr	r6, [r2, #16]
 8002466:	9600      	str	r6, [sp, #0]
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 8002468:	2c00      	cmp	r4, #0
 800246a:	d030      	beq.n	80024ce <USB_OTG_EP0StartXfer+0xda>
      deptsiz.b.pktcnt = 1;
      
    }
    else
    {
      if (ep->xfer_len > ep->maxpacket)
 800246c:	688b      	ldr	r3, [r1, #8]
 800246e:	429c      	cmp	r4, r3
 8002470:	d942      	bls.n	80024f8 <USB_OTG_EP0StartXfer+0x104>
      {
        ep->xfer_len = ep->maxpacket;
        deptsiz.b.xfersize = ep->maxpacket;
 8002472:	f89d 4000 	ldrb.w	r4, [sp]
    }
    else
    {
      if (ep->xfer_len > ep->maxpacket)
      {
        ep->xfer_len = ep->maxpacket;
 8002476:	614b      	str	r3, [r1, #20]
        deptsiz.b.xfersize = ep->maxpacket;
 8002478:	f363 0406 	bfi	r4, r3, #0, #7
 800247c:	f88d 4000 	strb.w	r4, [sp]
      }
      else
      {
        deptsiz.b.xfersize = ep->xfer_len;
      }
      deptsiz.b.pktcnt = 1;
 8002480:	f89d c002 	ldrb.w	ip, [sp, #2]
 8002484:	2401      	movs	r4, #1
 8002486:	f364 0cc4 	bfi	ip, r4, #3, #2
 800248a:	f88d c002 	strb.w	ip, [sp, #2]
    }
    USB_OTG_WRITE_REG32(&in_regs->DIEPTSIZ, deptsiz.d32);
 800248e:	9b00      	ldr	r3, [sp, #0]
 8002490:	6113      	str	r3, [r2, #16]
    
    if (pdev->cfg.dma_enable == 1)
 8002492:	78c3      	ldrb	r3, [r0, #3]
 8002494:	2b01      	cmp	r3, #1
 8002496:	d027      	beq.n	80024e8 <USB_OTG_EP0StartXfer+0xf4>
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);  
    }
    
    /* EP enable, IN data in FIFO */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 8002498:	f045 4304 	orr.w	r3, r5, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32(&in_regs->DIEPCTL, depctl.d32);
 800249c:	6013      	str	r3, [r2, #0]
    
    
    
    if (pdev->cfg.dma_enable == 0)
 800249e:	78c2      	ldrb	r2, [r0, #3]
 80024a0:	2a00      	cmp	r2, #0
 80024a2:	d1d2      	bne.n	800244a <USB_OTG_EP0StartXfer+0x56>
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0)
 80024a4:	694a      	ldr	r2, [r1, #20]
 80024a6:	2a00      	cmp	r2, #0
 80024a8:	d0cf      	beq.n	800244a <USB_OTG_EP0StartXfer+0x56>
      {
        {
          fifoemptymsk |= 1 << ep->num;
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 80024aa:	6903      	ldr	r3, [r0, #16]
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0)
      {
        {
          fifoemptymsk |= 1 << ep->num;
 80024ac:	780a      	ldrb	r2, [r1, #0]
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 80024ae:	6b59      	ldr	r1, [r3, #52]	; 0x34
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0)
      {
        {
          fifoemptymsk |= 1 << ep->num;
 80024b0:	2001      	movs	r0, #1
 80024b2:	fa10 f202 	lsls.w	r2, r0, r2
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 80024b6:	ea42 0001 	orr.w	r0, r2, r1
 80024ba:	6358      	str	r0, [r3, #52]	; 0x34
 80024bc:	e7c5      	b.n	800244a <USB_OTG_EP0StartXfer+0x56>
      deptsiz.b.pktcnt = 1;
    }
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
    if (pdev->cfg.dma_enable == 1)
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
 80024be:	780b      	ldrb	r3, [r1, #0]
 80024c0:	690c      	ldr	r4, [r1, #16]
 80024c2:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
 80024c6:	f8dc 3054 	ldr.w	r3, [ip, #84]	; 0x54
 80024ca:	615c      	str	r4, [r3, #20]
 80024cc:	e7b5      	b.n	800243a <USB_OTG_EP0StartXfer+0x46>
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = 0;
 80024ce:	f89d 7000 	ldrb.w	r7, [sp]
      deptsiz.b.pktcnt = 1;
 80024d2:	f89d 6002 	ldrb.w	r6, [sp, #2]
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = 0;
 80024d6:	f364 0706 	bfi	r7, r4, #0, #7
      deptsiz.b.pktcnt = 1;
 80024da:	f363 06c4 	bfi	r6, r3, #3, #2
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = 0;
 80024de:	f88d 7000 	strb.w	r7, [sp]
      deptsiz.b.pktcnt = 1;
 80024e2:	f88d 6002 	strb.w	r6, [sp, #2]
 80024e6:	e7d2      	b.n	800248e <USB_OTG_EP0StartXfer+0x9a>
    }
    USB_OTG_WRITE_REG32(&in_regs->DIEPTSIZ, deptsiz.d32);
    
    if (pdev->cfg.dma_enable == 1)
    {
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);  
 80024e8:	780b      	ldrb	r3, [r1, #0]
 80024ea:	690c      	ldr	r4, [r1, #16]
 80024ec:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
 80024f0:	f8dc 3018 	ldr.w	r3, [ip, #24]
 80024f4:	615c      	str	r4, [r3, #20]
 80024f6:	e7cf      	b.n	8002498 <USB_OTG_EP0StartXfer+0xa4>
        ep->xfer_len = ep->maxpacket;
        deptsiz.b.xfersize = ep->maxpacket;
      }
      else
      {
        deptsiz.b.xfersize = ep->xfer_len;
 80024f8:	f89d 3000 	ldrb.w	r3, [sp]
 80024fc:	f364 0306 	bfi	r3, r4, #0, #7
 8002500:	f88d 3000 	strb.w	r3, [sp]
 8002504:	e7bc      	b.n	8002480 <USB_OTG_EP0StartXfer+0x8c>
 8002506:	bf00      	nop

08002508 <USB_OTG_EPSetStall>:
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
 8002508:	784b      	ldrb	r3, [r1, #1]
 800250a:	2b01      	cmp	r3, #1
 800250c:	d00a      	beq.n	8002524 <USB_OTG_EPSetStall+0x1c>
    depctl.b.stall = 1;
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
  }
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 800250e:	7809      	ldrb	r1, [r1, #0]
 8002510:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
 8002514:	f8dc 3054 	ldr.w	r3, [ip, #84]	; 0x54
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 8002518:	681a      	ldr	r2, [r3, #0]
    /* set the stall bit */
    depctl.b.stall = 1;
 800251a:	f442 1000 	orr.w	r0, r2, #2097152	; 0x200000
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
 800251e:	6018      	str	r0, [r3, #0]
  }
  return status;
}
 8002520:	2000      	movs	r0, #0
 8002522:	4770      	bx	lr
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 8002524:	780b      	ldrb	r3, [r1, #0]
 8002526:	eb00 0283 	add.w	r2, r0, r3, lsl #2
 800252a:	6992      	ldr	r2, [r2, #24]
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 800252c:	6813      	ldr	r3, [r2, #0]
    /* set the disable and stall bits */
    if (depctl.b.epena)
 800252e:	f3c3 6c07 	ubfx	ip, r3, #24, #8
 8002532:	f00c 0080 	and.w	r0, ip, #128	; 0x80
 8002536:	b2c1      	uxtb	r1, r0
 8002538:	b109      	cbz	r1, 800253e <USB_OTG_EPSetStall+0x36>
    {
      depctl.b.epdis = 1;
 800253a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    }
    depctl.b.stall = 1;
 800253e:	f443 1100 	orr.w	r1, r3, #2097152	; 0x200000
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
 8002542:	6011      	str	r1, [r2, #0]
    /* set the stall bit */
    depctl.b.stall = 1;
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
  }
  return status;
}
 8002544:	2000      	movs	r0, #0
 8002546:	4770      	bx	lr

08002548 <USB_OTG_EPClearStall>:
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  
  if (ep->is_in == 1)
 8002548:	f891 c001 	ldrb.w	ip, [r1, #1]
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 800254c:	780b      	ldrb	r3, [r1, #0]
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 800254e:	78c9      	ldrb	r1, [r1, #3]
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  
  if (ep->is_in == 1)
 8002550:	f1bc 0f01 	cmp.w	ip, #1
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 8002554:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
 8002558:	bf0c      	ite	eq
 800255a:	f8dc 2018 	ldreq.w	r2, [ip, #24]
  }
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 800255e:	f8dc 2054 	ldrne.w	r2, [ip, #84]	; 0x54
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 8002562:	1e88      	subs	r0, r1, #2
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
  }
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 8002564:	6813      	ldr	r3, [r2, #0]
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 8002566:	b2c1      	uxtb	r1, r0
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
 8002568:	f36f 5355 	bfc	r3, #21, #1
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 800256c:	2901      	cmp	r1, #1
  {
    depctl.b.setd0pid = 1; /* DATA0 */
 800256e:	bf98      	it	ls
 8002570:	f043 5380 	orrls.w	r3, r3, #268435456	; 0x10000000
  }
  USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
 8002574:	6013      	str	r3, [r2, #0]
  return status;
}
 8002576:	2000      	movs	r0, #0
 8002578:	4770      	bx	lr
 800257a:	bf00      	nop

0800257c <USB_OTG_ReadDevAllOutEp_itr>:
* @retval OUT endpoint interrupt bits
*/
uint32_t USB_OTG_ReadDevAllOutEp_itr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v;
  v  = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
 800257c:	6903      	ldr	r3, [r0, #16]
 800257e:	699a      	ldr	r2, [r3, #24]
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
 8002580:	69d9      	ldr	r1, [r3, #28]
 8002582:	ea01 0002 	and.w	r0, r1, r2
  return ((v & 0xffff0000) >> 16);
}
 8002586:	0c00      	lsrs	r0, r0, #16
 8002588:	4770      	bx	lr
 800258a:	bf00      	nop

0800258c <USB_OTG_ReadDevOutEP_itr>:
* @retval Device OUT EP Interrupt register
*/
uint32_t USB_OTG_ReadDevOutEP_itr(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
  uint32_t v;
  v  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[epnum]->DOEPINT);
 800258c:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOEPMSK);
 8002590:	6902      	ldr	r2, [r0, #16]
* @retval Device OUT EP Interrupt register
*/
uint32_t USB_OTG_ReadDevOutEP_itr(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
  uint32_t v;
  v  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[epnum]->DOEPINT);
 8002592:	f8dc 1054 	ldr.w	r1, [ip, #84]	; 0x54
 8002596:	688b      	ldr	r3, [r1, #8]
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOEPMSK);
 8002598:	6950      	ldr	r0, [r2, #20]
  return v;
}
 800259a:	4018      	ands	r0, r3
 800259c:	4770      	bx	lr
 800259e:	bf00      	nop

080025a0 <USB_OTG_ReadDevAllInEPItr>:
* @retval int status register
*/
uint32_t USB_OTG_ReadDevAllInEPItr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v;
  v = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
 80025a0:	6902      	ldr	r2, [r0, #16]
 80025a2:	6991      	ldr	r1, [r2, #24]
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
 80025a4:	69d3      	ldr	r3, [r2, #28]
 80025a6:	ea01 0003 	and.w	r0, r1, r3
  return (v & 0xffff);
}
 80025aa:	b280      	uxth	r0, r0
 80025ac:	4770      	bx	lr
 80025ae:	bf00      	nop

080025b0 <USB_OTG_EP0_OutStart>:
* @brief  configures EPO to receive SETUP packets
* @param  None
* @retval : None
*/
void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
{
 80025b0:	b082      	sub	sp, #8
  USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
  doeptsize0.d32 = 0;
  doeptsize0.b.supcnt = 3;
  doeptsize0.b.pktcnt = 1;
 80025b2:	2201      	movs	r2, #1
* @retval : None
*/
void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
  doeptsize0.d32 = 0;
 80025b4:	2300      	movs	r3, #0
  doeptsize0.b.supcnt = 3;
  doeptsize0.b.pktcnt = 1;
 80025b6:	2100      	movs	r1, #0
* @retval : None
*/
void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
  doeptsize0.d32 = 0;
 80025b8:	9300      	str	r3, [sp, #0]
  doeptsize0.b.supcnt = 3;
  doeptsize0.b.pktcnt = 1;
 80025ba:	f362 01c4 	bfi	r1, r2, #3, #2
  doeptsize0.b.xfersize = 8 * 3;
 80025be:	2318      	movs	r3, #24
*/
void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
  doeptsize0.d32 = 0;
  doeptsize0.b.supcnt = 3;
 80025c0:	22c0      	movs	r2, #192	; 0xc0
 80025c2:	f88d 2003 	strb.w	r2, [sp, #3]
  doeptsize0.b.pktcnt = 1;
 80025c6:	f88d 1002 	strb.w	r1, [sp, #2]
  doeptsize0.b.xfersize = 8 * 3;
 80025ca:	f88d 3000 	strb.w	r3, [sp]
  USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPTSIZ, doeptsize0.d32 );
 80025ce:	6d43      	ldr	r3, [r0, #84]	; 0x54
 80025d0:	9900      	ldr	r1, [sp, #0]
 80025d2:	6119      	str	r1, [r3, #16]
  
  if (pdev->cfg.dma_enable == 1)
 80025d4:	78c2      	ldrb	r2, [r0, #3]
 80025d6:	2a01      	cmp	r2, #1
 80025d8:	d106      	bne.n	80025e8 <USB_OTG_EP0_OutStart+0x38>
  {
    USB_OTG_DEPCTL_TypeDef  doepctl;
    doepctl.d32 = 0;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPDMA, 
 80025da:	f500 61b9 	add.w	r1, r0, #1480	; 0x5c8
 80025de:	6159      	str	r1, [r3, #20]
    
    /* EP enable */
    doepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[0]->DOEPCTL);
    doepctl.b.epena = 1;
    doepctl.d32 = 0x80008000;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPCTL, doepctl.d32);
 80025e0:	f04f 2080 	mov.w	r0, #2147516416	; 0x80008000
    doepctl.d32 = 0;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPDMA, 
                        (uint32_t)&pdev->dev.setup_packet);
    
    /* EP enable */
    doepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[0]->DOEPCTL);
 80025e4:	681a      	ldr	r2, [r3, #0]
    doepctl.b.epena = 1;
    doepctl.d32 = 0x80008000;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPCTL, doepctl.d32);
 80025e6:	6018      	str	r0, [r3, #0]
  }
}
 80025e8:	b002      	add	sp, #8
 80025ea:	4770      	bx	lr

080025ec <USB_OTG_ActiveRemoteWakeup>:
  
  USB_OTG_DCTL_TypeDef     dctl;
  USB_OTG_DSTS_TypeDef     dsts;
  USB_OTG_PCGCCTL_TypeDef  power;  
  
  if (pdev->dev.DevRemoteWakeup) 
 80025ec:	f8d0 3114 	ldr.w	r3, [r0, #276]	; 0x114
* @brief  USB_OTG_RemoteWakeup : active remote wakeup signalling
* @param  None
* @retval : None
*/
void USB_OTG_ActiveRemoteWakeup(USB_OTG_CORE_HANDLE *pdev)
{
 80025f0:	b510      	push	{r4, lr}
 80025f2:	4604      	mov	r4, r0
  
  USB_OTG_DCTL_TypeDef     dctl;
  USB_OTG_DSTS_TypeDef     dsts;
  USB_OTG_PCGCCTL_TypeDef  power;  
  
  if (pdev->dev.DevRemoteWakeup) 
 80025f4:	b1db      	cbz	r3, 800262e <USB_OTG_ActiveRemoteWakeup+0x42>
  {
    dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 80025f6:	6903      	ldr	r3, [r0, #16]
 80025f8:	689a      	ldr	r2, [r3, #8]
    if(dsts.b.suspsts == 1)
 80025fa:	f012 0f01 	tst.w	r2, #1
 80025fe:	d016      	beq.n	800262e <USB_OTG_ActiveRemoteWakeup+0x42>
    {
      if(pdev->cfg.low_power)
 8002600:	7a81      	ldrb	r1, [r0, #10]
 8002602:	b141      	cbz	r1, 8002616 <USB_OTG_ActiveRemoteWakeup+0x2a>
      {
        /* un-gate USB Core clock */
        power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
 8002604:	f8d0 210c 	ldr.w	r2, [r0, #268]	; 0x10c
        power.b.gatehclk = 0;
        power.b.stoppclk = 0;
        USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 8002608:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
    {
      if(pdev->cfg.low_power)
      {
        /* un-gate USB Core clock */
        power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
        power.b.gatehclk = 0;
 800260c:	f36f 0241 	bfc	r2, #1, #1
        power.b.stoppclk = 0;
 8002610:	f36f 0200 	bfc	r2, #0, #1
        USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 8002614:	6002      	str	r2, [r0, #0]
      }   
      /* active Remote wakeup signaling */
      dctl.d32 = 0;
      dctl.b.rmtwkupsig = 1;
      USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, 0, dctl.d32);
 8002616:	6859      	ldr	r1, [r3, #4]
 8002618:	f041 0201 	orr.w	r2, r1, #1
 800261c:	605a      	str	r2, [r3, #4]
      USB_OTG_BSP_mDelay(5);
 800261e:	2005      	movs	r0, #5
 8002620:	f001 f991 	bl	8003946 <USB_OTG_BSP_mDelay>
      USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
 8002624:	6923      	ldr	r3, [r4, #16]
 8002626:	6858      	ldr	r0, [r3, #4]
 8002628:	f020 0101 	bic.w	r1, r0, #1
 800262c:	6059      	str	r1, [r3, #4]
 800262e:	bd10      	pop	{r4, pc}

08002630 <USB_OTG_UngateClock>:
* @param  None
* @retval : None
*/
void USB_OTG_UngateClock(USB_OTG_CORE_HANDLE *pdev)
{
  if(pdev->cfg.low_power)
 8002630:	7a83      	ldrb	r3, [r0, #10]
 8002632:	b16b      	cbz	r3, 8002650 <USB_OTG_UngateClock+0x20>
  {
    
    USB_OTG_DSTS_TypeDef     dsts;
    USB_OTG_PCGCCTL_TypeDef  power; 
    
    dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8002634:	6902      	ldr	r2, [r0, #16]
 8002636:	6891      	ldr	r1, [r2, #8]
    
    if(dsts.b.suspsts == 1)
 8002638:	f011 0f01 	tst.w	r1, #1
 800263c:	d008      	beq.n	8002650 <USB_OTG_UngateClock+0x20>
    {
      /* un-gate USB Core clock */
      power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
 800263e:	f8d0 310c 	ldr.w	r3, [r0, #268]	; 0x10c
      power.b.gatehclk = 0;
      power.b.stoppclk = 0;
      USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 8002642:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
    
    if(dsts.b.suspsts == 1)
    {
      /* un-gate USB Core clock */
      power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
      power.b.gatehclk = 0;
 8002646:	f36f 0341 	bfc	r3, #1, #1
      power.b.stoppclk = 0;
 800264a:	f36f 0300 	bfc	r3, #0, #1
      USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 800264e:	6003      	str	r3, [r0, #0]
 8002650:	4770      	bx	lr
 8002652:	bf00      	nop

08002654 <USB_OTG_StopDevice>:
* @brief  Stop the device and clean up fifo's
* @param  None
* @retval : None
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
{
 8002654:	b570      	push	{r4, r5, r6, lr}
  uint32_t i;
  
  pdev->dev.device_status = 1;
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002656:	7843      	ldrb	r3, [r0, #1]
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t i;
  
  pdev->dev.device_status = 1;
 8002658:	2201      	movs	r2, #1
* @brief  Stop the device and clean up fifo's
* @param  None
* @retval : None
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
{
 800265a:	4604      	mov	r4, r0
  uint32_t i;
  
  pdev->dev.device_status = 1;
 800265c:	f880 2112 	strb.w	r2, [r0, #274]	; 0x112
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002660:	b163      	cbz	r3, 800267c <USB_OTG_StopDevice+0x28>
/**
* @brief  Stop the device and clean up fifo's
* @param  None
* @retval : None
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
 8002662:	f100 0214 	add.w	r2, r0, #20
{
  uint32_t i;
  
  pdev->dev.device_status = 1;
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002666:	2300      	movs	r3, #0
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 8002668:	21ff      	movs	r1, #255	; 0xff
 800266a:	f852 5f04 	ldr.w	r5, [r2, #4]!
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 800266e:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
  
  pdev->dev.device_status = 1;
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 8002670:	60a9      	str	r1, [r5, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 8002672:	6081      	str	r1, [r0, #8]
{
  uint32_t i;
  
  pdev->dev.device_status = 1;
    
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002674:	7860      	ldrb	r0, [r4, #1]
 8002676:	3301      	adds	r3, #1
 8002678:	4298      	cmp	r0, r3
 800267a:	d8f6      	bhi.n	800266a <USB_OTG_StopDevice+0x16>
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }

  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 800267c:	6923      	ldr	r3, [r4, #16]
 800267e:	2200      	movs	r2, #0
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
 8002680:	f04f 31ff 	mov.w	r1, #4294967295
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }

  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 8002684:	611a      	str	r2, [r3, #16]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
 8002686:	4620      	mov	r0, r4
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }

  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
 8002688:	615a      	str	r2, [r3, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
 800268a:	61da      	str	r2, [r3, #28]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
 800268c:	6199      	str	r1, [r3, #24]
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
 800268e:	f7ff fc55 	bl	8001f3c <USB_OTG_FlushRxFifo>
  USB_OTG_FlushTxFifo(pdev ,  0x10 );  
 8002692:	4620      	mov	r0, r4
 8002694:	2110      	movs	r1, #16
}
 8002696:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
  USB_OTG_FlushTxFifo(pdev ,  0x10 );  
 800269a:	e425      	b.n	8001ee8 <USB_OTG_FlushTxFifo>

0800269c <USB_OTG_GetEPStatus>:
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  uint32_t Status = 0;  
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
 800269c:	784b      	ldrb	r3, [r1, #1]
 800269e:	2b01      	cmp	r3, #1
 80026a0:	d01a      	beq.n	80026d8 <USB_OTG_GetEPStatus+0x3c>
      Status = USB_OTG_EP_TX_VALID;     

  }
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 80026a2:	780b      	ldrb	r3, [r1, #0]
 80026a4:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 80026a8:	6d42      	ldr	r2, [r0, #84]	; 0x54
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 80026aa:	6811      	ldr	r1, [r2, #0]
    if (depctl.b.stall == 1)  
 80026ac:	f3c1 4007 	ubfx	r0, r1, #16, #8
 80026b0:	f000 0c20 	and.w	ip, r0, #32
 80026b4:	fa5f f38c 	uxtb.w	r3, ip
 80026b8:	b95b      	cbnz	r3, 80026d2 <USB_OTG_GetEPStatus+0x36>
      Status = USB_OTG_EP_RX_STALL;
    else if (depctl.b.naksts == 1)
 80026ba:	f000 0102 	and.w	r1, r0, #2
 80026be:	fa5f fc81 	uxtb.w	ip, r1
      Status = USB_OTG_EP_RX_NAK;
 80026c2:	f1bc 0f00 	cmp.w	ip, #0
 80026c6:	bf0c      	ite	eq
 80026c8:	f44f 5040 	moveq.w	r0, #12288	; 0x3000
 80026cc:	f44f 5000 	movne.w	r0, #8192	; 0x2000
 80026d0:	4770      	bx	lr
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
    if (depctl.b.stall == 1)  
      Status = USB_OTG_EP_RX_STALL;
 80026d2:	f44f 5080 	mov.w	r0, #4096	; 0x1000
      Status = USB_OTG_EP_RX_VALID; 
  } 
  
  /* Return the current status */
  return Status;
}
 80026d6:	4770      	bx	lr
  uint32_t Status = 0;  
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 80026d8:	7809      	ldrb	r1, [r1, #0]
 80026da:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
 80026de:	f8dc 3018 	ldr.w	r3, [ip, #24]
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 80026e2:	6818      	ldr	r0, [r3, #0]
    
    if (depctl.b.stall == 1)  
 80026e4:	f3c0 4007 	ubfx	r0, r0, #16, #8
 80026e8:	f000 0220 	and.w	r2, r0, #32
 80026ec:	b2d1      	uxtb	r1, r2
 80026ee:	b939      	cbnz	r1, 8002700 <USB_OTG_GetEPStatus+0x64>
      Status = USB_OTG_EP_TX_STALL;
    else if (depctl.b.naksts == 1)
 80026f0:	f000 0002 	and.w	r0, r0, #2
 80026f4:	b2c2      	uxtb	r2, r0
      Status = USB_OTG_EP_TX_NAK;
 80026f6:	2a00      	cmp	r2, #0
 80026f8:	bf0c      	ite	eq
 80026fa:	2030      	moveq	r0, #48	; 0x30
 80026fc:	2020      	movne	r0, #32
 80026fe:	4770      	bx	lr
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
    
    if (depctl.b.stall == 1)  
      Status = USB_OTG_EP_TX_STALL;
 8002700:	2010      	movs	r0, #16
 8002702:	4770      	bx	lr

08002704 <USB_OTG_SetEPStatus>:
*         Status : new Status
*         ep : EP structure
* @retval : None
*/
void USB_OTG_SetEPStatus (USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep , uint32_t Status)
{
 8002704:	b470      	push	{r4, r5, r6}
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;

  /* Process for IN endpoint */
  if (ep->is_in == 1)
 8002706:	784d      	ldrb	r5, [r1, #1]
 8002708:	2d01      	cmp	r5, #1
 800270a:	d016      	beq.n	800273a <USB_OTG_SetEPStatus+0x36>
    else if (Status == USB_OTG_EP_TX_DIS)
      depctl.b.usbactep = 0;
  } 
  else /* Process for OUT endpoint */
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 800270c:	f891 c000 	ldrb.w	ip, [r1]
 8002710:	eb00 068c 	add.w	r6, r0, ip, lsl #2
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);    
    
    if (Status == USB_OTG_EP_RX_STALL)  {
 8002714:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    else if (Status == USB_OTG_EP_TX_DIS)
      depctl.b.usbactep = 0;
  } 
  else /* Process for OUT endpoint */
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 8002718:	6d75      	ldr	r5, [r6, #84]	; 0x54
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);    
 800271a:	682c      	ldr	r4, [r5, #0]
 800271c:	4626      	mov	r6, r4
    
    if (Status == USB_OTG_EP_RX_STALL)  {
 800271e:	d019      	beq.n	8002754 <USB_OTG_SetEPStatus+0x50>
      depctl.b.stall = 1;
    }
    else if (Status == USB_OTG_EP_RX_NAK)
 8002720:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8002724:	d013      	beq.n	800274e <USB_OTG_SetEPStatus+0x4a>
      depctl.b.snak = 1;
    else if (Status == USB_OTG_EP_RX_VALID)
 8002726:	f5b2 5f40 	cmp.w	r2, #12288	; 0x3000
 800272a:	d018      	beq.n	800275e <USB_OTG_SetEPStatus+0x5a>
      }  
      depctl.b.cnak = 1;
      depctl.b.usbactep = 1;    
      depctl.b.epena = 1;
    }
    else if (Status == USB_OTG_EP_RX_DIS)
 800272c:	b912      	cbnz	r2, 8002734 <USB_OTG_SetEPStatus+0x30>
    {
      depctl.b.usbactep = 0;    
 800272e:	f362 36cf 	bfi	r6, r2, #15, #1
 8002732:	4634      	mov	r4, r6
    }
  }

  USB_OTG_WRITE_REG32(depctl_addr, depctl.d32); 
 8002734:	602c      	str	r4, [r5, #0]
}
 8002736:	bc70      	pop	{r4, r5, r6}
 8002738:	4770      	bx	lr
  depctl.d32 = 0;

  /* Process for IN endpoint */
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 800273a:	780b      	ldrb	r3, [r1, #0]
 800273c:	eb00 0483 	add.w	r4, r0, r3, lsl #2
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
    
    if (Status == USB_OTG_EP_TX_STALL)  
 8002740:	2a10      	cmp	r2, #16
  depctl.d32 = 0;

  /* Process for IN endpoint */
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 8002742:	69a5      	ldr	r5, [r4, #24]
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 8002744:	682c      	ldr	r4, [r5, #0]
 8002746:	4626      	mov	r6, r4
    
    if (Status == USB_OTG_EP_TX_STALL)  
 8002748:	d018      	beq.n	800277c <USB_OTG_SetEPStatus+0x78>
    {
      USB_OTG_EPSetStall(pdev, ep); return;
    }
    else if (Status == USB_OTG_EP_TX_NAK)
 800274a:	2a20      	cmp	r2, #32
 800274c:	d105      	bne.n	800275a <USB_OTG_SetEPStatus+0x56>
    
    if (Status == USB_OTG_EP_RX_STALL)  {
      depctl.b.stall = 1;
    }
    else if (Status == USB_OTG_EP_RX_NAK)
      depctl.b.snak = 1;
 800274e:	f044 6400 	orr.w	r4, r4, #134217728	; 0x8000000
 8002752:	e7ef      	b.n	8002734 <USB_OTG_SetEPStatus+0x30>
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);    
    
    if (Status == USB_OTG_EP_RX_STALL)  {
      depctl.b.stall = 1;
 8002754:	f444 1400 	orr.w	r4, r4, #2097152	; 0x200000
 8002758:	e7ec      	b.n	8002734 <USB_OTG_SetEPStatus+0x30>
    {
      USB_OTG_EPSetStall(pdev, ep); return;
    }
    else if (Status == USB_OTG_EP_TX_NAK)
      depctl.b.snak = 1;
    else if (Status == USB_OTG_EP_TX_VALID)
 800275a:	2a30      	cmp	r2, #48	; 0x30
 800275c:	d1e6      	bne.n	800272c <USB_OTG_SetEPStatus+0x28>
    }
    else if (Status == USB_OTG_EP_RX_NAK)
      depctl.b.snak = 1;
    else if (Status == USB_OTG_EP_RX_VALID)
    {
      if (depctl.b.stall == 1)
 800275e:	f3c4 4c07 	ubfx	ip, r4, #16, #8
 8002762:	f00c 0320 	and.w	r3, ip, #32
 8002766:	b2da      	uxtb	r2, r3
 8002768:	b922      	cbnz	r2, 8002774 <USB_OTG_SetEPStatus+0x70>
      {  
        ep->even_odd_frame = 0;
        USB_OTG_EPClearStall(pdev, ep);
        return;
      }  
      depctl.b.cnak = 1;
 800276a:	f044 6080 	orr.w	r0, r4, #67108864	; 0x4000000
      depctl.b.usbactep = 1;    
      depctl.b.epena = 1;
 800276e:	f040 2480 	orr.w	r4, r0, #2147516416	; 0x80008000
 8002772:	e7df      	b.n	8002734 <USB_OTG_SetEPStatus+0x30>
      depctl.b.snak = 1;
    else if (Status == USB_OTG_EP_RX_VALID)
    {
      if (depctl.b.stall == 1)
      {  
        ep->even_odd_frame = 0;
 8002774:	2200      	movs	r2, #0
 8002776:	714a      	strb	r2, [r1, #5]
      depctl.b.usbactep = 0;    
    }
  }

  USB_OTG_WRITE_REG32(depctl_addr, depctl.d32); 
}
 8002778:	bc70      	pop	{r4, r5, r6}
    else if (Status == USB_OTG_EP_RX_VALID)
    {
      if (depctl.b.stall == 1)
      {  
        ep->even_odd_frame = 0;
        USB_OTG_EPClearStall(pdev, ep);
 800277a:	e6e5      	b.n	8002548 <USB_OTG_EPClearStall>
      depctl.b.usbactep = 0;    
    }
  }

  USB_OTG_WRITE_REG32(depctl_addr, depctl.d32); 
}
 800277c:	bc70      	pop	{r4, r5, r6}
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
    
    if (Status == USB_OTG_EP_TX_STALL)  
    {
      USB_OTG_EPSetStall(pdev, ep); return;
 800277e:	e6c3      	b.n	8002508 <USB_OTG_EPSetStall>

08002780 <DCD_Init>:



void DCD_Init(USB_OTG_CORE_HANDLE *pdev , 
              USB_OTG_CORE_ID_TypeDef coreID)
{
 8002780:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002784:	4604      	mov	r4, r0
  uint32_t i;
  USB_OTG_EP *ep;
  
  USB_OTG_SelectCore (pdev , coreID);
 8002786:	f7ff fa3b 	bl	8001c00 <USB_OTG_SelectCore>
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 800278a:	7866      	ldrb	r6, [r4, #1]
  uint32_t i;
  USB_OTG_EP *ep;
  
  USB_OTG_SelectCore (pdev , coreID);
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
 800278c:	2701      	movs	r7, #1
  pdev->dev.device_address = 0;
 800278e:	2100      	movs	r1, #0
  uint32_t i;
  USB_OTG_EP *ep;
  
  USB_OTG_SelectCore (pdev , coreID);
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
 8002790:	f884 7112 	strb.w	r7, [r4, #274]	; 0x112
  pdev->dev.device_address = 0;
 8002794:	f884 1113 	strb.w	r1, [r4, #275]	; 0x113
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002798:	2e00      	cmp	r6, #0
 800279a:	f000 809a 	beq.w	80028d2 <DCD_Init+0x152>
 800279e:	1e73      	subs	r3, r6, #1
    ep->is_in = 1;
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 80027a0:	f04f 0e40 	mov.w	lr, #64	; 0x40
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80027a4:	42b7      	cmp	r7, r6
 80027a6:	ea03 0207 	and.w	r2, r3, r7
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
 80027aa:	f884 7119 	strb.w	r7, [r4, #281]	; 0x119
    ep->num = i;
 80027ae:	f884 1118 	strb.w	r1, [r4, #280]	; 0x118
    ep->tx_fifo_num = i;
 80027b2:	f8a4 111e 	strh.w	r1, [r4, #286]	; 0x11e
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 80027b6:	f884 111b 	strb.w	r1, [r4, #283]	; 0x11b
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 80027ba:	f8c4 e120 	str.w	lr, [r4, #288]	; 0x120
    ep->xfer_buff = 0;
 80027be:	f8c4 1124 	str.w	r1, [r4, #292]	; 0x124
    ep->xfer_len = 0;
 80027c2:	f8c4 112c 	str.w	r1, [r4, #300]	; 0x12c
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80027c6:	4638      	mov	r0, r7
 80027c8:	f104 0328 	add.w	r3, r4, #40	; 0x28
 80027cc:	d234      	bcs.n	8002838 <DCD_Init+0xb8>
 80027ce:	b192      	cbz	r2, 80027f6 <DCD_Init+0x76>
 80027d0:	2002      	movs	r0, #2
 80027d2:	42b0      	cmp	r0, r6
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
 80027d4:	f883 7119 	strb.w	r7, [r3, #281]	; 0x119
    ep->num = i;
 80027d8:	f883 7118 	strb.w	r7, [r3, #280]	; 0x118
    ep->tx_fifo_num = i;
 80027dc:	f8a3 711e 	strh.w	r7, [r3, #286]	; 0x11e
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 80027e0:	f883 111b 	strb.w	r1, [r3, #283]	; 0x11b
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 80027e4:	f8c3 e120 	str.w	lr, [r3, #288]	; 0x120
    ep->xfer_buff = 0;
 80027e8:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
    ep->xfer_len = 0;
 80027ec:	f8c3 112c 	str.w	r1, [r3, #300]	; 0x12c
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80027f0:	f104 0350 	add.w	r3, r4, #80	; 0x50
 80027f4:	d220      	bcs.n	8002838 <DCD_Init+0xb8>
 80027f6:	1c45      	adds	r5, r0, #1
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
    ep->num = i;
 80027f8:	f883 0118 	strb.w	r0, [r3, #280]	; 0x118
    ep->tx_fifo_num = i;
 80027fc:	f8a3 011e 	strh.w	r0, [r3, #286]	; 0x11e
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002800:	3002      	adds	r0, #2
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
 8002802:	f883 7119 	strb.w	r7, [r3, #281]	; 0x119
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 8002806:	f883 111b 	strb.w	r1, [r3, #283]	; 0x11b
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 800280a:	f8c3 e120 	str.w	lr, [r3, #288]	; 0x120
    ep->xfer_buff = 0;
 800280e:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
    ep->xfer_len = 0;
 8002812:	f8c3 112c 	str.w	r1, [r3, #300]	; 0x12c
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
 8002816:	f883 7141 	strb.w	r7, [r3, #321]	; 0x141
    ep->num = i;
 800281a:	f883 5140 	strb.w	r5, [r3, #320]	; 0x140
    ep->tx_fifo_num = i;
 800281e:	f8a3 5146 	strh.w	r5, [r3, #326]	; 0x146
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 8002822:	f883 1143 	strb.w	r1, [r3, #323]	; 0x143
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 8002826:	f8c3 e148 	str.w	lr, [r3, #328]	; 0x148
    ep->xfer_buff = 0;
 800282a:	f8c3 114c 	str.w	r1, [r3, #332]	; 0x14c
    ep->xfer_len = 0;
 800282e:	f8c3 1154 	str.w	r1, [r3, #340]	; 0x154
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002832:	3350      	adds	r3, #80	; 0x50
 8002834:	42b0      	cmp	r0, r6
 8002836:	d3de      	bcc.n	80027f6 <DCD_Init+0x76>
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8002838:	2001      	movs	r0, #1
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 800283a:	2200      	movs	r2, #0
    ep->is_in = 0;
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 800283c:	2740      	movs	r7, #64	; 0x40
 800283e:	1e71      	subs	r1, r6, #1
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8002840:	42b0      	cmp	r0, r6
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 8002842:	f884 2371 	strb.w	r2, [r4, #881]	; 0x371
    ep->num = i;
 8002846:	f884 2370 	strb.w	r2, [r4, #880]	; 0x370
    ep->tx_fifo_num = i;
 800284a:	f8a4 2376 	strh.w	r2, [r4, #886]	; 0x376
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
 800284e:	f884 2373 	strb.w	r2, [r4, #883]	; 0x373
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 8002852:	f8c4 7378 	str.w	r7, [r4, #888]	; 0x378
    ep->xfer_buff = 0;
 8002856:	f8c4 237c 	str.w	r2, [r4, #892]	; 0x37c
    ep->xfer_len = 0;
 800285a:	f8c4 2384 	str.w	r2, [r4, #900]	; 0x384
 800285e:	ea01 0100 	and.w	r1, r1, r0
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8002862:	f104 0328 	add.w	r3, r4, #40	; 0x28
 8002866:	d234      	bcs.n	80028d2 <DCD_Init+0x152>
 8002868:	b191      	cbz	r1, 8002890 <DCD_Init+0x110>
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
    ep->num = i;
 800286a:	f883 0370 	strb.w	r0, [r3, #880]	; 0x370
    ep->tx_fifo_num = i;
 800286e:	f8a3 0376 	strh.w	r0, [r3, #886]	; 0x376
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8002872:	2002      	movs	r0, #2
 8002874:	42b0      	cmp	r0, r6
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 8002876:	f883 2371 	strb.w	r2, [r3, #881]	; 0x371
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
 800287a:	f883 2373 	strb.w	r2, [r3, #883]	; 0x373
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 800287e:	f8c3 7378 	str.w	r7, [r3, #888]	; 0x378
    ep->xfer_buff = 0;
 8002882:	f8c3 237c 	str.w	r2, [r3, #892]	; 0x37c
    ep->xfer_len = 0;
 8002886:	f8c3 2384 	str.w	r2, [r3, #900]	; 0x384
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 800288a:	f104 0350 	add.w	r3, r4, #80	; 0x50
 800288e:	d220      	bcs.n	80028d2 <DCD_Init+0x152>
 8002890:	1c45      	adds	r5, r0, #1
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
    ep->num = i;
 8002892:	f883 0370 	strb.w	r0, [r3, #880]	; 0x370
    ep->tx_fifo_num = i;
 8002896:	f8a3 0376 	strh.w	r0, [r3, #886]	; 0x376
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 800289a:	3002      	adds	r0, #2
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 800289c:	f883 2371 	strb.w	r2, [r3, #881]	; 0x371
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
 80028a0:	f883 2373 	strb.w	r2, [r3, #883]	; 0x373
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 80028a4:	f8c3 7378 	str.w	r7, [r3, #888]	; 0x378
    ep->xfer_buff = 0;
 80028a8:	f8c3 237c 	str.w	r2, [r3, #892]	; 0x37c
    ep->xfer_len = 0;
 80028ac:	f8c3 2384 	str.w	r2, [r3, #900]	; 0x384
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 80028b0:	f883 2399 	strb.w	r2, [r3, #921]	; 0x399
    ep->num = i;
 80028b4:	f883 5398 	strb.w	r5, [r3, #920]	; 0x398
    ep->tx_fifo_num = i;
 80028b8:	f8a3 539e 	strh.w	r5, [r3, #926]	; 0x39e
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
 80028bc:	f883 239b 	strb.w	r2, [r3, #923]	; 0x39b
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 80028c0:	f8c3 73a0 	str.w	r7, [r3, #928]	; 0x3a0
    ep->xfer_buff = 0;
 80028c4:	f8c3 23a4 	str.w	r2, [r3, #932]	; 0x3a4
    ep->xfer_len = 0;
 80028c8:	f8c3 23ac 	str.w	r2, [r3, #940]	; 0x3ac
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 80028cc:	3350      	adds	r3, #80	; 0x50
 80028ce:	42b0      	cmp	r0, r6
 80028d0:	d3de      	bcc.n	8002890 <DCD_Init+0x110>
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  USB_OTG_DisableGlobalInt(pdev);
 80028d2:	4620      	mov	r0, r4
 80028d4:	f7ff fb00 	bl	8001ed8 <USB_OTG_DisableGlobalInt>
  
  /*Init the Core (common init.) */
  USB_OTG_CoreInit(pdev);
 80028d8:	4620      	mov	r0, r4
 80028da:	f7ff fa73 	bl	8001dc4 <USB_OTG_CoreInit>


  /* Force Device Mode*/
  USB_OTG_SetCurrentMode(pdev, DEVICE_MODE);
 80028de:	2100      	movs	r1, #0
 80028e0:	4620      	mov	r0, r4
 80028e2:	f7ff fb51 	bl	8001f88 <USB_OTG_SetCurrentMode>
  
  /* Init Device */
  USB_OTG_CoreInitDev(pdev);
 80028e6:	4620      	mov	r0, r4
 80028e8:	f7ff fbac 	bl	8002044 <USB_OTG_CoreInitDev>
  
  
  /* Enable USB Global interrupt */
  USB_OTG_EnableGlobalInt(pdev);
 80028ec:	4620      	mov	r0, r4
}
 80028ee:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  /* Init Device */
  USB_OTG_CoreInitDev(pdev);
  
  
  /* Enable USB Global interrupt */
  USB_OTG_EnableGlobalInt(pdev);
 80028f2:	f7ff bae9 	b.w	8001ec8 <USB_OTG_EnableGlobalInt>
 80028f6:	bf00      	nop

080028f8 <DCD_EP_Open>:
*/
uint32_t DCD_EP_Open(USB_OTG_CORE_HANDLE *pdev , 
                     uint8_t ep_addr,
                     uint16_t ep_mps,
                     uint8_t ep_type)
{
 80028f8:	b538      	push	{r3, r4, r5, lr}
  USB_OTG_EP *ep;
  
  if ((ep_addr & 0x80) == 0x80)
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 80028fa:	f001 057f 	and.w	r5, r1, #127	; 0x7f
                     uint16_t ep_mps,
                     uint8_t ep_type)
{
  USB_OTG_EP *ep;
  
  if ((ep_addr & 0x80) == 0x80)
 80028fe:	b2cc      	uxtb	r4, r1
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002900:	eb05 0185 	add.w	r1, r5, r5, lsl #2
 8002904:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
                     uint16_t ep_mps,
                     uint8_t ep_type)
{
  USB_OTG_EP *ep;
  
  if ((ep_addr & 0x80) == 0x80)
 8002908:	f014 0f80 	tst.w	r4, #128	; 0x80
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 800290c:	bf14      	ite	ne
 800290e:	f501 718c 	addne.w	r1, r1, #280	; 0x118
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8002912:	f501 715c 	addeq.w	r1, r1, #880	; 0x370
  }
  ep->num   = ep_addr & 0x7F;
 8002916:	b2ed      	uxtb	r5, r5
  
  ep->is_in = (0x80 & ep_addr) != 0;
 8002918:	09e4      	lsrs	r4, r4, #7
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
 800291a:	700d      	strb	r5, [r1, #0]
  
  ep->is_in = (0x80 & ep_addr) != 0;
 800291c:	704c      	strb	r4, [r1, #1]
  ep->maxpacket = ep_mps;
 800291e:	608a      	str	r2, [r1, #8]
  ep->type = ep_type;
 8002920:	70cb      	strb	r3, [r1, #3]
  if (ep->is_in)
 8002922:	b104      	cbz	r4, 8002926 <DCD_EP_Open+0x2e>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 8002924:	80cd      	strh	r5, [r1, #6]
  }
  /* Set initial data PID. */
  if (ep_type == USB_OTG_EP_BULK )
 8002926:	2b02      	cmp	r3, #2
 8002928:	d101      	bne.n	800292e <DCD_EP_Open+0x36>
  {
    ep->data_pid_start = 0;
 800292a:	2300      	movs	r3, #0
 800292c:	710b      	strb	r3, [r1, #4]
  }
  USB_OTG_EPActivate(pdev , ep );
 800292e:	f7ff fc3b 	bl	80021a8 <USB_OTG_EPActivate>
  return 0;
}
 8002932:	2000      	movs	r0, #0
 8002934:	bd38      	pop	{r3, r4, r5, pc}
 8002936:	bf00      	nop

08002938 <DCD_EP_Close>:
{
  USB_OTG_EP *ep;
  
  if ((ep_addr&0x80) == 0x80)
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002938:	f001 027f 	and.w	r2, r1, #127	; 0x7f
* @param pdev: device instance
* @param ep_addr: endpoint address
* @retval : status
*/
uint32_t DCD_EP_Close(USB_OTG_CORE_HANDLE *pdev , uint8_t  ep_addr)
{
 800293c:	b508      	push	{r3, lr}
  USB_OTG_EP *ep;
  
  if ((ep_addr&0x80) == 0x80)
 800293e:	b2cb      	uxtb	r3, r1
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002940:	eb02 0182 	add.w	r1, r2, r2, lsl #2
*/
uint32_t DCD_EP_Close(USB_OTG_CORE_HANDLE *pdev , uint8_t  ep_addr)
{
  USB_OTG_EP *ep;
  
  if ((ep_addr&0x80) == 0x80)
 8002944:	f013 0f80 	tst.w	r3, #128	; 0x80
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8002948:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
 800294c:	bf14      	ite	ne
 800294e:	f501 718c 	addne.w	r1, r1, #280	; 0x118
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8002952:	f501 715c 	addeq.w	r1, r1, #880	; 0x370
  }
  ep->num   = ep_addr & 0x7F;
  ep->is_in = (0x80 & ep_addr) != 0;
 8002956:	09db      	lsrs	r3, r3, #7
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
 8002958:	700a      	strb	r2, [r1, #0]
  ep->is_in = (0x80 & ep_addr) != 0;
 800295a:	704b      	strb	r3, [r1, #1]
  USB_OTG_EPDeactivate(pdev , ep );
 800295c:	f7ff fc5a 	bl	8002214 <USB_OTG_EPDeactivate>
  return 0;
}
 8002960:	2000      	movs	r0, #0
 8002962:	bd08      	pop	{r3, pc}

08002964 <DCD_EP_PrepareRx>:
                            uint8_t *pbuf,                        
                            uint16_t  buf_len)
{
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8002964:	f001 017f 	and.w	r1, r1, #127	; 0x7f
*/
uint32_t   DCD_EP_PrepareRx( USB_OTG_CORE_HANDLE *pdev,
                            uint8_t   ep_addr,
                            uint8_t *pbuf,                        
                            uint16_t  buf_len)
{
 8002968:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 800296a:	eb01 0581 	add.w	r5, r1, r1, lsl #2
 800296e:	00ec      	lsls	r4, r5, #3
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
 8002970:	1905      	adds	r5, r0, r4
  ep->xfer_len = buf_len;
  ep->xfer_count = 0;
 8002972:	2700      	movs	r7, #0
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
 8002974:	b2ce      	uxtb	r6, r1
 8002976:	f885 6370 	strb.w	r6, [r5, #880]	; 0x370
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
  ep->xfer_len = buf_len;
  ep->xfer_count = 0;
  ep->is_in = 0;
 800297a:	f885 7371 	strb.w	r7, [r5, #881]	; 0x371
  ep->num = ep_addr & 0x7F;
  
  if (pdev->cfg.dma_enable == 1)
 800297e:	f890 e003 	ldrb.w	lr, [r0, #3]
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
  ep->xfer_len = buf_len;
 8002982:	f8c5 3384 	str.w	r3, [r5, #900]	; 0x384
  ep->xfer_count = 0;
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
  
  if (pdev->cfg.dma_enable == 1)
 8002986:	f1be 0f01 	cmp.w	lr, #1
                            uint8_t *pbuf,                        
                            uint16_t  buf_len)
{
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 800298a:	f504 745c 	add.w	r4, r4, #880	; 0x370
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
  
  if (pdev->cfg.dma_enable == 1)
  {
    ep->dma_addr = (uint32_t)pbuf;  
 800298e:	bf08      	it	eq
 8002990:	b2f6      	uxtbeq	r6, r6
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
 8002992:	f8c5 237c 	str.w	r2, [r5, #892]	; 0x37c
  ep->xfer_len = buf_len;
  ep->xfer_count = 0;
 8002996:	f8c5 7388 	str.w	r7, [r5, #904]	; 0x388
                            uint8_t *pbuf,                        
                            uint16_t  buf_len)
{
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 800299a:	eb00 0104 	add.w	r1, r0, r4
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
  
  if (pdev->cfg.dma_enable == 1)
  {
    ep->dma_addr = (uint32_t)pbuf;  
 800299e:	bf08      	it	eq
 80029a0:	f8c5 2380 	streq.w	r2, [r5, #896]	; 0x380
  }
  
  if ( ep->num == 0 )
 80029a4:	b11e      	cbz	r6, 80029ae <DCD_EP_PrepareRx+0x4a>
  {
    USB_OTG_EP0StartXfer(pdev , ep);
  }
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
 80029a6:	f7ff fc59 	bl	800225c <USB_OTG_EPStartXfer>
  }
  return 0;
}
 80029aa:	2000      	movs	r0, #0
 80029ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ep->dma_addr = (uint32_t)pbuf;  
  }
  
  if ( ep->num == 0 )
  {
    USB_OTG_EP0StartXfer(pdev , ep);
 80029ae:	f7ff fd21 	bl	80023f4 <USB_OTG_EP0StartXfer>
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
  }
  return 0;
}
 80029b2:	2000      	movs	r0, #0
 80029b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80029b6:	bf00      	nop

080029b8 <DCD_EP_Tx>:
*/
uint32_t  DCD_EP_Tx ( USB_OTG_CORE_HANDLE *pdev,
                     uint8_t   ep_addr,
                     uint8_t   *pbuf,
                     uint32_t   buf_len)
{
 80029b8:	b570      	push	{r4, r5, r6, lr}
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 80029ba:	f001 057f 	and.w	r5, r1, #127	; 0x7f
 80029be:	eb05 0485 	add.w	r4, r5, r5, lsl #2
 80029c2:	00e1      	lsls	r1, r4, #3
  
  /* Setup and start the Transfer */
  ep->is_in = 1;
 80029c4:	1844      	adds	r4, r0, r1
                     uint8_t   *pbuf,
                     uint32_t   buf_len)
{
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 80029c6:	f501 768c 	add.w	r6, r1, #280	; 0x118
 80029ca:	1981      	adds	r1, r0, r6
  
  /* Setup and start the Transfer */
  ep->is_in = 1;
  ep->num = ep_addr & 0x7F;  
  ep->xfer_buff = pbuf;
 80029cc:	f8c4 2124 	str.w	r2, [r4, #292]	; 0x124
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
  
  /* Setup and start the Transfer */
  ep->is_in = 1;
 80029d0:	2601      	movs	r6, #1
  ep->num = ep_addr & 0x7F;  
  ep->xfer_buff = pbuf;
  ep->dma_addr = (uint32_t)pbuf;  
 80029d2:	f8c4 2128 	str.w	r2, [r4, #296]	; 0x128
  ep->xfer_count = 0;
 80029d6:	2200      	movs	r2, #0
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
  
  /* Setup and start the Transfer */
  ep->is_in = 1;
 80029d8:	f884 6119 	strb.w	r6, [r4, #281]	; 0x119
  ep->num = ep_addr & 0x7F;  
 80029dc:	f884 5118 	strb.w	r5, [r4, #280]	; 0x118
  ep->xfer_buff = pbuf;
  ep->dma_addr = (uint32_t)pbuf;  
  ep->xfer_count = 0;
 80029e0:	f8c4 2130 	str.w	r2, [r4, #304]	; 0x130
  ep->xfer_len  = buf_len;
 80029e4:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
  
  if ( ep->num == 0 )
 80029e8:	b11d      	cbz	r5, 80029f2 <DCD_EP_Tx+0x3a>
  {
    USB_OTG_EP0StartXfer(pdev , ep);
  }
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
 80029ea:	f7ff fc37 	bl	800225c <USB_OTG_EPStartXfer>
  }
  return 0;
}
 80029ee:	2000      	movs	r0, #0
 80029f0:	bd70      	pop	{r4, r5, r6, pc}
  ep->xfer_count = 0;
  ep->xfer_len  = buf_len;
  
  if ( ep->num == 0 )
  {
    USB_OTG_EP0StartXfer(pdev , ep);
 80029f2:	f7ff fcff 	bl	80023f4 <USB_OTG_EP0StartXfer>
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
  }
  return 0;
}
 80029f6:	2000      	movs	r0, #0
 80029f8:	bd70      	pop	{r4, r5, r6, pc}
 80029fa:	bf00      	nop

080029fc <DCD_EP_Stall>:
* @retval : status
*/
uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 80029fc:	b2ca      	uxtb	r2, r1
 80029fe:	f012 0f80 	tst.w	r2, #128	; 0x80
* @param pdev: device instance
* @param epnum: endpoint address
* @retval : status
*/
uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
{
 8002a02:	b510      	push	{r4, lr}
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 8002a04:	d111      	bne.n	8002a2a <DCD_EP_Stall+0x2e>
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8002a06:	eb01 0e81 	add.w	lr, r1, r1, lsl #2
 8002a0a:	eb00 0cce 	add.w	ip, r0, lr, lsl #3
 8002a0e:	f50c 735c 	add.w	r3, ip, #880	; 0x370
 8002a12:	f001 017f 	and.w	r1, r1, #127	; 0x7f
  }

  ep->is_stall = 1;
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 8002a16:	09d2      	lsrs	r2, r2, #7
  else
  {
    ep = &pdev->dev.out_ep[epnum];
  }

  ep->is_stall = 1;
 8002a18:	2401      	movs	r4, #1
  ep->num   = epnum & 0x7F;
 8002a1a:	7019      	strb	r1, [r3, #0]
  else
  {
    ep = &pdev->dev.out_ep[epnum];
  }

  ep->is_stall = 1;
 8002a1c:	709c      	strb	r4, [r3, #2]
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 8002a1e:	705a      	strb	r2, [r3, #1]
  
  USB_OTG_EPSetStall(pdev , ep);
 8002a20:	4619      	mov	r1, r3
 8002a22:	f7ff fd71 	bl	8002508 <USB_OTG_EPSetStall>
  return (0);
}
 8002a26:	2000      	movs	r0, #0
 8002a28:	bd10      	pop	{r4, pc}
uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];
 8002a2a:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8002a2e:	eb01 0481 	add.w	r4, r1, r1, lsl #2
 8002a32:	eb00 03c4 	add.w	r3, r0, r4, lsl #3
 8002a36:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8002a3a:	e7ec      	b.n	8002a16 <DCD_EP_Stall+0x1a>

08002a3c <DCD_EP_ClrStall>:
* @retval : status
*/
uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 8002a3c:	b2ca      	uxtb	r2, r1
 8002a3e:	f012 0f80 	tst.w	r2, #128	; 0x80
* @param pdev: device instance
* @param epnum: endpoint address
* @retval : status
*/
uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
 8002a42:	b510      	push	{r4, lr}
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 8002a44:	d111      	bne.n	8002a6a <DCD_EP_ClrStall+0x2e>
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8002a46:	eb01 0e81 	add.w	lr, r1, r1, lsl #2
 8002a4a:	eb00 0cce 	add.w	ip, r0, lr, lsl #3
 8002a4e:	f50c 735c 	add.w	r3, ip, #880	; 0x370
 8002a52:	f001 017f 	and.w	r1, r1, #127	; 0x7f
  }
  
  ep->is_stall = 0;  
 8002a56:	2400      	movs	r4, #0
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 8002a58:	09d2      	lsrs	r2, r2, #7
  {
    ep = &pdev->dev.out_ep[epnum];
  }
  
  ep->is_stall = 0;  
  ep->num   = epnum & 0x7F;
 8002a5a:	7019      	strb	r1, [r3, #0]
  else
  {
    ep = &pdev->dev.out_ep[epnum];
  }
  
  ep->is_stall = 0;  
 8002a5c:	709c      	strb	r4, [r3, #2]
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 8002a5e:	705a      	strb	r2, [r3, #1]
  
  USB_OTG_EPClearStall(pdev , ep);
 8002a60:	4619      	mov	r1, r3
 8002a62:	f7ff fd71 	bl	8002548 <USB_OTG_EPClearStall>
  return (0);
}
 8002a66:	4620      	mov	r0, r4
 8002a68:	bd10      	pop	{r4, pc}
uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
 8002a6a:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8002a6e:	eb01 0481 	add.w	r4, r1, r1, lsl #2
 8002a72:	eb00 03c4 	add.w	r3, r0, r4, lsl #3
 8002a76:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8002a7a:	e7ec      	b.n	8002a56 <DCD_EP_ClrStall+0x1a>

08002a7c <DCD_EP_Flush>:
* @retval : status
*/
uint32_t  DCD_EP_Flush (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{

  if ((epnum & 0x80) == 0x80)
 8002a7c:	f011 0f80 	tst.w	r1, #128	; 0x80
* @param pdev: device instance
* @param epnum: endpoint address
* @retval : status
*/
uint32_t  DCD_EP_Flush (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
 8002a80:	b508      	push	{r3, lr}

  if ((epnum & 0x80) == 0x80)
 8002a82:	d103      	bne.n	8002a8c <DCD_EP_Flush+0x10>
  {
    USB_OTG_FlushTxFifo(pdev, epnum & 0x7F);
  }
  else
  {
    USB_OTG_FlushRxFifo(pdev);
 8002a84:	f7ff fa5a 	bl	8001f3c <USB_OTG_FlushRxFifo>
  }

  return (0);
}
 8002a88:	2000      	movs	r0, #0
 8002a8a:	bd08      	pop	{r3, pc}
uint32_t  DCD_EP_Flush (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{

  if ((epnum & 0x80) == 0x80)
  {
    USB_OTG_FlushTxFifo(pdev, epnum & 0x7F);
 8002a8c:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8002a90:	f7ff fa2a 	bl	8001ee8 <USB_OTG_FlushTxFifo>
  {
    USB_OTG_FlushRxFifo(pdev);
  }

  return (0);
}
 8002a94:	2000      	movs	r0, #0
 8002a96:	bd08      	pop	{r3, pc}

08002a98 <DCD_EP_SetAddress>:
void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
{
  USB_OTG_DCFG_TypeDef  dcfg;
  dcfg.d32 = 0;
  dcfg.b.devaddr = address;
  USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
 8002a98:	6903      	ldr	r3, [r0, #16]
* @retval : status
*/
void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
{
  USB_OTG_DCFG_TypeDef  dcfg;
  dcfg.d32 = 0;
 8002a9a:	2200      	movs	r2, #0
  dcfg.b.devaddr = address;
  USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
 8002a9c:	6818      	ldr	r0, [r3, #0]
*/
void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
{
  USB_OTG_DCFG_TypeDef  dcfg;
  dcfg.d32 = 0;
  dcfg.b.devaddr = address;
 8002a9e:	f361 120a 	bfi	r2, r1, #4, #7
  USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
 8002aa2:	4302      	orrs	r2, r0
 8002aa4:	601a      	str	r2, [r3, #0]
}
 8002aa6:	4770      	bx	lr

08002aa8 <DCD_DevConnect>:
*/
void  DCD_DevConnect (USB_OTG_CORE_HANDLE *pdev)
{
#ifndef USE_OTG_MODE
  USB_OTG_DCTL_TypeDef  dctl;
  dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 8002aa8:	6903      	ldr	r3, [r0, #16]
 8002aaa:	685a      	ldr	r2, [r3, #4]
  /* Connect device */
  dctl.b.sftdiscon  = 0;
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
  USB_OTG_BSP_mDelay(3);
 8002aac:	2003      	movs	r0, #3
{
#ifndef USE_OTG_MODE
  USB_OTG_DCTL_TypeDef  dctl;
  dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
  /* Connect device */
  dctl.b.sftdiscon  = 0;
 8002aae:	f36f 0241 	bfc	r2, #1, #1
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
 8002ab2:	605a      	str	r2, [r3, #4]
  USB_OTG_BSP_mDelay(3);
 8002ab4:	f000 bf47 	b.w	8003946 <USB_OTG_BSP_mDelay>

08002ab8 <DCD_DevDisconnect>:
*/
void  DCD_DevDisconnect (USB_OTG_CORE_HANDLE *pdev)
{
#ifndef USE_OTG_MODE
  USB_OTG_DCTL_TypeDef  dctl;
  dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 8002ab8:	6903      	ldr	r3, [r0, #16]
 8002aba:	6858      	ldr	r0, [r3, #4]
  /* Disconnect device for 3ms */
  dctl.b.sftdiscon  = 1;
 8002abc:	f040 0202 	orr.w	r2, r0, #2
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
  USB_OTG_BSP_mDelay(3);
 8002ac0:	2003      	movs	r0, #3
#ifndef USE_OTG_MODE
  USB_OTG_DCTL_TypeDef  dctl;
  dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
  /* Disconnect device for 3ms */
  dctl.b.sftdiscon  = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
 8002ac2:	605a      	str	r2, [r3, #4]
  USB_OTG_BSP_mDelay(3);
 8002ac4:	f000 bf3f 	b.w	8003946 <USB_OTG_BSP_mDelay>

08002ac8 <DCD_GetEPStatus>:
uint32_t DCD_GetEPStatus(USB_OTG_CORE_HANDLE *pdev ,uint8_t epnum)
{
  USB_OTG_EP *ep;
  uint32_t Status = 0;  
  
  if ((0x80 & epnum) == 0x80)
 8002ac8:	f011 0f80 	tst.w	r1, #128	; 0x80
 8002acc:	d107      	bne.n	8002ade <DCD_GetEPStatus+0x16>
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8002ace:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8002ad2:	eb00 0cc1 	add.w	ip, r0, r1, lsl #3
 8002ad6:	f50c 715c 	add.w	r1, ip, #880	; 0x370
  }
  
  Status = USB_OTG_GetEPStatus(pdev ,ep);
 8002ada:	f7ff bddf 	b.w	800269c <USB_OTG_GetEPStatus>
  USB_OTG_EP *ep;
  uint32_t Status = 0;  
  
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
 8002ade:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 8002ae2:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 8002ae6:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
 8002aea:	f501 718c 	add.w	r1, r1, #280	; 0x118
 8002aee:	e7f4      	b.n	8002ada <DCD_GetEPStatus+0x12>

08002af0 <DCD_SetEPStatus>:
*/
void DCD_SetEPStatus (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum , uint32_t Status)
{
  USB_OTG_EP *ep;
  
  if ((0x80 & epnum) == 0x80)
 8002af0:	f011 0f80 	tst.w	r1, #128	; 0x80
 8002af4:	d107      	bne.n	8002b06 <DCD_SetEPStatus+0x16>
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8002af6:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 8002afa:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
 8002afe:	f501 715c 	add.w	r1, r1, #880	; 0x370
  }
  
   USB_OTG_SetEPStatus(pdev ,ep , Status);
 8002b02:	f7ff bdff 	b.w	8002704 <USB_OTG_SetEPStatus>
{
  USB_OTG_EP *ep;
  
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
 8002b06:	f001 0c7f 	and.w	ip, r1, #127	; 0x7f
 8002b0a:	eb0c 038c 	add.w	r3, ip, ip, lsl #2
 8002b0e:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
 8002b12:	f501 718c 	add.w	r1, r1, #280	; 0x118
 8002b16:	e7f4      	b.n	8002b02 <DCD_SetEPStatus+0x12>

08002b18 <USBD_OTG_ISR_Handler>:
*         handles all USB Interrupts
* @param  pdev: device instance
* @retval status
*/
uint32_t USBD_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
{
 8002b18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002b1c:	b083      	sub	sp, #12
 8002b1e:	4606      	mov	r6, r0
  USB_OTG_GINTSTS_TypeDef  gintr_status;
  uint32_t retval = 0;
  
  if (USB_OTG_IsDeviceMode(pdev)) /* ensure that we are in device mode */
 8002b20:	f7ff fa52 	bl	8001fc8 <USB_OTG_IsDeviceMode>
 8002b24:	b910      	cbnz	r0, 8002b2c <USBD_OTG_ISR_Handler+0x14>
      retval |= DCD_OTG_ISR(pdev);
    }   
#endif    
  }
  return retval;
}
 8002b26:	b003      	add	sp, #12
 8002b28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  USB_OTG_GINTSTS_TypeDef  gintr_status;
  uint32_t retval = 0;
  
  if (USB_OTG_IsDeviceMode(pdev)) /* ensure that we are in device mode */
  {
    gintr_status.d32 = USB_OTG_ReadCoreItr(pdev);
 8002b2c:	4630      	mov	r0, r6
 8002b2e:	f7ff fa59 	bl	8001fe4 <USB_OTG_ReadCoreItr>
    if (!gintr_status.d32) /* avoid spurious interrupt */
 8002b32:	4681      	mov	r9, r0
 8002b34:	2800      	cmp	r0, #0
 8002b36:	d0f6      	beq.n	8002b26 <USBD_OTG_ISR_Handler+0xe>
    {
      return 0;
    }
    
    if (gintr_status.b.outepintr)
 8002b38:	f3c0 4107 	ubfx	r1, r0, #16, #8
 8002b3c:	f001 0008 	and.w	r0, r1, #8
 8002b40:	b2c0      	uxtb	r0, r0
 8002b42:	2800      	cmp	r0, #0
 8002b44:	f040 8118 	bne.w	8002d78 <USBD_OTG_ISR_Handler+0x260>
    {
      retval |= DCD_HandleOutEP_ISR(pdev);
    }    
    
    if (gintr_status.b.inepint)
 8002b48:	f3c9 4e07 	ubfx	lr, r9, #16, #8
 8002b4c:	f00e 0c04 	and.w	ip, lr, #4
 8002b50:	fa5f f38c 	uxtb.w	r3, ip
 8002b54:	2b00      	cmp	r3, #0
 8002b56:	d166      	bne.n	8002c26 <USBD_OTG_ISR_Handler+0x10e>
    {
      retval |= DCD_HandleInEP_ISR(pdev);
    }
    
    if (gintr_status.b.modemismatch)
 8002b58:	f009 0c02 	and.w	ip, r9, #2
 8002b5c:	fa5f f38c 	uxtb.w	r3, ip
 8002b60:	b113      	cbz	r3, 8002b68 <USBD_OTG_ISR_Handler+0x50>
      USB_OTG_GINTSTS_TypeDef  gintsts;
      
      /* Clear interrupt */
      gintsts.d32 = 0;
      gintsts.b.modemismatch = 1;
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002b62:	68f2      	ldr	r2, [r6, #12]
    {
      USB_OTG_GINTSTS_TypeDef  gintsts;
      
      /* Clear interrupt */
      gintsts.d32 = 0;
      gintsts.b.modemismatch = 1;
 8002b64:	2102      	movs	r1, #2
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002b66:	6151      	str	r1, [r2, #20]
    }
    
    if (gintr_status.b.wkupintr)
 8002b68:	f3c9 6107 	ubfx	r1, r9, #24, #8
 8002b6c:	f001 0c80 	and.w	ip, r1, #128	; 0x80
 8002b70:	fa5f f38c 	uxtb.w	r3, ip
 8002b74:	b193      	cbz	r3, 8002b9c <USBD_OTG_ISR_Handler+0x84>
{
  USB_OTG_GINTSTS_TypeDef  gintsts;
  USB_OTG_DCTL_TypeDef     devctl;
  USB_OTG_PCGCCTL_TypeDef  power;
  
  if(pdev->cfg.low_power)
 8002b76:	7ab0      	ldrb	r0, [r6, #10]
 8002b78:	2800      	cmp	r0, #0
 8002b7a:	f040 8204 	bne.w	8002f86 <USBD_OTG_ISR_Handler+0x46e>
  }
  
  /* Clear the Remote Wake-up Signaling */
  devctl.d32 = 0;
  devctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, devctl.d32, 0);
 8002b7e:	6933      	ldr	r3, [r6, #16]
  
  /* Inform upper layer by the Resume Event */
  USBD_DCD_INT_fops->Resume (pdev);
 8002b80:	4aa8      	ldr	r2, [pc, #672]	; (8002e24 <USBD_OTG_ISR_Handler+0x30c>)
  }
  
  /* Clear the Remote Wake-up Signaling */
  devctl.d32 = 0;
  devctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, devctl.d32, 0);
 8002b82:	6859      	ldr	r1, [r3, #4]
  
  /* Inform upper layer by the Resume Event */
  USBD_DCD_INT_fops->Resume (pdev);
 8002b84:	6810      	ldr	r0, [r2, #0]
  }
  
  /* Clear the Remote Wake-up Signaling */
  devctl.d32 = 0;
  devctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, devctl.d32, 0);
 8002b86:	f021 0101 	bic.w	r1, r1, #1
 8002b8a:	6059      	str	r1, [r3, #4]
  
  /* Inform upper layer by the Resume Event */
  USBD_DCD_INT_fops->Resume (pdev);
 8002b8c:	6982      	ldr	r2, [r0, #24]
 8002b8e:	4630      	mov	r0, r6
 8002b90:	4790      	blx	r2
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.wkupintr = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002b92:	68f0      	ldr	r0, [r6, #12]
  /* Inform upper layer by the Resume Event */
  USBD_DCD_INT_fops->Resume (pdev);
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.wkupintr = 1;
 8002b94:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002b98:	6141      	str	r1, [r0, #20]
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
    }
    
    if (gintr_status.b.wkupintr)
    {
      retval |= DCD_HandleResume_ISR(pdev);
 8002b9a:	2001      	movs	r0, #1
    }
    
    if (gintr_status.b.usbsuspend)
 8002b9c:	f3c9 2107 	ubfx	r1, r9, #8, #8
 8002ba0:	f001 0c08 	and.w	ip, r1, #8
 8002ba4:	fa5f f38c 	uxtb.w	r3, ip
 8002ba8:	2b00      	cmp	r3, #0
 8002baa:	f040 81cb 	bne.w	8002f44 <USBD_OTG_ISR_Handler+0x42c>
    {
      retval |= DCD_HandleUSBSuspend_ISR(pdev);
    }
    if (gintr_status.b.sofintr)
 8002bae:	f009 0c08 	and.w	ip, r9, #8
 8002bb2:	fa5f f28c 	uxtb.w	r2, ip
 8002bb6:	2a00      	cmp	r2, #0
 8002bb8:	f040 81ba 	bne.w	8002f30 <USBD_OTG_ISR_Handler+0x418>
    {
      retval |= DCD_HandleSof_ISR(pdev);
      
    }
    
    if (gintr_status.b.rxstsqlvl)
 8002bbc:	f009 0c10 	and.w	ip, r9, #16
 8002bc0:	fa5f f38c 	uxtb.w	r3, ip
 8002bc4:	2b00      	cmp	r3, #0
 8002bc6:	f040 818d 	bne.w	8002ee4 <USBD_OTG_ISR_Handler+0x3cc>
    {
      retval |= DCD_HandleRxStatusQueueLevel_ISR(pdev);
      
    }
    
    if (gintr_status.b.usbreset)
 8002bca:	f3c9 2107 	ubfx	r1, r9, #8, #8
 8002bce:	f001 0c10 	and.w	ip, r1, #16
 8002bd2:	fa5f f38c 	uxtb.w	r3, ip
 8002bd6:	2b00      	cmp	r3, #0
 8002bd8:	f040 814a 	bne.w	8002e70 <USBD_OTG_ISR_Handler+0x358>
    {
      retval |= DCD_HandleUsbReset_ISR(pdev);
      
    }
    if (gintr_status.b.enumdone)
 8002bdc:	f3c9 2107 	ubfx	r1, r9, #8, #8
 8002be0:	f001 0c20 	and.w	ip, r1, #32
 8002be4:	fa5f f38c 	uxtb.w	r3, ip
 8002be8:	2b00      	cmp	r3, #0
 8002bea:	f040 8128 	bne.w	8002e3e <USBD_OTG_ISR_Handler+0x326>
    {
      retval |= DCD_HandleEnumDone_ISR(pdev);
    }
    
    if (gintr_status.b.incomplisoin)
 8002bee:	f3c9 4207 	ubfx	r2, r9, #16, #8
 8002bf2:	f002 0c10 	and.w	ip, r2, #16
 8002bf6:	fa5f f18c 	uxtb.w	r1, ip
 8002bfa:	2900      	cmp	r1, #0
 8002bfc:	f040 8114 	bne.w	8002e28 <USBD_OTG_ISR_Handler+0x310>
    {
      retval |= DCD_IsoINIncomplete_ISR(pdev);
    }

    if (gintr_status.b.incomplisoout)
 8002c00:	f3c9 4107 	ubfx	r1, r9, #16, #8
 8002c04:	f001 0c20 	and.w	ip, r1, #32
 8002c08:	fa5f f38c 	uxtb.w	r3, ip
 8002c0c:	2b00      	cmp	r3, #0
 8002c0e:	d08a      	beq.n	8002b26 <USBD_OTG_ISR_Handler+0xe>
{
  USB_OTG_GINTSTS_TypeDef gintsts;  
  
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoOUTIncomplete (pdev); 
 8002c10:	4a84      	ldr	r2, [pc, #528]	; (8002e24 <USBD_OTG_ISR_Handler+0x30c>)
 8002c12:	6811      	ldr	r1, [r2, #0]
 8002c14:	4630      	mov	r0, r6
 8002c16:	6a0b      	ldr	r3, [r1, #32]
 8002c18:	4798      	blx	r3
  
  /* Clear interrupt */
  gintsts.b.incomplisoout = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002c1a:	68f0      	ldr	r0, [r6, #12]
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoOUTIncomplete (pdev); 
  
  /* Clear interrupt */
  gintsts.b.incomplisoout = 1;
 8002c1c:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002c20:	6142      	str	r2, [r0, #20]
      retval |= DCD_IsoINIncomplete_ISR(pdev);
    }

    if (gintr_status.b.incomplisoout)
    {
      retval |= DCD_IsoOUTIncomplete_ISR(pdev);
 8002c22:	2001      	movs	r0, #1
 8002c24:	e77f      	b.n	8002b26 <USBD_OTG_ISR_Handler+0xe>
  
  uint32_t ep_intr;
  uint32_t epnum = 0;
  uint32_t fifoemptymsk;
  diepint.d32 = 0;
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
 8002c26:	4630      	mov	r0, r6
 8002c28:	f7ff fcba 	bl	80025a0 <USB_OTG_ReadDevAllInEPItr>
  
  while ( ep_intr )
 8002c2c:	4682      	mov	sl, r0
 8002c2e:	2800      	cmp	r0, #0
 8002c30:	f000 80a0 	beq.w	8002d74 <USBD_OTG_ISR_Handler+0x25c>
 8002c34:	4637      	mov	r7, r6
 8002c36:	4634      	mov	r4, r6
static uint32_t DCD_HandleInEP_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_DIEPINTn_TypeDef  diepint;
  
  uint32_t ep_intr;
  uint32_t epnum = 0;
 8002c38:	f04f 0b00 	mov.w	fp, #0
      {
        CLEAR_IN_EP_INTR(epnum, inepnakeff);
      }
      if ( diepint.b.epdisabled )
      {
        CLEAR_IN_EP_INTR(epnum, epdisabled);
 8002c3c:	f8cd 9004 	str.w	r9, [sp, #4]
 8002c40:	46b0      	mov	r8, r6
  diepint.d32 = 0;
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
  
  while ( ep_intr )
  {
    if (ep_intr&0x1) /* In ITR */
 8002c42:	f01a 0f01 	tst.w	sl, #1
 8002c46:	f000 808a 	beq.w	8002d5e <USBD_OTG_ISR_Handler+0x246>
* @retval status
*/
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
 8002c4a:	f8d8 3010 	ldr.w	r3, [r8, #16]
  diepint.d32 = 0;
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
  
  while ( ep_intr )
  {
    if (ep_intr&0x1) /* In ITR */
 8002c4e:	fa5f f68b 	uxtb.w	r6, fp
* @retval status
*/
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
 8002c52:	6919      	ldr	r1, [r3, #16]
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
 8002c54:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  msk |= ((emp >> epnum) & 0x1) << 7;
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 8002c56:	eb08 0c86 	add.w	ip, r8, r6, lsl #2
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
  msk |= ((emp >> epnum) & 0x1) << 7;
 8002c5a:	fa32 f506 	lsrs.w	r5, r2, r6
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 8002c5e:	f8dc 0018 	ldr.w	r0, [ip, #24]
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
  msk |= ((emp >> epnum) & 0x1) << 7;
 8002c62:	01ed      	lsls	r5, r5, #7
 8002c64:	f005 02ff 	and.w	r2, r5, #255	; 0xff
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 8002c68:	6880      	ldr	r0, [r0, #8]
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
  msk |= ((emp >> epnum) & 0x1) << 7;
 8002c6a:	ea42 0901 	orr.w	r9, r2, r1
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 8002c6e:	ea09 0500 	and.w	r5, r9, r0
  while ( ep_intr )
  {
    if (ep_intr&0x1) /* In ITR */
    {
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
 8002c72:	b2ed      	uxtb	r5, r5
 8002c74:	f015 0f01 	tst.w	r5, #1
 8002c78:	f040 81b7 	bne.w	8002fea <USBD_OTG_ISR_Handler+0x4d2>
            /* prepare to rx more setup packets */
            USB_OTG_EP0_OutStart(pdev);
          }
        }           
      }
      if ( diepint.b.ahberr )
 8002c7c:	f005 0904 	and.w	r9, r5, #4
 8002c80:	fa5f f389 	uxtb.w	r3, r9
 8002c84:	b113      	cbz	r3, 8002c8c <USBD_OTG_ISR_Handler+0x174>
      {
        CLEAR_IN_EP_INTR(epnum, ahberr);
 8002c86:	69ba      	ldr	r2, [r7, #24]
 8002c88:	2504      	movs	r5, #4
 8002c8a:	6095      	str	r5, [r2, #8]
      }
      if ( diepint.b.timeout )
 8002c8c:	f005 0008 	and.w	r0, r5, #8
 8002c90:	b2c1      	uxtb	r1, r0
 8002c92:	b111      	cbz	r1, 8002c9a <USBD_OTG_ISR_Handler+0x182>
      {
        CLEAR_IN_EP_INTR(epnum, timeout);
 8002c94:	69bb      	ldr	r3, [r7, #24]
 8002c96:	2508      	movs	r5, #8
 8002c98:	609d      	str	r5, [r3, #8]
      }
      if (diepint.b.intktxfemp)
 8002c9a:	f005 0c10 	and.w	ip, r5, #16
 8002c9e:	fa5f f28c 	uxtb.w	r2, ip
 8002ca2:	b112      	cbz	r2, 8002caa <USBD_OTG_ISR_Handler+0x192>
      {
        CLEAR_IN_EP_INTR(epnum, intktxfemp);
 8002ca4:	69b9      	ldr	r1, [r7, #24]
 8002ca6:	2510      	movs	r5, #16
 8002ca8:	608d      	str	r5, [r1, #8]
      }
      if (diepint.b.intknepmis)
 8002caa:	f005 0920 	and.w	r9, r5, #32
 8002cae:	fa5f f089 	uxtb.w	r0, r9
 8002cb2:	b110      	cbz	r0, 8002cba <USBD_OTG_ISR_Handler+0x1a2>
      {
        CLEAR_IN_EP_INTR(epnum, intknepmis);
 8002cb4:	69bb      	ldr	r3, [r7, #24]
 8002cb6:	2520      	movs	r5, #32
 8002cb8:	609d      	str	r5, [r3, #8]
      }
      if (diepint.b.inepnakeff)
 8002cba:	f005 0c40 	and.w	ip, r5, #64	; 0x40
 8002cbe:	fa5f f28c 	uxtb.w	r2, ip
 8002cc2:	b112      	cbz	r2, 8002cca <USBD_OTG_ISR_Handler+0x1b2>
      {
        CLEAR_IN_EP_INTR(epnum, inepnakeff);
 8002cc4:	69b9      	ldr	r1, [r7, #24]
 8002cc6:	2540      	movs	r5, #64	; 0x40
 8002cc8:	608d      	str	r5, [r1, #8]
      }
      if ( diepint.b.epdisabled )
 8002cca:	f005 0902 	and.w	r9, r5, #2
 8002cce:	fa5f f089 	uxtb.w	r0, r9
 8002cd2:	b110      	cbz	r0, 8002cda <USBD_OTG_ISR_Handler+0x1c2>
      {
        CLEAR_IN_EP_INTR(epnum, epdisabled);
 8002cd4:	69bb      	ldr	r3, [r7, #24]
 8002cd6:	2502      	movs	r5, #2
 8002cd8:	609d      	str	r5, [r3, #8]
      }       
      if (diepint.b.emptyintr)
 8002cda:	f005 0580 	and.w	r5, r5, #128	; 0x80
 8002cde:	b2ed      	uxtb	r5, r5
 8002ce0:	2d00      	cmp	r5, #0
 8002ce2:	d03c      	beq.n	8002d5e <USBD_OTG_ISR_Handler+0x246>
  uint32_t len32b;
  txstatus.d32 = 0;
  
  ep = &pdev->dev.in_ep[epnum];    
  
  len = ep->xfer_len - ep->xfer_count;
 8002ce4:	f8d4 112c 	ldr.w	r1, [r4, #300]	; 0x12c
 8002ce8:	f8d4 0130 	ldr.w	r0, [r4, #304]	; 0x130
  {
    len = ep->maxpacket;
  }
  
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 8002cec:	69bb      	ldr	r3, [r7, #24]
  if (len > ep->maxpacket)
  {
    len = ep->maxpacket;
  }
  
  len32b = (len + 3) / 4;
 8002cee:	f8d4 2120 	ldr.w	r2, [r4, #288]	; 0x120
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 8002cf2:	f8d3 9018 	ldr.w	r9, [r3, #24]
  uint32_t len32b;
  txstatus.d32 = 0;
  
  ep = &pdev->dev.in_ep[epnum];    
  
  len = ep->xfer_len - ep->xfer_count;
 8002cf6:	1a0d      	subs	r5, r1, r0
  if (len > ep->maxpacket)
  {
    len = ep->maxpacket;
  }
  
  len32b = (len + 3) / 4;
 8002cf8:	4295      	cmp	r5, r2
 8002cfa:	bf34      	ite	cc
 8002cfc:	46ac      	movcc	ip, r5
 8002cfe:	4694      	movcs	ip, r2
 8002d00:	f10c 0c03 	add.w	ip, ip, #3
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002d04:	fa1f f989 	uxth.w	r9, r9
 8002d08:	ebb9 0f9c 	cmp.w	r9, ip, lsr #2
 8002d0c:	d925      	bls.n	8002d5a <USBD_OTG_ISR_Handler+0x242>
 8002d0e:	4281      	cmp	r1, r0
 8002d10:	d923      	bls.n	8002d5a <USBD_OTG_ISR_Handler+0x242>
          ep->xfer_count < ep->xfer_len &&
 8002d12:	b311      	cbz	r1, 8002d5a <USBD_OTG_ISR_Handler+0x242>
 8002d14:	f8d4 1124 	ldr.w	r1, [r4, #292]	; 0x124
 8002d18:	e006      	b.n	8002d28 <USBD_OTG_ISR_Handler+0x210>
 8002d1a:	f8d4 512c 	ldr.w	r5, [r4, #300]	; 0x12c
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002d1e:	42aa      	cmp	r2, r5
 8002d20:	d21b      	bcs.n	8002d5a <USBD_OTG_ISR_Handler+0x242>
 8002d22:	1aad      	subs	r5, r5, r2
 8002d24:	f8d4 2120 	ldr.w	r2, [r4, #288]	; 0x120
          ep->xfer_count < ep->xfer_len &&
            ep->xfer_len != 0)
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 8002d28:	4295      	cmp	r5, r2
 8002d2a:	bf28      	it	cs
 8002d2c:	4615      	movcs	r5, r2
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3) / 4;
    
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
 8002d2e:	b2ab      	uxth	r3, r5
 8002d30:	4632      	mov	r2, r6
 8002d32:	4640      	mov	r0, r8
 8002d34:	f7fe ff16 	bl	8001b64 <USB_OTG_WritePacket>
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
 8002d38:	f8d4 2130 	ldr.w	r2, [r4, #304]	; 0x130
    
    txstatus.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 8002d3c:	69bb      	ldr	r3, [r7, #24]
    }
    len32b = (len + 3) / 4;
    
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
    
    ep->xfer_buff  += len;
 8002d3e:	f8d4 1124 	ldr.w	r1, [r4, #292]	; 0x124
    ep->xfer_count += len;
 8002d42:	18aa      	adds	r2, r5, r2
 8002d44:	f8c4 2130 	str.w	r2, [r4, #304]	; 0x130
    
    txstatus.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 8002d48:	6998      	ldr	r0, [r3, #24]
    }
    len32b = (len + 3) / 4;
    
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
    
    ep->xfer_buff  += len;
 8002d4a:	1949      	adds	r1, r1, r5
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002d4c:	b280      	uxth	r0, r0
    
    if (len > ep->maxpacket)
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3) / 4;
 8002d4e:	3503      	adds	r5, #3
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002d50:	ebb0 0f95 	cmp.w	r0, r5, lsr #2
    }
    len32b = (len + 3) / 4;
    
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
    
    ep->xfer_buff  += len;
 8002d54:	f8c4 1124 	str.w	r1, [r4, #292]	; 0x124
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8002d58:	d8df      	bhi.n	8002d1a <USBD_OTG_ISR_Handler+0x202>
      if (diepint.b.emptyintr)
      {
        
        DCD_WriteEmptyTxFifo(pdev , epnum);
        
        CLEAR_IN_EP_INTR(epnum, emptyintr);
 8002d5a:	2680      	movs	r6, #128	; 0x80
 8002d5c:	609e      	str	r6, [r3, #8]
      }
    }
    epnum++;
    ep_intr >>= 1;
 8002d5e:	3428      	adds	r4, #40	; 0x28
 8002d60:	3704      	adds	r7, #4
  uint32_t epnum = 0;
  uint32_t fifoemptymsk;
  diepint.d32 = 0;
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
  
  while ( ep_intr )
 8002d62:	ea5f 0a5a 	movs.w	sl, sl, lsr #1
 8002d66:	d002      	beq.n	8002d6e <USBD_OTG_ISR_Handler+0x256>
        DCD_WriteEmptyTxFifo(pdev , epnum);
        
        CLEAR_IN_EP_INTR(epnum, emptyintr);
      }
    }
    epnum++;
 8002d68:	f10b 0b01 	add.w	fp, fp, #1
 8002d6c:	e769      	b.n	8002c42 <USBD_OTG_ISR_Handler+0x12a>
 8002d6e:	f8dd 9004 	ldr.w	r9, [sp, #4]
 8002d72:	4646      	mov	r6, r8
      retval |= DCD_HandleOutEP_ISR(pdev);
    }    
    
    if (gintr_status.b.inepint)
    {
      retval |= DCD_HandleInEP_ISR(pdev);
 8002d74:	2001      	movs	r0, #1
 8002d76:	e6ef      	b.n	8002b58 <USBD_OTG_ISR_Handler+0x40>
  uint32_t epnum = 0;
  
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
 8002d78:	4630      	mov	r0, r6
 8002d7a:	f7ff fbff 	bl	800257c <USB_OTG_ReadDevAllOutEp_itr>
  
  while ( ep_intr )
 8002d7e:	4604      	mov	r4, r0
 8002d80:	2800      	cmp	r0, #0
 8002d82:	d04d      	beq.n	8002e20 <USBD_OTG_ISR_Handler+0x308>
      if ( doepint.b.setup )
      {
        
        /* inform the upper layer that a setup packet is available */
        /* SETUP COMPLETE */
        USBD_DCD_INT_fops->SetupStage(pdev);
 8002d84:	f8df b09c 	ldr.w	fp, [pc, #156]	; 8002e24 <USBD_OTG_ISR_Handler+0x30c>
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
  
  while ( ep_intr )
 8002d88:	4635      	mov	r5, r6
 8002d8a:	46b0      	mov	r8, r6
static uint32_t DCD_HandleOutEP_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t ep_intr;
  USB_OTG_DOEPINTn_TypeDef  doepint;
  USB_OTG_DEPXFRSIZ_TypeDef  deptsiz;
  uint32_t epnum = 0;
 8002d8c:	2700      	movs	r7, #0
        CLEAR_OUT_EP_INTR(epnum, epdisabled);
      }
      /* AHB Error */
      if ( doepint.b.ahberr )
      {
        CLEAR_OUT_EP_INTR(epnum, ahberr);
 8002d8e:	46ca      	mov	sl, r9
 8002d90:	e005      	b.n	8002d9e <USBD_OTG_ISR_Handler+0x286>
        USBD_DCD_INT_fops->SetupStage(pdev);
        CLEAR_OUT_EP_INTR(epnum, setup);
      }
    }
    epnum++;
    ep_intr >>= 1;
 8002d92:	3504      	adds	r5, #4
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
  
  while ( ep_intr )
 8002d94:	0864      	lsrs	r4, r4, #1
        USBD_DCD_INT_fops->SetupStage(pdev);
        CLEAR_OUT_EP_INTR(epnum, setup);
      }
    }
    epnum++;
    ep_intr >>= 1;
 8002d96:	f108 0828 	add.w	r8, r8, #40	; 0x28
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
  
  while ( ep_intr )
 8002d9a:	d040      	beq.n	8002e1e <USBD_OTG_ISR_Handler+0x306>
        /* SETUP COMPLETE */
        USBD_DCD_INT_fops->SetupStage(pdev);
        CLEAR_OUT_EP_INTR(epnum, setup);
      }
    }
    epnum++;
 8002d9c:	3701      	adds	r7, #1
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
  
  while ( ep_intr )
  {
    if (ep_intr&0x1)
 8002d9e:	f014 0f01 	tst.w	r4, #1
 8002da2:	d0f6      	beq.n	8002d92 <USBD_OTG_ISR_Handler+0x27a>
 8002da4:	fa5f f987 	uxtb.w	r9, r7
    {
      
      doepint.d32 = USB_OTG_ReadDevOutEP_itr(pdev, epnum);
 8002da8:	4630      	mov	r0, r6
 8002daa:	4649      	mov	r1, r9
 8002dac:	f7ff fbee 	bl	800258c <USB_OTG_ReadDevOutEP_itr>
      
      /* Transfer complete */
      if ( doepint.b.xfercompl )
 8002db0:	b2c0      	uxtb	r0, r0
 8002db2:	f010 0f01 	tst.w	r0, #1
 8002db6:	d013      	beq.n	8002de0 <USBD_OTG_ISR_Handler+0x2c8>
      {
        /* Clear the bit in DOEPINTn for this interrupt */
        CLEAR_OUT_EP_INTR(epnum, xfercompl);
 8002db8:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8002dba:	2001      	movs	r0, #1
 8002dbc:	6098      	str	r0, [r3, #8]
        if (pdev->cfg.dma_enable == 1)
 8002dbe:	78f2      	ldrb	r2, [r6, #3]
 8002dc0:	2a01      	cmp	r2, #1
 8002dc2:	f000 8142 	beq.w	800304a <USBD_OTG_ISR_Handler+0x532>
          pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
            deptsiz.b.xfersize;
        }
        /* Inform upper layer: data ready */
        /* RX COMPLETE */
        USBD_DCD_INT_fops->DataOutStage(pdev , epnum);
 8002dc6:	f8db 1000 	ldr.w	r1, [fp]
 8002dca:	4630      	mov	r0, r6
 8002dcc:	680b      	ldr	r3, [r1, #0]
 8002dce:	4649      	mov	r1, r9
 8002dd0:	4798      	blx	r3
        
        if (pdev->cfg.dma_enable == 1)
 8002dd2:	f896 9003 	ldrb.w	r9, [r6, #3]
 8002dd6:	f1b9 0f01 	cmp.w	r9, #1
 8002dda:	f000 8129 	beq.w	8003030 <USBD_OTG_ISR_Handler+0x518>
 8002dde:	2001      	movs	r0, #1
            USB_OTG_EP0_OutStart(pdev);
          }
        }        
      }
      /* Endpoint disable  */
      if ( doepint.b.epdisabled )
 8002de0:	f000 0902 	and.w	r9, r0, #2
 8002de4:	fa5f f289 	uxtb.w	r2, r9
 8002de8:	b112      	cbz	r2, 8002df0 <USBD_OTG_ISR_Handler+0x2d8>
      {
        /* Clear the bit in DOEPINTn for this interrupt */
        CLEAR_OUT_EP_INTR(epnum, epdisabled);
 8002dea:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8002dec:	2002      	movs	r0, #2
 8002dee:	6098      	str	r0, [r3, #8]
      }
      /* AHB Error */
      if ( doepint.b.ahberr )
 8002df0:	f000 0c04 	and.w	ip, r0, #4
 8002df4:	fa5f f18c 	uxtb.w	r1, ip
 8002df8:	b111      	cbz	r1, 8002e00 <USBD_OTG_ISR_Handler+0x2e8>
      {
        CLEAR_OUT_EP_INTR(epnum, ahberr);
 8002dfa:	6d6a      	ldr	r2, [r5, #84]	; 0x54
 8002dfc:	2004      	movs	r0, #4
 8002dfe:	6090      	str	r0, [r2, #8]
      }
      /* Setup Phase Done (control EPs) */
      if ( doepint.b.setup )
 8002e00:	f000 0e08 	and.w	lr, r0, #8
 8002e04:	fa5f f08e 	uxtb.w	r0, lr
 8002e08:	2800      	cmp	r0, #0
 8002e0a:	d0c2      	beq.n	8002d92 <USBD_OTG_ISR_Handler+0x27a>
      {
        
        /* inform the upper layer that a setup packet is available */
        /* SETUP COMPLETE */
        USBD_DCD_INT_fops->SetupStage(pdev);
 8002e0c:	f8db 1000 	ldr.w	r1, [fp]
 8002e10:	4630      	mov	r0, r6
 8002e12:	688a      	ldr	r2, [r1, #8]
 8002e14:	4790      	blx	r2
        CLEAR_OUT_EP_INTR(epnum, setup);
 8002e16:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8002e18:	2108      	movs	r1, #8
 8002e1a:	6099      	str	r1, [r3, #8]
 8002e1c:	e7b9      	b.n	8002d92 <USBD_OTG_ISR_Handler+0x27a>
 8002e1e:	46d1      	mov	r9, sl
      return 0;
    }
    
    if (gintr_status.b.outepintr)
    {
      retval |= DCD_HandleOutEP_ISR(pdev);
 8002e20:	2001      	movs	r0, #1
 8002e22:	e691      	b.n	8002b48 <USBD_OTG_ISR_Handler+0x30>
 8002e24:	20000148 	.word	0x20000148
{
  USB_OTG_GINTSTS_TypeDef gintsts;  
  
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoINIncomplete (pdev); 
 8002e28:	488d      	ldr	r0, [pc, #564]	; (8003060 <USBD_OTG_ISR_Handler+0x548>)
 8002e2a:	6802      	ldr	r2, [r0, #0]
 8002e2c:	4630      	mov	r0, r6
 8002e2e:	69d1      	ldr	r1, [r2, #28]
 8002e30:	4788      	blx	r1
  
  /* Clear interrupt */
  gintsts.b.incomplisoin = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002e32:	68f3      	ldr	r3, [r6, #12]
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoINIncomplete (pdev); 
  
  /* Clear interrupt */
  gintsts.b.incomplisoin = 1;
 8002e34:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002e38:	6158      	str	r0, [r3, #20]
      retval |= DCD_HandleEnumDone_ISR(pdev);
    }
    
    if (gintr_status.b.incomplisoin)
    {
      retval |= DCD_IsoINIncomplete_ISR(pdev);
 8002e3a:	2001      	movs	r0, #1
 8002e3c:	e6e0      	b.n	8002c00 <USBD_OTG_ISR_Handler+0xe8>
static uint32_t DCD_HandleEnumDone_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_GINTSTS_TypeDef  gintsts;
  USB_OTG_GUSBCFG_TypeDef  gusbcfg;
  
  USB_OTG_EP0Activate(pdev);
 8002e3e:	4630      	mov	r0, r6
 8002e40:	f7ff f996 	bl	8002170 <USB_OTG_EP0Activate>
  
  /* Set USB turn-around time based on device speed and PHY interface. */
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8002e44:	68f4      	ldr	r4, [r6, #12]
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
 8002e46:	4630      	mov	r0, r6
  USB_OTG_GUSBCFG_TypeDef  gusbcfg;
  
  USB_OTG_EP0Activate(pdev);
  
  /* Set USB turn-around time based on device speed and PHY interface. */
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8002e48:	68e4      	ldr	r4, [r4, #12]
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
 8002e4a:	f7ff f981 	bl	8002150 <USB_OTG_GetDeviceSpeed>
 8002e4e:	2803      	cmp	r0, #3
 8002e50:	f000 80c1 	beq.w	8002fd6 <USBD_OTG_ISR_Handler+0x4be>
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
    gusbcfg.b.usbtrdtim = 9;
  }
  else
  {
    pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8002e54:	2001      	movs	r0, #1
    pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;  
 8002e56:	2140      	movs	r1, #64	; 0x40
    gusbcfg.b.usbtrdtim = 5;
 8002e58:	2305      	movs	r3, #5
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
    gusbcfg.b.usbtrdtim = 9;
  }
  else
  {
    pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8002e5a:	70b0      	strb	r0, [r6, #2]
    pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;  
 8002e5c:	80b1      	strh	r1, [r6, #4]
    gusbcfg.b.usbtrdtim = 5;
 8002e5e:	f363 248d 	bfi	r4, r3, #10, #4
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
 8002e62:	68f3      	ldr	r3, [r6, #12]
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.enumdone = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, gintsts.d32 );
 8002e64:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    pdev->cfg.speed            = USB_OTG_SPEED_FULL;
    pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;  
    gusbcfg.b.usbtrdtim = 5;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
 8002e68:	60dc      	str	r4, [r3, #12]
      retval |= DCD_HandleUsbReset_ISR(pdev);
      
    }
    if (gintr_status.b.enumdone)
    {
      retval |= DCD_HandleEnumDone_ISR(pdev);
 8002e6a:	2001      	movs	r0, #1
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.enumdone = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, gintsts.d32 );
 8002e6c:	615a      	str	r2, [r3, #20]
 8002e6e:	e6be      	b.n	8002bee <USBD_OTG_ISR_Handler+0xd6>
  dcfg.d32 = 0;
  gintsts.d32 = 0;
  
  /* Clear the Remote Wake-up Signaling */
  dctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
 8002e70:	6930      	ldr	r0, [r6, #16]
 8002e72:	6843      	ldr	r3, [r0, #4]
  USB_OTG_DCFG_TypeDef     dcfg;
  USB_OTG_DCTL_TypeDef     dctl;
  USB_OTG_GINTSTS_TypeDef  gintsts;
  uint32_t i;
  
  dctl.d32 = 0;
 8002e74:	2400      	movs	r4, #0
  dcfg.d32 = 0;
  gintsts.d32 = 0;
  
  /* Clear the Remote Wake-up Signaling */
  dctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
 8002e76:	f023 0201 	bic.w	r2, r3, #1
 8002e7a:	6042      	str	r2, [r0, #4]
  
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
 8002e7c:	4621      	mov	r1, r4
 8002e7e:	4630      	mov	r0, r6
 8002e80:	f7ff f832 	bl	8001ee8 <USB_OTG_FlushTxFifo>
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002e84:	7875      	ldrb	r5, [r6, #1]
 8002e86:	b16d      	cbz	r5, 8002ea4 <USBD_OTG_ISR_Handler+0x38c>
* @brief  STM32_USBF_OTG_ISR_Handler
*         handles all USB Interrupts
* @param  pdev: device instance
* @retval status
*/
uint32_t USBD_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
 8002e88:	f106 0214 	add.w	r2, r6, #20
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
  
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002e8c:	4623      	mov	r3, r4
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 8002e8e:	21ff      	movs	r1, #255	; 0xff
 8002e90:	f852 5f04 	ldr.w	r5, [r2, #4]!
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 8002e94:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 8002e96:	60a9      	str	r1, [r5, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 8002e98:	6081      	str	r1, [r0, #8]
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
  
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8002e9a:	f896 e001 	ldrb.w	lr, [r6, #1]
 8002e9e:	3301      	adds	r3, #1
 8002ea0:	4573      	cmp	r3, lr
 8002ea2:	d3f5      	bcc.n	8002e90 <USBD_OTG_ISR_Handler+0x378>
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
  
  daintmsk.ep.in = 1;
 8002ea4:	2501      	movs	r5, #1
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8002ea6:	6933      	ldr	r3, [r6, #16]
  
  daintmsk.ep.in = 1;
 8002ea8:	f365 040f 	bfi	r4, r5, #0, #16
  
  doepmsk.b.setup = 1;
  doepmsk.b.xfercompl = 1;
  doepmsk.b.ahberr = 1;
  doepmsk.b.epdisabled = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, doepmsk.d32 );
 8002eac:	210f      	movs	r1, #15
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8002eae:	f04f 32ff 	mov.w	r2, #4294967295
  diepmsk.b.xfercompl = 1;
  diepmsk.b.timeout = 1;
  diepmsk.b.epdisabled = 1;
  diepmsk.b.ahberr = 1;
  diepmsk.b.intknepmis = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, diepmsk.d32 );
 8002eb2:	202f      	movs	r0, #47	; 0x2f
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
  
  daintmsk.ep.in = 1;
  daintmsk.ep.out = 1;
 8002eb4:	f365 441f 	bfi	r4, r5, #16, #16
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8002eb8:	619a      	str	r2, [r3, #24]
  
  daintmsk.ep.in = 1;
  daintmsk.ep.out = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, daintmsk.d32 );
 8002eba:	61dc      	str	r4, [r3, #28]
  
  doepmsk.b.setup = 1;
  doepmsk.b.xfercompl = 1;
  doepmsk.b.ahberr = 1;
  doepmsk.b.epdisabled = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, doepmsk.d32 );
 8002ebc:	6159      	str	r1, [r3, #20]
  diepmsk.b.xfercompl = 1;
  diepmsk.b.timeout = 1;
  diepmsk.b.epdisabled = 1;
  diepmsk.b.ahberr = 1;
  diepmsk.b.intknepmis = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, diepmsk.d32 );
 8002ebe:	6118      	str	r0, [r3, #16]
#ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED  
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DINEP1MSK, diepmsk.d32 );
#endif
  /* Reset Device Address */
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
 8002ec0:	681a      	ldr	r2, [r3, #0]
  dcfg.b.devaddr = 0;
 8002ec2:	f36f 120a 	bfc	r2, #4, #7
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32);
 8002ec6:	601a      	str	r2, [r3, #0]
  
  
  /* setup EP0 to receive SETUP packets */
  USB_OTG_EP0_OutStart(pdev);
 8002ec8:	4630      	mov	r0, r6
 8002eca:	f7ff fb71 	bl	80025b0 <USB_OTG_EP0_OutStart>
  gintsts.d32 = 0;
  gintsts.b.usbreset = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
  
  /*Reset internal state machine */
  USBD_DCD_INT_fops->Reset(pdev);
 8002ece:	4964      	ldr	r1, [pc, #400]	; (8003060 <USBD_OTG_ISR_Handler+0x548>)
  USB_OTG_EP0_OutStart(pdev);
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbreset = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002ed0:	68f2      	ldr	r2, [r6, #12]
  
  /*Reset internal state machine */
  USBD_DCD_INT_fops->Reset(pdev);
 8002ed2:	680b      	ldr	r3, [r1, #0]
  /* setup EP0 to receive SETUP packets */
  USB_OTG_EP0_OutStart(pdev);
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbreset = 1;
 8002ed4:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002ed8:	6150      	str	r0, [r2, #20]
  
  /*Reset internal state machine */
  USBD_DCD_INT_fops->Reset(pdev);
 8002eda:	6919      	ldr	r1, [r3, #16]
 8002edc:	4630      	mov	r0, r6
 8002ede:	4788      	blx	r1
      
    }
    
    if (gintr_status.b.usbreset)
    {
      retval |= DCD_HandleUsbReset_ISR(pdev);
 8002ee0:	4628      	mov	r0, r5
 8002ee2:	e67b      	b.n	8002bdc <USBD_OTG_ISR_Handler+0xc4>
  USB_OTG_EP *ep;
  
  /* Disable the Rx Status Queue Level interrupt */
  int_mask.d32 = 0;
  int_mask.b.rxstsqlvl = 1;
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32, 0);
 8002ee4:	68f3      	ldr	r3, [r6, #12]
 8002ee6:	699d      	ldr	r5, [r3, #24]
 8002ee8:	f025 0410 	bic.w	r4, r5, #16
 8002eec:	619c      	str	r4, [r3, #24]
  
  /* Get the Status from the top of the FIFO */
  status.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRXSTSP );
 8002eee:	6a1c      	ldr	r4, [r3, #32]
  
  ep = &pdev->dev.out_ep[status.b.epnum];
  
  switch (status.b.pktsts)
 8002ef0:	f3c4 4243 	ubfx	r2, r4, #17, #4
 8002ef4:	2a02      	cmp	r2, #2
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32, 0);
  
  /* Get the Status from the top of the FIFO */
  status.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRXSTSP );
  
  ep = &pdev->dev.out_ep[status.b.epnum];
 8002ef6:	f004 050f 	and.w	r5, r4, #15
  
  switch (status.b.pktsts)
 8002efa:	d04e      	beq.n	8002f9a <USBD_OTG_ISR_Handler+0x482>
 8002efc:	2a06      	cmp	r2, #6
 8002efe:	d111      	bne.n	8002f24 <USBD_OTG_ISR_Handler+0x40c>
    break;
  case STS_SETUP_COMP:
    break;
  case STS_SETUP_UPDT:
    /* Copy the setup packet received in FIFO into the setup buffer in RAM */
    USB_OTG_ReadPacket(pdev , pdev->dev.setup_packet, 8);
 8002f00:	f506 61b9 	add.w	r1, r6, #1480	; 0x5c8
 8002f04:	4630      	mov	r0, r6
 8002f06:	2208      	movs	r2, #8
    ep->xfer_count += status.b.bcnt;
 8002f08:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    break;
  case STS_SETUP_COMP:
    break;
  case STS_SETUP_UPDT:
    /* Copy the setup packet received in FIFO into the setup buffer in RAM */
    USB_OTG_ReadPacket(pdev , pdev->dev.setup_packet, 8);
 8002f0c:	f7fe fe52 	bl	8001bb4 <USB_OTG_ReadPacket>
    ep->xfer_count += status.b.bcnt;
 8002f10:	eb06 0cc5 	add.w	ip, r6, r5, lsl #3
 8002f14:	f3c4 140a 	ubfx	r4, r4, #4, #11
 8002f18:	f8dc 1388 	ldr.w	r1, [ip, #904]	; 0x388
 8002f1c:	68f3      	ldr	r3, [r6, #12]
 8002f1e:	1860      	adds	r0, r4, r1
 8002f20:	f8cc 0388 	str.w	r0, [ip, #904]	; 0x388
  default:
    break;
  }
  
  /* Enable the Rx Status Queue Level interrupt */
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, int_mask.d32);
 8002f24:	6998      	ldr	r0, [r3, #24]
 8002f26:	f040 0210 	orr.w	r2, r0, #16
 8002f2a:	619a      	str	r2, [r3, #24]
      
    }
    
    if (gintr_status.b.rxstsqlvl)
    {
      retval |= DCD_HandleRxStatusQueueLevel_ISR(pdev);
 8002f2c:	2001      	movs	r0, #1
 8002f2e:	e64c      	b.n	8002bca <USBD_OTG_ISR_Handler+0xb2>
static uint32_t DCD_HandleSof_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_GINTSTS_TypeDef  GINTSTS;
  
  
  USBD_DCD_INT_fops->SOF(pdev);
 8002f30:	484b      	ldr	r0, [pc, #300]	; (8003060 <USBD_OTG_ISR_Handler+0x548>)
 8002f32:	6802      	ldr	r2, [r0, #0]
 8002f34:	4630      	mov	r0, r6
 8002f36:	68d1      	ldr	r1, [r2, #12]
 8002f38:	4788      	blx	r1
  
  /* Clear interrupt */
  GINTSTS.d32 = 0;
  GINTSTS.b.sofintr = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, GINTSTS.d32);
 8002f3a:	68f3      	ldr	r3, [r6, #12]
  
  USBD_DCD_INT_fops->SOF(pdev);
  
  /* Clear interrupt */
  GINTSTS.d32 = 0;
  GINTSTS.b.sofintr = 1;
 8002f3c:	2008      	movs	r0, #8
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, GINTSTS.d32);
 8002f3e:	6158      	str	r0, [r3, #20]
    {
      retval |= DCD_HandleUSBSuspend_ISR(pdev);
    }
    if (gintr_status.b.sofintr)
    {
      retval |= DCD_HandleSof_ISR(pdev);
 8002f40:	2001      	movs	r0, #1
 8002f42:	e63b      	b.n	8002bbc <USBD_OTG_ISR_Handler+0xa4>
{
  USB_OTG_GINTSTS_TypeDef  gintsts;
  USB_OTG_PCGCCTL_TypeDef  power;
  USB_OTG_DSTS_TypeDef     dsts;
  
  USBD_DCD_INT_fops->Suspend (pdev);      
 8002f44:	4846      	ldr	r0, [pc, #280]	; (8003060 <USBD_OTG_ISR_Handler+0x548>)
 8002f46:	6803      	ldr	r3, [r0, #0]
 8002f48:	4630      	mov	r0, r6
 8002f4a:	695a      	ldr	r2, [r3, #20]
 8002f4c:	4790      	blx	r2
  
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8002f4e:	6931      	ldr	r1, [r6, #16]
    
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbsuspend = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002f50:	68f3      	ldr	r3, [r6, #12]
  USB_OTG_PCGCCTL_TypeDef  power;
  USB_OTG_DSTS_TypeDef     dsts;
  
  USBD_DCD_INT_fops->Suspend (pdev);      
  
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8002f52:	6889      	ldr	r1, [r1, #8]
    
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbsuspend = 1;
 8002f54:	f44f 6200 	mov.w	r2, #2048	; 0x800
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002f58:	615a      	str	r2, [r3, #20]
  
  if((pdev->cfg.low_power) && (dsts.b.suspsts == 1))
 8002f5a:	7ab0      	ldrb	r0, [r6, #10]
 8002f5c:	b188      	cbz	r0, 8002f82 <USBD_OTG_ISR_Handler+0x46a>
 8002f5e:	f011 0f01 	tst.w	r1, #1
 8002f62:	d00e      	beq.n	8002f82 <USBD_OTG_ISR_Handler+0x46a>
  {
	/*  switch-off the clocks */
    power.d32 = 0;
    power.b.stoppclk = 1;
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);  
 8002f64:	f8d6 310c 	ldr.w	r3, [r6, #268]	; 0x10c
    
    power.b.gatehclk = 1;
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);
    
    /* Request to enter Sleep mode after exit from current ISR */
    SCB->SCR |= (SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk);
 8002f68:	4a3e      	ldr	r2, [pc, #248]	; (8003064 <USBD_OTG_ISR_Handler+0x54c>)
  if((pdev->cfg.low_power) && (dsts.b.suspsts == 1))
  {
	/*  switch-off the clocks */
    power.d32 = 0;
    power.b.stoppclk = 1;
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);  
 8002f6a:	6819      	ldr	r1, [r3, #0]
 8002f6c:	f041 0001 	orr.w	r0, r1, #1
 8002f70:	6018      	str	r0, [r3, #0]
    
    power.b.gatehclk = 1;
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);
 8002f72:	6819      	ldr	r1, [r3, #0]
 8002f74:	f041 0003 	orr.w	r0, r1, #3
 8002f78:	6018      	str	r0, [r3, #0]
    
    /* Request to enter Sleep mode after exit from current ISR */
    SCB->SCR |= (SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk);
 8002f7a:	6913      	ldr	r3, [r2, #16]
 8002f7c:	f043 0106 	orr.w	r1, r3, #6
 8002f80:	6111      	str	r1, [r2, #16]
      retval |= DCD_HandleResume_ISR(pdev);
    }
    
    if (gintr_status.b.usbsuspend)
    {
      retval |= DCD_HandleUSBSuspend_ISR(pdev);
 8002f82:	2001      	movs	r0, #1
 8002f84:	e613      	b.n	8002bae <USBD_OTG_ISR_Handler+0x96>
  USB_OTG_PCGCCTL_TypeDef  power;
  
  if(pdev->cfg.low_power)
  {
    /* un-gate USB Core clock */
    power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
 8002f86:	f8d6 310c 	ldr.w	r3, [r6, #268]	; 0x10c
    power.b.gatehclk = 0;
    power.b.stoppclk = 0;
    USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 8002f8a:	f8d6 210c 	ldr.w	r2, [r6, #268]	; 0x10c
  
  if(pdev->cfg.low_power)
  {
    /* un-gate USB Core clock */
    power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
    power.b.gatehclk = 0;
 8002f8e:	f36f 0341 	bfc	r3, #1, #1
    power.b.stoppclk = 0;
 8002f92:	f36f 0300 	bfc	r3, #0, #1
    USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 8002f96:	6013      	str	r3, [r2, #0]
 8002f98:	e5f1      	b.n	8002b7e <USBD_OTG_ISR_Handler+0x66>
  switch (status.b.pktsts)
  {
  case STS_GOUT_NAK:
    break;
  case STS_DATA_UPDT:
    if (status.b.bcnt)
 8002f9a:	f647 72f0 	movw	r2, #32752	; 0x7ff0
 8002f9e:	ea04 0102 	and.w	r1, r4, r2
 8002fa2:	2900      	cmp	r1, #0
 8002fa4:	d0be      	beq.n	8002f24 <USBD_OTG_ISR_Handler+0x40c>
    {
      USB_OTG_ReadPacket(pdev,ep->xfer_buff, status.b.bcnt);
 8002fa6:	eb05 0e85 	add.w	lr, r5, r5, lsl #2
 8002faa:	eb06 05ce 	add.w	r5, r6, lr, lsl #3
 8002fae:	f3c4 140a 	ubfx	r4, r4, #4, #11
 8002fb2:	4622      	mov	r2, r4
 8002fb4:	f8d5 137c 	ldr.w	r1, [r5, #892]	; 0x37c
 8002fb8:	4630      	mov	r0, r6
 8002fba:	f7fe fdfb 	bl	8001bb4 <USB_OTG_ReadPacket>
      ep->xfer_buff += status.b.bcnt;
 8002fbe:	f8d5 237c 	ldr.w	r2, [r5, #892]	; 0x37c
      ep->xfer_count += status.b.bcnt;
 8002fc2:	f8d5 1388 	ldr.w	r1, [r5, #904]	; 0x388
 8002fc6:	68f3      	ldr	r3, [r6, #12]
    break;
  case STS_DATA_UPDT:
    if (status.b.bcnt)
    {
      USB_OTG_ReadPacket(pdev,ep->xfer_buff, status.b.bcnt);
      ep->xfer_buff += status.b.bcnt;
 8002fc8:	1910      	adds	r0, r2, r4
      ep->xfer_count += status.b.bcnt;
 8002fca:	1864      	adds	r4, r4, r1
    break;
  case STS_DATA_UPDT:
    if (status.b.bcnt)
    {
      USB_OTG_ReadPacket(pdev,ep->xfer_buff, status.b.bcnt);
      ep->xfer_buff += status.b.bcnt;
 8002fcc:	f8c5 037c 	str.w	r0, [r5, #892]	; 0x37c
      ep->xfer_count += status.b.bcnt;
 8002fd0:	f8c5 4388 	str.w	r4, [r5, #904]	; 0x388
 8002fd4:	e7a6      	b.n	8002f24 <USBD_OTG_ISR_Handler+0x40c>
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
  {
    pdev->cfg.speed            = USB_OTG_SPEED_HIGH;
 8002fd6:	2200      	movs	r2, #0
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
 8002fd8:	f44f 7e00 	mov.w	lr, #512	; 0x200
    gusbcfg.b.usbtrdtim = 9;
 8002fdc:	2009      	movs	r0, #9
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
  {
    pdev->cfg.speed            = USB_OTG_SPEED_HIGH;
 8002fde:	70b2      	strb	r2, [r6, #2]
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
 8002fe0:	f8a6 e004 	strh.w	lr, [r6, #4]
    gusbcfg.b.usbtrdtim = 9;
 8002fe4:	f360 248d 	bfi	r4, r0, #10, #4
 8002fe8:	e73b      	b.n	8002e62 <USBD_OTG_ISR_Handler+0x34a>
      {
        fifoemptymsk = 0x1 << epnum;
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
        CLEAR_IN_EP_INTR(epnum, xfercompl);
        /* TX COMPLETE */
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 8002fea:	4d1d      	ldr	r5, [pc, #116]	; (8003060 <USBD_OTG_ISR_Handler+0x548>)
    {
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
      {
        fifoemptymsk = 0x1 << epnum;
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
 8002fec:	6b58      	ldr	r0, [r3, #52]	; 0x34
        CLEAR_IN_EP_INTR(epnum, xfercompl);
        /* TX COMPLETE */
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 8002fee:	6829      	ldr	r1, [r5, #0]
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
      {
        fifoemptymsk = 0x1 << epnum;
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
        CLEAR_IN_EP_INTR(epnum, xfercompl);
 8002ff0:	69ba      	ldr	r2, [r7, #24]
    if (ep_intr&0x1) /* In ITR */
    {
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
      {
        fifoemptymsk = 0x1 << epnum;
 8002ff2:	2501      	movs	r5, #1
 8002ff4:	fa05 fe0b 	lsl.w	lr, r5, fp
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
 8002ff8:	ea20 000e 	bic.w	r0, r0, lr
 8002ffc:	6358      	str	r0, [r3, #52]	; 0x34
        CLEAR_IN_EP_INTR(epnum, xfercompl);
        /* TX COMPLETE */
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 8002ffe:	684b      	ldr	r3, [r1, #4]
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
      {
        fifoemptymsk = 0x1 << epnum;
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
        CLEAR_IN_EP_INTR(epnum, xfercompl);
 8003000:	6095      	str	r5, [r2, #8]
        /* TX COMPLETE */
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 8003002:	4640      	mov	r0, r8
 8003004:	4631      	mov	r1, r6
 8003006:	4798      	blx	r3
        
        if (pdev->cfg.dma_enable == 1)
 8003008:	f898 9003 	ldrb.w	r9, [r8, #3]
 800300c:	45a9      	cmp	r9, r5
 800300e:	f47f ae35 	bne.w	8002c7c <USBD_OTG_ISR_Handler+0x164>
        {
          if((epnum == 0) && (pdev->dev.device_state == USB_OTG_EP0_STATUS_IN))
 8003012:	f1bb 0f00 	cmp.w	fp, #0
 8003016:	d104      	bne.n	8003022 <USBD_OTG_ISR_Handler+0x50a>
 8003018:	f898 c111 	ldrb.w	ip, [r8, #273]	; 0x111
 800301c:	f1bc 0f04 	cmp.w	ip, #4
 8003020:	d001      	beq.n	8003026 <USBD_OTG_ISR_Handler+0x50e>
          {
            /* prepare to rx more setup packets */
            USB_OTG_EP0_OutStart(pdev);
 8003022:	464d      	mov	r5, r9
 8003024:	e62a      	b.n	8002c7c <USBD_OTG_ISR_Handler+0x164>
 8003026:	4640      	mov	r0, r8
 8003028:	f7ff fac2 	bl	80025b0 <USB_OTG_EP0_OutStart>
 800302c:	464d      	mov	r5, r9
 800302e:	e625      	b.n	8002c7c <USBD_OTG_ISR_Handler+0x164>
        /* RX COMPLETE */
        USBD_DCD_INT_fops->DataOutStage(pdev , epnum);
        
        if (pdev->cfg.dma_enable == 1)
        {
          if((epnum == 0) && (pdev->dev.device_state == USB_OTG_EP0_STATUS_OUT))
 8003030:	b927      	cbnz	r7, 800303c <USBD_OTG_ISR_Handler+0x524>
 8003032:	f896 e111 	ldrb.w	lr, [r6, #273]	; 0x111
 8003036:	f1be 0f05 	cmp.w	lr, #5
 800303a:	d001      	beq.n	8003040 <USBD_OTG_ISR_Handler+0x528>
          {
            /* prepare to rx more setup packets */
            USB_OTG_EP0_OutStart(pdev);
 800303c:	4648      	mov	r0, r9
 800303e:	e6cf      	b.n	8002de0 <USBD_OTG_ISR_Handler+0x2c8>
 8003040:	4630      	mov	r0, r6
 8003042:	f7ff fab5 	bl	80025b0 <USB_OTG_EP0_OutStart>
 8003046:	4648      	mov	r0, r9
 8003048:	e6ca      	b.n	8002de0 <USBD_OTG_ISR_Handler+0x2c8>
      {
        /* Clear the bit in DOEPINTn for this interrupt */
        CLEAR_OUT_EP_INTR(epnum, xfercompl);
        if (pdev->cfg.dma_enable == 1)
        {
          deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[epnum]->DOEPTSIZ));
 800304a:	691a      	ldr	r2, [r3, #16]
          /*ToDo : handle more than one single MPS size packet */
          pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
 800304c:	f8d8 1378 	ldr.w	r1, [r8, #888]	; 0x378
            deptsiz.b.xfersize;
 8003050:	f3c2 0c12 	ubfx	ip, r2, #0, #19
        CLEAR_OUT_EP_INTR(epnum, xfercompl);
        if (pdev->cfg.dma_enable == 1)
        {
          deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[epnum]->DOEPTSIZ));
          /*ToDo : handle more than one single MPS size packet */
          pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
 8003054:	ebcc 0301 	rsb	r3, ip, r1
 8003058:	f8c8 3388 	str.w	r3, [r8, #904]	; 0x388
 800305c:	e6b3      	b.n	8002dc6 <USBD_OTG_ISR_Handler+0x2ae>
 800305e:	bf00      	nop
 8003060:	20000148 	.word	0x20000148
 8003064:	e000ed00 	.word	0xe000ed00

08003068 <USBD_Resume>:
*/

static uint8_t USBD_Resume(USB_OTG_CORE_HANDLE  *pdev)
{
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceResumed(); 
 8003068:	f8d0 15e4 	ldr.w	r1, [r0, #1508]	; 0x5e4
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Resume(USB_OTG_CORE_HANDLE  *pdev)
{
 800306c:	b510      	push	{r4, lr}
 800306e:	4604      	mov	r4, r0
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceResumed(); 
 8003070:	6908      	ldr	r0, [r1, #16]
 8003072:	4780      	blx	r0
  pdev->dev.device_status = USB_OTG_CONFIGURED;  
 8003074:	2303      	movs	r3, #3
 8003076:	f884 3112 	strb.w	r3, [r4, #274]	; 0x112
  return USBD_OK;
}
 800307a:	2000      	movs	r0, #0
 800307c:	bd10      	pop	{r4, pc}
 800307e:	bf00      	nop

08003080 <USBD_Suspend>:
static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev)
{
  
  pdev->dev.device_status  = USB_OTG_SUSPENDED;
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceSuspended(); 
 8003080:	f8d0 15e4 	ldr.w	r1, [r0, #1508]	; 0x5e4
*/

static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev)
{
  
  pdev->dev.device_status  = USB_OTG_SUSPENDED;
 8003084:	2204      	movs	r2, #4
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev)
{
 8003086:	b508      	push	{r3, lr}
  
  pdev->dev.device_status  = USB_OTG_SUSPENDED;
 8003088:	f880 2112 	strb.w	r2, [r0, #274]	; 0x112
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceSuspended(); 
 800308c:	68cb      	ldr	r3, [r1, #12]
 800308e:	4798      	blx	r3
  return USBD_OK;
}
 8003090:	2000      	movs	r0, #0
 8003092:	bd08      	pop	{r3, pc}

08003094 <USBD_SOF>:
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_SOF(USB_OTG_CORE_HANDLE  *pdev)
{
 8003094:	b508      	push	{r3, lr}
  if(pdev->dev.class_cb->SOF)
 8003096:	f8d0 35e0 	ldr.w	r3, [r0, #1504]	; 0x5e0
 800309a:	69db      	ldr	r3, [r3, #28]
 800309c:	b103      	cbz	r3, 80030a0 <USBD_SOF+0xc>
  {
    pdev->dev.class_cb->SOF(pdev); 
 800309e:	4798      	blx	r3
  }
  return USBD_OK;
}
 80030a0:	2000      	movs	r0, #0
 80030a2:	bd08      	pop	{r3, pc}

080030a4 <USBD_IsoINIncomplete>:
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoINIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
  pdev->dev.class_cb->IsoINIncomplete(pdev);   
 80030a4:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
*         Handle iso in incomplete event
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoINIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
 80030a8:	b508      	push	{r3, lr}
  pdev->dev.class_cb->IsoINIncomplete(pdev);   
 80030aa:	6a0b      	ldr	r3, [r1, #32]
 80030ac:	4798      	blx	r3
  return USBD_OK;
}
 80030ae:	2000      	movs	r0, #0
 80030b0:	bd08      	pop	{r3, pc}
 80030b2:	bf00      	nop

080030b4 <USBD_IsoOUTIncomplete>:
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoOUTIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
  pdev->dev.class_cb->IsoOUTIncomplete(pdev);   
 80030b4:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
*         Handle iso out incomplete event
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoOUTIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
 80030b8:	b508      	push	{r3, lr}
  pdev->dev.class_cb->IsoOUTIncomplete(pdev);   
 80030ba:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 80030bc:	4798      	blx	r3
  return USBD_OK;
}
 80030be:	2000      	movs	r0, #0
 80030c0:	bd08      	pop	{r3, pc}
 80030c2:	bf00      	nop

080030c4 <USBD_Reset>:
*/

static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
{
  /* Open EP0 OUT */
  DCD_EP_Open(pdev,
 80030c4:	2100      	movs	r1, #0
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
{
 80030c6:	b510      	push	{r4, lr}
  /* Open EP0 OUT */
  DCD_EP_Open(pdev,
 80030c8:	460b      	mov	r3, r1
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
{
 80030ca:	4604      	mov	r4, r0
  /* Open EP0 OUT */
  DCD_EP_Open(pdev,
 80030cc:	2240      	movs	r2, #64	; 0x40
 80030ce:	f7ff fc13 	bl	80028f8 <DCD_EP_Open>
              0x00,
              USB_OTG_MAX_EP0_SIZE,
              EP_TYPE_CTRL);
  
  /* Open EP0 IN */
  DCD_EP_Open(pdev,
 80030d2:	2180      	movs	r1, #128	; 0x80
 80030d4:	2240      	movs	r2, #64	; 0x40
 80030d6:	2300      	movs	r3, #0
 80030d8:	4620      	mov	r0, r4
 80030da:	f7ff fc0d 	bl	80028f8 <DCD_EP_Open>
              USB_OTG_MAX_EP0_SIZE,
              EP_TYPE_CTRL);
  
  /* Upon Reset call usr call back */
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.usr_cb->DeviceReset(pdev->cfg.speed);
 80030de:	f8d4 15e4 	ldr.w	r1, [r4, #1508]	; 0x5e4
 80030e2:	78a0      	ldrb	r0, [r4, #2]
              0x80,
              USB_OTG_MAX_EP0_SIZE,
              EP_TYPE_CTRL);
  
  /* Upon Reset call usr call back */
  pdev->dev.device_status = USB_OTG_DEFAULT;
 80030e4:	2201      	movs	r2, #1
 80030e6:	f884 2112 	strb.w	r2, [r4, #274]	; 0x112
  pdev->dev.usr_cb->DeviceReset(pdev->cfg.speed);
 80030ea:	684b      	ldr	r3, [r1, #4]
 80030ec:	4798      	blx	r3
  
  return USBD_OK;
}
 80030ee:	2000      	movs	r0, #0
 80030f0:	bd10      	pop	{r4, pc}
 80030f2:	bf00      	nop

080030f4 <USBD_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_SetupStage(USB_OTG_CORE_HANDLE *pdev)
{
 80030f4:	b510      	push	{r4, lr}
 80030f6:	b082      	sub	sp, #8
  USB_SETUP_REQ req;
  
  USBD_ParseSetupRequest(pdev , &req);
 80030f8:	4669      	mov	r1, sp
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_SetupStage(USB_OTG_CORE_HANDLE *pdev)
{
 80030fa:	4604      	mov	r4, r0
  USB_SETUP_REQ req;
  
  USBD_ParseSetupRequest(pdev , &req);
 80030fc:	f000 f93c 	bl	8003378 <USBD_ParseSetupRequest>
  
  switch (req.bmRequest & 0x1F) 
 8003100:	f89d 1000 	ldrb.w	r1, [sp]
 8003104:	f001 031f 	and.w	r3, r1, #31
 8003108:	2b01      	cmp	r3, #1
 800310a:	d014      	beq.n	8003136 <USBD_SetupStage+0x42>
 800310c:	2b02      	cmp	r3, #2
 800310e:	d00d      	beq.n	800312c <USBD_SetupStage+0x38>
 8003110:	b13b      	cbz	r3, 8003122 <USBD_SetupStage+0x2e>
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &req);   
    break;
    
  default:           
    DCD_EP_Stall(pdev , req.bmRequest & 0x80);
 8003112:	4620      	mov	r0, r4
 8003114:	f001 0180 	and.w	r1, r1, #128	; 0x80
 8003118:	f7ff fc70 	bl	80029fc <DCD_EP_Stall>
    break;
  }  
  return USBD_OK;
}
 800311c:	2000      	movs	r0, #0
 800311e:	b002      	add	sp, #8
 8003120:	bd10      	pop	{r4, pc}
  USBD_ParseSetupRequest(pdev , &req);
  
  switch (req.bmRequest & 0x1F) 
  {
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &req);
 8003122:	4620      	mov	r0, r4
 8003124:	4669      	mov	r1, sp
 8003126:	f000 f9f1 	bl	800350c <USBD_StdDevReq>
    break;
 800312a:	e7f7      	b.n	800311c <USBD_SetupStage+0x28>
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &req);
    break;
    
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &req);   
 800312c:	4620      	mov	r0, r4
 800312e:	4669      	mov	r1, sp
 8003130:	f000 f960 	bl	80033f4 <USBD_StdEPReq>
    break;
 8003134:	e7f2      	b.n	800311c <USBD_SetupStage+0x28>
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &req);
    break;
    
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &req);
 8003136:	4620      	mov	r0, r4
 8003138:	4669      	mov	r1, sp
 800313a:	f000 f9cd 	bl	80034d8 <USBD_StdItfReq>
    break;
 800313e:	e7ed      	b.n	800311c <USBD_SetupStage+0x28>

08003140 <USBD_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
static uint8_t USBD_DataInStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
 8003140:	b538      	push	{r3, r4, r5, lr}
 8003142:	4604      	mov	r4, r0
  USB_OTG_EP *ep;
  
  if(epnum == 0) 
 8003144:	b929      	cbnz	r1, 8003152 <USBD_DataInStage+0x12>
  {
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
 8003146:	f890 3111 	ldrb.w	r3, [r0, #273]	; 0x111
 800314a:	2b02      	cmp	r3, #2
 800314c:	d00d      	beq.n	800316a <USBD_DataInStage+0x2a>
          (pdev->dev.device_status == USB_OTG_CONFIGURED))
  {
    pdev->dev.class_cb->DataIn(pdev, epnum); 
  }  
  return USBD_OK;
}
 800314e:	2000      	movs	r0, #0
 8003150:	bd38      	pop	{r3, r4, r5, pc}
          USBD_CtlReceiveStatus(pdev);
        }
      }
    }
  }
  else if((pdev->dev.class_cb->DataIn != NULL)&& 
 8003152:	f8d0 25e0 	ldr.w	r2, [r0, #1504]	; 0x5e0
 8003156:	6953      	ldr	r3, [r2, #20]
 8003158:	2b00      	cmp	r3, #0
 800315a:	d0f8      	beq.n	800314e <USBD_DataInStage+0xe>
 800315c:	f890 c112 	ldrb.w	ip, [r0, #274]	; 0x112
 8003160:	f1bc 0f03 	cmp.w	ip, #3
 8003164:	d1f3      	bne.n	800314e <USBD_DataInStage+0xe>
          (pdev->dev.device_status == USB_OTG_CONFIGURED))
  {
    pdev->dev.class_cb->DataIn(pdev, epnum); 
 8003166:	4798      	blx	r3
 8003168:	e7f1      	b.n	800314e <USBD_DataInStage+0xe>
  if(epnum == 0) 
  {
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
    {
      if(ep->rem_data_len > ep->maxpacket)
 800316a:	f8d0 2134 	ldr.w	r2, [r0, #308]	; 0x134
 800316e:	f8d0 3120 	ldr.w	r3, [r0, #288]	; 0x120
 8003172:	429a      	cmp	r2, r3
 8003174:	d910      	bls.n	8003198 <USBD_DataInStage+0x58>
      {
        ep->rem_data_len -=  ep->maxpacket;
        if(pdev->cfg.dma_enable == 1)
 8003176:	78c1      	ldrb	r1, [r0, #3]
 8003178:	2901      	cmp	r1, #1
 800317a:	f8d0 1124 	ldr.w	r1, [r0, #292]	; 0x124
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 800317e:	ebc3 0202 	rsb	r2, r3, r2
        if(pdev->cfg.dma_enable == 1)
        {
          /* in slave mode this, is handled by the TxFifoEmpty ISR */
          ep->xfer_buff += ep->maxpacket;
 8003182:	bf08      	it	eq
 8003184:	18c9      	addeq	r1, r1, r3
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 8003186:	f8c0 2134 	str.w	r2, [r0, #308]	; 0x134
        if(pdev->cfg.dma_enable == 1)
        {
          /* in slave mode this, is handled by the TxFifoEmpty ISR */
          ep->xfer_buff += ep->maxpacket;
 800318a:	bf08      	it	eq
 800318c:	f8c0 1124 	streq.w	r1, [r0, #292]	; 0x124
        }
        USBD_CtlContinueSendData (pdev, 
 8003190:	b292      	uxth	r2, r2
 8003192:	f000 f8a5 	bl	80032e0 <USBD_CtlContinueSendData>
 8003196:	e7da      	b.n	800314e <USBD_DataInStage+0xe>
                                  ep->xfer_buff, 
                                  ep->rem_data_len);
      }
      else
      { /* last packet is MPS multiple, so send ZLP packet */
        if((ep->total_data_len % ep->maxpacket == 0) &&
 8003198:	f8d0 2138 	ldr.w	r2, [r0, #312]	; 0x138
 800319c:	fbb2 f5f3 	udiv	r5, r2, r3
 80031a0:	fb03 2515 	mls	r5, r3, r5, r2
 80031a4:	b95d      	cbnz	r5, 80031be <USBD_DataInStage+0x7e>
 80031a6:	4293      	cmp	r3, r2
 80031a8:	d809      	bhi.n	80031be <USBD_DataInStage+0x7e>
           (ep->total_data_len >= ep->maxpacket) &&
 80031aa:	f8d0 313c 	ldr.w	r3, [r0, #316]	; 0x13c
 80031ae:	429a      	cmp	r2, r3
 80031b0:	d205      	bcs.n	80031be <USBD_DataInStage+0x7e>
             (ep->total_data_len < ep->ctl_data_len ))
        {
          
          USBD_CtlContinueSendData(pdev , NULL, 0);
 80031b2:	462a      	mov	r2, r5
 80031b4:	f000 f894 	bl	80032e0 <USBD_CtlContinueSendData>
          ep->ctl_data_len = 0;
 80031b8:	f8c4 513c 	str.w	r5, [r4, #316]	; 0x13c
 80031bc:	e7c7      	b.n	800314e <USBD_DataInStage+0xe>
        }
        else
        {
          if((pdev->dev.class_cb->EP0_TxSent != NULL)&&
 80031be:	f8d4 05e0 	ldr.w	r0, [r4, #1504]	; 0x5e0
 80031c2:	68c3      	ldr	r3, [r0, #12]
 80031c4:	b123      	cbz	r3, 80031d0 <USBD_DataInStage+0x90>
 80031c6:	f894 c112 	ldrb.w	ip, [r4, #274]	; 0x112
 80031ca:	f1bc 0f03 	cmp.w	ip, #3
 80031ce:	d003      	beq.n	80031d8 <USBD_DataInStage+0x98>
             (pdev->dev.device_status == USB_OTG_CONFIGURED))
          {
            pdev->dev.class_cb->EP0_TxSent(pdev); 
          }          
          USBD_CtlReceiveStatus(pdev);
 80031d0:	4620      	mov	r0, r4
 80031d2:	f000 f8b9 	bl	8003348 <USBD_CtlReceiveStatus>
 80031d6:	e7ba      	b.n	800314e <USBD_DataInStage+0xe>
        else
        {
          if((pdev->dev.class_cb->EP0_TxSent != NULL)&&
             (pdev->dev.device_status == USB_OTG_CONFIGURED))
          {
            pdev->dev.class_cb->EP0_TxSent(pdev); 
 80031d8:	4620      	mov	r0, r4
 80031da:	4798      	blx	r3
 80031dc:	e7f8      	b.n	80031d0 <USBD_DataInStage+0x90>
 80031de:	bf00      	nop

080031e0 <USBD_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
static uint8_t USBD_DataOutStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
 80031e0:	b510      	push	{r4, lr}
 80031e2:	4604      	mov	r4, r0
  USB_OTG_EP *ep;
  
  if(epnum == 0) 
 80031e4:	b929      	cbnz	r1, 80031f2 <USBD_DataOutStage+0x12>
  {
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
 80031e6:	f890 3111 	ldrb.w	r3, [r0, #273]	; 0x111
 80031ea:	2b03      	cmp	r3, #3
 80031ec:	d00d      	beq.n	800320a <USBD_DataOutStage+0x2a>
          (pdev->dev.device_status == USB_OTG_CONFIGURED))
  {
    pdev->dev.class_cb->DataOut(pdev, epnum); 
  }  
  return USBD_OK;
}
 80031ee:	2000      	movs	r0, #0
 80031f0:	bd10      	pop	{r4, pc}
        }
        USBD_CtlSendStatus(pdev);
      }
    }
  }
  else if((pdev->dev.class_cb->DataOut != NULL)&&
 80031f2:	f8d0 25e0 	ldr.w	r2, [r0, #1504]	; 0x5e0
 80031f6:	6993      	ldr	r3, [r2, #24]
 80031f8:	2b00      	cmp	r3, #0
 80031fa:	d0f8      	beq.n	80031ee <USBD_DataOutStage+0xe>
 80031fc:	f890 c112 	ldrb.w	ip, [r0, #274]	; 0x112
 8003200:	f1bc 0f03 	cmp.w	ip, #3
 8003204:	d1f3      	bne.n	80031ee <USBD_DataOutStage+0xe>
          (pdev->dev.device_status == USB_OTG_CONFIGURED))
  {
    pdev->dev.class_cb->DataOut(pdev, epnum); 
 8003206:	4798      	blx	r3
 8003208:	e7f1      	b.n	80031ee <USBD_DataOutStage+0xe>
  if(epnum == 0) 
  {
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
    {
      if(ep->rem_data_len > ep->maxpacket)
 800320a:	f8d0 238c 	ldr.w	r2, [r0, #908]	; 0x38c
 800320e:	f8d0 3378 	ldr.w	r3, [r0, #888]	; 0x378
 8003212:	429a      	cmp	r2, r3
 8003214:	d912      	bls.n	800323c <USBD_DataOutStage+0x5c>
      {
        ep->rem_data_len -=  ep->maxpacket;
        
        if(pdev->cfg.dma_enable == 1)
 8003216:	78c1      	ldrb	r1, [r0, #3]
 8003218:	2901      	cmp	r1, #1
 800321a:	f8d0 137c 	ldr.w	r1, [r0, #892]	; 0x37c
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 800321e:	ebc3 0202 	rsb	r2, r3, r2
        
        if(pdev->cfg.dma_enable == 1)
        {
          /* in slave mode this, is handled by the RxSTSQLvl ISR */
          ep->xfer_buff += ep->maxpacket; 
 8003222:	bf04      	itt	eq
 8003224:	18c9      	addeq	r1, r1, r3
 8003226:	f8c0 137c 	streq.w	r1, [r0, #892]	; 0x37c
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 800322a:	f8c0 238c 	str.w	r2, [r0, #908]	; 0x38c
          /* in slave mode this, is handled by the RxSTSQLvl ISR */
          ep->xfer_buff += ep->maxpacket; 
        }        
        USBD_CtlContinueRx (pdev, 
                            ep->xfer_buff,
                            MIN(ep->rem_data_len ,ep->maxpacket));
 800322e:	429a      	cmp	r2, r3
 8003230:	bf28      	it	cs
 8003232:	461a      	movcs	r2, r3
        if(pdev->cfg.dma_enable == 1)
        {
          /* in slave mode this, is handled by the RxSTSQLvl ISR */
          ep->xfer_buff += ep->maxpacket; 
        }        
        USBD_CtlContinueRx (pdev, 
 8003234:	b292      	uxth	r2, r2
 8003236:	f000 f86d 	bl	8003314 <USBD_CtlContinueRx>
 800323a:	e7d8      	b.n	80031ee <USBD_DataOutStage+0xe>
                            ep->xfer_buff,
                            MIN(ep->rem_data_len ,ep->maxpacket));
      }
      else
      {
        if((pdev->dev.class_cb->EP0_RxReady != NULL)&&
 800323c:	f8d0 35e0 	ldr.w	r3, [r0, #1504]	; 0x5e0
 8003240:	691b      	ldr	r3, [r3, #16]
 8003242:	b123      	cbz	r3, 800324e <USBD_DataOutStage+0x6e>
 8003244:	f890 c112 	ldrb.w	ip, [r0, #274]	; 0x112
 8003248:	f1bc 0f03 	cmp.w	ip, #3
 800324c:	d003      	beq.n	8003256 <USBD_DataOutStage+0x76>
           (pdev->dev.device_status == USB_OTG_CONFIGURED))
        {
          pdev->dev.class_cb->EP0_RxReady(pdev); 
        }
        USBD_CtlSendStatus(pdev);
 800324e:	4620      	mov	r0, r4
 8003250:	f000 f86a 	bl	8003328 <USBD_CtlSendStatus>
 8003254:	e7cb      	b.n	80031ee <USBD_DataOutStage+0xe>
      else
      {
        if((pdev->dev.class_cb->EP0_RxReady != NULL)&&
           (pdev->dev.device_status == USB_OTG_CONFIGURED))
        {
          pdev->dev.class_cb->EP0_RxReady(pdev); 
 8003256:	4798      	blx	r3
 8003258:	e7f9      	b.n	800324e <USBD_DataOutStage+0x6e>
 800325a:	bf00      	nop

0800325c <USBD_Init>:
void USBD_Init(USB_OTG_CORE_HANDLE *pdev,
               USB_OTG_CORE_ID_TypeDef coreID,
               USBD_DEVICE *pDevice,                  
               USBD_Class_cb_TypeDef *class_cb, 
               USBD_Usr_cb_TypeDef *usr_cb)
{
 800325c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003260:	9d06      	ldr	r5, [sp, #24]
 8003262:	4604      	mov	r4, r0
 8003264:	4616      	mov	r6, r2
 8003266:	461f      	mov	r7, r3
 8003268:	4688      	mov	r8, r1
  /* Hardware Init */
  USB_OTG_BSP_Init(pdev);  
 800326a:	f000 fafb 	bl	8003864 <USB_OTG_BSP_Init>
  pdev->dev.class_cb = class_cb;
  pdev->dev.usr_cb = usr_cb;  
  pdev->dev.usr_device = pDevice;    
  
  /* set USB OTG core params */
  DCD_Init(pdev , coreID);
 800326e:	4620      	mov	r0, r4
 8003270:	4641      	mov	r1, r8
  USB_OTG_BSP_Init(pdev);  
  
  USBD_DeInit(pdev);
  
  /*Register class and user callbacks */
  pdev->dev.class_cb = class_cb;
 8003272:	f8c4 75e0 	str.w	r7, [r4, #1504]	; 0x5e0
  pdev->dev.usr_cb = usr_cb;  
 8003276:	f8c4 55e4 	str.w	r5, [r4, #1508]	; 0x5e4
  pdev->dev.usr_device = pDevice;    
 800327a:	f8c4 65e8 	str.w	r6, [r4, #1512]	; 0x5e8
  
  /* set USB OTG core params */
  DCD_Init(pdev , coreID);
 800327e:	f7ff fa7f 	bl	8002780 <DCD_Init>
  
  /* Upon Init call usr callback */
  pdev->dev.usr_cb->Init();
 8003282:	f8d4 05e4 	ldr.w	r0, [r4, #1508]	; 0x5e4
 8003286:	6803      	ldr	r3, [r0, #0]
 8003288:	4798      	blx	r3
  
  /* Enable Interrupts */
  USB_OTG_BSP_EnableInterrupt(pdev);
 800328a:	4620      	mov	r0, r4
}
 800328c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  
  /* Upon Init call usr callback */
  pdev->dev.usr_cb->Init();
  
  /* Enable Interrupts */
  USB_OTG_BSP_EnableInterrupt(pdev);
 8003290:	f000 bb3a 	b.w	8003908 <USB_OTG_BSP_EnableInterrupt>

08003294 <USBD_DeInit>:
USBD_Status USBD_DeInit(USB_OTG_CORE_HANDLE *pdev)
{
  /* Software Init */
  
  return USBD_OK;
}
 8003294:	2000      	movs	r0, #0
 8003296:	4770      	bx	lr

08003298 <USBD_SetCfg>:
* @retval status
*/

USBD_Status USBD_SetCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
  pdev->dev.class_cb->Init(pdev, cfgidx); 
 8003298:	f8d0 35e0 	ldr.w	r3, [r0, #1504]	; 0x5e0
* @param  cfgidx: configuration index
* @retval status
*/

USBD_Status USBD_SetCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
 800329c:	b510      	push	{r4, lr}
 800329e:	4604      	mov	r4, r0
  pdev->dev.class_cb->Init(pdev, cfgidx); 
 80032a0:	681a      	ldr	r2, [r3, #0]
 80032a2:	4790      	blx	r2
  
  /* Upon set config call usr call back */
  pdev->dev.usr_cb->DeviceConfigured();
 80032a4:	f8d4 05e4 	ldr.w	r0, [r4, #1508]	; 0x5e4
 80032a8:	6883      	ldr	r3, [r0, #8]
 80032aa:	4798      	blx	r3
  return USBD_OK; 
}
 80032ac:	2000      	movs	r0, #0
 80032ae:	bd10      	pop	{r4, pc}

080032b0 <USBD_ClrCfg>:
* @param  cfgidx: configuration index
* @retval status: USBD_Status
*/
USBD_Status USBD_ClrCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
  pdev->dev.class_cb->DeInit(pdev, cfgidx);   
 80032b0:	f8d0 25e0 	ldr.w	r2, [r0, #1504]	; 0x5e0
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_Status
*/
USBD_Status USBD_ClrCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
 80032b4:	b508      	push	{r3, lr}
  pdev->dev.class_cb->DeInit(pdev, cfgidx);   
 80032b6:	6853      	ldr	r3, [r2, #4]
 80032b8:	4798      	blx	r3
  return USBD_OK;
}
 80032ba:	2000      	movs	r0, #0
 80032bc:	bd08      	pop	{r3, pc}
 80032be:	bf00      	nop

080032c0 <USBD_CtlSendData>:
* @retval status
*/
USBD_Status  USBD_CtlSendData (USB_OTG_CORE_HANDLE  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 80032c0:	4613      	mov	r3, r2
 80032c2:	460a      	mov	r2, r1
  USBD_Status ret = USBD_OK;
  
  pdev->dev.in_ep[0].total_data_len = len;
  pdev->dev.in_ep[0].rem_data_len   = len;
  pdev->dev.device_state = USB_OTG_EP0_DATA_IN;
 80032c4:	2102      	movs	r1, #2
* @retval status
*/
USBD_Status  USBD_CtlSendData (USB_OTG_CORE_HANDLE  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 80032c6:	b510      	push	{r4, lr}
  USBD_Status ret = USBD_OK;
  
  pdev->dev.in_ep[0].total_data_len = len;
 80032c8:	f8c0 3138 	str.w	r3, [r0, #312]	; 0x138
  pdev->dev.in_ep[0].rem_data_len   = len;
 80032cc:	f8c0 3134 	str.w	r3, [r0, #308]	; 0x134
  pdev->dev.device_state = USB_OTG_EP0_DATA_IN;
 80032d0:	f880 1111 	strb.w	r1, [r0, #273]	; 0x111

  DCD_EP_Tx (pdev, 0, pbuf, len);
 80032d4:	2100      	movs	r1, #0
 80032d6:	f7ff fb6f 	bl	80029b8 <DCD_EP_Tx>
 
  return ret;
}
 80032da:	2000      	movs	r0, #0
 80032dc:	bd10      	pop	{r4, pc}
 80032de:	bf00      	nop

080032e0 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_Status  USBD_CtlContinueSendData (USB_OTG_CORE_HANDLE  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 80032e0:	b510      	push	{r4, lr}
 80032e2:	460c      	mov	r4, r1
 80032e4:	4613      	mov	r3, r2
  USBD_Status ret = USBD_OK;
  
  DCD_EP_Tx (pdev, 0, pbuf, len);
 80032e6:	2100      	movs	r1, #0
 80032e8:	4622      	mov	r2, r4
 80032ea:	f7ff fb65 	bl	80029b8 <DCD_EP_Tx>
  
  
  return ret;
}
 80032ee:	2000      	movs	r0, #0
 80032f0:	bd10      	pop	{r4, pc}
 80032f2:	bf00      	nop

080032f4 <USBD_CtlPrepareRx>:
* @retval status
*/
USBD_Status  USBD_CtlPrepareRx (USB_OTG_CORE_HANDLE  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
 80032f4:	4613      	mov	r3, r2
 80032f6:	460a      	mov	r2, r1
  USBD_Status ret = USBD_OK;
  
  pdev->dev.out_ep[0].total_data_len = len;
  pdev->dev.out_ep[0].rem_data_len   = len;
  pdev->dev.device_state = USB_OTG_EP0_DATA_OUT;
 80032f8:	2103      	movs	r1, #3
* @retval status
*/
USBD_Status  USBD_CtlPrepareRx (USB_OTG_CORE_HANDLE  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
 80032fa:	b510      	push	{r4, lr}
  USBD_Status ret = USBD_OK;
  
  pdev->dev.out_ep[0].total_data_len = len;
 80032fc:	f8c0 3390 	str.w	r3, [r0, #912]	; 0x390
  pdev->dev.out_ep[0].rem_data_len   = len;
 8003300:	f8c0 338c 	str.w	r3, [r0, #908]	; 0x38c
  pdev->dev.device_state = USB_OTG_EP0_DATA_OUT;
 8003304:	f880 1111 	strb.w	r1, [r0, #273]	; 0x111
  
  DCD_EP_PrepareRx (pdev,
 8003308:	2100      	movs	r1, #0
 800330a:	f7ff fb2b 	bl	8002964 <DCD_EP_PrepareRx>
                    pbuf,
                    len);
  

  return ret;
}
 800330e:	2000      	movs	r0, #0
 8003310:	bd10      	pop	{r4, pc}
 8003312:	bf00      	nop

08003314 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_Status  USBD_CtlContinueRx (USB_OTG_CORE_HANDLE  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 8003314:	b510      	push	{r4, lr}
 8003316:	460c      	mov	r4, r1
 8003318:	4613      	mov	r3, r2
  USBD_Status ret = USBD_OK;
  
  DCD_EP_PrepareRx (pdev,
 800331a:	2100      	movs	r1, #0
 800331c:	4622      	mov	r2, r4
 800331e:	f7ff fb21 	bl	8002964 <DCD_EP_PrepareRx>
                    0,                     
                    pbuf,                         
                    len);
  return ret;
}
 8003322:	2000      	movs	r0, #0
 8003324:	bd10      	pop	{r4, pc}
 8003326:	bf00      	nop

08003328 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 8003328:	b538      	push	{r3, r4, r5, lr}
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
  DCD_EP_Tx (pdev,
 800332a:	2100      	movs	r1, #0
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
 800332c:	2504      	movs	r5, #4
*         send zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 800332e:	4604      	mov	r4, r0
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
  DCD_EP_Tx (pdev,
 8003330:	460a      	mov	r2, r1
 8003332:	460b      	mov	r3, r1
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
 8003334:	f880 5111 	strb.w	r5, [r0, #273]	; 0x111
  DCD_EP_Tx (pdev,
 8003338:	f7ff fb3e 	bl	80029b8 <DCD_EP_Tx>
             0,
             NULL, 
             0); 
  
  USB_OTG_EP0_OutStart(pdev);  
 800333c:	4620      	mov	r0, r4
 800333e:	f7ff f937 	bl	80025b0 <USB_OTG_EP0_OutStart>
  
  return ret;
}
 8003342:	2000      	movs	r0, #0
 8003344:	bd38      	pop	{r3, r4, r5, pc}
 8003346:	bf00      	nop

08003348 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 8003348:	b538      	push	{r3, r4, r5, lr}
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
  DCD_EP_PrepareRx ( pdev,
 800334a:	2100      	movs	r1, #0
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
 800334c:	2505      	movs	r5, #5
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 800334e:	4604      	mov	r4, r0
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
  DCD_EP_PrepareRx ( pdev,
 8003350:	460a      	mov	r2, r1
 8003352:	460b      	mov	r3, r1
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
 8003354:	f880 5111 	strb.w	r5, [r0, #273]	; 0x111
  DCD_EP_PrepareRx ( pdev,
 8003358:	f7ff fb04 	bl	8002964 <DCD_EP_PrepareRx>
                    0,
                    NULL,
                    0);  

  USB_OTG_EP0_OutStart(pdev);
 800335c:	4620      	mov	r0, r4
 800335e:	f7ff f927 	bl	80025b0 <USB_OTG_EP0_OutStart>
  
  return ret;
}
 8003362:	2000      	movs	r0, #0
 8003364:	bd38      	pop	{r3, r4, r5, pc}
 8003366:	bf00      	nop

08003368 <USBD_GetRxCount>:
*         epnum: endpoint index
* @retval Rx Data blength
*/
uint16_t  USBD_GetRxCount (USB_OTG_CORE_HANDLE  *pdev , uint8_t epnum)
{
  return pdev->dev.out_ep[epnum].xfer_count;
 8003368:	eb01 0281 	add.w	r2, r1, r1, lsl #2
 800336c:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
}
 8003370:	f8b1 0388 	ldrh.w	r0, [r1, #904]	; 0x388
 8003374:	4770      	bx	lr
 8003376:	bf00      	nop

08003378 <USBD_ParseSetupRequest>:
*/

void USBD_ParseSetupRequest( USB_OTG_CORE_HANDLE  *pdev,
                            USB_SETUP_REQ *req)
{
  req->bmRequest     = *(uint8_t *)  (pdev->dev.setup_packet);
 8003378:	f890 25c8 	ldrb.w	r2, [r0, #1480]	; 0x5c8
 800337c:	700a      	strb	r2, [r1, #0]
  req->bRequest      = *(uint8_t *)  (pdev->dev.setup_packet +  1);
 800337e:	f890 c5c9 	ldrb.w	ip, [r0, #1481]	; 0x5c9
 8003382:	f881 c001 	strb.w	ip, [r1, #1]
  req->wValue        = SWAPBYTE      (pdev->dev.setup_packet +  2);
 8003386:	f890 35cb 	ldrb.w	r3, [r0, #1483]	; 0x5cb
 800338a:	f890 25ca 	ldrb.w	r2, [r0, #1482]	; 0x5ca
 800338e:	021b      	lsls	r3, r3, #8
 8003390:	eb03 0c02 	add.w	ip, r3, r2
 8003394:	f8a1 c002 	strh.w	ip, [r1, #2]
  req->wIndex        = SWAPBYTE      (pdev->dev.setup_packet +  4);
 8003398:	f890 35cd 	ldrb.w	r3, [r0, #1485]	; 0x5cd
 800339c:	f890 25cc 	ldrb.w	r2, [r0, #1484]	; 0x5cc
 80033a0:	021b      	lsls	r3, r3, #8
 80033a2:	eb03 0c02 	add.w	ip, r3, r2
 80033a6:	f8a1 c004 	strh.w	ip, [r1, #4]
  req->wLength       = SWAPBYTE      (pdev->dev.setup_packet +  6);
 80033aa:	f890 35cf 	ldrb.w	r3, [r0, #1487]	; 0x5cf
 80033ae:	f890 25ce 	ldrb.w	r2, [r0, #1486]	; 0x5ce
 80033b2:	021b      	lsls	r3, r3, #8
 80033b4:	eb03 0c02 	add.w	ip, r3, r2
 80033b8:	fa1f f28c 	uxth.w	r2, ip
  
  pdev->dev.in_ep[0].ctl_data_len = req->wLength  ;
  pdev->dev.device_state = USB_OTG_EP0_SETUP;
 80033bc:	2301      	movs	r3, #1
{
  req->bmRequest     = *(uint8_t *)  (pdev->dev.setup_packet);
  req->bRequest      = *(uint8_t *)  (pdev->dev.setup_packet +  1);
  req->wValue        = SWAPBYTE      (pdev->dev.setup_packet +  2);
  req->wIndex        = SWAPBYTE      (pdev->dev.setup_packet +  4);
  req->wLength       = SWAPBYTE      (pdev->dev.setup_packet +  6);
 80033be:	80ca      	strh	r2, [r1, #6]
  
  pdev->dev.in_ep[0].ctl_data_len = req->wLength  ;
 80033c0:	f8c0 213c 	str.w	r2, [r0, #316]	; 0x13c
  pdev->dev.device_state = USB_OTG_EP0_SETUP;
 80033c4:	f880 3111 	strb.w	r3, [r0, #273]	; 0x111
}
 80033c8:	4770      	bx	lr
 80033ca:	bf00      	nop

080033cc <USBD_CtlError>:
* @retval None
*/

void USBD_CtlError( USB_OTG_CORE_HANDLE  *pdev,
                            USB_SETUP_REQ *req)
{
 80033cc:	b510      	push	{r4, lr}
  if((req->bmRequest & 0x80) == 0x80)
 80033ce:	f991 3000 	ldrsb.w	r3, [r1]
 80033d2:	2b00      	cmp	r3, #0
* @retval None
*/

void USBD_CtlError( USB_OTG_CORE_HANDLE  *pdev,
                            USB_SETUP_REQ *req)
{
 80033d4:	4604      	mov	r4, r0
  if((req->bmRequest & 0x80) == 0x80)
 80033d6:	db09      	blt.n	80033ec <USBD_CtlError+0x20>
  {
    DCD_EP_Stall(pdev , 0x80);
  }
  else 
  {
    if(req->wLength == 0)
 80033d8:	88c9      	ldrh	r1, [r1, #6]
 80033da:	b139      	cbz	r1, 80033ec <USBD_CtlError+0x20>
    {
       DCD_EP_Stall(pdev , 0x80);
    }
    else
    {
      DCD_EP_Stall(pdev , 0);
 80033dc:	2100      	movs	r1, #0
 80033de:	f7ff fb0d 	bl	80029fc <DCD_EP_Stall>
    }
  }
  USB_OTG_EP0_OutStart(pdev);  
 80033e2:	4620      	mov	r0, r4
}
 80033e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    else
    {
      DCD_EP_Stall(pdev , 0);
    }
  }
  USB_OTG_EP0_OutStart(pdev);  
 80033e8:	f7ff b8e2 	b.w	80025b0 <USB_OTG_EP0_OutStart>
  }
  else 
  {
    if(req->wLength == 0)
    {
       DCD_EP_Stall(pdev , 0x80);
 80033ec:	2180      	movs	r1, #128	; 0x80
 80033ee:	f7ff fb05 	bl	80029fc <DCD_EP_Stall>
 80033f2:	e7f6      	b.n	80033e2 <USBD_CtlError+0x16>

080033f4 <USBD_StdEPReq>:
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdEPReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 80033f4:	b538      	push	{r3, r4, r5, lr}
  uint8_t   ep_addr;
  USBD_Status ret = USBD_OK; 
  
  ep_addr  = LOBYTE(req->wIndex);   
  
  switch (req->bRequest) 
 80033f6:	784b      	ldrb	r3, [r1, #1]
{
  
  uint8_t   ep_addr;
  USBD_Status ret = USBD_OK; 
  
  ep_addr  = LOBYTE(req->wIndex);   
 80033f8:	790a      	ldrb	r2, [r1, #4]
  
  switch (req->bRequest) 
 80033fa:	2b01      	cmp	r3, #1
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdEPReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 80033fc:	460c      	mov	r4, r1
 80033fe:	4605      	mov	r5, r0
  uint8_t   ep_addr;
  USBD_Status ret = USBD_OK; 
  
  ep_addr  = LOBYTE(req->wIndex);   
  
  switch (req->bRequest) 
 8003400:	d00e      	beq.n	8003420 <USBD_StdEPReq+0x2c>
 8003402:	d303      	bcc.n	800340c <USBD_StdEPReq+0x18>
 8003404:	2b03      	cmp	r3, #3
 8003406:	d017      	beq.n	8003438 <USBD_StdEPReq+0x44>
    
  default:
    break;
  }
  return ret;
}
 8003408:	2000      	movs	r0, #0
 800340a:	bd38      	pop	{r3, r4, r5, pc}
      break;    
    }
    break;
    
  case USB_REQ_GET_STATUS:                  
    switch (pdev->dev.device_status) 
 800340c:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 8003410:	2b02      	cmp	r3, #2
 8003412:	d009      	beq.n	8003428 <USBD_StdEPReq+0x34>
 8003414:	2b03      	cmp	r3, #3
 8003416:	d03c      	beq.n	8003492 <USBD_StdEPReq+0x9e>
                        (uint8_t *)&USBD_ep_status,
                        2);
      break;
      
    default:                         
       USBD_CtlError(pdev , req);
 8003418:	f7ff ffd8 	bl	80033cc <USBD_CtlError>
    
  default:
    break;
  }
  return ret;
}
 800341c:	2000      	movs	r0, #0
 800341e:	bd38      	pop	{r3, r4, r5, pc}
    }
    break;
    
  case USB_REQ_CLEAR_FEATURE :
    
    switch (pdev->dev.device_status) 
 8003420:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 8003424:	2b02      	cmp	r3, #2
 8003426:	d11f      	bne.n	8003468 <USBD_StdEPReq+0x74>
    
  case USB_REQ_GET_STATUS:                  
    switch (pdev->dev.device_status) 
    {
    case USB_OTG_ADDRESSED:          
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8003428:	2a00      	cmp	r2, #0
 800342a:	d0ed      	beq.n	8003408 <USBD_StdEPReq+0x14>
 800342c:	2a80      	cmp	r2, #128	; 0x80
 800342e:	d0eb      	beq.n	8003408 <USBD_StdEPReq+0x14>
      {
        DCD_EP_Stall(pdev , ep_addr);
 8003430:	4611      	mov	r1, r2
 8003432:	f7ff fae3 	bl	80029fc <DCD_EP_Stall>
 8003436:	e7e7      	b.n	8003408 <USBD_StdEPReq+0x14>
  switch (req->bRequest) 
  {
    
  case USB_REQ_SET_FEATURE :
    
    switch (pdev->dev.device_status) 
 8003438:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 800343c:	2b02      	cmp	r3, #2
 800343e:	d0f3      	beq.n	8003428 <USBD_StdEPReq+0x34>
 8003440:	2b03      	cmp	r3, #3
 8003442:	d1e9      	bne.n	8003418 <USBD_StdEPReq+0x24>
        DCD_EP_Stall(pdev , ep_addr);
      }
      break;	
      
    case USB_OTG_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 8003444:	884b      	ldrh	r3, [r1, #2]
 8003446:	b92b      	cbnz	r3, 8003454 <USBD_StdEPReq+0x60>
      {
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8003448:	b122      	cbz	r2, 8003454 <USBD_StdEPReq+0x60>
 800344a:	2a80      	cmp	r2, #128	; 0x80
 800344c:	d002      	beq.n	8003454 <USBD_StdEPReq+0x60>
        { 
          DCD_EP_Stall(pdev , ep_addr);
 800344e:	4611      	mov	r1, r2
 8003450:	f7ff fad4 	bl	80029fc <DCD_EP_Stall>
          
        }
      }
      pdev->dev.class_cb->Setup (pdev, req);   
 8003454:	f8d5 15e0 	ldr.w	r1, [r5, #1504]	; 0x5e0
 8003458:	4628      	mov	r0, r5
 800345a:	688a      	ldr	r2, [r1, #8]
 800345c:	4621      	mov	r1, r4
 800345e:	4790      	blx	r2
      USBD_CtlSendStatus(pdev);
 8003460:	4628      	mov	r0, r5
 8003462:	f7ff ff61 	bl	8003328 <USBD_CtlSendStatus>
      
      break;
 8003466:	e7cf      	b.n	8003408 <USBD_StdEPReq+0x14>
    }
    break;
    
  case USB_REQ_CLEAR_FEATURE :
    
    switch (pdev->dev.device_status) 
 8003468:	2b03      	cmp	r3, #3
 800346a:	d1d5      	bne.n	8003418 <USBD_StdEPReq+0x24>
        DCD_EP_Stall(pdev , ep_addr);
      }
      break;	
      
    case USB_OTG_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 800346c:	884b      	ldrh	r3, [r1, #2]
 800346e:	2b00      	cmp	r3, #0
 8003470:	d1ca      	bne.n	8003408 <USBD_StdEPReq+0x14>
      {
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8003472:	b152      	cbz	r2, 800348a <USBD_StdEPReq+0x96>
 8003474:	2a80      	cmp	r2, #128	; 0x80
 8003476:	d008      	beq.n	800348a <USBD_StdEPReq+0x96>
        {        
          DCD_EP_ClrStall(pdev , ep_addr);
 8003478:	4611      	mov	r1, r2
 800347a:	f7ff fadf 	bl	8002a3c <DCD_EP_ClrStall>
          pdev->dev.class_cb->Setup (pdev, req);
 800347e:	f8d5 15e0 	ldr.w	r1, [r5, #1504]	; 0x5e0
 8003482:	4628      	mov	r0, r5
 8003484:	688a      	ldr	r2, [r1, #8]
 8003486:	4621      	mov	r1, r4
 8003488:	4790      	blx	r2
        }
        USBD_CtlSendStatus(pdev);
 800348a:	4628      	mov	r0, r5
 800348c:	f7ff ff4c 	bl	8003328 <USBD_CtlSendStatus>
 8003490:	e7ba      	b.n	8003408 <USBD_StdEPReq+0x14>
      break;	
      
    case USB_OTG_CONFIGURED:         
      
      
      if ((ep_addr & 0x80)== 0x80)
 8003492:	f012 0f80 	tst.w	r2, #128	; 0x80
 8003496:	d10e      	bne.n	80034b6 <USBD_StdEPReq+0xc2>
          USBD_ep_status = 0x0000;  
        }
      }
      else if ((ep_addr & 0x80)== 0x00)
      {
        if(pdev->dev.out_ep[ep_addr].is_stall)
 8003498:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800349c:	eb00 03c2 	add.w	r3, r0, r2, lsl #3
 80034a0:	f893 3372 	ldrb.w	r3, [r3, #882]	; 0x372
 80034a4:	b98b      	cbnz	r3, 80034ca <USBD_StdEPReq+0xd6>
          USBD_ep_status = 0x0001;     
        }
        
        else 
        {
          USBD_ep_status = 0x0000;     
 80034a6:	4a0b      	ldr	r2, [pc, #44]	; (80034d4 <USBD_StdEPReq+0xe0>)
 80034a8:	6013      	str	r3, [r2, #0]
        }      
      }
      USBD_CtlSendData (pdev,
 80034aa:	4628      	mov	r0, r5
 80034ac:	4909      	ldr	r1, [pc, #36]	; (80034d4 <USBD_StdEPReq+0xe0>)
 80034ae:	2202      	movs	r2, #2
 80034b0:	f7ff ff06 	bl	80032c0 <USBD_CtlSendData>
                        (uint8_t *)&USBD_ep_status,
                        2);
      break;
 80034b4:	e7a8      	b.n	8003408 <USBD_StdEPReq+0x14>
    case USB_OTG_CONFIGURED:         
      
      
      if ((ep_addr & 0x80)== 0x80)
      {
        if(pdev->dev.in_ep[ep_addr & 0x7F].is_stall)
 80034b6:	f002 0e7f 	and.w	lr, r2, #127	; 0x7f
 80034ba:	eb0e 0c8e 	add.w	ip, lr, lr, lsl #2
 80034be:	eb00 00cc 	add.w	r0, r0, ip, lsl #3
 80034c2:	f890 311a 	ldrb.w	r3, [r0, #282]	; 0x11a
 80034c6:	2b00      	cmp	r3, #0
 80034c8:	d0ed      	beq.n	80034a6 <USBD_StdEPReq+0xb2>
      }
      else if ((ep_addr & 0x80)== 0x00)
      {
        if(pdev->dev.out_ep[ep_addr].is_stall)
        {
          USBD_ep_status = 0x0001;     
 80034ca:	4802      	ldr	r0, [pc, #8]	; (80034d4 <USBD_StdEPReq+0xe0>)
 80034cc:	2101      	movs	r1, #1
 80034ce:	6001      	str	r1, [r0, #0]
 80034d0:	e7eb      	b.n	80034aa <USBD_StdEPReq+0xb6>
 80034d2:	bf00      	nop
 80034d4:	2000080c 	.word	0x2000080c

080034d8 <USBD_StdItfReq>:
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdItfReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 80034d8:	b538      	push	{r3, r4, r5, lr}
  USBD_Status ret = USBD_OK; 
  
  switch (pdev->dev.device_status) 
 80034da:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 80034de:	2b03      	cmp	r3, #3
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdItfReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 80034e0:	4604      	mov	r4, r0
 80034e2:	460d      	mov	r5, r1
  USBD_Status ret = USBD_OK; 
  
  switch (pdev->dev.device_status) 
 80034e4:	d003      	beq.n	80034ee <USBD_StdItfReq+0x16>
       USBD_CtlError(pdev , req);
    }
    break;
    
  default:
     USBD_CtlError(pdev , req);
 80034e6:	f7ff ff71 	bl	80033cc <USBD_CtlError>
    break;
  }
  return ret;
}
 80034ea:	2000      	movs	r0, #0
 80034ec:	bd38      	pop	{r3, r4, r5, pc}
  
  switch (pdev->dev.device_status) 
  {
  case USB_OTG_CONFIGURED:
    
    if (LOBYTE(req->wIndex) <= USBD_ITF_MAX_NUM) 
 80034ee:	790a      	ldrb	r2, [r1, #4]
 80034f0:	2a01      	cmp	r2, #1
 80034f2:	d8f8      	bhi.n	80034e6 <USBD_StdItfReq+0xe>
    {
      pdev->dev.class_cb->Setup (pdev, req); 
 80034f4:	f8d0 25e0 	ldr.w	r2, [r0, #1504]	; 0x5e0
 80034f8:	6893      	ldr	r3, [r2, #8]
 80034fa:	4798      	blx	r3
      
      if((req->wLength == 0)&& (ret == USBD_OK))
 80034fc:	88e8      	ldrh	r0, [r5, #6]
 80034fe:	2800      	cmp	r0, #0
 8003500:	d1f3      	bne.n	80034ea <USBD_StdItfReq+0x12>
      {
         USBD_CtlSendStatus(pdev);
 8003502:	4620      	mov	r0, r4
 8003504:	f7ff ff10 	bl	8003328 <USBD_CtlSendStatus>
 8003508:	e7ef      	b.n	80034ea <USBD_StdItfReq+0x12>
 800350a:	bf00      	nop

0800350c <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdDevReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 800350c:	b570      	push	{r4, r5, r6, lr}
  USBD_Status ret = USBD_OK;  
  
  switch (req->bRequest) 
 800350e:	784b      	ldrb	r3, [r1, #1]
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdDevReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 8003510:	b082      	sub	sp, #8
 8003512:	460c      	mov	r4, r1
 8003514:	4605      	mov	r5, r0
  USBD_Status ret = USBD_OK;  
  
  switch (req->bRequest) 
 8003516:	2b09      	cmp	r3, #9
 8003518:	d813      	bhi.n	8003542 <USBD_StdDevReq+0x36>
 800351a:	e8df f003 	tbb	[pc, r3]
 800351e:	2a18      	.short	0x2a18
 8003520:	57124012 	.word	0x57124012
 8003524:	058b1274 	.word	0x058b1274
                           USB_SETUP_REQ *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 8003528:	78a1      	ldrb	r1, [r4, #2]
 800352a:	4e9b      	ldr	r6, [pc, #620]	; (8003798 <USBD_StdDevReq+0x28c>)
  
  if (cfgidx > USBD_CFG_MAX_NUM ) 
 800352c:	2901      	cmp	r1, #1
                           USB_SETUP_REQ *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 800352e:	7131      	strb	r1, [r6, #4]
  
  if (cfgidx > USBD_CFG_MAX_NUM ) 
 8003530:	d807      	bhi.n	8003542 <USBD_StdDevReq+0x36>
  {            
     USBD_CtlError(pdev , req);                              
  } 
  else 
  {
    switch (pdev->dev.device_status) 
 8003532:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 8003536:	2b02      	cmp	r3, #2
 8003538:	f000 813f 	beq.w	80037ba <USBD_StdDevReq+0x2ae>
 800353c:	2b03      	cmp	r3, #3
 800353e:	f000 80cd 	beq.w	80036dc <USBD_StdDevReq+0x1d0>
  case USB_REQ_CLEAR_FEATURE:                                   
    USBD_ClrFeature (pdev , req);
    break;
    
  default:  
    USBD_CtlError(pdev , req);
 8003542:	4621      	mov	r1, r4
 8003544:	f7ff ff42 	bl	80033cc <USBD_CtlError>
    break;
  }
  
  return ret;
}
 8003548:	2000      	movs	r0, #0
 800354a:	b002      	add	sp, #8
 800354c:	bd70      	pop	{r4, r5, r6, pc}
*/
static void USBD_GetStatus(USB_OTG_CORE_HANDLE  *pdev, 
                           USB_SETUP_REQ *req)
{
  
  switch (pdev->dev.device_status) 
 800354e:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 8003552:	1e99      	subs	r1, r3, #2
 8003554:	2901      	cmp	r1, #1
 8003556:	d8f4      	bhi.n	8003542 <USBD_StdDevReq+0x36>
  {
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    
    if (pdev->dev.DevRemoteWakeup) 
 8003558:	f8d0 0114 	ldr.w	r0, [r0, #276]	; 0x114
 800355c:	2800      	cmp	r0, #0
 800355e:	d17e      	bne.n	800365e <USBD_StdDevReq+0x152>
    {
      USBD_cfg_status = USB_CONFIG_SELF_POWERED | USB_CONFIG_REMOTE_WAKEUP;                                
    }
    else
    {
      USBD_cfg_status = USB_CONFIG_SELF_POWERED;   
 8003560:	4b8d      	ldr	r3, [pc, #564]	; (8003798 <USBD_StdDevReq+0x28c>)
 8003562:	2001      	movs	r0, #1
 8003564:	60d8      	str	r0, [r3, #12]
    }
    
    USBD_CtlSendData (pdev, 
 8003566:	4628      	mov	r0, r5
 8003568:	498c      	ldr	r1, [pc, #560]	; (800379c <USBD_StdDevReq+0x290>)
 800356a:	2201      	movs	r2, #1
 800356c:	f7ff fea8 	bl	80032c0 <USBD_CtlSendData>
 8003570:	e7ea      	b.n	8003548 <USBD_StdDevReq+0x3c>
* @retval status
*/
static void USBD_ClrFeature(USB_OTG_CORE_HANDLE  *pdev, 
                            USB_SETUP_REQ *req)
{
  switch (pdev->dev.device_status)
 8003572:	f890 2112 	ldrb.w	r2, [r0, #274]	; 0x112
 8003576:	1e91      	subs	r1, r2, #2
 8003578:	2901      	cmp	r1, #1
 800357a:	d8e2      	bhi.n	8003542 <USBD_StdDevReq+0x36>
  {
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 800357c:	f8b4 c002 	ldrh.w	ip, [r4, #2]
 8003580:	f1bc 0f01 	cmp.w	ip, #1
 8003584:	d1e0      	bne.n	8003548 <USBD_StdDevReq+0x3c>
    {
      pdev->dev.DevRemoteWakeup = 0; 
      pdev->dev.class_cb->Setup (pdev, req);   
 8003586:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
  {
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
    {
      pdev->dev.DevRemoteWakeup = 0; 
 800358a:	2200      	movs	r2, #0
      pdev->dev.class_cb->Setup (pdev, req);   
 800358c:	688b      	ldr	r3, [r1, #8]
  {
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
    {
      pdev->dev.DevRemoteWakeup = 0; 
 800358e:	f8c0 2114 	str.w	r2, [r0, #276]	; 0x114
      pdev->dev.class_cb->Setup (pdev, req);   
 8003592:	4621      	mov	r1, r4
 8003594:	4798      	blx	r3
      USBD_CtlSendStatus(pdev);
 8003596:	4628      	mov	r0, r5
 8003598:	f7ff fec6 	bl	8003328 <USBD_CtlSendStatus>
 800359c:	e7d4      	b.n	8003548 <USBD_StdDevReq+0x3c>
{

  USB_OTG_DCTL_TypeDef     dctl;
  uint8_t test_mode = 0;
 
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 800359e:	8863      	ldrh	r3, [r4, #2]
 80035a0:	2b01      	cmp	r3, #1
 80035a2:	f000 811c 	beq.w	80037de <USBD_StdDevReq+0x2d2>
    pdev->dev.DevRemoteWakeup = 1;  
    pdev->dev.class_cb->Setup (pdev, req);   
    USBD_CtlSendStatus(pdev);
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
 80035a6:	2b02      	cmp	r3, #2
 80035a8:	d1ce      	bne.n	8003548 <USBD_StdDevReq+0x3c>
           ((req->wIndex & 0xFF) == 0))
 80035aa:	88a3      	ldrh	r3, [r4, #4]
    pdev->dev.DevRemoteWakeup = 1;  
    pdev->dev.class_cb->Setup (pdev, req);   
    USBD_CtlSendStatus(pdev);
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
 80035ac:	f013 0fff 	tst.w	r3, #255	; 0xff
 80035b0:	d1ca      	bne.n	8003548 <USBD_StdDevReq+0x3c>
           ((req->wIndex & 0xFF) == 0))
  {
    dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 80035b2:	6901      	ldr	r1, [r0, #16]
    
    test_mode = req->wIndex >> 8;
    switch (test_mode) 
 80035b4:	0a1c      	lsrs	r4, r3, #8
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
           ((req->wIndex & 0xFF) == 0))
  {
    dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 80035b6:	684a      	ldr	r2, [r1, #4]
    
    test_mode = req->wIndex >> 8;
    switch (test_mode) 
 80035b8:	1e63      	subs	r3, r4, #1
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
           ((req->wIndex & 0xFF) == 0))
  {
    dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 80035ba:	4610      	mov	r0, r2
    
    test_mode = req->wIndex >> 8;
    switch (test_mode) 
 80035bc:	2b04      	cmp	r3, #4
 80035be:	f200 80a4 	bhi.w	800370a <USBD_StdDevReq+0x1fe>
 80035c2:	e8df f003 	tbb	[pc, r3]
 80035c6:	b1a7      	.short	0xb1a7
 80035c8:	b6ac      	.short	0xb6ac
 80035ca:	9e          	.byte	0x9e
 80035cb:	00          	.byte	0x00
static void USBD_SetAddress(USB_OTG_CORE_HANDLE  *pdev, 
                            USB_SETUP_REQ *req)
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 80035cc:	88a3      	ldrh	r3, [r4, #4]
 80035ce:	2b00      	cmp	r3, #0
 80035d0:	d140      	bne.n	8003654 <USBD_StdDevReq+0x148>
 80035d2:	88e2      	ldrh	r2, [r4, #6]
 80035d4:	2a00      	cmp	r2, #0
 80035d6:	d13d      	bne.n	8003654 <USBD_StdDevReq+0x148>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    
    if (pdev->dev.device_status == USB_OTG_CONFIGURED) 
 80035d8:	f890 e112 	ldrb.w	lr, [r0, #274]	; 0x112
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 80035dc:	8862      	ldrh	r2, [r4, #2]
    
    if (pdev->dev.device_status == USB_OTG_CONFIGURED) 
 80035de:	f1be 0f03 	cmp.w	lr, #3
 80035e2:	d0ae      	beq.n	8003542 <USBD_StdDevReq+0x36>
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 80035e4:	f002 047f 	and.w	r4, r2, #127	; 0x7f
    {
      USBD_CtlError(pdev , req);
    } 
    else 
    {
      pdev->dev.device_address = dev_addr;
 80035e8:	f880 4113 	strb.w	r4, [r0, #275]	; 0x113
      DCD_EP_SetAddress(pdev, dev_addr);               
 80035ec:	4621      	mov	r1, r4
 80035ee:	f7ff fa53 	bl	8002a98 <DCD_EP_SetAddress>
      USBD_CtlSendStatus(pdev);                         
 80035f2:	4628      	mov	r0, r5
 80035f4:	f7ff fe98 	bl	8003328 <USBD_CtlSendStatus>
      
      if (dev_addr != 0) 
 80035f8:	2c00      	cmp	r4, #0
 80035fa:	f000 80ec 	beq.w	80037d6 <USBD_StdDevReq+0x2ca>
      {
        pdev->dev.device_status  = USB_OTG_ADDRESSED;
 80035fe:	2002      	movs	r0, #2
 8003600:	f885 0112 	strb.w	r0, [r5, #274]	; 0x112
 8003604:	e7a0      	b.n	8003548 <USBD_StdDevReq+0x3c>
                               USB_SETUP_REQ *req)
{
  uint16_t len;
  uint8_t *pbuf;
  
  switch (req->wValue >> 8)
 8003606:	8862      	ldrh	r2, [r4, #2]
 8003608:	0a11      	lsrs	r1, r2, #8
 800360a:	1e4b      	subs	r3, r1, #1
 800360c:	2b06      	cmp	r3, #6
 800360e:	d898      	bhi.n	8003542 <USBD_StdDevReq+0x36>
 8003610:	a101      	add	r1, pc, #4	; (adr r1, 8003618 <USBD_StdDevReq+0x10c>)
 8003612:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8003616:	bf00      	nop
 8003618:	080036bb 	.word	0x080036bb
 800361c:	0800367d 	.word	0x0800367d
 8003620:	08003667 	.word	0x08003667
 8003624:	08003543 	.word	0x08003543
 8003628:	08003543 	.word	0x08003543
 800362c:	08003543 	.word	0x08003543
 8003630:	08003543 	.word	0x08003543
*/
static void USBD_GetConfig(USB_OTG_CORE_HANDLE  *pdev, 
                           USB_SETUP_REQ *req)
{
 
  if (req->wLength != 1) 
 8003634:	88e2      	ldrh	r2, [r4, #6]
 8003636:	2a01      	cmp	r2, #1
 8003638:	d183      	bne.n	8003542 <USBD_StdDevReq+0x36>
  {                   
     USBD_CtlError(pdev , req);
  }
  else 
  {
    switch (pdev->dev.device_status )  
 800363a:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 800363e:	2b02      	cmp	r3, #2
 8003640:	f000 80b7 	beq.w	80037b2 <USBD_StdDevReq+0x2a6>
 8003644:	2b03      	cmp	r3, #3
 8003646:	f47f af7c 	bne.w	8003542 <USBD_StdDevReq+0x36>
                        1);
      break;
      
    case USB_OTG_CONFIGURED:                   
      
      USBD_CtlSendData (pdev, 
 800364a:	f500 7188 	add.w	r1, r0, #272	; 0x110
 800364e:	f7ff fe37 	bl	80032c0 <USBD_CtlSendData>
 8003652:	e779      	b.n	8003548 <USBD_StdDevReq+0x3c>
      }
    }
  } 
  else 
  {
     USBD_CtlError(pdev , req);                        
 8003654:	4628      	mov	r0, r5
 8003656:	4621      	mov	r1, r4
 8003658:	f7ff feb8 	bl	80033cc <USBD_CtlError>
 800365c:	e774      	b.n	8003548 <USBD_StdDevReq+0x3c>
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    
    if (pdev->dev.DevRemoteWakeup) 
    {
      USBD_cfg_status = USB_CONFIG_SELF_POWERED | USB_CONFIG_REMOTE_WAKEUP;                                
 800365e:	494e      	ldr	r1, [pc, #312]	; (8003798 <USBD_StdDevReq+0x28c>)
 8003660:	2203      	movs	r2, #3
 8003662:	60ca      	str	r2, [r1, #12]
 8003664:	e77f      	b.n	8003566 <USBD_StdDevReq+0x5a>
    pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    pdev->dev.pConfig_descriptor = pbuf;    
    break;
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
 8003666:	fa5f fc82 	uxtb.w	ip, r2
 800366a:	f1bc 0f05 	cmp.w	ip, #5
 800366e:	f63f af68 	bhi.w	8003542 <USBD_StdDevReq+0x36>
 8003672:	e8df f00c 	tbb	[pc, ip]
 8003676:	8795      	.short	0x8795
 8003678:	636c757e 	.word	0x636c757e
      len = 8;
    }
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetConfigDescriptor(pdev->cfg.speed, &len);
 800367c:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
 8003680:	7880      	ldrb	r0, [r0, #2]
 8003682:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8003684:	f10d 0106 	add.w	r1, sp, #6
 8003688:	4798      	blx	r3
       (pdev->cfg.phy_itface  == USB_OTG_ULPI_PHY))
    {
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetOtherConfigDescriptor(pdev->cfg.speed, &len);
    }
#endif  
    pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 800368a:	2202      	movs	r2, #2
 800368c:	7042      	strb	r2, [r0, #1]
      len = 8;
    }
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetConfigDescriptor(pdev->cfg.speed, &len);
 800368e:	4601      	mov	r1, r0
    {
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetOtherConfigDescriptor(pdev->cfg.speed, &len);
    }
#endif  
    pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    pdev->dev.pConfig_descriptor = pbuf;    
 8003690:	f8c5 05ec 	str.w	r0, [r5, #1516]	; 0x5ec
  default: 
     USBD_CtlError(pdev , req);
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
 8003694:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8003698:	2b00      	cmp	r3, #0
 800369a:	f43f af55 	beq.w	8003548 <USBD_StdDevReq+0x3c>
 800369e:	88e2      	ldrh	r2, [r4, #6]
 80036a0:	2a00      	cmp	r2, #0
 80036a2:	f43f af51 	beq.w	8003548 <USBD_StdDevReq+0x3c>
  {
    
    len = MIN(len , req->wLength);
 80036a6:	429a      	cmp	r2, r3
 80036a8:	bf38      	it	cc
 80036aa:	4613      	movcc	r3, r2
    
    USBD_CtlSendData (pdev, 
 80036ac:	4628      	mov	r0, r5
 80036ae:	461a      	mov	r2, r3
  }
  
  if((len != 0)&& (req->wLength != 0))
  {
    
    len = MIN(len , req->wLength);
 80036b0:	f8ad 3006 	strh.w	r3, [sp, #6]
    
    USBD_CtlSendData (pdev, 
 80036b4:	f7ff fe04 	bl	80032c0 <USBD_CtlSendData>
 80036b8:	e746      	b.n	8003548 <USBD_StdDevReq+0x3c>
  uint8_t *pbuf;
  
  switch (req->wValue >> 8)
  {
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->dev.usr_device->GetDeviceDescriptor(pdev->cfg.speed, &len);
 80036ba:	f8d0 35e8 	ldr.w	r3, [r0, #1512]	; 0x5e8
 80036be:	7880      	ldrb	r0, [r0, #2]
 80036c0:	681a      	ldr	r2, [r3, #0]
 80036c2:	f10d 0106 	add.w	r1, sp, #6
 80036c6:	4790      	blx	r2
    if ((req->wLength == 64) ||( pdev->dev.device_status == USB_OTG_DEFAULT))  
 80036c8:	88e2      	ldrh	r2, [r4, #6]
 80036ca:	2a40      	cmp	r2, #64	; 0x40
  uint8_t *pbuf;
  
  switch (req->wValue >> 8)
  {
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->dev.usr_device->GetDeviceDescriptor(pdev->cfg.speed, &len);
 80036cc:	4601      	mov	r1, r0
    if ((req->wLength == 64) ||( pdev->dev.device_status == USB_OTG_DEFAULT))  
 80036ce:	d003      	beq.n	80036d8 <USBD_StdDevReq+0x1cc>
 80036d0:	f895 0112 	ldrb.w	r0, [r5, #274]	; 0x112
 80036d4:	2801      	cmp	r0, #1
 80036d6:	d1dd      	bne.n	8003694 <USBD_StdDevReq+0x188>
  default: 
     USBD_CtlError(pdev , req);
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
 80036d8:	2308      	movs	r3, #8
 80036da:	e7e1      	b.n	80036a0 <USBD_StdDevReq+0x194>
         USBD_CtlSendStatus(pdev);
      }
      break;
      
    case USB_OTG_CONFIGURED:
      if (cfgidx == 0) 
 80036dc:	2900      	cmp	r1, #0
 80036de:	f000 8089 	beq.w	80037f4 <USBD_StdDevReq+0x2e8>
        pdev->dev.device_config = cfgidx;          
        USBD_ClrCfg(pdev , cfgidx);
        USBD_CtlSendStatus(pdev);
        
      } 
      else  if (cfgidx != pdev->dev.device_config) 
 80036e2:	f890 1110 	ldrb.w	r1, [r0, #272]	; 0x110
 80036e6:	2901      	cmp	r1, #1
 80036e8:	d008      	beq.n	80036fc <USBD_StdDevReq+0x1f0>
      {
        /* Clear old configuration */
        USBD_ClrCfg(pdev , pdev->dev.device_config);
 80036ea:	f7ff fde1 	bl	80032b0 <USBD_ClrCfg>
        
        /* set new configuration */
        pdev->dev.device_config = cfgidx;
 80036ee:	7931      	ldrb	r1, [r6, #4]
        USBD_SetCfg(pdev , cfgidx);
 80036f0:	4628      	mov	r0, r5
      {
        /* Clear old configuration */
        USBD_ClrCfg(pdev , pdev->dev.device_config);
        
        /* set new configuration */
        pdev->dev.device_config = cfgidx;
 80036f2:	f885 1110 	strb.w	r1, [r5, #272]	; 0x110
        USBD_SetCfg(pdev , cfgidx);
 80036f6:	f7ff fdcf 	bl	8003298 <USBD_SetCfg>
        USBD_CtlSendStatus(pdev);
 80036fa:	4628      	mov	r0, r5
 80036fc:	f7ff fe14 	bl	8003328 <USBD_CtlSendStatus>
 8003700:	e722      	b.n	8003548 <USBD_StdDevReq+0x3c>
    case 4: // TEST_PACKET
      dctl.b.tstctl = 4;
      break;
      
    case 5: // TEST_FORCE_ENABLE
      dctl.b.tstctl = 5;
 8003702:	2305      	movs	r3, #5
 8003704:	f363 1006 	bfi	r0, r3, #4, #3
 8003708:	4602      	mov	r2, r0
      break;
    }
    USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
 800370a:	604a      	str	r2, [r1, #4]
    USBD_CtlSendStatus(pdev);
 800370c:	4628      	mov	r0, r5
 800370e:	f7ff fe0b 	bl	8003328 <USBD_CtlSendStatus>
 8003712:	e719      	b.n	8003548 <USBD_StdDevReq+0x3c>
    
    test_mode = req->wIndex >> 8;
    switch (test_mode) 
    {
    case 1: // TEST_J
      dctl.b.tstctl = 1;
 8003714:	2201      	movs	r2, #1
 8003716:	f362 1006 	bfi	r0, r2, #4, #3
 800371a:	4602      	mov	r2, r0
 800371c:	e7f5      	b.n	800370a <USBD_StdDevReq+0x1fe>
    case 2: // TEST_K	
      dctl.b.tstctl = 2;
      break;
      
    case 3: // TEST_SE0_NAK
      dctl.b.tstctl = 3;
 800371e:	2403      	movs	r4, #3
 8003720:	f364 1006 	bfi	r0, r4, #4, #3
 8003724:	4602      	mov	r2, r0
 8003726:	e7f0      	b.n	800370a <USBD_StdDevReq+0x1fe>
    case 1: // TEST_J
      dctl.b.tstctl = 1;
      break;
      
    case 2: // TEST_K	
      dctl.b.tstctl = 2;
 8003728:	2302      	movs	r3, #2
 800372a:	f363 1006 	bfi	r0, r3, #4, #3
 800372e:	4602      	mov	r2, r0
 8003730:	e7eb      	b.n	800370a <USBD_StdDevReq+0x1fe>
    case 3: // TEST_SE0_NAK
      dctl.b.tstctl = 3;
      break;
      
    case 4: // TEST_PACKET
      dctl.b.tstctl = 4;
 8003732:	2204      	movs	r2, #4
 8003734:	f362 1006 	bfi	r0, r2, #4, #3
 8003738:	4602      	mov	r2, r0
 800373a:	e7e6      	b.n	800370a <USBD_StdDevReq+0x1fe>
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->dev.usr_device->GetConfigurationStrDescriptor(pdev->cfg.speed, &len);
      break;
      
    case USBD_IDX_INTERFACE_STR:
      pbuf = pdev->dev.usr_device->GetInterfaceStrDescriptor(pdev->cfg.speed, &len);
 800373c:	f8d0 15e8 	ldr.w	r1, [r0, #1512]	; 0x5e8
 8003740:	7880      	ldrb	r0, [r0, #2]
 8003742:	698a      	ldr	r2, [r1, #24]
 8003744:	f10d 0106 	add.w	r1, sp, #6
 8003748:	4790      	blx	r2
 800374a:	4601      	mov	r1, r0
 800374c:	e7a2      	b.n	8003694 <USBD_StdDevReq+0x188>
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->dev.usr_device->GetSerialStrDescriptor(pdev->cfg.speed, &len);
      break;
      
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->dev.usr_device->GetConfigurationStrDescriptor(pdev->cfg.speed, &len);
 800374e:	f8d0 35e8 	ldr.w	r3, [r0, #1512]	; 0x5e8
 8003752:	7880      	ldrb	r0, [r0, #2]
 8003754:	695a      	ldr	r2, [r3, #20]
 8003756:	f10d 0106 	add.w	r1, sp, #6
 800375a:	4790      	blx	r2
 800375c:	4601      	mov	r1, r0
 800375e:	e799      	b.n	8003694 <USBD_StdDevReq+0x188>
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->dev.usr_device->GetProductStrDescriptor(pdev->cfg.speed, &len);
      break;
      
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->dev.usr_device->GetSerialStrDescriptor(pdev->cfg.speed, &len);
 8003760:	f8d0 15e8 	ldr.w	r1, [r0, #1512]	; 0x5e8
 8003764:	7880      	ldrb	r0, [r0, #2]
 8003766:	690b      	ldr	r3, [r1, #16]
 8003768:	f10d 0106 	add.w	r1, sp, #6
 800376c:	4798      	blx	r3
 800376e:	4601      	mov	r1, r0
 8003770:	e790      	b.n	8003694 <USBD_StdDevReq+0x188>
    case USBD_IDX_MFC_STR:
      pbuf = pdev->dev.usr_device->GetManufacturerStrDescriptor(pdev->cfg.speed, &len);
      break;
      
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->dev.usr_device->GetProductStrDescriptor(pdev->cfg.speed, &len);
 8003772:	f8d0 25e8 	ldr.w	r2, [r0, #1512]	; 0x5e8
 8003776:	7880      	ldrb	r0, [r0, #2]
 8003778:	68d3      	ldr	r3, [r2, #12]
 800377a:	f10d 0106 	add.w	r1, sp, #6
 800377e:	4798      	blx	r3
 8003780:	4601      	mov	r1, r0
 8003782:	e787      	b.n	8003694 <USBD_StdDevReq+0x188>
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->dev.usr_device->GetLangIDStrDescriptor(pdev->cfg.speed, &len);        
      break;
      
    case USBD_IDX_MFC_STR:
      pbuf = pdev->dev.usr_device->GetManufacturerStrDescriptor(pdev->cfg.speed, &len);
 8003784:	f8d0 15e8 	ldr.w	r1, [r0, #1512]	; 0x5e8
 8003788:	7880      	ldrb	r0, [r0, #2]
 800378a:	688a      	ldr	r2, [r1, #8]
 800378c:	f10d 0106 	add.w	r1, sp, #6
 8003790:	4790      	blx	r2
 8003792:	4601      	mov	r1, r0
 8003794:	e77e      	b.n	8003694 <USBD_StdDevReq+0x188>
 8003796:	bf00      	nop
 8003798:	2000080c 	.word	0x2000080c
 800379c:	20000818 	.word	0x20000818
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
    {
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->dev.usr_device->GetLangIDStrDescriptor(pdev->cfg.speed, &len);        
 80037a0:	f8d0 35e8 	ldr.w	r3, [r0, #1512]	; 0x5e8
 80037a4:	7880      	ldrb	r0, [r0, #2]
 80037a6:	685a      	ldr	r2, [r3, #4]
 80037a8:	f10d 0106 	add.w	r1, sp, #6
 80037ac:	4790      	blx	r2
 80037ae:	4601      	mov	r1, r0
 80037b0:	e770      	b.n	8003694 <USBD_StdDevReq+0x188>
  {
    switch (pdev->dev.device_status )  
    {
    case USB_OTG_ADDRESSED:                     
      
      USBD_CtlSendData (pdev, 
 80037b2:	4916      	ldr	r1, [pc, #88]	; (800380c <USBD_StdDevReq+0x300>)
 80037b4:	f7ff fd84 	bl	80032c0 <USBD_CtlSendData>
 80037b8:	e6c6      	b.n	8003548 <USBD_StdDevReq+0x3c>
  else 
  {
    switch (pdev->dev.device_status) 
    {
    case USB_OTG_ADDRESSED:
      if (cfgidx) 
 80037ba:	2900      	cmp	r1, #0
 80037bc:	d09e      	beq.n	80036fc <USBD_StdDevReq+0x1f0>
      {                                			   							   							   				
        pdev->dev.device_config = cfgidx;
 80037be:	2101      	movs	r1, #1
        pdev->dev.device_status = USB_OTG_CONFIGURED;
 80037c0:	2303      	movs	r3, #3
    switch (pdev->dev.device_status) 
    {
    case USB_OTG_ADDRESSED:
      if (cfgidx) 
      {                                			   							   							   				
        pdev->dev.device_config = cfgidx;
 80037c2:	f880 1110 	strb.w	r1, [r0, #272]	; 0x110
        pdev->dev.device_status = USB_OTG_CONFIGURED;
 80037c6:	f880 3112 	strb.w	r3, [r0, #274]	; 0x112
        USBD_SetCfg(pdev , cfgidx);
 80037ca:	f7ff fd65 	bl	8003298 <USBD_SetCfg>
        USBD_CtlSendStatus(pdev);
 80037ce:	4628      	mov	r0, r5
 80037d0:	f7ff fdaa 	bl	8003328 <USBD_CtlSendStatus>
 80037d4:	e6b8      	b.n	8003548 <USBD_StdDevReq+0x3c>
      {
        pdev->dev.device_status  = USB_OTG_ADDRESSED;
      } 
      else 
      {
        pdev->dev.device_status  = USB_OTG_DEFAULT; 
 80037d6:	2101      	movs	r1, #1
 80037d8:	f885 1112 	strb.w	r1, [r5, #274]	; 0x112
 80037dc:	e6b4      	b.n	8003548 <USBD_StdDevReq+0x3c>
  uint8_t test_mode = 0;
 
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
  {
    pdev->dev.DevRemoteWakeup = 1;  
    pdev->dev.class_cb->Setup (pdev, req);   
 80037de:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	; 0x5e0
  USB_OTG_DCTL_TypeDef     dctl;
  uint8_t test_mode = 0;
 
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
  {
    pdev->dev.DevRemoteWakeup = 1;  
 80037e2:	f8c0 3114 	str.w	r3, [r0, #276]	; 0x114
    pdev->dev.class_cb->Setup (pdev, req);   
 80037e6:	688a      	ldr	r2, [r1, #8]
 80037e8:	4621      	mov	r1, r4
 80037ea:	4790      	blx	r2
    USBD_CtlSendStatus(pdev);
 80037ec:	4628      	mov	r0, r5
        USBD_ClrCfg(pdev , pdev->dev.device_config);
        
        /* set new configuration */
        pdev->dev.device_config = cfgidx;
        USBD_SetCfg(pdev , cfgidx);
        USBD_CtlSendStatus(pdev);
 80037ee:	f7ff fd9b 	bl	8003328 <USBD_CtlSendStatus>
 80037f2:	e6a9      	b.n	8003548 <USBD_StdDevReq+0x3c>
      break;
      
    case USB_OTG_CONFIGURED:
      if (cfgidx == 0) 
      {                           
        pdev->dev.device_status = USB_OTG_ADDRESSED;
 80037f4:	2202      	movs	r2, #2
 80037f6:	f880 2112 	strb.w	r2, [r0, #274]	; 0x112
        pdev->dev.device_config = cfgidx;          
 80037fa:	f880 1110 	strb.w	r1, [r0, #272]	; 0x110
        USBD_ClrCfg(pdev , cfgidx);
 80037fe:	f7ff fd57 	bl	80032b0 <USBD_ClrCfg>
        USBD_CtlSendStatus(pdev);
 8003802:	4628      	mov	r0, r5
 8003804:	f7ff fd90 	bl	8003328 <USBD_CtlSendStatus>
 8003808:	e69e      	b.n	8003548 <USBD_StdDevReq+0x3c>
 800380a:	bf00      	nop
 800380c:	20000814 	.word	0x20000814

08003810 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 8003810:	b430      	push	{r4, r5}
  uint8_t idx = 0;
  
  if (desc != NULL) 
 8003812:	b1f8      	cbz	r0, 8003854 <USBD_GetString+0x44>
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != NULL) 
 8003814:	7803      	ldrb	r3, [r0, #0]
 8003816:	2b00      	cmp	r3, #0
 8003818:	d01e      	beq.n	8003858 <USBD_GetString+0x48>
 800381a:	4604      	mov	r4, r0
 800381c:	2300      	movs	r3, #0
 800381e:	f814 5f01 	ldrb.w	r5, [r4, #1]!
    {
        len++;
 8003822:	3301      	adds	r3, #1
 8003824:	b2db      	uxtb	r3, r3
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != NULL) 
 8003826:	2d00      	cmp	r5, #0
 8003828:	d1f9      	bne.n	800381e <USBD_GetString+0xe>
 800382a:	005c      	lsls	r4, r3, #1
 800382c:	1ca3      	adds	r3, r4, #2
 800382e:	b2dc      	uxtb	r4, r3
{
  uint8_t idx = 0;
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
 8003830:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 8003832:	2203      	movs	r2, #3
  uint8_t idx = 0;
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
 8003834:	700c      	strb	r4, [r1, #0]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 8003836:	704a      	strb	r2, [r1, #1]
    
    while (*desc != NULL) 
 8003838:	7802      	ldrb	r2, [r0, #0]
 800383a:	b15a      	cbz	r2, 8003854 <USBD_GetString+0x44>
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 800383c:	2302      	movs	r3, #2
    
    while (*desc != NULL) 
    {
      unicode[idx++] = *desc++;
      unicode[idx++] =  0x00;
 800383e:	2500      	movs	r5, #0
 8003840:	1c5c      	adds	r4, r3, #1
 8003842:	b2e4      	uxtb	r4, r4
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
    
    while (*desc != NULL) 
    {
      unicode[idx++] = *desc++;
 8003844:	54ca      	strb	r2, [r1, r3]
      unicode[idx++] =  0x00;
 8003846:	550d      	strb	r5, [r1, r4]
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
    
    while (*desc != NULL) 
 8003848:	f810 2f01 	ldrb.w	r2, [r0, #1]!
    {
      unicode[idx++] = *desc++;
      unicode[idx++] =  0x00;
 800384c:	3302      	adds	r3, #2
 800384e:	b2db      	uxtb	r3, r3
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
    
    while (*desc != NULL) 
 8003850:	2a00      	cmp	r2, #0
 8003852:	d1f5      	bne.n	8003840 <USBD_GetString+0x30>
    {
      unicode[idx++] = *desc++;
      unicode[idx++] =  0x00;
    }
  } 
}
 8003854:	bc30      	pop	{r4, r5}
 8003856:	4770      	bx	lr
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != NULL) 
 8003858:	2402      	movs	r4, #2
 800385a:	4623      	mov	r3, r4
 800385c:	e7e8      	b.n	8003830 <USBD_GetString+0x20>
 800385e:	bf00      	nop

08003860 <USB_OTG_BSP_ConfigVBUS>:
#include "stm32f4xx_conf.h"


void USB_OTG_BSP_ConfigVBUS(USB_OTG_CORE_HANDLE *pdev) {

}
 8003860:	4770      	bx	lr

08003862 <USB_OTG_BSP_DriveVBUS>:

void USB_OTG_BSP_DriveVBUS(USB_OTG_CORE_HANDLE *pdev,uint8_t state) {

}
 8003862:	4770      	bx	lr

08003864 <USB_OTG_BSP_Init>:
* @param  None
* @retval None
*/

void USB_OTG_BSP_Init(USB_OTG_CORE_HANDLE *pdev)
{
 8003864:	b537      	push	{r0, r1, r2, r4, r5, lr}
#endif


 #ifdef USE_USB_OTG_FS

  RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOA , ENABLE);
 8003866:	2001      	movs	r0, #1
 8003868:	4601      	mov	r1, r0
 800386a:	f7fd fc93 	bl	8001194 <RCC_AHB1PeriphClockCmd>

  /* Configure SOF VBUS ID DM DP Pins */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8  |
 800386e:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
 8003872:	9300      	str	r3, [sp, #0]
    GPIO_Pin_9  |
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8003874:	2302      	movs	r3, #2
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8  |
    GPIO_Pin_9  |
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8003876:	2503      	movs	r5, #3
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8003878:	f88d 3004 	strb.w	r3, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800387c:	4669      	mov	r1, sp
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800387e:	3b02      	subs	r3, #2
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8003880:	4820      	ldr	r0, [pc, #128]	; (8003904 <USB_OTG_BSP_Init+0xa0>)
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8003882:	f88d 3006 	strb.w	r3, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 8003886:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8  |
    GPIO_Pin_9  |
      GPIO_Pin_11 |
        GPIO_Pin_12;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 800388a:	f88d 5005 	strb.w	r5, [sp, #5]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800388e:	f7fd fec1 	bl	8001614 <GPIO_Init>

  GPIO_PinAFConfig(GPIOA,GPIO_PinSource8,GPIO_AF_OTG1_FS) ;
 8003892:	2108      	movs	r1, #8
 8003894:	220a      	movs	r2, #10
 8003896:	481b      	ldr	r0, [pc, #108]	; (8003904 <USB_OTG_BSP_Init+0xa0>)
 8003898:	f7fd ffb4 	bl	8001804 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_OTG1_FS) ;
 800389c:	2109      	movs	r1, #9
 800389e:	220a      	movs	r2, #10
 80038a0:	4818      	ldr	r0, [pc, #96]	; (8003904 <USB_OTG_BSP_Init+0xa0>)
 80038a2:	f7fd ffaf 	bl	8001804 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource11,GPIO_AF_OTG1_FS) ;
 80038a6:	210b      	movs	r1, #11
 80038a8:	220a      	movs	r2, #10
 80038aa:	4816      	ldr	r0, [pc, #88]	; (8003904 <USB_OTG_BSP_Init+0xa0>)
 80038ac:	f7fd ffaa 	bl	8001804 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;
 80038b0:	220a      	movs	r2, #10
 80038b2:	210c      	movs	r1, #12
 80038b4:	4813      	ldr	r0, [pc, #76]	; (8003904 <USB_OTG_BSP_Init+0xa0>)
 80038b6:	f7fd ffa5 	bl	8001804 <GPIO_PinAFConfig>

  /* this for ID line debug */


  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 80038ba:	2401      	movs	r4, #1
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;

  /* this for ID line debug */


  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
 80038bc:	f44f 6380 	mov.w	r3, #1024	; 0x400
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 80038c0:	4669      	mov	r1, sp
 80038c2:	4810      	ldr	r0, [pc, #64]	; (8003904 <USB_OTG_BSP_Init+0xa0>)
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;

  /* this for ID line debug */


  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
 80038c4:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 80038c6:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
 80038ca:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 80038ce:	f88d 5005 	strb.w	r5, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 80038d2:	f7fd fe9f 	bl	8001614 <GPIO_Init>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_OTG1_FS) ;
 80038d6:	210a      	movs	r1, #10
 80038d8:	460a      	mov	r2, r1
 80038da:	480a      	ldr	r0, [pc, #40]	; (8003904 <USB_OTG_BSP_Init+0xa0>)
 80038dc:	f7fd ff92 	bl	8001804 <GPIO_PinAFConfig>

  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 80038e0:	4621      	mov	r1, r4
 80038e2:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80038e6:	f7fd fc8d 	bl	8001204 <RCC_APB2PeriphClockCmd>
  RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_OTG_FS, ENABLE) ;
 80038ea:	2080      	movs	r0, #128	; 0x80
 80038ec:	4621      	mov	r1, r4
 80038ee:	f7fd fc5f 	bl	80011b0 <RCC_AHB2PeriphClockCmd>

 #endif //USB_OTG_HS


  /* enable the PWR clock */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
 80038f2:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 80038f6:	4621      	mov	r1, r4
 80038f8:	f7fd fcbc 	bl	8001274 <RCC_APB1PeriphResetCmd>
  NVIC_Init(&NVIC_InitStructure);

  EXTI_ClearITPendingBit(EXTI_Line20);
#endif

  EXTI_ClearITPendingBit(EXTI_Line0);
 80038fc:	4620      	mov	r0, r4
 80038fe:	f7fd fdf7 	bl	80014f0 <EXTI_ClearITPendingBit>
}
 8003902:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8003904:	40020000 	.word	0x40020000

08003908 <USB_OTG_BSP_EnableInterrupt>:
*         Enabele USB Global interrupt
* @param  None
* @retval None
*/
void USB_OTG_BSP_EnableInterrupt(USB_OTG_CORE_HANDLE *pdev)
{
 8003908:	b507      	push	{r0, r1, r2, lr}
  NVIC_InitTypeDef NVIC_InitStructure;

  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
 800390a:	f44f 60c0 	mov.w	r0, #1536	; 0x600
 800390e:	f000 f81f 	bl	8003950 <NVIC_PriorityGroupConfig>
#ifdef USE_USB_OTG_HS
  NVIC_InitStructure.NVIC_IRQChannel = OTG_HS_IRQn;
#else
  NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;
 8003912:	2343      	movs	r3, #67	; 0x43
 8003914:	f88d 3004 	strb.w	r3, [sp, #4]
#endif
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 11;
 8003918:	3b38      	subs	r3, #56	; 0x38
 800391a:	f88d 3005 	strb.w	r3, [sp, #5]
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
 800391e:	3b08      	subs	r3, #8
 8003920:	f88d 3006 	strb.w	r3, [sp, #6]
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
 8003924:	a801      	add	r0, sp, #4
#else
  NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;
#endif
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 11;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8003926:	3b02      	subs	r3, #2
 8003928:	f88d 3007 	strb.w	r3, [sp, #7]
  NVIC_Init(&NVIC_InitStructure);
 800392c:	f000 f81a 	bl	8003964 <NVIC_Init>
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 11;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
#endif
}
 8003930:	bd0e      	pop	{r1, r2, r3, pc}

08003932 <USB_OTG_BSP_uDelay>:
* @retval None
*/
void USB_OTG_BSP_uDelay (const uint32_t usec)
{
  uint32_t count = 0;
  const uint32_t utime = (120 * usec / 7);
 8003932:	2378      	movs	r3, #120	; 0x78
 8003934:	2207      	movs	r2, #7
 8003936:	4343      	muls	r3, r0
 8003938:	fbb3 f3f2 	udiv	r3, r3, r2
* @param  usec : Value of delay required in micro sec
* @retval None
*/
void USB_OTG_BSP_uDelay (const uint32_t usec)
{
  uint32_t count = 0;
 800393c:	3a07      	subs	r2, #7
  const uint32_t utime = (120 * usec / 7);
  do
  {
    if ( ++count > utime )
 800393e:	3201      	adds	r2, #1
 8003940:	429a      	cmp	r2, r3
 8003942:	d9fc      	bls.n	800393e <USB_OTG_BSP_uDelay+0xc>
    {
      return ;
    }
  }
  while (1);
}
 8003944:	4770      	bx	lr

08003946 <USB_OTG_BSP_mDelay>:
* @param  msec : Value of delay required in milli sec
* @retval None
*/
void USB_OTG_BSP_mDelay (const uint32_t msec)
{
  USB_OTG_BSP_uDelay(msec * 1000);
 8003946:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800394a:	4358      	muls	r0, r3
 800394c:	e7f1      	b.n	8003932 <USB_OTG_BSP_uDelay>
 800394e:	bf00      	nop

08003950 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8003950:	f040 61be 	orr.w	r1, r0, #99614720	; 0x5f00000
 8003954:	4b02      	ldr	r3, [pc, #8]	; (8003960 <NVIC_PriorityGroupConfig+0x10>)
 8003956:	f441 2020 	orr.w	r0, r1, #655360	; 0xa0000
 800395a:	60d8      	str	r0, [r3, #12]
}
 800395c:	4770      	bx	lr
 800395e:	bf00      	nop
 8003960:	e000ed00 	.word	0xe000ed00

08003964 <NVIC_Init>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8003964:	78c3      	ldrb	r3, [r0, #3]
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8003966:	b470      	push	{r4, r5, r6}
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8003968:	b963      	cbnz	r3, 8003984 <NVIC_Init+0x20>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800396a:	7802      	ldrb	r2, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800396c:	2101      	movs	r1, #1
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800396e:	0950      	lsrs	r0, r2, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003970:	f002 031f 	and.w	r3, r2, #31
 8003974:	fa11 f203 	lsls.w	r2, r1, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003978:	3020      	adds	r0, #32
 800397a:	4916      	ldr	r1, [pc, #88]	; (80039d4 <NVIC_Init+0x70>)
 800397c:	f841 2020 	str.w	r2, [r1, r0, lsl #2]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 8003980:	bc70      	pop	{r4, r5, r6}
 8003982:	4770      	bx	lr
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003984:	4b14      	ldr	r3, [pc, #80]	; (80039d8 <NVIC_Init+0x74>)
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8003986:	7846      	ldrb	r6, [r0, #1]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003988:	68dc      	ldr	r4, [r3, #12]
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 800398a:	7885      	ldrb	r5, [r0, #2]
        
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 800398c:	7801      	ldrb	r1, [r0, #0]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 800398e:	43e2      	mvns	r2, r4
 8003990:	f3c2 2202 	ubfx	r2, r2, #8, #3
    tmppre = (0x4 - tmppriority);
 8003994:	f1c2 0c04 	rsb	ip, r2, #4
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8003998:	fa5f f48c 	uxtb.w	r4, ip
 800399c:	fa16 f404 	lsls.w	r4, r6, r4
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
 80039a0:	260f      	movs	r6, #15
 80039a2:	fa56 f202 	asrs.w	r2, r6, r2
    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
        
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 80039a6:	f5a3 6340 	sub.w	r3, r3, #3072	; 0xc00
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 80039aa:	ea02 0c05 	and.w	ip, r2, r5
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 80039ae:	b2e4      	uxtb	r4, r4
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 80039b0:	ea4c 0204 	orr.w	r2, ip, r4
        
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 80039b4:	eb01 0c03 	add.w	ip, r1, r3
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
        
    tmppriority = tmppriority << 0x04;
 80039b8:	0112      	lsls	r2, r2, #4
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 80039ba:	f88c 2300 	strb.w	r2, [ip, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80039be:	7800      	ldrb	r0, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 80039c0:	2201      	movs	r2, #1
 80039c2:	f000 031f 	and.w	r3, r0, #31
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80039c6:	0941      	lsrs	r1, r0, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 80039c8:	fa12 f003 	lsls.w	r0, r2, r3
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80039cc:	4a01      	ldr	r2, [pc, #4]	; (80039d4 <NVIC_Init+0x70>)
 80039ce:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
 80039d2:	e7d5      	b.n	8003980 <NVIC_Init+0x1c>
 80039d4:	e000e100 	.word	0xe000e100
 80039d8:	e000ed00 	.word	0xe000ed00

080039dc <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 80039dc:	f021 4c60 	bic.w	ip, r1, #3758096384	; 0xe0000000
 80039e0:	f02c 027f 	bic.w	r2, ip, #127	; 0x7f
 80039e4:	4b02      	ldr	r3, [pc, #8]	; (80039f0 <NVIC_SetVectorTable+0x14>)
 80039e6:	ea42 0100 	orr.w	r1, r2, r0
 80039ea:	6099      	str	r1, [r3, #8]
}
 80039ec:	4770      	bx	lr
 80039ee:	bf00      	nop
 80039f0:	e000ed00 	.word	0xe000ed00

080039f4 <NVIC_SystemLPConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 80039f4:	b929      	cbnz	r1, 8003a02 <NVIC_SystemLPConfig+0xe>
  {
    SCB->SCR |= LowPowerMode;
  }
  else
  {
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
 80039f6:	4b05      	ldr	r3, [pc, #20]	; (8003a0c <NVIC_SystemLPConfig+0x18>)
 80039f8:	691a      	ldr	r2, [r3, #16]
 80039fa:	ea22 0100 	bic.w	r1, r2, r0
 80039fe:	6119      	str	r1, [r3, #16]
 8003a00:	4770      	bx	lr
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    SCB->SCR |= LowPowerMode;
 8003a02:	4b02      	ldr	r3, [pc, #8]	; (8003a0c <NVIC_SystemLPConfig+0x18>)
 8003a04:	691a      	ldr	r2, [r3, #16]
 8003a06:	4310      	orrs	r0, r2
 8003a08:	6118      	str	r0, [r3, #16]
 8003a0a:	4770      	bx	lr
 8003a0c:	e000ed00 	.word	0xe000ed00

08003a10 <SysTick_CLKSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8003a10:	4b04      	ldr	r3, [pc, #16]	; (8003a24 <SysTick_CLKSourceConfig+0x14>)
 8003a12:	681a      	ldr	r2, [r3, #0]
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 8003a14:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8003a16:	bf0c      	ite	eq
 8003a18:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8003a1c:	f022 0204 	bicne.w	r2, r2, #4
 8003a20:	601a      	str	r2, [r3, #0]
 8003a22:	4770      	bx	lr
 8003a24:	e000e010 	.word	0xe000e010

08003a28 <DISCgpiopins_Config>:
{
/* ----------------------------- PORTA -------------------------------------- */
/* ----------------------------- PORTB -------------------------------------- */
/* ----------------------------- PORTC -------------------------------------- */
/* ----------------------------- PORTD -------------------------------------- */
	RCC_AHB1ENR |= (1<<3);	// Enable port D clocking (p 110, p 148)
 8003a28:	4b0d      	ldr	r3, [pc, #52]	; (8003a60 <DISCgpiopins_Config+0x38>)
 8003a2a:	681a      	ldr	r2, [r3, #0]
 8003a2c:	f042 0208 	orr.w	r2, r2, #8
 8003a30:	601a      	str	r2, [r3, #0]

	/* PD12,13,14,15 are the green, orange, red, blue LEDs on the Discovery board */
	GPIOD_MODER    =   (GPIOD_MODER   & (~(0x00ff << 24))) | (0x0055 << 24);	// Mode = General purpose output
 8003a32:	4b0c      	ldr	r3, [pc, #48]	; (8003a64 <DISCgpiopins_Config+0x3c>)
 8003a34:	681a      	ldr	r2, [r3, #0]
 8003a36:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8003a3a:	f042 42aa 	orr.w	r2, r2, #1426063360	; 0x55000000
 8003a3e:	601a      	str	r2, [r3, #0]
	GPIOD_OTYPER   =   (GPIOD_OTYPER  & (~(0x000f << 12))) | (0x0000 << 12);	// Type output = push-pull
 8003a40:	685a      	ldr	r2, [r3, #4]
 8003a42:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
 8003a46:	605a      	str	r2, [r3, #4]
	GPIOD_OSPEEDR  =   (GPIOD_OSPEEDR & (~(0x00ff << 24))) | (0x00aa << 24);	// Pin speed = Speed 50 MHz
 8003a48:	689a      	ldr	r2, [r3, #8]
 8003a4a:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8003a4e:	f042 422a 	orr.w	r2, r2, #2852126720	; 0xaa000000
 8003a52:	609a      	str	r2, [r3, #8]
	GPIOD_PUPDR    =   (GPIOD_PUPDR   & (~(0x00ff << 24))) | (0x0000 << 24);	// Pull up/down = none.
 8003a54:	68da      	ldr	r2, [r3, #12]
 8003a56:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8003a5a:	60da      	str	r2, [r3, #12]

	return;
}
 8003a5c:	4770      	bx	lr
 8003a5e:	bf00      	nop
 8003a60:	40023830 	.word	0x40023830
 8003a64:	40020c00 	.word	0x40020c00

08003a68 <DISCgpiopins_default>:
/* ----------------------------- PORTB -------------------------------------- */
/* ----------------------------- PORTC -------------------------------------- */
/* ----------------------------- PORTD -------------------------------------- */
/* ----------------------------- PORTE -------------------------------------- */
	return;
}
 8003a68:	4770      	bx	lr

08003a6a <f4gpiopins_Config>:
 * void f4gpiopins_Config(volatile u32 * p, u16 pinnumber, struct PINCONFIG * s  );
 * @param	: See comments on each in source code
 * @brief	: Configure one gpio pin 
 ******************************************************************************/
void f4gpiopins_Config(volatile u32 * p, u16 pinnumber, struct PINCONFIG * s)
{
 8003a6a:	b5f0      	push	{r4, r5, r6, r7, lr}

	/* Make sure bus clocking is enabled so that gpio registers can be accessed (p 110) */
	u32 x = ((u32)p - (u32)GPIOA) >> 10;	// Shift count for enabling RCC_AHB1ENR
 8003a6c:	f100 443f 	add.w	r4, r0, #3204448256	; 0xbf000000
 8003a70:	f504 047e 	add.w	r4, r4, #16646144	; 0xfe0000
	RCC_AHB1ENR |= ((1 << x) & 0x01ff);	// Enable port clocking
 8003a74:	2601      	movs	r6, #1
 8003a76:	4d29      	ldr	r5, [pc, #164]	; (8003b1c <f4gpiopins_Config+0xb2>)
 ******************************************************************************/
void f4gpiopins_Config(volatile u32 * p, u16 pinnumber, struct PINCONFIG * s)
{

	/* Make sure bus clocking is enabled so that gpio registers can be accessed (p 110) */
	u32 x = ((u32)p - (u32)GPIOA) >> 10;	// Shift count for enabling RCC_AHB1ENR
 8003a78:	0aa3      	lsrs	r3, r4, #10
	RCC_AHB1ENR |= ((1 << x) & 0x01ff);	// Enable port clocking
 8003a7a:	fa16 f303 	lsls.w	r3, r6, r3
 8003a7e:	682f      	ldr	r7, [r5, #0]
 8003a80:	05db      	lsls	r3, r3, #23
 8003a82:	0ddb      	lsrs	r3, r3, #23
 8003a84:	433b      	orrs	r3, r7
 8003a86:	602b      	str	r3, [r5, #0]
00: Input (reset state)
01: General purpose output mode
10: Alternate function mode
11: Analog mode
*/
	GPIO_MODER(p)  &= ~(0x03 << (pinnumber << 1));		// Reset old mode values
 8003a88:	fa11 f306 	lsls.w	r3, r1, r6
 8003a8c:	2503      	movs	r5, #3
 8003a8e:	6804      	ldr	r4, [r0, #0]
 8003a90:	409d      	lsls	r5, r3
 8003a92:	43ed      	mvns	r5, r5
 8003a94:	ea05 0404 	and.w	r4, r5, r4
 8003a98:	6004      	str	r4, [r0, #0]
	GPIO_MODER(p)  |= ((s->mode & 0x03) << (pinnumber << 1));	// Add new values
 8003a9a:	7817      	ldrb	r7, [r2, #0]
 8003a9c:	6804      	ldr	r4, [r0, #0]
 8003a9e:	f007 0703 	and.w	r7, r7, #3
 8003aa2:	409f      	lsls	r7, r3
 8003aa4:	4327      	orrs	r7, r4
 8003aa6:	4604      	mov	r4, r0
/* TYPE GPIO_OTYPER
These bits are written by software to configure the output type of the I/O port.
0: Output push-pull (reset state)
1: Output open-drain
*/
	GPIO_MODER(p+1) &= ~(0x01 << pinnumber);		// Reset old type bit
 8003aa8:	408e      	lsls	r6, r1
01: General purpose output mode
10: Alternate function mode
11: Analog mode
*/
	GPIO_MODER(p)  &= ~(0x03 << (pinnumber << 1));		// Reset old mode values
	GPIO_MODER(p)  |= ((s->mode & 0x03) << (pinnumber << 1));	// Add new values
 8003aaa:	f844 7b04 	str.w	r7, [r4], #4
/* TYPE GPIO_OTYPER
These bits are written by software to configure the output type of the I/O port.
0: Output push-pull (reset state)
1: Output open-drain
*/
	GPIO_MODER(p+1) &= ~(0x01 << pinnumber);		// Reset old type bit
 8003aae:	6847      	ldr	r7, [r0, #4]
 8003ab0:	ea27 0606 	bic.w	r6, r7, r6
 8003ab4:	6046      	str	r6, [r0, #4]
	GPIO_MODER(p+1) |=  ((s->type & 0x01) << pinnumber);// Add new type bit
 8003ab6:	7856      	ldrb	r6, [r2, #1]
 8003ab8:	6847      	ldr	r7, [r0, #4]
 8003aba:	f006 0601 	and.w	r6, r6, #1
 8003abe:	408e      	lsls	r6, r1
 8003ac0:	433e      	orrs	r6, r7
 8003ac2:	6046      	str	r6, [r0, #4]
01: 25 MHz Medium speed
10: 50 MHz Fast speed
11: 100 MHz High speed on 30 pF (80 MHz Output max speed on 15 pF)
*/

	GPIO_MODER(p+2) &= ~(0x03 << (pinnumber << 1));		// Reset old speed values
 8003ac4:	6886      	ldr	r6, [r0, #8]
 8003ac6:	ea05 0606 	and.w	r6, r5, r6
 8003aca:	6086      	str	r6, [r0, #8]
	GPIO_MODER(p+2) |= ((s->speed & 0x03) << (pinnumber << 1));// Add new values
 8003acc:	7896      	ldrb	r6, [r2, #2]
 8003ace:	6887      	ldr	r7, [r0, #8]
 8003ad0:	f006 0603 	and.w	r6, r6, #3
 8003ad4:	409e      	lsls	r6, r3
 8003ad6:	433e      	orrs	r6, r7
 8003ad8:	6086      	str	r6, [r0, #8]
00: No pull-up, pull-down
01: Pull-up
10: Pull-down
11: Reserved
*/
	GPIO_MODER(p+3) &= ~(0x03 << (pinnumber << 1));		// Reset old pupdn values
 8003ada:	68c6      	ldr	r6, [r0, #12]
 8003adc:	4035      	ands	r5, r6
 8003ade:	60c5      	str	r5, [r0, #12]
	GPIO_MODER(p+3) |= ((s->pupdn & 0x03) << (pinnumber << 1));	// Add new values
 8003ae0:	78d6      	ldrb	r6, [r2, #3]
 8003ae2:	68c5      	ldr	r5, [r0, #12]
 8003ae4:	f006 0603 	and.w	r6, r6, #3
 8003ae8:	fa16 f303 	lsls.w	r3, r6, r3
 8003aec:	432b      	orrs	r3, r5
                                  1111: AF15
0111: AF7

GPIO_AFRL
*/
	if (pinnumber >= 8)
 8003aee:	2907      	cmp	r1, #7
01: Pull-up
10: Pull-down
11: Reserved
*/
	GPIO_MODER(p+3) &= ~(0x03 << (pinnumber << 1));		// Reset old pupdn values
	GPIO_MODER(p+3) |= ((s->pupdn & 0x03) << (pinnumber << 1));	// Add new values
 8003af0:	60c3      	str	r3, [r0, #12]
                                  1111: AF15
0111: AF7

GPIO_AFRL
*/
	if (pinnumber >= 8)
 8003af2:	d902      	bls.n	8003afa <f4gpiopins_Config+0x90>
	{ // Here, the high register (pins 8 - 15) (p 152)
		pinnumber -= 8;		// adjust shift count 
 8003af4:	3908      	subs	r1, #8
 8003af6:	b289      	uxth	r1, r1
 8003af8:	4620      	mov	r0, r4
		p++;			// Point to high register
	}

	GPIO_MODER(p+8) &= ~(0x0f << (pinnumber << 2));			// Remove old AF settings
 8003afa:	6a04      	ldr	r4, [r0, #32]
 8003afc:	0089      	lsls	r1, r1, #2
 8003afe:	230f      	movs	r3, #15
 8003b00:	408b      	lsls	r3, r1
 8003b02:	ea24 0303 	bic.w	r3, r4, r3
 8003b06:	6203      	str	r3, [r0, #32]
	GPIO_MODER(p+8) |=  ((s->afrl & 0x0f) << (pinnumber << 2));	// Add new settings
 8003b08:	7912      	ldrb	r2, [r2, #4]
 8003b0a:	6a03      	ldr	r3, [r0, #32]
 8003b0c:	f002 020f 	and.w	r2, r2, #15
 8003b10:	fa12 f101 	lsls.w	r1, r2, r1
 8003b14:	4319      	orrs	r1, r3
 8003b16:	6201      	str	r1, [r0, #32]

	return;
}
 8003b18:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003b1a:	bf00      	nop
 8003b1c:	40023830 	.word	0x40023830

08003b20 <loop>:
{
	LEDSALL_off;
	return;
}	
static void loop(volatile int ct)
{
 8003b20:	b082      	sub	sp, #8
 8003b22:	9001      	str	r0, [sp, #4]
	while (ct > 0) ct -= 1; 
 8003b24:	e002      	b.n	8003b2c <loop+0xc>
 8003b26:	9b01      	ldr	r3, [sp, #4]
 8003b28:	3b01      	subs	r3, #1
 8003b2a:	9301      	str	r3, [sp, #4]
 8003b2c:	9b01      	ldr	r3, [sp, #4]
 8003b2e:	2b00      	cmp	r3, #0
 8003b30:	dcf9      	bgt.n	8003b26 <loop+0x6>
	return;
}
 8003b32:	b002      	add	sp, #8
 8003b34:	4770      	bx	lr

08003b36 <panic_leds>:
 * @brief	: Configure gpio pins for Discovery F4 board
 ******************************************************************************/
int PanicCount;

void panic_leds(unsigned int count)
{
 8003b36:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	unsigned int i;
	volatile int x;		// Loop ct for timing pause
	volatile int xon;	// Loop ct for timing LED on duration
	volatile int xoff;	// Loop ct for timing LED off duration
	int sw = 0;
PanicCount = count; // Usefull for debugging this
 8003b38:	4b1d      	ldr	r3, [pc, #116]	; (8003bb0 <panic_leds+0x7a>)
	/* Have clocks been setup? */
	if (sysclk_freq < 1000000)
 8003b3a:	4a1e      	ldr	r2, [pc, #120]	; (8003bb4 <panic_leds+0x7e>)
	unsigned int i;
	volatile int x;		// Loop ct for timing pause
	volatile int xon;	// Loop ct for timing LED on duration
	volatile int xoff;	// Loop ct for timing LED off duration
	int sw = 0;
PanicCount = count; // Usefull for debugging this
 8003b3c:	6018      	str	r0, [r3, #0]
	/* Have clocks been setup? */
	if (sysclk_freq < 1000000)
 8003b3e:	4b1e      	ldr	r3, [pc, #120]	; (8003bb8 <panic_leds+0x82>)
 8003b40:	6819      	ldr	r1, [r3, #0]
 8003b42:	4291      	cmp	r1, r2
	{ // Here, no.  We are running on the 8 MHz HSI oscillator
		sysclk_freq = 8000000;	// Set default
 8003b44:	bf9c      	itt	ls
 8003b46:	4d1d      	ldrls	r5, [pc, #116]	; (8003bbc <panic_leds+0x86>)
 8003b48:	601d      	strls	r5, [r3, #0]
		sw = 8000000;	// Not zero
	}

	/* Setup timing for pause */
	x = sysclk_freq/10;
 8003b4a:	681b      	ldr	r3, [r3, #0]
{
	unsigned int i;
	volatile int x;		// Loop ct for timing pause
	volatile int xon;	// Loop ct for timing LED on duration
	volatile int xoff;	// Loop ct for timing LED off duration
	int sw = 0;
 8003b4c:	bf88      	it	hi
 8003b4e:	2500      	movhi	r5, #0
		sysclk_freq = 8000000;	// Set default
		sw = 8000000;	// Not zero
	}

	/* Setup timing for pause */
	x = sysclk_freq/10;
 8003b50:	220a      	movs	r2, #10
 8003b52:	fbb3 f2f2 	udiv	r2, r3, r2
 8003b56:	9203      	str	r2, [sp, #12]

	/* Setup timing for fast flash */
	xon =  sysclk_freq/250;
 8003b58:	22fa      	movs	r2, #250	; 0xfa
 8003b5a:	fbb3 f2f2 	udiv	r2, r3, r2
 8003b5e:	9202      	str	r2, [sp, #8]
	xoff = sysclk_freq/40;
 8003b60:	2228      	movs	r2, #40	; 0x28
 8003b62:	fbb3 f3f2 	udiv	r3, r3, r2
 8003b66:	9301      	str	r3, [sp, #4]

	/* Limit max count */
	if (count == 0) count = 6; // Bogus count

	/* Be sure we have the ports and pins setup for the LEDs */
	RCC_AHB1ENR |= 0x08;	// Enable IO port D
 8003b68:	4b15      	ldr	r3, [pc, #84]	; (8003bc0 <panic_leds+0x8a>)
 8003b6a:	681a      	ldr	r2, [r3, #0]
 8003b6c:	f042 0208 	orr.w	r2, r2, #8
 * @brief	: Configure gpio pins for Discovery F4 board
 ******************************************************************************/
int PanicCount;

void panic_leds(unsigned int count)
{
 8003b70:	4604      	mov	r4, r0

	/* Limit max count */
	if (count == 0) count = 6; // Bogus count

	/* Be sure we have the ports and pins setup for the LEDs */
	RCC_AHB1ENR |= 0x08;	// Enable IO port D
 8003b72:	601a      	str	r2, [r3, #0]
	/* Setup timing for fast flash */
	xon =  sysclk_freq/250;
	xoff = sysclk_freq/40;

	/* Limit max count */
	if (count == 0) count = 6; // Bogus count
 8003b74:	2800      	cmp	r0, #0
 8003b76:	bf08      	it	eq
 8003b78:	2406      	moveq	r4, #6

	/* Be sure we have the ports and pins setup for the LEDs */
	RCC_AHB1ENR |= 0x08;	// Enable IO port D
	DISCgpiopins_Config();	// Configure pins
 8003b7a:	f7ff ff55 	bl	8003a28 <DISCgpiopins_Config>

	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	if (sw == 0)
 8003b7e:	b175      	cbz	r5, 8003b9e <panic_leds+0x68>
 8003b80:	e014      	b.n	8003bac <panic_leds+0x76>
#include "libopencm3/stm32/f4/rcc.h"

extern unsigned int	sysclk_freq;	/* 	SYSCLK freq		E.g. 72000000	*/
static void allon(void)
{
	LEDSALL_on;
 8003b82:	4e10      	ldr	r6, [pc, #64]	; (8003bc4 <panic_leds+0x8e>)
 8003b84:	f44f 4370 	mov.w	r3, #61440	; 0xf000
 8003b88:	6033      	str	r3, [r6, #0]
	{
		while (1==1)
		{
			for (i = 0; i < count; i++)
			{
				allon();	loop(xon);
 8003b8a:	9802      	ldr	r0, [sp, #8]
 8003b8c:	f7ff ffc8 	bl	8003b20 <loop>
	LEDSALL_on;
	return;
}
static void alloff(void)
{
	LEDSALL_off;
 8003b90:	f04f 4370 	mov.w	r3, #4026531840	; 0xf0000000
 8003b94:	6033      	str	r3, [r6, #0]
		while (1==1)
		{
			for (i = 0; i < count; i++)
			{
				allon();	loop(xon);
				alloff();	loop(xoff);			
 8003b96:	9801      	ldr	r0, [sp, #4]
 8003b98:	f7ff ffc2 	bl	8003b20 <loop>
	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	if (sw == 0)
	{
		while (1==1)
		{
			for (i = 0; i < count; i++)
 8003b9c:	3501      	adds	r5, #1
 8003b9e:	42a5      	cmp	r5, r4
 8003ba0:	d3ef      	bcc.n	8003b82 <panic_leds+0x4c>
			{
				allon();	loop(xon);
				alloff();	loop(xoff);			
			}
			loop(x);
 8003ba2:	9803      	ldr	r0, [sp, #12]
 8003ba4:	f7ff ffbc 	bl	8003b20 <loop>
	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	if (sw == 0)
	{
		while (1==1)
		{
			for (i = 0; i < count; i++)
 8003ba8:	2500      	movs	r5, #0
 8003baa:	e7f8      	b.n	8003b9e <panic_leds+0x68>
				alloff();	loop(xoff);			
			}
			loop(x);
		}
	}
}
 8003bac:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
 8003bae:	bf00      	nop
 8003bb0:	2000081c 	.word	0x2000081c
 8003bb4:	000f423f 	.word	0x000f423f
 8003bb8:	20000840 	.word	0x20000840
 8003bbc:	007a1200 	.word	0x007a1200
 8003bc0:	40023830 	.word	0x40023830
 8003bc4:	40020c18 	.word	0x40020c18

08003bc8 <spi2rw_init>:
/******************************************************************************
 * void spi2rw_init(void);
 *  @brief Initialize SPI 
*******************************************************************************/ 
void spi2rw_init(void)
{
 8003bc8:	b538      	push	{r3, r4, r5, lr}
	/* Enable bus clocking for SPI2 */
	RCC_APB1ENR |= (1<<14);	// Enable SPI2 clocking
 8003bca:	4b17      	ldr	r3, [pc, #92]	; (8003c28 <spi2rw_init+0x60>)

	/* Set up pins for SPI2 use. */
	f4gpiopins_Config ((volatile u32*)GPIOB, 12, (struct PINCONFIG*)&outputcs);	// CS
 8003bcc:	4c17      	ldr	r4, [pc, #92]	; (8003c2c <spi2rw_init+0x64>)
 *  @brief Initialize SPI 
*******************************************************************************/ 
void spi2rw_init(void)
{
	/* Enable bus clocking for SPI2 */
	RCC_APB1ENR |= (1<<14);	// Enable SPI2 clocking
 8003bce:	681a      	ldr	r2, [r3, #0]

	/* Set up pins for SPI2 use. */
	f4gpiopins_Config ((volatile u32*)GPIOB, 12, (struct PINCONFIG*)&outputcs);	// CS
 8003bd0:	4817      	ldr	r0, [pc, #92]	; (8003c30 <spi2rw_init+0x68>)
 *  @brief Initialize SPI 
*******************************************************************************/ 
void spi2rw_init(void)
{
	/* Enable bus clocking for SPI2 */
	RCC_APB1ENR |= (1<<14);	// Enable SPI2 clocking
 8003bd2:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8003bd6:	601a      	str	r2, [r3, #0]

	/* Set up pins for SPI2 use. */
	f4gpiopins_Config ((volatile u32*)GPIOB, 12, (struct PINCONFIG*)&outputcs);	// CS
 8003bd8:	210c      	movs	r1, #12
 8003bda:	4622      	mov	r2, r4
	f4gpiopins_Config ((volatile u32*)GPIOB, 13, (struct PINCONFIG*)&outputaf);	// SCK
 8003bdc:	1d65      	adds	r5, r4, #5
{
	/* Enable bus clocking for SPI2 */
	RCC_APB1ENR |= (1<<14);	// Enable SPI2 clocking

	/* Set up pins for SPI2 use. */
	f4gpiopins_Config ((volatile u32*)GPIOB, 12, (struct PINCONFIG*)&outputcs);	// CS
 8003bde:	f7ff ff44 	bl	8003a6a <f4gpiopins_Config>
	f4gpiopins_Config ((volatile u32*)GPIOB, 13, (struct PINCONFIG*)&outputaf);	// SCK
 8003be2:	4813      	ldr	r0, [pc, #76]	; (8003c30 <spi2rw_init+0x68>)
 8003be4:	210d      	movs	r1, #13
 8003be6:	462a      	mov	r2, r5
 8003be8:	f7ff ff3f 	bl	8003a6a <f4gpiopins_Config>
	f4gpiopins_Config ((volatile u32*)GPIOB, 14, (struct PINCONFIG*)&inputaf);	// MISO
 8003bec:	4810      	ldr	r0, [pc, #64]	; (8003c30 <spi2rw_init+0x68>)
 8003bee:	210e      	movs	r1, #14
 8003bf0:	f104 020a 	add.w	r2, r4, #10
 8003bf4:	f7ff ff39 	bl	8003a6a <f4gpiopins_Config>
	f4gpiopins_Config ((volatile u32*)GPIOB, 15, (struct PINCONFIG*)&outputaf);	// MOSI
 8003bf8:	462a      	mov	r2, r5
 8003bfa:	480d      	ldr	r0, [pc, #52]	; (8003c30 <spi2rw_init+0x68>)
 8003bfc:	210f      	movs	r1, #15
 8003bfe:	f7ff ff34 	bl	8003a6a <f4gpiopins_Config>

	GPIO_BSRR(GPIOB)  = (1<<12);// Set /CS high
 8003c02:	4b0c      	ldr	r3, [pc, #48]	; (8003c34 <spi2rw_init+0x6c>)
 8003c04:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8003c08:	601a      	str	r2, [r3, #0]

	// Set divisor to max.  If APB1 is 42 Mhz, then divide by 256 = 164062.5 Hz, 48 us per byte
/* NOTE: The following line is where the "phase" is set for the clock and polarity */
	//          (SSM SSI)  |enable peripheral | baud divisor | master select | CK 1 when idle    | phase  )
	SPI2_CR1 =  (0x3 << 8) |   (1 << 6)       | (0x7 << 3)   |   (1 << 2)    |    (1 << 1)       |  0x01    ;
 8003c0a:	4b0b      	ldr	r3, [pc, #44]	; (8003c38 <spi2rw_init+0x70>)
 8003c0c:	f240 327f 	movw	r2, #895	; 0x37f
 8003c10:	601a      	str	r2, [r3, #0]
	
	/* SPI-CR2 use default, no interrupt masks enabled at this point */

	/* Set and enable interrupt controller for SPI2 */
	NVICIPR (NVIC_SPI2_IRQ, SPI2_PRIORITY );	// Set interrupt priority
 8003c12:	4b0a      	ldr	r3, [pc, #40]	; (8003c3c <spi2rw_init+0x74>)
 8003c14:	681a      	ldr	r2, [r3, #0]
 8003c16:	f042 0250 	orr.w	r2, r2, #80	; 0x50
 8003c1a:	601a      	str	r2, [r3, #0]
	NVICISER(NVIC_SPI2_IRQ);			// Enable interrupt controller for SPI2
 8003c1c:	4b08      	ldr	r3, [pc, #32]	; (8003c40 <spi2rw_init+0x78>)
 8003c1e:	681a      	ldr	r2, [r3, #0]
 8003c20:	f042 0210 	orr.w	r2, r2, #16
 8003c24:	601a      	str	r2, [r3, #0]

	return;
}
 8003c26:	bd38      	pop	{r3, r4, r5, pc}
 8003c28:	40023840 	.word	0x40023840
 8003c2c:	0800b708 	.word	0x0800b708
 8003c30:	40020400 	.word	0x40020400
 8003c34:	40020418 	.word	0x40020418
 8003c38:	40003800 	.word	0x40003800
 8003c3c:	e000e424 	.word	0xe000e424
 8003c40:	e000e104 	.word	0xe000e104

08003c44 <spi2_busy>:
 * @return	: 0 = /CS line is low; not-zero (busy) = /CS line is high (not busy)
*******************************************************************************/
unsigned short spi2_busy(void)
{
/* The /CS line is used to show if the SPI transfer is in progress */
	return (GPIOB_ODR & (1<<12));	// Return /CS bit
 8003c44:	4b02      	ldr	r3, [pc, #8]	; (8003c50 <spi2_busy+0xc>)
 8003c46:	6818      	ldr	r0, [r3, #0]
}
 8003c48:	f400 5080 	and.w	r0, r0, #4096	; 0x1000
 8003c4c:	4770      	bx	lr
 8003c4e:	bf00      	nop
 8003c50:	40020414 	.word	0x40020414

08003c54 <spi2_rw>:
 * @param	: char *pout = pointer to byte array with bytes to output
 * @param	: char *pin  = pointer to byte array to receive bytes coming in
 * @param	: int count  = byte count of number of write/read cycles
*******************************************************************************/
void spi2_rw (char *pout, char * pin, int count)
{
 8003c54:	b570      	push	{r4, r5, r6, lr}
 8003c56:	4604      	mov	r4, r0
 8003c58:	460d      	mov	r5, r1
 8003c5a:	4616      	mov	r6, r2
	/* The following should not be necessary, but it is here JIC. */
	while ( spi2_busy() == 0 );	// Loop until a prior spi communication is complete
 8003c5c:	f7ff fff2 	bl	8003c44 <spi2_busy>
 8003c60:	2800      	cmp	r0, #0
 8003c62:	d0fb      	beq.n	8003c5c <spi2_rw+0x8>

	GPIO_BSRR(GPIOB)  = (1<<(12+16));	// Set /CS low (show busy)
 8003c64:	4b08      	ldr	r3, [pc, #32]	; (8003c88 <spi2_rw+0x34>)
 8003c66:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003c6a:	601a      	str	r2, [r3, #0]
	spi2_outptr = pout;		// Set pointer for interrupt handler to store outgoing data
	spi2_inptr = pin;		// Set pointer for interrupt handler to store incoming data
 8003c6c:	4b07      	ldr	r3, [pc, #28]	; (8003c8c <spi2_rw+0x38>)
	spi2_cnt = count;		// Set byte count for interrupt handler
	SPI2_DR = *spi2_outptr++;	// Load outgoing byte to start spi cycle
 8003c6e:	4a08      	ldr	r2, [pc, #32]	; (8003c90 <spi2_rw+0x3c>)
	/* The following should not be necessary, but it is here JIC. */
	while ( spi2_busy() == 0 );	// Loop until a prior spi communication is complete

	GPIO_BSRR(GPIOB)  = (1<<(12+16));	// Set /CS low (show busy)
	spi2_outptr = pout;		// Set pointer for interrupt handler to store outgoing data
	spi2_inptr = pin;		// Set pointer for interrupt handler to store incoming data
 8003c70:	601d      	str	r5, [r3, #0]
	spi2_cnt = count;		// Set byte count for interrupt handler
 8003c72:	605e      	str	r6, [r3, #4]
	SPI2_DR = *spi2_outptr++;	// Load outgoing byte to start spi cycle
 8003c74:	f814 1b01 	ldrb.w	r1, [r4], #1
 8003c78:	6011      	str	r1, [r2, #0]
 8003c7a:	609c      	str	r4, [r3, #8]
	SPI2_CR2 |= (SPI_CR2_RXNEIE);	// Enable receive buffer loaded (not empty) interrupt
 8003c7c:	4b05      	ldr	r3, [pc, #20]	; (8003c94 <spi2_rw+0x40>)
 8003c7e:	681a      	ldr	r2, [r3, #0]
 8003c80:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8003c84:	601a      	str	r2, [r3, #0]
	return;
}
 8003c86:	bd70      	pop	{r4, r5, r6, pc}
 8003c88:	40020418 	.word	0x40020418
 8003c8c:	20000820 	.word	0x20000820
 8003c90:	4000380c 	.word	0x4000380c
 8003c94:	40003804 	.word	0x40003804

08003c98 <SPI2_IRQHandler>:
off (not really necessary), and the i/o pin with the CS line is brought back high. 
*/

	volatile unsigned int dummy;

	if ( (SPI2_SR & SPI_SR_RXNE) != 0)  // Check for bogus interrupt
 8003c98:	4b15      	ldr	r3, [pc, #84]	; (8003cf0 <SPI2_IRQHandler+0x58>)
 8003c9a:	681b      	ldr	r3, [r3, #0]
 8003c9c:	f013 0f01 	tst.w	r3, #1
 * ISR routine
 *####################################################################################### */
int spidebug1;

void SPI2_IRQHandler(void)
{      
 8003ca0:	b507      	push	{r0, r1, r2, lr}
off (not really necessary), and the i/o pin with the CS line is brought back high. 
*/

	volatile unsigned int dummy;

	if ( (SPI2_SR & SPI_SR_RXNE) != 0)  // Check for bogus interrupt
 8003ca2:	d020      	beq.n	8003ce6 <SPI2_IRQHandler+0x4e>
	{ /* Here, valid receive interrupt. */
		*spi2_inptr++ = SPI2_DR;	// Get byte that was read
 8003ca4:	4b13      	ldr	r3, [pc, #76]	; (8003cf4 <SPI2_IRQHandler+0x5c>)
 8003ca6:	4914      	ldr	r1, [pc, #80]	; (8003cf8 <SPI2_IRQHandler+0x60>)
 8003ca8:	681a      	ldr	r2, [r3, #0]
 8003caa:	6808      	ldr	r0, [r1, #0]
 8003cac:	f802 0b01 	strb.w	r0, [r2], #1
 8003cb0:	601a      	str	r2, [r3, #0]
		spi2_cnt -= 1;	 		// Decrement byte count
 8003cb2:	685a      	ldr	r2, [r3, #4]
 8003cb4:	3a01      	subs	r2, #1
		if (spi2_cnt <= 0)		// Have we exhausted the count?
 8003cb6:	2a00      	cmp	r2, #0
	volatile unsigned int dummy;

	if ( (SPI2_SR & SPI_SR_RXNE) != 0)  // Check for bogus interrupt
	{ /* Here, valid receive interrupt. */
		*spi2_inptr++ = SPI2_DR;	// Get byte that was read
		spi2_cnt -= 1;	 		// Decrement byte count
 8003cb8:	605a      	str	r2, [r3, #4]
		if (spi2_cnt <= 0)		// Have we exhausted the count?
 8003cba:	dc0c      	bgt.n	8003cd6 <SPI2_IRQHandler+0x3e>
		{ /* Here, yes, this byte is the reponse from the last byte transmitted */ 
			SPI2_CR2 &= ~SPI_CR2_RXNEIE;	// Turn off RXE interrupt enable
 8003cbc:	4a0f      	ldr	r2, [pc, #60]	; (8003cfc <SPI2_IRQHandler+0x64>)
			GPIO_BSRR(GPIOB)  = (1<<12);// Set /CS high (show not busy)
			if (spi2_readdoneptr != 0) // Skip if pointer is NULL
 8003cbe:	68db      	ldr	r3, [r3, #12]
	{ /* Here, valid receive interrupt. */
		*spi2_inptr++ = SPI2_DR;	// Get byte that was read
		spi2_cnt -= 1;	 		// Decrement byte count
		if (spi2_cnt <= 0)		// Have we exhausted the count?
		{ /* Here, yes, this byte is the reponse from the last byte transmitted */ 
			SPI2_CR2 &= ~SPI_CR2_RXNEIE;	// Turn off RXE interrupt enable
 8003cc0:	6811      	ldr	r1, [r2, #0]
 8003cc2:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 8003cc6:	6011      	str	r1, [r2, #0]
			GPIO_BSRR(GPIOB)  = (1<<12);// Set /CS high (show not busy)
 8003cc8:	4a0d      	ldr	r2, [pc, #52]	; (8003d00 <SPI2_IRQHandler+0x68>)
 8003cca:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8003cce:	6011      	str	r1, [r2, #0]
			if (spi2_readdoneptr != 0) // Skip if pointer is NULL
 8003cd0:	b163      	cbz	r3, 8003cec <SPI2_IRQHandler+0x54>
				(*spi2_readdoneptr)();	// In case we want to do something else
 8003cd2:	4798      	blx	r3
 8003cd4:	e00a      	b.n	8003cec <SPI2_IRQHandler+0x54>
			return;
		}
		else
		{
spidebug1 +=1;
 8003cd6:	691a      	ldr	r2, [r3, #16]
 8003cd8:	3201      	adds	r2, #1
 8003cda:	611a      	str	r2, [r3, #16]
			SPI2_DR = *spi2_outptr++;	// Load outgoing byte to start next spi cycle
 8003cdc:	689a      	ldr	r2, [r3, #8]
 8003cde:	f812 0b01 	ldrb.w	r0, [r2], #1
 8003ce2:	6008      	str	r0, [r1, #0]
 8003ce4:	609a      	str	r2, [r3, #8]
		}
	}
	dummy = SPI2_SR; // Prevent tail-chaining.
 8003ce6:	4b02      	ldr	r3, [pc, #8]	; (8003cf0 <SPI2_IRQHandler+0x58>)
 8003ce8:	681b      	ldr	r3, [r3, #0]
 8003cea:	9301      	str	r3, [sp, #4]
	return;
}
 8003cec:	bd0e      	pop	{r1, r2, r3, pc}
 8003cee:	bf00      	nop
 8003cf0:	40003808 	.word	0x40003808
 8003cf4:	20000820 	.word	0x20000820
 8003cf8:	4000380c 	.word	0x4000380c
 8003cfc:	40003804 	.word	0x40003804
 8003d00:	40020418 	.word	0x40020418

08003d04 <convert>:
	pclk2_freq  =   hclk_freq/convert(clocks->apb2);	// APB2 driven from AHB
 	return;                                           
}
/* Convert 0,4,5,6,7 input to 1,2,4,8,16 */
unsigned int convert(unsigned int ucX)
{	
 8003d04:	2301      	movs	r3, #1
	return (ucX == 0)?:(1 << (ucX-3) );
 8003d06:	b118      	cbz	r0, 8003d10 <convert+0xc>
 8003d08:	3803      	subs	r0, #3
 8003d0a:	fa13 f000 	lsls.w	r0, r3, r0
 8003d0e:	4770      	bx	lr
 8003d10:	4618      	mov	r0, r3
}
 8003d12:	4770      	bx	lr

08003d14 <clockspecifysetup>:
 * @brief	: Setup the clocks & bus freq dividers
 * @param	: chase: 0 = use HSI (internal 8 MHz RC osc), 1 = use HSE (external Xtal osc)
 * @return	: static variables are set from input paramaters passed in struct
 ******************************************************************************/
void clockspecifysetup(struct CLOCKS *clocks)
{
 8003d14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003d16:	4603      	mov	r3, r0
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
	unsigned short sw_pll = 0;		// 0 = pll not used; 1 = pll used
	unsigned short pllp = clocks->pllp;	// Likely the clocks struct was a "const" and we may have to override the value given
 8003d18:	89c4      	ldrh	r4, [r0, #14]

	/* See Ref manual page 85 figure 9 */
	/* Note: Out of reset, the HSI (internal rc osc) is selected and ready. */


	switch (clocks->hso)	// Select high speed oscillator source
 8003d1a:	781a      	ldrb	r2, [r3, #0]
{
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
	unsigned short sw_pll = 0;		// 0 = pll not used; 1 = pll used
	unsigned short pllp = clocks->pllp;	// Likely the clocks struct was a "const" and we may have to override the value given
	unsigned short pllm = clocks->pllm;
 8003d1c:	8a41      	ldrh	r1, [r0, #18]
	unsigned short plln = clocks->plln;
	unsigned short pllq = clocks->pllq;
 8003d1e:	899d      	ldrh	r5, [r3, #12]
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
	unsigned short sw_pll = 0;		// 0 = pll not used; 1 = pll used
	unsigned short pllp = clocks->pllp;	// Likely the clocks struct was a "const" and we may have to override the value given
	unsigned short pllm = clocks->pllm;
	unsigned short plln = clocks->plln;
 8003d20:	8a00      	ldrh	r0, [r0, #16]
	unsigned short pllq = clocks->pllq;
	unsigned int	freq = clocks->freq;	
 8003d22:	689e      	ldr	r6, [r3, #8]

	/* See Ref manual page 85 figure 9 */
	/* Note: Out of reset, the HSI (internal rc osc) is selected and ready. */


	switch (clocks->hso)	// Select high speed oscillator source
 8003d24:	2a04      	cmp	r2, #4
 8003d26:	d834      	bhi.n	8003d92 <clockspecifysetup+0x7e>
 8003d28:	e8df f002 	tbb	[pc, r2]
 8003d2c:	1e110334 	.word	0x1e110334
 8003d30:	28          	.byte	0x28
 8003d31:	00          	.byte	0x00
		/* No action needed needed since HSI is already running and ready.  
			This osc as system clock is what got us to this point! */
		freq = 16000000;				// The internal RC osc is always 16MHz
		break;
	case 1: // Use external xtal controlled osc
		RCC_CR = RCC_CR_HSEON;			// Start hi-speed external oscillator
 8003d32:	4a6a      	ldr	r2, [pc, #424]	; (8003edc <clockspecifysetup+0x1c8>)
 8003d34:	f44f 3780 	mov.w	r7, #65536	; 0x10000
 8003d38:	6017      	str	r7, [r2, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 8003d3a:	4a68      	ldr	r2, [pc, #416]	; (8003edc <clockspecifysetup+0x1c8>)
 8003d3c:	6817      	ldr	r7, [r2, #0]
 8003d3e:	f417 3f00 	tst.w	r7, #131072	; 0x20000
 8003d42:	d0fa      	beq.n	8003d3a <clockspecifysetup+0x26>
		usSW = 0x01;				// SWS = HSE as system clock
RCC_CR &= ~RCC_CR_HSION;	// Turn off HSI osc
 8003d44:	6817      	ldr	r7, [r2, #0]
 8003d46:	f027 0701 	bic.w	r7, r7, #1
 8003d4a:	6017      	str	r7, [r2, #0]
 8003d4c:	e01f      	b.n	8003d8e <clockspecifysetup+0x7a>
		break;
	case 2: // Use external signal input
		RCC_CR = RCC_CR_HSEBYP;			// By-pass external osc and use external signal
 8003d4e:	4a63      	ldr	r2, [pc, #396]	; (8003edc <clockspecifysetup+0x1c8>)
 8003d50:	f44f 2780 	mov.w	r7, #262144	; 0x40000
 8003d54:	6017      	str	r7, [r2, #0]
		RCC_CR = RCC_CR_HSEON;			// Start hi-speed external clock
 8003d56:	f44f 3780 	mov.w	r7, #65536	; 0x10000
 8003d5a:	6017      	str	r7, [r2, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 8003d5c:	4a5f      	ldr	r2, [pc, #380]	; (8003edc <clockspecifysetup+0x1c8>)
 8003d5e:	6812      	ldr	r2, [r2, #0]
 8003d60:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8003d64:	d0fa      	beq.n	8003d5c <clockspecifysetup+0x48>
 8003d66:	e012      	b.n	8003d8e <clockspecifysetup+0x7a>
		usSW = 0x01;				// SWS = HSE as system clock
		break;
	case 3: // Use remapped external osc *xtal*
//$$$		AFIO_MAPR |= (1 << 15); 		// Bit 15 PD01_REMAP: Port D0/Port D1 mapping on OSC_IN/OSC_OUT		
		RCC_CR = RCC_CR_HSEON;			// Start oscillators hi-speed internal and external
 8003d68:	4a5c      	ldr	r2, [pc, #368]	; (8003edc <clockspecifysetup+0x1c8>)
 8003d6a:	f44f 3780 	mov.w	r7, #65536	; 0x10000
 8003d6e:	6017      	str	r7, [r2, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 8003d70:	4a5a      	ldr	r2, [pc, #360]	; (8003edc <clockspecifysetup+0x1c8>)
 8003d72:	6812      	ldr	r2, [r2, #0]
 8003d74:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8003d78:	d0fa      	beq.n	8003d70 <clockspecifysetup+0x5c>
 8003d7a:	e008      	b.n	8003d8e <clockspecifysetup+0x7a>
		usSW = 0x01;				// SWS = HSE as system clock
		break;
	case 4: // Use remapped external osc *signal*
//$$$		AFIO_MAPR |= (1 << 15); 		// Bit 15 PD01_REMAP: Port D0/Port D1 mapping on OSC_IN/OSC_OUT		
		RCC_CR = RCC_CR_HSEBYP;			// By-pass external osc and use external signal
 8003d7c:	4a57      	ldr	r2, [pc, #348]	; (8003edc <clockspecifysetup+0x1c8>)
 8003d7e:	f44f 2780 	mov.w	r7, #262144	; 0x40000
 8003d82:	6017      	str	r7, [r2, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 8003d84:	4a55      	ldr	r2, [pc, #340]	; (8003edc <clockspecifysetup+0x1c8>)
 8003d86:	6812      	ldr	r2, [r2, #0]
 8003d88:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8003d8c:	d0fa      	beq.n	8003d84 <clockspecifysetup+0x70>
		usSW = 0x01;				// SWS = HSE as system clock
 8003d8e:	2201      	movs	r2, #1
 8003d90:	e002      	b.n	8003d98 <clockspecifysetup+0x84>
 8003d92:	e7fe      	b.n	8003d92 <clockspecifysetup+0x7e>
	switch (clocks->hso)	// Select high speed oscillator source
	{
	case 0:	// Use internal 16 Mhz rc osc
		/* No action needed needed since HSI is already running and ready.  
			This osc as system clock is what got us to this point! */
		freq = 16000000;				// The internal RC osc is always 16MHz
 8003d94:	4e52      	ldr	r6, [pc, #328]	; (8003ee0 <clockspecifysetup+0x1cc>)
 * @param	: chase: 0 = use HSI (internal 8 MHz RC osc), 1 = use HSE (external Xtal osc)
 * @return	: static variables are set from input paramaters passed in struct
 ******************************************************************************/
void clockspecifysetup(struct CLOCKS *clocks)
{
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
 8003d96:	2200      	movs	r2, #0
This register is used to configure the PLL clock outputs according to the formulas:
    f(VCO clock) = f(PLL clock input)  (PLLN / PLLM)
    f(PLL general clock output) = f(VCO clock) / PLLP
    f(USB OTG FS, SDIO, RNG clock output) = f(VCO clock) / PLLQ
*/
	if ( (plln != 0) && (pllm != 0) ) // Is PLL multiplier/divider specifed?
 8003d98:	2800      	cmp	r0, #0
 8003d9a:	d041      	beq.n	8003e20 <clockspecifysetup+0x10c>
 8003d9c:	2900      	cmp	r1, #0
 8003d9e:	d041      	beq.n	8003e24 <clockspecifysetup+0x110>
	{ // Here, yes the PLL is to be used

		/* Make sure pllp is valid */
		if ((clocks->pllp >> 1) == 0 ) pllp = 2;
 8003da0:	89df      	ldrh	r7, [r3, #14]
 8003da2:	087f      	lsrs	r7, r7, #1
 8003da4:	d003      	beq.n	8003dae <clockspecifysetup+0x9a>
		if ((clocks->pllp >> 1) >  4 ) pllp = 8;
 8003da6:	2f04      	cmp	r7, #4
 8003da8:	bf88      	it	hi
 8003daa:	2408      	movhi	r4, #8
 8003dac:	e000      	b.n	8003db0 <clockspecifysetup+0x9c>
*/
	if ( (plln != 0) && (pllm != 0) ) // Is PLL multiplier/divider specifed?
	{ // Here, yes the PLL is to be used

		/* Make sure pllp is valid */
		if ((clocks->pllp >> 1) == 0 ) pllp = 2;
 8003dae:	2402      	movs	r4, #2
		if ((clocks->pllp >> 1) >  4 ) pllp = 8;

		/* Make sure plln, pllm is within range */
		if (plln > 432 ) while (1==1);
 8003db0:	f5b0 7fd8 	cmp.w	r0, #432	; 0x1b0
 8003db4:	d900      	bls.n	8003db8 <clockspecifysetup+0xa4>
 8003db6:	e7fe      	b.n	8003db6 <clockspecifysetup+0xa2>
		if (plln <   2 ) while (1==1);
 8003db8:	2801      	cmp	r0, #1
 8003dba:	d100      	bne.n	8003dbe <clockspecifysetup+0xaa>
 8003dbc:	e7fe      	b.n	8003dbc <clockspecifysetup+0xa8>
		if (pllm >  64 ) while (1==1);
 8003dbe:	2940      	cmp	r1, #64	; 0x40
 8003dc0:	d900      	bls.n	8003dc4 <clockspecifysetup+0xb0>
 8003dc2:	e7fe      	b.n	8003dc2 <clockspecifysetup+0xae>
		if (pllm <   2 ) while (1==1);	
 8003dc4:	2901      	cmp	r1, #1
 8003dc6:	d100      	bne.n	8003dca <clockspecifysetup+0xb6>
 8003dc8:	e7fe      	b.n	8003dc8 <clockspecifysetup+0xb4>

		/* Divider for 48 MHz peripherals */
		if ((pllq == 0) || (pllq > 15)) pllq = 15;	
 8003dca:	1e6f      	subs	r7, r5, #1
 8003dcc:	b2bf      	uxth	r7, r7
 8003dce:	2f0e      	cmp	r7, #14
 8003dd0:	bf88      	it	hi
 8003dd2:	250f      	movhi	r5, #15

		vco_freq = (freq * clocks->plln) / clocks->pllm; 	// VCO freq
 8003dd4:	8a1f      	ldrh	r7, [r3, #16]
 8003dd6:	437e      	muls	r6, r7
 8003dd8:	8a5f      	ldrh	r7, [r3, #18]
 8003dda:	fbb6 f6f7 	udiv	r6, r6, r7

		/* Don't blast ahead if the VCO freq is out of range */
		if (vco_freq > 432000000) while(1==1); 	// SCREWED
 8003dde:	4f41      	ldr	r7, [pc, #260]	; (8003ee4 <clockspecifysetup+0x1d0>)
 8003de0:	42be      	cmp	r6, r7
 8003de2:	d900      	bls.n	8003de6 <clockspecifysetup+0xd2>
 8003de4:	e7fe      	b.n	8003de4 <clockspecifysetup+0xd0>
		if (vco_freq < 64) 	  while(1==1); 	// SCREWED
 8003de6:	2e3f      	cmp	r6, #63	; 0x3f
 8003de8:	d800      	bhi.n	8003dec <clockspecifysetup+0xd8>
 8003dea:	e7fe      	b.n	8003dea <clockspecifysetup+0xd6>
		
		sysclk_freq = vco_freq / pllp;
 8003dec:	4f3e      	ldr	r7, [pc, #248]	; (8003ee8 <clockspecifysetup+0x1d4>)
 8003dee:	fbb6 f6f4 	udiv	r6, r6, r4
 8003df2:	603e      	str	r6, [r7, #0]

		/* Don't blast ahead if the sysclk freq is too high */
		if (sysclk_freq > 168000000)	while(1==1); // SCREWED
 8003df4:	4f3d      	ldr	r7, [pc, #244]	; (8003eec <clockspecifysetup+0x1d8>)
 8003df6:	42be      	cmp	r6, r7
 8003df8:	d900      	bls.n	8003dfc <clockspecifysetup+0xe8>
 8003dfa:	e7fe      	b.n	8003dfa <clockspecifysetup+0xe6>

		/* Setup PLL counts */
		RCC_PLLCFGR = (pllq << 24) | ( (clocks->pllsrc & 0x01) << 22) | ( pllp << 16) | ( (plln & 0x01ff) << 6) | (pllm);
 8003dfc:	785e      	ldrb	r6, [r3, #1]
 8003dfe:	05c0      	lsls	r0, r0, #23
 8003e00:	0dc0      	lsrs	r0, r0, #23
 8003e02:	f006 0601 	and.w	r6, r6, #1
 8003e06:	0180      	lsls	r0, r0, #6
 8003e08:	ea40 5086 	orr.w	r0, r0, r6, lsl #22
 8003e0c:	ea40 0101 	orr.w	r1, r0, r1
 8003e10:	ea41 4404 	orr.w	r4, r1, r4, lsl #16
 8003e14:	4836      	ldr	r0, [pc, #216]	; (8003ef0 <clockspecifysetup+0x1dc>)
 8003e16:	ea44 6505 	orr.w	r5, r4, r5, lsl #24
 8003e1a:	6005      	str	r5, [r0, #0]

		sw_pll = 1;
 8003e1c:	2601      	movs	r6, #1
 8003e1e:	e002      	b.n	8003e26 <clockspecifysetup+0x112>
 ******************************************************************************/
void clockspecifysetup(struct CLOCKS *clocks)
{
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
	unsigned short sw_pll = 0;		// 0 = pll not used; 1 = pll used
 8003e20:	4606      	mov	r6, r0
 8003e22:	e000      	b.n	8003e26 <clockspecifysetup+0x112>
 8003e24:	460e      	mov	r6, r1

		sw_pll = 1;
	}

	/* Determine number of flash wait states p 55.  2.7-3.6v ONLY */
	if (sysclk_freq >  30) ws = 1;
 8003e26:	4930      	ldr	r1, [pc, #192]	; (8003ee8 <clockspecifysetup+0x1d4>)
 8003e28:	680c      	ldr	r4, [r1, #0]
 8003e2a:	2c1e      	cmp	r4, #30
 8003e2c:	d94e      	bls.n	8003ecc <clockspecifysetup+0x1b8>
	if (sysclk_freq >  60) ws = 2;
 8003e2e:	2c3c      	cmp	r4, #60	; 0x3c
 8003e30:	d94e      	bls.n	8003ed0 <clockspecifysetup+0x1bc>
	if (sysclk_freq >  90) ws = 3;
 8003e32:	2c5a      	cmp	r4, #90	; 0x5a
 8003e34:	d94e      	bls.n	8003ed4 <clockspecifysetup+0x1c0>
	if (sysclk_freq > 120) ws = 4;
 8003e36:	2c78      	cmp	r4, #120	; 0x78
 8003e38:	d94e      	bls.n	8003ed8 <clockspecifysetup+0x1c4>
 8003e3a:	2c96      	cmp	r4, #150	; 0x96
 8003e3c:	bf8c      	ite	hi
 8003e3e:	2105      	movhi	r1, #5
 8003e40:	2104      	movls	r1, #4
	if (sysclk_freq > 150) ws = 5;

	/* Set wait states in register */
	FLASH_ACR |= ws;
 8003e42:	482c      	ldr	r0, [pc, #176]	; (8003ef4 <clockspecifysetup+0x1e0>)
 8003e44:	6805      	ldr	r5, [r0, #0]
 8003e46:	ea41 0505 	orr.w	r5, r1, r5
 8003e4a:	6005      	str	r5, [r0, #0]

	/* Wait for register to become effective p 55 */
	while ((FLASH_ACR & 0x07) != ws);
 8003e4c:	4829      	ldr	r0, [pc, #164]	; (8003ef4 <clockspecifysetup+0x1e0>)
 8003e4e:	6800      	ldr	r0, [r0, #0]
 8003e50:	f000 0007 	and.w	r0, r0, #7
 8003e54:	4288      	cmp	r0, r1
 8003e56:	d1f9      	bne.n	8003e4c <clockspecifysetup+0x138>


	/* Clock configuraton register (Ref manual, page 97)	*/
	// Setup up bus dividers
	RCC_CFGR = (clocks->apb2  << 13)  |	/* (3b) PPRE2: ABP2 prescaler bit code	(4-7)		*/ 
 8003e58:	78dd      	ldrb	r5, [r3, #3]
		   (clocks->apb1  << 10)  |	/* (3b) PPRE1: APB1 prescaler bit code	(4-7)		*/ 
 8003e5a:	7898      	ldrb	r0, [r3, #2]
		   (clocks->ahb   <<  4)  ;	/* (4b) HPRE:  AHB  prescaler bit code	(8-15)		*/
 8003e5c:	791b      	ldrb	r3, [r3, #4]
	while ((FLASH_ACR & 0x07) != ws);


	/* Clock configuraton register (Ref manual, page 97)	*/
	// Setup up bus dividers
	RCC_CFGR = (clocks->apb2  << 13)  |	/* (3b) PPRE2: ABP2 prescaler bit code	(4-7)		*/ 
 8003e5e:	4926      	ldr	r1, [pc, #152]	; (8003ef8 <clockspecifysetup+0x1e4>)
 8003e60:	036f      	lsls	r7, r5, #13
 8003e62:	ea47 2780 	orr.w	r7, r7, r0, lsl #10
		   (clocks->apb1  << 10)  |	/* (3b) PPRE1: APB1 prescaler bit code	(4-7)		*/ 
 8003e66:	ea47 1703 	orr.w	r7, r7, r3, lsl #4
		   (clocks->ahb   <<  4)  ;	/* (4b) HPRE:  AHB  prescaler bit code	(8-15)		*/


	if (sw_pll == 1)	// Are we using the PLL?
 8003e6a:	2e01      	cmp	r6, #1
	while ((FLASH_ACR & 0x07) != ws);


	/* Clock configuraton register (Ref manual, page 97)	*/
	// Setup up bus dividers
	RCC_CFGR = (clocks->apb2  << 13)  |	/* (3b) PPRE2: ABP2 prescaler bit code	(4-7)		*/ 
 8003e6c:	600f      	str	r7, [r1, #0]
		   (clocks->apb1  << 10)  |	/* (3b) PPRE1: APB1 prescaler bit code	(4-7)		*/ 
		   (clocks->ahb   <<  4)  ;	/* (4b) HPRE:  AHB  prescaler bit code	(8-15)		*/


	if (sw_pll == 1)	// Are we using the PLL?
 8003e6e:	d10a      	bne.n	8003e86 <clockspecifysetup+0x172>
	{ // Here yes, start PLL
		// Enable PLL
		RCC_CR |= (1<<24);			// PLLON:  Turn PLL on
 8003e70:	4a1a      	ldr	r2, [pc, #104]	; (8003edc <clockspecifysetup+0x1c8>)
 8003e72:	6811      	ldr	r1, [r2, #0]
 8003e74:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 8003e78:	6011      	str	r1, [r2, #0]
		while ((RCC_CR & (1<<25) ) == 0);	// PLLRDY: Wait for PLL to become ready
 8003e7a:	4a18      	ldr	r2, [pc, #96]	; (8003edc <clockspecifysetup+0x1c8>)
 8003e7c:	6812      	ldr	r2, [r2, #0]
 8003e7e:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8003e82:	d0fa      	beq.n	8003e7a <clockspecifysetup+0x166>

		// Select PLL as system clock source 
		usSW = 0x02;				// Change the usSW code for PLL
 8003e84:	2202      	movs	r2, #2
	}

	

	/* Switch the system clock source to the one specified */
	RCC_CFGR = (RCC_CFGR & ~0x03) | usSW;		// Set system clock source (it has been running on HSI (internal 8 MHz rc clock)
 8003e86:	491c      	ldr	r1, [pc, #112]	; (8003ef8 <clockspecifysetup+0x1e4>)
 8003e88:	680e      	ldr	r6, [r1, #0]
 8003e8a:	f026 0603 	bic.w	r6, r6, #3
 8003e8e:	ea42 0606 	orr.w	r6, r2, r6
 8003e92:	600e      	str	r6, [r1, #0]
	while ( (RCC_CFGR & 0x0c) != (unsigned short)(usSW << 2) );	// Wait until system is running on the clock source
 8003e94:	0092      	lsls	r2, r2, #2
 8003e96:	4918      	ldr	r1, [pc, #96]	; (8003ef8 <clockspecifysetup+0x1e4>)
 8003e98:	6809      	ldr	r1, [r1, #0]
 8003e9a:	f001 010c 	and.w	r1, r1, #12
 8003e9e:	4291      	cmp	r1, r2
 8003ea0:	d1f9      	bne.n	8003e96 <clockspecifysetup+0x182>


	/* Compute static variables with bus freqs that other routines will use to for their setup */
	hclk_freq   = sysclk_freq/ahbtbl[(clocks->ahb)];	// AHB bus freq = sysclck/ ahb bus divider
 8003ea2:	4a16      	ldr	r2, [pc, #88]	; (8003efc <clockspecifysetup+0x1e8>)
 8003ea4:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8003ea8:	fbb4 f4f3 	udiv	r4, r4, r3
 8003eac:	4b14      	ldr	r3, [pc, #80]	; (8003f00 <clockspecifysetup+0x1ec>)
 8003eae:	601c      	str	r4, [r3, #0]
	pclk1_freq  =   hclk_freq/convert(clocks->apb1);	// APB1 driven from AHB (must not exceed 36 MHz)
 8003eb0:	f7ff ff28 	bl	8003d04 <convert>
 8003eb4:	4b13      	ldr	r3, [pc, #76]	; (8003f04 <clockspecifysetup+0x1f0>)
 8003eb6:	fbb4 f0f0 	udiv	r0, r4, r0
 8003eba:	6018      	str	r0, [r3, #0]
	pclk2_freq  =   hclk_freq/convert(clocks->apb2);	// APB2 driven from AHB
 8003ebc:	4628      	mov	r0, r5
 8003ebe:	f7ff ff21 	bl	8003d04 <convert>
 8003ec2:	4b11      	ldr	r3, [pc, #68]	; (8003f08 <clockspecifysetup+0x1f4>)
 8003ec4:	fbb4 f0f0 	udiv	r0, r4, r0
 8003ec8:	6018      	str	r0, [r3, #0]
 	return;                                           
}
 8003eca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 * @return	: static variables are set from input paramaters passed in struct
 ******************************************************************************/
void clockspecifysetup(struct CLOCKS *clocks)
{
	unsigned short usSW = 0;		// Oscillator selection code (default = HSI)
	unsigned short ws = 0;			// Wait states (default for 16 MHz HSI)
 8003ecc:	2100      	movs	r1, #0
 8003ece:	e7b8      	b.n	8003e42 <clockspecifysetup+0x12e>

		sw_pll = 1;
	}

	/* Determine number of flash wait states p 55.  2.7-3.6v ONLY */
	if (sysclk_freq >  30) ws = 1;
 8003ed0:	2101      	movs	r1, #1
 8003ed2:	e7b6      	b.n	8003e42 <clockspecifysetup+0x12e>
	if (sysclk_freq >  60) ws = 2;
 8003ed4:	2102      	movs	r1, #2
 8003ed6:	e7b4      	b.n	8003e42 <clockspecifysetup+0x12e>
	if (sysclk_freq >  90) ws = 3;
 8003ed8:	2103      	movs	r1, #3
 8003eda:	e7b2      	b.n	8003e42 <clockspecifysetup+0x12e>
 8003edc:	40023800 	.word	0x40023800
 8003ee0:	00f42400 	.word	0x00f42400
 8003ee4:	19bfcc00 	.word	0x19bfcc00
 8003ee8:	20000840 	.word	0x20000840
 8003eec:	0a037a00 	.word	0x0a037a00
 8003ef0:	40023804 	.word	0x40023804
 8003ef4:	40023c00 	.word	0x40023c00
 8003ef8:	40023808 	.word	0x40023808
 8003efc:	0800b718 	.word	0x0800b718
 8003f00:	20000834 	.word	0x20000834
 8003f04:	20000838 	.word	0x20000838
 8003f08:	2000083c 	.word	0x2000083c

08003f0c <clockI2Ssetup>:
int clockI2Ssetup(unsigned int R, unsigned int N)
{
	int i = 10000;	// Anti-hang loop counter
	
	/* Check input value ranges */
	if (R <   2) return 1;
 8003f0c:	2801      	cmp	r0, #1
 * @param	: R = valid range: 2-7 (3 bits)
 * @param	: N = valid range: 192-432 (9 bits). 
 * @return	: 0 = OK; 1 = failed
 ******************************************************************************/
int clockI2Ssetup(unsigned int R, unsigned int N)
{
 8003f0e:	b530      	push	{r4, r5, lr}
	int i = 10000;	// Anti-hang loop counter
	
	/* Check input value ranges */
	if (R <   2) return 1;
 8003f10:	d91f      	bls.n	8003f52 <clockI2Ssetup+0x46>
	if (R >   7) return 1;
 8003f12:	2807      	cmp	r0, #7
 8003f14:	d81d      	bhi.n	8003f52 <clockI2Ssetup+0x46>
	if (N < 192) return 1;
 8003f16:	29bf      	cmp	r1, #191	; 0xbf
 8003f18:	d91b      	bls.n	8003f52 <clockI2Ssetup+0x46>
	if (N > 432) return 1;
 8003f1a:	f5b1 7fd8 	cmp.w	r1, #432	; 0x1b0
 8003f1e:	d81a      	bhi.n	8003f56 <clockI2Ssetup+0x4a>

	/* Turn PLL off and reset counters */
	RCC_CR &= ~(1<<26);			// Disable PLL2I2S if previously enabled (p 92)
 8003f20:	4b0e      	ldr	r3, [pc, #56]	; (8003f5c <clockI2Ssetup+0x50>)
	while ( (RCC_CR & (1<<27)) == 1 );	// Be sure it is not ready (p 93)
	RCC_PLLI2SCFGR &= ~(0x70007fc0) ;	// Reset current R & N setttings (p 132)
 8003f22:	4c0f      	ldr	r4, [pc, #60]	; (8003f60 <clockI2Ssetup+0x54>)
	if (R >   7) return 1;
	if (N < 192) return 1;
	if (N > 432) return 1;

	/* Turn PLL off and reset counters */
	RCC_CR &= ~(1<<26);			// Disable PLL2I2S if previously enabled (p 92)
 8003f24:	681a      	ldr	r2, [r3, #0]
 8003f26:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8003f2a:	601a      	str	r2, [r3, #0]
	while ( (RCC_CR & (1<<27)) == 1 );	// Be sure it is not ready (p 93)
 8003f2c:	681a      	ldr	r2, [r3, #0]
	RCC_PLLI2SCFGR &= ~(0x70007fc0) ;	// Reset current R & N setttings (p 132)
 8003f2e:	4a0d      	ldr	r2, [pc, #52]	; (8003f64 <clockI2Ssetup+0x58>)
 8003f30:	6815      	ldr	r5, [r2, #0]
 8003f32:	ea05 0404 	and.w	r4, r5, r4
 8003f36:	6014      	str	r4, [r2, #0]

	/* Set up new PLL counters (p 132) */
	RCC_PLLI2SCFGR |= (R << 28) | (N << 6) ;
 8003f38:	6814      	ldr	r4, [r2, #0]
 8003f3a:	ea44 7000 	orr.w	r0, r4, r0, lsl #28
 8003f3e:	ea40 1181 	orr.w	r1, r0, r1, lsl #6
 8003f42:	6011      	str	r1, [r2, #0]

	/* Enable PLL */
	RCC_CR |= (1<<26);	// Enable bit
 8003f44:	681a      	ldr	r2, [r3, #0]
 8003f46:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8003f4a:	601a      	str	r2, [r3, #0]

	/* Wait for it to come ready, but don't allow to hang forever. (p 93) */
	while ( ((RCC_CR & (1<<27)) == 1) && (--i > 0) );
 8003f4c:	681b      	ldr	r3, [r3, #0]
	if ( i < 0 ) return 1;		// Timed out

	return 0;
 8003f4e:	2000      	movs	r0, #0
 8003f50:	bd30      	pop	{r4, r5, pc}
	int i = 10000;	// Anti-hang loop counter
	
	/* Check input value ranges */
	if (R <   2) return 1;
	if (R >   7) return 1;
	if (N < 192) return 1;
 8003f52:	2001      	movs	r0, #1
 8003f54:	bd30      	pop	{r4, r5, pc}
	if (N > 432) return 1;
 8003f56:	2001      	movs	r0, #1
	/* Wait for it to come ready, but don't allow to hang forever. (p 93) */
	while ( ((RCC_CR & (1<<27)) == 1) && (--i > 0) );
	if ( i < 0 ) return 1;		// Timed out

	return 0;
}
 8003f58:	bd30      	pop	{r4, r5, pc}
 8003f5a:	bf00      	nop
 8003f5c:	40023800 	.word	0x40023800
 8003f60:	8fff803f 	.word	0x8fff803f
 8003f64:	40023884 	.word	0x40023884

08003f68 <nvic_dma_stream_vector_add>:
 * @param	: stream_number = 0-7 for stream selected
 * @return	: 0 = OK; -1 = irq number out of range; -2 or less = stream already in use
******************************************************************************/
int nvic_dma_stream_vector_add(void(*p)(u32*), u32* q, u32 dma_irq_number, u32 stream_number)
{
	if (stream_number > 7) return -1;	// JIC a bozo sent a bad number
 8003f68:	2b07      	cmp	r3, #7
 * @param	: dma_irq_number = nvic irq number
 * @param	: stream_number = 0-7 for stream selected
 * @return	: 0 = OK; -1 = irq number out of range; -2 or less = stream already in use
******************************************************************************/
int nvic_dma_stream_vector_add(void(*p)(u32*), u32* q, u32 dma_irq_number, u32 stream_number)
{
 8003f6a:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (stream_number > 7) return -1;	// JIC a bozo sent a bad number
 8003f6c:	d863      	bhi.n	8004036 <nvic_dma_stream_vector_add+0xce>

	/* Convert DMA irq number (vector position) to an index 0 - 7 */
	// --------- DMA1 -----------
	if ((dma_irq_number >= DMASTRM10) && (dma_irq_number <= DMASTRM16))
 8003f6e:	f1a2 040b 	sub.w	r4, r2, #11
 8003f72:	2c06      	cmp	r4, #6
 8003f74:	d815      	bhi.n	8003fa2 <nvic_dma_stream_vector_add+0x3a>
	{
		if ((dma1_stream_use & (1 << stream_number)) != 0) return -2; 	// Already setup
 8003f76:	4a39      	ldr	r2, [pc, #228]	; (800405c <nvic_dma_stream_vector_add+0xf4>)
 8003f78:	7815      	ldrb	r5, [r2, #0]
 8003f7a:	fa55 f603 	asrs.w	r6, r5, r3
 8003f7e:	f016 0601 	ands.w	r6, r6, #1
 8003f82:	d15b      	bne.n	800403c <nvic_dma_stream_vector_add+0xd4>
		dma1_stream_use |=     (1 << stream_number);			// Set bit to show used
 8003f84:	2701      	movs	r7, #1
 8003f86:	fa17 f303 	lsls.w	r3, r7, r3
 8003f8a:	ea43 0505 	orr.w	r5, r3, r5
 8003f8e:	7015      	strb	r5, [r2, #0]
		dma1[(dma_irq_number - DMASTRM10)].jmp  = p; // Pointer to IRQ handler
		dma1[(dma_irq_number - DMASTRM10)].base = q; // Pointer to control block
		RCC_AHB1ENR |= (1<<21); // Enable DMA1 clocking
 8003f90:	4b33      	ldr	r3, [pc, #204]	; (8004060 <nvic_dma_stream_vector_add+0xf8>)
	// --------- DMA1 -----------
	if ((dma_irq_number >= DMASTRM10) && (dma_irq_number <= DMASTRM16))
	{
		if ((dma1_stream_use & (1 << stream_number)) != 0) return -2; 	// Already setup
		dma1_stream_use |=     (1 << stream_number);			// Set bit to show used
		dma1[(dma_irq_number - DMASTRM10)].jmp  = p; // Pointer to IRQ handler
 8003f92:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 8003f96:	6050      	str	r0, [r2, #4]
		dma1[(dma_irq_number - DMASTRM10)].base = q; // Pointer to control block
 8003f98:	6091      	str	r1, [r2, #8]
		RCC_AHB1ENR |= (1<<21); // Enable DMA1 clocking
 8003f9a:	681a      	ldr	r2, [r3, #0]
 8003f9c:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8003fa0:	e046      	b.n	8004030 <nvic_dma_stream_vector_add+0xc8>
		return 0;
	}
	if (dma_irq_number == DMASTRM17)
 8003fa2:	2a2f      	cmp	r2, #47	; 0x2f
 8003fa4:	d110      	bne.n	8003fc8 <nvic_dma_stream_vector_add+0x60>
	{
		if ((dma1_stream_use & 0x80) != 0) return -3; 	// Already setup
 8003fa6:	4b2d      	ldr	r3, [pc, #180]	; (800405c <nvic_dma_stream_vector_add+0xf4>)
 8003fa8:	781a      	ldrb	r2, [r3, #0]
 8003faa:	f012 0f80 	tst.w	r2, #128	; 0x80
 8003fae:	d148      	bne.n	8004042 <nvic_dma_stream_vector_add+0xda>
		dma1_stream_use |=     0x80;			// Set bit to show used
 8003fb0:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8003fb4:	701a      	strb	r2, [r3, #0]
		dma1[7].jmp  = p; 
 8003fb6:	63d8      	str	r0, [r3, #60]	; 0x3c
		dma1[7].base = q;
 8003fb8:	6419      	str	r1, [r3, #64]	; 0x40
		RCC_AHB1ENR |= (1<<21); // Enable DMA1 clocking
 8003fba:	4b29      	ldr	r3, [pc, #164]	; (8004060 <nvic_dma_stream_vector_add+0xf8>)
 8003fbc:	681a      	ldr	r2, [r3, #0]
 8003fbe:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8003fc2:	601a      	str	r2, [r3, #0]
		return 0;
 8003fc4:	2000      	movs	r0, #0
 8003fc6:	bdf0      	pop	{r4, r5, r6, r7, pc}

	// --------- DMA2 -----------
	}
	if ( (dma_irq_number >= DMASTRM20) && (dma_irq_number <= DMASTRM24 ))
 8003fc8:	f1a2 0438 	sub.w	r4, r2, #56	; 0x38
 8003fcc:	2c04      	cmp	r4, #4
 8003fce:	d813      	bhi.n	8003ff8 <nvic_dma_stream_vector_add+0x90>
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -4; 	// Already setup
 8003fd0:	4a22      	ldr	r2, [pc, #136]	; (800405c <nvic_dma_stream_vector_add+0xf4>)
 8003fd2:	f892 5044 	ldrb.w	r5, [r2, #68]	; 0x44
 8003fd6:	fa55 f603 	asrs.w	r6, r5, r3
 8003fda:	f016 0601 	ands.w	r6, r6, #1
 8003fde:	d133      	bne.n	8004048 <nvic_dma_stream_vector_add+0xe0>
		dma2_stream_use |=     (1 << stream_number);			// Set bit to show used
 8003fe0:	2701      	movs	r7, #1
 8003fe2:	fa17 f303 	lsls.w	r3, r7, r3
 8003fe6:	ea43 0505 	orr.w	r5, r3, r5
 8003fea:	f882 5044 	strb.w	r5, [r2, #68]	; 0x44
		dma2[dma_irq_number - DMASTRM20].jmp  = p; 
 8003fee:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 8003ff2:	6490      	str	r0, [r2, #72]	; 0x48
		dma2[dma_irq_number - DMASTRM20].base = q;
 8003ff4:	64d1      	str	r1, [r2, #76]	; 0x4c
 8003ff6:	e017      	b.n	8004028 <nvic_dma_stream_vector_add+0xc0>
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
		return 0;
	}
	if ( (dma_irq_number >= DMASTRM25) && (dma_irq_number <= DMASTRM27 ))
 8003ff8:	f1a2 0444 	sub.w	r4, r2, #68	; 0x44
 8003ffc:	2c02      	cmp	r4, #2
 8003ffe:	d826      	bhi.n	800404e <nvic_dma_stream_vector_add+0xe6>
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -5; 	// Already setup
 8004000:	4c16      	ldr	r4, [pc, #88]	; (800405c <nvic_dma_stream_vector_add+0xf4>)
 8004002:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
 8004006:	fa55 f603 	asrs.w	r6, r5, r3
 800400a:	f016 0601 	ands.w	r6, r6, #1
 800400e:	d121      	bne.n	8004054 <nvic_dma_stream_vector_add+0xec>
		dma2_stream_use |=     (1 << stream_number);			// Set bit to show used
 8004010:	2701      	movs	r7, #1
 8004012:	fa17 f303 	lsls.w	r3, r7, r3
 8004016:	ea43 0505 	orr.w	r5, r3, r5
		dma2[dma_irq_number - DMASTRM25 + 5].jmp  = p; 
 800401a:	3a3f      	subs	r2, #63	; 0x3f
		return 0;
	}
	if ( (dma_irq_number >= DMASTRM25) && (dma_irq_number <= DMASTRM27 ))
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -5; 	// Already setup
		dma2_stream_use |=     (1 << stream_number);			// Set bit to show used
 800401c:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
		dma2[dma_irq_number - DMASTRM25 + 5].jmp  = p; 
 8004020:	eb04 04c2 	add.w	r4, r4, r2, lsl #3
 8004024:	64a0      	str	r0, [r4, #72]	; 0x48
		dma2[dma_irq_number - DMASTRM25 + 5].base = q; 
 8004026:	64e1      	str	r1, [r4, #76]	; 0x4c
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
 8004028:	4b0d      	ldr	r3, [pc, #52]	; (8004060 <nvic_dma_stream_vector_add+0xf8>)
 800402a:	681a      	ldr	r2, [r3, #0]
 800402c:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8004030:	601a      	str	r2, [r3, #0]
		return 0;
 8004032:	4630      	mov	r0, r6
 8004034:	bdf0      	pop	{r4, r5, r6, r7, pc}
 * @param	: stream_number = 0-7 for stream selected
 * @return	: 0 = OK; -1 = irq number out of range; -2 or less = stream already in use
******************************************************************************/
int nvic_dma_stream_vector_add(void(*p)(u32*), u32* q, u32 dma_irq_number, u32 stream_number)
{
	if (stream_number > 7) return -1;	// JIC a bozo sent a bad number
 8004036:	f04f 30ff 	mov.w	r0, #4294967295
 800403a:	bdf0      	pop	{r4, r5, r6, r7, pc}

	/* Convert DMA irq number (vector position) to an index 0 - 7 */
	// --------- DMA1 -----------
	if ((dma_irq_number >= DMASTRM10) && (dma_irq_number <= DMASTRM16))
	{
		if ((dma1_stream_use & (1 << stream_number)) != 0) return -2; 	// Already setup
 800403c:	f06f 0001 	mvn.w	r0, #1
 8004040:	bdf0      	pop	{r4, r5, r6, r7, pc}
		RCC_AHB1ENR |= (1<<21); // Enable DMA1 clocking
		return 0;
	}
	if (dma_irq_number == DMASTRM17)
	{
		if ((dma1_stream_use & 0x80) != 0) return -3; 	// Already setup
 8004042:	f06f 0002 	mvn.w	r0, #2
 8004046:	bdf0      	pop	{r4, r5, r6, r7, pc}

	// --------- DMA2 -----------
	}
	if ( (dma_irq_number >= DMASTRM20) && (dma_irq_number <= DMASTRM24 ))
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -4; 	// Already setup
 8004048:	f06f 0003 	mvn.w	r0, #3
 800404c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		dma2[dma_irq_number - DMASTRM25 + 5].jmp  = p; 
		dma2[dma_irq_number - DMASTRM25 + 5].base = q; 
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
		return 0;
	}
	return -7;
 800404e:	f06f 0006 	mvn.w	r0, #6
 8004052:	bdf0      	pop	{r4, r5, r6, r7, pc}
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
		return 0;
	}
	if ( (dma_irq_number >= DMASTRM25) && (dma_irq_number <= DMASTRM27 ))
	{
		if ((dma2_stream_use & (1 << stream_number)) != 0) return -5; 	// Already setup
 8004054:	f06f 0004 	mvn.w	r0, #4
		dma2[dma_irq_number - DMASTRM25 + 5].base = q; 
		RCC_AHB1ENR |= (1<<22); // Enable DMA2 clocking
		return 0;
	}
	return -7;
}
 8004058:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800405a:	bf00      	nop
 800405c:	20000844 	.word	0x20000844
 8004060:	40023830 	.word	0x40023830

08004064 <DMA1_Stream0_IRQHandler>:
/* IRQ vectors for DMA streams points to the following.
   The following dispatches them to the routines of interest, along with one 32b pointer. */
//                                (*(  (void (**)(void))APPJUMP)   )(            );


void DMA1_Stream0_IRQHandler (void){(*dma1[0].jmp)(dma1[0].base); return;} 
 8004064:	4a02      	ldr	r2, [pc, #8]	; (8004070 <DMA1_Stream0_IRQHandler+0xc>)
 8004066:	b508      	push	{r3, lr}
 8004068:	6890      	ldr	r0, [r2, #8]
 800406a:	6853      	ldr	r3, [r2, #4]
 800406c:	4798      	blx	r3
 800406e:	bd08      	pop	{r3, pc}
 8004070:	20000844 	.word	0x20000844

08004074 <DMA1_Stream1_IRQHandler>:
void DMA1_Stream1_IRQHandler (void){(*dma1[1].jmp)(dma1[1].base); return;}	
 8004074:	4a02      	ldr	r2, [pc, #8]	; (8004080 <DMA1_Stream1_IRQHandler+0xc>)
 8004076:	b508      	push	{r3, lr}
 8004078:	6910      	ldr	r0, [r2, #16]
 800407a:	68d3      	ldr	r3, [r2, #12]
 800407c:	4798      	blx	r3
 800407e:	bd08      	pop	{r3, pc}
 8004080:	20000844 	.word	0x20000844

08004084 <DMA1_Stream2_IRQHandler>:
void DMA1_Stream2_IRQHandler (void){(*dma1[2].jmp)(dma1[2].base); return;}	
 8004084:	4a02      	ldr	r2, [pc, #8]	; (8004090 <DMA1_Stream2_IRQHandler+0xc>)
 8004086:	b508      	push	{r3, lr}
 8004088:	6990      	ldr	r0, [r2, #24]
 800408a:	6953      	ldr	r3, [r2, #20]
 800408c:	4798      	blx	r3
 800408e:	bd08      	pop	{r3, pc}
 8004090:	20000844 	.word	0x20000844

08004094 <DMA1_Stream3_IRQHandler>:
void DMA1_Stream3_IRQHandler (void){(*dma1[3].jmp)(dma1[3].base); return;}	
 8004094:	4a02      	ldr	r2, [pc, #8]	; (80040a0 <DMA1_Stream3_IRQHandler+0xc>)
 8004096:	b508      	push	{r3, lr}
 8004098:	6a10      	ldr	r0, [r2, #32]
 800409a:	69d3      	ldr	r3, [r2, #28]
 800409c:	4798      	blx	r3
 800409e:	bd08      	pop	{r3, pc}
 80040a0:	20000844 	.word	0x20000844

080040a4 <DMA1_Stream4_IRQHandler>:
void DMA1_Stream4_IRQHandler (void){(*dma1[4].jmp)(dma1[4].base); return;}	
 80040a4:	4a02      	ldr	r2, [pc, #8]	; (80040b0 <DMA1_Stream4_IRQHandler+0xc>)
 80040a6:	b508      	push	{r3, lr}
 80040a8:	6a90      	ldr	r0, [r2, #40]	; 0x28
 80040aa:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80040ac:	4798      	blx	r3
 80040ae:	bd08      	pop	{r3, pc}
 80040b0:	20000844 	.word	0x20000844

080040b4 <DMA1_Stream5_IRQHandler>:
void DMA1_Stream5_IRQHandler (void){(*dma1[5].jmp)(dma1[5].base); return;}	
 80040b4:	4a02      	ldr	r2, [pc, #8]	; (80040c0 <DMA1_Stream5_IRQHandler+0xc>)
 80040b6:	b508      	push	{r3, lr}
 80040b8:	6b10      	ldr	r0, [r2, #48]	; 0x30
 80040ba:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 80040bc:	4798      	blx	r3
 80040be:	bd08      	pop	{r3, pc}
 80040c0:	20000844 	.word	0x20000844

080040c4 <DMA1_Stream6_IRQHandler>:
void DMA1_Stream6_IRQHandler (void){(*dma1[6].jmp)(dma1[6].base); return;}	
 80040c4:	4a02      	ldr	r2, [pc, #8]	; (80040d0 <DMA1_Stream6_IRQHandler+0xc>)
 80040c6:	b508      	push	{r3, lr}
 80040c8:	6b90      	ldr	r0, [r2, #56]	; 0x38
 80040ca:	6b53      	ldr	r3, [r2, #52]	; 0x34
 80040cc:	4798      	blx	r3
 80040ce:	bd08      	pop	{r3, pc}
 80040d0:	20000844 	.word	0x20000844

080040d4 <DMA1_Stream7_IRQHandler>:
void DMA1_Stream7_IRQHandler (void){(*dma1[7].jmp)(dma1[7].base); return;}	
 80040d4:	4a02      	ldr	r2, [pc, #8]	; (80040e0 <DMA1_Stream7_IRQHandler+0xc>)
 80040d6:	b508      	push	{r3, lr}
 80040d8:	6c10      	ldr	r0, [r2, #64]	; 0x40
 80040da:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 80040dc:	4798      	blx	r3
 80040de:	bd08      	pop	{r3, pc}
 80040e0:	20000844 	.word	0x20000844

080040e4 <DMA2_Stream0_IRQHandler>:

void DMA2_Stream0_IRQHandler (void){(*dma2[0].jmp)(dma2[0].base); return;}	
 80040e4:	4a02      	ldr	r2, [pc, #8]	; (80040f0 <DMA2_Stream0_IRQHandler+0xc>)
 80040e6:	b508      	push	{r3, lr}
 80040e8:	6cd0      	ldr	r0, [r2, #76]	; 0x4c
 80040ea:	6c93      	ldr	r3, [r2, #72]	; 0x48
 80040ec:	4798      	blx	r3
 80040ee:	bd08      	pop	{r3, pc}
 80040f0:	20000844 	.word	0x20000844

080040f4 <DMA2_Stream1_IRQHandler>:
void DMA2_Stream1_IRQHandler (void){(*dma2[1].jmp)(dma2[1].base); return;}	
 80040f4:	4a02      	ldr	r2, [pc, #8]	; (8004100 <DMA2_Stream1_IRQHandler+0xc>)
 80040f6:	b508      	push	{r3, lr}
 80040f8:	6d50      	ldr	r0, [r2, #84]	; 0x54
 80040fa:	6d13      	ldr	r3, [r2, #80]	; 0x50
 80040fc:	4798      	blx	r3
 80040fe:	bd08      	pop	{r3, pc}
 8004100:	20000844 	.word	0x20000844

08004104 <DMA2_Stream2_IRQHandler>:
void DMA2_Stream2_IRQHandler (void){(*dma2[2].jmp)(dma2[2].base); return;}	
 8004104:	4a02      	ldr	r2, [pc, #8]	; (8004110 <DMA2_Stream2_IRQHandler+0xc>)
 8004106:	b508      	push	{r3, lr}
 8004108:	6dd0      	ldr	r0, [r2, #92]	; 0x5c
 800410a:	6d93      	ldr	r3, [r2, #88]	; 0x58
 800410c:	4798      	blx	r3
 800410e:	bd08      	pop	{r3, pc}
 8004110:	20000844 	.word	0x20000844

08004114 <DMA2_Stream3_IRQHandler>:
void DMA2_Stream3_IRQHandler (void){(*dma2[3].jmp)(dma2[3].base); return;}	
 8004114:	4a02      	ldr	r2, [pc, #8]	; (8004120 <DMA2_Stream3_IRQHandler+0xc>)
 8004116:	b508      	push	{r3, lr}
 8004118:	6e50      	ldr	r0, [r2, #100]	; 0x64
 800411a:	6e13      	ldr	r3, [r2, #96]	; 0x60
 800411c:	4798      	blx	r3
 800411e:	bd08      	pop	{r3, pc}
 8004120:	20000844 	.word	0x20000844

08004124 <DMA2_Stream4_IRQHandler>:
void DMA2_Stream4_IRQHandler (void){(*dma2[4].jmp)(dma2[4].base); return;}	
 8004124:	4a02      	ldr	r2, [pc, #8]	; (8004130 <DMA2_Stream4_IRQHandler+0xc>)
 8004126:	b508      	push	{r3, lr}
 8004128:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 800412a:	6e93      	ldr	r3, [r2, #104]	; 0x68
 800412c:	4798      	blx	r3
 800412e:	bd08      	pop	{r3, pc}
 8004130:	20000844 	.word	0x20000844

08004134 <DMA2_Stream5_IRQHandler>:

void DMA2_Stream5_IRQHandler (void){(*dma2[5].jmp)(dma2[5].base); return;}
 8004134:	4a02      	ldr	r2, [pc, #8]	; (8004140 <DMA2_Stream5_IRQHandler+0xc>)
 8004136:	b508      	push	{r3, lr}
 8004138:	6f50      	ldr	r0, [r2, #116]	; 0x74
 800413a:	6f13      	ldr	r3, [r2, #112]	; 0x70
 800413c:	4798      	blx	r3
 800413e:	bd08      	pop	{r3, pc}
 8004140:	20000844 	.word	0x20000844

08004144 <DMA2_Stream6_IRQHandler>:
void DMA2_Stream6_IRQHandler (void){(*dma2[6].jmp)(dma2[6].base); return;}	
 8004144:	4a02      	ldr	r2, [pc, #8]	; (8004150 <DMA2_Stream6_IRQHandler+0xc>)
 8004146:	b508      	push	{r3, lr}
 8004148:	6fd0      	ldr	r0, [r2, #124]	; 0x7c
 800414a:	6f93      	ldr	r3, [r2, #120]	; 0x78
 800414c:	4798      	blx	r3
 800414e:	bd08      	pop	{r3, pc}
 8004150:	20000844 	.word	0x20000844

08004154 <DMA2_Stream7_IRQHandler>:
void DMA2_Stream7_IRQHandler (void){(*dma2[7].jmp)(dma2[7].base); return;}	
 8004154:	4a03      	ldr	r2, [pc, #12]	; (8004164 <DMA2_Stream7_IRQHandler+0x10>)
 8004156:	b508      	push	{r3, lr}
 8004158:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84
 800415c:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 8004160:	4798      	blx	r3
 8004162:	bd08      	pop	{r3, pc}
 8004164:	20000844 	.word	0x20000844

08004168 <rxbuff_adv>:
 * @param	: pctl = pointer to control block
 * @param	: p = pointer to be advanced
 * @return	: new pointer 'p'
*******************************************************************************/
static u8* rxbuff_adv (struct CB_UART* pctl, u8* p)
{
 8004168:	4603      	mov	r3, r0
	p += 1; if (p >= pctl->rxbuff_end) p = pctl->rxbuff_base;
 800416a:	1c48      	adds	r0, r1, #1
 800416c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800416e:	4290      	cmp	r0, r2
 8004170:	bf28      	it	cs
 8004172:	6ad8      	ldrcs	r0, [r3, #44]	; 0x2c
	return p;
}
 8004174:	4770      	bx	lr

08004176 <txbuff_adv>:
 * @param	: pctl = pointer to control block
 * @param	: p = pointer to be advanced
 * @return	: new pointer 'p'
*******************************************************************************/
static u8* txbuff_adv (struct CB_UART* pctl, u8* p)
{
 8004176:	4603      	mov	r3, r0
	p += 1; if (p >= pctl->txbuff_end) p = pctl->txbuff_base;
 8004178:	1c48      	adds	r0, r1, #1
 800417a:	699a      	ldr	r2, [r3, #24]
 800417c:	4290      	cmp	r0, r2
 800417e:	bf28      	it	cs
 8004180:	6958      	ldrcs	r0, [r3, #20]
	return p;
}
 8004182:	4770      	bx	lr

08004184 <common_dma>:
   routine. */
	int tmp;
	u8* ptmp;

	/* Are there bytes buffered? (Certainly yes if entered from mainline.) */  
	tmp = (pctl->txbuff_in - pctl->txbuff_out);
 8004184:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8004186:	6a02      	ldr	r2, [r0, #32]
 8004188:	1ad2      	subs	r2, r2, r3
	if (tmp == 0) return;	
 800418a:	2a00      	cmp	r2, #0
 * @brief	: Set up a disabled (idle) DMA to send if there are byte buffered
 * @param	: pctl = pointer to uart control block
 *####################################################################################### */

static void common_dma(struct CB_UART* pctl)
{
 800418c:	b530      	push	{r4, r5, lr}
	int tmp;
	u8* ptmp;

	/* Are there bytes buffered? (Certainly yes if entered from mainline.) */  
	tmp = (pctl->txbuff_in - pctl->txbuff_out);
	if (tmp == 0) return;	
 800418e:	d022      	beq.n	80041d6 <common_dma+0x52>
 8004190:	68c1      	ldr	r1, [r0, #12]

	if (tmp < 0)	// Wrap around check.
 8004192:	da07      	bge.n	80041a4 <common_dma+0x20>
	{ // Here, there is wrap-around, so send what remains in (non-circular) buffer.
	  // (Upon the next DMA interrupt what remains after the wrap-around will be sent.)

		// Compute number of bytes remaining to the end of the buffer
		tmp = (pctl->txbuff_end - pctl->txbuff_out); 			// Remaining ct
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; 	// Set TX mem address
 8004194:	6804      	ldr	r4, [r0, #0]
	if (tmp < 0)	// Wrap around check.
	{ // Here, there is wrap-around, so send what remains in (non-circular) buffer.
	  // (Upon the next DMA interrupt what remains after the wrap-around will be sent.)

		// Compute number of bytes remaining to the end of the buffer
		tmp = (pctl->txbuff_end - pctl->txbuff_out); 			// Remaining ct
 8004196:	6982      	ldr	r2, [r0, #24]
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; 	// Set TX mem address
 8004198:	2518      	movs	r5, #24
 800419a:	fb05 4101 	mla	r1, r5, r1, r4
	if (tmp < 0)	// Wrap around check.
	{ // Here, there is wrap-around, so send what remains in (non-circular) buffer.
	  // (Upon the next DMA interrupt what remains after the wrap-around will be sent.)

		// Compute number of bytes remaining to the end of the buffer
		tmp = (pctl->txbuff_end - pctl->txbuff_out); 			// Remaining ct
 800419e:	1ad2      	subs	r2, r2, r3
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; 	// Set TX mem address
 80041a0:	61cb      	str	r3, [r1, #28]
 80041a2:	e008      	b.n	80041b6 <common_dma+0x32>
		pctl->txbuff_dmanext = pctl->txbuff_base;				// Save new start ptr
	}
	else
	{ // Here, no wrap around, so all buffered bytes can be sent with one setting
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; // Set TX mem address
 80041a4:	6804      	ldr	r4, [r0, #0]
 80041a6:	2518      	movs	r5, #24
 80041a8:	fb05 4101 	mla	r1, r5, r1, r4
 80041ac:	61cb      	str	r3, [r1, #28]
// redundant	tmp = pctl->txbuff_in - pctl->txbuff_out);		// Number of bytes to send
		ptmp = tmp + pctl->txbuff_out;
		if (ptmp >= pctl->txbuff_end)
 80041ae:	6981      	ldr	r1, [r0, #24]
	}
	else
	{ // Here, no wrap around, so all buffered bytes can be sent with one setting
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; // Set TX mem address
// redundant	tmp = pctl->txbuff_in - pctl->txbuff_out);		// Number of bytes to send
		ptmp = tmp + pctl->txbuff_out;
 80041b0:	189b      	adds	r3, r3, r2
		if (ptmp >= pctl->txbuff_end)
 80041b2:	428b      	cmp	r3, r1
 80041b4:	d300      	bcc.n	80041b8 <common_dma+0x34>
			ptmp = pctl->txbuff_base;
 80041b6:	6943      	ldr	r3, [r0, #20]
		pctl->txbuff_dmanext = ptmp;				// Save new start ptr
	}

	DMA_SNDTR(pctl->idma,pctl->txdma_stream)  = tmp;		// Set number of bytes
 80041b8:	6804      	ldr	r4, [r0, #0]
 80041ba:	68c1      	ldr	r1, [r0, #12]
		DMA_SM0AR(pctl->idma,pctl->txdma_stream) = pctl->txbuff_out; // Set TX mem address
// redundant	tmp = pctl->txbuff_in - pctl->txbuff_out);		// Number of bytes to send
		ptmp = tmp + pctl->txbuff_out;
		if (ptmp >= pctl->txbuff_end)
			ptmp = pctl->txbuff_base;
		pctl->txbuff_dmanext = ptmp;				// Save new start ptr
 80041bc:	6283      	str	r3, [r0, #40]	; 0x28
	}

	DMA_SNDTR(pctl->idma,pctl->txdma_stream)  = tmp;		// Set number of bytes
 80041be:	2318      	movs	r3, #24
 80041c0:	4359      	muls	r1, r3
 80041c2:	3414      	adds	r4, #20
 80041c4:	5062      	str	r2, [r4, r1]
	DMA_SCR (pctl->idma,pctl->txdma_stream) |= 0x1;		// Enable DMA and away we go!
 80041c6:	6802      	ldr	r2, [r0, #0]
 80041c8:	68c1      	ldr	r1, [r0, #12]
 80041ca:	3210      	adds	r2, #16
 80041cc:	434b      	muls	r3, r1
 80041ce:	58d1      	ldr	r1, [r2, r3]
 80041d0:	f041 0101 	orr.w	r1, r1, #1
 80041d4:	50d1      	str	r1, [r2, r3]
 80041d6:	bd30      	pop	{r4, r5, pc}

080041d8 <DMA_UART_IRQHandler>:
{
	/* The following is for consistency in the code in this file. ('nvic_dma_mgr.c' uses volatile u32*) */
	struct CB_UART* pctl = (struct CB_UART*)pall;

	/* Clear all interrupt flags for this DMA stream */
	if (pctl->txdma_stream > 3)
 80041d8:	68c3      	ldr	r3, [r0, #12]
 80041da:	4a0a      	ldr	r2, [pc, #40]	; (8004204 <DMA_UART_IRQHandler+0x2c>)
 80041dc:	2b03      	cmp	r3, #3
 80041de:	d908      	bls.n	80041f2 <DMA_UART_IRQHandler+0x1a>
	{// High register
		DMA_HIFCR(pctl->idma) = (0x3d << tcif_tbl[pctl->txdma_stream-4]);
 80041e0:	18d3      	adds	r3, r2, r3
 80041e2:	6801      	ldr	r1, [r0, #0]
 80041e4:	f813 3c04 	ldrb.w	r3, [r3, #-4]
 80041e8:	223d      	movs	r2, #61	; 0x3d
 80041ea:	fa12 f303 	lsls.w	r3, r2, r3
 80041ee:	60cb      	str	r3, [r1, #12]
 80041f0:	e005      	b.n	80041fe <DMA_UART_IRQHandler+0x26>
	}
	else
	{ // Low register
		DMA_LIFCR(pctl->idma) = (0x3d << tcif_tbl[pctl->txdma_stream]);
 80041f2:	5cd3      	ldrb	r3, [r2, r3]
 80041f4:	6801      	ldr	r1, [r0, #0]
 80041f6:	223d      	movs	r2, #61	; 0x3d
 80041f8:	fa12 f303 	lsls.w	r3, r2, r3
 80041fc:	608b      	str	r3, [r1, #8]
	}
	pctl->txbuff_out = pctl->txbuff_dmanext; // Update where in the buffer we have xmitted
 80041fe:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8004200:	6243      	str	r3, [r0, #36]	; 0x24

	/* Here, check if there are bytes buffered and if so, figure out how to send them. */
	common_dma(pctl);
 8004202:	e7bf      	b.n	8004184 <common_dma>
 8004204:	0800b738 	.word	0x0800b738

08004208 <bsp_panic>:
static void common_dma(struct CB_UART* pctl);

/* Error trapping */
int PANIC_x;	// Global variable to look at.
void bsp_panic (int x)
{ PANIC_x = x; panic_leds(7); } // Save code, and flash LEDs 7x
 8004208:	4b02      	ldr	r3, [pc, #8]	; (8004214 <bsp_panic+0xc>)
 800420a:	6018      	str	r0, [r3, #0]
 800420c:	2007      	movs	r0, #7
 800420e:	f7ff bc92 	b.w	8003b36 <panic_leds>
 8004212:	bf00      	nop
 8004214:	200008cc 	.word	0x200008cc

08004218 <mapindex>:
 * @brief	: Edit & Map register base address to control block index & enable APBxENR
 * @param	: p = pointer to register base
 * @return	: 0 - 7 = OK; panic_leds for fail
******************************************************************************/	
static int mapindex(volatile u32 iuart)
{
 8004218:	b507      	push	{r0, r1, r2, lr}
 800421a:	9001      	str	r0, [sp, #4]
	int idx;

	/* Index v register base */
	switch (iuart)
 800421c:	9b01      	ldr	r3, [sp, #4]
 800421e:	4a21      	ldr	r2, [pc, #132]	; (80042a4 <mapindex+0x8c>)
 8004220:	4293      	cmp	r3, r2
 8004222:	d030      	beq.n	8004286 <mapindex+0x6e>
 8004224:	d806      	bhi.n	8004234 <mapindex+0x1c>
 8004226:	4a20      	ldr	r2, [pc, #128]	; (80042a8 <mapindex+0x90>)
 8004228:	4293      	cmp	r3, r2
 800422a:	d01e      	beq.n	800426a <mapindex+0x52>
 800422c:	4a1f      	ldr	r2, [pc, #124]	; (80042ac <mapindex+0x94>)
 800422e:	4293      	cmp	r3, r2
 8004230:	d109      	bne.n	8004246 <mapindex+0x2e>
 8004232:	e021      	b.n	8004278 <mapindex+0x60>
 8004234:	4a1e      	ldr	r2, [pc, #120]	; (80042b0 <mapindex+0x98>)
 8004236:	4293      	cmp	r3, r2
 8004238:	d009      	beq.n	800424e <mapindex+0x36>
 800423a:	4a1e      	ldr	r2, [pc, #120]	; (80042b4 <mapindex+0x9c>)
 800423c:	4293      	cmp	r3, r2
 800423e:	d00d      	beq.n	800425c <mapindex+0x44>
 8004240:	4a1d      	ldr	r2, [pc, #116]	; (80042b8 <mapindex+0xa0>)
 8004242:	4293      	cmp	r3, r2
 8004244:	d026      	beq.n	8004294 <mapindex+0x7c>
	case UART4:	idx =  3; break;
	case UART5:	idx =  4; break;
	case USART6:	idx =  5; break;

	default:
		bsp_panic(-61);	// No match for request
 8004246:	f06f 003c 	mvn.w	r0, #60	; 0x3c
 800424a:	f7ff ffdd 	bl	8004208 <bsp_panic>
	}
	/* Enable USART/UART module on appropriate bus */
	switch (idx)
	{
	case 0:	RCC_AHB2ENR |= (1 << 4); break;
 800424e:	4b1b      	ldr	r3, [pc, #108]	; (80042bc <mapindex+0xa4>)
 8004250:	681a      	ldr	r2, [r3, #0]
 8004252:	f042 0210 	orr.w	r2, r2, #16
 8004256:	601a      	str	r2, [r3, #0]
 8004258:	2000      	movs	r0, #0
 800425a:	e021      	b.n	80042a0 <mapindex+0x88>
	case 5:	RCC_AHB2ENR |= (1 << 5); break;	
 800425c:	4b17      	ldr	r3, [pc, #92]	; (80042bc <mapindex+0xa4>)
 800425e:	681a      	ldr	r2, [r3, #0]
 8004260:	f042 0220 	orr.w	r2, r2, #32
 8004264:	601a      	str	r2, [r3, #0]
 8004266:	2005      	movs	r0, #5
 8004268:	e01a      	b.n	80042a0 <mapindex+0x88>

	case 1:	RCC_AHB1ENR |= (1 << 17); break;
 800426a:	4b15      	ldr	r3, [pc, #84]	; (80042c0 <mapindex+0xa8>)
 800426c:	681a      	ldr	r2, [r3, #0]
 800426e:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8004272:	601a      	str	r2, [r3, #0]
 8004274:	2001      	movs	r0, #1
 8004276:	e013      	b.n	80042a0 <mapindex+0x88>
	case 2:	RCC_AHB1ENR |= (1 << 18); break;
 8004278:	4b11      	ldr	r3, [pc, #68]	; (80042c0 <mapindex+0xa8>)
 800427a:	681a      	ldr	r2, [r3, #0]
 800427c:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8004280:	601a      	str	r2, [r3, #0]
 8004282:	2002      	movs	r0, #2
 8004284:	e00c      	b.n	80042a0 <mapindex+0x88>
	case 3:	RCC_AHB1ENR |= (1 << 19); break;
 8004286:	4b0e      	ldr	r3, [pc, #56]	; (80042c0 <mapindex+0xa8>)
 8004288:	681a      	ldr	r2, [r3, #0]
 800428a:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 800428e:	601a      	str	r2, [r3, #0]
 8004290:	2003      	movs	r0, #3
 8004292:	e005      	b.n	80042a0 <mapindex+0x88>
	case 4:	RCC_AHB1ENR |= (1 << 20); break;
 8004294:	4b0a      	ldr	r3, [pc, #40]	; (80042c0 <mapindex+0xa8>)
 8004296:	681a      	ldr	r2, [r3, #0]
 8004298:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 800429c:	601a      	str	r2, [r3, #0]
 800429e:	2004      	movs	r0, #4
	default:
		bsp_panic(-62);	// Wrong
	}

	return idx;
}
 80042a0:	bd0e      	pop	{r1, r2, r3, pc}
 80042a2:	bf00      	nop
 80042a4:	40004c00 	.word	0x40004c00
 80042a8:	40004400 	.word	0x40004400
 80042ac:	40004800 	.word	0x40004800
 80042b0:	40011000 	.word	0x40011000
 80042b4:	40011400 	.word	0x40011400
 80042b8:	40005000 	.word	0x40005000
 80042bc:	40023834 	.word	0x40023834
 80042c0:	40023830 	.word	0x40023830

080042c4 <getbuff>:
 * @param	: rxbuffsize = requested size of rx buffer
 * @param	: txbuffsize = requested size of rx buffer
 * @return	: 0 = OK; -1; fail = led trap
******************************************************************************/	
static int getbuff(int idx, u32 rxbuffsize, u32 txbuffsize)
{
 80042c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80042c6:	4604      	mov	r4, r0
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
 80042c8:	4f13      	ldr	r7, [pc, #76]	; (8004318 <getbuff+0x54>)
 80042ca:	4608      	mov	r0, r1
 * @param	: rxbuffsize = requested size of rx buffer
 * @param	: txbuffsize = requested size of rx buffer
 * @return	: 0 = OK; -1; fail = led trap
******************************************************************************/	
static int getbuff(int idx, u32 rxbuffsize, u32 txbuffsize)
{
 80042cc:	460d      	mov	r5, r1
 80042ce:	4616      	mov	r6, r2
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
 80042d0:	f000 fcd2 	bl	8004c78 <malloc>
 80042d4:	01a3      	lsls	r3, r4, #6
 80042d6:	18fb      	adds	r3, r7, r3
 80042d8:	6318      	str	r0, [r3, #48]	; 0x30
 80042da:	b910      	cbnz	r0, 80042e2 <getbuff+0x1e>
 80042dc:	380d      	subs	r0, #13
 80042de:	f7ff ff93 	bl	8004208 <bsp_panic>
	if ((cb_uart[idx].txbuff_base = malloc(txbuffsize)) == NULL) bsp_panic(-14);	// malloc failed to obtain tx buffer
 80042e2:	4630      	mov	r0, r6
 80042e4:	f000 fcc8 	bl	8004c78 <malloc>
 80042e8:	01a4      	lsls	r4, r4, #6
 80042ea:	193b      	adds	r3, r7, r4
 80042ec:	6198      	str	r0, [r3, #24]
 80042ee:	b910      	cbnz	r0, 80042f6 <getbuff+0x32>
 80042f0:	380e      	subs	r0, #14
 80042f2:	f7ff ff89 	bl	8004208 <bsp_panic>
	cb_uart[idx].rxbuff_end  = cb_uart[idx].rxbuff_base + rxbuffsize;
 80042f6:	193c      	adds	r4, r7, r4
	cb_uart[idx].txbuff_dmanext = cb_uart[idx].txbuff_base;
	cb_uart[idx].rxbuff_in   = cb_uart[idx].rxbuff_base;
	cb_uart[idx].txbuff_in   = cb_uart[idx].txbuff_base;
	
	return 0;
}
 80042f8:	2000      	movs	r0, #0
static int getbuff(int idx, u32 rxbuffsize, u32 txbuffsize)
{
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
	if ((cb_uart[idx].txbuff_base = malloc(txbuffsize)) == NULL) bsp_panic(-14);	// malloc failed to obtain tx buffer
	cb_uart[idx].rxbuff_end  = cb_uart[idx].rxbuff_base + rxbuffsize;
 80042fa:	6b22      	ldr	r2, [r4, #48]	; 0x30
	cb_uart[idx].txbuff_end  = cb_uart[idx].txbuff_base + txbuffsize;
	cb_uart[idx].rxbuff_size = rxbuffsize;
 80042fc:	63a5      	str	r5, [r4, #56]	; 0x38
static int getbuff(int idx, u32 rxbuffsize, u32 txbuffsize)
{
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
	if ((cb_uart[idx].txbuff_base = malloc(txbuffsize)) == NULL) bsp_panic(-14);	// malloc failed to obtain tx buffer
	cb_uart[idx].rxbuff_end  = cb_uart[idx].rxbuff_base + rxbuffsize;
 80042fe:	1953      	adds	r3, r2, r5
 8004300:	6363      	str	r3, [r4, #52]	; 0x34
	cb_uart[idx].txbuff_end  = cb_uart[idx].txbuff_base + txbuffsize;
 8004302:	69a3      	ldr	r3, [r4, #24]
	cb_uart[idx].rxbuff_size = rxbuffsize;
	cb_uart[idx].txbuff_size = txbuffsize;
 8004304:	6226      	str	r6, [r4, #32]
{
	/* Obtain some buffer space and initialize buffer pointers. */
	if ((cb_uart[idx].rxbuff_base = malloc(rxbuffsize)) == NULL) bsp_panic(-13);	// malloc failed to obtain rx buffer
	if ((cb_uart[idx].txbuff_base = malloc(txbuffsize)) == NULL) bsp_panic(-14);	// malloc failed to obtain tx buffer
	cb_uart[idx].rxbuff_end  = cb_uart[idx].rxbuff_base + rxbuffsize;
	cb_uart[idx].txbuff_end  = cb_uart[idx].txbuff_base + txbuffsize;
 8004306:	1999      	adds	r1, r3, r6
 8004308:	61e1      	str	r1, [r4, #28]
	cb_uart[idx].rxbuff_size = rxbuffsize;
	cb_uart[idx].txbuff_size = txbuffsize;
	cb_uart[idx].rxbuff_out  = cb_uart[idx].rxbuff_base;
 800430a:	6422      	str	r2, [r4, #64]	; 0x40
	cb_uart[idx].txbuff_out  = cb_uart[idx].txbuff_base;
 800430c:	62a3      	str	r3, [r4, #40]	; 0x28
	cb_uart[idx].txbuff_dmanext = cb_uart[idx].txbuff_base;
 800430e:	62e3      	str	r3, [r4, #44]	; 0x2c
	cb_uart[idx].rxbuff_in   = cb_uart[idx].rxbuff_base;
 8004310:	63e2      	str	r2, [r4, #60]	; 0x3c
	cb_uart[idx].txbuff_in   = cb_uart[idx].txbuff_base;
 8004312:	6263      	str	r3, [r4, #36]	; 0x24
	
	return 0;
}
 8004314:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004316:	bf00      	nop
 8004318:	200008cc 	.word	0x200008cc

0800431c <uartnumber_to_baseaddr>:
*******************************************************************************/
static u32 uartnumber_to_baseaddr(u32 uartnumber)
{
	u32 iuart = 0;
	/* Convert uart number to uart register base address */
	switch (uartnumber)
 800431c:	3801      	subs	r0, #1
 * @brief	: Map uart number (1-6) to uart module base address
 * @param	: uartnumber = (1 -6), e.g. 2 = USART2
 * @return	: USART/UART base address, e.g. USART2 = 0x40004400
*******************************************************************************/
static u32 uartnumber_to_baseaddr(u32 uartnumber)
{
 800431e:	b508      	push	{r3, lr}
	u32 iuart = 0;
	/* Convert uart number to uart register base address */
	switch (uartnumber)
 8004320:	2805      	cmp	r0, #5
 8004322:	d80e      	bhi.n	8004342 <uartnumber_to_baseaddr+0x26>
 8004324:	e8df f000 	tbb	[pc, r0]
 8004328:	07051303 	.word	0x07051303
 800432c:	0b09      	.short	0x0b09
	{
	case 1:	iuart = USART1;	break;
 800432e:	4809      	ldr	r0, [pc, #36]	; (8004354 <uartnumber_to_baseaddr+0x38>)
 8004330:	bd08      	pop	{r3, pc}
	case 2:	iuart = USART2;	break;
	case 3:	iuart = USART3;	break;
 8004332:	4809      	ldr	r0, [pc, #36]	; (8004358 <uartnumber_to_baseaddr+0x3c>)
 8004334:	bd08      	pop	{r3, pc}
	case 4:	iuart =  UART4;	break;
 8004336:	4809      	ldr	r0, [pc, #36]	; (800435c <uartnumber_to_baseaddr+0x40>)
 8004338:	bd08      	pop	{r3, pc}
	case 5:	iuart =  UART5;	break;
 800433a:	4809      	ldr	r0, [pc, #36]	; (8004360 <uartnumber_to_baseaddr+0x44>)
 800433c:	bd08      	pop	{r3, pc}
	case 6:	iuart = USART6;	break;
 800433e:	4809      	ldr	r0, [pc, #36]	; (8004364 <uartnumber_to_baseaddr+0x48>)
 8004340:	bd08      	pop	{r3, pc}

	default:
		bsp_panic(-66);	// No match for request
 8004342:	f06f 0041 	mvn.w	r0, #65	; 0x41
 8004346:	f7ff ff5f 	bl	8004208 <bsp_panic>
 * @param	: uartnumber = (1 -6), e.g. 2 = USART2
 * @return	: USART/UART base address, e.g. USART2 = 0x40004400
*******************************************************************************/
static u32 uartnumber_to_baseaddr(u32 uartnumber)
{
	u32 iuart = 0;
 800434a:	2000      	movs	r0, #0
 800434c:	bd08      	pop	{r3, pc}
	/* Convert uart number to uart register base address */
	switch (uartnumber)
	{
	case 1:	iuart = USART1;	break;
	case 2:	iuart = USART2;	break;
 800434e:	4806      	ldr	r0, [pc, #24]	; (8004368 <uartnumber_to_baseaddr+0x4c>)
	default:
		bsp_panic(-66);	// No match for request
	}	
	return iuart;

}
 8004350:	bd08      	pop	{r3, pc}
 8004352:	bf00      	nop
 8004354:	40011000 	.word	0x40011000
 8004358:	40004800 	.word	0x40004800
 800435c:	40004c00 	.word	0x40004c00
 8004360:	40005000 	.word	0x40005000
 8004364:	40011400 	.word	0x40011400
 8004368:	40004400 	.word	0x40004400

0800436c <irq_given_datastream>:
{
	u32	dma;
	int	num;
};
static struct IRQNUM irq_given_datastream(u32 iuart, int dmastream)
{
 800436c:	b570      	push	{r4, r5, r6, lr}
	struct IRQNUM irqnum = {0,0}; 
	if (dmastream < 0) bsp_panic(-714);
 800436e:	1e16      	subs	r6, r2, #0
{
	u32	dma;
	int	num;
};
static struct IRQNUM irq_given_datastream(u32 iuart, int dmastream)
{
 8004370:	4604      	mov	r4, r0
 8004372:	460d      	mov	r5, r1
	struct IRQNUM irqnum = {0,0}; 
	if (dmastream < 0) bsp_panic(-714);
 8004374:	da02      	bge.n	800437c <irq_given_datastream+0x10>
 8004376:	480f      	ldr	r0, [pc, #60]	; (80043b4 <irq_given_datastream+0x48>)
 8004378:	f7ff ff46 	bl	8004208 <bsp_panic>

	if ((iuart == USART1) || (iuart == USART6))
 800437c:	4b0e      	ldr	r3, [pc, #56]	; (80043b8 <irq_given_datastream+0x4c>)
 800437e:	429d      	cmp	r5, r3
 8004380:	d002      	beq.n	8004388 <irq_given_datastream+0x1c>
 8004382:	4b0e      	ldr	r3, [pc, #56]	; (80043bc <irq_given_datastream+0x50>)
 8004384:	429d      	cmp	r5, r3
 8004386:	d108      	bne.n	800439a <irq_given_datastream+0x2e>
	{
		irqnum.dma = DMA2_BASE;
		if (dmastream > 4)	// Determine IRQ number for the stream 
 8004388:	2e04      	cmp	r6, #4
 800438a:	4b0d      	ldr	r3, [pc, #52]	; (80043c0 <irq_given_datastream+0x54>)
 800438c:	dd02      	ble.n	8004394 <irq_given_datastream+0x28>
 800438e:	6023      	str	r3, [r4, #0]
		{ irqnum.num = (DMASTRM25 + dmastream - 5); return irqnum;}
 8004390:	363f      	adds	r6, #63	; 0x3f
 8004392:	e00b      	b.n	80043ac <irq_given_datastream+0x40>
 8004394:	6023      	str	r3, [r4, #0]
		else
		{ irqnum.num = (DMASTRM20 + dmastream); return irqnum;}
 8004396:	3638      	adds	r6, #56	; 0x38
 8004398:	e008      	b.n	80043ac <irq_given_datastream+0x40>
	}

	irqnum.dma = DMA1_BASE;
	if (dmastream == 7)
 800439a:	2e07      	cmp	r6, #7
 800439c:	4b09      	ldr	r3, [pc, #36]	; (80043c4 <irq_given_datastream+0x58>)
 800439e:	d103      	bne.n	80043a8 <irq_given_datastream+0x3c>
 80043a0:	6023      	str	r3, [r4, #0]
 80043a2:	232f      	movs	r3, #47	; 0x2f
 80043a4:	6063      	str	r3, [r4, #4]
		{ irqnum.num = (DMASTRM17); return irqnum;}
 80043a6:	e002      	b.n	80043ae <irq_given_datastream+0x42>
 80043a8:	6023      	str	r3, [r4, #0]
	else
		{ irqnum.num = (DMASTRM10 + dmastream); return irqnum;}
 80043aa:	360b      	adds	r6, #11
		{ irqnum.num = (DMASTRM20 + dmastream); return irqnum;}
	}

	irqnum.dma = DMA1_BASE;
	if (dmastream == 7)
		{ irqnum.num = (DMASTRM17); return irqnum;}
 80043ac:	6066      	str	r6, [r4, #4]
	else
		{ irqnum.num = (DMASTRM10 + dmastream); return irqnum;}

	bsp_panic(-715);	// Shouldn't happen
	return irqnum;
}
 80043ae:	4620      	mov	r0, r4
 80043b0:	bd70      	pop	{r4, r5, r6, pc}
 80043b2:	bf00      	nop
 80043b4:	fffffd36 	.word	0xfffffd36
 80043b8:	40011000 	.word	0x40011000
 80043bc:	40011400 	.word	0x40011400
 80043c0:	40026400 	.word	0x40026400
 80043c4:	40026000 	.word	0x40026000

080043c8 <bsp_uart_open>:
 * @return	: control block pointer
******************************************************************************/	
static const char* open_name[8] = {"tty1", "tty2", "tty3", "tty4", "tty5", "tty6", "tty7", "tty8"};

struct CB_UART* bsp_uart_open(const char *name)
{
 80043c8:	b570      	push	{r4, r5, r6, lr}
	int i;
	for (i = 0; i < 8; i++)
	{
		if (strcmp(name, open_name[i]) == 0) break;
	}
	if (i >= 8) return (struct CB_UART*)-1;
 80043ca:	4d09      	ldr	r5, [pc, #36]	; (80043f0 <bsp_uart_open+0x28>)
 * @return	: control block pointer
******************************************************************************/	
static const char* open_name[8] = {"tty1", "tty2", "tty3", "tty4", "tty5", "tty6", "tty7", "tty8"};

struct CB_UART* bsp_uart_open(const char *name)
{
 80043cc:	4606      	mov	r6, r0
	int i;
	for (i = 0; i < 8; i++)
 80043ce:	2400      	movs	r4, #0
	{
		if (strcmp(name, open_name[i]) == 0) break;
 80043d0:	4630      	mov	r0, r6
 80043d2:	f855 1f04 	ldr.w	r1, [r5, #4]!
 80043d6:	f000 ffd3 	bl	8005380 <strcmp>
 80043da:	b128      	cbz	r0, 80043e8 <bsp_uart_open+0x20>
static const char* open_name[8] = {"tty1", "tty2", "tty3", "tty4", "tty5", "tty6", "tty7", "tty8"};

struct CB_UART* bsp_uart_open(const char *name)
{
	int i;
	for (i = 0; i < 8; i++)
 80043dc:	3401      	adds	r4, #1
 80043de:	2c08      	cmp	r4, #8
 80043e0:	d1f6      	bne.n	80043d0 <bsp_uart_open+0x8>
	{
		if (strcmp(name, open_name[i]) == 0) break;
	}
	if (i >= 8) return (struct CB_UART*)-1;
 80043e2:	f04f 30ff 	mov.w	r0, #4294967295
 80043e6:	bd70      	pop	{r4, r5, r6, pc}
	
	return &cb_uart[i];	// Return control block ptr to 'open'
 80043e8:	4802      	ldr	r0, [pc, #8]	; (80043f4 <bsp_uart_open+0x2c>)
 80043ea:	01a4      	lsls	r4, r4, #6
 80043ec:	1900      	adds	r0, r0, r4
}
 80043ee:	bd70      	pop	{r4, r5, r6, pc}
 80043f0:	0800b738 	.word	0x0800b738
 80043f4:	200008d0 	.word	0x200008d0

080043f8 <bsp_uart_dma_init>:
 * @param	: dmastreamtx: DMA stream number for TX (0 - 7)
 * @param	: dma_tx_int_priority: interrupt priority, (0x00 - 0xf0) e.g. 0xc0, low 4 bits zero
 * @return	: 0 = success; fail traps to 'panic_leds'
*******************************************************************************/
int bsp_uart_dma_init(u32 iuart, u32 baud, u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority)
{
 80043f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80043fc:	b08b      	sub	sp, #44	; 0x2c
 80043fe:	4604      	mov	r4, r0
 8004400:	9f14      	ldr	r7, [sp, #80]	; 0x50
 8004402:	9101      	str	r1, [sp, #4]
	u32 dma_channel_number_rx = 4;	// Initialize to prevent compiler warning
	u32 dma_channel_number_tx = 5;	


	/* Be sure arguments passed are within range */
	if (dmastreamrx > 7) bsp_panic(-1);
 8004404:	2f07      	cmp	r7, #7
 * @param	: dmastreamtx: DMA stream number for TX (0 - 7)
 * @param	: dma_tx_int_priority: interrupt priority, (0x00 - 0xf0) e.g. 0xc0, low 4 bits zero
 * @return	: 0 = success; fail traps to 'panic_leds'
*******************************************************************************/
int bsp_uart_dma_init(u32 iuart, u32 baud, u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority)
{
 8004406:	9202      	str	r2, [sp, #8]
 8004408:	9303      	str	r3, [sp, #12]
 800440a:	f8dd a054 	ldr.w	sl, [sp, #84]	; 0x54
	u32 dma_channel_number_rx = 4;	// Initialize to prevent compiler warning
	u32 dma_channel_number_tx = 5;	


	/* Be sure arguments passed are within range */
	if (dmastreamrx > 7) bsp_panic(-1);
 800440e:	d903      	bls.n	8004418 <bsp_uart_dma_init+0x20>
 8004410:	f04f 30ff 	mov.w	r0, #4294967295
 8004414:	f7ff fef8 	bl	8004208 <bsp_panic>
	if (dmastreamtx > 7) bsp_panic(-2);
 8004418:	f1ba 0f07 	cmp.w	sl, #7
 800441c:	d903      	bls.n	8004426 <bsp_uart_dma_init+0x2e>
 800441e:	f06f 0001 	mvn.w	r0, #1
 8004422:	f7ff fef1 	bl	8004208 <bsp_panic>
	if ((dma_tx_int_priority & 0xffffff0f) != 0) bsp_panic(-3); // Bogus priority
 8004426:	9916      	ldr	r1, [sp, #88]	; 0x58
 8004428:	f031 01f0 	bics.w	r1, r1, #240	; 0xf0
 800442c:	d003      	beq.n	8004436 <bsp_uart_dma_init+0x3e>
 800442e:	f06f 0002 	mvn.w	r0, #2
 8004432:	f7ff fee9 	bl	8004208 <bsp_panic>
	
	cb_Idx = mapindex(iuart);	// Map usart/uart register base to control block index
 8004436:	4620      	mov	r0, r4
 8004438:	f7ff feee 	bl	8004218 <mapindex>

	/* Convert dma stream to dma base and irq number */
	dma_irq_number_tx = irq_given_datastream(iuart, dmastreamtx); // TX
 800443c:	4621      	mov	r1, r4
 800443e:	4652      	mov	r2, sl
	/* Be sure arguments passed are within range */
	if (dmastreamrx > 7) bsp_panic(-1);
	if (dmastreamtx > 7) bsp_panic(-2);
	if ((dma_tx_int_priority & 0xffffff0f) != 0) bsp_panic(-3); // Bogus priority
	
	cb_Idx = mapindex(iuart);	// Map usart/uart register base to control block index
 8004440:	4683      	mov	fp, r0

	/* Convert dma stream to dma base and irq number */
	dma_irq_number_tx = irq_given_datastream(iuart, dmastreamtx); // TX
 8004442:	a806      	add	r0, sp, #24
 8004444:	f7ff ff92 	bl	800436c <irq_given_datastream>
	dma_irq_number_rx = irq_given_datastream(iuart, dmastreamrx); // RX
 8004448:	a804      	add	r0, sp, #16
 800444a:	4621      	mov	r1, r4
 800444c:	463a      	mov	r2, r7
	if ((dma_tx_int_priority & 0xffffff0f) != 0) bsp_panic(-3); // Bogus priority
	
	cb_Idx = mapindex(iuart);	// Map usart/uart register base to control block index

	/* Convert dma stream to dma base and irq number */
	dma_irq_number_tx = irq_given_datastream(iuart, dmastreamtx); // TX
 800444e:	9e06      	ldr	r6, [sp, #24]
 8004450:	9d07      	ldr	r5, [sp, #28]
	dma_irq_number_rx = irq_given_datastream(iuart, dmastreamrx); // RX
 8004452:	f7ff ff8b 	bl	800436c <irq_given_datastream>
	
	/* The DMA determined should be the same...mostly a debugging issue. */
	if (dma_irq_number_tx.dma != dma_irq_number_rx.dma) bsp_panic(-333);
 8004456:	9b04      	ldr	r3, [sp, #16]
	
	cb_Idx = mapindex(iuart);	// Map usart/uart register base to control block index

	/* Convert dma stream to dma base and irq number */
	dma_irq_number_tx = irq_given_datastream(iuart, dmastreamtx); // TX
	dma_irq_number_rx = irq_given_datastream(iuart, dmastreamrx); // RX
 8004458:	f8dd 9014 	ldr.w	r9, [sp, #20]
	
	/* The DMA determined should be the same...mostly a debugging issue. */
	if (dma_irq_number_tx.dma != dma_irq_number_rx.dma) bsp_panic(-333);
 800445c:	429e      	cmp	r6, r3
 800445e:	d003      	beq.n	8004468 <bsp_uart_dma_init+0x70>
 8004460:	f46f 70a6 	mvn.w	r0, #332	; 0x14c
 8004464:	f7ff fed0 	bl	8004208 <bsp_panic>
	dma_x = dma_irq_number_tx.dma;	// Lazy way of dealing with it later

	/* Set dma stream interrupt to revector to this routine; check if dma is in use. */
	tmp = nvic_dma_stream_vector_add( (void(*)(u32*))&DMA_UART_IRQHandler, (u32*)&cb_uart[cb_Idx], dma_irq_number_tx.num, dmastreamtx);
 8004468:	4a85      	ldr	r2, [pc, #532]	; (8004680 <bsp_uart_dma_init+0x288>)
 800446a:	4886      	ldr	r0, [pc, #536]	; (8004684 <bsp_uart_dma_init+0x28c>)
 800446c:	ea4f 138b 	mov.w	r3, fp, lsl #6
 8004470:	eb02 0803 	add.w	r8, r2, r3
 8004474:	4641      	mov	r1, r8
 8004476:	462a      	mov	r2, r5
 8004478:	4653      	mov	r3, sl
 800447a:	f7ff fd75 	bl	8003f68 <nvic_dma_stream_vector_add>
	if (tmp != 0) bsp_panic(-30 + tmp);
 800447e:	b110      	cbz	r0, 8004486 <bsp_uart_dma_init+0x8e>
 8004480:	381e      	subs	r0, #30
 8004482:	f7ff fec1 	bl	8004208 <bsp_panic>

	/* RX doesn't interrupt, but we need to show that the stream has been taken */
	tmp = nvic_dma_stream_vector_add( (void(*)(u32*))&DMA_UART_IRQHandler, (u32*)&cb_uart[cb_Idx], dma_irq_number_rx.num, dmastreamrx);
 8004486:	487f      	ldr	r0, [pc, #508]	; (8004684 <bsp_uart_dma_init+0x28c>)
 8004488:	4641      	mov	r1, r8
 800448a:	464a      	mov	r2, r9
 800448c:	463b      	mov	r3, r7
 800448e:	f7ff fd6b 	bl	8003f68 <nvic_dma_stream_vector_add>
	if (tmp != 0) bsp_panic(-130 + tmp);
 8004492:	b110      	cbz	r0, 800449a <bsp_uart_dma_init+0xa2>
 8004494:	3882      	subs	r0, #130	; 0x82
 8004496:	f7ff feb7 	bl	8004208 <bsp_panic>


	/* Load some parameters that might be important. */
	cb_uart[cb_Idx].idma = dma_x;	// Save dma register base address
 800449a:	4a7b      	ldr	r2, [pc, #492]	; (8004688 <bsp_uart_dma_init+0x290>)
 800449c:	ea4f 138b 	mov.w	r3, fp, lsl #6
 80044a0:	18d3      	adds	r3, r2, r3
	cb_uart[cb_Idx].rxdma_stream = dmastreamrx; // Save stream number
	cb_uart[cb_Idx].txdma_stream = dmastreamtx; // Save stream number
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
	cb_uart[cb_Idx].flag = 2;	// Show this setup for dma driven
 80044a2:	2102      	movs	r1, #2
	tmp = nvic_dma_stream_vector_add( (void(*)(u32*))&DMA_UART_IRQHandler, (u32*)&cb_uart[cb_Idx], dma_irq_number_rx.num, dmastreamrx);
	if (tmp != 0) bsp_panic(-130 + tmp);


	/* Load some parameters that might be important. */
	cb_uart[cb_Idx].idma = dma_x;	// Save dma register base address
 80044a4:	605e      	str	r6, [r3, #4]
	cb_uart[cb_Idx].rxdma_stream = dmastreamrx; // Save stream number
 80044a6:	60df      	str	r7, [r3, #12]
	cb_uart[cb_Idx].txdma_stream = dmastreamtx; // Save stream number
 80044a8:	f8c3 a010 	str.w	sl, [r3, #16]
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
 80044ac:	609c      	str	r4, [r3, #8]
	cb_uart[cb_Idx].flag = 2;	// Show this setup for dma driven
 80044ae:	6159      	str	r1, [r3, #20]

	/* Find DMA channel numbers for RX and TX, given stream number */
	switch (dma_x)
 80044b0:	4b76      	ldr	r3, [pc, #472]	; (800468c <bsp_uart_dma_init+0x294>)
 80044b2:	429e      	cmp	r6, r3
 80044b4:	d003      	beq.n	80044be <bsp_uart_dma_init+0xc6>
 80044b6:	4b76      	ldr	r3, [pc, #472]	; (8004690 <bsp_uart_dma_init+0x298>)
 80044b8:	429e      	cmp	r6, r3
 80044ba:	d11f      	bne.n	80044fc <bsp_uart_dma_init+0x104>
 80044bc:	e00f      	b.n	80044de <bsp_uart_dma_init+0xe6>
	{
	case DMA1_BASE:
		if (dma1_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
 80044be:	f007 0207 	and.w	r2, r7, #7
 80044c2:	4b74      	ldr	r3, [pc, #464]	; (8004694 <bsp_uart_dma_init+0x29c>)
 80044c4:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80044c8:	42a1      	cmp	r1, r4
 80044ca:	d01b      	beq.n	8004504 <bsp_uart_dma_init+0x10c>
		if (dma1_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
 80044cc:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80044d0:	6a1b      	ldr	r3, [r3, #32]
 80044d2:	42a3      	cmp	r3, r4
 80044d4:	d022      	beq.n	800451c <bsp_uart_dma_init+0x124>
		bsp_panic(-6);	// RX stream specified is not compatible with UART/DMA1
 80044d6:	f06f 0005 	mvn.w	r0, #5
 80044da:	f7ff fe95 	bl	8004208 <bsp_panic>

	case DMA2_BASE:
		if (dma2_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
 80044de:	4b6d      	ldr	r3, [pc, #436]	; (8004694 <bsp_uart_dma_init+0x29c>)
 80044e0:	f007 0207 	and.w	r2, r7, #7
 80044e4:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80044e8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80044ea:	42a2      	cmp	r2, r4
 80044ec:	d00a      	beq.n	8004504 <bsp_uart_dma_init+0x10c>
		if (dma2_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
 80044ee:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80044f0:	42a3      	cmp	r3, r4
 80044f2:	d00a      	beq.n	800450a <bsp_uart_dma_init+0x112>
		bsp_panic(-7);	// RX stream specified is not compatible with UART/DMA2
 80044f4:	f06f 0006 	mvn.w	r0, #6
 80044f8:	f7ff fe86 	bl	8004208 <bsp_panic>
	default:
		bsp_panic(-8);	// Something seriously wrong here!
 80044fc:	f06f 0007 	mvn.w	r0, #7
 8004500:	f7ff fe82 	bl	8004208 <bsp_panic>
		if (dma1_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
		if (dma1_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
		bsp_panic(-6);	// RX stream specified is not compatible with UART/DMA1

	case DMA2_BASE:
		if (dma2_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
 8004504:	f04f 0904 	mov.w	r9, #4
 8004508:	e001      	b.n	800450e <bsp_uart_dma_init+0x116>
		if (dma2_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
 800450a:	f04f 0905 	mov.w	r9, #5
	default:
		bsp_panic(-8);	// Something seriously wrong here!

	}

	switch (dma_x)
 800450e:	4b5f      	ldr	r3, [pc, #380]	; (800468c <bsp_uart_dma_init+0x294>)
 8004510:	429e      	cmp	r6, r3
 8004512:	d005      	beq.n	8004520 <bsp_uart_dma_init+0x128>
 8004514:	4b5e      	ldr	r3, [pc, #376]	; (8004690 <bsp_uart_dma_init+0x298>)
 8004516:	429e      	cmp	r6, r3
 8004518:	d128      	bne.n	800456c <bsp_uart_dma_init+0x174>
 800451a:	e016      	b.n	800454a <bsp_uart_dma_init+0x152>
	/* Find DMA channel numbers for RX and TX, given stream number */
	switch (dma_x)
	{
	case DMA1_BASE:
		if (dma1_rxstreamtbl_4[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 4; break;}
		if (dma1_rxstreamtbl_5[dmastreamrx & 0x7] == iuart) {dma_channel_number_rx = 5; break;}
 800451c:	f04f 0905 	mov.w	r9, #5
	}

	switch (dma_x)
	{
	case DMA1_BASE:
		if (dma1_txstreamtbl_4[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 4; break;}
 8004520:	4b5c      	ldr	r3, [pc, #368]	; (8004694 <bsp_uart_dma_init+0x29c>)
 8004522:	f00a 0207 	and.w	r2, sl, #7
 8004526:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800452a:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 800452e:	42a2      	cmp	r2, r4
 8004530:	d024      	beq.n	800457c <bsp_uart_dma_init+0x184>
		if (dma1_txstreamtbl_5[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 5; break;}
 8004532:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 8004536:	42a2      	cmp	r2, r4
 8004538:	d023      	beq.n	8004582 <bsp_uart_dma_init+0x18a>
		if (dma1_txstreamtbl_7[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 7; break;}
 800453a:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 800453e:	42a3      	cmp	r3, r4
 8004540:	d019      	beq.n	8004576 <bsp_uart_dma_init+0x17e>
		bsp_panic(-9);	// TX stream specified is not compatible with UART/DMA1
 8004542:	f06f 0008 	mvn.w	r0, #8
 8004546:	f7ff fe5f 	bl	8004208 <bsp_panic>

	case DMA2_BASE:
		if (dma2_txstreamtbl_4[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 4; break;}
 800454a:	4b52      	ldr	r3, [pc, #328]	; (8004694 <bsp_uart_dma_init+0x29c>)
 800454c:	f00a 0207 	and.w	r2, sl, #7
 8004550:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8004554:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8004558:	42a2      	cmp	r2, r4
 800455a:	d00f      	beq.n	800457c <bsp_uart_dma_init+0x184>
		if (dma2_txstreamtbl_5[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 5; break;}
 800455c:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8004560:	42a3      	cmp	r3, r4
 8004562:	d00e      	beq.n	8004582 <bsp_uart_dma_init+0x18a>
		bsp_panic(-10);	// TX stream specified is not compatible with UART/DMA2
 8004564:	f06f 0009 	mvn.w	r0, #9
 8004568:	f7ff fe4e 	bl	8004208 <bsp_panic>
	default:
		bsp_panic(-11);	// Something seriously wrong here!
 800456c:	f06f 000a 	mvn.w	r0, #10
 8004570:	f7ff fe4a 	bl	8004208 <bsp_panic>
 8004574:	e005      	b.n	8004582 <bsp_uart_dma_init+0x18a>
	switch (dma_x)
	{
	case DMA1_BASE:
		if (dma1_txstreamtbl_4[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 4; break;}
		if (dma1_txstreamtbl_5[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 5; break;}
		if (dma1_txstreamtbl_7[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 7; break;}
 8004576:	f04f 0807 	mov.w	r8, #7
 800457a:	e004      	b.n	8004586 <bsp_uart_dma_init+0x18e>
		bsp_panic(-9);	// TX stream specified is not compatible with UART/DMA1

	case DMA2_BASE:
		if (dma2_txstreamtbl_4[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 4; break;}
 800457c:	f04f 0804 	mov.w	r8, #4
 8004580:	e001      	b.n	8004586 <bsp_uart_dma_init+0x18e>
		if (dma2_txstreamtbl_5[dmastreamtx & 0x7] == iuart) {dma_channel_number_tx = 5; break;}
 8004582:	f04f 0805 	mov.w	r8, #5
	default:
		bsp_panic(-11);	// Something seriously wrong here!

	}
static u32 qqq;
	qqq = dma_channel_number_rx;
 8004586:	4a40      	ldr	r2, [pc, #256]	; (8004688 <bsp_uart_dma_init+0x290>)
/* At this point we (should!) have a good DMA channel and stream that associates with the UART. */

	/* Set up UART pins, port & uart clockings.  THIS IS BOARD SPECIFIC */
	if (uart_pins(iuart, &uartpins) != 0) bsp_panic(-15);
 8004588:	4620      	mov	r0, r4
	default:
		bsp_panic(-11);	// Something seriously wrong here!

	}
static u32 qqq;
	qqq = dma_channel_number_rx;
 800458a:	f8c2 9204 	str.w	r9, [r2, #516]	; 0x204
/* At this point we (should!) have a good DMA channel and stream that associates with the UART. */

	/* Set up UART pins, port & uart clockings.  THIS IS BOARD SPECIFIC */
	if (uart_pins(iuart, &uartpins) != 0) bsp_panic(-15);
 800458e:	a908      	add	r1, sp, #32
 8004590:	f000 fa68 	bl	8004a64 <uart_pins>
 8004594:	b118      	cbz	r0, 800459e <bsp_uart_dma_init+0x1a6>
 8004596:	f06f 000e 	mvn.w	r0, #14
 800459a:	f7ff fe35 	bl	8004208 <bsp_panic>

	/* Setup baud rate */
	usartx_setbaud (iuart, uartpins.pclk, baud);
 800459e:	4620      	mov	r0, r4
 80045a0:	9908      	ldr	r1, [sp, #32]
 80045a2:	9a01      	ldr	r2, [sp, #4]
 80045a4:	f000 fb28 	bl	8004bf8 <usartx_setbaud>

	/* Obtain some buffer space */
	getbuff(cb_Idx, rxbuffsize, txbuffsize);
 80045a8:	4658      	mov	r0, fp
 80045aa:	9902      	ldr	r1, [sp, #8]
 80045ac:	9a03      	ldr	r2, [sp, #12]
 80045ae:	f7ff fe89 	bl	80042c4 <getbuff>

	/* ---------- Set up UART ----------------------------------------------------------------------------------- */

	/* Set up CR1 ---------------------------------------------------- */
	USART_CR1(iuart) |= (1<<13) | (1<<3) | (1<<2);// Set Usart enable, tx enable, rx enable
 80045b2:	68e3      	ldr	r3, [r4, #12]
	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 80045b4:	4934      	ldr	r1, [pc, #208]	; (8004688 <bsp_uart_dma_init+0x290>)
	getbuff(cb_Idx, rxbuffsize, txbuffsize);

	/* ---------- Set up UART ----------------------------------------------------------------------------------- */

	/* Set up CR1 ---------------------------------------------------- */
	USART_CR1(iuart) |= (1<<13) | (1<<3) | (1<<2);// Set Usart enable, tx enable, rx enable
 80045b6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80045ba:	f043 030c 	orr.w	r3, r3, #12
 80045be:	60e3      	str	r3, [r4, #12]

	/* Hook up usart tx and rx to dma channels */
	USART_CR3(iuart) |= (1<<7) | (1<<6);
 80045c0:	6963      	ldr	r3, [r4, #20]
 80045c2:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80045c6:	6163      	str	r3, [r4, #20]
	/* After reset CR2 is 0x0000 and this is just fine */

	/* --------- Set up the DMA channels ------------------------------------------------------------------------ */

	/* Set peripheral address for RX */
	DMA_SPAR(dma_x,dmastreamrx) = (u32*)(iuart + 0x04); // Address of uart DR register
 80045c8:	2318      	movs	r3, #24
 80045ca:	fb03 6707 	mla	r7, r3, r7, r6
	/* Set peripheral address for TX */
	DMA_SPAR(dma_x,dmastreamtx) = (u32*)(iuart + 0x04); // Address of uart DR register

	/* DMA stream configuration register--RX p 325 */
	//                                       Channel number     | MINC    | CIRC   | Per->Mem 
	DMA_SCR(dma_x,dmastreamrx) = ( (dma_channel_number_rx<< 25) | (1<<10) | (1<<8) | (0x0<<6) );   
 80045ce:	ea4f 6949 	mov.w	r9, r9, lsl #25

	/* Set peripheral address for RX */
	DMA_SPAR(dma_x,dmastreamrx) = (u32*)(iuart + 0x04); // Address of uart DR register

	/* Set peripheral address for TX */
	DMA_SPAR(dma_x,dmastreamtx) = (u32*)(iuart + 0x04); // Address of uart DR register
 80045d2:	fb03 660a 	mla	r6, r3, sl, r6
	/* After reset CR2 is 0x0000 and this is just fine */

	/* --------- Set up the DMA channels ------------------------------------------------------------------------ */

	/* Set peripheral address for RX */
	DMA_SPAR(dma_x,dmastreamrx) = (u32*)(iuart + 0x04); // Address of uart DR register
 80045d6:	3404      	adds	r4, #4
	/* Set peripheral address for TX */
	DMA_SPAR(dma_x,dmastreamtx) = (u32*)(iuart + 0x04); // Address of uart DR register

	/* DMA stream configuration register--RX p 325 */
	//                                       Channel number     | MINC    | CIRC   | Per->Mem 
	DMA_SCR(dma_x,dmastreamrx) = ( (dma_channel_number_rx<< 25) | (1<<10) | (1<<8) | (0x0<<6) );   
 80045d8:	f449 63a0 	orr.w	r3, r9, #1280	; 0x500

	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));
 80045dc:	ea4f 6848 	mov.w	r8, r8, lsl #25
	/* After reset CR2 is 0x0000 and this is just fine */

	/* --------- Set up the DMA channels ------------------------------------------------------------------------ */

	/* Set peripheral address for RX */
	DMA_SPAR(dma_x,dmastreamrx) = (u32*)(iuart + 0x04); // Address of uart DR register
 80045e0:	61bc      	str	r4, [r7, #24]

	/* Set peripheral address for TX */
	DMA_SPAR(dma_x,dmastreamtx) = (u32*)(iuart + 0x04); // Address of uart DR register
 80045e2:	61b4      	str	r4, [r6, #24]

	/* DMA stream configuration register--RX p 325 */
	//                                       Channel number     | MINC    | CIRC   | Per->Mem 
	DMA_SCR(dma_x,dmastreamrx) = ( (dma_channel_number_rx<< 25) | (1<<10) | (1<<8) | (0x0<<6) );   
 80045e4:	613b      	str	r3, [r7, #16]

	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));
 80045e6:	f448 3382 	orr.w	r3, r8, #66560	; 0x10400
 80045ea:	f043 0340 	orr.w	r3, r3, #64	; 0x40

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 80045ee:	ea4f 1b8b 	mov.w	fp, fp, lsl #6
	//                                       Channel number     | MINC    | CIRC   | Per->Mem 
	DMA_SCR(dma_x,dmastreamrx) = ( (dma_channel_number_rx<< 25) | (1<<10) | (1<<8) | (0x0<<6) );   

	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));
 80045f2:	6133      	str	r3, [r6, #16]

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 80045f4:	eb01 030b 	add.w	r3, r1, fp

	/* Set the number of bytes in the RX buff */
	DMA_SNDTR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_size;

	/* DMA for TX interrupts */
	NVICIPR (dma_irq_number_tx.num,dma_tx_int_priority);	// Set dma interrupt priority (tx)
 80045f8:	2d00      	cmp	r5, #0
	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 80045fa:	6b1a      	ldr	r2, [r3, #48]	; 0x30

	/* Set the number of bytes in the RX buff */
	DMA_SNDTR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_size;
 80045fc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
	/* DMA stream configuration register--TX */
	//                                       Channel number     | MINC    | CIRC   | Mem->per | priority
	DMA_SCR(dma_x,dmastreamtx) = ( (dma_channel_number_tx<< 25) | (1<<10) | (0<<8) | (0x1<<6) | (1<<16));

	/* Set RX memory address (stays forever) */
	DMA_SM0AR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_base;
 80045fe:	61fa      	str	r2, [r7, #28]

	/* Set the number of bytes in the RX buff */
	DMA_SNDTR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_size;
 8004600:	617b      	str	r3, [r7, #20]

	/* DMA for TX interrupts */
	NVICIPR (dma_irq_number_tx.num,dma_tx_int_priority);	// Set dma interrupt priority (tx)
 8004602:	4b25      	ldr	r3, [pc, #148]	; (8004698 <bsp_uart_dma_init+0x2a0>)
 8004604:	462a      	mov	r2, r5
 8004606:	bfb8      	it	lt
 8004608:	1cea      	addlt	r2, r5, #3
 800460a:	f022 0203 	bic.w	r2, r2, #3
 800460e:	ea05 0303 	and.w	r3, r5, r3
 8004612:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
 8004616:	2b00      	cmp	r3, #0
 8004618:	f502 4264 	add.w	r2, r2, #58368	; 0xe400
 800461c:	da03      	bge.n	8004626 <bsp_uart_dma_init+0x22e>
 800461e:	3b01      	subs	r3, #1
 8004620:	f063 0303 	orn	r3, r3, #3
 8004624:	3301      	adds	r3, #1
 8004626:	9916      	ldr	r1, [sp, #88]	; 0x58
 8004628:	00db      	lsls	r3, r3, #3
 800462a:	fa11 f303 	lsls.w	r3, r1, r3
 800462e:	6811      	ldr	r1, [r2, #0]
	NVICISER(dma_irq_number_tx.num);			// Enable dma interrupt (tx)
 8004630:	2d00      	cmp	r5, #0

	/* Set the number of bytes in the RX buff */
	DMA_SNDTR(dma_x,dmastreamrx) = cb_uart[cb_Idx].rxbuff_size;

	/* DMA for TX interrupts */
	NVICIPR (dma_irq_number_tx.num,dma_tx_int_priority);	// Set dma interrupt priority (tx)
 8004632:	ea41 0303 	orr.w	r3, r1, r3
 8004636:	6013      	str	r3, [r2, #0]
	NVICISER(dma_irq_number_tx.num);			// Enable dma interrupt (tx)
 8004638:	462b      	mov	r3, r5
 800463a:	bfb8      	it	lt
 800463c:	f105 031f 	addlt.w	r3, r5, #31
 8004640:	115a      	asrs	r2, r3, #5
 8004642:	4b16      	ldr	r3, [pc, #88]	; (800469c <bsp_uart_dma_init+0x2a4>)
 8004644:	18d3      	adds	r3, r2, r3
 8004646:	009a      	lsls	r2, r3, #2
 8004648:	4b15      	ldr	r3, [pc, #84]	; (80046a0 <bsp_uart_dma_init+0x2a8>)
 800464a:	ea05 0303 	and.w	r3, r5, r3
 800464e:	2b00      	cmp	r3, #0
 8004650:	da03      	bge.n	800465a <bsp_uart_dma_init+0x262>
 8004652:	3b01      	subs	r3, #1
 8004654:	f063 031f 	orn	r3, r3, #31
 8004658:	3301      	adds	r3, #1
 800465a:	2101      	movs	r1, #1
 800465c:	fa11 f303 	lsls.w	r3, r1, r3
 8004660:	6811      	ldr	r1, [r2, #0]
 8004662:	ea41 0303 	orr.w	r3, r1, r3
 8004666:	6013      	str	r3, [r2, #0]

	/* Final enabling of DMA */
	DMA_SCR(dma_x,dmastreamrx) |= (0x1);		// Enable rx stream
 8004668:	693b      	ldr	r3, [r7, #16]
 800466a:	f043 0301 	orr.w	r3, r3, #1
 800466e:	613b      	str	r3, [r7, #16]
	DMA_SCR(dma_x,dmastreamtx) |= ((1<<4));	// TCIE (xfer complete interrupt), not enable stream
 8004670:	6933      	ldr	r3, [r6, #16]
 8004672:	f043 0310 	orr.w	r3, r3, #16
 8004676:	6133      	str	r3, [r6, #16]

	return 0;	// SUCCESS!
}
 8004678:	2000      	movs	r0, #0
 800467a:	b00b      	add	sp, #44	; 0x2c
 800467c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004680:	200008d0 	.word	0x200008d0
 8004684:	080041d9 	.word	0x080041d9
 8004688:	200008cc 	.word	0x200008cc
 800468c:	40026000 	.word	0x40026000
 8004690:	40026400 	.word	0x40026400
 8004694:	2000014c 	.word	0x2000014c
 8004698:	80000003 	.word	0x80000003
 800469c:	38003840 	.word	0x38003840
 80046a0:	8000001f 	.word	0x8000001f

080046a4 <bsp_uart_dma_init_number>:
 * int bsp_uart_dma_init_number(u32 uartnumber, u32 baud,u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority);
 * @brief	: A wrapper for 'int bsp_uart_dma_init' with uart number (1-6) rather than uart base address as the first argument
 * @return	: Same as bsp_uart_dma_init
*******************************************************************************/
int bsp_uart_dma_init_number(u32 uartnumber, u32 baud,u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority)
{
 80046a4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80046a8:	f8dd 9020 	ldr.w	r9, [sp, #32]
 80046ac:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
 80046b0:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 80046b2:	460e      	mov	r6, r1
 80046b4:	4615      	mov	r5, r2
 80046b6:	461c      	mov	r4, r3
	u32 iuart = uartnumber_to_baseaddr(uartnumber);
 80046b8:	f7ff fe30 	bl	800431c <uartnumber_to_baseaddr>
	return  bsp_uart_dma_init(iuart, baud, rxbuffsize, txbuffsize, dmastreamrx, dmastreamtx, dma_tx_int_priority);
 80046bc:	4631      	mov	r1, r6
 80046be:	462a      	mov	r2, r5
 80046c0:	4623      	mov	r3, r4
 80046c2:	f8cd 9020 	str.w	r9, [sp, #32]
 80046c6:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
 80046ca:	970a      	str	r7, [sp, #40]	; 0x28
}
 80046cc:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 * @return	: Same as bsp_uart_dma_init
*******************************************************************************/
int bsp_uart_dma_init_number(u32 uartnumber, u32 baud,u32 rxbuffsize, u32 txbuffsize, u32 dmastreamrx, u32 dmastreamtx, u32 dma_tx_int_priority)
{
	u32 iuart = uartnumber_to_baseaddr(uartnumber);
	return  bsp_uart_dma_init(iuart, baud, rxbuffsize, txbuffsize, dmastreamrx, dmastreamtx, dma_tx_int_priority);
 80046d0:	e692      	b.n	80043f8 <bsp_uart_dma_init>

080046d2 <bsp_uart_getcount_ptr>:
*******************************************************************************/
int bsp_uart_getcount_ptr(struct CB_UART* pctl)
{
	int	Diff;

	if (pctl->flag == 1)
 80046d2:	6902      	ldr	r2, [r0, #16]
 80046d4:	2a01      	cmp	r2, #1
 * @brief	: Get the number of bytes buffered
 * @param	: pctl = pointer uart control block
 * @return	: number of chars in currently buffered.
*******************************************************************************/
int bsp_uart_getcount_ptr(struct CB_UART* pctl)
{
 80046d6:	4603      	mov	r3, r0
	int	Diff;

	if (pctl->flag == 1)
 80046d8:	d101      	bne.n	80046de <bsp_uart_getcount_ptr+0xc>
	{ // Here, interrupt driven uart
		Diff = (int)(pctl->rxbuff_in - pctl->rxbuff_out);
 80046da:	6b80      	ldr	r0, [r0, #56]	; 0x38
 80046dc:	e009      	b.n	80046f2 <bsp_uart_getcount_ptr+0x20>
		if (Diff < 0)
			Diff += pctl->rxbuff_size;  // Adjust for wrap
		return Diff;
	}

	if (pctl->flag == 2)
 80046de:	2a02      	cmp	r2, #2
 80046e0:	d10d      	bne.n	80046fe <bsp_uart_getcount_ptr+0x2c>
	{ // Here, DMA driven uart
		/* Difference between where we are taking out chars, and where DMA is/was storing */
		Diff = ( pctl->rxbuff_end - DMA_SNDTR(pctl->idma,pctl->rxdma_stream) - pctl->rxbuff_out );
 80046e2:	6801      	ldr	r1, [r0, #0]
 80046e4:	6882      	ldr	r2, [r0, #8]
 80046e6:	2018      	movs	r0, #24
 80046e8:	4342      	muls	r2, r0
 80046ea:	3114      	adds	r1, #20
 80046ec:	6b18      	ldr	r0, [r3, #48]	; 0x30
 80046ee:	588a      	ldr	r2, [r1, r2]
 80046f0:	1a80      	subs	r0, r0, r2
 80046f2:	6bda      	ldr	r2, [r3, #60]	; 0x3c
		if (Diff < 0)
 80046f4:	1a80      	subs	r0, r0, r2
 80046f6:	d503      	bpl.n	8004700 <bsp_uart_getcount_ptr+0x2e>
			Diff += pctl->rxbuff_size;  // Adjust for wrap
 80046f8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80046fa:	18c0      	adds	r0, r0, r3
 80046fc:	4770      	bx	lr
		return Diff;
	}
	return 0;	// Something wrong if we got here.
 80046fe:	2000      	movs	r0, #0
}
 8004700:	4770      	bx	lr

08004702 <bsp_uart_getcount_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_getcount_uartnum(int uartnum)	// Select by uart number (1 - n)
{
	if ( ((uartnum - 1) < 0) || ((uartnum - 1) > 7) ) return 0;
 8004702:	3801      	subs	r0, #1
 8004704:	2807      	cmp	r0, #7
 8004706:	d803      	bhi.n	8004710 <bsp_uart_getcount_uartnum+0xe>
	return bsp_uart_getcount_ptr(&cb_uart[uartnum - 1]);
 8004708:	4b02      	ldr	r3, [pc, #8]	; (8004714 <bsp_uart_getcount_uartnum+0x12>)
 800470a:	0180      	lsls	r0, r0, #6
 800470c:	1818      	adds	r0, r3, r0
 800470e:	e7e0      	b.n	80046d2 <bsp_uart_getcount_ptr>
}
 8004710:	2000      	movs	r0, #0
 8004712:	4770      	bx	lr
 8004714:	200008d0 	.word	0x200008d0

08004718 <bsp_uart_getc_ptr>:
 * @brief	: Get one char
 * @param	: pctl = pointer uart control block
 * @return	: char from buffer
*******************************************************************************/
char bsp_uart_getc_ptr(struct CB_UART* pctl)
{
 8004718:	b538      	push	{r3, r4, r5, lr}
 800471a:	4604      	mov	r4, r0
	char	c;
	u32 	i = 0;
 800471c:	2500      	movs	r5, #0

	/* Hang waiting for incoming bytes if bozo caller didn't check char count. */
	while (( bsp_uart_getcount_ptr(pctl) == 0)  && (i++ < 50000) ) ;
 800471e:	4620      	mov	r0, r4
 8004720:	f7ff ffd7 	bl	80046d2 <bsp_uart_getcount_ptr>
 8004724:	b120      	cbz	r0, 8004730 <bsp_uart_getc_ptr+0x18>
	if (i >= 50000) panic_leds(-50);
 8004726:	f24c 334f 	movw	r3, #49999	; 0xc34f
 800472a:	429d      	cmp	r5, r3
 800472c:	d909      	bls.n	8004742 <bsp_uart_getc_ptr+0x2a>
 800472e:	e004      	b.n	800473a <bsp_uart_getc_ptr+0x22>
{
	char	c;
	u32 	i = 0;

	/* Hang waiting for incoming bytes if bozo caller didn't check char count. */
	while (( bsp_uart_getcount_ptr(pctl) == 0)  && (i++ < 50000) ) ;
 8004730:	3501      	adds	r5, #1
 8004732:	f24c 3351 	movw	r3, #50001	; 0xc351
 8004736:	429d      	cmp	r5, r3
 8004738:	d1f1      	bne.n	800471e <bsp_uart_getc_ptr+0x6>
	if (i >= 50000) panic_leds(-50);
 800473a:	f06f 0031 	mvn.w	r0, #49	; 0x31
 800473e:	f7ff f9fa 	bl	8003b36 <panic_leds>

	c = *pctl->rxbuff_out;
 8004742:	6be1      	ldr	r1, [r4, #60]	; 0x3c
	pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
 8004744:	4620      	mov	r0, r4

	/* Hang waiting for incoming bytes if bozo caller didn't check char count. */
	while (( bsp_uart_getcount_ptr(pctl) == 0)  && (i++ < 50000) ) ;
	if (i >= 50000) panic_leds(-50);

	c = *pctl->rxbuff_out;
 8004746:	780d      	ldrb	r5, [r1, #0]
	pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
 8004748:	f7ff fd0e 	bl	8004168 <rxbuff_adv>
 800474c:	63e0      	str	r0, [r4, #60]	; 0x3c
	return c;
}
 800474e:	4628      	mov	r0, r5
 8004750:	bd38      	pop	{r3, r4, r5, pc}

08004752 <bsp_uart_getc_uartnum>:
/* ---------------------------------------------------------------------------- */
char bsp_uart_getc_uartnum(int uartnum)	// Select by uart number (1 - n)
{
	if (((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 8004752:	3801      	subs	r0, #1
 8004754:	2807      	cmp	r0, #7
 8004756:	d803      	bhi.n	8004760 <bsp_uart_getc_uartnum+0xe>
	return bsp_uart_getc_ptr(&cb_uart[uartnum - 1]);
 8004758:	4b02      	ldr	r3, [pc, #8]	; (8004764 <bsp_uart_getc_uartnum+0x12>)
 800475a:	0180      	lsls	r0, r0, #6
 800475c:	1818      	adds	r0, r3, r0
 800475e:	e7db      	b.n	8004718 <bsp_uart_getc_ptr>
}
 8004760:	2000      	movs	r0, #0
 8004762:	4770      	bx	lr
 8004764:	200008d0 	.word	0x200008d0

08004768 <bsp_uart_getn_ptr>:
 * @param	: pchr = pointer to output char buffer
 * @param	: len = number of bytes requested
 * @return	: number of chars actually transferred
*******************************************************************************/
int bsp_uart_getn_ptr(struct CB_UART* pctl, char *pchr, int len)
{
 8004768:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800476a:	4604      	mov	r4, r0
 800476c:	460d      	mov	r5, r1
 800476e:	4617      	mov	r7, r2
	int 	i;
	int 	ct;

	ct = bsp_uart_getcount_ptr(pctl);
 8004770:	f7ff ffaf 	bl	80046d2 <bsp_uart_getcount_ptr>
	if (ct == 0) return 0;
 8004774:	4606      	mov	r6, r0
 8004776:	b178      	cbz	r0, 8004798 <bsp_uart_getn_ptr+0x30>
 8004778:	42be      	cmp	r6, r7
 800477a:	bfa8      	it	ge
 800477c:	463e      	movge	r6, r7

	if (ct > len) ct = len; // Check fo more ready than requested

	for (i = 0; i < ct; i++)
 800477e:	2700      	movs	r7, #0
 8004780:	e008      	b.n	8004794 <bsp_uart_getn_ptr+0x2c>
	{
		*pchr++ = *pctl->rxbuff_out;	// Copy from buffer to output
 8004782:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004784:	781b      	ldrb	r3, [r3, #0]
 8004786:	55eb      	strb	r3, [r5, r7]
		pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
 8004788:	4620      	mov	r0, r4
 800478a:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800478c:	f7ff fcec 	bl	8004168 <rxbuff_adv>
	ct = bsp_uart_getcount_ptr(pctl);
	if (ct == 0) return 0;

	if (ct > len) ct = len; // Check fo more ready than requested

	for (i = 0; i < ct; i++)
 8004790:	3701      	adds	r7, #1
	{
		*pchr++ = *pctl->rxbuff_out;	// Copy from buffer to output
		pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
 8004792:	63e0      	str	r0, [r4, #60]	; 0x3c
	ct = bsp_uart_getcount_ptr(pctl);
	if (ct == 0) return 0;

	if (ct > len) ct = len; // Check fo more ready than requested

	for (i = 0; i < ct; i++)
 8004794:	42b7      	cmp	r7, r6
 8004796:	dbf4      	blt.n	8004782 <bsp_uart_getn_ptr+0x1a>
	{
		*pchr++ = *pctl->rxbuff_out;	// Copy from buffer to output
		pctl->rxbuff_out = rxbuff_adv(pctl, pctl->rxbuff_out);	// Advance pointer common routine
	}
	return ct; // Return number transfered.
}
 8004798:	4630      	mov	r0, r6
 800479a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800479c <bsp_uart_getn_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_getn_uartnum(int uartnum, char *pchr, int len)	// Select by uart number (1 - n)
{
	if ( ((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 800479c:	3801      	subs	r0, #1
 800479e:	2807      	cmp	r0, #7
 80047a0:	d803      	bhi.n	80047aa <bsp_uart_getn_uartnum+0xe>
	return bsp_uart_getn_ptr(&cb_uart[uartnum - 1],  pchr, len);
 80047a2:	4b03      	ldr	r3, [pc, #12]	; (80047b0 <bsp_uart_getn_uartnum+0x14>)
 80047a4:	0180      	lsls	r0, r0, #6
 80047a6:	1818      	adds	r0, r3, r0
 80047a8:	e7de      	b.n	8004768 <bsp_uart_getn_ptr>
}
 80047aa:	2000      	movs	r0, #0
 80047ac:	4770      	bx	lr
 80047ae:	bf00      	nop
 80047b0:	200008d0 	.word	0x200008d0

080047b4 <bsp_uart_start_dma>:
 * @param	: pctl: control block poiner
 * @return	:
*******************************************************************************/
void bsp_uart_start_dma(struct CB_UART* pctl)
{
	if (pctl->flag != 2) return;	// Return, not DMA driven
 80047b4:	6902      	ldr	r2, [r0, #16]
 80047b6:	2a02      	cmp	r2, #2
 * @brief	: If DMA driven uart, start DMA sending if not already sending
 * @param	: pctl: control block poiner
 * @return	:
*******************************************************************************/
void bsp_uart_start_dma(struct CB_UART* pctl)
{
 80047b8:	b510      	push	{r4, lr}
	if (pctl->flag != 2) return;	// Return, not DMA driven
 80047ba:	d10f      	bne.n	80047dc <bsp_uart_start_dma+0x28>
	
	/* Are we already running? */
	// First look at the enable bit
	if ((DMA_SCR(pctl->idma, pctl->txdma_stream) & 0x1) != 0) return;	// Already running
 80047bc:	6801      	ldr	r1, [r0, #0]
 80047be:	68c2      	ldr	r2, [r0, #12]
 80047c0:	2418      	movs	r4, #24
 80047c2:	4362      	muls	r2, r4
 80047c4:	3110      	adds	r1, #16
 80047c6:	5889      	ldr	r1, [r1, r2]
 80047c8:	f011 0f01 	tst.w	r1, #1
 80047cc:	d106      	bne.n	80047dc <bsp_uart_start_dma+0x28>


	// Check if the counter has gone to zero
	if ( DMA_SNDTR(pctl->idma,pctl->txdma_stream) != 0) return;
 80047ce:	6803      	ldr	r3, [r0, #0]
 80047d0:	3314      	adds	r3, #20
 80047d2:	589b      	ldr	r3, [r3, r2]
 80047d4:	b913      	cbnz	r3, 80047dc <bsp_uart_start_dma+0x28>
	
	/* Not running.  If there are any to send, set up the DMA. */
	common_dma(pctl);

	return;
}
 80047d6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

	// Check if the counter has gone to zero
	if ( DMA_SNDTR(pctl->idma,pctl->txdma_stream) != 0) return;
	
	/* Not running.  If there are any to send, set up the DMA. */
	common_dma(pctl);
 80047da:	e4d3      	b.n	8004184 <common_dma>
 80047dc:	bd10      	pop	{r4, pc}

080047de <bsp_uart_send_int>:
 * @param	: pctl = pointer uart control block
 * @return	: 
*******************************************************************************/
void bsp_uart_send_int(struct CB_UART* pctl)
{
	if (pctl->flag != 1) return;	// Return not interrupt drive & initialized
 80047de:	6903      	ldr	r3, [r0, #16]
 80047e0:	2b01      	cmp	r3, #1
 80047e2:	d109      	bne.n	80047f8 <bsp_uart_send_int+0x1a>

	if ((USART_CR1(pctl->iuart) & USART_CR1_TXEIE) != 0) // Already enabled?
 80047e4:	6843      	ldr	r3, [r0, #4]
 80047e6:	68db      	ldr	r3, [r3, #12]
 80047e8:	f013 0f80 	tst.w	r3, #128	; 0x80
 80047ec:	d104      	bne.n	80047f8 <bsp_uart_send_int+0x1a>
		return;

	USART_CR1(pctl->iuart) |= USART_CR1_TXEIE ;	// Enable interrupt
 80047ee:	6843      	ldr	r3, [r0, #4]
 80047f0:	68da      	ldr	r2, [r3, #12]
 80047f2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80047f6:	60da      	str	r2, [r3, #12]
 80047f8:	4770      	bx	lr

080047fa <bsp_uart_putc_ptr>:
 * @param	: Char to be sent
 * @return	: 1 = one char add; 0 = no chars added; -1 = pctl was null
 * NOTE: this does not start an idle DMA, but starts an idle interrupt driven uart
*******************************************************************************/
int bsp_uart_putc_ptr(struct CB_UART* pctl, char c) // Select by control block ptr
{
 80047fa:	b570      	push	{r4, r5, r6, lr}
 80047fc:	460e      	mov	r6, r1
	u8* p;

	if (pctl == 0) return -1;
 80047fe:	4604      	mov	r4, r0
 8004800:	b180      	cbz	r0, 8004824 <bsp_uart_putc_ptr+0x2a>

	/* Check if buffer filled.  Return zero if full. */
	p = txbuff_adv(pctl, pctl->txbuff_in); 	// Advance input pointer (circularly)
 8004802:	6a05      	ldr	r5, [r0, #32]
 8004804:	4629      	mov	r1, r5
 8004806:	f7ff fcb6 	bl	8004176 <txbuff_adv>
	if (p == pctl->txbuff_out)  return 0; 	// Return zero, rather than overwrite buffer
 800480a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800480c:	4298      	cmp	r0, r3
 800480e:	d00c      	beq.n	800482a <bsp_uart_putc_ptr+0x30>

	*pctl->txbuff_in = (u8)c;		// Store char
 8004810:	702e      	strb	r6, [r5, #0]

	/* Update the input buffer pointer to the next position. */
	pctl->txbuff_in = p;
 8004812:	6220      	str	r0, [r4, #32]

	/* Start sending if non-dma */
	bsp_uart_send_int(pctl);
 8004814:	4620      	mov	r0, r4
 8004816:	f7ff ffe2 	bl	80047de <bsp_uart_send_int>

	/* Start sending: if dma and not idle. */
	bsp_uart_start_dma(pctl); 
 800481a:	4620      	mov	r0, r4
 800481c:	f7ff ffca 	bl	80047b4 <bsp_uart_start_dma>

 	return 1; // Return byte count stored.
 8004820:	2001      	movs	r0, #1
 8004822:	bd70      	pop	{r4, r5, r6, pc}
*******************************************************************************/
int bsp_uart_putc_ptr(struct CB_UART* pctl, char c) // Select by control block ptr
{
	u8* p;

	if (pctl == 0) return -1;
 8004824:	f04f 30ff 	mov.w	r0, #4294967295
 8004828:	bd70      	pop	{r4, r5, r6, pc}

	/* Check if buffer filled.  Return zero if full. */
	p = txbuff_adv(pctl, pctl->txbuff_in); 	// Advance input pointer (circularly)
	if (p == pctl->txbuff_out)  return 0; 	// Return zero, rather than overwrite buffer
 800482a:	2000      	movs	r0, #0

	/* Start sending: if dma and not idle. */
	bsp_uart_start_dma(pctl); 

 	return 1; // Return byte count stored.
}
 800482c:	bd70      	pop	{r4, r5, r6, pc}

0800482e <bsp_uart_putc_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_putc_uartnum(int uartnum, char c)	// Select by uart number (1 - n)
{
	if (((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 800482e:	3801      	subs	r0, #1
 8004830:	2807      	cmp	r0, #7
 8004832:	d803      	bhi.n	800483c <bsp_uart_putc_uartnum+0xe>
	return bsp_uart_putc_ptr(&cb_uart[uartnum - 1], c);
 8004834:	4b02      	ldr	r3, [pc, #8]	; (8004840 <bsp_uart_putc_uartnum+0x12>)
 8004836:	0180      	lsls	r0, r0, #6
 8004838:	1818      	adds	r0, r3, r0
 800483a:	e7de      	b.n	80047fa <bsp_uart_putc_ptr>
}
 800483c:	2000      	movs	r0, #0
 800483e:	4770      	bx	lr
 8004840:	200008d0 	.word	0x200008d0

08004844 <bsp_uart_puts_ptr>:
 * @param	: p = pointer to buffer with bytes to be added
 * @return	: count of bytes added to buffer
 * NOTE: this starts either DMA or interrupt driven 
*******************************************************************************/
int bsp_uart_puts_ptr(struct CB_UART* pctl, char* p) // Select: control blk ptr
{
 8004844:	b570      	push	{r4, r5, r6, lr}
 8004846:	460d      	mov	r5, r1
	u32 ct = 0;
	int ret;

	if (pctl == 0) return -1;	// Pointer not set
 8004848:	4606      	mov	r6, r0
 800484a:	b168      	cbz	r0, 8004868 <bsp_uart_puts_ptr+0x24>
 800484c:	2400      	movs	r4, #0
 800484e:	e006      	b.n	800485e <bsp_uart_puts_ptr+0x1a>
	
	while (*p != 0)
	{
		ret = bsp_uart_putc_ptr(pctl, *p);	// Put char
 8004850:	4630      	mov	r0, r6
 8004852:	f7ff ffd2 	bl	80047fa <bsp_uart_putc_ptr>
		if (ret > 0)
 8004856:	2800      	cmp	r0, #0
		{ // Here, one byte was stored in buffer
			ct += ret;	// Add to count loaded
 8004858:	bfc4      	itt	gt
 800485a:	1824      	addgt	r4, r4, r0
			p++;
 800485c:	3501      	addgt	r5, #1
	u32 ct = 0;
	int ret;

	if (pctl == 0) return -1;	// Pointer not set
	
	while (*p != 0)
 800485e:	7829      	ldrb	r1, [r5, #0]
 8004860:	2900      	cmp	r1, #0
 8004862:	d1f5      	bne.n	8004850 <bsp_uart_puts_ptr+0xc>
			ct += ret;	// Add to count loaded
			p++;
		} // Note: loop hangs when buffer is full
	}

	return ct;
 8004864:	4620      	mov	r0, r4
 8004866:	bd70      	pop	{r4, r5, r6, pc}
int bsp_uart_puts_ptr(struct CB_UART* pctl, char* p) // Select: control blk ptr
{
	u32 ct = 0;
	int ret;

	if (pctl == 0) return -1;	// Pointer not set
 8004868:	f04f 30ff 	mov.w	r0, #4294967295
			p++;
		} // Note: loop hangs when buffer is full
	}

	return ct;
}
 800486c:	bd70      	pop	{r4, r5, r6, pc}

0800486e <bsp_uart_puts_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_puts_uartnum(int uartnum,char* p)	// Select by uart number (1 - n)
{
	if (((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 800486e:	3801      	subs	r0, #1
 8004870:	2807      	cmp	r0, #7
 8004872:	d803      	bhi.n	800487c <bsp_uart_puts_uartnum+0xe>
	return bsp_uart_puts_ptr(&cb_uart[uartnum - 1], p);
 8004874:	4b02      	ldr	r3, [pc, #8]	; (8004880 <bsp_uart_puts_uartnum+0x12>)
 8004876:	0180      	lsls	r0, r0, #6
 8004878:	1818      	adds	r0, r3, r0
 800487a:	e7e3      	b.n	8004844 <bsp_uart_puts_ptr>
}
 800487c:	2000      	movs	r0, #0
 800487e:	4770      	bx	lr
 8004880:	200008d0 	.word	0x200008d0

08004884 <bsp_uart_putn_ptr>:
 * @param	: count = number of bytes to be added
 * @return	: count of bytes added to buffer
 * NOTE: this starts either DMA or interrupt driven 
*******************************************************************************/
int bsp_uart_putn_ptr(struct CB_UART* pctl, char* p, int len ) // Select: control blk ptr
{
 8004884:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004886:	460c      	mov	r4, r1
 8004888:	4616      	mov	r6, r2
	u32 ct = len;
	int ret;
/* 'ct' and 'len' separate in case we decide to change it to return when the ct loaded is not equal len. */
	if (pctl == 0) return -1;	// Pointer not set
 800488a:	4607      	mov	r7, r0
 800488c:	b170      	cbz	r0, 80048ac <bsp_uart_putn_ptr+0x28>
 800488e:	4615      	mov	r5, r2
 8004890:	e008      	b.n	80048a4 <bsp_uart_putn_ptr+0x20>
	
	while (len > 0)
	{
		while ((ret = bsp_uart_putc_ptr(pctl, *p)) == 0) ; // Loop if full 
 8004892:	4638      	mov	r0, r7
 8004894:	7821      	ldrb	r1, [r4, #0]
 8004896:	f7ff ffb0 	bl	80047fa <bsp_uart_putc_ptr>
 800489a:	2800      	cmp	r0, #0
 800489c:	d0f9      	beq.n	8004892 <bsp_uart_putn_ptr+0xe>
		if (ret < 0 ) return ret; // Error.
 800489e:	db07      	blt.n	80048b0 <bsp_uart_putn_ptr+0x2c>
		p++;		// 
 80048a0:	3401      	adds	r4, #1
		len -= 1;	// Decrement input count
 80048a2:	3d01      	subs	r5, #1
	u32 ct = len;
	int ret;
/* 'ct' and 'len' separate in case we decide to change it to return when the ct loaded is not equal len. */
	if (pctl == 0) return -1;	// Pointer not set
	
	while (len > 0)
 80048a4:	2d00      	cmp	r5, #0
 80048a6:	dcf4      	bgt.n	8004892 <bsp_uart_putn_ptr+0xe>
		while ((ret = bsp_uart_putc_ptr(pctl, *p)) == 0) ; // Loop if full 
		if (ret < 0 ) return ret; // Error.
		p++;		// 
		len -= 1;	// Decrement input count
	}
	return (ct - len);	// Return count added to buffer
 80048a8:	1b70      	subs	r0, r6, r5
 80048aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
int bsp_uart_putn_ptr(struct CB_UART* pctl, char* p, int len ) // Select: control blk ptr
{
	u32 ct = len;
	int ret;
/* 'ct' and 'len' separate in case we decide to change it to return when the ct loaded is not equal len. */
	if (pctl == 0) return -1;	// Pointer not set
 80048ac:	f04f 30ff 	mov.w	r0, #4294967295
		if (ret < 0 ) return ret; // Error.
		p++;		// 
		len -= 1;	// Decrement input count
	}
	return (ct - len);	// Return count added to buffer
}
 80048b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080048b2 <bsp_uart_putn_uartnum>:
/* ---------------------------------------------------------------------------- */
int bsp_uart_putn_uartnum(int uartnum, char* p, int len )	// Select by uart number (1 - n)
{
	if (((uartnum - 1) < 0) || ((uartnum - 1) > 7)) return 0;
 80048b2:	3801      	subs	r0, #1
 80048b4:	2807      	cmp	r0, #7
 80048b6:	d803      	bhi.n	80048c0 <bsp_uart_putn_uartnum+0xe>
	return bsp_uart_putn_ptr(&cb_uart[uartnum - 1], p, len);
 80048b8:	4b02      	ldr	r3, [pc, #8]	; (80048c4 <bsp_uart_putn_uartnum+0x12>)
 80048ba:	0180      	lsls	r0, r0, #6
 80048bc:	1818      	adds	r0, r3, r0
 80048be:	e7e1      	b.n	8004884 <bsp_uart_putn_ptr>
}
 80048c0:	2000      	movs	r0, #0
 80048c2:	4770      	bx	lr
 80048c4:	200008d0 	.word	0x200008d0

080048c8 <bsp_uart_int_init>:
 * @param	: uart_int_priority: interrupt priority, (0x00 - 0xf0) e.g. 0xc0, low 4 bits zero
 * @return	: 0 = success; fail traps to 'panic_leds'
*******************************************************************************/

int bsp_uart_int_init(u32 iuart, u32 baud, u32 rxbuffsize, u32 txbuffsize,  u32 uart_int_priority)
{
 80048c8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 80048cc:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
	u32 cb_Idx;
	struct UARTPINS uartpins;

	if ((uart_int_priority & 0xf) != 0) bsp_panic(-3); // Bogus priority
 80048d0:	f018 0f0f 	tst.w	r8, #15
 * @param	: uart_int_priority: interrupt priority, (0x00 - 0xf0) e.g. 0xc0, low 4 bits zero
 * @return	: 0 = success; fail traps to 'panic_leds'
*******************************************************************************/

int bsp_uart_int_init(u32 iuart, u32 baud, u32 rxbuffsize, u32 txbuffsize,  u32 uart_int_priority)
{
 80048d4:	4604      	mov	r4, r0
 80048d6:	460e      	mov	r6, r1
 80048d8:	4615      	mov	r5, r2
 80048da:	4699      	mov	r9, r3
	u32 cb_Idx;
	struct UARTPINS uartpins;

	if ((uart_int_priority & 0xf) != 0) bsp_panic(-3); // Bogus priority
 80048dc:	d003      	beq.n	80048e6 <bsp_uart_int_init+0x1e>
 80048de:	f06f 0002 	mvn.w	r0, #2
 80048e2:	f7ff fc91 	bl	8004208 <bsp_panic>
	
	/* Map usart/uart register base to control block index & and enable APBxENR for USART/UART */
	cb_Idx = mapindex(iuart);	
 80048e6:	4620      	mov	r0, r4
 80048e8:	f7ff fc96 	bl	8004218 <mapindex>
		
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
 80048ec:	4b23      	ldr	r3, [pc, #140]	; (800497c <bsp_uart_int_init+0xb4>)
 80048ee:	0182      	lsls	r2, r0, #6
 80048f0:	1899      	adds	r1, r3, r2
	struct UARTPINS uartpins;

	if ((uart_int_priority & 0xf) != 0) bsp_panic(-3); // Bogus priority
	
	/* Map usart/uart register base to control block index & and enable APBxENR for USART/UART */
	cb_Idx = mapindex(iuart);	
 80048f2:	4607      	mov	r7, r0
		
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
	cb_uart[cb_Idx].flag = 1;	// Show this setup for interrupt driven
 80048f4:	2001      	movs	r0, #1
 80048f6:	6148      	str	r0, [r1, #20]
	if ((uart_int_priority & 0xf) != 0) bsp_panic(-3); // Bogus priority
	
	/* Map usart/uart register base to control block index & and enable APBxENR for USART/UART */
	cb_Idx = mapindex(iuart);	
		
	cb_uart[cb_Idx].iuart = iuart;	// Save uart register base address
 80048f8:	608c      	str	r4, [r1, #8]
	cb_uart[cb_Idx].flag = 1;	// Show this setup for interrupt driven

	/* Mapping adjusted file number to a control block pointer */
	cb_map[cb_Idx] = &cb_uart[cb_Idx];
 80048fa:	eb03 0187 	add.w	r1, r3, r7, lsl #2
 80048fe:	3304      	adds	r3, #4
 8004900:	189a      	adds	r2, r3, r2
 8004902:	f8c1 2208 	str.w	r2, [r1, #520]	; 0x208

	/* Set up UART pins, port & uart clockings.  THIS IS BOARD SPECIFIC */
	if (uart_pins(iuart, &uartpins) != 0) bsp_panic(-15);
 8004906:	4620      	mov	r0, r4
 8004908:	4669      	mov	r1, sp
 800490a:	f000 f8ab 	bl	8004a64 <uart_pins>
 800490e:	b118      	cbz	r0, 8004918 <bsp_uart_int_init+0x50>
 8004910:	f06f 000e 	mvn.w	r0, #14
 8004914:	f7ff fc78 	bl	8004208 <bsp_panic>

	/* Setup baud rate */
	usartx_setbaud (iuart, uartpins.pclk, baud);
 8004918:	4620      	mov	r0, r4
 800491a:	9900      	ldr	r1, [sp, #0]
 800491c:	4632      	mov	r2, r6
 800491e:	f000 f96b 	bl	8004bf8 <usartx_setbaud>

	/* Obtain some buffer space */
	getbuff(cb_Idx, rxbuffsize, txbuffsize);
 8004922:	4629      	mov	r1, r5
 8004924:	464a      	mov	r2, r9
 8004926:	4638      	mov	r0, r7
 8004928:	f7ff fccc 	bl	80042c4 <getbuff>
	/* Setup CR2 ------------------------------------------------------------------- */
	/* After reset CR2 is 0x0000 and this is just fine */

	/* Set up CR1 ---------------------------------------------------- */
	//                    UE       RXNEIE    TE       RE
	USART_CR1(iuart) |= (1<<13) | (1<<5) | (1<<3) | (1<<2);
 800492c:	68e3      	ldr	r3, [r4, #12]
 800492e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8004932:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
 8004936:	60e3      	str	r3, [r4, #12]

	/* UART interrupt */
	NVICIPR (uartpins.irqnumber, uart_int_priority);	// Set uart interrupt priority (tx)
 8004938:	9a01      	ldr	r2, [sp, #4]
 800493a:	f022 0303 	bic.w	r3, r2, #3
 800493e:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8004942:	f503 4364 	add.w	r3, r3, #58368	; 0xe400
 8004946:	f002 0203 	and.w	r2, r2, #3
 800494a:	00d2      	lsls	r2, r2, #3
 800494c:	fa08 f802 	lsl.w	r8, r8, r2
 8004950:	681a      	ldr	r2, [r3, #0]
 8004952:	ea42 0208 	orr.w	r2, r2, r8
 8004956:	601a      	str	r2, [r3, #0]
	NVICISER(uartpins.irqnumber);				// Enable interrupt
 8004958:	9a01      	ldr	r2, [sp, #4]
 800495a:	4b09      	ldr	r3, [pc, #36]	; (8004980 <bsp_uart_int_init+0xb8>)
 800495c:	0951      	lsrs	r1, r2, #5
 800495e:	18cb      	adds	r3, r1, r3
 8004960:	009b      	lsls	r3, r3, #2
 8004962:	2101      	movs	r1, #1
 8004964:	f002 021f 	and.w	r2, r2, #31
 8004968:	fa11 f202 	lsls.w	r2, r1, r2
 800496c:	6819      	ldr	r1, [r3, #0]
 800496e:	ea41 0202 	orr.w	r2, r1, r2
 8004972:	601a      	str	r2, [r3, #0]
	
	return 0;
}
 8004974:	2000      	movs	r0, #0
 8004976:	e8bd 83fe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, pc}
 800497a:	bf00      	nop
 800497c:	200008cc 	.word	0x200008cc
 8004980:	38003840 	.word	0x38003840

08004984 <bsp_uart_int_init_number>:
 * int bsp_uart_int_init_number(u32 uartnumber, u32 baud,u32 rxbuffsize, u32 txbuffsize, u32 dma_tx_int_priority);
 * @brief	: A wrapper for 'int bsp_uart_int_init' with uart number (1-6) rather than uart base address as the first argument
 * @return	: Same as bsp_uart_int_init
*******************************************************************************/
int bsp_uart_int_init_number(u32 uartnumber, u32 baud, u32 rxbuffsize, u32 txbuffsize,  u32 uart_int_priority)
{
 8004984:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004988:	9f06      	ldr	r7, [sp, #24]
 800498a:	460e      	mov	r6, r1
 800498c:	4615      	mov	r5, r2
 800498e:	461c      	mov	r4, r3
	u32 iuart = uartnumber_to_baseaddr(uartnumber);
 8004990:	f7ff fcc4 	bl	800431c <uartnumber_to_baseaddr>
	return  bsp_uart_int_init(iuart, baud, rxbuffsize, txbuffsize, uart_int_priority);
 8004994:	4631      	mov	r1, r6
 8004996:	462a      	mov	r2, r5
 8004998:	4623      	mov	r3, r4
 800499a:	9706      	str	r7, [sp, #24]
}
 800499c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 * @return	: Same as bsp_uart_int_init
*******************************************************************************/
int bsp_uart_int_init_number(u32 uartnumber, u32 baud, u32 rxbuffsize, u32 txbuffsize,  u32 uart_int_priority)
{
	u32 iuart = uartnumber_to_baseaddr(uartnumber);
	return  bsp_uart_int_init(iuart, baud, rxbuffsize, txbuffsize, uart_int_priority);
 80049a0:	e792      	b.n	80048c8 <bsp_uart_int_init>

080049a2 <UART_IRQHandler>:
void  UART8_IRQHandler(void) {UART_IRQHandler(&cb_uart[7]); return;}

void UART_IRQHandler(struct CB_UART* pctl)
{
	/* Receive */
	if ((USART_SR(pctl->iuart) & USART_SR_RXNE) != 0) // Receive reg loaded?
 80049a2:	6843      	ldr	r3, [r0, #4]
 80049a4:	681b      	ldr	r3, [r3, #0]
 80049a6:	f013 0f20 	tst.w	r3, #32
void USART6_IRQHandler(void) {UART_IRQHandler(&cb_uart[5]); return;}
void  UART7_IRQHandler(void) {UART_IRQHandler(&cb_uart[6]); return;}
void  UART8_IRQHandler(void) {UART_IRQHandler(&cb_uart[7]); return;}

void UART_IRQHandler(struct CB_UART* pctl)
{
 80049aa:	b510      	push	{r4, lr}
 80049ac:	4604      	mov	r4, r0
	/* Receive */
	if ((USART_SR(pctl->iuart) & USART_SR_RXNE) != 0) // Receive reg loaded?
 80049ae:	d007      	beq.n	80049c0 <UART_IRQHandler+0x1e>
	{  // Here, receive interrupt flag is on. 
		*pctl->rxbuff_in = USART_DR(pctl->iuart);// Read and store char
 80049b0:	6843      	ldr	r3, [r0, #4]
 80049b2:	685a      	ldr	r2, [r3, #4]
 80049b4:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80049b6:	701a      	strb	r2, [r3, #0]

		/* Advance pointers to line buffers and array of counts and reset when end reached */	
		pctl->rxbuff_in = rxbuff_adv(pctl, pctl->rxbuff_in);	// Advance pointers common routine
 80049b8:	6b81      	ldr	r1, [r0, #56]	; 0x38
 80049ba:	f7ff fbd5 	bl	8004168 <rxbuff_adv>
 80049be:	63a0      	str	r0, [r4, #56]	; 0x38
	}

	/* Transmit */
	if ( (USART_CR1(pctl->iuart) & USART_CR1_TXEIE) != 0)
 80049c0:	6863      	ldr	r3, [r4, #4]
 80049c2:	68db      	ldr	r3, [r3, #12]
 80049c4:	f013 0f80 	tst.w	r3, #128	; 0x80
 80049c8:	d014      	beq.n	80049f4 <UART_IRQHandler+0x52>
	{  // Here, yes.  Transmit interrupts are enabled so check if a tx interrupt
		if ( (USART_SR(pctl->iuart) & USART_SR_TXE) != 0) // Transmit register empty?
 80049ca:	6863      	ldr	r3, [r4, #4]
 80049cc:	681b      	ldr	r3, [r3, #0]
 80049ce:	f013 0f80 	tst.w	r3, #128	; 0x80
 80049d2:	d00f      	beq.n	80049f4 <UART_IRQHandler+0x52>
		{ // Here, yes.
			USART_DR(pctl->iuart) = *pctl->txbuff_out;// Send next char, step pointer
 80049d4:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80049d6:	6863      	ldr	r3, [r4, #4]
 80049d8:	780a      	ldrb	r2, [r1, #0]

			/* Advance output pointer */
			pctl->txbuff_out = txbuff_adv(pctl, pctl->txbuff_out);
 80049da:	4620      	mov	r0, r4
	/* Transmit */
	if ( (USART_CR1(pctl->iuart) & USART_CR1_TXEIE) != 0)
	{  // Here, yes.  Transmit interrupts are enabled so check if a tx interrupt
		if ( (USART_SR(pctl->iuart) & USART_SR_TXE) != 0) // Transmit register empty?
		{ // Here, yes.
			USART_DR(pctl->iuart) = *pctl->txbuff_out;// Send next char, step pointer
 80049dc:	605a      	str	r2, [r3, #4]

			/* Advance output pointer */
			pctl->txbuff_out = txbuff_adv(pctl, pctl->txbuff_out);
 80049de:	f7ff fbca 	bl	8004176 <txbuff_adv>

			/* Was the last byte loaded the last to send? */		
			if (pctl->txbuff_out == pctl->txbuff_in)
 80049e2:	6a23      	ldr	r3, [r4, #32]
		if ( (USART_SR(pctl->iuart) & USART_SR_TXE) != 0) // Transmit register empty?
		{ // Here, yes.
			USART_DR(pctl->iuart) = *pctl->txbuff_out;// Send next char, step pointer

			/* Advance output pointer */
			pctl->txbuff_out = txbuff_adv(pctl, pctl->txbuff_out);
 80049e4:	6260      	str	r0, [r4, #36]	; 0x24

			/* Was the last byte loaded the last to send? */		
			if (pctl->txbuff_out == pctl->txbuff_in)
 80049e6:	4298      	cmp	r0, r3
 80049e8:	d104      	bne.n	80049f4 <UART_IRQHandler+0x52>
			{ // Here yes. 
				USART_CR1(pctl->iuart) &= ~USART_CR1_TXEIE;		// Disable Tx interrupt	
 80049ea:	6863      	ldr	r3, [r4, #4]
 80049ec:	68da      	ldr	r2, [r3, #12]
 80049ee:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80049f2:	60da      	str	r2, [r3, #12]
 80049f4:	bd10      	pop	{r4, pc}

080049f6 <UART8_IRQHandler>:
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
void  UART5_IRQHandler(void) {UART_IRQHandler(&cb_uart[4]); return;}
void USART6_IRQHandler(void) {UART_IRQHandler(&cb_uart[5]); return;}
void  UART7_IRQHandler(void) {UART_IRQHandler(&cb_uart[6]); return;}
void  UART8_IRQHandler(void) {UART_IRQHandler(&cb_uart[7]); return;}
 80049f6:	4801      	ldr	r0, [pc, #4]	; (80049fc <UART8_IRQHandler+0x6>)
 80049f8:	e7d3      	b.n	80049a2 <UART_IRQHandler>
 80049fa:	bf00      	nop
 80049fc:	20000a90 	.word	0x20000a90

08004a00 <UART7_IRQHandler>:
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
void  UART5_IRQHandler(void) {UART_IRQHandler(&cb_uart[4]); return;}
void USART6_IRQHandler(void) {UART_IRQHandler(&cb_uart[5]); return;}
void  UART7_IRQHandler(void) {UART_IRQHandler(&cb_uart[6]); return;}
 8004a00:	4800      	ldr	r0, [pc, #0]	; (8004a04 <UART7_IRQHandler+0x4>)
 8004a02:	e7ce      	b.n	80049a2 <UART_IRQHandler>
 8004a04:	20000a50 	.word	0x20000a50

08004a08 <USART6_IRQHandler>:
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
void  UART5_IRQHandler(void) {UART_IRQHandler(&cb_uart[4]); return;}
void USART6_IRQHandler(void) {UART_IRQHandler(&cb_uart[5]); return;}
 8004a08:	4800      	ldr	r0, [pc, #0]	; (8004a0c <USART6_IRQHandler+0x4>)
 8004a0a:	e7ca      	b.n	80049a2 <UART_IRQHandler>
 8004a0c:	20000a10 	.word	0x20000a10

08004a10 <UART5_IRQHandler>:
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
void  UART5_IRQHandler(void) {UART_IRQHandler(&cb_uart[4]); return;}
 8004a10:	4800      	ldr	r0, [pc, #0]	; (8004a14 <UART5_IRQHandler+0x4>)
 8004a12:	e7c6      	b.n	80049a2 <UART_IRQHandler>
 8004a14:	200009d0 	.word	0x200009d0

08004a18 <UART4_IRQHandler>:
/* USART/UART interrupts use a common IRQ handler.  Pass the control block pointer. */
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
void  UART4_IRQHandler(void) {UART_IRQHandler(&cb_uart[3]); return;}
 8004a18:	4800      	ldr	r0, [pc, #0]	; (8004a1c <UART4_IRQHandler+0x4>)
 8004a1a:	e7c2      	b.n	80049a2 <UART_IRQHandler>
 8004a1c:	20000990 	.word	0x20000990

08004a20 <USART3_IRQHandler>:
 *####################################################################################### */
/* USART/UART interrupts use a common IRQ handler.  Pass the control block pointer. */
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
void USART3_IRQHandler(void) {UART_IRQHandler(&cb_uart[2]); return;}
 8004a20:	4800      	ldr	r0, [pc, #0]	; (8004a24 <USART3_IRQHandler+0x4>)
 8004a22:	e7be      	b.n	80049a2 <UART_IRQHandler>
 8004a24:	20000950 	.word	0x20000950

08004a28 <USART2_IRQHandler>:
 * ISR routine
 *####################################################################################### */
/* USART/UART interrupts use a common IRQ handler.  Pass the control block pointer. */
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
void USART2_IRQHandler(void) {UART_IRQHandler(&cb_uart[1]); return;}
 8004a28:	4800      	ldr	r0, [pc, #0]	; (8004a2c <USART2_IRQHandler+0x4>)
 8004a2a:	e7ba      	b.n	80049a2 <UART_IRQHandler>
 8004a2c:	20000910 	.word	0x20000910

08004a30 <USART1_IRQHandler>:
/*#######################################################################################
 * ISR routine
 *####################################################################################### */
/* USART/UART interrupts use a common IRQ handler.  Pass the control block pointer. */
void UART_IRQHandler(struct CB_UART* pctl);	// Prototype
void USART1_IRQHandler(void) {UART_IRQHandler(&cb_uart[0]); return;}
 8004a30:	4800      	ldr	r0, [pc, #0]	; (8004a34 <USART1_IRQHandler+0x4>)
 8004a32:	e7b6      	b.n	80049a2 <UART_IRQHandler>
 8004a34:	200008d0 	.word	0x200008d0

08004a38 <xprintf>:
#include <stdarg.h>
#include <stdio.h>
#include "bsp_uart.h"

int xprintf(int uartnumber, const char *fmt, ...)
{
 8004a38:	b40e      	push	{r1, r2, r3}
 8004a3a:	b530      	push	{r4, r5, lr}
 8004a3c:	b0c2      	sub	sp, #264	; 0x108
 8004a3e:	aa45      	add	r2, sp, #276	; 0x114
 8004a40:	4604      	mov	r4, r0
 8004a42:	f852 1b04 	ldr.w	r1, [r2], #4
	va_list argp;
	char vv[256];\
	int r;
	va_start(argp, fmt);
	va_start(argp, fmt);
	r = vsprintf(vv, fmt, argp);
 8004a46:	a801      	add	r0, sp, #4
{
	va_list argp;
	char vv[256];\
	int r;
	va_start(argp, fmt);
	va_start(argp, fmt);
 8004a48:	9241      	str	r2, [sp, #260]	; 0x104
	r = vsprintf(vv, fmt, argp);
 8004a4a:	f000 fda1 	bl	8005590 <vsprintf>
	va_end(argp);
	bsp_uart_puts_uartnum(uartnumber,vv);
 8004a4e:	a901      	add	r1, sp, #4
	va_list argp;
	char vv[256];\
	int r;
	va_start(argp, fmt);
	va_start(argp, fmt);
	r = vsprintf(vv, fmt, argp);
 8004a50:	4605      	mov	r5, r0
	va_end(argp);
	bsp_uart_puts_uartnum(uartnumber,vv);
 8004a52:	4620      	mov	r0, r4
 8004a54:	f7ff ff0b 	bl	800486e <bsp_uart_puts_uartnum>
	return r;
}
 8004a58:	4628      	mov	r0, r5
 8004a5a:	b042      	add	sp, #264	; 0x108
 8004a5c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8004a60:	b003      	add	sp, #12
 8004a62:	4770      	bx	lr

08004a64 <uart_pins>:
 * @param	: p = pointer to register base
 * @param	: pu = pointer to struct with return values
 * @return	: Edit check--0 = OK; not OK - panic_leds(8)
******************************************************************************/	
int uart_pins(u32 iuart, struct UARTPINS* pu)
{
 8004a64:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

	struct PINCONFIG	pin_uarttx = { \
 8004a66:	4a56      	ldr	r2, [pc, #344]	; (8004bc0 <uart_pins+0x15c>)
 * @param	: p = pointer to register base
 * @param	: pu = pointer to struct with return values
 * @return	: Edit check--0 = OK; not OK - panic_leds(8)
******************************************************************************/	
int uart_pins(u32 iuart, struct UARTPINS* pu)
{
 8004a68:	4603      	mov	r3, r0

	struct PINCONFIG	pin_uarttx = { \
 8004a6a:	6810      	ldr	r0, [r2, #0]
 8004a6c:	9002      	str	r0, [sp, #8]
 8004a6e:	7910      	ldrb	r0, [r2, #4]
 8004a70:	f88d 000c 	strb.w	r0, [sp, #12]
		GPIO_OTYPE_PP, 		// output type: push-pull 		
		GPIO_OSPEED_100MHZ, 	// speed: highest drive level
		GPIO_PUPD_NONE, 	// pull up/down: none
		0 };			// Alternate function code: to be filled in

	struct PINCONFIG	pin_uartrx = { \
 8004a74:	f852 0f05 	ldr.w	r0, [r2, #5]!
 8004a78:	7912      	ldrb	r2, [r2, #4]
 8004a7a:	9000      	str	r0, [sp, #0]
 8004a7c:	f88d 2004 	strb.w	r2, [sp, #4]
	u32	txport;
	u32	rxport;

	/* THIS IS BOARD SPECIFIC */
	// Set ports, pins, alternate function code, bus clock freq, and enable peripheral clock
	switch (iuart)
 8004a80:	4a50      	ldr	r2, [pc, #320]	; (8004bc4 <uart_pins+0x160>)
 8004a82:	4293      	cmp	r3, r2
 8004a84:	d04f      	beq.n	8004b26 <uart_pins+0xc2>
 8004a86:	d807      	bhi.n	8004a98 <uart_pins+0x34>
 8004a88:	4a4f      	ldr	r2, [pc, #316]	; (8004bc8 <uart_pins+0x164>)
 8004a8a:	4293      	cmp	r3, r2
 8004a8c:	d023      	beq.n	8004ad6 <uart_pins+0x72>
 8004a8e:	4a4f      	ldr	r2, [pc, #316]	; (8004bcc <uart_pins+0x168>)
 8004a90:	4293      	cmp	r3, r2
 8004a92:	f040 8091 	bne.w	8004bb8 <uart_pins+0x154>
 8004a96:	e032      	b.n	8004afe <uart_pins+0x9a>
 8004a98:	4a4d      	ldr	r2, [pc, #308]	; (8004bd0 <uart_pins+0x16c>)
 8004a9a:	4293      	cmp	r3, r2
 8004a9c:	d007      	beq.n	8004aae <uart_pins+0x4a>
 8004a9e:	4a4d      	ldr	r2, [pc, #308]	; (8004bd4 <uart_pins+0x170>)
 8004aa0:	4293      	cmp	r3, r2
 8004aa2:	d068      	beq.n	8004b76 <uart_pins+0x112>
 8004aa4:	4a4c      	ldr	r2, [pc, #304]	; (8004bd8 <uart_pins+0x174>)
 8004aa6:	4293      	cmp	r3, r2
 8004aa8:	f040 8086 	bne.w	8004bb8 <uart_pins+0x154>
 8004aac:	e04f      	b.n	8004b4e <uart_pins+0xea>
	{
		case USART1:
			rxport = GPIOA; txport = GPIOA; txpin = 9; rxpin = 10; af = 7; pu->pclk = pclk2_freq;
 8004aae:	4b4b      	ldr	r3, [pc, #300]	; (8004bdc <uart_pins+0x178>)
 8004ab0:	4c4b      	ldr	r4, [pc, #300]	; (8004be0 <uart_pins+0x17c>)
 8004ab2:	681b      	ldr	r3, [r3, #0]
 8004ab4:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x01;	// Port A
 8004ab6:	4b4b      	ldr	r3, [pc, #300]	; (8004be4 <uart_pins+0x180>)
 8004ab8:	681a      	ldr	r2, [r3, #0]
 8004aba:	f042 0201 	orr.w	r2, r2, #1
 8004abe:	601a      	str	r2, [r3, #0]
//			rxport = GPIOB; txport = GPIOB; txpin = 6; rxpin =  7; af = 7; pu->pclk = pclk2_freq;
//			RCC_AHB1ENR |= 0x02;	// Port B
			RCC_APB2ENR |= (1<<4); // Enable peripheral clock
 8004ac0:	695a      	ldr	r2, [r3, #20]
 8004ac2:	f042 0210 	orr.w	r2, r2, #16
 8004ac6:	615a      	str	r2, [r3, #20]
			pu->irqnumber = UART1_IRQ_NUMBER;
 8004ac8:	2325      	movs	r3, #37	; 0x25
 8004aca:	604b      	str	r3, [r1, #4]
	/* THIS IS BOARD SPECIFIC */
	// Set ports, pins, alternate function code, bus clock freq, and enable peripheral clock
	switch (iuart)
	{
		case USART1:
			rxport = GPIOA; txport = GPIOA; txpin = 9; rxpin = 10; af = 7; pu->pclk = pclk2_freq;
 8004acc:	4620      	mov	r0, r4
 8004ace:	2607      	movs	r6, #7
 8004ad0:	2109      	movs	r1, #9
 8004ad2:	250a      	movs	r5, #10
			RCC_AHB1ENR |= 0x01;	// Port A
//			rxport = GPIOB; txport = GPIOB; txpin = 6; rxpin =  7; af = 7; pu->pclk = pclk2_freq;
//			RCC_AHB1ENR |= 0x02;	// Port B
			RCC_APB2ENR |= (1<<4); // Enable peripheral clock
			pu->irqnumber = UART1_IRQ_NUMBER;
			break;
 8004ad4:	e062      	b.n	8004b9c <uart_pins+0x138>

		case (u32)USART2:
			rxport = GPIOA; txport = GPIOA; txpin = 2; rxpin =  3; af = 7; pu->pclk = pclk1_freq;
 8004ad6:	4b44      	ldr	r3, [pc, #272]	; (8004be8 <uart_pins+0x184>)
 8004ad8:	4c41      	ldr	r4, [pc, #260]	; (8004be0 <uart_pins+0x17c>)
 8004ada:	681b      	ldr	r3, [r3, #0]
 8004adc:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x01;	// Port A
 8004ade:	4b41      	ldr	r3, [pc, #260]	; (8004be4 <uart_pins+0x180>)
 8004ae0:	681a      	ldr	r2, [r3, #0]
 8004ae2:	f042 0201 	orr.w	r2, r2, #1
 8004ae6:	601a      	str	r2, [r3, #0]
//			rxport = GPIOD; txport = GPIOD; txpin = 5; rxpin =  6; af = 7; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x08;	// Port D
			RCC_APB1ENR |= (1<<17); // Enable peripheral clock
 8004ae8:	691a      	ldr	r2, [r3, #16]
 8004aea:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8004aee:	611a      	str	r2, [r3, #16]
			pu->irqnumber = UART2_IRQ_NUMBER;
 8004af0:	2326      	movs	r3, #38	; 0x26
 8004af2:	604b      	str	r3, [r1, #4]
			RCC_APB2ENR |= (1<<4); // Enable peripheral clock
			pu->irqnumber = UART1_IRQ_NUMBER;
			break;

		case (u32)USART2:
			rxport = GPIOA; txport = GPIOA; txpin = 2; rxpin =  3; af = 7; pu->pclk = pclk1_freq;
 8004af4:	4620      	mov	r0, r4
 8004af6:	2607      	movs	r6, #7
 8004af8:	2102      	movs	r1, #2
 8004afa:	2503      	movs	r5, #3
			RCC_AHB1ENR |= 0x01;	// Port A
//			rxport = GPIOD; txport = GPIOD; txpin = 5; rxpin =  6; af = 7; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x08;	// Port D
			RCC_APB1ENR |= (1<<17); // Enable peripheral clock
			pu->irqnumber = UART2_IRQ_NUMBER;
			break;
 8004afc:	e04e      	b.n	8004b9c <uart_pins+0x138>
			
		case (u32)USART3:
			rxport = GPIOB; txport = GPIOB; txpin = 10; rxpin = 11; af = 7; pu->pclk = pclk1_freq;
 8004afe:	4b3a      	ldr	r3, [pc, #232]	; (8004be8 <uart_pins+0x184>)
 8004b00:	4c3a      	ldr	r4, [pc, #232]	; (8004bec <uart_pins+0x188>)
 8004b02:	681b      	ldr	r3, [r3, #0]
 8004b04:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x02;	// Port B
 8004b06:	4b37      	ldr	r3, [pc, #220]	; (8004be4 <uart_pins+0x180>)
 8004b08:	681a      	ldr	r2, [r3, #0]
 8004b0a:	f042 0202 	orr.w	r2, r2, #2
 8004b0e:	601a      	str	r2, [r3, #0]
//			rxport = GPIOD; txport = GPIOD; txpin =  8; rxpin =  9; af = 7; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x08;	// Port D
			RCC_APB1ENR |= (1<<18); // Enable peripheral clock
 8004b10:	691a      	ldr	r2, [r3, #16]
 8004b12:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8004b16:	611a      	str	r2, [r3, #16]
			pu->irqnumber = UART3_IRQ_NUMBER;
 8004b18:	2327      	movs	r3, #39	; 0x27
 8004b1a:	604b      	str	r3, [r1, #4]
			RCC_APB1ENR |= (1<<17); // Enable peripheral clock
			pu->irqnumber = UART2_IRQ_NUMBER;
			break;
			
		case (u32)USART3:
			rxport = GPIOB; txport = GPIOB; txpin = 10; rxpin = 11; af = 7; pu->pclk = pclk1_freq;
 8004b1c:	4620      	mov	r0, r4
 8004b1e:	2607      	movs	r6, #7
 8004b20:	210a      	movs	r1, #10
 8004b22:	250b      	movs	r5, #11
			RCC_AHB1ENR |= 0x02;	// Port B
//			rxport = GPIOD; txport = GPIOD; txpin =  8; rxpin =  9; af = 7; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x08;	// Port D
			RCC_APB1ENR |= (1<<18); // Enable peripheral clock
			pu->irqnumber = UART3_IRQ_NUMBER;
			break;
 8004b24:	e03a      	b.n	8004b9c <uart_pins+0x138>

		case (u32)UART4:
			rxport = GPIOA; txport = GPIOA; txpin =  0; rxpin =  1; af = 8; pu->pclk = pclk1_freq;
 8004b26:	4b30      	ldr	r3, [pc, #192]	; (8004be8 <uart_pins+0x184>)
 8004b28:	4c2d      	ldr	r4, [pc, #180]	; (8004be0 <uart_pins+0x17c>)
 8004b2a:	681b      	ldr	r3, [r3, #0]
 8004b2c:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x01;	// Port A
 8004b2e:	4b2d      	ldr	r3, [pc, #180]	; (8004be4 <uart_pins+0x180>)
 8004b30:	681a      	ldr	r2, [r3, #0]
 8004b32:	f042 0201 	orr.w	r2, r2, #1
 8004b36:	601a      	str	r2, [r3, #0]
//			rxport = GPIOC; txport = GPIOC; txpin = 10; rxpin = 11; af = 8; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x04;	// Port C
			RCC_APB1ENR |= (1<<19); // Enable peripheral clock
 8004b38:	691a      	ldr	r2, [r3, #16]
 8004b3a:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8004b3e:	611a      	str	r2, [r3, #16]
			pu->irqnumber = UART4_IRQ_NUMBER;
 8004b40:	2334      	movs	r3, #52	; 0x34
 8004b42:	604b      	str	r3, [r1, #4]
			RCC_APB1ENR |= (1<<18); // Enable peripheral clock
			pu->irqnumber = UART3_IRQ_NUMBER;
			break;

		case (u32)UART4:
			rxport = GPIOA; txport = GPIOA; txpin =  0; rxpin =  1; af = 8; pu->pclk = pclk1_freq;
 8004b44:	4620      	mov	r0, r4
 8004b46:	2608      	movs	r6, #8
 8004b48:	2100      	movs	r1, #0
 8004b4a:	2501      	movs	r5, #1
			RCC_AHB1ENR |= 0x01;	// Port A
//			rxport = GPIOC; txport = GPIOC; txpin = 10; rxpin = 11; af = 8; pu->pclk = pclk1_freq;
//			RCC_AHB1ENR |= 0x04;	// Port C
			RCC_APB1ENR |= (1<<19); // Enable peripheral clock
			pu->irqnumber = UART4_IRQ_NUMBER;
			break;
 8004b4c:	e026      	b.n	8004b9c <uart_pins+0x138>

		case (u32)UART5:
			txport = GPIOC; rxport = GPIOD; txpin = 12; rxpin =  2; af = 8; pu->pclk = pclk1_freq;
 8004b4e:	4b26      	ldr	r3, [pc, #152]	; (8004be8 <uart_pins+0x184>)
 8004b50:	4c27      	ldr	r4, [pc, #156]	; (8004bf0 <uart_pins+0x18c>)
 8004b52:	681b      	ldr	r3, [r3, #0]
 8004b54:	4827      	ldr	r0, [pc, #156]	; (8004bf4 <uart_pins+0x190>)
 8004b56:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x06;	// Port C & D
 8004b58:	4b22      	ldr	r3, [pc, #136]	; (8004be4 <uart_pins+0x180>)
 8004b5a:	681a      	ldr	r2, [r3, #0]
 8004b5c:	f042 0206 	orr.w	r2, r2, #6
 8004b60:	601a      	str	r2, [r3, #0]
			RCC_APB1ENR |= (1<<20); // Enable peripheral clock
 8004b62:	691a      	ldr	r2, [r3, #16]
 8004b64:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8004b68:	611a      	str	r2, [r3, #16]
			pu->irqnumber = UART5_IRQ_NUMBER;
 8004b6a:	2335      	movs	r3, #53	; 0x35
 8004b6c:	604b      	str	r3, [r1, #4]
			RCC_APB1ENR |= (1<<19); // Enable peripheral clock
			pu->irqnumber = UART4_IRQ_NUMBER;
			break;

		case (u32)UART5:
			txport = GPIOC; rxport = GPIOD; txpin = 12; rxpin =  2; af = 8; pu->pclk = pclk1_freq;
 8004b6e:	2608      	movs	r6, #8
 8004b70:	210c      	movs	r1, #12
 8004b72:	2502      	movs	r5, #2
			RCC_AHB1ENR |= 0x06;	// Port C & D
			RCC_APB1ENR |= (1<<20); // Enable peripheral clock
			pu->irqnumber = UART5_IRQ_NUMBER;
			break;
 8004b74:	e012      	b.n	8004b9c <uart_pins+0x138>

		case (u32)USART6:
			txport = GPIOC; rxport = GPIOC; txpin =  6; rxpin =  7; af = 8; pu->pclk = pclk2_freq;
 8004b76:	4b19      	ldr	r3, [pc, #100]	; (8004bdc <uart_pins+0x178>)
 8004b78:	4c1e      	ldr	r4, [pc, #120]	; (8004bf4 <uart_pins+0x190>)
 8004b7a:	681b      	ldr	r3, [r3, #0]
 8004b7c:	600b      	str	r3, [r1, #0]
			RCC_AHB1ENR |= 0x04;	// Port C
 8004b7e:	4b19      	ldr	r3, [pc, #100]	; (8004be4 <uart_pins+0x180>)
 8004b80:	681a      	ldr	r2, [r3, #0]
 8004b82:	f042 0204 	orr.w	r2, r2, #4
 8004b86:	601a      	str	r2, [r3, #0]
			RCC_APB2ENR |= (1<<5); 	// Enable peripheral clock
 8004b88:	695a      	ldr	r2, [r3, #20]
 8004b8a:	f042 0220 	orr.w	r2, r2, #32
 8004b8e:	615a      	str	r2, [r3, #20]
			pu->irqnumber = UART6_IRQ_NUMBER;			
 8004b90:	2347      	movs	r3, #71	; 0x47
 8004b92:	604b      	str	r3, [r1, #4]
			RCC_APB1ENR |= (1<<20); // Enable peripheral clock
			pu->irqnumber = UART5_IRQ_NUMBER;
			break;

		case (u32)USART6:
			txport = GPIOC; rxport = GPIOC; txpin =  6; rxpin =  7; af = 8; pu->pclk = pclk2_freq;
 8004b94:	4620      	mov	r0, r4
 8004b96:	2608      	movs	r6, #8
 8004b98:	2106      	movs	r1, #6
 8004b9a:	2507      	movs	r5, #7
			return -1;	// Pin assignments: Shouldn't happen
	}

	/* Configure tx pin */
	pin_uarttx.afrl = af;
	f4gpiopins_Config ((volatile u32*)txport, txpin, (struct PINCONFIG*)&pin_uarttx);
 8004b9c:	aa02      	add	r2, sp, #8
		default:
			return -1;	// Pin assignments: Shouldn't happen
	}

	/* Configure tx pin */
	pin_uarttx.afrl = af;
 8004b9e:	f88d 600c 	strb.w	r6, [sp, #12]
	f4gpiopins_Config ((volatile u32*)txport, txpin, (struct PINCONFIG*)&pin_uarttx);
 8004ba2:	f7fe ff62 	bl	8003a6a <f4gpiopins_Config>

	/* Configure rx pin */
	pin_uartrx.afrl = af;
	f4gpiopins_Config ((volatile u32*)rxport, rxpin, (struct PINCONFIG*)&pin_uartrx);
 8004ba6:	4620      	mov	r0, r4
 8004ba8:	4629      	mov	r1, r5
 8004baa:	466a      	mov	r2, sp
	/* Configure tx pin */
	pin_uarttx.afrl = af;
	f4gpiopins_Config ((volatile u32*)txport, txpin, (struct PINCONFIG*)&pin_uarttx);

	/* Configure rx pin */
	pin_uartrx.afrl = af;
 8004bac:	f88d 6004 	strb.w	r6, [sp, #4]
	f4gpiopins_Config ((volatile u32*)rxport, rxpin, (struct PINCONFIG*)&pin_uartrx);
 8004bb0:	f7fe ff5b 	bl	8003a6a <f4gpiopins_Config>

	return 0;
 8004bb4:	2000      	movs	r0, #0
 8004bb6:	e001      	b.n	8004bbc <uart_pins+0x158>
			RCC_APB2ENR |= (1<<5); 	// Enable peripheral clock
			pu->irqnumber = UART6_IRQ_NUMBER;			
			break;

		default:
			return -1;	// Pin assignments: Shouldn't happen
 8004bb8:	f04f 30ff 	mov.w	r0, #4294967295
	/* Configure rx pin */
	pin_uartrx.afrl = af;
	f4gpiopins_Config ((volatile u32*)rxport, rxpin, (struct PINCONFIG*)&pin_uartrx);

	return 0;
}
 8004bbc:	b004      	add	sp, #16
 8004bbe:	bd70      	pop	{r4, r5, r6, pc}
 8004bc0:	0800b75c 	.word	0x0800b75c
 8004bc4:	40004c00 	.word	0x40004c00
 8004bc8:	40004400 	.word	0x40004400
 8004bcc:	40004800 	.word	0x40004800
 8004bd0:	40011000 	.word	0x40011000
 8004bd4:	40011400 	.word	0x40011400
 8004bd8:	40005000 	.word	0x40005000
 8004bdc:	2000083c 	.word	0x2000083c
 8004be0:	40020000 	.word	0x40020000
 8004be4:	40023830 	.word	0x40023830
 8004be8:	20000838 	.word	0x20000838
 8004bec:	40020400 	.word	0x40020400
 8004bf0:	40020c00 	.word	0x40020c00
 8004bf4:	40020800 	.word	0x40020800

08004bf8 <usartx_setbaud>:
	u32 tmpreg = 0x00;
	u32 fractionaldivider = 0x00;
	u32 integerdivider = 0x00;

	/* Determine the integer part */
	integerdivider = ((0x19 * pclk_freq) / (0x04 * u32BaudRate));
 8004bf8:	2319      	movs	r3, #25
 8004bfa:	434b      	muls	r3, r1
 8004bfc:	0092      	lsls	r2, r2, #2
 8004bfe:	fbb3 f3f2 	udiv	r3, r3, r2
	tmpreg = (integerdivider / 0x64) << 0x04;
 8004c02:	2164      	movs	r1, #100	; 0x64
 * void usartx_setbaud (u32 usartx, u32 pclk_freq, u32 u32BaudRate);
 * @brief	: set baudrate register (BRR)
 * @param	: u32BaudRate is the baud rate.
******************************************************************************/
void usartx_setbaud (u32 usartx, u32 pclk_freq, u32 u32BaudRate)
{
 8004c04:	b510      	push	{r4, lr}
	u32 fractionaldivider = 0x00;
	u32 integerdivider = 0x00;

	/* Determine the integer part */
	integerdivider = ((0x19 * pclk_freq) / (0x04 * u32BaudRate));
	tmpreg = (integerdivider / 0x64) << 0x04;
 8004c06:	fbb3 f4f1 	udiv	r4, r3, r1
 8004c0a:	0124      	lsls	r4, r4, #4

	/* Determine the fractional part */
	fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
 8004c0c:	0922      	lsrs	r2, r4, #4
 8004c0e:	fb01 3312 	mls	r3, r1, r2, r3
	tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((u8)0x0F);
 8004c12:	011b      	lsls	r3, r3, #4
 8004c14:	3332      	adds	r3, #50	; 0x32
 8004c16:	fbb3 f1f1 	udiv	r1, r3, r1
 8004c1a:	f001 010f 	and.w	r1, r1, #15
 8004c1e:	ea41 0404 	orr.w	r4, r1, r4

	/* Set USART BRR --------------------------------------------------------------- */
	  USART_BRR(usartx) = (u16)tmpreg;
 8004c22:	b2a4      	uxth	r4, r4
 8004c24:	6084      	str	r4, [r0, #8]
	return;
}
 8004c26:	bd10      	pop	{r4, pc}

08004c28 <__libc_init_array>:
 8004c28:	b570      	push	{r4, r5, r6, lr}
 8004c2a:	f64b 36a4 	movw	r6, #48036	; 0xbba4
 8004c2e:	f64b 35a4 	movw	r5, #48036	; 0xbba4
 8004c32:	f6c0 0600 	movt	r6, #2048	; 0x800
 8004c36:	f6c0 0500 	movt	r5, #2048	; 0x800
 8004c3a:	1b76      	subs	r6, r6, r5
 8004c3c:	10b6      	asrs	r6, r6, #2
 8004c3e:	d006      	beq.n	8004c4e <__libc_init_array+0x26>
 8004c40:	2400      	movs	r4, #0
 8004c42:	f855 3b04 	ldr.w	r3, [r5], #4
 8004c46:	3401      	adds	r4, #1
 8004c48:	4798      	blx	r3
 8004c4a:	42a6      	cmp	r6, r4
 8004c4c:	d1f9      	bne.n	8004c42 <__libc_init_array+0x1a>
 8004c4e:	f64b 36a4 	movw	r6, #48036	; 0xbba4
 8004c52:	f64b 35a4 	movw	r5, #48036	; 0xbba4
 8004c56:	f6c0 0600 	movt	r6, #2048	; 0x800
 8004c5a:	f6c0 0500 	movt	r5, #2048	; 0x800
 8004c5e:	1b76      	subs	r6, r6, r5
 8004c60:	f7fc f909 	bl	8000e76 <_init>
 8004c64:	10b6      	asrs	r6, r6, #2
 8004c66:	d006      	beq.n	8004c76 <__libc_init_array+0x4e>
 8004c68:	2400      	movs	r4, #0
 8004c6a:	f855 3b04 	ldr.w	r3, [r5], #4
 8004c6e:	3401      	adds	r4, #1
 8004c70:	4798      	blx	r3
 8004c72:	42a6      	cmp	r6, r4
 8004c74:	d1f9      	bne.n	8004c6a <__libc_init_array+0x42>
 8004c76:	bd70      	pop	{r4, r5, r6, pc}

08004c78 <malloc>:
 8004c78:	f240 236c 	movw	r3, #620	; 0x26c
 8004c7c:	4601      	mov	r1, r0
 8004c7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c82:	6818      	ldr	r0, [r3, #0]
 8004c84:	f000 b808 	b.w	8004c98 <_malloc_r>

08004c88 <free>:
 8004c88:	f240 236c 	movw	r3, #620	; 0x26c
 8004c8c:	4601      	mov	r1, r0
 8004c8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c92:	6818      	ldr	r0, [r3, #0]
 8004c94:	f000 bee2 	b.w	8005a5c <_free_r>

08004c98 <_malloc_r>:
 8004c98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004c9c:	f101 040b 	add.w	r4, r1, #11
 8004ca0:	2c16      	cmp	r4, #22
 8004ca2:	b083      	sub	sp, #12
 8004ca4:	4606      	mov	r6, r0
 8004ca6:	d931      	bls.n	8004d0c <_malloc_r+0x74>
 8004ca8:	f024 0407 	bic.w	r4, r4, #7
 8004cac:	0fe3      	lsrs	r3, r4, #31
 8004cae:	428c      	cmp	r4, r1
 8004cb0:	bf2c      	ite	cs
 8004cb2:	4619      	movcs	r1, r3
 8004cb4:	f043 0101 	orrcc.w	r1, r3, #1
 8004cb8:	2900      	cmp	r1, #0
 8004cba:	d130      	bne.n	8004d1e <_malloc_r+0x86>
 8004cbc:	4630      	mov	r0, r6
 8004cbe:	f000 faa9 	bl	8005214 <__malloc_lock>
 8004cc2:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
 8004cc6:	d22f      	bcs.n	8004d28 <_malloc_r+0x90>
 8004cc8:	ea4f 0cd4 	mov.w	ip, r4, lsr #3
 8004ccc:	f240 3560 	movw	r5, #864	; 0x360
 8004cd0:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8004cd4:	eb05 02cc 	add.w	r2, r5, ip, lsl #3
 8004cd8:	462f      	mov	r7, r5
 8004cda:	68d3      	ldr	r3, [r2, #12]
 8004cdc:	4293      	cmp	r3, r2
 8004cde:	f000 822d 	beq.w	800513c <_malloc_r+0x4a4>
 8004ce2:	685c      	ldr	r4, [r3, #4]
 8004ce4:	f103 0808 	add.w	r8, r3, #8
 8004ce8:	68da      	ldr	r2, [r3, #12]
 8004cea:	4630      	mov	r0, r6
 8004cec:	f024 0403 	bic.w	r4, r4, #3
 8004cf0:	6899      	ldr	r1, [r3, #8]
 8004cf2:	191b      	adds	r3, r3, r4
 8004cf4:	685c      	ldr	r4, [r3, #4]
 8004cf6:	60ca      	str	r2, [r1, #12]
 8004cf8:	f044 0401 	orr.w	r4, r4, #1
 8004cfc:	6091      	str	r1, [r2, #8]
 8004cfe:	605c      	str	r4, [r3, #4]
 8004d00:	f000 fa8a 	bl	8005218 <__malloc_unlock>
 8004d04:	4640      	mov	r0, r8
 8004d06:	b003      	add	sp, #12
 8004d08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004d0c:	2300      	movs	r3, #0
 8004d0e:	2410      	movs	r4, #16
 8004d10:	428c      	cmp	r4, r1
 8004d12:	bf2c      	ite	cs
 8004d14:	4619      	movcs	r1, r3
 8004d16:	f043 0101 	orrcc.w	r1, r3, #1
 8004d1a:	2900      	cmp	r1, #0
 8004d1c:	d0ce      	beq.n	8004cbc <_malloc_r+0x24>
 8004d1e:	230c      	movs	r3, #12
 8004d20:	f04f 0800 	mov.w	r8, #0
 8004d24:	6033      	str	r3, [r6, #0]
 8004d26:	e7ed      	b.n	8004d04 <_malloc_r+0x6c>
 8004d28:	ea5f 2c54 	movs.w	ip, r4, lsr #9
 8004d2c:	bf04      	itt	eq
 8004d2e:	ea4f 0cd4 	moveq.w	ip, r4, lsr #3
 8004d32:	ea4f 00cc 	moveq.w	r0, ip, lsl #3
 8004d36:	f040 8086 	bne.w	8004e46 <_malloc_r+0x1ae>
 8004d3a:	f240 3560 	movw	r5, #864	; 0x360
 8004d3e:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8004d42:	1828      	adds	r0, r5, r0
 8004d44:	462f      	mov	r7, r5
 8004d46:	68c3      	ldr	r3, [r0, #12]
 8004d48:	4298      	cmp	r0, r3
 8004d4a:	d106      	bne.n	8004d5a <_malloc_r+0xc2>
 8004d4c:	e00d      	b.n	8004d6a <_malloc_r+0xd2>
 8004d4e:	2900      	cmp	r1, #0
 8004d50:	f280 8179 	bge.w	8005046 <_malloc_r+0x3ae>
 8004d54:	68db      	ldr	r3, [r3, #12]
 8004d56:	4298      	cmp	r0, r3
 8004d58:	d007      	beq.n	8004d6a <_malloc_r+0xd2>
 8004d5a:	685a      	ldr	r2, [r3, #4]
 8004d5c:	f022 0203 	bic.w	r2, r2, #3
 8004d60:	1b11      	subs	r1, r2, r4
 8004d62:	290f      	cmp	r1, #15
 8004d64:	ddf3      	ble.n	8004d4e <_malloc_r+0xb6>
 8004d66:	f10c 3cff 	add.w	ip, ip, #4294967295
 8004d6a:	f10c 0c01 	add.w	ip, ip, #1
 8004d6e:	4abd      	ldr	r2, [pc, #756]	; (8005064 <_malloc_r+0x3cc>)
 8004d70:	6893      	ldr	r3, [r2, #8]
 8004d72:	429a      	cmp	r2, r3
 8004d74:	bf08      	it	eq
 8004d76:	6878      	ldreq	r0, [r7, #4]
 8004d78:	d024      	beq.n	8004dc4 <_malloc_r+0x12c>
 8004d7a:	6858      	ldr	r0, [r3, #4]
 8004d7c:	f020 0003 	bic.w	r0, r0, #3
 8004d80:	1b01      	subs	r1, r0, r4
 8004d82:	290f      	cmp	r1, #15
 8004d84:	f300 81c0 	bgt.w	8005108 <_malloc_r+0x470>
 8004d88:	2900      	cmp	r1, #0
 8004d8a:	60d2      	str	r2, [r2, #12]
 8004d8c:	6092      	str	r2, [r2, #8]
 8004d8e:	f280 8094 	bge.w	8004eba <_malloc_r+0x222>
 8004d92:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8004d96:	f080 8177 	bcs.w	8005088 <_malloc_r+0x3f0>
 8004d9a:	08c0      	lsrs	r0, r0, #3
 8004d9c:	f04f 0e01 	mov.w	lr, #1
 8004da0:	f8d7 8004 	ldr.w	r8, [r7, #4]
 8004da4:	eb07 01c0 	add.w	r1, r7, r0, lsl #3
 8004da8:	1080      	asrs	r0, r0, #2
 8004daa:	fa0e f000 	lsl.w	r0, lr, r0
 8004dae:	60d9      	str	r1, [r3, #12]
 8004db0:	f8d1 e008 	ldr.w	lr, [r1, #8]
 8004db4:	ea40 0008 	orr.w	r0, r0, r8
 8004db8:	6078      	str	r0, [r7, #4]
 8004dba:	f8c3 e008 	str.w	lr, [r3, #8]
 8004dbe:	f8ce 300c 	str.w	r3, [lr, #12]
 8004dc2:	608b      	str	r3, [r1, #8]
 8004dc4:	f04f 0e01 	mov.w	lr, #1
 8004dc8:	ea4f 03ac 	mov.w	r3, ip, asr #2
 8004dcc:	fa0e fe03 	lsl.w	lr, lr, r3
 8004dd0:	4586      	cmp	lr, r0
 8004dd2:	d87d      	bhi.n	8004ed0 <_malloc_r+0x238>
 8004dd4:	ea10 0f0e 	tst.w	r0, lr
 8004dd8:	d108      	bne.n	8004dec <_malloc_r+0x154>
 8004dda:	f02c 0c03 	bic.w	ip, ip, #3
 8004dde:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 8004de2:	f10c 0c04 	add.w	ip, ip, #4
 8004de6:	ea10 0f0e 	tst.w	r0, lr
 8004dea:	d0f8      	beq.n	8004dde <_malloc_r+0x146>
 8004dec:	eb07 0acc 	add.w	sl, r7, ip, lsl #3
 8004df0:	46e1      	mov	r9, ip
 8004df2:	46d0      	mov	r8, sl
 8004df4:	f8d8 000c 	ldr.w	r0, [r8, #12]
 8004df8:	4580      	cmp	r8, r0
 8004dfa:	d107      	bne.n	8004e0c <_malloc_r+0x174>
 8004dfc:	e196      	b.n	800512c <_malloc_r+0x494>
 8004dfe:	2b00      	cmp	r3, #0
 8004e00:	f280 81a6 	bge.w	8005150 <_malloc_r+0x4b8>
 8004e04:	68c0      	ldr	r0, [r0, #12]
 8004e06:	4580      	cmp	r8, r0
 8004e08:	f000 8190 	beq.w	800512c <_malloc_r+0x494>
 8004e0c:	6841      	ldr	r1, [r0, #4]
 8004e0e:	f021 0103 	bic.w	r1, r1, #3
 8004e12:	1b0b      	subs	r3, r1, r4
 8004e14:	2b0f      	cmp	r3, #15
 8004e16:	ddf2      	ble.n	8004dfe <_malloc_r+0x166>
 8004e18:	4680      	mov	r8, r0
 8004e1a:	68c5      	ldr	r5, [r0, #12]
 8004e1c:	1901      	adds	r1, r0, r4
 8004e1e:	f044 0e01 	orr.w	lr, r4, #1
 8004e22:	f858 7f08 	ldr.w	r7, [r8, #8]!
 8004e26:	f043 0401 	orr.w	r4, r3, #1
 8004e2a:	f8c0 e004 	str.w	lr, [r0, #4]
 8004e2e:	4630      	mov	r0, r6
 8004e30:	604c      	str	r4, [r1, #4]
 8004e32:	60fd      	str	r5, [r7, #12]
 8004e34:	60af      	str	r7, [r5, #8]
 8004e36:	60d1      	str	r1, [r2, #12]
 8004e38:	6091      	str	r1, [r2, #8]
 8004e3a:	60ca      	str	r2, [r1, #12]
 8004e3c:	608a      	str	r2, [r1, #8]
 8004e3e:	50cb      	str	r3, [r1, r3]
 8004e40:	f000 f9ea 	bl	8005218 <__malloc_unlock>
 8004e44:	e75e      	b.n	8004d04 <_malloc_r+0x6c>
 8004e46:	f1bc 0f04 	cmp.w	ip, #4
 8004e4a:	bf9e      	ittt	ls
 8004e4c:	ea4f 1c94 	movls.w	ip, r4, lsr #6
 8004e50:	f10c 0c38 	addls.w	ip, ip, #56	; 0x38
 8004e54:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8004e58:	f67f af6f 	bls.w	8004d3a <_malloc_r+0xa2>
 8004e5c:	f1bc 0f14 	cmp.w	ip, #20
 8004e60:	bf9c      	itt	ls
 8004e62:	f10c 0c5b 	addls.w	ip, ip, #91	; 0x5b
 8004e66:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8004e6a:	f67f af66 	bls.w	8004d3a <_malloc_r+0xa2>
 8004e6e:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
 8004e72:	bf9e      	ittt	ls
 8004e74:	ea4f 3c14 	movls.w	ip, r4, lsr #12
 8004e78:	f10c 0c6e 	addls.w	ip, ip, #110	; 0x6e
 8004e7c:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8004e80:	f67f af5b 	bls.w	8004d3a <_malloc_r+0xa2>
 8004e84:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
 8004e88:	bf9e      	ittt	ls
 8004e8a:	ea4f 3cd4 	movls.w	ip, r4, lsr #15
 8004e8e:	f10c 0c77 	addls.w	ip, ip, #119	; 0x77
 8004e92:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8004e96:	f67f af50 	bls.w	8004d3a <_malloc_r+0xa2>
 8004e9a:	f240 5354 	movw	r3, #1364	; 0x554
 8004e9e:	459c      	cmp	ip, r3
 8004ea0:	bf95      	itete	ls
 8004ea2:	ea4f 4c94 	movls.w	ip, r4, lsr #18
 8004ea6:	f44f 707c 	movhi.w	r0, #1008	; 0x3f0
 8004eaa:	f10c 0c7c 	addls.w	ip, ip, #124	; 0x7c
 8004eae:	f04f 0c7e 	movhi.w	ip, #126	; 0x7e
 8004eb2:	bf98      	it	ls
 8004eb4:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8004eb8:	e73f      	b.n	8004d3a <_malloc_r+0xa2>
 8004eba:	181a      	adds	r2, r3, r0
 8004ebc:	f103 0808 	add.w	r8, r3, #8
 8004ec0:	4630      	mov	r0, r6
 8004ec2:	6853      	ldr	r3, [r2, #4]
 8004ec4:	f043 0301 	orr.w	r3, r3, #1
 8004ec8:	6053      	str	r3, [r2, #4]
 8004eca:	f000 f9a5 	bl	8005218 <__malloc_unlock>
 8004ece:	e719      	b.n	8004d04 <_malloc_r+0x6c>
 8004ed0:	f8d7 8008 	ldr.w	r8, [r7, #8]
 8004ed4:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8004ed8:	f023 0903 	bic.w	r9, r3, #3
 8004edc:	454c      	cmp	r4, r9
 8004ede:	ebc4 0209 	rsb	r2, r4, r9
 8004ee2:	bf94      	ite	ls
 8004ee4:	2300      	movls	r3, #0
 8004ee6:	2301      	movhi	r3, #1
 8004ee8:	2a0f      	cmp	r2, #15
 8004eea:	bfd8      	it	le
 8004eec:	f043 0301 	orrle.w	r3, r3, #1
 8004ef0:	2b00      	cmp	r3, #0
 8004ef2:	f000 80b9 	beq.w	8005068 <_malloc_r+0x3d0>
 8004ef6:	f640 2af4 	movw	sl, #2804	; 0xaf4
 8004efa:	f8d5 3408 	ldr.w	r3, [r5, #1032]	; 0x408
 8004efe:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 8004f02:	4630      	mov	r0, r6
 8004f04:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004f08:	f8da 2000 	ldr.w	r2, [sl]
 8004f0c:	f102 0b10 	add.w	fp, r2, #16
 8004f10:	44a3      	add	fp, r4
 8004f12:	bf1f      	itttt	ne
 8004f14:	f50b 6b7e 	addne.w	fp, fp, #4064	; 0xfe0
 8004f18:	f10b 0b1f 	addne.w	fp, fp, #31
 8004f1c:	f42b 6b7e 	bicne.w	fp, fp, #4064	; 0xfe0
 8004f20:	f02b 0b1f 	bicne.w	fp, fp, #31
 8004f24:	4659      	mov	r1, fp
 8004f26:	f7fb fd7b 	bl	8000a20 <_sbrk_r>
 8004f2a:	f1b0 3fff 	cmp.w	r0, #4294967295
 8004f2e:	4603      	mov	r3, r0
 8004f30:	f000 8118 	beq.w	8005164 <_malloc_r+0x4cc>
 8004f34:	eb08 0109 	add.w	r1, r8, r9
 8004f38:	4281      	cmp	r1, r0
 8004f3a:	f200 8110 	bhi.w	800515e <_malloc_r+0x4c6>
 8004f3e:	f8da 2004 	ldr.w	r2, [sl, #4]
 8004f42:	4281      	cmp	r1, r0
 8004f44:	445a      	add	r2, fp
 8004f46:	f8ca 2004 	str.w	r2, [sl, #4]
 8004f4a:	f000 813e 	beq.w	80051ca <_malloc_r+0x532>
 8004f4e:	f8d5 e408 	ldr.w	lr, [r5, #1032]	; 0x408
 8004f52:	f240 3560 	movw	r5, #864	; 0x360
 8004f56:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8004f5a:	f1be 3fff 	cmp.w	lr, #4294967295
 8004f5e:	bf17      	itett	ne
 8004f60:	1882      	addne	r2, r0, r2
 8004f62:	f8c5 0408 	streq.w	r0, [r5, #1032]	; 0x408
 8004f66:	ebc1 0102 	rsbne	r1, r1, r2
 8004f6a:	f8ca 1004 	strne.w	r1, [sl, #4]
 8004f6e:	f010 0507 	ands.w	r5, r0, #7
 8004f72:	bf17      	itett	ne
 8004f74:	f1c5 0508 	rsbne	r5, r5, #8
 8004f78:	f44f 5580 	moveq.w	r5, #4096	; 0x1000
 8004f7c:	1943      	addne	r3, r0, r5
 8004f7e:	f505 5580 	addne.w	r5, r5, #4096	; 0x1000
 8004f82:	eb03 020b 	add.w	r2, r3, fp
 8004f86:	4630      	mov	r0, r6
 8004f88:	9301      	str	r3, [sp, #4]
 8004f8a:	0512      	lsls	r2, r2, #20
 8004f8c:	0d12      	lsrs	r2, r2, #20
 8004f8e:	1aad      	subs	r5, r5, r2
 8004f90:	4629      	mov	r1, r5
 8004f92:	f7fb fd45 	bl	8000a20 <_sbrk_r>
 8004f96:	9b01      	ldr	r3, [sp, #4]
 8004f98:	f1b0 3fff 	cmp.w	r0, #4294967295
 8004f9c:	f000 812c 	beq.w	80051f8 <_malloc_r+0x560>
 8004fa0:	1ac1      	subs	r1, r0, r3
 8004fa2:	1949      	adds	r1, r1, r5
 8004fa4:	f041 0101 	orr.w	r1, r1, #1
 8004fa8:	f8da 2004 	ldr.w	r2, [sl, #4]
 8004fac:	45b8      	cmp	r8, r7
 8004fae:	f640 2bf4 	movw	fp, #2804	; 0xaf4
 8004fb2:	60bb      	str	r3, [r7, #8]
 8004fb4:	442a      	add	r2, r5
 8004fb6:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 8004fba:	6059      	str	r1, [r3, #4]
 8004fbc:	f8ca 2004 	str.w	r2, [sl, #4]
 8004fc0:	d017      	beq.n	8004ff2 <_malloc_r+0x35a>
 8004fc2:	f1b9 0f0f 	cmp.w	r9, #15
 8004fc6:	f240 80e1 	bls.w	800518c <_malloc_r+0x4f4>
 8004fca:	f1a9 030c 	sub.w	r3, r9, #12
 8004fce:	f8d8 5004 	ldr.w	r5, [r8, #4]
 8004fd2:	f023 0307 	bic.w	r3, r3, #7
 8004fd6:	2005      	movs	r0, #5
 8004fd8:	eb08 0103 	add.w	r1, r8, r3
 8004fdc:	2b0f      	cmp	r3, #15
 8004fde:	f005 0501 	and.w	r5, r5, #1
 8004fe2:	ea43 0505 	orr.w	r5, r3, r5
 8004fe6:	f8c8 5004 	str.w	r5, [r8, #4]
 8004fea:	6048      	str	r0, [r1, #4]
 8004fec:	6088      	str	r0, [r1, #8]
 8004fee:	f200 80fb 	bhi.w	80051e8 <_malloc_r+0x550>
 8004ff2:	f8da 102c 	ldr.w	r1, [sl, #44]	; 0x2c
 8004ff6:	f640 23f4 	movw	r3, #2804	; 0xaf4
 8004ffa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004ffe:	428a      	cmp	r2, r1
 8005000:	f8da 1030 	ldr.w	r1, [sl, #48]	; 0x30
 8005004:	bf88      	it	hi
 8005006:	62da      	strhi	r2, [r3, #44]	; 0x2c
 8005008:	f640 23f4 	movw	r3, #2804	; 0xaf4
 800500c:	428a      	cmp	r2, r1
 800500e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005012:	f240 80a7 	bls.w	8005164 <_malloc_r+0x4cc>
 8005016:	f8d7 8008 	ldr.w	r8, [r7, #8]
 800501a:	631a      	str	r2, [r3, #48]	; 0x30
 800501c:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8005020:	f023 0303 	bic.w	r3, r3, #3
 8005024:	429c      	cmp	r4, r3
 8005026:	ebc4 0203 	rsb	r2, r4, r3
 800502a:	bf94      	ite	ls
 800502c:	2300      	movls	r3, #0
 800502e:	2301      	movhi	r3, #1
 8005030:	2a0f      	cmp	r2, #15
 8005032:	bfd8      	it	le
 8005034:	f043 0301 	orrle.w	r3, r3, #1
 8005038:	b1b3      	cbz	r3, 8005068 <_malloc_r+0x3d0>
 800503a:	4630      	mov	r0, r6
 800503c:	f04f 0800 	mov.w	r8, #0
 8005040:	f000 f8ea 	bl	8005218 <__malloc_unlock>
 8005044:	e65e      	b.n	8004d04 <_malloc_r+0x6c>
 8005046:	189a      	adds	r2, r3, r2
 8005048:	68d9      	ldr	r1, [r3, #12]
 800504a:	689c      	ldr	r4, [r3, #8]
 800504c:	f103 0808 	add.w	r8, r3, #8
 8005050:	6855      	ldr	r5, [r2, #4]
 8005052:	4630      	mov	r0, r6
 8005054:	f045 0301 	orr.w	r3, r5, #1
 8005058:	60e1      	str	r1, [r4, #12]
 800505a:	608c      	str	r4, [r1, #8]
 800505c:	6053      	str	r3, [r2, #4]
 800505e:	f000 f8db 	bl	8005218 <__malloc_unlock>
 8005062:	e64f      	b.n	8004d04 <_malloc_r+0x6c>
 8005064:	20000368 	.word	0x20000368
 8005068:	eb08 0304 	add.w	r3, r8, r4
 800506c:	f042 0201 	orr.w	r2, r2, #1
 8005070:	f044 0401 	orr.w	r4, r4, #1
 8005074:	4630      	mov	r0, r6
 8005076:	f8c8 4004 	str.w	r4, [r8, #4]
 800507a:	f108 0808 	add.w	r8, r8, #8
 800507e:	605a      	str	r2, [r3, #4]
 8005080:	60bb      	str	r3, [r7, #8]
 8005082:	f000 f8c9 	bl	8005218 <__malloc_unlock>
 8005086:	e63d      	b.n	8004d04 <_malloc_r+0x6c>
 8005088:	0a41      	lsrs	r1, r0, #9
 800508a:	2904      	cmp	r1, #4
 800508c:	bf9c      	itt	ls
 800508e:	ea4f 1e90 	movls.w	lr, r0, lsr #6
 8005092:	f10e 0e38 	addls.w	lr, lr, #56	; 0x38
 8005096:	d91d      	bls.n	80050d4 <_malloc_r+0x43c>
 8005098:	2914      	cmp	r1, #20
 800509a:	bf98      	it	ls
 800509c:	f101 0e5b 	addls.w	lr, r1, #91	; 0x5b
 80050a0:	d918      	bls.n	80050d4 <_malloc_r+0x43c>
 80050a2:	2954      	cmp	r1, #84	; 0x54
 80050a4:	bf9c      	itt	ls
 80050a6:	ea4f 3e10 	movls.w	lr, r0, lsr #12
 80050aa:	f10e 0e6e 	addls.w	lr, lr, #110	; 0x6e
 80050ae:	d911      	bls.n	80050d4 <_malloc_r+0x43c>
 80050b0:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
 80050b4:	bf9c      	itt	ls
 80050b6:	ea4f 3ed0 	movls.w	lr, r0, lsr #15
 80050ba:	f10e 0e77 	addls.w	lr, lr, #119	; 0x77
 80050be:	d909      	bls.n	80050d4 <_malloc_r+0x43c>
 80050c0:	f240 5e54 	movw	lr, #1364	; 0x554
 80050c4:	4571      	cmp	r1, lr
 80050c6:	bf96      	itet	ls
 80050c8:	ea4f 4e90 	movls.w	lr, r0, lsr #18
 80050cc:	f04f 0e7e 	movhi.w	lr, #126	; 0x7e
 80050d0:	f10e 0e7c 	addls.w	lr, lr, #124	; 0x7c
 80050d4:	eb07 08ce 	add.w	r8, r7, lr, lsl #3
 80050d8:	f8d8 1008 	ldr.w	r1, [r8, #8]
 80050dc:	4541      	cmp	r1, r8
 80050de:	d103      	bne.n	80050e8 <_malloc_r+0x450>
 80050e0:	e047      	b.n	8005172 <_malloc_r+0x4da>
 80050e2:	6889      	ldr	r1, [r1, #8]
 80050e4:	4588      	cmp	r8, r1
 80050e6:	d005      	beq.n	80050f4 <_malloc_r+0x45c>
 80050e8:	f8d1 e004 	ldr.w	lr, [r1, #4]
 80050ec:	f02e 0e03 	bic.w	lr, lr, #3
 80050f0:	4570      	cmp	r0, lr
 80050f2:	d3f6      	bcc.n	80050e2 <_malloc_r+0x44a>
 80050f4:	f8d1 e00c 	ldr.w	lr, [r1, #12]
 80050f8:	f8c3 e00c 	str.w	lr, [r3, #12]
 80050fc:	6099      	str	r1, [r3, #8]
 80050fe:	6878      	ldr	r0, [r7, #4]
 8005100:	60cb      	str	r3, [r1, #12]
 8005102:	f8ce 3008 	str.w	r3, [lr, #8]
 8005106:	e65d      	b.n	8004dc4 <_malloc_r+0x12c>
 8005108:	191d      	adds	r5, r3, r4
 800510a:	f041 0701 	orr.w	r7, r1, #1
 800510e:	60d5      	str	r5, [r2, #12]
 8005110:	f044 0401 	orr.w	r4, r4, #1
 8005114:	6095      	str	r5, [r2, #8]
 8005116:	4630      	mov	r0, r6
 8005118:	605c      	str	r4, [r3, #4]
 800511a:	f103 0808 	add.w	r8, r3, #8
 800511e:	60ea      	str	r2, [r5, #12]
 8005120:	60aa      	str	r2, [r5, #8]
 8005122:	606f      	str	r7, [r5, #4]
 8005124:	5069      	str	r1, [r5, r1]
 8005126:	f000 f877 	bl	8005218 <__malloc_unlock>
 800512a:	e5eb      	b.n	8004d04 <_malloc_r+0x6c>
 800512c:	f109 0901 	add.w	r9, r9, #1
 8005130:	f019 0f03 	tst.w	r9, #3
 8005134:	d02f      	beq.n	8005196 <_malloc_r+0x4fe>
 8005136:	f108 0808 	add.w	r8, r8, #8
 800513a:	e65b      	b.n	8004df4 <_malloc_r+0x15c>
 800513c:	f103 0208 	add.w	r2, r3, #8
 8005140:	695b      	ldr	r3, [r3, #20]
 8005142:	429a      	cmp	r2, r3
 8005144:	bf08      	it	eq
 8005146:	f10c 0c02 	addeq.w	ip, ip, #2
 800514a:	f43f ae10 	beq.w	8004d6e <_malloc_r+0xd6>
 800514e:	e5c8      	b.n	8004ce2 <_malloc_r+0x4a>
 8005150:	4680      	mov	r8, r0
 8005152:	1843      	adds	r3, r0, r1
 8005154:	68c2      	ldr	r2, [r0, #12]
 8005156:	4630      	mov	r0, r6
 8005158:	f858 1f08 	ldr.w	r1, [r8, #8]!
 800515c:	e5ca      	b.n	8004cf4 <_malloc_r+0x5c>
 800515e:	45b8      	cmp	r8, r7
 8005160:	f43f aeed 	beq.w	8004f3e <_malloc_r+0x2a6>
 8005164:	f8d7 8008 	ldr.w	r8, [r7, #8]
 8005168:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800516c:	f023 0303 	bic.w	r3, r3, #3
 8005170:	e758      	b.n	8005024 <_malloc_r+0x38c>
 8005172:	f04f 0901 	mov.w	r9, #1
 8005176:	f8d7 8004 	ldr.w	r8, [r7, #4]
 800517a:	ea4f 00ae 	mov.w	r0, lr, asr #2
 800517e:	468e      	mov	lr, r1
 8005180:	fa09 f000 	lsl.w	r0, r9, r0
 8005184:	ea48 0000 	orr.w	r0, r8, r0
 8005188:	6078      	str	r0, [r7, #4]
 800518a:	e7b5      	b.n	80050f8 <_malloc_r+0x460>
 800518c:	4698      	mov	r8, r3
 800518e:	2201      	movs	r2, #1
 8005190:	605a      	str	r2, [r3, #4]
 8005192:	2300      	movs	r3, #0
 8005194:	e746      	b.n	8005024 <_malloc_r+0x38c>
 8005196:	4651      	mov	r1, sl
 8005198:	f01c 0f03 	tst.w	ip, #3
 800519c:	460b      	mov	r3, r1
 800519e:	f10c 3cff 	add.w	ip, ip, #4294967295
 80051a2:	d02c      	beq.n	80051fe <_malloc_r+0x566>
 80051a4:	f853 1908 	ldr.w	r1, [r3], #-8
 80051a8:	4299      	cmp	r1, r3
 80051aa:	d0f5      	beq.n	8005198 <_malloc_r+0x500>
 80051ac:	687b      	ldr	r3, [r7, #4]
 80051ae:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 80051b2:	459e      	cmp	lr, r3
 80051b4:	f63f ae8c 	bhi.w	8004ed0 <_malloc_r+0x238>
 80051b8:	f1be 0f00 	cmp.w	lr, #0
 80051bc:	f43f ae88 	beq.w	8004ed0 <_malloc_r+0x238>
 80051c0:	ea1e 0f03 	tst.w	lr, r3
 80051c4:	d020      	beq.n	8005208 <_malloc_r+0x570>
 80051c6:	46cc      	mov	ip, r9
 80051c8:	e610      	b.n	8004dec <_malloc_r+0x154>
 80051ca:	ea4f 5e01 	mov.w	lr, r1, lsl #20
 80051ce:	ea4f 5e1e 	mov.w	lr, lr, lsr #20
 80051d2:	f1be 0f00 	cmp.w	lr, #0
 80051d6:	f47f aeba 	bne.w	8004f4e <_malloc_r+0x2b6>
 80051da:	68bb      	ldr	r3, [r7, #8]
 80051dc:	eb0b 0109 	add.w	r1, fp, r9
 80051e0:	f041 0101 	orr.w	r1, r1, #1
 80051e4:	6059      	str	r1, [r3, #4]
 80051e6:	e704      	b.n	8004ff2 <_malloc_r+0x35a>
 80051e8:	4630      	mov	r0, r6
 80051ea:	f108 0108 	add.w	r1, r8, #8
 80051ee:	f000 fc35 	bl	8005a5c <_free_r>
 80051f2:	f8db 2004 	ldr.w	r2, [fp, #4]
 80051f6:	e6fc      	b.n	8004ff2 <_malloc_r+0x35a>
 80051f8:	2101      	movs	r1, #1
 80051fa:	2500      	movs	r5, #0
 80051fc:	e6d4      	b.n	8004fa8 <_malloc_r+0x310>
 80051fe:	687b      	ldr	r3, [r7, #4]
 8005200:	ea23 030e 	bic.w	r3, r3, lr
 8005204:	607b      	str	r3, [r7, #4]
 8005206:	e7d1      	b.n	80051ac <_malloc_r+0x514>
 8005208:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 800520c:	f109 0904 	add.w	r9, r9, #4
 8005210:	e7d6      	b.n	80051c0 <_malloc_r+0x528>
 8005212:	bf00      	nop

08005214 <__malloc_lock>:
 8005214:	4770      	bx	lr
 8005216:	bf00      	nop

08005218 <__malloc_unlock>:
 8005218:	4770      	bx	lr
 800521a:	bf00      	nop

0800521c <setbuf>:
 800521c:	2900      	cmp	r1, #0
 800521e:	bf0c      	ite	eq
 8005220:	2202      	moveq	r2, #2
 8005222:	2200      	movne	r2, #0
 8005224:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8005228:	f000 b800 	b.w	800522c <setvbuf>

0800522c <setvbuf>:
 800522c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8005230:	f240 256c 	movw	r5, #620	; 0x26c
 8005234:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8005238:	4604      	mov	r4, r0
 800523a:	460e      	mov	r6, r1
 800523c:	4617      	mov	r7, r2
 800523e:	6828      	ldr	r0, [r5, #0]
 8005240:	4698      	mov	r8, r3
 8005242:	b110      	cbz	r0, 800524a <setvbuf+0x1e>
 8005244:	6983      	ldr	r3, [r0, #24]
 8005246:	2b00      	cmp	r3, #0
 8005248:	d05a      	beq.n	8005300 <setvbuf+0xd4>
 800524a:	f24b 736c 	movw	r3, #46956	; 0xb76c
 800524e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005252:	429c      	cmp	r4, r3
 8005254:	d05c      	beq.n	8005310 <setvbuf+0xe4>
 8005256:	f24b 738c 	movw	r3, #46988	; 0xb78c
 800525a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800525e:	429c      	cmp	r4, r3
 8005260:	d059      	beq.n	8005316 <setvbuf+0xea>
 8005262:	f24b 73ac 	movw	r3, #47020	; 0xb7ac
 8005266:	f6c0 0300 	movt	r3, #2048	; 0x800
 800526a:	429c      	cmp	r4, r3
 800526c:	bf04      	itt	eq
 800526e:	682b      	ldreq	r3, [r5, #0]
 8005270:	68dc      	ldreq	r4, [r3, #12]
 8005272:	2f02      	cmp	r7, #2
 8005274:	bf94      	ite	ls
 8005276:	f04f 0900 	movls.w	r9, #0
 800527a:	f04f 0901 	movhi.w	r9, #1
 800527e:	ea59 79d8 	orrs.w	r9, r9, r8, lsr #31
 8005282:	bf18      	it	ne
 8005284:	f04f 30ff 	movne.w	r0, #4294967295
 8005288:	d001      	beq.n	800528e <setvbuf+0x62>
 800528a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800528e:	6828      	ldr	r0, [r5, #0]
 8005290:	4621      	mov	r1, r4
 8005292:	f000 f989 	bl	80055a8 <_fflush_r>
 8005296:	89a2      	ldrh	r2, [r4, #12]
 8005298:	f240 236c 	movw	r3, #620	; 0x26c
 800529c:	f8c4 9004 	str.w	r9, [r4, #4]
 80052a0:	f012 0f80 	tst.w	r2, #128	; 0x80
 80052a4:	f8c4 9018 	str.w	r9, [r4, #24]
 80052a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80052ac:	d136      	bne.n	800531c <setvbuf+0xf0>
 80052ae:	2f02      	cmp	r7, #2
 80052b0:	f64f 737c 	movw	r3, #65404	; 0xff7c
 80052b4:	ea02 0303 	and.w	r3, r2, r3
 80052b8:	81a3      	strh	r3, [r4, #12]
 80052ba:	d035      	beq.n	8005328 <setvbuf+0xfc>
 80052bc:	2e00      	cmp	r6, #0
 80052be:	d041      	beq.n	8005344 <setvbuf+0x118>
 80052c0:	2f01      	cmp	r7, #1
 80052c2:	6829      	ldr	r1, [r5, #0]
 80052c4:	bf01      	itttt	eq
 80052c6:	f043 0301 	orreq.w	r3, r3, #1
 80052ca:	81a3      	strheq	r3, [r4, #12]
 80052cc:	f1c8 0200 	rsbeq	r2, r8, #0
 80052d0:	61a2      	streq	r2, [r4, #24]
 80052d2:	b29b      	uxth	r3, r3
 80052d4:	f245 729d 	movw	r2, #22429	; 0x579d
 80052d8:	f013 0008 	ands.w	r0, r3, #8
 80052dc:	f6c0 0200 	movt	r2, #2048	; 0x800
 80052e0:	628a      	str	r2, [r1, #40]	; 0x28
 80052e2:	6026      	str	r6, [r4, #0]
 80052e4:	6126      	str	r6, [r4, #16]
 80052e6:	f8c4 8014 	str.w	r8, [r4, #20]
 80052ea:	d0ce      	beq.n	800528a <setvbuf+0x5e>
 80052ec:	f013 0f03 	tst.w	r3, #3
 80052f0:	f04f 0000 	mov.w	r0, #0
 80052f4:	bf0c      	ite	eq
 80052f6:	4643      	moveq	r3, r8
 80052f8:	4603      	movne	r3, r0
 80052fa:	60a3      	str	r3, [r4, #8]
 80052fc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005300:	f000 fa70 	bl	80057e4 <__sinit>
 8005304:	f24b 736c 	movw	r3, #46956	; 0xb76c
 8005308:	f6c0 0300 	movt	r3, #2048	; 0x800
 800530c:	429c      	cmp	r4, r3
 800530e:	d1a2      	bne.n	8005256 <setvbuf+0x2a>
 8005310:	682b      	ldr	r3, [r5, #0]
 8005312:	685c      	ldr	r4, [r3, #4]
 8005314:	e7ad      	b.n	8005272 <setvbuf+0x46>
 8005316:	682b      	ldr	r3, [r5, #0]
 8005318:	689c      	ldr	r4, [r3, #8]
 800531a:	e7aa      	b.n	8005272 <setvbuf+0x46>
 800531c:	6818      	ldr	r0, [r3, #0]
 800531e:	6921      	ldr	r1, [r4, #16]
 8005320:	f000 fb9c 	bl	8005a5c <_free_r>
 8005324:	89a2      	ldrh	r2, [r4, #12]
 8005326:	e7c2      	b.n	80052ae <setvbuf+0x82>
 8005328:	2000      	movs	r0, #0
 800532a:	f104 0247 	add.w	r2, r4, #71	; 0x47
 800532e:	f043 0302 	orr.w	r3, r3, #2
 8005332:	6022      	str	r2, [r4, #0]
 8005334:	81a3      	strh	r3, [r4, #12]
 8005336:	2300      	movs	r3, #0
 8005338:	6122      	str	r2, [r4, #16]
 800533a:	60a3      	str	r3, [r4, #8]
 800533c:	2301      	movs	r3, #1
 800533e:	6163      	str	r3, [r4, #20]
 8005340:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005344:	f1b8 0f00 	cmp.w	r8, #0
 8005348:	bf08      	it	eq
 800534a:	f44f 6880 	moveq.w	r8, #1024	; 0x400
 800534e:	4640      	mov	r0, r8
 8005350:	f7ff fc92 	bl	8004c78 <malloc>
 8005354:	4606      	mov	r6, r0
 8005356:	b128      	cbz	r0, 8005364 <setvbuf+0x138>
 8005358:	89a3      	ldrh	r3, [r4, #12]
 800535a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800535e:	b29b      	uxth	r3, r3
 8005360:	81a3      	strh	r3, [r4, #12]
 8005362:	e7ad      	b.n	80052c0 <setvbuf+0x94>
 8005364:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8005368:	f7ff fc86 	bl	8004c78 <malloc>
 800536c:	4606      	mov	r6, r0
 800536e:	b918      	cbnz	r0, 8005378 <setvbuf+0x14c>
 8005370:	89a3      	ldrh	r3, [r4, #12]
 8005372:	f04f 30ff 	mov.w	r0, #4294967295
 8005376:	e7d8      	b.n	800532a <setvbuf+0xfe>
 8005378:	f44f 6880 	mov.w	r8, #1024	; 0x400
 800537c:	e7ec      	b.n	8005358 <setvbuf+0x12c>
 800537e:	bf00      	nop

08005380 <strcmp>:
 8005380:	ea80 0201 	eor.w	r2, r0, r1
 8005384:	f012 0f03 	tst.w	r2, #3
 8005388:	d13a      	bne.n	8005400 <strcmp_unaligned>
 800538a:	f010 0203 	ands.w	r2, r0, #3
 800538e:	f020 0003 	bic.w	r0, r0, #3
 8005392:	f021 0103 	bic.w	r1, r1, #3
 8005396:	f850 cb04 	ldr.w	ip, [r0], #4
 800539a:	bf08      	it	eq
 800539c:	f851 3b04 	ldreq.w	r3, [r1], #4
 80053a0:	d00d      	beq.n	80053be <strcmp+0x3e>
 80053a2:	f082 0203 	eor.w	r2, r2, #3
 80053a6:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80053aa:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 80053ae:	fa23 f202 	lsr.w	r2, r3, r2
 80053b2:	f851 3b04 	ldr.w	r3, [r1], #4
 80053b6:	ea4c 0c02 	orr.w	ip, ip, r2
 80053ba:	ea43 0302 	orr.w	r3, r3, r2
 80053be:	bf00      	nop
 80053c0:	f1ac 3201 	sub.w	r2, ip, #16843009	; 0x1010101
 80053c4:	459c      	cmp	ip, r3
 80053c6:	bf01      	itttt	eq
 80053c8:	ea22 020c 	biceq.w	r2, r2, ip
 80053cc:	f012 3f80 	tsteq.w	r2, #2155905152	; 0x80808080
 80053d0:	f850 cb04 	ldreq.w	ip, [r0], #4
 80053d4:	f851 3b04 	ldreq.w	r3, [r1], #4
 80053d8:	d0f2      	beq.n	80053c0 <strcmp+0x40>
 80053da:	ea4f 600c 	mov.w	r0, ip, lsl #24
 80053de:	ea4f 2c1c 	mov.w	ip, ip, lsr #8
 80053e2:	2801      	cmp	r0, #1
 80053e4:	bf28      	it	cs
 80053e6:	ebb0 6f03 	cmpcs.w	r0, r3, lsl #24
 80053ea:	bf08      	it	eq
 80053ec:	0a1b      	lsreq	r3, r3, #8
 80053ee:	d0f4      	beq.n	80053da <strcmp+0x5a>
 80053f0:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 80053f4:	ea4f 6010 	mov.w	r0, r0, lsr #24
 80053f8:	eba0 0003 	sub.w	r0, r0, r3
 80053fc:	4770      	bx	lr
 80053fe:	bf00      	nop

08005400 <strcmp_unaligned>:
 8005400:	f010 0f03 	tst.w	r0, #3
 8005404:	d00a      	beq.n	800541c <strcmp_unaligned+0x1c>
 8005406:	f810 2b01 	ldrb.w	r2, [r0], #1
 800540a:	f811 3b01 	ldrb.w	r3, [r1], #1
 800540e:	2a01      	cmp	r2, #1
 8005410:	bf28      	it	cs
 8005412:	429a      	cmpcs	r2, r3
 8005414:	d0f4      	beq.n	8005400 <strcmp_unaligned>
 8005416:	eba2 0003 	sub.w	r0, r2, r3
 800541a:	4770      	bx	lr
 800541c:	f84d 5d04 	str.w	r5, [sp, #-4]!
 8005420:	f84d 4d04 	str.w	r4, [sp, #-4]!
 8005424:	f04f 0201 	mov.w	r2, #1
 8005428:	ea42 2202 	orr.w	r2, r2, r2, lsl #8
 800542c:	ea42 4202 	orr.w	r2, r2, r2, lsl #16
 8005430:	f001 0c03 	and.w	ip, r1, #3
 8005434:	f021 0103 	bic.w	r1, r1, #3
 8005438:	f850 4b04 	ldr.w	r4, [r0], #4
 800543c:	f851 5b04 	ldr.w	r5, [r1], #4
 8005440:	f1bc 0f02 	cmp.w	ip, #2
 8005444:	d026      	beq.n	8005494 <strcmp_unaligned+0x94>
 8005446:	d84b      	bhi.n	80054e0 <strcmp_unaligned+0xe0>
 8005448:	f024 4c7f 	bic.w	ip, r4, #4278190080	; 0xff000000
 800544c:	ebbc 2f15 	cmp.w	ip, r5, lsr #8
 8005450:	eba4 0302 	sub.w	r3, r4, r2
 8005454:	ea23 0304 	bic.w	r3, r3, r4
 8005458:	d10d      	bne.n	8005476 <strcmp_unaligned+0x76>
 800545a:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 800545e:	bf08      	it	eq
 8005460:	f851 5b04 	ldreq.w	r5, [r1], #4
 8005464:	d10a      	bne.n	800547c <strcmp_unaligned+0x7c>
 8005466:	ea8c 0c04 	eor.w	ip, ip, r4
 800546a:	ebbc 6f05 	cmp.w	ip, r5, lsl #24
 800546e:	d10c      	bne.n	800548a <strcmp_unaligned+0x8a>
 8005470:	f850 4b04 	ldr.w	r4, [r0], #4
 8005474:	e7e8      	b.n	8005448 <strcmp_unaligned+0x48>
 8005476:	ea4f 2515 	mov.w	r5, r5, lsr #8
 800547a:	e05c      	b.n	8005536 <strcmp_unaligned+0x136>
 800547c:	f033 437f 	bics.w	r3, r3, #4278190080	; 0xff000000
 8005480:	d152      	bne.n	8005528 <strcmp_unaligned+0x128>
 8005482:	780d      	ldrb	r5, [r1, #0]
 8005484:	ea4f 6c14 	mov.w	ip, r4, lsr #24
 8005488:	e055      	b.n	8005536 <strcmp_unaligned+0x136>
 800548a:	ea4f 6c14 	mov.w	ip, r4, lsr #24
 800548e:	f005 05ff 	and.w	r5, r5, #255	; 0xff
 8005492:	e050      	b.n	8005536 <strcmp_unaligned+0x136>
 8005494:	ea4f 4c04 	mov.w	ip, r4, lsl #16
 8005498:	eba4 0302 	sub.w	r3, r4, r2
 800549c:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 80054a0:	ea23 0304 	bic.w	r3, r3, r4
 80054a4:	ebbc 4f15 	cmp.w	ip, r5, lsr #16
 80054a8:	d117      	bne.n	80054da <strcmp_unaligned+0xda>
 80054aa:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 80054ae:	bf08      	it	eq
 80054b0:	f851 5b04 	ldreq.w	r5, [r1], #4
 80054b4:	d107      	bne.n	80054c6 <strcmp_unaligned+0xc6>
 80054b6:	ea8c 0c04 	eor.w	ip, ip, r4
 80054ba:	ebbc 4f05 	cmp.w	ip, r5, lsl #16
 80054be:	d108      	bne.n	80054d2 <strcmp_unaligned+0xd2>
 80054c0:	f850 4b04 	ldr.w	r4, [r0], #4
 80054c4:	e7e6      	b.n	8005494 <strcmp_unaligned+0x94>
 80054c6:	041b      	lsls	r3, r3, #16
 80054c8:	d12e      	bne.n	8005528 <strcmp_unaligned+0x128>
 80054ca:	880d      	ldrh	r5, [r1, #0]
 80054cc:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 80054d0:	e031      	b.n	8005536 <strcmp_unaligned+0x136>
 80054d2:	ea4f 4505 	mov.w	r5, r5, lsl #16
 80054d6:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 80054da:	ea4f 4515 	mov.w	r5, r5, lsr #16
 80054de:	e02a      	b.n	8005536 <strcmp_unaligned+0x136>
 80054e0:	f004 0cff 	and.w	ip, r4, #255	; 0xff
 80054e4:	ebbc 6f15 	cmp.w	ip, r5, lsr #24
 80054e8:	eba4 0302 	sub.w	r3, r4, r2
 80054ec:	ea23 0304 	bic.w	r3, r3, r4
 80054f0:	d10d      	bne.n	800550e <strcmp_unaligned+0x10e>
 80054f2:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 80054f6:	bf08      	it	eq
 80054f8:	f851 5b04 	ldreq.w	r5, [r1], #4
 80054fc:	d10a      	bne.n	8005514 <strcmp_unaligned+0x114>
 80054fe:	ea8c 0c04 	eor.w	ip, ip, r4
 8005502:	ebbc 2f05 	cmp.w	ip, r5, lsl #8
 8005506:	d10a      	bne.n	800551e <strcmp_unaligned+0x11e>
 8005508:	f850 4b04 	ldr.w	r4, [r0], #4
 800550c:	e7e8      	b.n	80054e0 <strcmp_unaligned+0xe0>
 800550e:	ea4f 6515 	mov.w	r5, r5, lsr #24
 8005512:	e010      	b.n	8005536 <strcmp_unaligned+0x136>
 8005514:	f014 0fff 	tst.w	r4, #255	; 0xff
 8005518:	d006      	beq.n	8005528 <strcmp_unaligned+0x128>
 800551a:	f851 5b04 	ldr.w	r5, [r1], #4
 800551e:	ea4f 2c14 	mov.w	ip, r4, lsr #8
 8005522:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
 8005526:	e006      	b.n	8005536 <strcmp_unaligned+0x136>
 8005528:	f04f 0000 	mov.w	r0, #0
 800552c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005530:	f85d 5b04 	ldr.w	r5, [sp], #4
 8005534:	4770      	bx	lr
 8005536:	f00c 02ff 	and.w	r2, ip, #255	; 0xff
 800553a:	f005 00ff 	and.w	r0, r5, #255	; 0xff
 800553e:	2801      	cmp	r0, #1
 8005540:	bf28      	it	cs
 8005542:	4290      	cmpcs	r0, r2
 8005544:	bf04      	itt	eq
 8005546:	ea4f 2c1c 	moveq.w	ip, ip, lsr #8
 800554a:	0a2d      	lsreq	r5, r5, #8
 800554c:	d0f3      	beq.n	8005536 <strcmp_unaligned+0x136>
 800554e:	eba2 0000 	sub.w	r0, r2, r0
 8005552:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005556:	f85d 5b04 	ldr.w	r5, [sp], #4
 800555a:	4770      	bx	lr

0800555c <_vsprintf_r>:
 800555c:	b570      	push	{r4, r5, r6, lr}
 800555e:	b09a      	sub	sp, #104	; 0x68
 8005560:	460d      	mov	r5, r1
 8005562:	4669      	mov	r1, sp
 8005564:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
 8005568:	f44f 7602 	mov.w	r6, #520	; 0x208
 800556c:	9500      	str	r5, [sp, #0]
 800556e:	f8ad 600c 	strh.w	r6, [sp, #12]
 8005572:	f04f 36ff 	mov.w	r6, #4294967295
 8005576:	9504      	str	r5, [sp, #16]
 8005578:	f8ad 600e 	strh.w	r6, [sp, #14]
 800557c:	9402      	str	r4, [sp, #8]
 800557e:	9405      	str	r4, [sp, #20]
 8005580:	f000 fc32 	bl	8005de8 <_svfprintf_r>
 8005584:	9b00      	ldr	r3, [sp, #0]
 8005586:	2200      	movs	r2, #0
 8005588:	701a      	strb	r2, [r3, #0]
 800558a:	b01a      	add	sp, #104	; 0x68
 800558c:	bd70      	pop	{r4, r5, r6, pc}
 800558e:	bf00      	nop

08005590 <vsprintf>:
 8005590:	b430      	push	{r4, r5}
 8005592:	f240 246c 	movw	r4, #620	; 0x26c
 8005596:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800559a:	460d      	mov	r5, r1
 800559c:	4613      	mov	r3, r2
 800559e:	4601      	mov	r1, r0
 80055a0:	462a      	mov	r2, r5
 80055a2:	6820      	ldr	r0, [r4, #0]
 80055a4:	bc30      	pop	{r4, r5}
 80055a6:	e7d9      	b.n	800555c <_vsprintf_r>

080055a8 <_fflush_r>:
 80055a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80055ac:	460c      	mov	r4, r1
 80055ae:	690e      	ldr	r6, [r1, #16]
 80055b0:	4680      	mov	r8, r0
 80055b2:	2e00      	cmp	r6, #0
 80055b4:	d04a      	beq.n	800564c <_fflush_r+0xa4>
 80055b6:	b118      	cbz	r0, 80055c0 <_fflush_r+0x18>
 80055b8:	6983      	ldr	r3, [r0, #24]
 80055ba:	2b00      	cmp	r3, #0
 80055bc:	f000 808e 	beq.w	80056dc <_fflush_r+0x134>
 80055c0:	f24b 736c 	movw	r3, #46956	; 0xb76c
 80055c4:	f6c0 0300 	movt	r3, #2048	; 0x800
 80055c8:	429c      	cmp	r4, r3
 80055ca:	bf08      	it	eq
 80055cc:	f8d8 4004 	ldreq.w	r4, [r8, #4]
 80055d0:	d010      	beq.n	80055f4 <_fflush_r+0x4c>
 80055d2:	f24b 738c 	movw	r3, #46988	; 0xb78c
 80055d6:	f6c0 0300 	movt	r3, #2048	; 0x800
 80055da:	429c      	cmp	r4, r3
 80055dc:	bf08      	it	eq
 80055de:	f8d8 4008 	ldreq.w	r4, [r8, #8]
 80055e2:	d007      	beq.n	80055f4 <_fflush_r+0x4c>
 80055e4:	f24b 73ac 	movw	r3, #47020	; 0xb7ac
 80055e8:	f6c0 0300 	movt	r3, #2048	; 0x800
 80055ec:	429c      	cmp	r4, r3
 80055ee:	bf08      	it	eq
 80055f0:	f8d8 400c 	ldreq.w	r4, [r8, #12]
 80055f4:	89a6      	ldrh	r6, [r4, #12]
 80055f6:	2e00      	cmp	r6, #0
 80055f8:	d028      	beq.n	800564c <_fflush_r+0xa4>
 80055fa:	b233      	sxth	r3, r6
 80055fc:	f013 0008 	ands.w	r0, r3, #8
 8005600:	d027      	beq.n	8005652 <_fflush_r+0xaa>
 8005602:	6926      	ldr	r6, [r4, #16]
 8005604:	b316      	cbz	r6, 800564c <_fflush_r+0xa4>
 8005606:	f013 0f03 	tst.w	r3, #3
 800560a:	6825      	ldr	r5, [r4, #0]
 800560c:	6026      	str	r6, [r4, #0]
 800560e:	bf08      	it	eq
 8005610:	6963      	ldreq	r3, [r4, #20]
 8005612:	ebc6 0505 	rsb	r5, r6, r5
 8005616:	bf18      	it	ne
 8005618:	2300      	movne	r3, #0
 800561a:	2d00      	cmp	r5, #0
 800561c:	60a3      	str	r3, [r4, #8]
 800561e:	dc02      	bgt.n	8005626 <_fflush_r+0x7e>
 8005620:	e09a      	b.n	8005758 <_fflush_r+0x1b0>
 8005622:	2d00      	cmp	r5, #0
 8005624:	dd74      	ble.n	8005710 <_fflush_r+0x168>
 8005626:	4632      	mov	r2, r6
 8005628:	462b      	mov	r3, r5
 800562a:	6aa7      	ldr	r7, [r4, #40]	; 0x28
 800562c:	4640      	mov	r0, r8
 800562e:	6a21      	ldr	r1, [r4, #32]
 8005630:	47b8      	blx	r7
 8005632:	2800      	cmp	r0, #0
 8005634:	ebc0 0505 	rsb	r5, r0, r5
 8005638:	4406      	add	r6, r0
 800563a:	dcf2      	bgt.n	8005622 <_fflush_r+0x7a>
 800563c:	89a3      	ldrh	r3, [r4, #12]
 800563e:	f04f 30ff 	mov.w	r0, #4294967295
 8005642:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005646:	81a3      	strh	r3, [r4, #12]
 8005648:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800564c:	4630      	mov	r0, r6
 800564e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005652:	6862      	ldr	r2, [r4, #4]
 8005654:	f446 6300 	orr.w	r3, r6, #2048	; 0x800
 8005658:	81a3      	strh	r3, [r4, #12]
 800565a:	2a00      	cmp	r2, #0
 800565c:	dd5b      	ble.n	8005716 <_fflush_r+0x16e>
 800565e:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8005660:	2e00      	cmp	r6, #0
 8005662:	d0f3      	beq.n	800564c <_fflush_r+0xa4>
 8005664:	b29b      	uxth	r3, r3
 8005666:	2200      	movs	r2, #0
 8005668:	f413 5780 	ands.w	r7, r3, #4096	; 0x1000
 800566c:	f8d8 5000 	ldr.w	r5, [r8]
 8005670:	f8c8 2000 	str.w	r2, [r8]
 8005674:	bf18      	it	ne
 8005676:	6d62      	ldrne	r2, [r4, #84]	; 0x54
 8005678:	d033      	beq.n	80056e2 <_fflush_r+0x13a>
 800567a:	f013 0f04 	tst.w	r3, #4
 800567e:	d005      	beq.n	800568c <_fflush_r+0xe4>
 8005680:	6861      	ldr	r1, [r4, #4]
 8005682:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005684:	1a52      	subs	r2, r2, r1
 8005686:	b10b      	cbz	r3, 800568c <_fflush_r+0xe4>
 8005688:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800568a:	1ad2      	subs	r2, r2, r3
 800568c:	2300      	movs	r3, #0
 800568e:	4640      	mov	r0, r8
 8005690:	6a21      	ldr	r1, [r4, #32]
 8005692:	47b0      	blx	r6
 8005694:	f1b0 3fff 	cmp.w	r0, #4294967295
 8005698:	d02f      	beq.n	80056fa <_fflush_r+0x152>
 800569a:	89a3      	ldrh	r3, [r4, #12]
 800569c:	2100      	movs	r1, #0
 800569e:	6922      	ldr	r2, [r4, #16]
 80056a0:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80056a4:	6061      	str	r1, [r4, #4]
 80056a6:	041b      	lsls	r3, r3, #16
 80056a8:	6022      	str	r2, [r4, #0]
 80056aa:	0c1b      	lsrs	r3, r3, #16
 80056ac:	81a3      	strh	r3, [r4, #12]
 80056ae:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 80056b2:	d003      	beq.n	80056bc <_fflush_r+0x114>
 80056b4:	f1b0 3fff 	cmp.w	r0, #4294967295
 80056b8:	d031      	beq.n	800571e <_fflush_r+0x176>
 80056ba:	6560      	str	r0, [r4, #84]	; 0x54
 80056bc:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80056be:	f8c8 5000 	str.w	r5, [r8]
 80056c2:	2900      	cmp	r1, #0
 80056c4:	d031      	beq.n	800572a <_fflush_r+0x182>
 80056c6:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80056ca:	4299      	cmp	r1, r3
 80056cc:	d002      	beq.n	80056d4 <_fflush_r+0x12c>
 80056ce:	4640      	mov	r0, r8
 80056d0:	f000 f9c4 	bl	8005a5c <_free_r>
 80056d4:	2000      	movs	r0, #0
 80056d6:	6360      	str	r0, [r4, #52]	; 0x34
 80056d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80056dc:	f000 f882 	bl	80057e4 <__sinit>
 80056e0:	e76e      	b.n	80055c0 <_fflush_r+0x18>
 80056e2:	463a      	mov	r2, r7
 80056e4:	2301      	movs	r3, #1
 80056e6:	4640      	mov	r0, r8
 80056e8:	6a21      	ldr	r1, [r4, #32]
 80056ea:	47b0      	blx	r6
 80056ec:	f1b0 3fff 	cmp.w	r0, #4294967295
 80056f0:	4602      	mov	r2, r0
 80056f2:	d01d      	beq.n	8005730 <_fflush_r+0x188>
 80056f4:	89a3      	ldrh	r3, [r4, #12]
 80056f6:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 80056f8:	e7bf      	b.n	800567a <_fflush_r+0xd2>
 80056fa:	f8d8 3000 	ldr.w	r3, [r8]
 80056fe:	2b1d      	cmp	r3, #29
 8005700:	d89c      	bhi.n	800563c <_fflush_r+0x94>
 8005702:	f44f 7201 	mov.w	r2, #516	; 0x204
 8005706:	f2c8 0200 	movt	r2, #32768	; 0x8000
 800570a:	409a      	lsls	r2, r3
 800570c:	d4c5      	bmi.n	800569a <_fflush_r+0xf2>
 800570e:	e795      	b.n	800563c <_fflush_r+0x94>
 8005710:	2000      	movs	r0, #0
 8005712:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005716:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8005718:	2a00      	cmp	r2, #0
 800571a:	dca0      	bgt.n	800565e <_fflush_r+0xb6>
 800571c:	e7f9      	b.n	8005712 <_fflush_r+0x16a>
 800571e:	f8d8 3000 	ldr.w	r3, [r8]
 8005722:	2b00      	cmp	r3, #0
 8005724:	d1ca      	bne.n	80056bc <_fflush_r+0x114>
 8005726:	6560      	str	r0, [r4, #84]	; 0x54
 8005728:	e7c8      	b.n	80056bc <_fflush_r+0x114>
 800572a:	4608      	mov	r0, r1
 800572c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005730:	f8d8 3000 	ldr.w	r3, [r8]
 8005734:	2b00      	cmp	r3, #0
 8005736:	d0dd      	beq.n	80056f4 <_fflush_r+0x14c>
 8005738:	f1a3 021d 	sub.w	r2, r3, #29
 800573c:	4251      	negs	r1, r2
 800573e:	eb41 0102 	adc.w	r1, r1, r2
 8005742:	2b16      	cmp	r3, #22
 8005744:	bf14      	ite	ne
 8005746:	460b      	movne	r3, r1
 8005748:	f041 0301 	orreq.w	r3, r1, #1
 800574c:	b13b      	cbz	r3, 800575e <_fflush_r+0x1b6>
 800574e:	f8c8 5000 	str.w	r5, [r8]
 8005752:	4638      	mov	r0, r7
 8005754:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005758:	2000      	movs	r0, #0
 800575a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800575e:	89a3      	ldrh	r3, [r4, #12]
 8005760:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005764:	81a3      	strh	r3, [r4, #12]
 8005766:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800576a:	bf00      	nop

0800576c <fflush>:
 800576c:	b130      	cbz	r0, 800577c <fflush+0x10>
 800576e:	f240 236c 	movw	r3, #620	; 0x26c
 8005772:	4601      	mov	r1, r0
 8005774:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005778:	6818      	ldr	r0, [r3, #0]
 800577a:	e715      	b.n	80055a8 <_fflush_r>
 800577c:	f24b 7368 	movw	r3, #46952	; 0xb768
 8005780:	f245 51a9 	movw	r1, #21929	; 0x55a9
 8005784:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005788:	f6c0 0100 	movt	r1, #2048	; 0x800
 800578c:	6818      	ldr	r0, [r3, #0]
 800578e:	f000 ba5b 	b.w	8005c48 <_fwalk_reent>
 8005792:	bf00      	nop

08005794 <__fp_lock>:
 8005794:	2000      	movs	r0, #0
 8005796:	4770      	bx	lr

08005798 <__fp_unlock>:
 8005798:	2000      	movs	r0, #0
 800579a:	4770      	bx	lr

0800579c <_cleanup_r>:
 800579c:	f248 511d 	movw	r1, #34077	; 0x851d
 80057a0:	f6c0 0100 	movt	r1, #2048	; 0x800
 80057a4:	f000 ba26 	b.w	8005bf4 <_fwalk>

080057a8 <__sfmoreglue>:
 80057a8:	b570      	push	{r4, r5, r6, lr}
 80057aa:	2568      	movs	r5, #104	; 0x68
 80057ac:	460e      	mov	r6, r1
 80057ae:	fb05 f501 	mul.w	r5, r5, r1
 80057b2:	f105 010c 	add.w	r1, r5, #12
 80057b6:	f7ff fa6f 	bl	8004c98 <_malloc_r>
 80057ba:	4604      	mov	r4, r0
 80057bc:	b148      	cbz	r0, 80057d2 <__sfmoreglue+0x2a>
 80057be:	f100 030c 	add.w	r3, r0, #12
 80057c2:	2100      	movs	r1, #0
 80057c4:	6046      	str	r6, [r0, #4]
 80057c6:	462a      	mov	r2, r5
 80057c8:	4618      	mov	r0, r3
 80057ca:	6021      	str	r1, [r4, #0]
 80057cc:	60a3      	str	r3, [r4, #8]
 80057ce:	f000 fa67 	bl	8005ca0 <memset>
 80057d2:	4620      	mov	r0, r4
 80057d4:	bd70      	pop	{r4, r5, r6, pc}
 80057d6:	bf00      	nop

080057d8 <_cleanup>:
 80057d8:	f24b 7368 	movw	r3, #46952	; 0xb768
 80057dc:	f6c0 0300 	movt	r3, #2048	; 0x800
 80057e0:	6818      	ldr	r0, [r3, #0]
 80057e2:	e7db      	b.n	800579c <_cleanup_r>

080057e4 <__sinit>:
 80057e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80057e8:	4605      	mov	r5, r0
 80057ea:	6984      	ldr	r4, [r0, #24]
 80057ec:	b083      	sub	sp, #12
 80057ee:	2c00      	cmp	r4, #0
 80057f0:	d178      	bne.n	80058e4 <__sinit+0x100>
 80057f2:	f245 729d 	movw	r2, #22429	; 0x579d
 80057f6:	2301      	movs	r3, #1
 80057f8:	f6c0 0200 	movt	r2, #2048	; 0x800
 80057fc:	6183      	str	r3, [r0, #24]
 80057fe:	6282      	str	r2, [r0, #40]	; 0x28
 8005800:	f645 5955 	movw	r9, #23893	; 0x5d55
 8005804:	f8c0 40d8 	str.w	r4, [r0, #216]	; 0xd8
 8005808:	f645 587d 	movw	r8, #23933	; 0x5d7d
 800580c:	f8c0 40dc 	str.w	r4, [r0, #220]	; 0xdc
 8005810:	f645 5ab9 	movw	sl, #23993	; 0x5db9
 8005814:	f8c0 40e0 	str.w	r4, [r0, #224]	; 0xe0
 8005818:	f645 5be1 	movw	fp, #24033	; 0x5de1
 800581c:	9301      	str	r3, [sp, #4]
 800581e:	f000 f865 	bl	80058ec <__sfp>
 8005822:	f6c0 0900 	movt	r9, #2048	; 0x800
 8005826:	f6c0 0800 	movt	r8, #2048	; 0x800
 800582a:	f6c0 0a00 	movt	sl, #2048	; 0x800
 800582e:	f6c0 0b00 	movt	fp, #2048	; 0x800
 8005832:	6068      	str	r0, [r5, #4]
 8005834:	4628      	mov	r0, r5
 8005836:	f000 f859 	bl	80058ec <__sfp>
 800583a:	60a8      	str	r0, [r5, #8]
 800583c:	4628      	mov	r0, r5
 800583e:	f000 f855 	bl	80058ec <__sfp>
 8005842:	686f      	ldr	r7, [r5, #4]
 8005844:	4621      	mov	r1, r4
 8005846:	2208      	movs	r2, #8
 8005848:	60e8      	str	r0, [r5, #12]
 800584a:	2004      	movs	r0, #4
 800584c:	603c      	str	r4, [r7, #0]
 800584e:	81b8      	strh	r0, [r7, #12]
 8005850:	f107 005c 	add.w	r0, r7, #92	; 0x5c
 8005854:	607c      	str	r4, [r7, #4]
 8005856:	60bc      	str	r4, [r7, #8]
 8005858:	667c      	str	r4, [r7, #100]	; 0x64
 800585a:	81fc      	strh	r4, [r7, #14]
 800585c:	613c      	str	r4, [r7, #16]
 800585e:	617c      	str	r4, [r7, #20]
 8005860:	61bc      	str	r4, [r7, #24]
 8005862:	f000 fa1d 	bl	8005ca0 <memset>
 8005866:	68ae      	ldr	r6, [r5, #8]
 8005868:	9b01      	ldr	r3, [sp, #4]
 800586a:	4621      	mov	r1, r4
 800586c:	2208      	movs	r2, #8
 800586e:	2009      	movs	r0, #9
 8005870:	623f      	str	r7, [r7, #32]
 8005872:	81b0      	strh	r0, [r6, #12]
 8005874:	f106 005c 	add.w	r0, r6, #92	; 0x5c
 8005878:	81f3      	strh	r3, [r6, #14]
 800587a:	f8c7 9024 	str.w	r9, [r7, #36]	; 0x24
 800587e:	f8c7 8028 	str.w	r8, [r7, #40]	; 0x28
 8005882:	f8c7 a02c 	str.w	sl, [r7, #44]	; 0x2c
 8005886:	f8c7 b030 	str.w	fp, [r7, #48]	; 0x30
 800588a:	6034      	str	r4, [r6, #0]
 800588c:	6074      	str	r4, [r6, #4]
 800588e:	60b4      	str	r4, [r6, #8]
 8005890:	6674      	str	r4, [r6, #100]	; 0x64
 8005892:	6134      	str	r4, [r6, #16]
 8005894:	6174      	str	r4, [r6, #20]
 8005896:	61b4      	str	r4, [r6, #24]
 8005898:	f000 fa02 	bl	8005ca0 <memset>
 800589c:	68ed      	ldr	r5, [r5, #12]
 800589e:	2312      	movs	r3, #18
 80058a0:	2002      	movs	r0, #2
 80058a2:	6236      	str	r6, [r6, #32]
 80058a4:	4621      	mov	r1, r4
 80058a6:	81e8      	strh	r0, [r5, #14]
 80058a8:	2208      	movs	r2, #8
 80058aa:	f8c6 9024 	str.w	r9, [r6, #36]	; 0x24
 80058ae:	f105 005c 	add.w	r0, r5, #92	; 0x5c
 80058b2:	81ab      	strh	r3, [r5, #12]
 80058b4:	f8c6 8028 	str.w	r8, [r6, #40]	; 0x28
 80058b8:	f8c6 a02c 	str.w	sl, [r6, #44]	; 0x2c
 80058bc:	f8c6 b030 	str.w	fp, [r6, #48]	; 0x30
 80058c0:	602c      	str	r4, [r5, #0]
 80058c2:	606c      	str	r4, [r5, #4]
 80058c4:	60ac      	str	r4, [r5, #8]
 80058c6:	666c      	str	r4, [r5, #100]	; 0x64
 80058c8:	612c      	str	r4, [r5, #16]
 80058ca:	616c      	str	r4, [r5, #20]
 80058cc:	61ac      	str	r4, [r5, #24]
 80058ce:	f000 f9e7 	bl	8005ca0 <memset>
 80058d2:	622d      	str	r5, [r5, #32]
 80058d4:	f8c5 9024 	str.w	r9, [r5, #36]	; 0x24
 80058d8:	f8c5 8028 	str.w	r8, [r5, #40]	; 0x28
 80058dc:	f8c5 a02c 	str.w	sl, [r5, #44]	; 0x2c
 80058e0:	f8c5 b030 	str.w	fp, [r5, #48]	; 0x30
 80058e4:	b003      	add	sp, #12
 80058e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80058ea:	bf00      	nop

080058ec <__sfp>:
 80058ec:	f24b 7368 	movw	r3, #46952	; 0xb768
 80058f0:	f6c0 0300 	movt	r3, #2048	; 0x800
 80058f4:	b570      	push	{r4, r5, r6, lr}
 80058f6:	4606      	mov	r6, r0
 80058f8:	681d      	ldr	r5, [r3, #0]
 80058fa:	69ab      	ldr	r3, [r5, #24]
 80058fc:	2b00      	cmp	r3, #0
 80058fe:	d029      	beq.n	8005954 <__sfp+0x68>
 8005900:	35d8      	adds	r5, #216	; 0xd8
 8005902:	686b      	ldr	r3, [r5, #4]
 8005904:	68ac      	ldr	r4, [r5, #8]
 8005906:	3b01      	subs	r3, #1
 8005908:	d503      	bpl.n	8005912 <__sfp+0x26>
 800590a:	e01f      	b.n	800594c <__sfp+0x60>
 800590c:	3468      	adds	r4, #104	; 0x68
 800590e:	3b01      	subs	r3, #1
 8005910:	d31c      	bcc.n	800594c <__sfp+0x60>
 8005912:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8005916:	2a00      	cmp	r2, #0
 8005918:	d1f8      	bne.n	800590c <__sfp+0x20>
 800591a:	2500      	movs	r5, #0
 800591c:	f04f 33ff 	mov.w	r3, #4294967295
 8005920:	6665      	str	r5, [r4, #100]	; 0x64
 8005922:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8005926:	81e3      	strh	r3, [r4, #14]
 8005928:	4629      	mov	r1, r5
 800592a:	2301      	movs	r3, #1
 800592c:	6025      	str	r5, [r4, #0]
 800592e:	81a3      	strh	r3, [r4, #12]
 8005930:	2208      	movs	r2, #8
 8005932:	60a5      	str	r5, [r4, #8]
 8005934:	6065      	str	r5, [r4, #4]
 8005936:	6125      	str	r5, [r4, #16]
 8005938:	6165      	str	r5, [r4, #20]
 800593a:	61a5      	str	r5, [r4, #24]
 800593c:	f000 f9b0 	bl	8005ca0 <memset>
 8005940:	6365      	str	r5, [r4, #52]	; 0x34
 8005942:	63a5      	str	r5, [r4, #56]	; 0x38
 8005944:	64a5      	str	r5, [r4, #72]	; 0x48
 8005946:	64e5      	str	r5, [r4, #76]	; 0x4c
 8005948:	4620      	mov	r0, r4
 800594a:	bd70      	pop	{r4, r5, r6, pc}
 800594c:	6828      	ldr	r0, [r5, #0]
 800594e:	b128      	cbz	r0, 800595c <__sfp+0x70>
 8005950:	4605      	mov	r5, r0
 8005952:	e7d6      	b.n	8005902 <__sfp+0x16>
 8005954:	4628      	mov	r0, r5
 8005956:	f7ff ff45 	bl	80057e4 <__sinit>
 800595a:	e7d1      	b.n	8005900 <__sfp+0x14>
 800595c:	4630      	mov	r0, r6
 800595e:	2104      	movs	r1, #4
 8005960:	f7ff ff22 	bl	80057a8 <__sfmoreglue>
 8005964:	6028      	str	r0, [r5, #0]
 8005966:	2800      	cmp	r0, #0
 8005968:	d1f2      	bne.n	8005950 <__sfp+0x64>
 800596a:	230c      	movs	r3, #12
 800596c:	4604      	mov	r4, r0
 800596e:	6033      	str	r3, [r6, #0]
 8005970:	e7ea      	b.n	8005948 <__sfp+0x5c>
 8005972:	bf00      	nop

08005974 <__sfp_lock_acquire>:
 8005974:	4770      	bx	lr
 8005976:	bf00      	nop

08005978 <__sfp_lock_release>:
 8005978:	4770      	bx	lr
 800597a:	bf00      	nop

0800597c <__sinit_lock_acquire>:
 800597c:	4770      	bx	lr
 800597e:	bf00      	nop

08005980 <__sinit_lock_release>:
 8005980:	4770      	bx	lr
 8005982:	bf00      	nop

08005984 <__fp_lock_all>:
 8005984:	f240 236c 	movw	r3, #620	; 0x26c
 8005988:	f245 7195 	movw	r1, #22421	; 0x5795
 800598c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005990:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005994:	6818      	ldr	r0, [r3, #0]
 8005996:	f000 b92d 	b.w	8005bf4 <_fwalk>
 800599a:	bf00      	nop

0800599c <__fp_unlock_all>:
 800599c:	f240 236c 	movw	r3, #620	; 0x26c
 80059a0:	f245 7199 	movw	r1, #22425	; 0x5799
 80059a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80059a8:	f6c0 0100 	movt	r1, #2048	; 0x800
 80059ac:	6818      	ldr	r0, [r3, #0]
 80059ae:	f000 b921 	b.w	8005bf4 <_fwalk>
 80059b2:	bf00      	nop

080059b4 <_malloc_trim_r>:
 80059b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80059b6:	f240 3460 	movw	r4, #864	; 0x360
 80059ba:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80059be:	460f      	mov	r7, r1
 80059c0:	4605      	mov	r5, r0
 80059c2:	f7ff fc27 	bl	8005214 <__malloc_lock>
 80059c6:	68a3      	ldr	r3, [r4, #8]
 80059c8:	685e      	ldr	r6, [r3, #4]
 80059ca:	f026 0603 	bic.w	r6, r6, #3
 80059ce:	f506 637e 	add.w	r3, r6, #4064	; 0xfe0
 80059d2:	330f      	adds	r3, #15
 80059d4:	1bdf      	subs	r7, r3, r7
 80059d6:	0b3f      	lsrs	r7, r7, #12
 80059d8:	3f01      	subs	r7, #1
 80059da:	033f      	lsls	r7, r7, #12
 80059dc:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
 80059e0:	db07      	blt.n	80059f2 <_malloc_trim_r+0x3e>
 80059e2:	2100      	movs	r1, #0
 80059e4:	4628      	mov	r0, r5
 80059e6:	f7fb f81b 	bl	8000a20 <_sbrk_r>
 80059ea:	68a3      	ldr	r3, [r4, #8]
 80059ec:	199b      	adds	r3, r3, r6
 80059ee:	4298      	cmp	r0, r3
 80059f0:	d004      	beq.n	80059fc <_malloc_trim_r+0x48>
 80059f2:	4628      	mov	r0, r5
 80059f4:	f7ff fc10 	bl	8005218 <__malloc_unlock>
 80059f8:	2000      	movs	r0, #0
 80059fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80059fc:	4279      	negs	r1, r7
 80059fe:	4628      	mov	r0, r5
 8005a00:	f7fb f80e 	bl	8000a20 <_sbrk_r>
 8005a04:	f1b0 3fff 	cmp.w	r0, #4294967295
 8005a08:	d010      	beq.n	8005a2c <_malloc_trim_r+0x78>
 8005a0a:	f640 23f8 	movw	r3, #2808	; 0xaf8
 8005a0e:	68a1      	ldr	r1, [r4, #8]
 8005a10:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a14:	1bf6      	subs	r6, r6, r7
 8005a16:	4628      	mov	r0, r5
 8005a18:	f046 0601 	orr.w	r6, r6, #1
 8005a1c:	681a      	ldr	r2, [r3, #0]
 8005a1e:	604e      	str	r6, [r1, #4]
 8005a20:	1bd7      	subs	r7, r2, r7
 8005a22:	601f      	str	r7, [r3, #0]
 8005a24:	f7ff fbf8 	bl	8005218 <__malloc_unlock>
 8005a28:	2001      	movs	r0, #1
 8005a2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005a2c:	2100      	movs	r1, #0
 8005a2e:	4628      	mov	r0, r5
 8005a30:	f7fa fff6 	bl	8000a20 <_sbrk_r>
 8005a34:	68a3      	ldr	r3, [r4, #8]
 8005a36:	1ac2      	subs	r2, r0, r3
 8005a38:	2a0f      	cmp	r2, #15
 8005a3a:	ddda      	ble.n	80059f2 <_malloc_trim_r+0x3e>
 8005a3c:	f240 7468 	movw	r4, #1896	; 0x768
 8005a40:	f640 21f8 	movw	r1, #2808	; 0xaf8
 8005a44:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8005a48:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8005a4c:	f042 0201 	orr.w	r2, r2, #1
 8005a50:	605a      	str	r2, [r3, #4]
 8005a52:	6823      	ldr	r3, [r4, #0]
 8005a54:	1ac0      	subs	r0, r0, r3
 8005a56:	6008      	str	r0, [r1, #0]
 8005a58:	e7cb      	b.n	80059f2 <_malloc_trim_r+0x3e>
 8005a5a:	bf00      	nop

08005a5c <_free_r>:
 8005a5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005a60:	460d      	mov	r5, r1
 8005a62:	4604      	mov	r4, r0
 8005a64:	2900      	cmp	r1, #0
 8005a66:	d058      	beq.n	8005b1a <_free_r+0xbe>
 8005a68:	f7ff fbd4 	bl	8005214 <__malloc_lock>
 8005a6c:	f1a5 0208 	sub.w	r2, r5, #8
 8005a70:	f240 3060 	movw	r0, #864	; 0x360
 8005a74:	6856      	ldr	r6, [r2, #4]
 8005a76:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005a7a:	f026 0301 	bic.w	r3, r6, #1
 8005a7e:	f8d0 c008 	ldr.w	ip, [r0, #8]
 8005a82:	18d1      	adds	r1, r2, r3
 8005a84:	458c      	cmp	ip, r1
 8005a86:	684f      	ldr	r7, [r1, #4]
 8005a88:	f027 0703 	bic.w	r7, r7, #3
 8005a8c:	d065      	beq.n	8005b5a <_free_r+0xfe>
 8005a8e:	f016 0601 	ands.w	r6, r6, #1
 8005a92:	604f      	str	r7, [r1, #4]
 8005a94:	d031      	beq.n	8005afa <_free_r+0x9e>
 8005a96:	2600      	movs	r6, #0
 8005a98:	19cd      	adds	r5, r1, r7
 8005a9a:	686d      	ldr	r5, [r5, #4]
 8005a9c:	f015 0f01 	tst.w	r5, #1
 8005aa0:	d106      	bne.n	8005ab0 <_free_r+0x54>
 8005aa2:	19db      	adds	r3, r3, r7
 8005aa4:	2e00      	cmp	r6, #0
 8005aa6:	d04b      	beq.n	8005b40 <_free_r+0xe4>
 8005aa8:	688d      	ldr	r5, [r1, #8]
 8005aaa:	68c9      	ldr	r1, [r1, #12]
 8005aac:	60e9      	str	r1, [r5, #12]
 8005aae:	608d      	str	r5, [r1, #8]
 8005ab0:	f043 0101 	orr.w	r1, r3, #1
 8005ab4:	50d3      	str	r3, [r2, r3]
 8005ab6:	6051      	str	r1, [r2, #4]
 8005ab8:	b9d6      	cbnz	r6, 8005af0 <_free_r+0x94>
 8005aba:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8005abe:	d32e      	bcc.n	8005b1e <_free_r+0xc2>
 8005ac0:	0a59      	lsrs	r1, r3, #9
 8005ac2:	2904      	cmp	r1, #4
 8005ac4:	d86b      	bhi.n	8005b9e <_free_r+0x142>
 8005ac6:	099e      	lsrs	r6, r3, #6
 8005ac8:	3638      	adds	r6, #56	; 0x38
 8005aca:	00f5      	lsls	r5, r6, #3
 8005acc:	1945      	adds	r5, r0, r5
 8005ace:	68a9      	ldr	r1, [r5, #8]
 8005ad0:	42a9      	cmp	r1, r5
 8005ad2:	d103      	bne.n	8005adc <_free_r+0x80>
 8005ad4:	e069      	b.n	8005baa <_free_r+0x14e>
 8005ad6:	6889      	ldr	r1, [r1, #8]
 8005ad8:	428d      	cmp	r5, r1
 8005ada:	d004      	beq.n	8005ae6 <_free_r+0x8a>
 8005adc:	6848      	ldr	r0, [r1, #4]
 8005ade:	f020 0003 	bic.w	r0, r0, #3
 8005ae2:	4283      	cmp	r3, r0
 8005ae4:	d3f7      	bcc.n	8005ad6 <_free_r+0x7a>
 8005ae6:	68cb      	ldr	r3, [r1, #12]
 8005ae8:	60d3      	str	r3, [r2, #12]
 8005aea:	6091      	str	r1, [r2, #8]
 8005aec:	60ca      	str	r2, [r1, #12]
 8005aee:	609a      	str	r2, [r3, #8]
 8005af0:	4620      	mov	r0, r4
 8005af2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8005af6:	f7ff bb8f 	b.w	8005218 <__malloc_unlock>
 8005afa:	f855 5c08 	ldr.w	r5, [r5, #-8]
 8005afe:	f100 0c08 	add.w	ip, r0, #8
 8005b02:	1b52      	subs	r2, r2, r5
 8005b04:	195b      	adds	r3, r3, r5
 8005b06:	6895      	ldr	r5, [r2, #8]
 8005b08:	4565      	cmp	r5, ip
 8005b0a:	d046      	beq.n	8005b9a <_free_r+0x13e>
 8005b0c:	f8d2 c00c 	ldr.w	ip, [r2, #12]
 8005b10:	f8c5 c00c 	str.w	ip, [r5, #12]
 8005b14:	f8cc 5008 	str.w	r5, [ip, #8]
 8005b18:	e7be      	b.n	8005a98 <_free_r+0x3c>
 8005b1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005b1e:	08db      	lsrs	r3, r3, #3
 8005b20:	2501      	movs	r5, #1
 8005b22:	6846      	ldr	r6, [r0, #4]
 8005b24:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
 8005b28:	109b      	asrs	r3, r3, #2
 8005b2a:	fa15 f303 	lsls.w	r3, r5, r3
 8005b2e:	60d1      	str	r1, [r2, #12]
 8005b30:	688d      	ldr	r5, [r1, #8]
 8005b32:	ea46 0303 	orr.w	r3, r6, r3
 8005b36:	6043      	str	r3, [r0, #4]
 8005b38:	6095      	str	r5, [r2, #8]
 8005b3a:	60ea      	str	r2, [r5, #12]
 8005b3c:	608a      	str	r2, [r1, #8]
 8005b3e:	e7d7      	b.n	8005af0 <_free_r+0x94>
 8005b40:	688d      	ldr	r5, [r1, #8]
 8005b42:	4f2b      	ldr	r7, [pc, #172]	; (8005bf0 <_free_r+0x194>)
 8005b44:	42bd      	cmp	r5, r7
 8005b46:	d1b0      	bne.n	8005aaa <_free_r+0x4e>
 8005b48:	60ea      	str	r2, [r5, #12]
 8005b4a:	f043 0101 	orr.w	r1, r3, #1
 8005b4e:	60aa      	str	r2, [r5, #8]
 8005b50:	60d5      	str	r5, [r2, #12]
 8005b52:	6095      	str	r5, [r2, #8]
 8005b54:	6051      	str	r1, [r2, #4]
 8005b56:	50d3      	str	r3, [r2, r3]
 8005b58:	e7ca      	b.n	8005af0 <_free_r+0x94>
 8005b5a:	f016 0f01 	tst.w	r6, #1
 8005b5e:	443b      	add	r3, r7
 8005b60:	d107      	bne.n	8005b72 <_free_r+0x116>
 8005b62:	f855 1c08 	ldr.w	r1, [r5, #-8]
 8005b66:	1a52      	subs	r2, r2, r1
 8005b68:	185b      	adds	r3, r3, r1
 8005b6a:	6895      	ldr	r5, [r2, #8]
 8005b6c:	68d1      	ldr	r1, [r2, #12]
 8005b6e:	60e9      	str	r1, [r5, #12]
 8005b70:	608d      	str	r5, [r1, #8]
 8005b72:	f240 716c 	movw	r1, #1900	; 0x76c
 8005b76:	f043 0501 	orr.w	r5, r3, #1
 8005b7a:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8005b7e:	6055      	str	r5, [r2, #4]
 8005b80:	6082      	str	r2, [r0, #8]
 8005b82:	680a      	ldr	r2, [r1, #0]
 8005b84:	4293      	cmp	r3, r2
 8005b86:	d3b3      	bcc.n	8005af0 <_free_r+0x94>
 8005b88:	f640 23f4 	movw	r3, #2804	; 0xaf4
 8005b8c:	4620      	mov	r0, r4
 8005b8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b92:	6819      	ldr	r1, [r3, #0]
 8005b94:	f7ff ff0e 	bl	80059b4 <_malloc_trim_r>
 8005b98:	e7aa      	b.n	8005af0 <_free_r+0x94>
 8005b9a:	2601      	movs	r6, #1
 8005b9c:	e77c      	b.n	8005a98 <_free_r+0x3c>
 8005b9e:	2914      	cmp	r1, #20
 8005ba0:	d80c      	bhi.n	8005bbc <_free_r+0x160>
 8005ba2:	f101 065b 	add.w	r6, r1, #91	; 0x5b
 8005ba6:	00f5      	lsls	r5, r6, #3
 8005ba8:	e790      	b.n	8005acc <_free_r+0x70>
 8005baa:	2501      	movs	r5, #1
 8005bac:	6847      	ldr	r7, [r0, #4]
 8005bae:	10b6      	asrs	r6, r6, #2
 8005bb0:	460b      	mov	r3, r1
 8005bb2:	40b5      	lsls	r5, r6
 8005bb4:	ea47 0505 	orr.w	r5, r7, r5
 8005bb8:	6045      	str	r5, [r0, #4]
 8005bba:	e795      	b.n	8005ae8 <_free_r+0x8c>
 8005bbc:	2954      	cmp	r1, #84	; 0x54
 8005bbe:	d803      	bhi.n	8005bc8 <_free_r+0x16c>
 8005bc0:	0b1e      	lsrs	r6, r3, #12
 8005bc2:	366e      	adds	r6, #110	; 0x6e
 8005bc4:	00f5      	lsls	r5, r6, #3
 8005bc6:	e781      	b.n	8005acc <_free_r+0x70>
 8005bc8:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
 8005bcc:	d803      	bhi.n	8005bd6 <_free_r+0x17a>
 8005bce:	0bde      	lsrs	r6, r3, #15
 8005bd0:	3677      	adds	r6, #119	; 0x77
 8005bd2:	00f5      	lsls	r5, r6, #3
 8005bd4:	e77a      	b.n	8005acc <_free_r+0x70>
 8005bd6:	f240 5554 	movw	r5, #1364	; 0x554
 8005bda:	42a9      	cmp	r1, r5
 8005bdc:	d803      	bhi.n	8005be6 <_free_r+0x18a>
 8005bde:	0c9e      	lsrs	r6, r3, #18
 8005be0:	367c      	adds	r6, #124	; 0x7c
 8005be2:	00f5      	lsls	r5, r6, #3
 8005be4:	e772      	b.n	8005acc <_free_r+0x70>
 8005be6:	f44f 757c 	mov.w	r5, #1008	; 0x3f0
 8005bea:	267e      	movs	r6, #126	; 0x7e
 8005bec:	e76e      	b.n	8005acc <_free_r+0x70>
 8005bee:	bf00      	nop
 8005bf0:	20000368 	.word	0x20000368

08005bf4 <_fwalk>:
 8005bf4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8005bf8:	4607      	mov	r7, r0
 8005bfa:	4689      	mov	r9, r1
 8005bfc:	f7ff feba 	bl	8005974 <__sfp_lock_acquire>
 8005c00:	37d8      	adds	r7, #216	; 0xd8
 8005c02:	bf08      	it	eq
 8005c04:	46b8      	moveq	r8, r7
 8005c06:	d01a      	beq.n	8005c3e <_fwalk+0x4a>
 8005c08:	f04f 0800 	mov.w	r8, #0
 8005c0c:	687e      	ldr	r6, [r7, #4]
 8005c0e:	68bc      	ldr	r4, [r7, #8]
 8005c10:	2e00      	cmp	r6, #0
 8005c12:	dd11      	ble.n	8005c38 <_fwalk+0x44>
 8005c14:	2500      	movs	r5, #0
 8005c16:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8005c1a:	3501      	adds	r5, #1
 8005c1c:	b143      	cbz	r3, 8005c30 <_fwalk+0x3c>
 8005c1e:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 8005c22:	4620      	mov	r0, r4
 8005c24:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005c28:	d002      	beq.n	8005c30 <_fwalk+0x3c>
 8005c2a:	47c8      	blx	r9
 8005c2c:	ea48 0800 	orr.w	r8, r8, r0
 8005c30:	42b5      	cmp	r5, r6
 8005c32:	f104 0468 	add.w	r4, r4, #104	; 0x68
 8005c36:	d1ee      	bne.n	8005c16 <_fwalk+0x22>
 8005c38:	683f      	ldr	r7, [r7, #0]
 8005c3a:	2f00      	cmp	r7, #0
 8005c3c:	d1e6      	bne.n	8005c0c <_fwalk+0x18>
 8005c3e:	f7ff fe9b 	bl	8005978 <__sfp_lock_release>
 8005c42:	4640      	mov	r0, r8
 8005c44:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08005c48 <_fwalk_reent>:
 8005c48:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005c4c:	4680      	mov	r8, r0
 8005c4e:	468a      	mov	sl, r1
 8005c50:	f7ff fe90 	bl	8005974 <__sfp_lock_acquire>
 8005c54:	f118 07d8 	adds.w	r7, r8, #216	; 0xd8
 8005c58:	bf08      	it	eq
 8005c5a:	46b9      	moveq	r9, r7
 8005c5c:	d01b      	beq.n	8005c96 <_fwalk_reent+0x4e>
 8005c5e:	f04f 0900 	mov.w	r9, #0
 8005c62:	687e      	ldr	r6, [r7, #4]
 8005c64:	68bc      	ldr	r4, [r7, #8]
 8005c66:	2e00      	cmp	r6, #0
 8005c68:	dd12      	ble.n	8005c90 <_fwalk_reent+0x48>
 8005c6a:	2500      	movs	r5, #0
 8005c6c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8005c70:	3501      	adds	r5, #1
 8005c72:	b14b      	cbz	r3, 8005c88 <_fwalk_reent+0x40>
 8005c74:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 8005c78:	4621      	mov	r1, r4
 8005c7a:	4640      	mov	r0, r8
 8005c7c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005c80:	d002      	beq.n	8005c88 <_fwalk_reent+0x40>
 8005c82:	47d0      	blx	sl
 8005c84:	ea49 0900 	orr.w	r9, r9, r0
 8005c88:	42b5      	cmp	r5, r6
 8005c8a:	f104 0468 	add.w	r4, r4, #104	; 0x68
 8005c8e:	d1ed      	bne.n	8005c6c <_fwalk_reent+0x24>
 8005c90:	683f      	ldr	r7, [r7, #0]
 8005c92:	2f00      	cmp	r7, #0
 8005c94:	d1e5      	bne.n	8005c62 <_fwalk_reent+0x1a>
 8005c96:	f7ff fe6f 	bl	8005978 <__sfp_lock_release>
 8005c9a:	4648      	mov	r0, r9
 8005c9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08005ca0 <memset>:
 8005ca0:	2a03      	cmp	r2, #3
 8005ca2:	b2c9      	uxtb	r1, r1
 8005ca4:	b470      	push	{r4, r5, r6}
 8005ca6:	d808      	bhi.n	8005cba <memset+0x1a>
 8005ca8:	b12a      	cbz	r2, 8005cb6 <memset+0x16>
 8005caa:	4603      	mov	r3, r0
 8005cac:	1812      	adds	r2, r2, r0
 8005cae:	f803 1b01 	strb.w	r1, [r3], #1
 8005cb2:	4293      	cmp	r3, r2
 8005cb4:	d1fb      	bne.n	8005cae <memset+0xe>
 8005cb6:	bc70      	pop	{r4, r5, r6}
 8005cb8:	4770      	bx	lr
 8005cba:	1882      	adds	r2, r0, r2
 8005cbc:	4604      	mov	r4, r0
 8005cbe:	e001      	b.n	8005cc4 <memset+0x24>
 8005cc0:	f804 1b01 	strb.w	r1, [r4], #1
 8005cc4:	f014 0f03 	tst.w	r4, #3
 8005cc8:	d1fa      	bne.n	8005cc0 <memset+0x20>
 8005cca:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
 8005cce:	fb03 f301 	mul.w	r3, r3, r1
 8005cd2:	e01f      	b.n	8005d14 <memset+0x74>
 8005cd4:	f844 3c40 	str.w	r3, [r4, #-64]
 8005cd8:	f844 3c3c 	str.w	r3, [r4, #-60]
 8005cdc:	f844 3c38 	str.w	r3, [r4, #-56]
 8005ce0:	f844 3c34 	str.w	r3, [r4, #-52]
 8005ce4:	f844 3c30 	str.w	r3, [r4, #-48]
 8005ce8:	f844 3c2c 	str.w	r3, [r4, #-44]
 8005cec:	f844 3c28 	str.w	r3, [r4, #-40]
 8005cf0:	f844 3c24 	str.w	r3, [r4, #-36]
 8005cf4:	f844 3c20 	str.w	r3, [r4, #-32]
 8005cf8:	f844 3c1c 	str.w	r3, [r4, #-28]
 8005cfc:	f844 3c18 	str.w	r3, [r4, #-24]
 8005d00:	f844 3c14 	str.w	r3, [r4, #-20]
 8005d04:	f844 3c10 	str.w	r3, [r4, #-16]
 8005d08:	f844 3c0c 	str.w	r3, [r4, #-12]
 8005d0c:	f844 3c08 	str.w	r3, [r4, #-8]
 8005d10:	f844 3c04 	str.w	r3, [r4, #-4]
 8005d14:	1b16      	subs	r6, r2, r4
 8005d16:	4625      	mov	r5, r4
 8005d18:	3440      	adds	r4, #64	; 0x40
 8005d1a:	2e3f      	cmp	r6, #63	; 0x3f
 8005d1c:	dcda      	bgt.n	8005cd4 <memset+0x34>
 8005d1e:	462c      	mov	r4, r5
 8005d20:	e007      	b.n	8005d32 <memset+0x92>
 8005d22:	f844 3c10 	str.w	r3, [r4, #-16]
 8005d26:	f844 3c0c 	str.w	r3, [r4, #-12]
 8005d2a:	f844 3c08 	str.w	r3, [r4, #-8]
 8005d2e:	f844 3c04 	str.w	r3, [r4, #-4]
 8005d32:	1b16      	subs	r6, r2, r4
 8005d34:	4625      	mov	r5, r4
 8005d36:	3410      	adds	r4, #16
 8005d38:	2e0f      	cmp	r6, #15
 8005d3a:	dcf2      	bgt.n	8005d22 <memset+0x82>
 8005d3c:	e001      	b.n	8005d42 <memset+0xa2>
 8005d3e:	f845 3b04 	str.w	r3, [r5], #4
 8005d42:	1b54      	subs	r4, r2, r5
 8005d44:	2c03      	cmp	r4, #3
 8005d46:	dcfa      	bgt.n	8005d3e <memset+0x9e>
 8005d48:	e001      	b.n	8005d4e <memset+0xae>
 8005d4a:	f805 1b01 	strb.w	r1, [r5], #1
 8005d4e:	4295      	cmp	r5, r2
 8005d50:	d3fb      	bcc.n	8005d4a <memset+0xaa>
 8005d52:	e7b0      	b.n	8005cb6 <memset+0x16>

08005d54 <__sread>:
 8005d54:	b510      	push	{r4, lr}
 8005d56:	460c      	mov	r4, r1
 8005d58:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8005d5c:	f003 f9c8 	bl	80090f0 <_read_r>
 8005d60:	2800      	cmp	r0, #0
 8005d62:	bfab      	itete	ge
 8005d64:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8005d66:	89a3      	ldrhlt	r3, [r4, #12]
 8005d68:	181b      	addge	r3, r3, r0
 8005d6a:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8005d6e:	bfac      	ite	ge
 8005d70:	6563      	strge	r3, [r4, #84]	; 0x54
 8005d72:	81a3      	strhlt	r3, [r4, #12]
 8005d74:	bd10      	pop	{r4, pc}
 8005d76:	bf00      	nop

08005d78 <__seofread>:
 8005d78:	2000      	movs	r0, #0
 8005d7a:	4770      	bx	lr

08005d7c <__swrite>:
 8005d7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005d80:	461d      	mov	r5, r3
 8005d82:	898b      	ldrh	r3, [r1, #12]
 8005d84:	460c      	mov	r4, r1
 8005d86:	4607      	mov	r7, r0
 8005d88:	4616      	mov	r6, r2
 8005d8a:	f413 7f80 	tst.w	r3, #256	; 0x100
 8005d8e:	d006      	beq.n	8005d9e <__swrite+0x22>
 8005d90:	2302      	movs	r3, #2
 8005d92:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8005d96:	2200      	movs	r2, #0
 8005d98:	f002 fc18 	bl	80085cc <_lseek_r>
 8005d9c:	89a3      	ldrh	r3, [r4, #12]
 8005d9e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8005da2:	4638      	mov	r0, r7
 8005da4:	81a3      	strh	r3, [r4, #12]
 8005da6:	4632      	mov	r2, r6
 8005da8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8005dac:	462b      	mov	r3, r5
 8005dae:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8005db2:	f001 bb39 	b.w	8007428 <_write_r>
 8005db6:	bf00      	nop

08005db8 <__sseek>:
 8005db8:	b510      	push	{r4, lr}
 8005dba:	460c      	mov	r4, r1
 8005dbc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8005dc0:	f002 fc04 	bl	80085cc <_lseek_r>
 8005dc4:	89a3      	ldrh	r3, [r4, #12]
 8005dc6:	f1b0 3fff 	cmp.w	r0, #4294967295
 8005dca:	bf15      	itete	ne
 8005dcc:	6560      	strne	r0, [r4, #84]	; 0x54
 8005dce:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8005dd2:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8005dd6:	81a3      	strheq	r3, [r4, #12]
 8005dd8:	bf18      	it	ne
 8005dda:	81a3      	strhne	r3, [r4, #12]
 8005ddc:	bd10      	pop	{r4, pc}
 8005dde:	bf00      	nop

08005de0 <__sclose>:
 8005de0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8005de4:	f001 bb36 	b.w	8007454 <_close_r>

08005de8 <_svfprintf_r>:
 8005de8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005dec:	b0c5      	sub	sp, #276	; 0x114
 8005dee:	4614      	mov	r4, r2
 8005df0:	9312      	str	r3, [sp, #72]	; 0x48
 8005df2:	910c      	str	r1, [sp, #48]	; 0x30
 8005df4:	9011      	str	r0, [sp, #68]	; 0x44
 8005df6:	f002 fbd9 	bl	80085ac <_localeconv_r>
 8005dfa:	6800      	ldr	r0, [r0, #0]
 8005dfc:	9019      	str	r0, [sp, #100]	; 0x64
 8005dfe:	f003 fa61 	bl	80092c4 <strlen>
 8005e02:	901c      	str	r0, [sp, #112]	; 0x70
 8005e04:	980c      	ldr	r0, [sp, #48]	; 0x30
 8005e06:	8983      	ldrh	r3, [r0, #12]
 8005e08:	f013 0f80 	tst.w	r3, #128	; 0x80
 8005e0c:	d003      	beq.n	8005e16 <_svfprintf_r+0x2e>
 8005e0e:	6903      	ldr	r3, [r0, #16]
 8005e10:	2b00      	cmp	r3, #0
 8005e12:	f001 816f 	beq.w	80070f4 <_svfprintf_r+0x130c>
 8005e16:	f10d 0a7c 	add.w	sl, sp, #124	; 0x7c
 8005e1a:	2300      	movs	r3, #0
 8005e1c:	4656      	mov	r6, sl
 8005e1e:	f10d 01f7 	add.w	r1, sp, #247	; 0xf7
 8005e22:	930e      	str	r3, [sp, #56]	; 0x38
 8005e24:	9409      	str	r4, [sp, #36]	; 0x24
 8005e26:	931a      	str	r3, [sp, #104]	; 0x68
 8005e28:	931b      	str	r3, [sp, #108]	; 0x6c
 8005e2a:	9317      	str	r3, [sp, #92]	; 0x5c
 8005e2c:	931d      	str	r3, [sp, #116]	; 0x74
 8005e2e:	930f      	str	r3, [sp, #60]	; 0x3c
 8005e30:	9107      	str	r1, [sp, #28]
 8005e32:	f8cd a0e4 	str.w	sl, [sp, #228]	; 0xe4
 8005e36:	933b      	str	r3, [sp, #236]	; 0xec
 8005e38:	933a      	str	r3, [sp, #232]	; 0xe8
 8005e3a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8005e3c:	7813      	ldrb	r3, [r2, #0]
 8005e3e:	f1b3 0225 	subs.w	r2, r3, #37	; 0x25
 8005e42:	bf18      	it	ne
 8005e44:	2201      	movne	r2, #1
 8005e46:	2b00      	cmp	r3, #0
 8005e48:	bf0c      	ite	eq
 8005e4a:	2300      	moveq	r3, #0
 8005e4c:	f002 0301 	andne.w	r3, r2, #1
 8005e50:	2b00      	cmp	r3, #0
 8005e52:	f000 80bd 	beq.w	8005fd0 <_svfprintf_r+0x1e8>
 8005e56:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8005e58:	1c5a      	adds	r2, r3, #1
 8005e5a:	4617      	mov	r7, r2
 8005e5c:	3201      	adds	r2, #1
 8005e5e:	783b      	ldrb	r3, [r7, #0]
 8005e60:	1e19      	subs	r1, r3, #0
 8005e62:	bf18      	it	ne
 8005e64:	2101      	movne	r1, #1
 8005e66:	2b25      	cmp	r3, #37	; 0x25
 8005e68:	bf0c      	ite	eq
 8005e6a:	2300      	moveq	r3, #0
 8005e6c:	f001 0301 	andne.w	r3, r1, #1
 8005e70:	2b00      	cmp	r3, #0
 8005e72:	d1f2      	bne.n	8005e5a <_svfprintf_r+0x72>
 8005e74:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8005e76:	ebb7 0804 	subs.w	r8, r7, r4
 8005e7a:	d010      	beq.n	8005e9e <_svfprintf_r+0xb6>
 8005e7c:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8005e7e:	9809      	ldr	r0, [sp, #36]	; 0x24
 8005e80:	3401      	adds	r4, #1
 8005e82:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8005e84:	2c07      	cmp	r4, #7
 8005e86:	f8c6 8004 	str.w	r8, [r6, #4]
 8005e8a:	6030      	str	r0, [r6, #0]
 8005e8c:	4445      	add	r5, r8
 8005e8e:	943a      	str	r4, [sp, #232]	; 0xe8
 8005e90:	953b      	str	r5, [sp, #236]	; 0xec
 8005e92:	f300 8081 	bgt.w	8005f98 <_svfprintf_r+0x1b0>
 8005e96:	3608      	adds	r6, #8
 8005e98:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8005e9a:	4441      	add	r1, r8
 8005e9c:	910f      	str	r1, [sp, #60]	; 0x3c
 8005e9e:	783b      	ldrb	r3, [r7, #0]
 8005ea0:	2b00      	cmp	r3, #0
 8005ea2:	f000 8081 	beq.w	8005fa8 <_svfprintf_r+0x1c0>
 8005ea6:	1c7c      	adds	r4, r7, #1
 8005ea8:	2200      	movs	r2, #0
 8005eaa:	2300      	movs	r3, #0
 8005eac:	920d      	str	r2, [sp, #52]	; 0x34
 8005eae:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
 8005eb2:	2520      	movs	r5, #32
 8005eb4:	9409      	str	r4, [sp, #36]	; 0x24
 8005eb6:	212b      	movs	r1, #43	; 0x2b
 8005eb8:	787b      	ldrb	r3, [r7, #1]
 8005eba:	f04f 37ff 	mov.w	r7, #4294967295
 8005ebe:	9208      	str	r2, [sp, #32]
 8005ec0:	4622      	mov	r2, r4
 8005ec2:	3201      	adds	r2, #1
 8005ec4:	f1a3 0020 	sub.w	r0, r3, #32
 8005ec8:	2858      	cmp	r0, #88	; 0x58
 8005eca:	f200 831c 	bhi.w	8006506 <_svfprintf_r+0x71e>
 8005ece:	e8df f010 	tbh	[pc, r0, lsl #1]
 8005ed2:	032d      	.short	0x032d
 8005ed4:	031a031a 	.word	0x031a031a
 8005ed8:	031a0336 	.word	0x031a0336
 8005edc:	031a031a 	.word	0x031a031a
 8005ee0:	031a031a 	.word	0x031a031a
 8005ee4:	03c7031a 	.word	0x03c7031a
 8005ee8:	031a0081 	.word	0x031a0081
 8005eec:	0085005d 	.word	0x0085005d
 8005ef0:	009f031a 	.word	0x009f031a
 8005ef4:	00a500a5 	.word	0x00a500a5
 8005ef8:	00a500a5 	.word	0x00a500a5
 8005efc:	00a500a5 	.word	0x00a500a5
 8005f00:	00a500a5 	.word	0x00a500a5
 8005f04:	031a00a5 	.word	0x031a00a5
 8005f08:	031a031a 	.word	0x031a031a
 8005f0c:	031a031a 	.word	0x031a031a
 8005f10:	031a031a 	.word	0x031a031a
 8005f14:	031a031a 	.word	0x031a031a
 8005f18:	00b7031a 	.word	0x00b7031a
 8005f1c:	031a0241 	.word	0x031a0241
 8005f20:	031a0241 	.word	0x031a0241
 8005f24:	031a031a 	.word	0x031a031a
 8005f28:	027f031a 	.word	0x027f031a
 8005f2c:	031a031a 	.word	0x031a031a
 8005f30:	031a0285 	.word	0x031a0285
 8005f34:	031a031a 	.word	0x031a031a
 8005f38:	031a031a 	.word	0x031a031a
 8005f3c:	031a02a3 	.word	0x031a02a3
 8005f40:	02b2031a 	.word	0x02b2031a
 8005f44:	031a031a 	.word	0x031a031a
 8005f48:	031a031a 	.word	0x031a031a
 8005f4c:	031a031a 	.word	0x031a031a
 8005f50:	031a031a 	.word	0x031a031a
 8005f54:	031a031a 	.word	0x031a031a
 8005f58:	033c0354 	.word	0x033c0354
 8005f5c:	02410241 	.word	0x02410241
 8005f60:	034e0241 	.word	0x034e0241
 8005f64:	031a033c 	.word	0x031a033c
 8005f68:	030b031a 	.word	0x030b031a
 8005f6c:	039a031a 	.word	0x039a031a
 8005f70:	037e0368 	.word	0x037e0368
 8005f74:	031a02dd 	.word	0x031a02dd
 8005f78:	031a02e3 	.word	0x031a02e3
 8005f7c:	031a03ab 	.word	0x031a03ab
 8005f80:	03d2031a 	.word	0x03d2031a
 8005f84:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005f86:	9012      	str	r0, [sp, #72]	; 0x48
 8005f88:	425b      	negs	r3, r3
 8005f8a:	930d      	str	r3, [sp, #52]	; 0x34
 8005f8c:	9c08      	ldr	r4, [sp, #32]
 8005f8e:	f044 0404 	orr.w	r4, r4, #4
 8005f92:	9408      	str	r4, [sp, #32]
 8005f94:	7813      	ldrb	r3, [r2, #0]
 8005f96:	e794      	b.n	8005ec2 <_svfprintf_r+0xda>
 8005f98:	9811      	ldr	r0, [sp, #68]	; 0x44
 8005f9a:	aa39      	add	r2, sp, #228	; 0xe4
 8005f9c:	990c      	ldr	r1, [sp, #48]	; 0x30
 8005f9e:	f003 f9c1 	bl	8009324 <__ssprint_r>
 8005fa2:	b940      	cbnz	r0, 8005fb6 <_svfprintf_r+0x1ce>
 8005fa4:	4656      	mov	r6, sl
 8005fa6:	e777      	b.n	8005e98 <_svfprintf_r+0xb0>
 8005fa8:	9b3b      	ldr	r3, [sp, #236]	; 0xec
 8005faa:	b123      	cbz	r3, 8005fb6 <_svfprintf_r+0x1ce>
 8005fac:	9811      	ldr	r0, [sp, #68]	; 0x44
 8005fae:	aa39      	add	r2, sp, #228	; 0xe4
 8005fb0:	990c      	ldr	r1, [sp, #48]	; 0x30
 8005fb2:	f003 f9b7 	bl	8009324 <__ssprint_r>
 8005fb6:	990c      	ldr	r1, [sp, #48]	; 0x30
 8005fb8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8005fba:	898b      	ldrh	r3, [r1, #12]
 8005fbc:	f013 0f40 	tst.w	r3, #64	; 0x40
 8005fc0:	bf18      	it	ne
 8005fc2:	f04f 32ff 	movne.w	r2, #4294967295
 8005fc6:	920f      	str	r2, [sp, #60]	; 0x3c
 8005fc8:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8005fca:	b045      	add	sp, #276	; 0x114
 8005fcc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005fd0:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8005fd2:	e764      	b.n	8005e9e <_svfprintf_r+0xb6>
 8005fd4:	f88d 110f 	strb.w	r1, [sp, #271]	; 0x10f
 8005fd8:	7813      	ldrb	r3, [r2, #0]
 8005fda:	e772      	b.n	8005ec2 <_svfprintf_r+0xda>
 8005fdc:	f812 3b01 	ldrb.w	r3, [r2], #1
 8005fe0:	2b2a      	cmp	r3, #42	; 0x2a
 8005fe2:	f001 81fc 	beq.w	80073de <_svfprintf_r+0x15f6>
 8005fe6:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 8005fea:	2809      	cmp	r0, #9
 8005fec:	f201 81ac 	bhi.w	8007348 <_svfprintf_r+0x1560>
 8005ff0:	4614      	mov	r4, r2
 8005ff2:	2700      	movs	r7, #0
 8005ff4:	f814 3b01 	ldrb.w	r3, [r4], #1
 8005ff8:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 8005ffc:	eb00 0747 	add.w	r7, r0, r7, lsl #1
 8006000:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 8006004:	2809      	cmp	r0, #9
 8006006:	4622      	mov	r2, r4
 8006008:	d9f4      	bls.n	8005ff4 <_svfprintf_r+0x20c>
 800600a:	ea47 77e7 	orr.w	r7, r7, r7, asr #31
 800600e:	e759      	b.n	8005ec4 <_svfprintf_r+0xdc>
 8006010:	9b08      	ldr	r3, [sp, #32]
 8006012:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006016:	9308      	str	r3, [sp, #32]
 8006018:	7813      	ldrb	r3, [r2, #0]
 800601a:	e752      	b.n	8005ec2 <_svfprintf_r+0xda>
 800601c:	4614      	mov	r4, r2
 800601e:	2000      	movs	r0, #0
 8006020:	f1a3 0830 	sub.w	r8, r3, #48	; 0x30
 8006024:	f814 3b01 	ldrb.w	r3, [r4], #1
 8006028:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800602c:	f1a3 0c30 	sub.w	ip, r3, #48	; 0x30
 8006030:	4622      	mov	r2, r4
 8006032:	f1bc 0f09 	cmp.w	ip, #9
 8006036:	eb08 0040 	add.w	r0, r8, r0, lsl #1
 800603a:	d9f1      	bls.n	8006020 <_svfprintf_r+0x238>
 800603c:	900d      	str	r0, [sp, #52]	; 0x34
 800603e:	e741      	b.n	8005ec4 <_svfprintf_r+0xdc>
 8006040:	9209      	str	r2, [sp, #36]	; 0x24
 8006042:	9a08      	ldr	r2, [sp, #32]
 8006044:	9316      	str	r3, [sp, #88]	; 0x58
 8006046:	f042 0210 	orr.w	r2, r2, #16
 800604a:	9208      	str	r2, [sp, #32]
 800604c:	9b08      	ldr	r3, [sp, #32]
 800604e:	f013 0f20 	tst.w	r3, #32
 8006052:	f000 8281 	beq.w	8006558 <_svfprintf_r+0x770>
 8006056:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8006058:	1de3      	adds	r3, r4, #7
 800605a:	f023 0307 	bic.w	r3, r3, #7
 800605e:	f103 0008 	add.w	r0, r3, #8
 8006062:	9012      	str	r0, [sp, #72]	; 0x48
 8006064:	e9d3 4500 	ldrd	r4, r5, [r3]
 8006068:	2c00      	cmp	r4, #0
 800606a:	f175 0200 	sbcs.w	r2, r5, #0
 800606e:	f2c0 85cd 	blt.w	8006c0c <_svfprintf_r+0xe24>
 8006072:	ea54 0305 	orrs.w	r3, r4, r5
 8006076:	f04f 0301 	mov.w	r3, #1
 800607a:	bf0c      	ite	eq
 800607c:	2200      	moveq	r2, #0
 800607e:	2201      	movne	r2, #1
 8006080:	2f00      	cmp	r7, #0
 8006082:	bfa2      	ittt	ge
 8006084:	9908      	ldrge	r1, [sp, #32]
 8006086:	f021 0180 	bicge.w	r1, r1, #128	; 0x80
 800608a:	9108      	strge	r1, [sp, #32]
 800608c:	2f00      	cmp	r7, #0
 800608e:	bf18      	it	ne
 8006090:	f042 0201 	orrne.w	r2, r2, #1
 8006094:	2a00      	cmp	r2, #0
 8006096:	f000 83ac 	beq.w	80067f2 <_svfprintf_r+0xa0a>
 800609a:	2b01      	cmp	r3, #1
 800609c:	f000 84fe 	beq.w	8006a9c <_svfprintf_r+0xcb4>
 80060a0:	2b02      	cmp	r3, #2
 80060a2:	f000 84de 	beq.w	8006a62 <_svfprintf_r+0xc7a>
 80060a6:	f10d 0bbc 	add.w	fp, sp, #188	; 0xbc
 80060aa:	f10b 0327 	add.w	r3, fp, #39	; 0x27
 80060ae:	08ea      	lsrs	r2, r5, #3
 80060b0:	ea4f 08d4 	mov.w	r8, r4, lsr #3
 80060b4:	ea48 7845 	orr.w	r8, r8, r5, lsl #29
 80060b8:	f004 0407 	and.w	r4, r4, #7
 80060bc:	4611      	mov	r1, r2
 80060be:	f104 0230 	add.w	r2, r4, #48	; 0x30
 80060c2:	460d      	mov	r5, r1
 80060c4:	4644      	mov	r4, r8
 80060c6:	469c      	mov	ip, r3
 80060c8:	701a      	strb	r2, [r3, #0]
 80060ca:	3b01      	subs	r3, #1
 80060cc:	ea54 0005 	orrs.w	r0, r4, r5
 80060d0:	d1ed      	bne.n	80060ae <_svfprintf_r+0x2c6>
 80060d2:	9908      	ldr	r1, [sp, #32]
 80060d4:	f8cd c04c 	str.w	ip, [sp, #76]	; 0x4c
 80060d8:	f011 0f01 	tst.w	r1, #1
 80060dc:	f040 8588 	bne.w	8006bf0 <_svfprintf_r+0xe08>
 80060e0:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 80060e4:	ebcc 020b 	rsb	r2, ip, fp
 80060e8:	9210      	str	r2, [sp, #64]	; 0x40
 80060ea:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 80060ee:	2000      	movs	r0, #0
 80060f0:	9c10      	ldr	r4, [sp, #64]	; 0x40
 80060f2:	9714      	str	r7, [sp, #80]	; 0x50
 80060f4:	42bc      	cmp	r4, r7
 80060f6:	bfb8      	it	lt
 80060f8:	463c      	movlt	r4, r7
 80060fa:	9018      	str	r0, [sp, #96]	; 0x60
 80060fc:	940a      	str	r4, [sp, #40]	; 0x28
 80060fe:	b112      	cbz	r2, 8006106 <_svfprintf_r+0x31e>
 8006100:	980a      	ldr	r0, [sp, #40]	; 0x28
 8006102:	3001      	adds	r0, #1
 8006104:	900a      	str	r0, [sp, #40]	; 0x28
 8006106:	9908      	ldr	r1, [sp, #32]
 8006108:	f011 0b02 	ands.w	fp, r1, #2
 800610c:	d002      	beq.n	8006114 <_svfprintf_r+0x32c>
 800610e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8006110:	3302      	adds	r3, #2
 8006112:	930a      	str	r3, [sp, #40]	; 0x28
 8006114:	9c08      	ldr	r4, [sp, #32]
 8006116:	f014 0484 	ands.w	r4, r4, #132	; 0x84
 800611a:	9415      	str	r4, [sp, #84]	; 0x54
 800611c:	f040 82cd 	bne.w	80066ba <_svfprintf_r+0x8d2>
 8006120:	980d      	ldr	r0, [sp, #52]	; 0x34
 8006122:	990a      	ldr	r1, [sp, #40]	; 0x28
 8006124:	1a47      	subs	r7, r0, r1
 8006126:	2f00      	cmp	r7, #0
 8006128:	f340 82c7 	ble.w	80066ba <_svfprintf_r+0x8d2>
 800612c:	2f10      	cmp	r7, #16
 800612e:	f341 8065 	ble.w	80071fc <_svfprintf_r+0x1414>
 8006132:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006134:	f24b 78cc 	movw	r8, #47052	; 0xb7cc
 8006138:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 800613a:	f6c0 0800 	movt	r8, #2048	; 0x800
 800613e:	4629      	mov	r1, r5
 8006140:	f04f 0910 	mov.w	r9, #16
 8006144:	4622      	mov	r2, r4
 8006146:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8006148:	4644      	mov	r4, r8
 800614a:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 800614e:	e002      	b.n	8006156 <_svfprintf_r+0x36e>
 8006150:	3f10      	subs	r7, #16
 8006152:	2f10      	cmp	r7, #16
 8006154:	dd1b      	ble.n	800618e <_svfprintf_r+0x3a6>
 8006156:	3201      	adds	r2, #1
 8006158:	6034      	str	r4, [r6, #0]
 800615a:	f8c6 9004 	str.w	r9, [r6, #4]
 800615e:	3110      	adds	r1, #16
 8006160:	3608      	adds	r6, #8
 8006162:	2a07      	cmp	r2, #7
 8006164:	923a      	str	r2, [sp, #232]	; 0xe8
 8006166:	f106 0308 	add.w	r3, r6, #8
 800616a:	913b      	str	r1, [sp, #236]	; 0xec
 800616c:	ddf0      	ble.n	8006150 <_svfprintf_r+0x368>
 800616e:	4640      	mov	r0, r8
 8006170:	4629      	mov	r1, r5
 8006172:	aa39      	add	r2, sp, #228	; 0xe4
 8006174:	4656      	mov	r6, sl
 8006176:	f003 f8d5 	bl	8009324 <__ssprint_r>
 800617a:	f10a 0308 	add.w	r3, sl, #8
 800617e:	2800      	cmp	r0, #0
 8006180:	f47f af19 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8006184:	3f10      	subs	r7, #16
 8006186:	993b      	ldr	r1, [sp, #236]	; 0xec
 8006188:	2f10      	cmp	r7, #16
 800618a:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 800618c:	dce3      	bgt.n	8006156 <_svfprintf_r+0x36e>
 800618e:	46a0      	mov	r8, r4
 8006190:	460d      	mov	r5, r1
 8006192:	4614      	mov	r4, r2
 8006194:	3401      	adds	r4, #1
 8006196:	f8c6 8000 	str.w	r8, [r6]
 800619a:	2c07      	cmp	r4, #7
 800619c:	6077      	str	r7, [r6, #4]
 800619e:	443d      	add	r5, r7
 80061a0:	943a      	str	r4, [sp, #232]	; 0xe8
 80061a2:	953b      	str	r5, [sp, #236]	; 0xec
 80061a4:	f300 827e 	bgt.w	80066a4 <_svfprintf_r+0x8bc>
 80061a8:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 80061ac:	461e      	mov	r6, r3
 80061ae:	b16a      	cbz	r2, 80061cc <_svfprintf_r+0x3e4>
 80061b0:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80061b2:	ab43      	add	r3, sp, #268	; 0x10c
 80061b4:	3303      	adds	r3, #3
 80061b6:	6033      	str	r3, [r6, #0]
 80061b8:	3401      	adds	r4, #1
 80061ba:	2301      	movs	r3, #1
 80061bc:	2c07      	cmp	r4, #7
 80061be:	6073      	str	r3, [r6, #4]
 80061c0:	441d      	add	r5, r3
 80061c2:	943a      	str	r4, [sp, #232]	; 0xe8
 80061c4:	953b      	str	r5, [sp, #236]	; 0xec
 80061c6:	f300 83e9 	bgt.w	800699c <_svfprintf_r+0xbb4>
 80061ca:	3608      	adds	r6, #8
 80061cc:	f1bb 0f00 	cmp.w	fp, #0
 80061d0:	d00c      	beq.n	80061ec <_svfprintf_r+0x404>
 80061d2:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80061d4:	ab43      	add	r3, sp, #268	; 0x10c
 80061d6:	6033      	str	r3, [r6, #0]
 80061d8:	2302      	movs	r3, #2
 80061da:	3401      	adds	r4, #1
 80061dc:	6073      	str	r3, [r6, #4]
 80061de:	2c07      	cmp	r4, #7
 80061e0:	441d      	add	r5, r3
 80061e2:	943a      	str	r4, [sp, #232]	; 0xe8
 80061e4:	953b      	str	r5, [sp, #236]	; 0xec
 80061e6:	f300 83ce 	bgt.w	8006986 <_svfprintf_r+0xb9e>
 80061ea:	3608      	adds	r6, #8
 80061ec:	9a15      	ldr	r2, [sp, #84]	; 0x54
 80061ee:	2a80      	cmp	r2, #128	; 0x80
 80061f0:	f000 8310 	beq.w	8006814 <_svfprintf_r+0xa2c>
 80061f4:	9914      	ldr	r1, [sp, #80]	; 0x50
 80061f6:	9810      	ldr	r0, [sp, #64]	; 0x40
 80061f8:	1a0f      	subs	r7, r1, r0
 80061fa:	2f00      	cmp	r7, #0
 80061fc:	f340 835b 	ble.w	80068b6 <_svfprintf_r+0xace>
 8006200:	2f10      	cmp	r7, #16
 8006202:	f340 85eb 	ble.w	8006ddc <_svfprintf_r+0xff4>
 8006206:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006208:	462a      	mov	r2, r5
 800620a:	f8df 8a98 	ldr.w	r8, [pc, #2712]	; 8006ca4 <_svfprintf_r+0xebc>
 800620e:	f04f 0b10 	mov.w	fp, #16
 8006212:	4623      	mov	r3, r4
 8006214:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8006216:	4644      	mov	r4, r8
 8006218:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 800621c:	e002      	b.n	8006224 <_svfprintf_r+0x43c>
 800621e:	3f10      	subs	r7, #16
 8006220:	2f10      	cmp	r7, #16
 8006222:	dd1b      	ble.n	800625c <_svfprintf_r+0x474>
 8006224:	3301      	adds	r3, #1
 8006226:	6034      	str	r4, [r6, #0]
 8006228:	f8c6 b004 	str.w	fp, [r6, #4]
 800622c:	3210      	adds	r2, #16
 800622e:	3608      	adds	r6, #8
 8006230:	2b07      	cmp	r3, #7
 8006232:	933a      	str	r3, [sp, #232]	; 0xe8
 8006234:	f106 0908 	add.w	r9, r6, #8
 8006238:	923b      	str	r2, [sp, #236]	; 0xec
 800623a:	ddf0      	ble.n	800621e <_svfprintf_r+0x436>
 800623c:	4640      	mov	r0, r8
 800623e:	4629      	mov	r1, r5
 8006240:	aa39      	add	r2, sp, #228	; 0xe4
 8006242:	f10a 0908 	add.w	r9, sl, #8
 8006246:	f003 f86d 	bl	8009324 <__ssprint_r>
 800624a:	4656      	mov	r6, sl
 800624c:	2800      	cmp	r0, #0
 800624e:	f47f aeb2 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8006252:	3f10      	subs	r7, #16
 8006254:	9a3b      	ldr	r2, [sp, #236]	; 0xec
 8006256:	2f10      	cmp	r7, #16
 8006258:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 800625a:	dce3      	bgt.n	8006224 <_svfprintf_r+0x43c>
 800625c:	46a0      	mov	r8, r4
 800625e:	4615      	mov	r5, r2
 8006260:	461c      	mov	r4, r3
 8006262:	3401      	adds	r4, #1
 8006264:	f8c6 8000 	str.w	r8, [r6]
 8006268:	2c07      	cmp	r4, #7
 800626a:	6077      	str	r7, [r6, #4]
 800626c:	443d      	add	r5, r7
 800626e:	943a      	str	r4, [sp, #232]	; 0xe8
 8006270:	953b      	str	r5, [sp, #236]	; 0xec
 8006272:	f300 837d 	bgt.w	8006970 <_svfprintf_r+0xb88>
 8006276:	9a08      	ldr	r2, [sp, #32]
 8006278:	f412 7f80 	tst.w	r2, #256	; 0x100
 800627c:	f040 824e 	bne.w	800671c <_svfprintf_r+0x934>
 8006280:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006282:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8006284:	3401      	adds	r4, #1
 8006286:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8006288:	2c07      	cmp	r4, #7
 800628a:	441d      	add	r5, r3
 800628c:	f8c9 3004 	str.w	r3, [r9, #4]
 8006290:	f8c9 0000 	str.w	r0, [r9]
 8006294:	953b      	str	r5, [sp, #236]	; 0xec
 8006296:	943a      	str	r4, [sp, #232]	; 0xe8
 8006298:	f300 8235 	bgt.w	8006706 <_svfprintf_r+0x91e>
 800629c:	f109 0908 	add.w	r9, r9, #8
 80062a0:	9c08      	ldr	r4, [sp, #32]
 80062a2:	f014 0f04 	tst.w	r4, #4
 80062a6:	d046      	beq.n	8006336 <_svfprintf_r+0x54e>
 80062a8:	980d      	ldr	r0, [sp, #52]	; 0x34
 80062aa:	990a      	ldr	r1, [sp, #40]	; 0x28
 80062ac:	1a46      	subs	r6, r0, r1
 80062ae:	2e00      	cmp	r6, #0
 80062b0:	dd41      	ble.n	8006336 <_svfprintf_r+0x54e>
 80062b2:	2e10      	cmp	r6, #16
 80062b4:	f340 87da 	ble.w	800726c <_svfprintf_r+0x1484>
 80062b8:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80062ba:	f24b 78cc 	movw	r8, #47052	; 0xb7cc
 80062be:	f6c0 0800 	movt	r8, #2048	; 0x800
 80062c2:	2710      	movs	r7, #16
 80062c4:	4623      	mov	r3, r4
 80062c6:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 80062ca:	4644      	mov	r4, r8
 80062cc:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 80062d0:	e002      	b.n	80062d8 <_svfprintf_r+0x4f0>
 80062d2:	3e10      	subs	r6, #16
 80062d4:	2e10      	cmp	r6, #16
 80062d6:	dd19      	ble.n	800630c <_svfprintf_r+0x524>
 80062d8:	3301      	adds	r3, #1
 80062da:	3510      	adds	r5, #16
 80062dc:	2b07      	cmp	r3, #7
 80062de:	f8c9 4000 	str.w	r4, [r9]
 80062e2:	f8c9 7004 	str.w	r7, [r9, #4]
 80062e6:	f109 0908 	add.w	r9, r9, #8
 80062ea:	933a      	str	r3, [sp, #232]	; 0xe8
 80062ec:	953b      	str	r5, [sp, #236]	; 0xec
 80062ee:	ddf0      	ble.n	80062d2 <_svfprintf_r+0x4ea>
 80062f0:	4640      	mov	r0, r8
 80062f2:	4659      	mov	r1, fp
 80062f4:	aa39      	add	r2, sp, #228	; 0xe4
 80062f6:	46d1      	mov	r9, sl
 80062f8:	f003 f814 	bl	8009324 <__ssprint_r>
 80062fc:	2800      	cmp	r0, #0
 80062fe:	f47f ae5a 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8006302:	3e10      	subs	r6, #16
 8006304:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006306:	2e10      	cmp	r6, #16
 8006308:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 800630a:	dce5      	bgt.n	80062d8 <_svfprintf_r+0x4f0>
 800630c:	46a0      	mov	r8, r4
 800630e:	461c      	mov	r4, r3
 8006310:	3401      	adds	r4, #1
 8006312:	f8c9 8000 	str.w	r8, [r9]
 8006316:	2c07      	cmp	r4, #7
 8006318:	f8c9 6004 	str.w	r6, [r9, #4]
 800631c:	4435      	add	r5, r6
 800631e:	943a      	str	r4, [sp, #232]	; 0xe8
 8006320:	953b      	str	r5, [sp, #236]	; 0xec
 8006322:	dd08      	ble.n	8006336 <_svfprintf_r+0x54e>
 8006324:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006326:	aa39      	add	r2, sp, #228	; 0xe4
 8006328:	990c      	ldr	r1, [sp, #48]	; 0x30
 800632a:	f002 fffb 	bl	8009324 <__ssprint_r>
 800632e:	2800      	cmp	r0, #0
 8006330:	f47f ae41 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8006334:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006336:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8006338:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 800633a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800633c:	429c      	cmp	r4, r3
 800633e:	bfac      	ite	ge
 8006340:	1912      	addge	r2, r2, r4
 8006342:	18d2      	addlt	r2, r2, r3
 8006344:	920f      	str	r2, [sp, #60]	; 0x3c
 8006346:	2d00      	cmp	r5, #0
 8006348:	f040 8303 	bne.w	8006952 <_svfprintf_r+0xb6a>
 800634c:	2000      	movs	r0, #0
 800634e:	4656      	mov	r6, sl
 8006350:	903a      	str	r0, [sp, #232]	; 0xe8
 8006352:	e572      	b.n	8005e3a <_svfprintf_r+0x52>
 8006354:	9908      	ldr	r1, [sp, #32]
 8006356:	461d      	mov	r5, r3
 8006358:	9209      	str	r2, [sp, #36]	; 0x24
 800635a:	f011 0f08 	tst.w	r1, #8
 800635e:	9316      	str	r3, [sp, #88]	; 0x58
 8006360:	f000 8487 	beq.w	8006c72 <_svfprintf_r+0xe8a>
 8006364:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8006366:	1dd3      	adds	r3, r2, #7
 8006368:	f023 0307 	bic.w	r3, r3, #7
 800636c:	f103 0408 	add.w	r4, r3, #8
 8006370:	9412      	str	r4, [sp, #72]	; 0x48
 8006372:	6818      	ldr	r0, [r3, #0]
 8006374:	901a      	str	r0, [sp, #104]	; 0x68
 8006376:	685b      	ldr	r3, [r3, #4]
 8006378:	931b      	str	r3, [sp, #108]	; 0x6c
 800637a:	981a      	ldr	r0, [sp, #104]	; 0x68
 800637c:	991b      	ldr	r1, [sp, #108]	; 0x6c
 800637e:	f002 ff59 	bl	8009234 <__fpclassifyd>
 8006382:	2801      	cmp	r0, #1
 8006384:	f040 8450 	bne.w	8006c28 <_svfprintf_r+0xe40>
 8006388:	981a      	ldr	r0, [sp, #104]	; 0x68
 800638a:	2200      	movs	r2, #0
 800638c:	2300      	movs	r3, #0
 800638e:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8006390:	f004 fdba 	bl	800af08 <__aeabi_dcmplt>
 8006394:	2800      	cmp	r0, #0
 8006396:	f040 871c 	bne.w	80071d2 <_svfprintf_r+0x13ea>
 800639a:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 800639e:	2003      	movs	r0, #3
 80063a0:	f64b 3340 	movw	r3, #47936	; 0xbb40
 80063a4:	f64b 313c 	movw	r1, #47932	; 0xbb3c
 80063a8:	900a      	str	r0, [sp, #40]	; 0x28
 80063aa:	9816      	ldr	r0, [sp, #88]	; 0x58
 80063ac:	f6c0 0100 	movt	r1, #2048	; 0x800
 80063b0:	f6c0 0300 	movt	r3, #2048	; 0x800
 80063b4:	2400      	movs	r4, #0
 80063b6:	2847      	cmp	r0, #71	; 0x47
 80063b8:	bfd8      	it	le
 80063ba:	460b      	movle	r3, r1
 80063bc:	9908      	ldr	r1, [sp, #32]
 80063be:	9313      	str	r3, [sp, #76]	; 0x4c
 80063c0:	2303      	movs	r3, #3
 80063c2:	f021 0180 	bic.w	r1, r1, #128	; 0x80
 80063c6:	9414      	str	r4, [sp, #80]	; 0x50
 80063c8:	9108      	str	r1, [sp, #32]
 80063ca:	9310      	str	r3, [sp, #64]	; 0x40
 80063cc:	9418      	str	r4, [sp, #96]	; 0x60
 80063ce:	e696      	b.n	80060fe <_svfprintf_r+0x316>
 80063d0:	9c08      	ldr	r4, [sp, #32]
 80063d2:	f044 0408 	orr.w	r4, r4, #8
 80063d6:	9408      	str	r4, [sp, #32]
 80063d8:	7813      	ldrb	r3, [r2, #0]
 80063da:	e572      	b.n	8005ec2 <_svfprintf_r+0xda>
 80063dc:	9908      	ldr	r1, [sp, #32]
 80063de:	9209      	str	r2, [sp, #36]	; 0x24
 80063e0:	f041 0110 	orr.w	r1, r1, #16
 80063e4:	9108      	str	r1, [sp, #32]
 80063e6:	9a08      	ldr	r2, [sp, #32]
 80063e8:	9316      	str	r3, [sp, #88]	; 0x58
 80063ea:	f012 0320 	ands.w	r3, r2, #32
 80063ee:	f000 80df 	beq.w	80065b0 <_svfprintf_r+0x7c8>
 80063f2:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80063f4:	1dda      	adds	r2, r3, #7
 80063f6:	2300      	movs	r3, #0
 80063f8:	f022 0207 	bic.w	r2, r2, #7
 80063fc:	f102 0408 	add.w	r4, r2, #8
 8006400:	9412      	str	r4, [sp, #72]	; 0x48
 8006402:	e9d2 4500 	ldrd	r4, r5, [r2]
 8006406:	ea54 0005 	orrs.w	r0, r4, r5
 800640a:	bf0c      	ite	eq
 800640c:	2200      	moveq	r2, #0
 800640e:	2201      	movne	r2, #1
 8006410:	2000      	movs	r0, #0
 8006412:	f88d 010f 	strb.w	r0, [sp, #271]	; 0x10f
 8006416:	e633      	b.n	8006080 <_svfprintf_r+0x298>
 8006418:	9c08      	ldr	r4, [sp, #32]
 800641a:	9209      	str	r2, [sp, #36]	; 0x24
 800641c:	f044 0410 	orr.w	r4, r4, #16
 8006420:	9408      	str	r4, [sp, #32]
 8006422:	9808      	ldr	r0, [sp, #32]
 8006424:	9316      	str	r3, [sp, #88]	; 0x58
 8006426:	f010 0f20 	tst.w	r0, #32
 800642a:	f000 8104 	beq.w	8006636 <_svfprintf_r+0x84e>
 800642e:	9912      	ldr	r1, [sp, #72]	; 0x48
 8006430:	2301      	movs	r3, #1
 8006432:	1dca      	adds	r2, r1, #7
 8006434:	e7e0      	b.n	80063f8 <_svfprintf_r+0x610>
 8006436:	9209      	str	r2, [sp, #36]	; 0x24
 8006438:	f64b 314c 	movw	r1, #47948	; 0xbb4c
 800643c:	9a08      	ldr	r2, [sp, #32]
 800643e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8006442:	9316      	str	r3, [sp, #88]	; 0x58
 8006444:	f012 0f20 	tst.w	r2, #32
 8006448:	9117      	str	r1, [sp, #92]	; 0x5c
 800644a:	f000 8120 	beq.w	800668e <_svfprintf_r+0x8a6>
 800644e:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8006450:	1de3      	adds	r3, r4, #7
 8006452:	f023 0307 	bic.w	r3, r3, #7
 8006456:	f103 0008 	add.w	r0, r3, #8
 800645a:	9012      	str	r0, [sp, #72]	; 0x48
 800645c:	e9d3 4500 	ldrd	r4, r5, [r3]
 8006460:	ea54 0205 	orrs.w	r2, r4, r5
 8006464:	9b08      	ldr	r3, [sp, #32]
 8006466:	bf0c      	ite	eq
 8006468:	2200      	moveq	r2, #0
 800646a:	2201      	movne	r2, #1
 800646c:	4213      	tst	r3, r2
 800646e:	f000 8369 	beq.w	8006b44 <_svfprintf_r+0xd5c>
 8006472:	9816      	ldr	r0, [sp, #88]	; 0x58
 8006474:	2330      	movs	r3, #48	; 0x30
 8006476:	9908      	ldr	r1, [sp, #32]
 8006478:	2201      	movs	r2, #1
 800647a:	f88d 310c 	strb.w	r3, [sp, #268]	; 0x10c
 800647e:	2302      	movs	r3, #2
 8006480:	f041 0102 	orr.w	r1, r1, #2
 8006484:	f88d 010d 	strb.w	r0, [sp, #269]	; 0x10d
 8006488:	9108      	str	r1, [sp, #32]
 800648a:	e7c1      	b.n	8006410 <_svfprintf_r+0x628>
 800648c:	9808      	ldr	r0, [sp, #32]
 800648e:	f040 0020 	orr.w	r0, r0, #32
 8006492:	9008      	str	r0, [sp, #32]
 8006494:	7813      	ldrb	r3, [r2, #0]
 8006496:	e514      	b.n	8005ec2 <_svfprintf_r+0xda>
 8006498:	9209      	str	r2, [sp, #36]	; 0x24
 800649a:	2100      	movs	r1, #0
 800649c:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800649e:	9316      	str	r3, [sp, #88]	; 0x58
 80064a0:	f88d 110f 	strb.w	r1, [sp, #271]	; 0x10f
 80064a4:	1d14      	adds	r4, r2, #4
 80064a6:	6813      	ldr	r3, [r2, #0]
 80064a8:	9313      	str	r3, [sp, #76]	; 0x4c
 80064aa:	2b00      	cmp	r3, #0
 80064ac:	f000 86f0 	beq.w	8007290 <_svfprintf_r+0x14a8>
 80064b0:	2f00      	cmp	r7, #0
 80064b2:	f2c0 8693 	blt.w	80071dc <_svfprintf_r+0x13f4>
 80064b6:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80064b8:	2100      	movs	r1, #0
 80064ba:	463a      	mov	r2, r7
 80064bc:	f002 f89c 	bl	80085f8 <memchr>
 80064c0:	2800      	cmp	r0, #0
 80064c2:	f000 8736 	beq.w	8007332 <_svfprintf_r+0x154a>
 80064c6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80064c8:	1ac0      	subs	r0, r0, r3
 80064ca:	9010      	str	r0, [sp, #64]	; 0x40
 80064cc:	42b8      	cmp	r0, r7
 80064ce:	f340 84f4 	ble.w	8006eba <_svfprintf_r+0x10d2>
 80064d2:	2000      	movs	r0, #0
 80064d4:	ea27 71e7 	bic.w	r1, r7, r7, asr #31
 80064d8:	9014      	str	r0, [sp, #80]	; 0x50
 80064da:	910a      	str	r1, [sp, #40]	; 0x28
 80064dc:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 80064e0:	9412      	str	r4, [sp, #72]	; 0x48
 80064e2:	9710      	str	r7, [sp, #64]	; 0x40
 80064e4:	9018      	str	r0, [sp, #96]	; 0x60
 80064e6:	e60a      	b.n	80060fe <_svfprintf_r+0x316>
 80064e8:	7813      	ldrb	r3, [r2, #0]
 80064ea:	2b6c      	cmp	r3, #108	; 0x6c
 80064ec:	bf0b      	itete	eq
 80064ee:	9b08      	ldreq	r3, [sp, #32]
 80064f0:	9c08      	ldrne	r4, [sp, #32]
 80064f2:	f043 0320 	orreq.w	r3, r3, #32
 80064f6:	f044 0410 	orrne.w	r4, r4, #16
 80064fa:	bf0a      	itet	eq
 80064fc:	9308      	streq	r3, [sp, #32]
 80064fe:	9408      	strne	r4, [sp, #32]
 8006500:	f812 3f01 	ldrbeq.w	r3, [r2, #1]!
 8006504:	e4dd      	b.n	8005ec2 <_svfprintf_r+0xda>
 8006506:	9209      	str	r2, [sp, #36]	; 0x24
 8006508:	9316      	str	r3, [sp, #88]	; 0x58
 800650a:	2b00      	cmp	r3, #0
 800650c:	f43f ad4c 	beq.w	8005fa8 <_svfprintf_r+0x1c0>
 8006510:	2200      	movs	r2, #0
 8006512:	2101      	movs	r1, #1
 8006514:	f88d 30bc 	strb.w	r3, [sp, #188]	; 0xbc
 8006518:	ac2f      	add	r4, sp, #188	; 0xbc
 800651a:	2300      	movs	r3, #0
 800651c:	910a      	str	r1, [sp, #40]	; 0x28
 800651e:	9110      	str	r1, [sp, #64]	; 0x40
 8006520:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
 8006524:	9214      	str	r2, [sp, #80]	; 0x50
 8006526:	9218      	str	r2, [sp, #96]	; 0x60
 8006528:	9413      	str	r4, [sp, #76]	; 0x4c
 800652a:	e5ec      	b.n	8006106 <_svfprintf_r+0x31e>
 800652c:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
 8006530:	2b00      	cmp	r3, #0
 8006532:	f040 839b 	bne.w	8006c6c <_svfprintf_r+0xe84>
 8006536:	f88d 510f 	strb.w	r5, [sp, #271]	; 0x10f
 800653a:	7813      	ldrb	r3, [r2, #0]
 800653c:	e4c1      	b.n	8005ec2 <_svfprintf_r+0xda>
 800653e:	9808      	ldr	r0, [sp, #32]
 8006540:	f040 0001 	orr.w	r0, r0, #1
 8006544:	9008      	str	r0, [sp, #32]
 8006546:	7813      	ldrb	r3, [r2, #0]
 8006548:	e4bb      	b.n	8005ec2 <_svfprintf_r+0xda>
 800654a:	9316      	str	r3, [sp, #88]	; 0x58
 800654c:	9b08      	ldr	r3, [sp, #32]
 800654e:	9209      	str	r2, [sp, #36]	; 0x24
 8006550:	f013 0f20 	tst.w	r3, #32
 8006554:	f47f ad7f 	bne.w	8006056 <_svfprintf_r+0x26e>
 8006558:	9908      	ldr	r1, [sp, #32]
 800655a:	f011 0f10 	tst.w	r1, #16
 800655e:	f000 83a3 	beq.w	8006ca8 <_svfprintf_r+0xec0>
 8006562:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8006564:	6814      	ldr	r4, [r2, #0]
 8006566:	3204      	adds	r2, #4
 8006568:	9212      	str	r2, [sp, #72]	; 0x48
 800656a:	17e5      	asrs	r5, r4, #31
 800656c:	e57c      	b.n	8006068 <_svfprintf_r+0x280>
 800656e:	9808      	ldr	r0, [sp, #32]
 8006570:	f040 0040 	orr.w	r0, r0, #64	; 0x40
 8006574:	9008      	str	r0, [sp, #32]
 8006576:	7813      	ldrb	r3, [r2, #0]
 8006578:	e4a3      	b.n	8005ec2 <_svfprintf_r+0xda>
 800657a:	9316      	str	r3, [sp, #88]	; 0x58
 800657c:	2101      	movs	r1, #1
 800657e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006580:	2000      	movs	r0, #0
 8006582:	9209      	str	r2, [sp, #36]	; 0x24
 8006584:	2200      	movs	r2, #0
 8006586:	1d1c      	adds	r4, r3, #4
 8006588:	910a      	str	r1, [sp, #40]	; 0x28
 800658a:	681b      	ldr	r3, [r3, #0]
 800658c:	9412      	str	r4, [sp, #72]	; 0x48
 800658e:	9110      	str	r1, [sp, #64]	; 0x40
 8006590:	a92f      	add	r1, sp, #188	; 0xbc
 8006592:	f88d 010f 	strb.w	r0, [sp, #271]	; 0x10f
 8006596:	9214      	str	r2, [sp, #80]	; 0x50
 8006598:	9218      	str	r2, [sp, #96]	; 0x60
 800659a:	9113      	str	r1, [sp, #76]	; 0x4c
 800659c:	f88d 30bc 	strb.w	r3, [sp, #188]	; 0xbc
 80065a0:	e5b1      	b.n	8006106 <_svfprintf_r+0x31e>
 80065a2:	9209      	str	r2, [sp, #36]	; 0x24
 80065a4:	9a08      	ldr	r2, [sp, #32]
 80065a6:	9316      	str	r3, [sp, #88]	; 0x58
 80065a8:	f012 0320 	ands.w	r3, r2, #32
 80065ac:	f47f af21 	bne.w	80063f2 <_svfprintf_r+0x60a>
 80065b0:	9908      	ldr	r1, [sp, #32]
 80065b2:	f011 0210 	ands.w	r2, r1, #16
 80065b6:	f000 8391 	beq.w	8006cdc <_svfprintf_r+0xef4>
 80065ba:	9c12      	ldr	r4, [sp, #72]	; 0x48
 80065bc:	6822      	ldr	r2, [r4, #0]
 80065be:	3404      	adds	r4, #4
 80065c0:	2500      	movs	r5, #0
 80065c2:	9412      	str	r4, [sp, #72]	; 0x48
 80065c4:	4614      	mov	r4, r2
 80065c6:	3a00      	subs	r2, #0
 80065c8:	bf18      	it	ne
 80065ca:	2201      	movne	r2, #1
 80065cc:	e720      	b.n	8006410 <_svfprintf_r+0x628>
 80065ce:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80065d0:	2178      	movs	r1, #120	; 0x78
 80065d2:	9c08      	ldr	r4, [sp, #32]
 80065d4:	2500      	movs	r5, #0
 80065d6:	9209      	str	r2, [sp, #36]	; 0x24
 80065d8:	f64b 3060 	movw	r0, #47968	; 0xbb60
 80065dc:	681a      	ldr	r2, [r3, #0]
 80065de:	f044 0402 	orr.w	r4, r4, #2
 80065e2:	3304      	adds	r3, #4
 80065e4:	9408      	str	r4, [sp, #32]
 80065e6:	9312      	str	r3, [sp, #72]	; 0x48
 80065e8:	4614      	mov	r4, r2
 80065ea:	2330      	movs	r3, #48	; 0x30
 80065ec:	3a00      	subs	r2, #0
 80065ee:	f88d 310c 	strb.w	r3, [sp, #268]	; 0x10c
 80065f2:	bf18      	it	ne
 80065f4:	2201      	movne	r2, #1
 80065f6:	f6c0 0000 	movt	r0, #2048	; 0x800
 80065fa:	f88d 110d 	strb.w	r1, [sp, #269]	; 0x10d
 80065fe:	9017      	str	r0, [sp, #92]	; 0x5c
 8006600:	2302      	movs	r3, #2
 8006602:	9116      	str	r1, [sp, #88]	; 0x58
 8006604:	e704      	b.n	8006410 <_svfprintf_r+0x628>
 8006606:	9209      	str	r2, [sp, #36]	; 0x24
 8006608:	9a08      	ldr	r2, [sp, #32]
 800660a:	f012 0f20 	tst.w	r2, #32
 800660e:	f000 8358 	beq.w	8006cc2 <_svfprintf_r+0xeda>
 8006612:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006614:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 8006616:	9812      	ldr	r0, [sp, #72]	; 0x48
 8006618:	6819      	ldr	r1, [r3, #0]
 800661a:	4622      	mov	r2, r4
 800661c:	17e3      	asrs	r3, r4, #31
 800661e:	3004      	adds	r0, #4
 8006620:	9012      	str	r0, [sp, #72]	; 0x48
 8006622:	e9c1 2300 	strd	r2, r3, [r1]
 8006626:	e408      	b.n	8005e3a <_svfprintf_r+0x52>
 8006628:	9808      	ldr	r0, [sp, #32]
 800662a:	9209      	str	r2, [sp, #36]	; 0x24
 800662c:	f010 0f20 	tst.w	r0, #32
 8006630:	9316      	str	r3, [sp, #88]	; 0x58
 8006632:	f47f aefc 	bne.w	800642e <_svfprintf_r+0x646>
 8006636:	9908      	ldr	r1, [sp, #32]
 8006638:	f011 0f10 	tst.w	r1, #16
 800663c:	f040 8291 	bne.w	8006b62 <_svfprintf_r+0xd7a>
 8006640:	9808      	ldr	r0, [sp, #32]
 8006642:	f010 0f40 	tst.w	r0, #64	; 0x40
 8006646:	f000 828c 	beq.w	8006b62 <_svfprintf_r+0xd7a>
 800664a:	9912      	ldr	r1, [sp, #72]	; 0x48
 800664c:	2301      	movs	r3, #1
 800664e:	2500      	movs	r5, #0
 8006650:	880a      	ldrh	r2, [r1, #0]
 8006652:	3104      	adds	r1, #4
 8006654:	9112      	str	r1, [sp, #72]	; 0x48
 8006656:	4614      	mov	r4, r2
 8006658:	3a00      	subs	r2, #0
 800665a:	bf18      	it	ne
 800665c:	2201      	movne	r2, #1
 800665e:	e6d7      	b.n	8006410 <_svfprintf_r+0x628>
 8006660:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006662:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8006664:	681b      	ldr	r3, [r3, #0]
 8006666:	1d20      	adds	r0, r4, #4
 8006668:	2b00      	cmp	r3, #0
 800666a:	930d      	str	r3, [sp, #52]	; 0x34
 800666c:	f6ff ac8a 	blt.w	8005f84 <_svfprintf_r+0x19c>
 8006670:	7813      	ldrb	r3, [r2, #0]
 8006672:	9012      	str	r0, [sp, #72]	; 0x48
 8006674:	e425      	b.n	8005ec2 <_svfprintf_r+0xda>
 8006676:	9209      	str	r2, [sp, #36]	; 0x24
 8006678:	f64b 3060 	movw	r0, #47968	; 0xbb60
 800667c:	9a08      	ldr	r2, [sp, #32]
 800667e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006682:	9316      	str	r3, [sp, #88]	; 0x58
 8006684:	f012 0f20 	tst.w	r2, #32
 8006688:	9017      	str	r0, [sp, #92]	; 0x5c
 800668a:	f47f aee0 	bne.w	800644e <_svfprintf_r+0x666>
 800668e:	9908      	ldr	r1, [sp, #32]
 8006690:	f011 0f10 	tst.w	r1, #16
 8006694:	f000 82fa 	beq.w	8006c8c <_svfprintf_r+0xea4>
 8006698:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800669a:	2500      	movs	r5, #0
 800669c:	6814      	ldr	r4, [r2, #0]
 800669e:	3204      	adds	r2, #4
 80066a0:	9212      	str	r2, [sp, #72]	; 0x48
 80066a2:	e6dd      	b.n	8006460 <_svfprintf_r+0x678>
 80066a4:	9811      	ldr	r0, [sp, #68]	; 0x44
 80066a6:	aa39      	add	r2, sp, #228	; 0xe4
 80066a8:	990c      	ldr	r1, [sp, #48]	; 0x30
 80066aa:	f002 fe3b 	bl	8009324 <__ssprint_r>
 80066ae:	2800      	cmp	r0, #0
 80066b0:	f47f ac81 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 80066b4:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 80066b8:	4656      	mov	r6, sl
 80066ba:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80066bc:	e577      	b.n	80061ae <_svfprintf_r+0x3c6>
 80066be:	9a08      	ldr	r2, [sp, #32]
 80066c0:	f012 0f01 	tst.w	r2, #1
 80066c4:	f040 80fd 	bne.w	80068c2 <_svfprintf_r+0xada>
 80066c8:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80066ca:	3501      	adds	r5, #1
 80066cc:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80066ce:	2301      	movs	r3, #1
 80066d0:	3401      	adds	r4, #1
 80066d2:	f8c9 3004 	str.w	r3, [r9, #4]
 80066d6:	2c07      	cmp	r4, #7
 80066d8:	f8c9 2000 	str.w	r2, [r9]
 80066dc:	953b      	str	r5, [sp, #236]	; 0xec
 80066de:	943a      	str	r4, [sp, #232]	; 0xe8
 80066e0:	f300 851f 	bgt.w	8007122 <_svfprintf_r+0x133a>
 80066e4:	f109 0b08 	add.w	fp, r9, #8
 80066e8:	f10b 0908 	add.w	r9, fp, #8
 80066ec:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80066ee:	3401      	adds	r4, #1
 80066f0:	2c07      	cmp	r4, #7
 80066f2:	441d      	add	r5, r3
 80066f4:	f8cb 3004 	str.w	r3, [fp, #4]
 80066f8:	ab3e      	add	r3, sp, #248	; 0xf8
 80066fa:	f8cb 3000 	str.w	r3, [fp]
 80066fe:	953b      	str	r5, [sp, #236]	; 0xec
 8006700:	943a      	str	r4, [sp, #232]	; 0xe8
 8006702:	f77f adcd 	ble.w	80062a0 <_svfprintf_r+0x4b8>
 8006706:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006708:	aa39      	add	r2, sp, #228	; 0xe4
 800670a:	990c      	ldr	r1, [sp, #48]	; 0x30
 800670c:	f002 fe0a 	bl	8009324 <__ssprint_r>
 8006710:	2800      	cmp	r0, #0
 8006712:	f47f ac50 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8006716:	46d1      	mov	r9, sl
 8006718:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800671a:	e5c1      	b.n	80062a0 <_svfprintf_r+0x4b8>
 800671c:	9916      	ldr	r1, [sp, #88]	; 0x58
 800671e:	2965      	cmp	r1, #101	; 0x65
 8006720:	f340 80cb 	ble.w	80068ba <_svfprintf_r+0xad2>
 8006724:	981a      	ldr	r0, [sp, #104]	; 0x68
 8006726:	2200      	movs	r2, #0
 8006728:	2300      	movs	r3, #0
 800672a:	991b      	ldr	r1, [sp, #108]	; 0x6c
 800672c:	f004 fbe2 	bl	800aef4 <__aeabi_dcmpeq>
 8006730:	2800      	cmp	r0, #0
 8006732:	f000 813e 	beq.w	80069b2 <_svfprintf_r+0xbca>
 8006736:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006738:	f64b 337c 	movw	r3, #47996	; 0xbb7c
 800673c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006740:	f8c9 3000 	str.w	r3, [r9]
 8006744:	3401      	adds	r4, #1
 8006746:	2301      	movs	r3, #1
 8006748:	2c07      	cmp	r4, #7
 800674a:	f8c9 3004 	str.w	r3, [r9, #4]
 800674e:	441d      	add	r5, r3
 8006750:	943a      	str	r4, [sp, #232]	; 0xe8
 8006752:	953b      	str	r5, [sp, #236]	; 0xec
 8006754:	bfd8      	it	le
 8006756:	f109 0908 	addle.w	r9, r9, #8
 800675a:	f300 8346 	bgt.w	8006dea <_svfprintf_r+0x1002>
 800675e:	9b42      	ldr	r3, [sp, #264]	; 0x108
 8006760:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8006762:	4293      	cmp	r3, r2
 8006764:	db04      	blt.n	8006770 <_svfprintf_r+0x988>
 8006766:	9b08      	ldr	r3, [sp, #32]
 8006768:	f013 0f01 	tst.w	r3, #1
 800676c:	f43f ad98 	beq.w	80062a0 <_svfprintf_r+0x4b8>
 8006770:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006772:	981c      	ldr	r0, [sp, #112]	; 0x70
 8006774:	3401      	adds	r4, #1
 8006776:	9919      	ldr	r1, [sp, #100]	; 0x64
 8006778:	2c07      	cmp	r4, #7
 800677a:	4405      	add	r5, r0
 800677c:	f8c9 0004 	str.w	r0, [r9, #4]
 8006780:	bfd8      	it	le
 8006782:	f109 0308 	addle.w	r3, r9, #8
 8006786:	f8c9 1000 	str.w	r1, [r9]
 800678a:	953b      	str	r5, [sp, #236]	; 0xec
 800678c:	943a      	str	r4, [sp, #232]	; 0xe8
 800678e:	f300 83bc 	bgt.w	8006f0a <_svfprintf_r+0x1122>
 8006792:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8006794:	1e56      	subs	r6, r2, #1
 8006796:	2e00      	cmp	r6, #0
 8006798:	f340 831d 	ble.w	8006dd6 <_svfprintf_r+0xfee>
 800679c:	2e10      	cmp	r6, #16
 800679e:	f340 85e8 	ble.w	8007372 <_svfprintf_r+0x158a>
 80067a2:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80067a4:	2710      	movs	r7, #16
 80067a6:	f8df 84fc 	ldr.w	r8, [pc, #1276]	; 8006ca4 <_svfprintf_r+0xebc>
 80067aa:	4622      	mov	r2, r4
 80067ac:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 80067b0:	4644      	mov	r4, r8
 80067b2:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 80067b6:	e003      	b.n	80067c0 <_svfprintf_r+0x9d8>
 80067b8:	3e10      	subs	r6, #16
 80067ba:	2e10      	cmp	r6, #16
 80067bc:	f340 81c4 	ble.w	8006b48 <_svfprintf_r+0xd60>
 80067c0:	3201      	adds	r2, #1
 80067c2:	601c      	str	r4, [r3, #0]
 80067c4:	605f      	str	r7, [r3, #4]
 80067c6:	3510      	adds	r5, #16
 80067c8:	3308      	adds	r3, #8
 80067ca:	2a07      	cmp	r2, #7
 80067cc:	923a      	str	r2, [sp, #232]	; 0xe8
 80067ce:	f103 0908 	add.w	r9, r3, #8
 80067d2:	953b      	str	r5, [sp, #236]	; 0xec
 80067d4:	ddf0      	ble.n	80067b8 <_svfprintf_r+0x9d0>
 80067d6:	4640      	mov	r0, r8
 80067d8:	4659      	mov	r1, fp
 80067da:	aa39      	add	r2, sp, #228	; 0xe4
 80067dc:	f10a 0908 	add.w	r9, sl, #8
 80067e0:	f002 fda0 	bl	8009324 <__ssprint_r>
 80067e4:	4653      	mov	r3, sl
 80067e6:	2800      	cmp	r0, #0
 80067e8:	f47f abe5 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 80067ec:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80067ee:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 80067f0:	e7e2      	b.n	80067b8 <_svfprintf_r+0x9d0>
 80067f2:	2b00      	cmp	r3, #0
 80067f4:	f040 80b7 	bne.w	8006966 <_svfprintf_r+0xb7e>
 80067f8:	9c08      	ldr	r4, [sp, #32]
 80067fa:	f014 0f01 	tst.w	r4, #1
 80067fe:	f000 812b 	beq.w	8006a58 <_svfprintf_r+0xc70>
 8006802:	2001      	movs	r0, #1
 8006804:	2330      	movs	r3, #48	; 0x30
 8006806:	f10d 01e3 	add.w	r1, sp, #227	; 0xe3
 800680a:	9010      	str	r0, [sp, #64]	; 0x40
 800680c:	f88d 30e3 	strb.w	r3, [sp, #227]	; 0xe3
 8006810:	9113      	str	r1, [sp, #76]	; 0x4c
 8006812:	e46a      	b.n	80060ea <_svfprintf_r+0x302>
 8006814:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8006816:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8006818:	1b1f      	subs	r7, r3, r4
 800681a:	2f00      	cmp	r7, #0
 800681c:	f77f acea 	ble.w	80061f4 <_svfprintf_r+0x40c>
 8006820:	2f10      	cmp	r7, #16
 8006822:	f340 8569 	ble.w	80072f8 <_svfprintf_r+0x1510>
 8006826:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006828:	4633      	mov	r3, r6
 800682a:	f8df 8478 	ldr.w	r8, [pc, #1144]	; 8006ca4 <_svfprintf_r+0xebc>
 800682e:	f04f 0910 	mov.w	r9, #16
 8006832:	4622      	mov	r2, r4
 8006834:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 8006838:	4644      	mov	r4, r8
 800683a:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 800683e:	e002      	b.n	8006846 <_svfprintf_r+0xa5e>
 8006840:	3f10      	subs	r7, #16
 8006842:	2f10      	cmp	r7, #16
 8006844:	dd1b      	ble.n	800687e <_svfprintf_r+0xa96>
 8006846:	3201      	adds	r2, #1
 8006848:	601c      	str	r4, [r3, #0]
 800684a:	f8c3 9004 	str.w	r9, [r3, #4]
 800684e:	3510      	adds	r5, #16
 8006850:	3308      	adds	r3, #8
 8006852:	2a07      	cmp	r2, #7
 8006854:	923a      	str	r2, [sp, #232]	; 0xe8
 8006856:	f103 0608 	add.w	r6, r3, #8
 800685a:	953b      	str	r5, [sp, #236]	; 0xec
 800685c:	ddf0      	ble.n	8006840 <_svfprintf_r+0xa58>
 800685e:	4640      	mov	r0, r8
 8006860:	4659      	mov	r1, fp
 8006862:	aa39      	add	r2, sp, #228	; 0xe4
 8006864:	f10a 0608 	add.w	r6, sl, #8
 8006868:	f002 fd5c 	bl	8009324 <__ssprint_r>
 800686c:	4653      	mov	r3, sl
 800686e:	2800      	cmp	r0, #0
 8006870:	f47f aba1 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8006874:	3f10      	subs	r7, #16
 8006876:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006878:	2f10      	cmp	r7, #16
 800687a:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 800687c:	dce3      	bgt.n	8006846 <_svfprintf_r+0xa5e>
 800687e:	46a0      	mov	r8, r4
 8006880:	4614      	mov	r4, r2
 8006882:	3401      	adds	r4, #1
 8006884:	f8c3 8000 	str.w	r8, [r3]
 8006888:	2c07      	cmp	r4, #7
 800688a:	605f      	str	r7, [r3, #4]
 800688c:	443d      	add	r5, r7
 800688e:	943a      	str	r4, [sp, #232]	; 0xe8
 8006890:	953b      	str	r5, [sp, #236]	; 0xec
 8006892:	f77f acaf 	ble.w	80061f4 <_svfprintf_r+0x40c>
 8006896:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006898:	aa39      	add	r2, sp, #228	; 0xe4
 800689a:	990c      	ldr	r1, [sp, #48]	; 0x30
 800689c:	f002 fd42 	bl	8009324 <__ssprint_r>
 80068a0:	2800      	cmp	r0, #0
 80068a2:	f47f ab88 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 80068a6:	9914      	ldr	r1, [sp, #80]	; 0x50
 80068a8:	4656      	mov	r6, sl
 80068aa:	9810      	ldr	r0, [sp, #64]	; 0x40
 80068ac:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80068ae:	1a0f      	subs	r7, r1, r0
 80068b0:	2f00      	cmp	r7, #0
 80068b2:	f73f aca5 	bgt.w	8006200 <_svfprintf_r+0x418>
 80068b6:	46b1      	mov	r9, r6
 80068b8:	e4dd      	b.n	8006276 <_svfprintf_r+0x48e>
 80068ba:	990e      	ldr	r1, [sp, #56]	; 0x38
 80068bc:	2901      	cmp	r1, #1
 80068be:	f77f aefe 	ble.w	80066be <_svfprintf_r+0x8d6>
 80068c2:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80068c4:	3501      	adds	r5, #1
 80068c6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80068c8:	3401      	adds	r4, #1
 80068ca:	f8c9 3000 	str.w	r3, [r9]
 80068ce:	2301      	movs	r3, #1
 80068d0:	2c07      	cmp	r4, #7
 80068d2:	f8c9 3004 	str.w	r3, [r9, #4]
 80068d6:	bfd8      	it	le
 80068d8:	f109 0908 	addle.w	r9, r9, #8
 80068dc:	953b      	str	r5, [sp, #236]	; 0xec
 80068de:	943a      	str	r4, [sp, #232]	; 0xe8
 80068e0:	bfd8      	it	le
 80068e2:	f109 0608 	addle.w	r6, r9, #8
 80068e6:	f300 8141 	bgt.w	8006b6c <_svfprintf_r+0xd84>
 80068ea:	3401      	adds	r4, #1
 80068ec:	991c      	ldr	r1, [sp, #112]	; 0x70
 80068ee:	9819      	ldr	r0, [sp, #100]	; 0x64
 80068f0:	2c07      	cmp	r4, #7
 80068f2:	440d      	add	r5, r1
 80068f4:	bfd8      	it	le
 80068f6:	f106 0b08 	addle.w	fp, r6, #8
 80068fa:	f8c9 1004 	str.w	r1, [r9, #4]
 80068fe:	f8c9 0000 	str.w	r0, [r9]
 8006902:	943a      	str	r4, [sp, #232]	; 0xe8
 8006904:	953b      	str	r5, [sp, #236]	; 0xec
 8006906:	f300 813f 	bgt.w	8006b88 <_svfprintf_r+0xda0>
 800690a:	981a      	ldr	r0, [sp, #104]	; 0x68
 800690c:	2200      	movs	r2, #0
 800690e:	2300      	movs	r3, #0
 8006910:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8006912:	f004 faef 	bl	800aef4 <__aeabi_dcmpeq>
 8006916:	2800      	cmp	r0, #0
 8006918:	f040 80ce 	bne.w	8006ab8 <_svfprintf_r+0xcd0>
 800691c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800691e:	3401      	adds	r4, #1
 8006920:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8006922:	1e5a      	subs	r2, r3, #1
 8006924:	6072      	str	r2, [r6, #4]
 8006926:	1c43      	adds	r3, r0, #1
 8006928:	2c07      	cmp	r4, #7
 800692a:	6033      	str	r3, [r6, #0]
 800692c:	4415      	add	r5, r2
 800692e:	943a      	str	r4, [sp, #232]	; 0xe8
 8006930:	953b      	str	r5, [sp, #236]	; 0xec
 8006932:	f77f aed9 	ble.w	80066e8 <_svfprintf_r+0x900>
 8006936:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006938:	aa39      	add	r2, sp, #228	; 0xe4
 800693a:	990c      	ldr	r1, [sp, #48]	; 0x30
 800693c:	f002 fcf2 	bl	8009324 <__ssprint_r>
 8006940:	2800      	cmp	r0, #0
 8006942:	f47f ab38 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8006946:	f10a 0908 	add.w	r9, sl, #8
 800694a:	46d3      	mov	fp, sl
 800694c:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800694e:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006950:	e6cc      	b.n	80066ec <_svfprintf_r+0x904>
 8006952:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006954:	aa39      	add	r2, sp, #228	; 0xe4
 8006956:	990c      	ldr	r1, [sp, #48]	; 0x30
 8006958:	f002 fce4 	bl	8009324 <__ssprint_r>
 800695c:	2800      	cmp	r0, #0
 800695e:	f43f acf5 	beq.w	800634c <_svfprintf_r+0x564>
 8006962:	f7ff bb28 	b.w	8005fb6 <_svfprintf_r+0x1ce>
 8006966:	9210      	str	r2, [sp, #64]	; 0x40
 8006968:	aa39      	add	r2, sp, #228	; 0xe4
 800696a:	9213      	str	r2, [sp, #76]	; 0x4c
 800696c:	f7ff bbbd 	b.w	80060ea <_svfprintf_r+0x302>
 8006970:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006972:	aa39      	add	r2, sp, #228	; 0xe4
 8006974:	990c      	ldr	r1, [sp, #48]	; 0x30
 8006976:	f002 fcd5 	bl	8009324 <__ssprint_r>
 800697a:	2800      	cmp	r0, #0
 800697c:	f47f ab1b 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8006980:	46d1      	mov	r9, sl
 8006982:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006984:	e477      	b.n	8006276 <_svfprintf_r+0x48e>
 8006986:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006988:	aa39      	add	r2, sp, #228	; 0xe4
 800698a:	990c      	ldr	r1, [sp, #48]	; 0x30
 800698c:	f002 fcca 	bl	8009324 <__ssprint_r>
 8006990:	2800      	cmp	r0, #0
 8006992:	f47f ab10 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8006996:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006998:	4656      	mov	r6, sl
 800699a:	e427      	b.n	80061ec <_svfprintf_r+0x404>
 800699c:	9811      	ldr	r0, [sp, #68]	; 0x44
 800699e:	aa39      	add	r2, sp, #228	; 0xe4
 80069a0:	990c      	ldr	r1, [sp, #48]	; 0x30
 80069a2:	f002 fcbf 	bl	8009324 <__ssprint_r>
 80069a6:	2800      	cmp	r0, #0
 80069a8:	f47f ab05 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 80069ac:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80069ae:	4656      	mov	r6, sl
 80069b0:	e40c      	b.n	80061cc <_svfprintf_r+0x3e4>
 80069b2:	9e42      	ldr	r6, [sp, #264]	; 0x108
 80069b4:	2e00      	cmp	r6, #0
 80069b6:	f340 8223 	ble.w	8006e00 <_svfprintf_r+0x1018>
 80069ba:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 80069bc:	9c18      	ldr	r4, [sp, #96]	; 0x60
 80069be:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80069c0:	42a6      	cmp	r6, r4
 80069c2:	bfa8      	it	ge
 80069c4:	4626      	movge	r6, r4
 80069c6:	990e      	ldr	r1, [sp, #56]	; 0x38
 80069c8:	2e00      	cmp	r6, #0
 80069ca:	eb00 0b01 	add.w	fp, r0, r1
 80069ce:	dd0e      	ble.n	80069ee <_svfprintf_r+0xc06>
 80069d0:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80069d2:	19ad      	adds	r5, r5, r6
 80069d4:	f8c9 0000 	str.w	r0, [r9]
 80069d8:	3401      	adds	r4, #1
 80069da:	f8c9 6004 	str.w	r6, [r9, #4]
 80069de:	2c07      	cmp	r4, #7
 80069e0:	953b      	str	r5, [sp, #236]	; 0xec
 80069e2:	943a      	str	r4, [sp, #232]	; 0xe8
 80069e4:	bfd8      	it	le
 80069e6:	f109 0908 	addle.w	r9, r9, #8
 80069ea:	f300 8411 	bgt.w	8007210 <_svfprintf_r+0x1428>
 80069ee:	9a18      	ldr	r2, [sp, #96]	; 0x60
 80069f0:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
 80069f4:	1b96      	subs	r6, r2, r6
 80069f6:	2e00      	cmp	r6, #0
 80069f8:	f340 83e9 	ble.w	80071ce <_svfprintf_r+0x13e6>
 80069fc:	2e10      	cmp	r6, #16
 80069fe:	f340 84e1 	ble.w	80073c4 <_svfprintf_r+0x15dc>
 8006a02:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006a04:	4629      	mov	r1, r5
 8006a06:	f8df 829c 	ldr.w	r8, [pc, #668]	; 8006ca4 <_svfprintf_r+0xebc>
 8006a0a:	2710      	movs	r7, #16
 8006a0c:	4622      	mov	r2, r4
 8006a0e:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8006a10:	4644      	mov	r4, r8
 8006a12:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8006a16:	e003      	b.n	8006a20 <_svfprintf_r+0xc38>
 8006a18:	3e10      	subs	r6, #16
 8006a1a:	2e10      	cmp	r6, #16
 8006a1c:	f340 8170 	ble.w	8006d00 <_svfprintf_r+0xf18>
 8006a20:	3201      	adds	r2, #1
 8006a22:	3110      	adds	r1, #16
 8006a24:	2a07      	cmp	r2, #7
 8006a26:	f8c9 4000 	str.w	r4, [r9]
 8006a2a:	f8c9 7004 	str.w	r7, [r9, #4]
 8006a2e:	f109 0908 	add.w	r9, r9, #8
 8006a32:	923a      	str	r2, [sp, #232]	; 0xe8
 8006a34:	f109 0308 	add.w	r3, r9, #8
 8006a38:	913b      	str	r1, [sp, #236]	; 0xec
 8006a3a:	dded      	ble.n	8006a18 <_svfprintf_r+0xc30>
 8006a3c:	4640      	mov	r0, r8
 8006a3e:	4629      	mov	r1, r5
 8006a40:	aa39      	add	r2, sp, #228	; 0xe4
 8006a42:	46d1      	mov	r9, sl
 8006a44:	f002 fc6e 	bl	8009324 <__ssprint_r>
 8006a48:	f10a 0308 	add.w	r3, sl, #8
 8006a4c:	2800      	cmp	r0, #0
 8006a4e:	f47f aab2 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8006a52:	993b      	ldr	r1, [sp, #236]	; 0xec
 8006a54:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 8006a56:	e7df      	b.n	8006a18 <_svfprintf_r+0xc30>
 8006a58:	9310      	str	r3, [sp, #64]	; 0x40
 8006a5a:	ab39      	add	r3, sp, #228	; 0xe4
 8006a5c:	9313      	str	r3, [sp, #76]	; 0x4c
 8006a5e:	f7ff bb44 	b.w	80060ea <_svfprintf_r+0x302>
 8006a62:	f10d 0bbc 	add.w	fp, sp, #188	; 0xbc
 8006a66:	9917      	ldr	r1, [sp, #92]	; 0x5c
 8006a68:	f10b 0027 	add.w	r0, fp, #39	; 0x27
 8006a6c:	f004 020f 	and.w	r2, r4, #15
 8006a70:	0923      	lsrs	r3, r4, #4
 8006a72:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 8006a76:	ea4f 1c15 	mov.w	ip, r5, lsr #4
 8006a7a:	5c8a      	ldrb	r2, [r1, r2]
 8006a7c:	461c      	mov	r4, r3
 8006a7e:	4603      	mov	r3, r0
 8006a80:	4665      	mov	r5, ip
 8006a82:	3801      	subs	r0, #1
 8006a84:	701a      	strb	r2, [r3, #0]
 8006a86:	ea54 0205 	orrs.w	r2, r4, r5
 8006a8a:	d1ef      	bne.n	8006a6c <_svfprintf_r+0xc84>
 8006a8c:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8006a90:	9313      	str	r3, [sp, #76]	; 0x4c
 8006a92:	ebc3 030b 	rsb	r3, r3, fp
 8006a96:	9310      	str	r3, [sp, #64]	; 0x40
 8006a98:	f7ff bb27 	b.w	80060ea <_svfprintf_r+0x302>
 8006a9c:	2c0a      	cmp	r4, #10
 8006a9e:	f175 0100 	sbcs.w	r1, r5, #0
 8006aa2:	d27f      	bcs.n	8006ba4 <_svfprintf_r+0xdbc>
 8006aa4:	3430      	adds	r4, #48	; 0x30
 8006aa6:	2201      	movs	r2, #1
 8006aa8:	f10d 03e3 	add.w	r3, sp, #227	; 0xe3
 8006aac:	9210      	str	r2, [sp, #64]	; 0x40
 8006aae:	f88d 40e3 	strb.w	r4, [sp, #227]	; 0xe3
 8006ab2:	9313      	str	r3, [sp, #76]	; 0x4c
 8006ab4:	f7ff bb19 	b.w	80060ea <_svfprintf_r+0x302>
 8006ab8:	990e      	ldr	r1, [sp, #56]	; 0x38
 8006aba:	1e4f      	subs	r7, r1, #1
 8006abc:	2f00      	cmp	r7, #0
 8006abe:	bfdc      	itt	le
 8006ac0:	f106 0908 	addle.w	r9, r6, #8
 8006ac4:	46b3      	movle	fp, r6
 8006ac6:	f77f ae11 	ble.w	80066ec <_svfprintf_r+0x904>
 8006aca:	2f10      	cmp	r7, #16
 8006acc:	bfd8      	it	le
 8006ace:	f8df 81d4 	ldrle.w	r8, [pc, #468]	; 8006ca4 <_svfprintf_r+0xebc>
 8006ad2:	dd2c      	ble.n	8006b2e <_svfprintf_r+0xd46>
 8006ad4:	f8df 81cc 	ldr.w	r8, [pc, #460]	; 8006ca4 <_svfprintf_r+0xebc>
 8006ad8:	4623      	mov	r3, r4
 8006ada:	462a      	mov	r2, r5
 8006adc:	f04f 0910 	mov.w	r9, #16
 8006ae0:	4644      	mov	r4, r8
 8006ae2:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8006ae4:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8006ae8:	e002      	b.n	8006af0 <_svfprintf_r+0xd08>
 8006aea:	3f10      	subs	r7, #16
 8006aec:	2f10      	cmp	r7, #16
 8006aee:	dd1b      	ble.n	8006b28 <_svfprintf_r+0xd40>
 8006af0:	3301      	adds	r3, #1
 8006af2:	6034      	str	r4, [r6, #0]
 8006af4:	f8c6 9004 	str.w	r9, [r6, #4]
 8006af8:	3210      	adds	r2, #16
 8006afa:	3608      	adds	r6, #8
 8006afc:	2b07      	cmp	r3, #7
 8006afe:	933a      	str	r3, [sp, #232]	; 0xe8
 8006b00:	f106 0b08 	add.w	fp, r6, #8
 8006b04:	923b      	str	r2, [sp, #236]	; 0xec
 8006b06:	ddf0      	ble.n	8006aea <_svfprintf_r+0xd02>
 8006b08:	4640      	mov	r0, r8
 8006b0a:	4629      	mov	r1, r5
 8006b0c:	aa39      	add	r2, sp, #228	; 0xe4
 8006b0e:	f10a 0b08 	add.w	fp, sl, #8
 8006b12:	f002 fc07 	bl	8009324 <__ssprint_r>
 8006b16:	4656      	mov	r6, sl
 8006b18:	2800      	cmp	r0, #0
 8006b1a:	f47f aa4c 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8006b1e:	3f10      	subs	r7, #16
 8006b20:	9a3b      	ldr	r2, [sp, #236]	; 0xec
 8006b22:	2f10      	cmp	r7, #16
 8006b24:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 8006b26:	dce3      	bgt.n	8006af0 <_svfprintf_r+0xd08>
 8006b28:	46a0      	mov	r8, r4
 8006b2a:	4615      	mov	r5, r2
 8006b2c:	461c      	mov	r4, r3
 8006b2e:	3401      	adds	r4, #1
 8006b30:	f8c6 8000 	str.w	r8, [r6]
 8006b34:	2c07      	cmp	r4, #7
 8006b36:	6077      	str	r7, [r6, #4]
 8006b38:	443d      	add	r5, r7
 8006b3a:	943a      	str	r4, [sp, #232]	; 0xe8
 8006b3c:	953b      	str	r5, [sp, #236]	; 0xec
 8006b3e:	f77f add3 	ble.w	80066e8 <_svfprintf_r+0x900>
 8006b42:	e6f8      	b.n	8006936 <_svfprintf_r+0xb4e>
 8006b44:	2302      	movs	r3, #2
 8006b46:	e463      	b.n	8006410 <_svfprintf_r+0x628>
 8006b48:	46a0      	mov	r8, r4
 8006b4a:	4614      	mov	r4, r2
 8006b4c:	3401      	adds	r4, #1
 8006b4e:	f8c3 8000 	str.w	r8, [r3]
 8006b52:	2c07      	cmp	r4, #7
 8006b54:	605e      	str	r6, [r3, #4]
 8006b56:	4435      	add	r5, r6
 8006b58:	943a      	str	r4, [sp, #232]	; 0xe8
 8006b5a:	953b      	str	r5, [sp, #236]	; 0xec
 8006b5c:	f77f aba0 	ble.w	80062a0 <_svfprintf_r+0x4b8>
 8006b60:	e5d1      	b.n	8006706 <_svfprintf_r+0x91e>
 8006b62:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006b64:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8006b66:	681a      	ldr	r2, [r3, #0]
 8006b68:	2301      	movs	r3, #1
 8006b6a:	e528      	b.n	80065be <_svfprintf_r+0x7d6>
 8006b6c:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006b6e:	aa39      	add	r2, sp, #228	; 0xe4
 8006b70:	990c      	ldr	r1, [sp, #48]	; 0x30
 8006b72:	f002 fbd7 	bl	8009324 <__ssprint_r>
 8006b76:	2800      	cmp	r0, #0
 8006b78:	f47f aa1d 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8006b7c:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006b7e:	f10a 0608 	add.w	r6, sl, #8
 8006b82:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006b84:	46d1      	mov	r9, sl
 8006b86:	e6b0      	b.n	80068ea <_svfprintf_r+0xb02>
 8006b88:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006b8a:	aa39      	add	r2, sp, #228	; 0xe4
 8006b8c:	990c      	ldr	r1, [sp, #48]	; 0x30
 8006b8e:	f002 fbc9 	bl	8009324 <__ssprint_r>
 8006b92:	2800      	cmp	r0, #0
 8006b94:	f47f aa0f 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8006b98:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006b9a:	f10a 0b08 	add.w	fp, sl, #8
 8006b9e:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006ba0:	4656      	mov	r6, sl
 8006ba2:	e6b2      	b.n	800690a <_svfprintf_r+0xb22>
 8006ba4:	f10d 0bbc 	add.w	fp, sp, #188	; 0xbc
 8006ba8:	46b1      	mov	r9, r6
 8006baa:	f10b 0827 	add.w	r8, fp, #39	; 0x27
 8006bae:	4620      	mov	r0, r4
 8006bb0:	4629      	mov	r1, r5
 8006bb2:	220a      	movs	r2, #10
 8006bb4:	2300      	movs	r3, #0
 8006bb6:	f004 f9f7 	bl	800afa8 <__aeabi_uldivmod>
 8006bba:	4646      	mov	r6, r8
 8006bbc:	4620      	mov	r0, r4
 8006bbe:	4629      	mov	r1, r5
 8006bc0:	2300      	movs	r3, #0
 8006bc2:	f108 38ff 	add.w	r8, r8, #4294967295
 8006bc6:	f102 0430 	add.w	r4, r2, #48	; 0x30
 8006bca:	220a      	movs	r2, #10
 8006bcc:	7034      	strb	r4, [r6, #0]
 8006bce:	f004 f9eb 	bl	800afa8 <__aeabi_uldivmod>
 8006bd2:	4604      	mov	r4, r0
 8006bd4:	460d      	mov	r5, r1
 8006bd6:	ea54 0005 	orrs.w	r0, r4, r5
 8006bda:	d1e8      	bne.n	8006bae <_svfprintf_r+0xdc6>
 8006bdc:	9613      	str	r6, [sp, #76]	; 0x4c
 8006bde:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8006be2:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8006be4:	464e      	mov	r6, r9
 8006be6:	ebc1 010b 	rsb	r1, r1, fp
 8006bea:	9110      	str	r1, [sp, #64]	; 0x40
 8006bec:	f7ff ba7d 	b.w	80060ea <_svfprintf_r+0x302>
 8006bf0:	2a30      	cmp	r2, #48	; 0x30
 8006bf2:	f000 8333 	beq.w	800725c <_svfprintf_r+0x1474>
 8006bf6:	9313      	str	r3, [sp, #76]	; 0x4c
 8006bf8:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8006bfc:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8006bfe:	ebc3 040b 	rsb	r4, r3, fp
 8006c02:	2330      	movs	r3, #48	; 0x30
 8006c04:	9410      	str	r4, [sp, #64]	; 0x40
 8006c06:	7003      	strb	r3, [r0, #0]
 8006c08:	f7ff ba6f 	b.w	80060ea <_svfprintf_r+0x302>
 8006c0c:	4264      	negs	r4, r4
 8006c0e:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 8006c12:	232d      	movs	r3, #45	; 0x2d
 8006c14:	ea54 0005 	orrs.w	r0, r4, r5
 8006c18:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
 8006c1c:	bf0c      	ite	eq
 8006c1e:	2200      	moveq	r2, #0
 8006c20:	2201      	movne	r2, #1
 8006c22:	2301      	movs	r3, #1
 8006c24:	f7ff ba2c 	b.w	8006080 <_svfprintf_r+0x298>
 8006c28:	981a      	ldr	r0, [sp, #104]	; 0x68
 8006c2a:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8006c2c:	f002 fb02 	bl	8009234 <__fpclassifyd>
 8006c30:	2800      	cmp	r0, #0
 8006c32:	f040 8175 	bne.w	8006f20 <_svfprintf_r+0x1138>
 8006c36:	9014      	str	r0, [sp, #80]	; 0x50
 8006c38:	f64b 3348 	movw	r3, #47944	; 0xbb48
 8006c3c:	f64b 3244 	movw	r2, #47940	; 0xbb44
 8006c40:	9816      	ldr	r0, [sp, #88]	; 0x58
 8006c42:	f6c0 0200 	movt	r2, #2048	; 0x800
 8006c46:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006c4a:	2847      	cmp	r0, #71	; 0x47
 8006c4c:	bfd8      	it	le
 8006c4e:	4613      	movle	r3, r2
 8006c50:	9313      	str	r3, [sp, #76]	; 0x4c
 8006c52:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8006c54:	2403      	movs	r4, #3
 8006c56:	9908      	ldr	r1, [sp, #32]
 8006c58:	940a      	str	r4, [sp, #40]	; 0x28
 8006c5a:	f021 0180 	bic.w	r1, r1, #128	; 0x80
 8006c5e:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8006c62:	9108      	str	r1, [sp, #32]
 8006c64:	9410      	str	r4, [sp, #64]	; 0x40
 8006c66:	9318      	str	r3, [sp, #96]	; 0x60
 8006c68:	f7ff ba49 	b.w	80060fe <_svfprintf_r+0x316>
 8006c6c:	7813      	ldrb	r3, [r2, #0]
 8006c6e:	f7ff b928 	b.w	8005ec2 <_svfprintf_r+0xda>
 8006c72:	9912      	ldr	r1, [sp, #72]	; 0x48
 8006c74:	1dcb      	adds	r3, r1, #7
 8006c76:	f023 0307 	bic.w	r3, r3, #7
 8006c7a:	f103 0208 	add.w	r2, r3, #8
 8006c7e:	9212      	str	r2, [sp, #72]	; 0x48
 8006c80:	681c      	ldr	r4, [r3, #0]
 8006c82:	941a      	str	r4, [sp, #104]	; 0x68
 8006c84:	685b      	ldr	r3, [r3, #4]
 8006c86:	931b      	str	r3, [sp, #108]	; 0x6c
 8006c88:	f7ff bb77 	b.w	800637a <_svfprintf_r+0x592>
 8006c8c:	9b08      	ldr	r3, [sp, #32]
 8006c8e:	f013 0f40 	tst.w	r3, #64	; 0x40
 8006c92:	f000 8126 	beq.w	8006ee2 <_svfprintf_r+0x10fa>
 8006c96:	9812      	ldr	r0, [sp, #72]	; 0x48
 8006c98:	2500      	movs	r5, #0
 8006c9a:	8804      	ldrh	r4, [r0, #0]
 8006c9c:	3004      	adds	r0, #4
 8006c9e:	9012      	str	r0, [sp, #72]	; 0x48
 8006ca0:	f7ff bbde 	b.w	8006460 <_svfprintf_r+0x678>
 8006ca4:	0800b7dc 	.word	0x0800b7dc
 8006ca8:	9b08      	ldr	r3, [sp, #32]
 8006caa:	f013 0f40 	tst.w	r3, #64	; 0x40
 8006cae:	f000 8111 	beq.w	8006ed4 <_svfprintf_r+0x10ec>
 8006cb2:	9812      	ldr	r0, [sp, #72]	; 0x48
 8006cb4:	f9b0 4000 	ldrsh.w	r4, [r0]
 8006cb8:	3004      	adds	r0, #4
 8006cba:	9012      	str	r0, [sp, #72]	; 0x48
 8006cbc:	17e5      	asrs	r5, r4, #31
 8006cbe:	f7ff b9d3 	b.w	8006068 <_svfprintf_r+0x280>
 8006cc2:	9908      	ldr	r1, [sp, #32]
 8006cc4:	f011 0f10 	tst.w	r1, #16
 8006cc8:	f000 8112 	beq.w	8006ef0 <_svfprintf_r+0x1108>
 8006ccc:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8006cce:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 8006cd0:	6813      	ldr	r3, [r2, #0]
 8006cd2:	3204      	adds	r2, #4
 8006cd4:	9212      	str	r2, [sp, #72]	; 0x48
 8006cd6:	601c      	str	r4, [r3, #0]
 8006cd8:	f7ff b8af 	b.w	8005e3a <_svfprintf_r+0x52>
 8006cdc:	9808      	ldr	r0, [sp, #32]
 8006cde:	f010 0340 	ands.w	r3, r0, #64	; 0x40
 8006ce2:	f000 81fc 	beq.w	80070de <_svfprintf_r+0x12f6>
 8006ce6:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006ce8:	2500      	movs	r5, #0
 8006cea:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8006cec:	8819      	ldrh	r1, [r3, #0]
 8006cee:	3404      	adds	r4, #4
 8006cf0:	4613      	mov	r3, r2
 8006cf2:	9412      	str	r4, [sp, #72]	; 0x48
 8006cf4:	1e0a      	subs	r2, r1, #0
 8006cf6:	460c      	mov	r4, r1
 8006cf8:	bf18      	it	ne
 8006cfa:	2201      	movne	r2, #1
 8006cfc:	f7ff bb88 	b.w	8006410 <_svfprintf_r+0x628>
 8006d00:	46a0      	mov	r8, r4
 8006d02:	460d      	mov	r5, r1
 8006d04:	4614      	mov	r4, r2
 8006d06:	3401      	adds	r4, #1
 8006d08:	f8c9 8000 	str.w	r8, [r9]
 8006d0c:	2c07      	cmp	r4, #7
 8006d0e:	f8c9 6004 	str.w	r6, [r9, #4]
 8006d12:	4435      	add	r5, r6
 8006d14:	943a      	str	r4, [sp, #232]	; 0xe8
 8006d16:	953b      	str	r5, [sp, #236]	; 0xec
 8006d18:	f300 82af 	bgt.w	800727a <_svfprintf_r+0x1492>
 8006d1c:	9a42      	ldr	r2, [sp, #264]	; 0x108
 8006d1e:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 8006d20:	42a2      	cmp	r2, r4
 8006d22:	db4a      	blt.n	8006dba <_svfprintf_r+0xfd2>
 8006d24:	9808      	ldr	r0, [sp, #32]
 8006d26:	f010 0f01 	tst.w	r0, #1
 8006d2a:	d146      	bne.n	8006dba <_svfprintf_r+0xfd2>
 8006d2c:	9c13      	ldr	r4, [sp, #76]	; 0x4c
 8006d2e:	9818      	ldr	r0, [sp, #96]	; 0x60
 8006d30:	1821      	adds	r1, r4, r0
 8006d32:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 8006d34:	ebc1 070b 	rsb	r7, r1, fp
 8006d38:	1aa2      	subs	r2, r4, r2
 8006d3a:	42ba      	cmp	r2, r7
 8006d3c:	bfb8      	it	lt
 8006d3e:	4617      	movlt	r7, r2
 8006d40:	2f00      	cmp	r7, #0
 8006d42:	dd0a      	ble.n	8006d5a <_svfprintf_r+0xf72>
 8006d44:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006d46:	19ed      	adds	r5, r5, r7
 8006d48:	6019      	str	r1, [r3, #0]
 8006d4a:	3401      	adds	r4, #1
 8006d4c:	605f      	str	r7, [r3, #4]
 8006d4e:	2c07      	cmp	r4, #7
 8006d50:	953b      	str	r5, [sp, #236]	; 0xec
 8006d52:	943a      	str	r4, [sp, #232]	; 0xe8
 8006d54:	f300 8274 	bgt.w	8007240 <_svfprintf_r+0x1458>
 8006d58:	3308      	adds	r3, #8
 8006d5a:	ea27 76e7 	bic.w	r6, r7, r7, asr #31
 8006d5e:	1b96      	subs	r6, r2, r6
 8006d60:	2e00      	cmp	r6, #0
 8006d62:	dd38      	ble.n	8006dd6 <_svfprintf_r+0xfee>
 8006d64:	2e10      	cmp	r6, #16
 8006d66:	f340 8304 	ble.w	8007372 <_svfprintf_r+0x158a>
 8006d6a:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006d6c:	2710      	movs	r7, #16
 8006d6e:	f8df 86b4 	ldr.w	r8, [pc, #1716]	; 8007424 <_svfprintf_r+0x163c>
 8006d72:	4622      	mov	r2, r4
 8006d74:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 8006d78:	4644      	mov	r4, r8
 8006d7a:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8006d7e:	e003      	b.n	8006d88 <_svfprintf_r+0xfa0>
 8006d80:	3e10      	subs	r6, #16
 8006d82:	2e10      	cmp	r6, #16
 8006d84:	f77f aee0 	ble.w	8006b48 <_svfprintf_r+0xd60>
 8006d88:	3201      	adds	r2, #1
 8006d8a:	601c      	str	r4, [r3, #0]
 8006d8c:	605f      	str	r7, [r3, #4]
 8006d8e:	3510      	adds	r5, #16
 8006d90:	3308      	adds	r3, #8
 8006d92:	2a07      	cmp	r2, #7
 8006d94:	923a      	str	r2, [sp, #232]	; 0xe8
 8006d96:	f103 0908 	add.w	r9, r3, #8
 8006d9a:	953b      	str	r5, [sp, #236]	; 0xec
 8006d9c:	ddf0      	ble.n	8006d80 <_svfprintf_r+0xf98>
 8006d9e:	4640      	mov	r0, r8
 8006da0:	4659      	mov	r1, fp
 8006da2:	aa39      	add	r2, sp, #228	; 0xe4
 8006da4:	f10a 0908 	add.w	r9, sl, #8
 8006da8:	f002 fabc 	bl	8009324 <__ssprint_r>
 8006dac:	4653      	mov	r3, sl
 8006dae:	2800      	cmp	r0, #0
 8006db0:	f47f a901 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8006db4:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006db6:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
 8006db8:	e7e2      	b.n	8006d80 <_svfprintf_r+0xf98>
 8006dba:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006dbc:	991c      	ldr	r1, [sp, #112]	; 0x70
 8006dbe:	3401      	adds	r4, #1
 8006dc0:	9819      	ldr	r0, [sp, #100]	; 0x64
 8006dc2:	2c07      	cmp	r4, #7
 8006dc4:	440d      	add	r5, r1
 8006dc6:	6059      	str	r1, [r3, #4]
 8006dc8:	6018      	str	r0, [r3, #0]
 8006dca:	953b      	str	r5, [sp, #236]	; 0xec
 8006dcc:	943a      	str	r4, [sp, #232]	; 0xe8
 8006dce:	f300 822b 	bgt.w	8007228 <_svfprintf_r+0x1440>
 8006dd2:	3308      	adds	r3, #8
 8006dd4:	e7aa      	b.n	8006d2c <_svfprintf_r+0xf44>
 8006dd6:	4699      	mov	r9, r3
 8006dd8:	f7ff ba62 	b.w	80062a0 <_svfprintf_r+0x4b8>
 8006ddc:	f106 0908 	add.w	r9, r6, #8
 8006de0:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006de2:	f8df 8640 	ldr.w	r8, [pc, #1600]	; 8007424 <_svfprintf_r+0x163c>
 8006de6:	f7ff ba3c 	b.w	8006262 <_svfprintf_r+0x47a>
 8006dea:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006dec:	aa39      	add	r2, sp, #228	; 0xe4
 8006dee:	990c      	ldr	r1, [sp, #48]	; 0x30
 8006df0:	f002 fa98 	bl	8009324 <__ssprint_r>
 8006df4:	2800      	cmp	r0, #0
 8006df6:	f47f a8de 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8006dfa:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006dfc:	46d1      	mov	r9, sl
 8006dfe:	e4ae      	b.n	800675e <_svfprintf_r+0x976>
 8006e00:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006e02:	f64b 337c 	movw	r3, #47996	; 0xbb7c
 8006e06:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006e0a:	f8c9 3000 	str.w	r3, [r9]
 8006e0e:	3401      	adds	r4, #1
 8006e10:	2301      	movs	r3, #1
 8006e12:	2c07      	cmp	r4, #7
 8006e14:	f8c9 3004 	str.w	r3, [r9, #4]
 8006e18:	441d      	add	r5, r3
 8006e1a:	943a      	str	r4, [sp, #232]	; 0xe8
 8006e1c:	953b      	str	r5, [sp, #236]	; 0xec
 8006e1e:	bfd8      	it	le
 8006e20:	f109 0908 	addle.w	r9, r9, #8
 8006e24:	f300 818c 	bgt.w	8007140 <_svfprintf_r+0x1358>
 8006e28:	b936      	cbnz	r6, 8006e38 <_svfprintf_r+0x1050>
 8006e2a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8006e2c:	b923      	cbnz	r3, 8006e38 <_svfprintf_r+0x1050>
 8006e2e:	9c08      	ldr	r4, [sp, #32]
 8006e30:	f014 0f01 	tst.w	r4, #1
 8006e34:	f43f aa34 	beq.w	80062a0 <_svfprintf_r+0x4b8>
 8006e38:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8006e3a:	981c      	ldr	r0, [sp, #112]	; 0x70
 8006e3c:	3401      	adds	r4, #1
 8006e3e:	9919      	ldr	r1, [sp, #100]	; 0x64
 8006e40:	2c07      	cmp	r4, #7
 8006e42:	4405      	add	r5, r0
 8006e44:	f8c9 0004 	str.w	r0, [r9, #4]
 8006e48:	f8c9 1000 	str.w	r1, [r9]
 8006e4c:	bfd8      	it	le
 8006e4e:	f109 0908 	addle.w	r9, r9, #8
 8006e52:	953b      	str	r5, [sp, #236]	; 0xec
 8006e54:	943a      	str	r4, [sp, #232]	; 0xe8
 8006e56:	f300 81ab 	bgt.w	80071b0 <_svfprintf_r+0x13c8>
 8006e5a:	4276      	negs	r6, r6
 8006e5c:	2e00      	cmp	r6, #0
 8006e5e:	f340 8198 	ble.w	8007192 <_svfprintf_r+0x13aa>
 8006e62:	2e10      	cmp	r6, #16
 8006e64:	bfd8      	it	le
 8006e66:	f8df 85bc 	ldrle.w	r8, [pc, #1468]	; 8007424 <_svfprintf_r+0x163c>
 8006e6a:	f340 817a 	ble.w	8007162 <_svfprintf_r+0x137a>
 8006e6e:	f8df 85b4 	ldr.w	r8, [pc, #1460]	; 8007424 <_svfprintf_r+0x163c>
 8006e72:	4623      	mov	r3, r4
 8006e74:	2710      	movs	r7, #16
 8006e76:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 8006e7a:	4644      	mov	r4, r8
 8006e7c:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8006e80:	e003      	b.n	8006e8a <_svfprintf_r+0x10a2>
 8006e82:	3e10      	subs	r6, #16
 8006e84:	2e10      	cmp	r6, #16
 8006e86:	f340 816a 	ble.w	800715e <_svfprintf_r+0x1376>
 8006e8a:	3301      	adds	r3, #1
 8006e8c:	3510      	adds	r5, #16
 8006e8e:	2b07      	cmp	r3, #7
 8006e90:	f8c9 4000 	str.w	r4, [r9]
 8006e94:	f8c9 7004 	str.w	r7, [r9, #4]
 8006e98:	f109 0908 	add.w	r9, r9, #8
 8006e9c:	933a      	str	r3, [sp, #232]	; 0xe8
 8006e9e:	953b      	str	r5, [sp, #236]	; 0xec
 8006ea0:	ddef      	ble.n	8006e82 <_svfprintf_r+0x109a>
 8006ea2:	4640      	mov	r0, r8
 8006ea4:	4659      	mov	r1, fp
 8006ea6:	aa39      	add	r2, sp, #228	; 0xe4
 8006ea8:	46d1      	mov	r9, sl
 8006eaa:	f002 fa3b 	bl	8009324 <__ssprint_r>
 8006eae:	2800      	cmp	r0, #0
 8006eb0:	f47f a881 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8006eb4:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006eb6:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 8006eb8:	e7e3      	b.n	8006e82 <_svfprintf_r+0x109a>
 8006eba:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8006ebc:	2200      	movs	r2, #0
 8006ebe:	9412      	str	r4, [sp, #72]	; 0x48
 8006ec0:	2400      	movs	r4, #0
 8006ec2:	9214      	str	r2, [sp, #80]	; 0x50
 8006ec4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8006ec8:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8006ecc:	930a      	str	r3, [sp, #40]	; 0x28
 8006ece:	9418      	str	r4, [sp, #96]	; 0x60
 8006ed0:	f7ff b915 	b.w	80060fe <_svfprintf_r+0x316>
 8006ed4:	9912      	ldr	r1, [sp, #72]	; 0x48
 8006ed6:	680c      	ldr	r4, [r1, #0]
 8006ed8:	3104      	adds	r1, #4
 8006eda:	9112      	str	r1, [sp, #72]	; 0x48
 8006edc:	17e5      	asrs	r5, r4, #31
 8006ede:	f7ff b8c3 	b.w	8006068 <_svfprintf_r+0x280>
 8006ee2:	9912      	ldr	r1, [sp, #72]	; 0x48
 8006ee4:	2500      	movs	r5, #0
 8006ee6:	680c      	ldr	r4, [r1, #0]
 8006ee8:	3104      	adds	r1, #4
 8006eea:	9112      	str	r1, [sp, #72]	; 0x48
 8006eec:	f7ff bab8 	b.w	8006460 <_svfprintf_r+0x678>
 8006ef0:	9808      	ldr	r0, [sp, #32]
 8006ef2:	f010 0f40 	tst.w	r0, #64	; 0x40
 8006ef6:	f000 810c 	beq.w	8007112 <_svfprintf_r+0x132a>
 8006efa:	9912      	ldr	r1, [sp, #72]	; 0x48
 8006efc:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8006efe:	680b      	ldr	r3, [r1, #0]
 8006f00:	3104      	adds	r1, #4
 8006f02:	9112      	str	r1, [sp, #72]	; 0x48
 8006f04:	801a      	strh	r2, [r3, #0]
 8006f06:	f7fe bf98 	b.w	8005e3a <_svfprintf_r+0x52>
 8006f0a:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006f0c:	aa39      	add	r2, sp, #228	; 0xe4
 8006f0e:	990c      	ldr	r1, [sp, #48]	; 0x30
 8006f10:	f002 fa08 	bl	8009324 <__ssprint_r>
 8006f14:	2800      	cmp	r0, #0
 8006f16:	f47f a84e 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8006f1a:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8006f1c:	4653      	mov	r3, sl
 8006f1e:	e438      	b.n	8006792 <_svfprintf_r+0x9aa>
 8006f20:	f1b7 3fff 	cmp.w	r7, #4294967295
 8006f24:	f000 8151 	beq.w	80071ca <_svfprintf_r+0x13e2>
 8006f28:	9c16      	ldr	r4, [sp, #88]	; 0x58
 8006f2a:	f1a4 0e67 	sub.w	lr, r4, #103	; 0x67
 8006f2e:	f1de 0300 	rsbs	r3, lr, #0
 8006f32:	eb43 030e 	adc.w	r3, r3, lr
 8006f36:	2c47      	cmp	r4, #71	; 0x47
 8006f38:	bf08      	it	eq
 8006f3a:	f043 0301 	orreq.w	r3, r3, #1
 8006f3e:	b113      	cbz	r3, 8006f46 <_svfprintf_r+0x115e>
 8006f40:	2f00      	cmp	r7, #0
 8006f42:	bf08      	it	eq
 8006f44:	2701      	moveq	r7, #1
 8006f46:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8006f48:	9808      	ldr	r0, [sp, #32]
 8006f4a:	2b00      	cmp	r3, #0
 8006f4c:	f440 7080 	orr.w	r0, r0, #256	; 0x100
 8006f50:	9008      	str	r0, [sp, #32]
 8006f52:	f2c0 8201 	blt.w	8007358 <_svfprintf_r+0x1570>
 8006f56:	f8dd 906c 	ldr.w	r9, [sp, #108]	; 0x6c
 8006f5a:	2200      	movs	r2, #0
 8006f5c:	9214      	str	r2, [sp, #80]	; 0x50
 8006f5e:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8006f60:	f1a3 0466 	sub.w	r4, r3, #102	; 0x66
 8006f64:	f1d4 0b00 	rsbs	fp, r4, #0
 8006f68:	eb4b 0b04 	adc.w	fp, fp, r4
 8006f6c:	2b46      	cmp	r3, #70	; 0x46
 8006f6e:	bf08      	it	eq
 8006f70:	f04b 0b01 	orreq.w	fp, fp, #1
 8006f74:	f1bb 0f00 	cmp.w	fp, #0
 8006f78:	f040 81bb 	bne.w	80072f2 <_svfprintf_r+0x150a>
 8006f7c:	2b45      	cmp	r3, #69	; 0x45
 8006f7e:	d002      	beq.n	8006f86 <_svfprintf_r+0x119e>
 8006f80:	2b65      	cmp	r3, #101	; 0x65
 8006f82:	f040 81e6 	bne.w	8007352 <_svfprintf_r+0x156a>
 8006f86:	f107 0801 	add.w	r8, r7, #1
 8006f8a:	2302      	movs	r3, #2
 8006f8c:	9c1a      	ldr	r4, [sp, #104]	; 0x68
 8006f8e:	a942      	add	r1, sp, #264	; 0x108
 8006f90:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
 8006f94:	9300      	str	r3, [sp, #0]
 8006f96:	940a      	str	r4, [sp, #40]	; 0x28
 8006f98:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 8006f9c:	9811      	ldr	r0, [sp, #68]	; 0x44
 8006f9e:	9102      	str	r1, [sp, #8]
 8006fa0:	a941      	add	r1, sp, #260	; 0x104
 8006fa2:	f8cd 8004 	str.w	r8, [sp, #4]
 8006fa6:	9103      	str	r1, [sp, #12]
 8006fa8:	a940      	add	r1, sp, #256	; 0x100
 8006faa:	9104      	str	r1, [sp, #16]
 8006fac:	f000 fafe 	bl	80075ac <_dtoa_r>
 8006fb0:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8006fb2:	f1b2 0367 	subs.w	r3, r2, #103	; 0x67
 8006fb6:	bf18      	it	ne
 8006fb8:	2301      	movne	r3, #1
 8006fba:	2a47      	cmp	r2, #71	; 0x47
 8006fbc:	bf0c      	ite	eq
 8006fbe:	2300      	moveq	r3, #0
 8006fc0:	f003 0301 	andne.w	r3, r3, #1
 8006fc4:	9013      	str	r0, [sp, #76]	; 0x4c
 8006fc6:	b923      	cbnz	r3, 8006fd2 <_svfprintf_r+0x11ea>
 8006fc8:	9b08      	ldr	r3, [sp, #32]
 8006fca:	f013 0f01 	tst.w	r3, #1
 8006fce:	f000 81e1 	beq.w	8007394 <_svfprintf_r+0x15ac>
 8006fd2:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8006fd4:	eb00 0408 	add.w	r4, r0, r8
 8006fd8:	f1bb 0f00 	cmp.w	fp, #0
 8006fdc:	d005      	beq.n	8006fea <_svfprintf_r+0x1202>
 8006fde:	7803      	ldrb	r3, [r0, #0]
 8006fe0:	2b30      	cmp	r3, #48	; 0x30
 8006fe2:	f000 81e2 	beq.w	80073aa <_svfprintf_r+0x15c2>
 8006fe6:	9b42      	ldr	r3, [sp, #264]	; 0x108
 8006fe8:	18e4      	adds	r4, r4, r3
 8006fea:	981a      	ldr	r0, [sp, #104]	; 0x68
 8006fec:	2200      	movs	r2, #0
 8006fee:	2300      	movs	r3, #0
 8006ff0:	4649      	mov	r1, r9
 8006ff2:	f003 ff7f 	bl	800aef4 <__aeabi_dcmpeq>
 8006ff6:	2800      	cmp	r0, #0
 8006ff8:	f000 8185 	beq.w	8007306 <_svfprintf_r+0x151e>
 8006ffc:	4623      	mov	r3, r4
 8006ffe:	9440      	str	r4, [sp, #256]	; 0x100
 8007000:	9916      	ldr	r1, [sp, #88]	; 0x58
 8007002:	9c13      	ldr	r4, [sp, #76]	; 0x4c
 8007004:	f1a1 0067 	sub.w	r0, r1, #103	; 0x67
 8007008:	4242      	negs	r2, r0
 800700a:	ebc4 0303 	rsb	r3, r4, r3
 800700e:	eb42 0200 	adc.w	r2, r2, r0
 8007012:	930e      	str	r3, [sp, #56]	; 0x38
 8007014:	2947      	cmp	r1, #71	; 0x47
 8007016:	bf14      	ite	ne
 8007018:	4613      	movne	r3, r2
 800701a:	f042 0301 	orreq.w	r3, r2, #1
 800701e:	2b00      	cmp	r3, #0
 8007020:	f000 8148 	beq.w	80072b4 <_svfprintf_r+0x14cc>
 8007024:	9b42      	ldr	r3, [sp, #264]	; 0x108
 8007026:	f113 0f03 	cmn.w	r3, #3
 800702a:	9310      	str	r3, [sp, #64]	; 0x40
 800702c:	db02      	blt.n	8007034 <_svfprintf_r+0x124c>
 800702e:	429f      	cmp	r7, r3
 8007030:	f280 8174 	bge.w	800731c <_svfprintf_r+0x1534>
 8007034:	9816      	ldr	r0, [sp, #88]	; 0x58
 8007036:	3802      	subs	r0, #2
 8007038:	9016      	str	r0, [sp, #88]	; 0x58
 800703a:	3b01      	subs	r3, #1
 800703c:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800703e:	2b00      	cmp	r3, #0
 8007040:	9342      	str	r3, [sp, #264]	; 0x108
 8007042:	f88d 20f8 	strb.w	r2, [sp, #248]	; 0xf8
 8007046:	f2c0 81c3 	blt.w	80073d0 <_svfprintf_r+0x15e8>
 800704a:	222b      	movs	r2, #43	; 0x2b
 800704c:	f88d 20f9 	strb.w	r2, [sp, #249]	; 0xf9
 8007050:	2b09      	cmp	r3, #9
 8007052:	f340 8186 	ble.w	8007362 <_svfprintf_r+0x157a>
 8007056:	f246 6467 	movw	r4, #26215	; 0x6667
 800705a:	f10d 00f6 	add.w	r0, sp, #246	; 0xf6
 800705e:	f2c6 6466 	movt	r4, #26214	; 0x6666
 8007062:	fb84 2103 	smull	r2, r1, r4, r3
 8007066:	17da      	asrs	r2, r3, #31
 8007068:	4605      	mov	r5, r0
 800706a:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
 800706e:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 8007072:	eba3 0141 	sub.w	r1, r3, r1, lsl #1
 8007076:	4613      	mov	r3, r2
 8007078:	3130      	adds	r1, #48	; 0x30
 800707a:	2a09      	cmp	r2, #9
 800707c:	f800 1901 	strb.w	r1, [r0], #-1
 8007080:	dcef      	bgt.n	8007062 <_svfprintf_r+0x127a>
 8007082:	3330      	adds	r3, #48	; 0x30
 8007084:	1e6a      	subs	r2, r5, #1
 8007086:	f805 3c01 	strb.w	r3, [r5, #-1]
 800708a:	f10d 03f7 	add.w	r3, sp, #247	; 0xf7
 800708e:	429a      	cmp	r2, r3
 8007090:	f080 81c4 	bcs.w	800741c <_svfprintf_r+0x1634>
 8007094:	f10d 03fa 	add.w	r3, sp, #250	; 0xfa
 8007098:	f812 1b01 	ldrb.w	r1, [r2], #1
 800709c:	f803 1b01 	strb.w	r1, [r3], #1
 80070a0:	4619      	mov	r1, r3
 80070a2:	9c07      	ldr	r4, [sp, #28]
 80070a4:	4294      	cmp	r4, r2
 80070a6:	d8f7      	bhi.n	8007098 <_svfprintf_r+0x12b0>
 80070a8:	ab3e      	add	r3, sp, #248	; 0xf8
 80070aa:	980e      	ldr	r0, [sp, #56]	; 0x38
 80070ac:	1acb      	subs	r3, r1, r3
 80070ae:	990e      	ldr	r1, [sp, #56]	; 0x38
 80070b0:	1818      	adds	r0, r3, r0
 80070b2:	931d      	str	r3, [sp, #116]	; 0x74
 80070b4:	2901      	cmp	r1, #1
 80070b6:	9010      	str	r0, [sp, #64]	; 0x40
 80070b8:	f340 816e 	ble.w	8007398 <_svfprintf_r+0x15b0>
 80070bc:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80070be:	2400      	movs	r4, #0
 80070c0:	9418      	str	r4, [sp, #96]	; 0x60
 80070c2:	3301      	adds	r3, #1
 80070c4:	9310      	str	r3, [sp, #64]	; 0x40
 80070c6:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80070c8:	2b00      	cmp	r3, #0
 80070ca:	f040 8107 	bne.w	80072dc <_svfprintf_r+0x14f4>
 80070ce:	9c10      	ldr	r4, [sp, #64]	; 0x40
 80070d0:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 80070d4:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
 80070d8:	940a      	str	r4, [sp, #40]	; 0x28
 80070da:	f7ff b810 	b.w	80060fe <_svfprintf_r+0x316>
 80070de:	9812      	ldr	r0, [sp, #72]	; 0x48
 80070e0:	2500      	movs	r5, #0
 80070e2:	6802      	ldr	r2, [r0, #0]
 80070e4:	3004      	adds	r0, #4
 80070e6:	9012      	str	r0, [sp, #72]	; 0x48
 80070e8:	4614      	mov	r4, r2
 80070ea:	3a00      	subs	r2, #0
 80070ec:	bf18      	it	ne
 80070ee:	2201      	movne	r2, #1
 80070f0:	f7ff b98e 	b.w	8006410 <_svfprintf_r+0x628>
 80070f4:	2140      	movs	r1, #64	; 0x40
 80070f6:	9811      	ldr	r0, [sp, #68]	; 0x44
 80070f8:	f7fd fdce 	bl	8004c98 <_malloc_r>
 80070fc:	990c      	ldr	r1, [sp, #48]	; 0x30
 80070fe:	6008      	str	r0, [r1, #0]
 8007100:	6108      	str	r0, [r1, #16]
 8007102:	2800      	cmp	r0, #0
 8007104:	f000 8182 	beq.w	800740c <_svfprintf_r+0x1624>
 8007108:	980c      	ldr	r0, [sp, #48]	; 0x30
 800710a:	2340      	movs	r3, #64	; 0x40
 800710c:	6143      	str	r3, [r0, #20]
 800710e:	f7fe be82 	b.w	8005e16 <_svfprintf_r+0x2e>
 8007112:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8007114:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007116:	6823      	ldr	r3, [r4, #0]
 8007118:	3404      	adds	r4, #4
 800711a:	9412      	str	r4, [sp, #72]	; 0x48
 800711c:	6018      	str	r0, [r3, #0]
 800711e:	f7fe be8c 	b.w	8005e3a <_svfprintf_r+0x52>
 8007122:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007124:	aa39      	add	r2, sp, #228	; 0xe4
 8007126:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007128:	f002 f8fc 	bl	8009324 <__ssprint_r>
 800712c:	2800      	cmp	r0, #0
 800712e:	f47e af42 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8007132:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007134:	f10d 0984 	add.w	r9, sp, #132	; 0x84
 8007138:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 800713a:	46d3      	mov	fp, sl
 800713c:	f7ff bad6 	b.w	80066ec <_svfprintf_r+0x904>
 8007140:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007142:	aa39      	add	r2, sp, #228	; 0xe4
 8007144:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007146:	f002 f8ed 	bl	8009324 <__ssprint_r>
 800714a:	2800      	cmp	r0, #0
 800714c:	f47e af33 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8007150:	9e42      	ldr	r6, [sp, #264]	; 0x108
 8007152:	46d1      	mov	r9, sl
 8007154:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007156:	2e00      	cmp	r6, #0
 8007158:	f47f ae6e 	bne.w	8006e38 <_svfprintf_r+0x1050>
 800715c:	e665      	b.n	8006e2a <_svfprintf_r+0x1042>
 800715e:	46a0      	mov	r8, r4
 8007160:	461c      	mov	r4, r3
 8007162:	3401      	adds	r4, #1
 8007164:	f8c9 8000 	str.w	r8, [r9]
 8007168:	2c07      	cmp	r4, #7
 800716a:	f8c9 6004 	str.w	r6, [r9, #4]
 800716e:	4435      	add	r5, r6
 8007170:	943a      	str	r4, [sp, #232]	; 0xe8
 8007172:	953b      	str	r5, [sp, #236]	; 0xec
 8007174:	bfd8      	it	le
 8007176:	f109 0908 	addle.w	r9, r9, #8
 800717a:	dd0a      	ble.n	8007192 <_svfprintf_r+0x13aa>
 800717c:	9811      	ldr	r0, [sp, #68]	; 0x44
 800717e:	aa39      	add	r2, sp, #228	; 0xe4
 8007180:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007182:	f002 f8cf 	bl	8009324 <__ssprint_r>
 8007186:	2800      	cmp	r0, #0
 8007188:	f47e af15 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 800718c:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800718e:	46d1      	mov	r9, sl
 8007190:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007192:	3401      	adds	r4, #1
 8007194:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8007196:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8007198:	2c07      	cmp	r4, #7
 800719a:	441d      	add	r5, r3
 800719c:	f8c9 3004 	str.w	r3, [r9, #4]
 80071a0:	f8c9 2000 	str.w	r2, [r9]
 80071a4:	943a      	str	r4, [sp, #232]	; 0xe8
 80071a6:	953b      	str	r5, [sp, #236]	; 0xec
 80071a8:	f77f a878 	ble.w	800629c <_svfprintf_r+0x4b4>
 80071ac:	f7ff baab 	b.w	8006706 <_svfprintf_r+0x91e>
 80071b0:	9811      	ldr	r0, [sp, #68]	; 0x44
 80071b2:	aa39      	add	r2, sp, #228	; 0xe4
 80071b4:	990c      	ldr	r1, [sp, #48]	; 0x30
 80071b6:	f002 f8b5 	bl	8009324 <__ssprint_r>
 80071ba:	2800      	cmp	r0, #0
 80071bc:	f47e aefb 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 80071c0:	9e42      	ldr	r6, [sp, #264]	; 0x108
 80071c2:	46d1      	mov	r9, sl
 80071c4:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 80071c6:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80071c8:	e647      	b.n	8006e5a <_svfprintf_r+0x1072>
 80071ca:	2706      	movs	r7, #6
 80071cc:	e6bb      	b.n	8006f46 <_svfprintf_r+0x115e>
 80071ce:	464b      	mov	r3, r9
 80071d0:	e5a4      	b.n	8006d1c <_svfprintf_r+0xf34>
 80071d2:	222d      	movs	r2, #45	; 0x2d
 80071d4:	f88d 210f 	strb.w	r2, [sp, #271]	; 0x10f
 80071d8:	f7ff b8e1 	b.w	800639e <_svfprintf_r+0x5b6>
 80071dc:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80071de:	2100      	movs	r1, #0
 80071e0:	9114      	str	r1, [sp, #80]	; 0x50
 80071e2:	f002 f86f 	bl	80092c4 <strlen>
 80071e6:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80071e8:	9412      	str	r4, [sp, #72]	; 0x48
 80071ea:	9318      	str	r3, [sp, #96]	; 0x60
 80071ec:	ea20 72e0 	bic.w	r2, r0, r0, asr #31
 80071f0:	9010      	str	r0, [sp, #64]	; 0x40
 80071f2:	920a      	str	r2, [sp, #40]	; 0x28
 80071f4:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 80071f8:	f7fe bf81 	b.w	80060fe <_svfprintf_r+0x316>
 80071fc:	f24b 78cc 	movw	r8, #47052	; 0xb7cc
 8007200:	f106 0308 	add.w	r3, r6, #8
 8007204:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007206:	f6c0 0800 	movt	r8, #2048	; 0x800
 800720a:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 800720c:	f7fe bfc2 	b.w	8006194 <_svfprintf_r+0x3ac>
 8007210:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007212:	aa39      	add	r2, sp, #228	; 0xe4
 8007214:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007216:	f002 f885 	bl	8009324 <__ssprint_r>
 800721a:	2800      	cmp	r0, #0
 800721c:	f47e aecb 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8007220:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007222:	46d1      	mov	r9, sl
 8007224:	f7ff bbe3 	b.w	80069ee <_svfprintf_r+0xc06>
 8007228:	9811      	ldr	r0, [sp, #68]	; 0x44
 800722a:	aa39      	add	r2, sp, #228	; 0xe4
 800722c:	990c      	ldr	r1, [sp, #48]	; 0x30
 800722e:	f002 f879 	bl	8009324 <__ssprint_r>
 8007232:	2800      	cmp	r0, #0
 8007234:	f47e aebf 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8007238:	9a42      	ldr	r2, [sp, #264]	; 0x108
 800723a:	4653      	mov	r3, sl
 800723c:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800723e:	e575      	b.n	8006d2c <_svfprintf_r+0xf44>
 8007240:	9811      	ldr	r0, [sp, #68]	; 0x44
 8007242:	aa39      	add	r2, sp, #228	; 0xe4
 8007244:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007246:	f002 f86d 	bl	8009324 <__ssprint_r>
 800724a:	2800      	cmp	r0, #0
 800724c:	f47e aeb3 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 8007250:	9a42      	ldr	r2, [sp, #264]	; 0x108
 8007252:	4653      	mov	r3, sl
 8007254:	980e      	ldr	r0, [sp, #56]	; 0x38
 8007256:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8007258:	1a82      	subs	r2, r0, r2
 800725a:	e57e      	b.n	8006d5a <_svfprintf_r+0xf72>
 800725c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800725e:	f10b 0b28 	add.w	fp, fp, #40	; 0x28
 8007262:	ebc3 030b 	rsb	r3, r3, fp
 8007266:	9310      	str	r3, [sp, #64]	; 0x40
 8007268:	f7fe bf3f 	b.w	80060ea <_svfprintf_r+0x302>
 800726c:	f24b 78cc 	movw	r8, #47052	; 0xb7cc
 8007270:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007272:	f6c0 0800 	movt	r8, #2048	; 0x800
 8007276:	f7ff b84b 	b.w	8006310 <_svfprintf_r+0x528>
 800727a:	9811      	ldr	r0, [sp, #68]	; 0x44
 800727c:	aa39      	add	r2, sp, #228	; 0xe4
 800727e:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007280:	f002 f850 	bl	8009324 <__ssprint_r>
 8007284:	2800      	cmp	r0, #0
 8007286:	f47e ae96 	bne.w	8005fb6 <_svfprintf_r+0x1ce>
 800728a:	4653      	mov	r3, sl
 800728c:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 800728e:	e545      	b.n	8006d1c <_svfprintf_r+0xf34>
 8007290:	2f06      	cmp	r7, #6
 8007292:	bf28      	it	cs
 8007294:	2706      	movcs	r7, #6
 8007296:	f64b 3074 	movw	r0, #47988	; 0xbb74
 800729a:	ea27 71e7 	bic.w	r1, r7, r7, asr #31
 800729e:	f6c0 0000 	movt	r0, #2048	; 0x800
 80072a2:	461a      	mov	r2, r3
 80072a4:	9710      	str	r7, [sp, #64]	; 0x40
 80072a6:	910a      	str	r1, [sp, #40]	; 0x28
 80072a8:	9412      	str	r4, [sp, #72]	; 0x48
 80072aa:	9314      	str	r3, [sp, #80]	; 0x50
 80072ac:	9318      	str	r3, [sp, #96]	; 0x60
 80072ae:	9013      	str	r0, [sp, #76]	; 0x4c
 80072b0:	f7fe bf25 	b.w	80060fe <_svfprintf_r+0x316>
 80072b4:	9916      	ldr	r1, [sp, #88]	; 0x58
 80072b6:	2966      	cmp	r1, #102	; 0x66
 80072b8:	f040 808f 	bne.w	80073da <_svfprintf_r+0x15f2>
 80072bc:	9b42      	ldr	r3, [sp, #264]	; 0x108
 80072be:	2b00      	cmp	r3, #0
 80072c0:	9310      	str	r3, [sp, #64]	; 0x40
 80072c2:	f340 8098 	ble.w	80073f6 <_svfprintf_r+0x160e>
 80072c6:	b91f      	cbnz	r7, 80072d0 <_svfprintf_r+0x14e8>
 80072c8:	9808      	ldr	r0, [sp, #32]
 80072ca:	f010 0f01 	tst.w	r0, #1
 80072ce:	d002      	beq.n	80072d6 <_svfprintf_r+0x14ee>
 80072d0:	1c5a      	adds	r2, r3, #1
 80072d2:	19d2      	adds	r2, r2, r7
 80072d4:	9210      	str	r2, [sp, #64]	; 0x40
 80072d6:	9318      	str	r3, [sp, #96]	; 0x60
 80072d8:	9516      	str	r5, [sp, #88]	; 0x58
 80072da:	e6f4      	b.n	80070c6 <_svfprintf_r+0x12de>
 80072dc:	9810      	ldr	r0, [sp, #64]	; 0x40
 80072de:	222d      	movs	r2, #45	; 0x2d
 80072e0:	2100      	movs	r1, #0
 80072e2:	f88d 210f 	strb.w	r2, [sp, #271]	; 0x10f
 80072e6:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80072ea:	9114      	str	r1, [sp, #80]	; 0x50
 80072ec:	900a      	str	r0, [sp, #40]	; 0x28
 80072ee:	f7fe bf07 	b.w	8006100 <_svfprintf_r+0x318>
 80072f2:	46b8      	mov	r8, r7
 80072f4:	2303      	movs	r3, #3
 80072f6:	e649      	b.n	8006f8c <_svfprintf_r+0x11a4>
 80072f8:	4633      	mov	r3, r6
 80072fa:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80072fc:	3608      	adds	r6, #8
 80072fe:	f8df 8124 	ldr.w	r8, [pc, #292]	; 8007424 <_svfprintf_r+0x163c>
 8007302:	f7ff babe 	b.w	8006882 <_svfprintf_r+0xa9a>
 8007306:	9b40      	ldr	r3, [sp, #256]	; 0x100
 8007308:	429c      	cmp	r4, r3
 800730a:	f67f ae79 	bls.w	8007000 <_svfprintf_r+0x1218>
 800730e:	2230      	movs	r2, #48	; 0x30
 8007310:	f803 2b01 	strb.w	r2, [r3], #1
 8007314:	42a3      	cmp	r3, r4
 8007316:	9340      	str	r3, [sp, #256]	; 0x100
 8007318:	d1fa      	bne.n	8007310 <_svfprintf_r+0x1528>
 800731a:	e671      	b.n	8007000 <_svfprintf_r+0x1218>
 800731c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800731e:	4293      	cmp	r3, r2
 8007320:	db2e      	blt.n	8007380 <_svfprintf_r+0x1598>
 8007322:	9c08      	ldr	r4, [sp, #32]
 8007324:	f014 0f01 	tst.w	r4, #1
 8007328:	d03d      	beq.n	80073a6 <_svfprintf_r+0x15be>
 800732a:	1c58      	adds	r0, r3, #1
 800732c:	2567      	movs	r5, #103	; 0x67
 800732e:	9010      	str	r0, [sp, #64]	; 0x40
 8007330:	e7d1      	b.n	80072d6 <_svfprintf_r+0x14ee>
 8007332:	ea27 72e7 	bic.w	r2, r7, r7, asr #31
 8007336:	9014      	str	r0, [sp, #80]	; 0x50
 8007338:	920a      	str	r2, [sp, #40]	; 0x28
 800733a:	9412      	str	r4, [sp, #72]	; 0x48
 800733c:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
 8007340:	9710      	str	r7, [sp, #64]	; 0x40
 8007342:	9018      	str	r0, [sp, #96]	; 0x60
 8007344:	f7fe bedb 	b.w	80060fe <_svfprintf_r+0x316>
 8007348:	2700      	movs	r7, #0
 800734a:	ea47 77e7 	orr.w	r7, r7, r7, asr #31
 800734e:	f7fe bdb9 	b.w	8005ec4 <_svfprintf_r+0xdc>
 8007352:	46b8      	mov	r8, r7
 8007354:	2302      	movs	r3, #2
 8007356:	e619      	b.n	8006f8c <_svfprintf_r+0x11a4>
 8007358:	212d      	movs	r1, #45	; 0x2d
 800735a:	f103 4900 	add.w	r9, r3, #2147483648	; 0x80000000
 800735e:	9114      	str	r1, [sp, #80]	; 0x50
 8007360:	e5fd      	b.n	8006f5e <_svfprintf_r+0x1176>
 8007362:	3330      	adds	r3, #48	; 0x30
 8007364:	2230      	movs	r2, #48	; 0x30
 8007366:	a93f      	add	r1, sp, #252	; 0xfc
 8007368:	f88d 20fa 	strb.w	r2, [sp, #250]	; 0xfa
 800736c:	f88d 30fb 	strb.w	r3, [sp, #251]	; 0xfb
 8007370:	e69a      	b.n	80070a8 <_svfprintf_r+0x12c0>
 8007372:	f103 0908 	add.w	r9, r3, #8
 8007376:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 8007378:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8007424 <_svfprintf_r+0x163c>
 800737c:	f7ff bbe6 	b.w	8006b4c <_svfprintf_r+0xd64>
 8007380:	2b00      	cmp	r3, #0
 8007382:	990e      	ldr	r1, [sp, #56]	; 0x38
 8007384:	bfd4      	ite	le
 8007386:	f1c3 0202 	rsble	r2, r3, #2
 800738a:	2201      	movgt	r2, #1
 800738c:	1852      	adds	r2, r2, r1
 800738e:	2567      	movs	r5, #103	; 0x67
 8007390:	9210      	str	r2, [sp, #64]	; 0x40
 8007392:	e7a0      	b.n	80072d6 <_svfprintf_r+0x14ee>
 8007394:	9b40      	ldr	r3, [sp, #256]	; 0x100
 8007396:	e633      	b.n	8007000 <_svfprintf_r+0x1218>
 8007398:	9a08      	ldr	r2, [sp, #32]
 800739a:	f012 0301 	ands.w	r3, r2, #1
 800739e:	f47f ae8d 	bne.w	80070bc <_svfprintf_r+0x12d4>
 80073a2:	9318      	str	r3, [sp, #96]	; 0x60
 80073a4:	e68f      	b.n	80070c6 <_svfprintf_r+0x12de>
 80073a6:	2567      	movs	r5, #103	; 0x67
 80073a8:	e795      	b.n	80072d6 <_svfprintf_r+0x14ee>
 80073aa:	981a      	ldr	r0, [sp, #104]	; 0x68
 80073ac:	2200      	movs	r2, #0
 80073ae:	2300      	movs	r3, #0
 80073b0:	4649      	mov	r1, r9
 80073b2:	f003 fd9f 	bl	800aef4 <__aeabi_dcmpeq>
 80073b6:	2800      	cmp	r0, #0
 80073b8:	f47f ae15 	bne.w	8006fe6 <_svfprintf_r+0x11fe>
 80073bc:	f1c8 0301 	rsb	r3, r8, #1
 80073c0:	9342      	str	r3, [sp, #264]	; 0x108
 80073c2:	e610      	b.n	8006fe6 <_svfprintf_r+0x11fe>
 80073c4:	f109 0308 	add.w	r3, r9, #8
 80073c8:	9c3a      	ldr	r4, [sp, #232]	; 0xe8
 80073ca:	f8df 8058 	ldr.w	r8, [pc, #88]	; 8007424 <_svfprintf_r+0x163c>
 80073ce:	e49a      	b.n	8006d06 <_svfprintf_r+0xf1e>
 80073d0:	222d      	movs	r2, #45	; 0x2d
 80073d2:	425b      	negs	r3, r3
 80073d4:	f88d 20f9 	strb.w	r2, [sp, #249]	; 0xf9
 80073d8:	e63a      	b.n	8007050 <_svfprintf_r+0x1268>
 80073da:	9b42      	ldr	r3, [sp, #264]	; 0x108
 80073dc:	e62d      	b.n	800703a <_svfprintf_r+0x1252>
 80073de:	9812      	ldr	r0, [sp, #72]	; 0x48
 80073e0:	6807      	ldr	r7, [r0, #0]
 80073e2:	3004      	adds	r0, #4
 80073e4:	2f00      	cmp	r7, #0
 80073e6:	f6bf a943 	bge.w	8006670 <_svfprintf_r+0x888>
 80073ea:	7813      	ldrb	r3, [r2, #0]
 80073ec:	f04f 37ff 	mov.w	r7, #4294967295
 80073f0:	9012      	str	r0, [sp, #72]	; 0x48
 80073f2:	f7fe bd66 	b.w	8005ec2 <_svfprintf_r+0xda>
 80073f6:	b91f      	cbnz	r7, 8007400 <_svfprintf_r+0x1618>
 80073f8:	9908      	ldr	r1, [sp, #32]
 80073fa:	f011 0f01 	tst.w	r1, #1
 80073fe:	d002      	beq.n	8007406 <_svfprintf_r+0x161e>
 8007400:	3702      	adds	r7, #2
 8007402:	9710      	str	r7, [sp, #64]	; 0x40
 8007404:	e767      	b.n	80072d6 <_svfprintf_r+0x14ee>
 8007406:	2201      	movs	r2, #1
 8007408:	9210      	str	r2, [sp, #64]	; 0x40
 800740a:	e764      	b.n	80072d6 <_svfprintf_r+0x14ee>
 800740c:	9c11      	ldr	r4, [sp, #68]	; 0x44
 800740e:	f04f 32ff 	mov.w	r2, #4294967295
 8007412:	230c      	movs	r3, #12
 8007414:	920f      	str	r2, [sp, #60]	; 0x3c
 8007416:	6023      	str	r3, [r4, #0]
 8007418:	f7fe bdd6 	b.w	8005fc8 <_svfprintf_r+0x1e0>
 800741c:	f10d 01fa 	add.w	r1, sp, #250	; 0xfa
 8007420:	e642      	b.n	80070a8 <_svfprintf_r+0x12c0>
 8007422:	bf00      	nop
 8007424:	0800b7dc 	.word	0x0800b7dc

08007428 <_write_r>:
 8007428:	b538      	push	{r3, r4, r5, lr}
 800742a:	f641 24e4 	movw	r4, #6884	; 0x1ae4
 800742e:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8007432:	4605      	mov	r5, r0
 8007434:	4608      	mov	r0, r1
 8007436:	4611      	mov	r1, r2
 8007438:	461a      	mov	r2, r3
 800743a:	2300      	movs	r3, #0
 800743c:	6023      	str	r3, [r4, #0]
 800743e:	f7f9 fb03 	bl	8000a48 <_write>
 8007442:	f1b0 3fff 	cmp.w	r0, #4294967295
 8007446:	d000      	beq.n	800744a <_write_r+0x22>
 8007448:	bd38      	pop	{r3, r4, r5, pc}
 800744a:	6823      	ldr	r3, [r4, #0]
 800744c:	2b00      	cmp	r3, #0
 800744e:	d0fb      	beq.n	8007448 <_write_r+0x20>
 8007450:	602b      	str	r3, [r5, #0]
 8007452:	bd38      	pop	{r3, r4, r5, pc}

08007454 <_close_r>:
 8007454:	b538      	push	{r3, r4, r5, lr}
 8007456:	f641 24e4 	movw	r4, #6884	; 0x1ae4
 800745a:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800745e:	4605      	mov	r5, r0
 8007460:	4608      	mov	r0, r1
 8007462:	2300      	movs	r3, #0
 8007464:	6023      	str	r3, [r4, #0]
 8007466:	f7f9 fa83 	bl	8000970 <_close>
 800746a:	f1b0 3fff 	cmp.w	r0, #4294967295
 800746e:	d000      	beq.n	8007472 <_close_r+0x1e>
 8007470:	bd38      	pop	{r3, r4, r5, pc}
 8007472:	6823      	ldr	r3, [r4, #0]
 8007474:	2b00      	cmp	r3, #0
 8007476:	d0fb      	beq.n	8007470 <_close_r+0x1c>
 8007478:	602b      	str	r3, [r5, #0]
 800747a:	bd38      	pop	{r3, r4, r5, pc}
 800747c:	0000      	movs	r0, r0
	...

08007480 <quorem>:
 8007480:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007484:	b083      	sub	sp, #12
 8007486:	6903      	ldr	r3, [r0, #16]
 8007488:	4681      	mov	r9, r0
 800748a:	690d      	ldr	r5, [r1, #16]
 800748c:	9101      	str	r1, [sp, #4]
 800748e:	429d      	cmp	r5, r3
 8007490:	f300 8089 	bgt.w	80075a6 <quorem+0x126>
 8007494:	1cea      	adds	r2, r5, #3
 8007496:	f101 0414 	add.w	r4, r1, #20
 800749a:	f100 0814 	add.w	r8, r0, #20
 800749e:	3d01      	subs	r5, #1
 80074a0:	0092      	lsls	r2, r2, #2
 80074a2:	188b      	adds	r3, r1, r2
 80074a4:	1882      	adds	r2, r0, r2
 80074a6:	1d1f      	adds	r7, r3, #4
 80074a8:	6859      	ldr	r1, [r3, #4]
 80074aa:	6850      	ldr	r0, [r2, #4]
 80074ac:	3101      	adds	r1, #1
 80074ae:	f002 ffc3 	bl	800a438 <__aeabi_uidiv>
 80074b2:	4606      	mov	r6, r0
 80074b4:	2800      	cmp	r0, #0
 80074b6:	d03c      	beq.n	8007532 <quorem+0xb2>
 80074b8:	2000      	movs	r0, #0
 80074ba:	4642      	mov	r2, r8
 80074bc:	4623      	mov	r3, r4
 80074be:	4686      	mov	lr, r0
 80074c0:	f853 cb04 	ldr.w	ip, [r3], #4
 80074c4:	6811      	ldr	r1, [r2, #0]
 80074c6:	fa1f fb8c 	uxth.w	fp, ip
 80074ca:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 80074ce:	fa1f fa81 	uxth.w	sl, r1
 80074d2:	fb0b 0b06 	mla	fp, fp, r6, r0
 80074d6:	44d6      	add	lr, sl
 80074d8:	fb0c f006 	mul.w	r0, ip, r6
 80074dc:	eb00 401b 	add.w	r0, r0, fp, lsr #16
 80074e0:	fa1f fb8b 	uxth.w	fp, fp
 80074e4:	ebcb 0a0e 	rsb	sl, fp, lr
 80074e8:	fa1f fe80 	uxth.w	lr, r0
 80074ec:	0c00      	lsrs	r0, r0, #16
 80074ee:	ebce 4e11 	rsb	lr, lr, r1, lsr #16
 80074f2:	429f      	cmp	r7, r3
 80074f4:	eb0e 4e2a 	add.w	lr, lr, sl, asr #16
 80074f8:	fa1f fc8a 	uxth.w	ip, sl
 80074fc:	ea4c 410e 	orr.w	r1, ip, lr, lsl #16
 8007500:	ea4f 4e2e 	mov.w	lr, lr, asr #16
 8007504:	f842 1b04 	str.w	r1, [r2], #4
 8007508:	d2da      	bcs.n	80074c0 <quorem+0x40>
 800750a:	1d2a      	adds	r2, r5, #4
 800750c:	eb09 0382 	add.w	r3, r9, r2, lsl #2
 8007510:	6859      	ldr	r1, [r3, #4]
 8007512:	b971      	cbnz	r1, 8007532 <quorem+0xb2>
 8007514:	4598      	cmp	r8, r3
 8007516:	d20a      	bcs.n	800752e <quorem+0xae>
 8007518:	f859 2022 	ldr.w	r2, [r9, r2, lsl #2]
 800751c:	b93a      	cbnz	r2, 800752e <quorem+0xae>
 800751e:	3b04      	subs	r3, #4
 8007520:	e002      	b.n	8007528 <quorem+0xa8>
 8007522:	f853 2904 	ldr.w	r2, [r3], #-4
 8007526:	b912      	cbnz	r2, 800752e <quorem+0xae>
 8007528:	3d01      	subs	r5, #1
 800752a:	4598      	cmp	r8, r3
 800752c:	d3f9      	bcc.n	8007522 <quorem+0xa2>
 800752e:	f8c9 5010 	str.w	r5, [r9, #16]
 8007532:	4648      	mov	r0, r9
 8007534:	9901      	ldr	r1, [sp, #4]
 8007536:	f001 fbc3 	bl	8008cc0 <__mcmp>
 800753a:	2800      	cmp	r0, #0
 800753c:	db2f      	blt.n	800759e <quorem+0x11e>
 800753e:	3601      	adds	r6, #1
 8007540:	4643      	mov	r3, r8
 8007542:	f04f 0c00 	mov.w	ip, #0
 8007546:	f854 0b04 	ldr.w	r0, [r4], #4
 800754a:	6819      	ldr	r1, [r3, #0]
 800754c:	fa1f fa80 	uxth.w	sl, r0
 8007550:	0c00      	lsrs	r0, r0, #16
 8007552:	b28a      	uxth	r2, r1
 8007554:	ebc0 4111 	rsb	r1, r0, r1, lsr #16
 8007558:	ebca 0202 	rsb	r2, sl, r2
 800755c:	42a7      	cmp	r7, r4
 800755e:	4494      	add	ip, r2
 8007560:	eb01 422c 	add.w	r2, r1, ip, asr #16
 8007564:	fa1f fc8c 	uxth.w	ip, ip
 8007568:	ea4c 4102 	orr.w	r1, ip, r2, lsl #16
 800756c:	ea4f 4c22 	mov.w	ip, r2, asr #16
 8007570:	f843 1b04 	str.w	r1, [r3], #4
 8007574:	d2e7      	bcs.n	8007546 <quorem+0xc6>
 8007576:	1d2a      	adds	r2, r5, #4
 8007578:	eb09 0382 	add.w	r3, r9, r2, lsl #2
 800757c:	6859      	ldr	r1, [r3, #4]
 800757e:	b971      	cbnz	r1, 800759e <quorem+0x11e>
 8007580:	4598      	cmp	r8, r3
 8007582:	d20a      	bcs.n	800759a <quorem+0x11a>
 8007584:	f859 2022 	ldr.w	r2, [r9, r2, lsl #2]
 8007588:	b93a      	cbnz	r2, 800759a <quorem+0x11a>
 800758a:	3b04      	subs	r3, #4
 800758c:	e002      	b.n	8007594 <quorem+0x114>
 800758e:	f853 2904 	ldr.w	r2, [r3], #-4
 8007592:	b912      	cbnz	r2, 800759a <quorem+0x11a>
 8007594:	3d01      	subs	r5, #1
 8007596:	4598      	cmp	r8, r3
 8007598:	d3f9      	bcc.n	800758e <quorem+0x10e>
 800759a:	f8c9 5010 	str.w	r5, [r9, #16]
 800759e:	4630      	mov	r0, r6
 80075a0:	b003      	add	sp, #12
 80075a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80075a6:	2000      	movs	r0, #0
 80075a8:	e7fa      	b.n	80075a0 <quorem+0x120>
 80075aa:	bf00      	nop

080075ac <_dtoa_r>:
 80075ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80075b0:	b09f      	sub	sp, #124	; 0x7c
 80075b2:	6a45      	ldr	r5, [r0, #36]	; 0x24
 80075b4:	4604      	mov	r4, r0
 80075b6:	4690      	mov	r8, r2
 80075b8:	4699      	mov	r9, r3
 80075ba:	9e2b      	ldr	r6, [sp, #172]	; 0xac
 80075bc:	2d00      	cmp	r5, #0
 80075be:	f000 8390 	beq.w	8007ce2 <_dtoa_r+0x736>
 80075c2:	682b      	ldr	r3, [r5, #0]
 80075c4:	b153      	cbz	r3, 80075dc <_dtoa_r+0x30>
 80075c6:	686a      	ldr	r2, [r5, #4]
 80075c8:	2501      	movs	r5, #1
 80075ca:	4619      	mov	r1, r3
 80075cc:	4095      	lsls	r5, r2
 80075ce:	609d      	str	r5, [r3, #8]
 80075d0:	605a      	str	r2, [r3, #4]
 80075d2:	f001 f933 	bl	800883c <_Bfree>
 80075d6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80075d8:	2200      	movs	r2, #0
 80075da:	601a      	str	r2, [r3, #0]
 80075dc:	f1b9 0500 	subs.w	r5, r9, #0
 80075e0:	f2c0 80d3 	blt.w	800778a <_dtoa_r+0x1de>
 80075e4:	2300      	movs	r3, #0
 80075e6:	6033      	str	r3, [r6, #0]
 80075e8:	2300      	movs	r3, #0
 80075ea:	461a      	mov	r2, r3
 80075ec:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 80075f0:	f6c7 72f0 	movt	r2, #32752	; 0x7ff0
 80075f4:	ea05 0303 	and.w	r3, r5, r3
 80075f8:	4293      	cmp	r3, r2
 80075fa:	f000 80af 	beq.w	800775c <_dtoa_r+0x1b0>
 80075fe:	2200      	movs	r2, #0
 8007600:	2300      	movs	r3, #0
 8007602:	4640      	mov	r0, r8
 8007604:	4649      	mov	r1, r9
 8007606:	e9cd 8902 	strd	r8, r9, [sp, #8]
 800760a:	2601      	movs	r6, #1
 800760c:	f003 fc72 	bl	800aef4 <__aeabi_dcmpeq>
 8007610:	b988      	cbnz	r0, 8007636 <_dtoa_r+0x8a>
 8007612:	f016 0fff 	tst.w	r6, #255	; 0xff
 8007616:	d112      	bne.n	800763e <_dtoa_r+0x92>
 8007618:	982a      	ldr	r0, [sp, #168]	; 0xa8
 800761a:	2301      	movs	r3, #1
 800761c:	992c      	ldr	r1, [sp, #176]	; 0xb0
 800761e:	6003      	str	r3, [r0, #0]
 8007620:	f64b 307c 	movw	r0, #47996	; 0xbb7c
 8007624:	f6c0 0000 	movt	r0, #2048	; 0x800
 8007628:	b111      	cbz	r1, 8007630 <_dtoa_r+0x84>
 800762a:	4b7b      	ldr	r3, [pc, #492]	; (8007818 <_dtoa_r+0x26c>)
 800762c:	1e58      	subs	r0, r3, #1
 800762e:	600b      	str	r3, [r1, #0]
 8007630:	b01f      	add	sp, #124	; 0x7c
 8007632:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007636:	2600      	movs	r6, #0
 8007638:	f016 0fff 	tst.w	r6, #255	; 0xff
 800763c:	d0ec      	beq.n	8007618 <_dtoa_r+0x6c>
 800763e:	4620      	mov	r0, r4
 8007640:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8007644:	a91c      	add	r1, sp, #112	; 0x70
 8007646:	9100      	str	r1, [sp, #0]
 8007648:	a91d      	add	r1, sp, #116	; 0x74
 800764a:	9101      	str	r1, [sp, #4]
 800764c:	f001 fc4c 	bl	8008ee8 <__d2b>
 8007650:	f3c5 560a 	ubfx	r6, r5, #20, #11
 8007654:	4682      	mov	sl, r0
 8007656:	2e00      	cmp	r6, #0
 8007658:	f000 80ac 	beq.w	80077b4 <_dtoa_r+0x208>
 800765c:	9803      	ldr	r0, [sp, #12]
 800765e:	f5a6 767e 	sub.w	r6, r6, #1016	; 0x3f8
 8007662:	9f1d      	ldr	r7, [sp, #116]	; 0x74
 8007664:	3e07      	subs	r6, #7
 8007666:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
 800766a:	2100      	movs	r1, #0
 800766c:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 8007670:	9116      	str	r1, [sp, #88]	; 0x58
 8007672:	f043 537e 	orr.w	r3, r3, #1065353216	; 0x3f800000
 8007676:	f443 03e0 	orr.w	r3, r3, #7340032	; 0x700000
 800767a:	9303      	str	r3, [sp, #12]
 800767c:	2300      	movs	r3, #0
 800767e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8007682:	2200      	movs	r2, #0
 8007684:	f6c3 73f8 	movt	r3, #16376	; 0x3ff8
 8007688:	f003 f818 	bl	800a6bc <__aeabi_dsub>
 800768c:	a35c      	add	r3, pc, #368	; (adr r3, 8007800 <_dtoa_r+0x254>)
 800768e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007692:	f003 f9c7 	bl	800aa24 <__aeabi_dmul>
 8007696:	a35c      	add	r3, pc, #368	; (adr r3, 8007808 <_dtoa_r+0x25c>)
 8007698:	e9d3 2300 	ldrd	r2, r3, [r3]
 800769c:	f003 f810 	bl	800a6c0 <__adddf3>
 80076a0:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80076a4:	4630      	mov	r0, r6
 80076a6:	f003 f957 	bl	800a958 <__aeabi_i2d>
 80076aa:	a359      	add	r3, pc, #356	; (adr r3, 8007810 <_dtoa_r+0x264>)
 80076ac:	e9d3 2300 	ldrd	r2, r3, [r3]
 80076b0:	f003 f9b8 	bl	800aa24 <__aeabi_dmul>
 80076b4:	4602      	mov	r2, r0
 80076b6:	460b      	mov	r3, r1
 80076b8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80076bc:	f003 f800 	bl	800a6c0 <__adddf3>
 80076c0:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80076c4:	f003 fc48 	bl	800af58 <__aeabi_d2iz>
 80076c8:	2200      	movs	r2, #0
 80076ca:	2300      	movs	r3, #0
 80076cc:	4605      	mov	r5, r0
 80076ce:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80076d2:	f003 fc19 	bl	800af08 <__aeabi_dcmplt>
 80076d6:	b140      	cbz	r0, 80076ea <_dtoa_r+0x13e>
 80076d8:	4628      	mov	r0, r5
 80076da:	f003 f93d 	bl	800a958 <__aeabi_i2d>
 80076de:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80076e2:	f003 fc07 	bl	800aef4 <__aeabi_dcmpeq>
 80076e6:	b900      	cbnz	r0, 80076ea <_dtoa_r+0x13e>
 80076e8:	3d01      	subs	r5, #1
 80076ea:	2d16      	cmp	r5, #22
 80076ec:	f200 8255 	bhi.w	8007b9a <_dtoa_r+0x5ee>
 80076f0:	f64b 0100 	movw	r1, #47104	; 0xb800
 80076f4:	4642      	mov	r2, r8
 80076f6:	f6c0 0100 	movt	r1, #2048	; 0x800
 80076fa:	464b      	mov	r3, r9
 80076fc:	eb01 01c5 	add.w	r1, r1, r5, lsl #3
 8007700:	e9d1 0100 	ldrd	r0, r1, [r1]
 8007704:	f003 fc1e 	bl	800af44 <__aeabi_dcmpgt>
 8007708:	2800      	cmp	r0, #0
 800770a:	f000 8300 	beq.w	8007d0e <_dtoa_r+0x762>
 800770e:	3d01      	subs	r5, #1
 8007710:	2000      	movs	r0, #0
 8007712:	9015      	str	r0, [sp, #84]	; 0x54
 8007714:	3f01      	subs	r7, #1
 8007716:	1bbe      	subs	r6, r7, r6
 8007718:	f100 82f4 	bmi.w	8007d04 <_dtoa_r+0x758>
 800771c:	2000      	movs	r0, #0
 800771e:	960b      	str	r6, [sp, #44]	; 0x2c
 8007720:	900d      	str	r0, [sp, #52]	; 0x34
 8007722:	2d00      	cmp	r5, #0
 8007724:	f2c0 82e6 	blt.w	8007cf4 <_dtoa_r+0x748>
 8007728:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800772a:	2200      	movs	r2, #0
 800772c:	9511      	str	r5, [sp, #68]	; 0x44
 800772e:	1949      	adds	r1, r1, r5
 8007730:	920f      	str	r2, [sp, #60]	; 0x3c
 8007732:	910b      	str	r1, [sp, #44]	; 0x2c
 8007734:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8007736:	2a09      	cmp	r2, #9
 8007738:	d870      	bhi.n	800781c <_dtoa_r+0x270>
 800773a:	2a05      	cmp	r2, #5
 800773c:	f340 8690 	ble.w	8008460 <_dtoa_r+0xeb4>
 8007740:	2700      	movs	r7, #0
 8007742:	3a04      	subs	r2, #4
 8007744:	9228      	str	r2, [sp, #160]	; 0xa0
 8007746:	9828      	ldr	r0, [sp, #160]	; 0xa0
 8007748:	1e83      	subs	r3, r0, #2
 800774a:	2b03      	cmp	r3, #3
 800774c:	f200 840a 	bhi.w	8007f64 <_dtoa_r+0x9b8>
 8007750:	e8df f013 	tbh	[pc, r3, lsl #1]
 8007754:	03ec0402 	.word	0x03ec0402
 8007758:	040503cc 	.word	0x040503cc
 800775c:	982a      	ldr	r0, [sp, #168]	; 0xa8
 800775e:	f242 730f 	movw	r3, #9999	; 0x270f
 8007762:	6003      	str	r3, [r0, #0]
 8007764:	f64b 308c 	movw	r0, #48012	; 0xbb8c
 8007768:	f6c0 0000 	movt	r0, #2048	; 0x800
 800776c:	f1b8 0f00 	cmp.w	r8, #0
 8007770:	d011      	beq.n	8007796 <_dtoa_r+0x1ea>
 8007772:	992c      	ldr	r1, [sp, #176]	; 0xb0
 8007774:	2900      	cmp	r1, #0
 8007776:	f43f af5b 	beq.w	8007630 <_dtoa_r+0x84>
 800777a:	78c2      	ldrb	r2, [r0, #3]
 800777c:	1cc3      	adds	r3, r0, #3
 800777e:	b10a      	cbz	r2, 8007784 <_dtoa_r+0x1d8>
 8007780:	f100 0308 	add.w	r3, r0, #8
 8007784:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
 8007786:	6013      	str	r3, [r2, #0]
 8007788:	e752      	b.n	8007630 <_dtoa_r+0x84>
 800778a:	f025 4500 	bic.w	r5, r5, #2147483648	; 0x80000000
 800778e:	2301      	movs	r3, #1
 8007790:	46a9      	mov	r9, r5
 8007792:	6033      	str	r3, [r6, #0]
 8007794:	e728      	b.n	80075e8 <_dtoa_r+0x3c>
 8007796:	f64b 3280 	movw	r2, #48000	; 0xbb80
 800779a:	f64b 338c 	movw	r3, #48012	; 0xbb8c
 800779e:	f3c5 0013 	ubfx	r0, r5, #0, #20
 80077a2:	f6c0 0200 	movt	r2, #2048	; 0x800
 80077a6:	f6c0 0300 	movt	r3, #2048	; 0x800
 80077aa:	2800      	cmp	r0, #0
 80077ac:	bf0c      	ite	eq
 80077ae:	4610      	moveq	r0, r2
 80077b0:	4618      	movne	r0, r3
 80077b2:	e7de      	b.n	8007772 <_dtoa_r+0x1c6>
 80077b4:	9f1d      	ldr	r7, [sp, #116]	; 0x74
 80077b6:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 80077b8:	18fb      	adds	r3, r7, r3
 80077ba:	f503 6386 	add.w	r3, r3, #1072	; 0x430
 80077be:	1c9e      	adds	r6, r3, #2
 80077c0:	2e20      	cmp	r6, #32
 80077c2:	bfdc      	itt	le
 80077c4:	f1c6 0020 	rsble	r0, r6, #32
 80077c8:	fa08 f000 	lslle.w	r0, r8, r0
 80077cc:	dd07      	ble.n	80077de <_dtoa_r+0x232>
 80077ce:	f1c6 0040 	rsb	r0, r6, #64	; 0x40
 80077d2:	3b1e      	subs	r3, #30
 80077d4:	4085      	lsls	r5, r0
 80077d6:	fa28 f303 	lsr.w	r3, r8, r3
 80077da:	ea45 0003 	orr.w	r0, r5, r3
 80077de:	2201      	movs	r2, #1
 80077e0:	9216      	str	r2, [sp, #88]	; 0x58
 80077e2:	f003 f8a9 	bl	800a938 <__aeabi_ui2d>
 80077e6:	f5a6 6686 	sub.w	r6, r6, #1072	; 0x430
 80077ea:	3e03      	subs	r6, #3
 80077ec:	460b      	mov	r3, r1
 80077ee:	4602      	mov	r2, r0
 80077f0:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80077f4:	9b03      	ldr	r3, [sp, #12]
 80077f6:	f1a3 73f8 	sub.w	r3, r3, #32505856	; 0x1f00000
 80077fa:	9303      	str	r3, [sp, #12]
 80077fc:	e73e      	b.n	800767c <_dtoa_r+0xd0>
 80077fe:	bf00      	nop
 8007800:	636f4361 	.word	0x636f4361
 8007804:	3fd287a7 	.word	0x3fd287a7
 8007808:	8b60c8b3 	.word	0x8b60c8b3
 800780c:	3fc68a28 	.word	0x3fc68a28
 8007810:	509f79fb 	.word	0x509f79fb
 8007814:	3fd34413 	.word	0x3fd34413
 8007818:	0800bb7d 	.word	0x0800bb7d
 800781c:	2000      	movs	r0, #0
 800781e:	f04f 31ff 	mov.w	r1, #4294967295
 8007822:	4607      	mov	r7, r0
 8007824:	2201      	movs	r2, #1
 8007826:	9028      	str	r0, [sp, #160]	; 0xa0
 8007828:	910e      	str	r1, [sp, #56]	; 0x38
 800782a:	9210      	str	r2, [sp, #64]	; 0x40
 800782c:	910a      	str	r1, [sp, #40]	; 0x28
 800782e:	9029      	str	r0, [sp, #164]	; 0xa4
 8007830:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8007832:	2300      	movs	r3, #0
 8007834:	6073      	str	r3, [r6, #4]
 8007836:	4620      	mov	r0, r4
 8007838:	6871      	ldr	r1, [r6, #4]
 800783a:	f000 ffcb 	bl	80087d4 <_Balloc>
 800783e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007840:	6030      	str	r0, [r6, #0]
 8007842:	681b      	ldr	r3, [r3, #0]
 8007844:	930c      	str	r3, [sp, #48]	; 0x30
 8007846:	2f00      	cmp	r7, #0
 8007848:	f000 80de 	beq.w	8007a08 <_dtoa_r+0x45c>
 800784c:	2d00      	cmp	r5, #0
 800784e:	4640      	mov	r0, r8
 8007850:	4649      	mov	r1, r9
 8007852:	e9cd 8908 	strd	r8, r9, [sp, #32]
 8007856:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800785a:	f340 842e 	ble.w	80080ba <_dtoa_r+0xb0e>
 800785e:	f64b 0300 	movw	r3, #47104	; 0xb800
 8007862:	f005 020f 	and.w	r2, r5, #15
 8007866:	f6c0 0300 	movt	r3, #2048	; 0x800
 800786a:	112e      	asrs	r6, r5, #4
 800786c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8007870:	f016 0f10 	tst.w	r6, #16
 8007874:	bf08      	it	eq
 8007876:	f04f 0802 	moveq.w	r8, #2
 800787a:	e9d3 0100 	ldrd	r0, r1, [r3]
 800787e:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
 8007882:	f040 8247 	bne.w	8007d14 <_dtoa_r+0x768>
 8007886:	b1be      	cbz	r6, 80078b8 <_dtoa_r+0x30c>
 8007888:	f64b 07c8 	movw	r7, #47304	; 0xb8c8
 800788c:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 8007890:	f6c0 0700 	movt	r7, #2048	; 0x800
 8007894:	f016 0f01 	tst.w	r6, #1
 8007898:	4610      	mov	r0, r2
 800789a:	4619      	mov	r1, r3
 800789c:	d007      	beq.n	80078ae <_dtoa_r+0x302>
 800789e:	e9d7 2300 	ldrd	r2, r3, [r7]
 80078a2:	f108 0801 	add.w	r8, r8, #1
 80078a6:	f003 f8bd 	bl	800aa24 <__aeabi_dmul>
 80078aa:	4602      	mov	r2, r0
 80078ac:	460b      	mov	r3, r1
 80078ae:	3708      	adds	r7, #8
 80078b0:	1076      	asrs	r6, r6, #1
 80078b2:	d1ef      	bne.n	8007894 <_dtoa_r+0x2e8>
 80078b4:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
 80078b8:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80078bc:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 80078c0:	f003 f9da 	bl	800ac78 <__aeabi_ddiv>
 80078c4:	e9cd 0108 	strd	r0, r1, [sp, #32]
 80078c8:	9915      	ldr	r1, [sp, #84]	; 0x54
 80078ca:	2900      	cmp	r1, #0
 80078cc:	d038      	beq.n	8007940 <_dtoa_r+0x394>
 80078ce:	2300      	movs	r3, #0
 80078d0:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80078d4:	2200      	movs	r2, #0
 80078d6:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
 80078da:	2601      	movs	r6, #1
 80078dc:	f003 fb14 	bl	800af08 <__aeabi_dcmplt>
 80078e0:	2800      	cmp	r0, #0
 80078e2:	f000 8301 	beq.w	8007ee8 <_dtoa_r+0x93c>
 80078e6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80078e8:	2a00      	cmp	r2, #0
 80078ea:	bfd4      	ite	le
 80078ec:	2600      	movle	r6, #0
 80078ee:	f006 0601 	andgt.w	r6, r6, #1
 80078f2:	b32e      	cbz	r6, 8007940 <_dtoa_r+0x394>
 80078f4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80078f6:	2b00      	cmp	r3, #0
 80078f8:	f340 8082 	ble.w	8007a00 <_dtoa_r+0x454>
 80078fc:	2300      	movs	r3, #0
 80078fe:	2200      	movs	r2, #0
 8007900:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8007904:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8007908:	f003 f88c 	bl	800aa24 <__aeabi_dmul>
 800790c:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8007910:	f108 0001 	add.w	r0, r8, #1
 8007914:	1e69      	subs	r1, r5, #1
 8007916:	9112      	str	r1, [sp, #72]	; 0x48
 8007918:	f003 f81e 	bl	800a958 <__aeabi_i2d>
 800791c:	4602      	mov	r2, r0
 800791e:	460b      	mov	r3, r1
 8007920:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8007924:	f003 f87e 	bl	800aa24 <__aeabi_dmul>
 8007928:	2300      	movs	r3, #0
 800792a:	2200      	movs	r2, #0
 800792c:	f2c4 031c 	movt	r3, #16412	; 0x401c
 8007930:	f002 fec6 	bl	800a6c0 <__adddf3>
 8007934:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
 8007938:	4680      	mov	r8, r0
 800793a:	f1a1 7950 	sub.w	r9, r1, #54525952	; 0x3400000
 800793e:	e23c      	b.n	8007dba <_dtoa_r+0x80e>
 8007940:	4640      	mov	r0, r8
 8007942:	f003 f809 	bl	800a958 <__aeabi_i2d>
 8007946:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 800794a:	f003 f86b 	bl	800aa24 <__aeabi_dmul>
 800794e:	2300      	movs	r3, #0
 8007950:	2200      	movs	r2, #0
 8007952:	f2c4 031c 	movt	r3, #16412	; 0x401c
 8007956:	f002 feb3 	bl	800a6c0 <__adddf3>
 800795a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800795c:	f1a1 7650 	sub.w	r6, r1, #54525952	; 0x3400000
 8007960:	4680      	mov	r8, r0
 8007962:	46b1      	mov	r9, r6
 8007964:	2a00      	cmp	r2, #0
 8007966:	f040 8225 	bne.w	8007db4 <_dtoa_r+0x808>
 800796a:	2300      	movs	r3, #0
 800796c:	2200      	movs	r2, #0
 800796e:	f2c4 0314 	movt	r3, #16404	; 0x4014
 8007972:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8007976:	f002 fea1 	bl	800a6bc <__aeabi_dsub>
 800797a:	4642      	mov	r2, r8
 800797c:	4633      	mov	r3, r6
 800797e:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8007982:	f003 fadf 	bl	800af44 <__aeabi_dcmpgt>
 8007986:	2800      	cmp	r0, #0
 8007988:	f040 820f 	bne.w	8007daa <_dtoa_r+0x7fe>
 800798c:	4642      	mov	r2, r8
 800798e:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8007992:	f106 4300 	add.w	r3, r6, #2147483648	; 0x80000000
 8007996:	f003 fab7 	bl	800af08 <__aeabi_dcmplt>
 800799a:	2800      	cmp	r0, #0
 800799c:	d030      	beq.n	8007a00 <_dtoa_r+0x454>
 800799e:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 80079a2:	f8cd b020 	str.w	fp, [sp, #32]
 80079a6:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 80079a8:	2700      	movs	r7, #0
 80079aa:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 80079ac:	43dd      	mvns	r5, r3
 80079ae:	4659      	mov	r1, fp
 80079b0:	4620      	mov	r0, r4
 80079b2:	f000 ff43 	bl	800883c <_Bfree>
 80079b6:	9908      	ldr	r1, [sp, #32]
 80079b8:	b171      	cbz	r1, 80079d8 <_dtoa_r+0x42c>
 80079ba:	1e3b      	subs	r3, r7, #0
 80079bc:	bf18      	it	ne
 80079be:	2301      	movne	r3, #1
 80079c0:	428f      	cmp	r7, r1
 80079c2:	bf0c      	ite	eq
 80079c4:	2300      	moveq	r3, #0
 80079c6:	f003 0301 	andne.w	r3, r3, #1
 80079ca:	2b00      	cmp	r3, #0
 80079cc:	f040 835e 	bne.w	800808c <_dtoa_r+0xae0>
 80079d0:	4620      	mov	r0, r4
 80079d2:	9908      	ldr	r1, [sp, #32]
 80079d4:	f000 ff32 	bl	800883c <_Bfree>
 80079d8:	4620      	mov	r0, r4
 80079da:	4651      	mov	r1, sl
 80079dc:	f000 ff2e 	bl	800883c <_Bfree>
 80079e0:	2300      	movs	r3, #0
 80079e2:	7033      	strb	r3, [r6, #0]
 80079e4:	3501      	adds	r5, #1
 80079e6:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 80079e8:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 80079ea:	6015      	str	r5, [r2, #0]
 80079ec:	2b00      	cmp	r3, #0
 80079ee:	f000 8418 	beq.w	8008222 <_dtoa_r+0xc76>
 80079f2:	601e      	str	r6, [r3, #0]
 80079f4:	980c      	ldr	r0, [sp, #48]	; 0x30
 80079f6:	e61b      	b.n	8007630 <_dtoa_r+0x84>
 80079f8:	9d18      	ldr	r5, [sp, #96]	; 0x60
 80079fa:	f8dd a05c 	ldr.w	sl, [sp, #92]	; 0x5c
 80079fe:	9c08      	ldr	r4, [sp, #32]
 8007a00:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8007a04:	4680      	mov	r8, r0
 8007a06:	4689      	mov	r9, r1
 8007a08:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8007a0a:	43df      	mvns	r7, r3
 8007a0c:	0fff      	lsrs	r7, r7, #31
 8007a0e:	2d0e      	cmp	r5, #14
 8007a10:	bfcc      	ite	gt
 8007a12:	2700      	movgt	r7, #0
 8007a14:	f007 0701 	andle.w	r7, r7, #1
 8007a18:	2f00      	cmp	r7, #0
 8007a1a:	f000 80c1 	beq.w	8007ba0 <_dtoa_r+0x5f4>
 8007a1e:	f64b 0300 	movw	r3, #47104	; 0xb800
 8007a22:	9929      	ldr	r1, [sp, #164]	; 0xa4
 8007a24:	f6c0 0300 	movt	r3, #2048	; 0x800
 8007a28:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8007a2a:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 8007a2e:	0fcf      	lsrs	r7, r1, #31
 8007a30:	e9d3 0100 	ldrd	r0, r1, [r3]
 8007a34:	2a00      	cmp	r2, #0
 8007a36:	bfcc      	ite	gt
 8007a38:	2700      	movgt	r7, #0
 8007a3a:	f007 0701 	andle.w	r7, r7, #1
 8007a3e:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8007a42:	2f00      	cmp	r7, #0
 8007a44:	f040 819e 	bne.w	8007d84 <_dtoa_r+0x7d8>
 8007a48:	4602      	mov	r2, r0
 8007a4a:	460b      	mov	r3, r1
 8007a4c:	4640      	mov	r0, r8
 8007a4e:	4649      	mov	r1, r9
 8007a50:	e9cd 8904 	strd	r8, r9, [sp, #16]
 8007a54:	f003 f910 	bl	800ac78 <__aeabi_ddiv>
 8007a58:	f003 fa7e 	bl	800af58 <__aeabi_d2iz>
 8007a5c:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8007a5e:	4681      	mov	r9, r0
 8007a60:	f002 ff7a 	bl	800a958 <__aeabi_i2d>
 8007a64:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8007a68:	f002 ffdc 	bl	800aa24 <__aeabi_dmul>
 8007a6c:	4602      	mov	r2, r0
 8007a6e:	460b      	mov	r3, r1
 8007a70:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8007a74:	f002 fe22 	bl	800a6bc <__aeabi_dsub>
 8007a78:	f109 0330 	add.w	r3, r9, #48	; 0x30
 8007a7c:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8007a80:	f806 3b01 	strb.w	r3, [r6], #1
 8007a84:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8007a86:	2a01      	cmp	r2, #1
 8007a88:	d056      	beq.n	8007b38 <_dtoa_r+0x58c>
 8007a8a:	2300      	movs	r3, #0
 8007a8c:	2200      	movs	r2, #0
 8007a8e:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8007a92:	f04f 0801 	mov.w	r8, #1
 8007a96:	f002 ffc5 	bl	800aa24 <__aeabi_dmul>
 8007a9a:	2200      	movs	r2, #0
 8007a9c:	2300      	movs	r3, #0
 8007a9e:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8007aa2:	f003 fa27 	bl	800aef4 <__aeabi_dcmpeq>
 8007aa6:	b100      	cbz	r0, 8007aaa <_dtoa_r+0x4fe>
 8007aa8:	46b8      	mov	r8, r7
 8007aaa:	f018 0fff 	tst.w	r8, #255	; 0xff
 8007aae:	d093      	beq.n	80079d8 <_dtoa_r+0x42c>
 8007ab0:	990a      	ldr	r1, [sp, #40]	; 0x28
 8007ab2:	4637      	mov	r7, r6
 8007ab4:	980c      	ldr	r0, [sp, #48]	; 0x30
 8007ab6:	46a0      	mov	r8, r4
 8007ab8:	9507      	str	r5, [sp, #28]
 8007aba:	eb00 0b01 	add.w	fp, r0, r1
 8007abe:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
 8007ac2:	465d      	mov	r5, fp
 8007ac4:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 8007ac8:	e00d      	b.n	8007ae6 <_dtoa_r+0x53a>
 8007aca:	f002 ffab 	bl	800aa24 <__aeabi_dmul>
 8007ace:	2200      	movs	r2, #0
 8007ad0:	2300      	movs	r3, #0
 8007ad2:	4682      	mov	sl, r0
 8007ad4:	468b      	mov	fp, r1
 8007ad6:	f003 fa0d 	bl	800aef4 <__aeabi_dcmpeq>
 8007ada:	b100      	cbz	r0, 8007ade <_dtoa_r+0x532>
 8007adc:	2400      	movs	r4, #0
 8007ade:	f014 0fff 	tst.w	r4, #255	; 0xff
 8007ae2:	f000 840f 	beq.w	8008304 <_dtoa_r+0xd58>
 8007ae6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8007aea:	4650      	mov	r0, sl
 8007aec:	4659      	mov	r1, fp
 8007aee:	2401      	movs	r4, #1
 8007af0:	f003 f8c2 	bl	800ac78 <__aeabi_ddiv>
 8007af4:	f003 fa30 	bl	800af58 <__aeabi_d2iz>
 8007af8:	4681      	mov	r9, r0
 8007afa:	f002 ff2d 	bl	800a958 <__aeabi_i2d>
 8007afe:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8007b02:	f109 0630 	add.w	r6, r9, #48	; 0x30
 8007b06:	f002 ff8d 	bl	800aa24 <__aeabi_dmul>
 8007b0a:	4602      	mov	r2, r0
 8007b0c:	460b      	mov	r3, r1
 8007b0e:	4650      	mov	r0, sl
 8007b10:	4659      	mov	r1, fp
 8007b12:	f002 fdd3 	bl	800a6bc <__aeabi_dsub>
 8007b16:	2300      	movs	r3, #0
 8007b18:	f807 6b01 	strb.w	r6, [r7], #1
 8007b1c:	2200      	movs	r2, #0
 8007b1e:	42af      	cmp	r7, r5
 8007b20:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8007b24:	463e      	mov	r6, r7
 8007b26:	4682      	mov	sl, r0
 8007b28:	468b      	mov	fp, r1
 8007b2a:	d1ce      	bne.n	8007aca <_dtoa_r+0x51e>
 8007b2c:	e9cd ab04 	strd	sl, fp, [sp, #16]
 8007b30:	4644      	mov	r4, r8
 8007b32:	9d07      	ldr	r5, [sp, #28]
 8007b34:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 8007b38:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8007b3c:	4602      	mov	r2, r0
 8007b3e:	460b      	mov	r3, r1
 8007b40:	f002 fdbe 	bl	800a6c0 <__adddf3>
 8007b44:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8007b48:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8007b4c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8007b50:	f003 f9da 	bl	800af08 <__aeabi_dcmplt>
 8007b54:	b960      	cbnz	r0, 8007b70 <_dtoa_r+0x5c4>
 8007b56:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8007b5a:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8007b5e:	f003 f9c9 	bl	800aef4 <__aeabi_dcmpeq>
 8007b62:	2800      	cmp	r0, #0
 8007b64:	f43f af38 	beq.w	80079d8 <_dtoa_r+0x42c>
 8007b68:	f019 0f01 	tst.w	r9, #1
 8007b6c:	f43f af34 	beq.w	80079d8 <_dtoa_r+0x42c>
 8007b70:	9512      	str	r5, [sp, #72]	; 0x48
 8007b72:	980c      	ldr	r0, [sp, #48]	; 0x30
 8007b74:	4633      	mov	r3, r6
 8007b76:	f813 1c01 	ldrb.w	r1, [r3, #-1]
 8007b7a:	1e5a      	subs	r2, r3, #1
 8007b7c:	461e      	mov	r6, r3
 8007b7e:	4613      	mov	r3, r2
 8007b80:	2939      	cmp	r1, #57	; 0x39
 8007b82:	f040 83e1 	bne.w	8008348 <_dtoa_r+0xd9c>
 8007b86:	4283      	cmp	r3, r0
 8007b88:	d1f5      	bne.n	8007b76 <_dtoa_r+0x5ca>
 8007b8a:	980c      	ldr	r0, [sp, #48]	; 0x30
 8007b8c:	2131      	movs	r1, #49	; 0x31
 8007b8e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8007b90:	1c5d      	adds	r5, r3, #1
 8007b92:	2330      	movs	r3, #48	; 0x30
 8007b94:	7003      	strb	r3, [r0, #0]
 8007b96:	7011      	strb	r1, [r2, #0]
 8007b98:	e71e      	b.n	80079d8 <_dtoa_r+0x42c>
 8007b9a:	2101      	movs	r1, #1
 8007b9c:	9115      	str	r1, [sp, #84]	; 0x54
 8007b9e:	e5b9      	b.n	8007714 <_dtoa_r+0x168>
 8007ba0:	9910      	ldr	r1, [sp, #64]	; 0x40
 8007ba2:	2900      	cmp	r1, #0
 8007ba4:	f040 80c7 	bne.w	8007d36 <_dtoa_r+0x78a>
 8007ba8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007baa:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 8007bac:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 8007bae:	9308      	str	r3, [sp, #32]
 8007bb0:	2e00      	cmp	r6, #0
 8007bb2:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8007bb4:	bfd4      	ite	le
 8007bb6:	2300      	movle	r3, #0
 8007bb8:	2301      	movgt	r3, #1
 8007bba:	2800      	cmp	r0, #0
 8007bbc:	bfd4      	ite	le
 8007bbe:	2300      	movle	r3, #0
 8007bc0:	f003 0301 	andgt.w	r3, r3, #1
 8007bc4:	b14b      	cbz	r3, 8007bda <_dtoa_r+0x62e>
 8007bc6:	4603      	mov	r3, r0
 8007bc8:	990d      	ldr	r1, [sp, #52]	; 0x34
 8007bca:	42b3      	cmp	r3, r6
 8007bcc:	bfa8      	it	ge
 8007bce:	4633      	movge	r3, r6
 8007bd0:	1af6      	subs	r6, r6, r3
 8007bd2:	1ac9      	subs	r1, r1, r3
 8007bd4:	1ac0      	subs	r0, r0, r3
 8007bd6:	910d      	str	r1, [sp, #52]	; 0x34
 8007bd8:	900b      	str	r0, [sp, #44]	; 0x2c
 8007bda:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8007bdc:	2a00      	cmp	r2, #0
 8007bde:	dd1a      	ble.n	8007c16 <_dtoa_r+0x66a>
 8007be0:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007be2:	2b00      	cmp	r3, #0
 8007be4:	f000 8394 	beq.w	8008310 <_dtoa_r+0xd64>
 8007be8:	2f00      	cmp	r7, #0
 8007bea:	dd10      	ble.n	8007c0e <_dtoa_r+0x662>
 8007bec:	9908      	ldr	r1, [sp, #32]
 8007bee:	463a      	mov	r2, r7
 8007bf0:	4620      	mov	r0, r4
 8007bf2:	f000 ffbd 	bl	8008b70 <__pow5mult>
 8007bf6:	4652      	mov	r2, sl
 8007bf8:	9008      	str	r0, [sp, #32]
 8007bfa:	4620      	mov	r0, r4
 8007bfc:	9908      	ldr	r1, [sp, #32]
 8007bfe:	f000 ff23 	bl	8008a48 <__multiply>
 8007c02:	4651      	mov	r1, sl
 8007c04:	4683      	mov	fp, r0
 8007c06:	4620      	mov	r0, r4
 8007c08:	f000 fe18 	bl	800883c <_Bfree>
 8007c0c:	46da      	mov	sl, fp
 8007c0e:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007c10:	1bc2      	subs	r2, r0, r7
 8007c12:	f040 8384 	bne.w	800831e <_dtoa_r+0xd72>
 8007c16:	2101      	movs	r1, #1
 8007c18:	4620      	mov	r0, r4
 8007c1a:	f000 ff0b 	bl	8008a34 <__i2b>
 8007c1e:	9911      	ldr	r1, [sp, #68]	; 0x44
 8007c20:	2900      	cmp	r1, #0
 8007c22:	4683      	mov	fp, r0
 8007c24:	dd05      	ble.n	8007c32 <_dtoa_r+0x686>
 8007c26:	4659      	mov	r1, fp
 8007c28:	4620      	mov	r0, r4
 8007c2a:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8007c2c:	f000 ffa0 	bl	8008b70 <__pow5mult>
 8007c30:	4683      	mov	fp, r0
 8007c32:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8007c34:	2a01      	cmp	r2, #1
 8007c36:	f340 819e 	ble.w	8007f76 <_dtoa_r+0x9ca>
 8007c3a:	2700      	movs	r7, #0
 8007c3c:	9911      	ldr	r1, [sp, #68]	; 0x44
 8007c3e:	2900      	cmp	r1, #0
 8007c40:	f040 82f2 	bne.w	8008228 <_dtoa_r+0xc7c>
 8007c44:	2301      	movs	r3, #1
 8007c46:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8007c48:	189b      	adds	r3, r3, r2
 8007c4a:	f013 031f 	ands.w	r3, r3, #31
 8007c4e:	f000 8222 	beq.w	8008096 <_dtoa_r+0xaea>
 8007c52:	f1c3 0320 	rsb	r3, r3, #32
 8007c56:	2b04      	cmp	r3, #4
 8007c58:	f340 83f6 	ble.w	8008448 <_dtoa_r+0xe9c>
 8007c5c:	3b04      	subs	r3, #4
 8007c5e:	980d      	ldr	r0, [sp, #52]	; 0x34
 8007c60:	18f6      	adds	r6, r6, r3
 8007c62:	18d2      	adds	r2, r2, r3
 8007c64:	18c0      	adds	r0, r0, r3
 8007c66:	920b      	str	r2, [sp, #44]	; 0x2c
 8007c68:	900d      	str	r0, [sp, #52]	; 0x34
 8007c6a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007c6c:	2b00      	cmp	r3, #0
 8007c6e:	dd05      	ble.n	8007c7c <_dtoa_r+0x6d0>
 8007c70:	4651      	mov	r1, sl
 8007c72:	4620      	mov	r0, r4
 8007c74:	461a      	mov	r2, r3
 8007c76:	f000 ffcd 	bl	8008c14 <__lshift>
 8007c7a:	4682      	mov	sl, r0
 8007c7c:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8007c7e:	2800      	cmp	r0, #0
 8007c80:	dd05      	ble.n	8007c8e <_dtoa_r+0x6e2>
 8007c82:	4659      	mov	r1, fp
 8007c84:	4620      	mov	r0, r4
 8007c86:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8007c88:	f000 ffc4 	bl	8008c14 <__lshift>
 8007c8c:	4683      	mov	fp, r0
 8007c8e:	9915      	ldr	r1, [sp, #84]	; 0x54
 8007c90:	2900      	cmp	r1, #0
 8007c92:	f040 82d3 	bne.w	800823c <_dtoa_r+0xc90>
 8007c96:	9928      	ldr	r1, [sp, #160]	; 0xa0
 8007c98:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8007c9a:	2902      	cmp	r1, #2
 8007c9c:	bfd4      	ite	le
 8007c9e:	2300      	movle	r3, #0
 8007ca0:	2301      	movgt	r3, #1
 8007ca2:	2a00      	cmp	r2, #0
 8007ca4:	bfcc      	ite	gt
 8007ca6:	2300      	movgt	r3, #0
 8007ca8:	f003 0301 	andle.w	r3, r3, #1
 8007cac:	2b00      	cmp	r3, #0
 8007cae:	f000 817c 	beq.w	8007faa <_dtoa_r+0x9fe>
 8007cb2:	2a00      	cmp	r2, #0
 8007cb4:	f47f ae77 	bne.w	80079a6 <_dtoa_r+0x3fa>
 8007cb8:	4659      	mov	r1, fp
 8007cba:	2205      	movs	r2, #5
 8007cbc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007cbe:	4620      	mov	r0, r4
 8007cc0:	f000 fdd8 	bl	8008874 <__multadd>
 8007cc4:	4683      	mov	fp, r0
 8007cc6:	4650      	mov	r0, sl
 8007cc8:	4659      	mov	r1, fp
 8007cca:	f000 fff9 	bl	8008cc0 <__mcmp>
 8007cce:	2800      	cmp	r0, #0
 8007cd0:	f77f ae69 	ble.w	80079a6 <_dtoa_r+0x3fa>
 8007cd4:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8007cd6:	2331      	movs	r3, #49	; 0x31
 8007cd8:	3501      	adds	r5, #1
 8007cda:	2700      	movs	r7, #0
 8007cdc:	f806 3b01 	strb.w	r3, [r6], #1
 8007ce0:	e665      	b.n	80079ae <_dtoa_r+0x402>
 8007ce2:	2010      	movs	r0, #16
 8007ce4:	f7fc ffc8 	bl	8004c78 <malloc>
 8007ce8:	6260      	str	r0, [r4, #36]	; 0x24
 8007cea:	6045      	str	r5, [r0, #4]
 8007cec:	6085      	str	r5, [r0, #8]
 8007cee:	6005      	str	r5, [r0, #0]
 8007cf0:	60c5      	str	r5, [r0, #12]
 8007cf2:	e473      	b.n	80075dc <_dtoa_r+0x30>
 8007cf4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007cf6:	4268      	negs	r0, r5
 8007cf8:	2100      	movs	r1, #0
 8007cfa:	900f      	str	r0, [sp, #60]	; 0x3c
 8007cfc:	1b5b      	subs	r3, r3, r5
 8007cfe:	9111      	str	r1, [sp, #68]	; 0x44
 8007d00:	930d      	str	r3, [sp, #52]	; 0x34
 8007d02:	e517      	b.n	8007734 <_dtoa_r+0x188>
 8007d04:	4276      	negs	r6, r6
 8007d06:	2300      	movs	r3, #0
 8007d08:	960d      	str	r6, [sp, #52]	; 0x34
 8007d0a:	930b      	str	r3, [sp, #44]	; 0x2c
 8007d0c:	e509      	b.n	8007722 <_dtoa_r+0x176>
 8007d0e:	2200      	movs	r2, #0
 8007d10:	9215      	str	r2, [sp, #84]	; 0x54
 8007d12:	e4ff      	b.n	8007714 <_dtoa_r+0x168>
 8007d14:	f64b 03c8 	movw	r3, #47304	; 0xb8c8
 8007d18:	4640      	mov	r0, r8
 8007d1a:	f6c0 0300 	movt	r3, #2048	; 0x800
 8007d1e:	4649      	mov	r1, r9
 8007d20:	f006 060f 	and.w	r6, r6, #15
 8007d24:	f04f 0803 	mov.w	r8, #3
 8007d28:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8007d2c:	f002 ffa4 	bl	800ac78 <__aeabi_ddiv>
 8007d30:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8007d34:	e5a7      	b.n	8007886 <_dtoa_r+0x2da>
 8007d36:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8007d38:	2a01      	cmp	r2, #1
 8007d3a:	f340 82f6 	ble.w	800832a <_dtoa_r+0xd7e>
 8007d3e:	990a      	ldr	r1, [sp, #40]	; 0x28
 8007d40:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8007d42:	1e4b      	subs	r3, r1, #1
 8007d44:	429a      	cmp	r2, r3
 8007d46:	bfa8      	it	ge
 8007d48:	ebc3 0702 	rsbge	r7, r3, r2
 8007d4c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8007d4e:	bfbf      	itttt	lt
 8007d50:	980f      	ldrlt	r0, [sp, #60]	; 0x3c
 8007d52:	9911      	ldrlt	r1, [sp, #68]	; 0x44
 8007d54:	ebc0 0303 	rsblt	r3, r0, r3
 8007d58:	18c9      	addlt	r1, r1, r3
 8007d5a:	bfbe      	ittt	lt
 8007d5c:	18c0      	addlt	r0, r0, r3
 8007d5e:	9111      	strlt	r1, [sp, #68]	; 0x44
 8007d60:	900f      	strlt	r0, [sp, #60]	; 0x3c
 8007d62:	2a00      	cmp	r2, #0
 8007d64:	f2c0 82f9 	blt.w	800835a <_dtoa_r+0xdae>
 8007d68:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 8007d6a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007d6c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8007d6e:	4620      	mov	r0, r4
 8007d70:	2101      	movs	r1, #1
 8007d72:	18d2      	adds	r2, r2, r3
 8007d74:	920d      	str	r2, [sp, #52]	; 0x34
 8007d76:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8007d78:	18d2      	adds	r2, r2, r3
 8007d7a:	920b      	str	r2, [sp, #44]	; 0x2c
 8007d7c:	f000 fe5a 	bl	8008a34 <__i2b>
 8007d80:	9008      	str	r0, [sp, #32]
 8007d82:	e715      	b.n	8007bb0 <_dtoa_r+0x604>
 8007d84:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007d86:	2b00      	cmp	r3, #0
 8007d88:	f040 82d8 	bne.w	800833c <_dtoa_r+0xd90>
 8007d8c:	2300      	movs	r3, #0
 8007d8e:	2200      	movs	r2, #0
 8007d90:	f2c4 0314 	movt	r3, #16404	; 0x4014
 8007d94:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8007d98:	f002 fe44 	bl	800aa24 <__aeabi_dmul>
 8007d9c:	4642      	mov	r2, r8
 8007d9e:	464b      	mov	r3, r9
 8007da0:	f003 f8c6 	bl	800af30 <__aeabi_dcmpge>
 8007da4:	2800      	cmp	r0, #0
 8007da6:	f47f adfa 	bne.w	800799e <_dtoa_r+0x3f2>
 8007daa:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 8007dae:	f8cd b020 	str.w	fp, [sp, #32]
 8007db2:	e78f      	b.n	8007cd4 <_dtoa_r+0x728>
 8007db4:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 8007db8:	9512      	str	r5, [sp, #72]	; 0x48
 8007dba:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007dbc:	2b00      	cmp	r3, #0
 8007dbe:	f000 81af 	beq.w	8008120 <_dtoa_r+0xb74>
 8007dc2:	f64b 0300 	movw	r3, #47104	; 0xb800
 8007dc6:	2100      	movs	r1, #0
 8007dc8:	f6c0 0300 	movt	r3, #2048	; 0x800
 8007dcc:	2000      	movs	r0, #0
 8007dce:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 8007dd2:	f6c3 71e0 	movt	r1, #16352	; 0x3fe0
 8007dd6:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8007dd8:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 8007ddc:	f002 ff4c 	bl	800ac78 <__aeabi_ddiv>
 8007de0:	4642      	mov	r2, r8
 8007de2:	464b      	mov	r3, r9
 8007de4:	f002 fc6a 	bl	800a6bc <__aeabi_dsub>
 8007de8:	4680      	mov	r8, r0
 8007dea:	4689      	mov	r9, r1
 8007dec:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8007df0:	f003 f8b2 	bl	800af58 <__aeabi_d2iz>
 8007df4:	4607      	mov	r7, r0
 8007df6:	f002 fdaf 	bl	800a958 <__aeabi_i2d>
 8007dfa:	4602      	mov	r2, r0
 8007dfc:	460b      	mov	r3, r1
 8007dfe:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8007e02:	f002 fc5b 	bl	800a6bc <__aeabi_dsub>
 8007e06:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8007e0a:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8007e0e:	4640      	mov	r0, r8
 8007e10:	f806 3b01 	strb.w	r3, [r6], #1
 8007e14:	4649      	mov	r1, r9
 8007e16:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8007e1a:	f003 f893 	bl	800af44 <__aeabi_dcmpgt>
 8007e1e:	2800      	cmp	r0, #0
 8007e20:	f040 81fc 	bne.w	800821c <_dtoa_r+0xc70>
 8007e24:	2100      	movs	r1, #0
 8007e26:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8007e2a:	2000      	movs	r0, #0
 8007e2c:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
 8007e30:	f002 fc44 	bl	800a6bc <__aeabi_dsub>
 8007e34:	4602      	mov	r2, r0
 8007e36:	460b      	mov	r3, r1
 8007e38:	4640      	mov	r0, r8
 8007e3a:	4649      	mov	r1, r9
 8007e3c:	f003 f882 	bl	800af44 <__aeabi_dcmpgt>
 8007e40:	2800      	cmp	r0, #0
 8007e42:	f47f ae96 	bne.w	8007b72 <_dtoa_r+0x5c6>
 8007e46:	f1bb 0f01 	cmp.w	fp, #1
 8007e4a:	f77f add9 	ble.w	8007a00 <_dtoa_r+0x454>
 8007e4e:	980c      	ldr	r0, [sp, #48]	; 0x30
 8007e50:	4637      	mov	r7, r6
 8007e52:	9518      	str	r5, [sp, #96]	; 0x60
 8007e54:	4483      	add	fp, r0
 8007e56:	f8cd a05c 	str.w	sl, [sp, #92]	; 0x5c
 8007e5a:	465d      	mov	r5, fp
 8007e5c:	e9dd ab08 	ldrd	sl, fp, [sp, #32]
 8007e60:	9408      	str	r4, [sp, #32]
 8007e62:	e00f      	b.n	8007e84 <_dtoa_r+0x8d8>
 8007e64:	2100      	movs	r1, #0
 8007e66:	2000      	movs	r0, #0
 8007e68:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
 8007e6c:	f002 fc26 	bl	800a6bc <__aeabi_dsub>
 8007e70:	4642      	mov	r2, r8
 8007e72:	464b      	mov	r3, r9
 8007e74:	f003 f848 	bl	800af08 <__aeabi_dcmplt>
 8007e78:	2800      	cmp	r0, #0
 8007e7a:	f040 826a 	bne.w	8008352 <_dtoa_r+0xda6>
 8007e7e:	42af      	cmp	r7, r5
 8007e80:	f43f adba 	beq.w	80079f8 <_dtoa_r+0x44c>
 8007e84:	2300      	movs	r3, #0
 8007e86:	2200      	movs	r2, #0
 8007e88:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8007e8c:	4640      	mov	r0, r8
 8007e8e:	4649      	mov	r1, r9
 8007e90:	f002 fdc8 	bl	800aa24 <__aeabi_dmul>
 8007e94:	2300      	movs	r3, #0
 8007e96:	2200      	movs	r2, #0
 8007e98:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8007e9c:	4680      	mov	r8, r0
 8007e9e:	4689      	mov	r9, r1
 8007ea0:	4650      	mov	r0, sl
 8007ea2:	4659      	mov	r1, fp
 8007ea4:	f002 fdbe 	bl	800aa24 <__aeabi_dmul>
 8007ea8:	468b      	mov	fp, r1
 8007eaa:	4682      	mov	sl, r0
 8007eac:	f003 f854 	bl	800af58 <__aeabi_d2iz>
 8007eb0:	4604      	mov	r4, r0
 8007eb2:	f002 fd51 	bl	800a958 <__aeabi_i2d>
 8007eb6:	3430      	adds	r4, #48	; 0x30
 8007eb8:	4602      	mov	r2, r0
 8007eba:	460b      	mov	r3, r1
 8007ebc:	4650      	mov	r0, sl
 8007ebe:	4659      	mov	r1, fp
 8007ec0:	f002 fbfc 	bl	800a6bc <__aeabi_dsub>
 8007ec4:	4642      	mov	r2, r8
 8007ec6:	464b      	mov	r3, r9
 8007ec8:	f807 4b01 	strb.w	r4, [r7], #1
 8007ecc:	463e      	mov	r6, r7
 8007ece:	4682      	mov	sl, r0
 8007ed0:	468b      	mov	fp, r1
 8007ed2:	f003 f819 	bl	800af08 <__aeabi_dcmplt>
 8007ed6:	4652      	mov	r2, sl
 8007ed8:	465b      	mov	r3, fp
 8007eda:	2800      	cmp	r0, #0
 8007edc:	d0c2      	beq.n	8007e64 <_dtoa_r+0x8b8>
 8007ede:	f8dd a05c 	ldr.w	sl, [sp, #92]	; 0x5c
 8007ee2:	9c08      	ldr	r4, [sp, #32]
 8007ee4:	9d12      	ldr	r5, [sp, #72]	; 0x48
 8007ee6:	e577      	b.n	80079d8 <_dtoa_r+0x42c>
 8007ee8:	2600      	movs	r6, #0
 8007eea:	e4fc      	b.n	80078e6 <_dtoa_r+0x33a>
 8007eec:	2301      	movs	r3, #1
 8007eee:	9310      	str	r3, [sp, #64]	; 0x40
 8007ef0:	9929      	ldr	r1, [sp, #164]	; 0xa4
 8007ef2:	2900      	cmp	r1, #0
 8007ef4:	bfc2      	ittt	gt
 8007ef6:	468b      	movgt	fp, r1
 8007ef8:	910e      	strgt	r1, [sp, #56]	; 0x38
 8007efa:	910a      	strgt	r1, [sp, #40]	; 0x28
 8007efc:	f340 81b4 	ble.w	8008268 <_dtoa_r+0xcbc>
 8007f00:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8007f02:	2200      	movs	r2, #0
 8007f04:	f1bb 0f17 	cmp.w	fp, #23
 8007f08:	6072      	str	r2, [r6, #4]
 8007f0a:	f240 82a1 	bls.w	8008450 <_dtoa_r+0xea4>
 8007f0e:	2304      	movs	r3, #4
 8007f10:	005b      	lsls	r3, r3, #1
 8007f12:	3201      	adds	r2, #1
 8007f14:	f103 0114 	add.w	r1, r3, #20
 8007f18:	4559      	cmp	r1, fp
 8007f1a:	d9f9      	bls.n	8007f10 <_dtoa_r+0x964>
 8007f1c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007f1e:	6072      	str	r2, [r6, #4]
 8007f20:	2b0e      	cmp	r3, #14
 8007f22:	bf8c      	ite	hi
 8007f24:	2700      	movhi	r7, #0
 8007f26:	f007 0701 	andls.w	r7, r7, #1
 8007f2a:	e484      	b.n	8007836 <_dtoa_r+0x28a>
 8007f2c:	2300      	movs	r3, #0
 8007f2e:	9310      	str	r3, [sp, #64]	; 0x40
 8007f30:	9829      	ldr	r0, [sp, #164]	; 0xa4
 8007f32:	1828      	adds	r0, r5, r0
 8007f34:	900e      	str	r0, [sp, #56]	; 0x38
 8007f36:	f100 0b01 	add.w	fp, r0, #1
 8007f3a:	f1bb 0f00 	cmp.w	fp, #0
 8007f3e:	bfc8      	it	gt
 8007f40:	f8cd b028 	strgt.w	fp, [sp, #40]	; 0x28
 8007f44:	dcdc      	bgt.n	8007f00 <_dtoa_r+0x954>
 8007f46:	f1bb 0f0e 	cmp.w	fp, #14
 8007f4a:	bf8c      	ite	hi
 8007f4c:	2700      	movhi	r7, #0
 8007f4e:	f007 0701 	andls.w	r7, r7, #1
 8007f52:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
 8007f56:	e46b      	b.n	8007830 <_dtoa_r+0x284>
 8007f58:	2000      	movs	r0, #0
 8007f5a:	9010      	str	r0, [sp, #64]	; 0x40
 8007f5c:	e7c8      	b.n	8007ef0 <_dtoa_r+0x944>
 8007f5e:	2201      	movs	r2, #1
 8007f60:	9210      	str	r2, [sp, #64]	; 0x40
 8007f62:	e7e5      	b.n	8007f30 <_dtoa_r+0x984>
 8007f64:	f04f 33ff 	mov.w	r3, #4294967295
 8007f68:	2700      	movs	r7, #0
 8007f6a:	2001      	movs	r0, #1
 8007f6c:	930e      	str	r3, [sp, #56]	; 0x38
 8007f6e:	9010      	str	r0, [sp, #64]	; 0x40
 8007f70:	930a      	str	r3, [sp, #40]	; 0x28
 8007f72:	9729      	str	r7, [sp, #164]	; 0xa4
 8007f74:	e45c      	b.n	8007830 <_dtoa_r+0x284>
 8007f76:	f1b8 0f00 	cmp.w	r8, #0
 8007f7a:	f47f ae5e 	bne.w	8007c3a <_dtoa_r+0x68e>
 8007f7e:	f3c9 0313 	ubfx	r3, r9, #0, #20
 8007f82:	4647      	mov	r7, r8
 8007f84:	2b00      	cmp	r3, #0
 8007f86:	f47f ae59 	bne.w	8007c3c <_dtoa_r+0x690>
 8007f8a:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 8007f8e:	ea09 0303 	and.w	r3, r9, r3
 8007f92:	461f      	mov	r7, r3
 8007f94:	2b00      	cmp	r3, #0
 8007f96:	f43f ae51 	beq.w	8007c3c <_dtoa_r+0x690>
 8007f9a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007f9c:	2701      	movs	r7, #1
 8007f9e:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8007fa0:	3301      	adds	r3, #1
 8007fa2:	930d      	str	r3, [sp, #52]	; 0x34
 8007fa4:	3001      	adds	r0, #1
 8007fa6:	900b      	str	r0, [sp, #44]	; 0x2c
 8007fa8:	e648      	b.n	8007c3c <_dtoa_r+0x690>
 8007faa:	9810      	ldr	r0, [sp, #64]	; 0x40
 8007fac:	2800      	cmp	r0, #0
 8007fae:	f000 8161 	beq.w	8008274 <_dtoa_r+0xcc8>
 8007fb2:	2e00      	cmp	r6, #0
 8007fb4:	dd05      	ble.n	8007fc2 <_dtoa_r+0xa16>
 8007fb6:	4620      	mov	r0, r4
 8007fb8:	9908      	ldr	r1, [sp, #32]
 8007fba:	4632      	mov	r2, r6
 8007fbc:	f000 fe2a 	bl	8008c14 <__lshift>
 8007fc0:	9008      	str	r0, [sp, #32]
 8007fc2:	2f00      	cmp	r7, #0
 8007fc4:	f040 81ed 	bne.w	80083a2 <_dtoa_r+0xdf6>
 8007fc8:	9808      	ldr	r0, [sp, #32]
 8007fca:	9002      	str	r0, [sp, #8]
 8007fcc:	990a      	ldr	r1, [sp, #40]	; 0x28
 8007fce:	f008 0201 	and.w	r2, r8, #1
 8007fd2:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8007fd4:	9f08      	ldr	r7, [sp, #32]
 8007fd6:	1871      	adds	r1, r6, r1
 8007fd8:	920a      	str	r2, [sp, #40]	; 0x28
 8007fda:	910b      	str	r1, [sp, #44]	; 0x2c
 8007fdc:	9508      	str	r5, [sp, #32]
 8007fde:	4659      	mov	r1, fp
 8007fe0:	4650      	mov	r0, sl
 8007fe2:	f7ff fa4d 	bl	8007480 <quorem>
 8007fe6:	4639      	mov	r1, r7
 8007fe8:	f04f 0901 	mov.w	r9, #1
 8007fec:	3030      	adds	r0, #48	; 0x30
 8007fee:	9007      	str	r0, [sp, #28]
 8007ff0:	4650      	mov	r0, sl
 8007ff2:	f000 fe65 	bl	8008cc0 <__mcmp>
 8007ff6:	4659      	mov	r1, fp
 8007ff8:	9a02      	ldr	r2, [sp, #8]
 8007ffa:	4605      	mov	r5, r0
 8007ffc:	4620      	mov	r0, r4
 8007ffe:	f000 fe7d 	bl	8008cfc <__mdiff>
 8008002:	68c3      	ldr	r3, [r0, #12]
 8008004:	4680      	mov	r8, r0
 8008006:	2b00      	cmp	r3, #0
 8008008:	d03a      	beq.n	8008080 <_dtoa_r+0xad4>
 800800a:	4620      	mov	r0, r4
 800800c:	4641      	mov	r1, r8
 800800e:	f000 fc15 	bl	800883c <_Bfree>
 8008012:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 8008014:	ea59 0303 	orrs.w	r3, r9, r3
 8008018:	d103      	bne.n	8008022 <_dtoa_r+0xa76>
 800801a:	980a      	ldr	r0, [sp, #40]	; 0x28
 800801c:	2800      	cmp	r0, #0
 800801e:	f000 81f3 	beq.w	8008408 <_dtoa_r+0xe5c>
 8008022:	2d00      	cmp	r5, #0
 8008024:	f2c0 819d 	blt.w	8008362 <_dtoa_r+0xdb6>
 8008028:	9828      	ldr	r0, [sp, #160]	; 0xa0
 800802a:	4328      	orrs	r0, r5
 800802c:	d103      	bne.n	8008036 <_dtoa_r+0xa8a>
 800802e:	990a      	ldr	r1, [sp, #40]	; 0x28
 8008030:	2900      	cmp	r1, #0
 8008032:	f000 8196 	beq.w	8008362 <_dtoa_r+0xdb6>
 8008036:	f1b9 0f00 	cmp.w	r9, #0
 800803a:	f300 81d2 	bgt.w	80083e2 <_dtoa_r+0xe36>
 800803e:	9a07      	ldr	r2, [sp, #28]
 8008040:	f806 2b01 	strb.w	r2, [r6], #1
 8008044:	46b0      	mov	r8, r6
 8008046:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008048:	429e      	cmp	r6, r3
 800804a:	f000 81c6 	beq.w	80083da <_dtoa_r+0xe2e>
 800804e:	4651      	mov	r1, sl
 8008050:	220a      	movs	r2, #10
 8008052:	2300      	movs	r3, #0
 8008054:	4620      	mov	r0, r4
 8008056:	f000 fc0d 	bl	8008874 <__multadd>
 800805a:	4682      	mov	sl, r0
 800805c:	9802      	ldr	r0, [sp, #8]
 800805e:	4287      	cmp	r7, r0
 8008060:	d022      	beq.n	80080a8 <_dtoa_r+0xafc>
 8008062:	4639      	mov	r1, r7
 8008064:	220a      	movs	r2, #10
 8008066:	2300      	movs	r3, #0
 8008068:	4620      	mov	r0, r4
 800806a:	f000 fc03 	bl	8008874 <__multadd>
 800806e:	9902      	ldr	r1, [sp, #8]
 8008070:	220a      	movs	r2, #10
 8008072:	2300      	movs	r3, #0
 8008074:	4607      	mov	r7, r0
 8008076:	4620      	mov	r0, r4
 8008078:	f000 fbfc 	bl	8008874 <__multadd>
 800807c:	9002      	str	r0, [sp, #8]
 800807e:	e7ae      	b.n	8007fde <_dtoa_r+0xa32>
 8008080:	4650      	mov	r0, sl
 8008082:	4641      	mov	r1, r8
 8008084:	f000 fe1c 	bl	8008cc0 <__mcmp>
 8008088:	4681      	mov	r9, r0
 800808a:	e7be      	b.n	800800a <_dtoa_r+0xa5e>
 800808c:	4620      	mov	r0, r4
 800808e:	4639      	mov	r1, r7
 8008090:	f000 fbd4 	bl	800883c <_Bfree>
 8008094:	e49c      	b.n	80079d0 <_dtoa_r+0x424>
 8008096:	231c      	movs	r3, #28
 8008098:	990d      	ldr	r1, [sp, #52]	; 0x34
 800809a:	18f6      	adds	r6, r6, r3
 800809c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800809e:	18c9      	adds	r1, r1, r3
 80080a0:	910d      	str	r1, [sp, #52]	; 0x34
 80080a2:	18d2      	adds	r2, r2, r3
 80080a4:	920b      	str	r2, [sp, #44]	; 0x2c
 80080a6:	e5e0      	b.n	8007c6a <_dtoa_r+0x6be>
 80080a8:	4639      	mov	r1, r7
 80080aa:	4620      	mov	r0, r4
 80080ac:	220a      	movs	r2, #10
 80080ae:	2300      	movs	r3, #0
 80080b0:	f000 fbe0 	bl	8008874 <__multadd>
 80080b4:	4607      	mov	r7, r0
 80080b6:	9002      	str	r0, [sp, #8]
 80080b8:	e791      	b.n	8007fde <_dtoa_r+0xa32>
 80080ba:	426e      	negs	r6, r5
 80080bc:	2e00      	cmp	r6, #0
 80080be:	f000 811d 	beq.w	80082fc <_dtoa_r+0xd50>
 80080c2:	f006 030f 	and.w	r3, r6, #15
 80080c6:	f64b 0200 	movw	r2, #47104	; 0xb800
 80080ca:	f6c0 0200 	movt	r2, #2048	; 0x800
 80080ce:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80080d2:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80080d6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80080da:	f002 fca3 	bl	800aa24 <__aeabi_dmul>
 80080de:	1136      	asrs	r6, r6, #4
 80080e0:	e9cd 0108 	strd	r0, r1, [sp, #32]
 80080e4:	f000 810a 	beq.w	80082fc <_dtoa_r+0xd50>
 80080e8:	f64b 07c8 	movw	r7, #47304	; 0xb8c8
 80080ec:	f04f 0802 	mov.w	r8, #2
 80080f0:	f6c0 0700 	movt	r7, #2048	; 0x800
 80080f4:	4602      	mov	r2, r0
 80080f6:	460b      	mov	r3, r1
 80080f8:	f016 0f01 	tst.w	r6, #1
 80080fc:	4610      	mov	r0, r2
 80080fe:	4619      	mov	r1, r3
 8008100:	d007      	beq.n	8008112 <_dtoa_r+0xb66>
 8008102:	e9d7 2300 	ldrd	r2, r3, [r7]
 8008106:	f108 0801 	add.w	r8, r8, #1
 800810a:	f002 fc8b 	bl	800aa24 <__aeabi_dmul>
 800810e:	4602      	mov	r2, r0
 8008110:	460b      	mov	r3, r1
 8008112:	3708      	adds	r7, #8
 8008114:	1076      	asrs	r6, r6, #1
 8008116:	d1ef      	bne.n	80080f8 <_dtoa_r+0xb4c>
 8008118:	e9cd 2308 	strd	r2, r3, [sp, #32]
 800811c:	f7ff bbd4 	b.w	80078c8 <_dtoa_r+0x31c>
 8008120:	f10b 32ff 	add.w	r2, fp, #4294967295
 8008124:	9217      	str	r2, [sp, #92]	; 0x5c
 8008126:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8008128:	f64b 0100 	movw	r1, #47104	; 0xb800
 800812c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8008130:	4642      	mov	r2, r8
 8008132:	464b      	mov	r3, r9
 8008134:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8008136:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 800813a:	e9d1 0100 	ldrd	r0, r1, [r1]
 800813e:	f002 fc71 	bl	800aa24 <__aeabi_dmul>
 8008142:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
 8008146:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800814a:	f002 ff05 	bl	800af58 <__aeabi_d2iz>
 800814e:	4607      	mov	r7, r0
 8008150:	f002 fc02 	bl	800a958 <__aeabi_i2d>
 8008154:	460b      	mov	r3, r1
 8008156:	4602      	mov	r2, r0
 8008158:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800815c:	f002 faae 	bl	800a6bc <__aeabi_dsub>
 8008160:	f1bb 0f01 	cmp.w	fp, #1
 8008164:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8008168:	e9cd 0108 	strd	r0, r1, [sp, #32]
 800816c:	f806 3b01 	strb.w	r3, [r6], #1
 8008170:	d02b      	beq.n	80081ca <_dtoa_r+0xc1e>
 8008172:	990c      	ldr	r1, [sp, #48]	; 0x30
 8008174:	951b      	str	r5, [sp, #108]	; 0x6c
 8008176:	f101 39ff 	add.w	r9, r1, #4294967295
 800817a:	460f      	mov	r7, r1
 800817c:	44d9      	add	r9, fp
 800817e:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8008182:	46d3      	mov	fp, sl
 8008184:	464d      	mov	r5, r9
 8008186:	46b2      	mov	sl, r6
 8008188:	4626      	mov	r6, r4
 800818a:	2300      	movs	r3, #0
 800818c:	2200      	movs	r2, #0
 800818e:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8008192:	f002 fc47 	bl	800aa24 <__aeabi_dmul>
 8008196:	4689      	mov	r9, r1
 8008198:	4680      	mov	r8, r0
 800819a:	f002 fedd 	bl	800af58 <__aeabi_d2iz>
 800819e:	4604      	mov	r4, r0
 80081a0:	f002 fbda 	bl	800a958 <__aeabi_i2d>
 80081a4:	3430      	adds	r4, #48	; 0x30
 80081a6:	4602      	mov	r2, r0
 80081a8:	460b      	mov	r3, r1
 80081aa:	4640      	mov	r0, r8
 80081ac:	4649      	mov	r1, r9
 80081ae:	f002 fa85 	bl	800a6bc <__aeabi_dsub>
 80081b2:	f807 4f01 	strb.w	r4, [r7, #1]!
 80081b6:	42af      	cmp	r7, r5
 80081b8:	d1e7      	bne.n	800818a <_dtoa_r+0xbde>
 80081ba:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80081bc:	4634      	mov	r4, r6
 80081be:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
 80081c0:	4656      	mov	r6, sl
 80081c2:	18b6      	adds	r6, r6, r2
 80081c4:	46da      	mov	sl, fp
 80081c6:	e9cd 0108 	strd	r0, r1, [sp, #32]
 80081ca:	2300      	movs	r3, #0
 80081cc:	2200      	movs	r2, #0
 80081ce:	f6c3 73e0 	movt	r3, #16352	; 0x3fe0
 80081d2:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
 80081d6:	f002 fa73 	bl	800a6c0 <__adddf3>
 80081da:	4602      	mov	r2, r0
 80081dc:	460b      	mov	r3, r1
 80081de:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80081e2:	f002 feaf 	bl	800af44 <__aeabi_dcmpgt>
 80081e6:	2800      	cmp	r0, #0
 80081e8:	f47f acc3 	bne.w	8007b72 <_dtoa_r+0x5c6>
 80081ec:	2100      	movs	r1, #0
 80081ee:	e9dd 2318 	ldrd	r2, r3, [sp, #96]	; 0x60
 80081f2:	2000      	movs	r0, #0
 80081f4:	f6c3 71e0 	movt	r1, #16352	; 0x3fe0
 80081f8:	f002 fa60 	bl	800a6bc <__aeabi_dsub>
 80081fc:	4602      	mov	r2, r0
 80081fe:	460b      	mov	r3, r1
 8008200:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8008204:	f002 fe80 	bl	800af08 <__aeabi_dcmplt>
 8008208:	2800      	cmp	r0, #0
 800820a:	f43f abf9 	beq.w	8007a00 <_dtoa_r+0x454>
 800820e:	4633      	mov	r3, r6
 8008210:	461e      	mov	r6, r3
 8008212:	3b01      	subs	r3, #1
 8008214:	f816 2c01 	ldrb.w	r2, [r6, #-1]
 8008218:	2a30      	cmp	r2, #48	; 0x30
 800821a:	d0f9      	beq.n	8008210 <_dtoa_r+0xc64>
 800821c:	9d12      	ldr	r5, [sp, #72]	; 0x48
 800821e:	f7ff bbdb 	b.w	80079d8 <_dtoa_r+0x42c>
 8008222:	980c      	ldr	r0, [sp, #48]	; 0x30
 8008224:	f7ff ba04 	b.w	8007630 <_dtoa_r+0x84>
 8008228:	f8db 3010 	ldr.w	r3, [fp, #16]
 800822c:	eb0b 0383 	add.w	r3, fp, r3, lsl #2
 8008230:	6918      	ldr	r0, [r3, #16]
 8008232:	f000 fbad 	bl	8008990 <__hi0bits>
 8008236:	f1c0 0320 	rsb	r3, r0, #32
 800823a:	e504      	b.n	8007c46 <_dtoa_r+0x69a>
 800823c:	4650      	mov	r0, sl
 800823e:	4659      	mov	r1, fp
 8008240:	f000 fd3e 	bl	8008cc0 <__mcmp>
 8008244:	2800      	cmp	r0, #0
 8008246:	f6bf ad26 	bge.w	8007c96 <_dtoa_r+0x6ea>
 800824a:	4651      	mov	r1, sl
 800824c:	220a      	movs	r2, #10
 800824e:	4620      	mov	r0, r4
 8008250:	2300      	movs	r3, #0
 8008252:	f000 fb0f 	bl	8008874 <__multadd>
 8008256:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8008258:	3d01      	subs	r5, #1
 800825a:	4682      	mov	sl, r0
 800825c:	2a00      	cmp	r2, #0
 800825e:	f040 80e9 	bne.w	8008434 <_dtoa_r+0xe88>
 8008262:	980e      	ldr	r0, [sp, #56]	; 0x38
 8008264:	900a      	str	r0, [sp, #40]	; 0x28
 8008266:	e516      	b.n	8007c96 <_dtoa_r+0x6ea>
 8008268:	2201      	movs	r2, #1
 800826a:	920e      	str	r2, [sp, #56]	; 0x38
 800826c:	920a      	str	r2, [sp, #40]	; 0x28
 800826e:	9229      	str	r2, [sp, #164]	; 0xa4
 8008270:	f7ff bade 	b.w	8007830 <_dtoa_r+0x284>
 8008274:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8008276:	2701      	movs	r7, #1
 8008278:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
 800827c:	9502      	str	r5, [sp, #8]
 800827e:	e002      	b.n	8008286 <_dtoa_r+0xcda>
 8008280:	f000 faf8 	bl	8008874 <__multadd>
 8008284:	4682      	mov	sl, r0
 8008286:	4659      	mov	r1, fp
 8008288:	4650      	mov	r0, sl
 800828a:	f7ff f8f9 	bl	8007480 <quorem>
 800828e:	220a      	movs	r2, #10
 8008290:	2300      	movs	r3, #0
 8008292:	454f      	cmp	r7, r9
 8008294:	4651      	mov	r1, sl
 8008296:	f107 0701 	add.w	r7, r7, #1
 800829a:	f100 0530 	add.w	r5, r0, #48	; 0x30
 800829e:	4620      	mov	r0, r4
 80082a0:	f806 5b01 	strb.w	r5, [r6], #1
 80082a4:	46b0      	mov	r8, r6
 80082a6:	dbeb      	blt.n	8008280 <_dtoa_r+0xcd4>
 80082a8:	9507      	str	r5, [sp, #28]
 80082aa:	2700      	movs	r7, #0
 80082ac:	9d02      	ldr	r5, [sp, #8]
 80082ae:	4651      	mov	r1, sl
 80082b0:	2201      	movs	r2, #1
 80082b2:	4620      	mov	r0, r4
 80082b4:	f000 fcae 	bl	8008c14 <__lshift>
 80082b8:	4659      	mov	r1, fp
 80082ba:	4682      	mov	sl, r0
 80082bc:	f000 fd00 	bl	8008cc0 <__mcmp>
 80082c0:	2800      	cmp	r0, #0
 80082c2:	dd0f      	ble.n	80082e4 <_dtoa_r+0xd38>
 80082c4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80082c6:	4646      	mov	r6, r8
 80082c8:	f108 38ff 	add.w	r8, r8, #4294967295
 80082cc:	f816 3c01 	ldrb.w	r3, [r6, #-1]
 80082d0:	2b39      	cmp	r3, #57	; 0x39
 80082d2:	d161      	bne.n	8008398 <_dtoa_r+0xdec>
 80082d4:	4590      	cmp	r8, r2
 80082d6:	d1f6      	bne.n	80082c6 <_dtoa_r+0xd1a>
 80082d8:	980c      	ldr	r0, [sp, #48]	; 0x30
 80082da:	2331      	movs	r3, #49	; 0x31
 80082dc:	3501      	adds	r5, #1
 80082de:	7003      	strb	r3, [r0, #0]
 80082e0:	f7ff bb65 	b.w	80079ae <_dtoa_r+0x402>
 80082e4:	d103      	bne.n	80082ee <_dtoa_r+0xd42>
 80082e6:	9a07      	ldr	r2, [sp, #28]
 80082e8:	f012 0f01 	tst.w	r2, #1
 80082ec:	d1ea      	bne.n	80082c4 <_dtoa_r+0xd18>
 80082ee:	4646      	mov	r6, r8
 80082f0:	f818 3d01 	ldrb.w	r3, [r8, #-1]!
 80082f4:	2b30      	cmp	r3, #48	; 0x30
 80082f6:	d0fa      	beq.n	80082ee <_dtoa_r+0xd42>
 80082f8:	f7ff bb59 	b.w	80079ae <_dtoa_r+0x402>
 80082fc:	f04f 0802 	mov.w	r8, #2
 8008300:	f7ff bae2 	b.w	80078c8 <_dtoa_r+0x31c>
 8008304:	9d07      	ldr	r5, [sp, #28]
 8008306:	4644      	mov	r4, r8
 8008308:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 800830c:	f7ff bb64 	b.w	80079d8 <_dtoa_r+0x42c>
 8008310:	4651      	mov	r1, sl
 8008312:	4620      	mov	r0, r4
 8008314:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8008316:	f000 fc2b 	bl	8008b70 <__pow5mult>
 800831a:	4682      	mov	sl, r0
 800831c:	e47b      	b.n	8007c16 <_dtoa_r+0x66a>
 800831e:	4651      	mov	r1, sl
 8008320:	4620      	mov	r0, r4
 8008322:	f000 fc25 	bl	8008b70 <__pow5mult>
 8008326:	4682      	mov	sl, r0
 8008328:	e475      	b.n	8007c16 <_dtoa_r+0x66a>
 800832a:	9816      	ldr	r0, [sp, #88]	; 0x58
 800832c:	2800      	cmp	r0, #0
 800832e:	d04e      	beq.n	80083ce <_dtoa_r+0xe22>
 8008330:	f503 6386 	add.w	r3, r3, #1072	; 0x430
 8008334:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 8008336:	3303      	adds	r3, #3
 8008338:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 800833a:	e517      	b.n	8007d6c <_dtoa_r+0x7c0>
 800833c:	f04f 0b00 	mov.w	fp, #0
 8008340:	f8cd b020 	str.w	fp, [sp, #32]
 8008344:	f7ff bb2f 	b.w	80079a6 <_dtoa_r+0x3fa>
 8008348:	3101      	adds	r1, #1
 800834a:	9d12      	ldr	r5, [sp, #72]	; 0x48
 800834c:	7011      	strb	r1, [r2, #0]
 800834e:	f7ff bb43 	b.w	80079d8 <_dtoa_r+0x42c>
 8008352:	f8dd a05c 	ldr.w	sl, [sp, #92]	; 0x5c
 8008356:	9c08      	ldr	r4, [sp, #32]
 8008358:	e40b      	b.n	8007b72 <_dtoa_r+0x5c6>
 800835a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800835c:	1a9e      	subs	r6, r3, r2
 800835e:	2300      	movs	r3, #0
 8008360:	e504      	b.n	8007d6c <_dtoa_r+0x7c0>
 8008362:	f1b9 0f00 	cmp.w	r9, #0
 8008366:	9d08      	ldr	r5, [sp, #32]
 8008368:	dd0f      	ble.n	800838a <_dtoa_r+0xdde>
 800836a:	4651      	mov	r1, sl
 800836c:	2201      	movs	r2, #1
 800836e:	4620      	mov	r0, r4
 8008370:	f000 fc50 	bl	8008c14 <__lshift>
 8008374:	4659      	mov	r1, fp
 8008376:	4682      	mov	sl, r0
 8008378:	f000 fca2 	bl	8008cc0 <__mcmp>
 800837c:	2800      	cmp	r0, #0
 800837e:	dd53      	ble.n	8008428 <_dtoa_r+0xe7c>
 8008380:	9b07      	ldr	r3, [sp, #28]
 8008382:	2b39      	cmp	r3, #57	; 0x39
 8008384:	d039      	beq.n	80083fa <_dtoa_r+0xe4e>
 8008386:	3301      	adds	r3, #1
 8008388:	9307      	str	r3, [sp, #28]
 800838a:	9802      	ldr	r0, [sp, #8]
 800838c:	9907      	ldr	r1, [sp, #28]
 800838e:	9008      	str	r0, [sp, #32]
 8008390:	f806 1b01 	strb.w	r1, [r6], #1
 8008394:	f7ff bb0b 	b.w	80079ae <_dtoa_r+0x402>
 8008398:	3301      	adds	r3, #1
 800839a:	f888 3000 	strb.w	r3, [r8]
 800839e:	f7ff bb06 	b.w	80079ae <_dtoa_r+0x402>
 80083a2:	9a08      	ldr	r2, [sp, #32]
 80083a4:	4620      	mov	r0, r4
 80083a6:	6851      	ldr	r1, [r2, #4]
 80083a8:	f000 fa14 	bl	80087d4 <_Balloc>
 80083ac:	9b08      	ldr	r3, [sp, #32]
 80083ae:	f103 010c 	add.w	r1, r3, #12
 80083b2:	691a      	ldr	r2, [r3, #16]
 80083b4:	3202      	adds	r2, #2
 80083b6:	0092      	lsls	r2, r2, #2
 80083b8:	4606      	mov	r6, r0
 80083ba:	300c      	adds	r0, #12
 80083bc:	f000 f962 	bl	8008684 <memcpy>
 80083c0:	4620      	mov	r0, r4
 80083c2:	4631      	mov	r1, r6
 80083c4:	2201      	movs	r2, #1
 80083c6:	f000 fc25 	bl	8008c14 <__lshift>
 80083ca:	9002      	str	r0, [sp, #8]
 80083cc:	e5fe      	b.n	8007fcc <_dtoa_r+0xa20>
 80083ce:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80083d0:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 80083d2:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 80083d4:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 80083d8:	e4c8      	b.n	8007d6c <_dtoa_r+0x7c0>
 80083da:	9902      	ldr	r1, [sp, #8]
 80083dc:	9d08      	ldr	r5, [sp, #32]
 80083de:	9108      	str	r1, [sp, #32]
 80083e0:	e765      	b.n	80082ae <_dtoa_r+0xd02>
 80083e2:	9a07      	ldr	r2, [sp, #28]
 80083e4:	9d08      	ldr	r5, [sp, #32]
 80083e6:	2a39      	cmp	r2, #57	; 0x39
 80083e8:	d007      	beq.n	80083fa <_dtoa_r+0xe4e>
 80083ea:	9902      	ldr	r1, [sp, #8]
 80083ec:	9807      	ldr	r0, [sp, #28]
 80083ee:	9108      	str	r1, [sp, #32]
 80083f0:	1c43      	adds	r3, r0, #1
 80083f2:	f806 3b01 	strb.w	r3, [r6], #1
 80083f6:	f7ff bada 	b.w	80079ae <_dtoa_r+0x402>
 80083fa:	9b02      	ldr	r3, [sp, #8]
 80083fc:	46b0      	mov	r8, r6
 80083fe:	9308      	str	r3, [sp, #32]
 8008400:	2339      	movs	r3, #57	; 0x39
 8008402:	f808 3b01 	strb.w	r3, [r8], #1
 8008406:	e75d      	b.n	80082c4 <_dtoa_r+0xd18>
 8008408:	9907      	ldr	r1, [sp, #28]
 800840a:	462b      	mov	r3, r5
 800840c:	9d08      	ldr	r5, [sp, #32]
 800840e:	2939      	cmp	r1, #57	; 0x39
 8008410:	d0f3      	beq.n	80083fa <_dtoa_r+0xe4e>
 8008412:	2b00      	cmp	r3, #0
 8008414:	dd01      	ble.n	800841a <_dtoa_r+0xe6e>
 8008416:	3101      	adds	r1, #1
 8008418:	9107      	str	r1, [sp, #28]
 800841a:	9a02      	ldr	r2, [sp, #8]
 800841c:	9b07      	ldr	r3, [sp, #28]
 800841e:	9208      	str	r2, [sp, #32]
 8008420:	f806 3b01 	strb.w	r3, [r6], #1
 8008424:	f7ff bac3 	b.w	80079ae <_dtoa_r+0x402>
 8008428:	d1af      	bne.n	800838a <_dtoa_r+0xdde>
 800842a:	9a07      	ldr	r2, [sp, #28]
 800842c:	f012 0f01 	tst.w	r2, #1
 8008430:	d0ab      	beq.n	800838a <_dtoa_r+0xdde>
 8008432:	e7a5      	b.n	8008380 <_dtoa_r+0xdd4>
 8008434:	2300      	movs	r3, #0
 8008436:	4620      	mov	r0, r4
 8008438:	9908      	ldr	r1, [sp, #32]
 800843a:	220a      	movs	r2, #10
 800843c:	f000 fa1a 	bl	8008874 <__multadd>
 8008440:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8008442:	930a      	str	r3, [sp, #40]	; 0x28
 8008444:	9008      	str	r0, [sp, #32]
 8008446:	e426      	b.n	8007c96 <_dtoa_r+0x6ea>
 8008448:	f43f ac0f 	beq.w	8007c6a <_dtoa_r+0x6be>
 800844c:	331c      	adds	r3, #28
 800844e:	e623      	b.n	8008098 <_dtoa_r+0xaec>
 8008450:	990a      	ldr	r1, [sp, #40]	; 0x28
 8008452:	290e      	cmp	r1, #14
 8008454:	bf8c      	ite	hi
 8008456:	2700      	movhi	r7, #0
 8008458:	f007 0701 	andls.w	r7, r7, #1
 800845c:	f7ff b9eb 	b.w	8007836 <_dtoa_r+0x28a>
 8008460:	2701      	movs	r7, #1
 8008462:	f7ff b970 	b.w	8007746 <_dtoa_r+0x19a>
 8008466:	bf00      	nop

08008468 <_fclose_r>:
 8008468:	b570      	push	{r4, r5, r6, lr}
 800846a:	460c      	mov	r4, r1
 800846c:	4605      	mov	r5, r0
 800846e:	460e      	mov	r6, r1
 8008470:	2900      	cmp	r1, #0
 8008472:	d048      	beq.n	8008506 <_fclose_r+0x9e>
 8008474:	f7fd fa7e 	bl	8005974 <__sfp_lock_acquire>
 8008478:	b115      	cbz	r5, 8008480 <_fclose_r+0x18>
 800847a:	69ab      	ldr	r3, [r5, #24]
 800847c:	2b00      	cmp	r3, #0
 800847e:	d044      	beq.n	800850a <_fclose_r+0xa2>
 8008480:	f24b 736c 	movw	r3, #46956	; 0xb76c
 8008484:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008488:	429c      	cmp	r4, r3
 800848a:	bf08      	it	eq
 800848c:	686c      	ldreq	r4, [r5, #4]
 800848e:	d00e      	beq.n	80084ae <_fclose_r+0x46>
 8008490:	f24b 738c 	movw	r3, #46988	; 0xb78c
 8008494:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008498:	429c      	cmp	r4, r3
 800849a:	bf08      	it	eq
 800849c:	68ac      	ldreq	r4, [r5, #8]
 800849e:	d006      	beq.n	80084ae <_fclose_r+0x46>
 80084a0:	f24b 73ac 	movw	r3, #47020	; 0xb7ac
 80084a4:	f6c0 0300 	movt	r3, #2048	; 0x800
 80084a8:	429c      	cmp	r4, r3
 80084aa:	bf08      	it	eq
 80084ac:	68ec      	ldreq	r4, [r5, #12]
 80084ae:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
 80084b2:	b336      	cbz	r6, 8008502 <_fclose_r+0x9a>
 80084b4:	4628      	mov	r0, r5
 80084b6:	4621      	mov	r1, r4
 80084b8:	f7fd f876 	bl	80055a8 <_fflush_r>
 80084bc:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80084be:	4606      	mov	r6, r0
 80084c0:	b13b      	cbz	r3, 80084d2 <_fclose_r+0x6a>
 80084c2:	4628      	mov	r0, r5
 80084c4:	6a21      	ldr	r1, [r4, #32]
 80084c6:	4798      	blx	r3
 80084c8:	ea36 0620 	bics.w	r6, r6, r0, asr #32
 80084cc:	bf28      	it	cs
 80084ce:	f04f 36ff 	movcs.w	r6, #4294967295
 80084d2:	89a3      	ldrh	r3, [r4, #12]
 80084d4:	f013 0f80 	tst.w	r3, #128	; 0x80
 80084d8:	d11b      	bne.n	8008512 <_fclose_r+0xaa>
 80084da:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80084dc:	b141      	cbz	r1, 80084f0 <_fclose_r+0x88>
 80084de:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80084e2:	4299      	cmp	r1, r3
 80084e4:	d002      	beq.n	80084ec <_fclose_r+0x84>
 80084e6:	4628      	mov	r0, r5
 80084e8:	f7fd fab8 	bl	8005a5c <_free_r>
 80084ec:	2300      	movs	r3, #0
 80084ee:	6363      	str	r3, [r4, #52]	; 0x34
 80084f0:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 80084f2:	b121      	cbz	r1, 80084fe <_fclose_r+0x96>
 80084f4:	4628      	mov	r0, r5
 80084f6:	f7fd fab1 	bl	8005a5c <_free_r>
 80084fa:	2300      	movs	r3, #0
 80084fc:	64a3      	str	r3, [r4, #72]	; 0x48
 80084fe:	2300      	movs	r3, #0
 8008500:	81a3      	strh	r3, [r4, #12]
 8008502:	f7fd fa39 	bl	8005978 <__sfp_lock_release>
 8008506:	4630      	mov	r0, r6
 8008508:	bd70      	pop	{r4, r5, r6, pc}
 800850a:	4628      	mov	r0, r5
 800850c:	f7fd f96a 	bl	80057e4 <__sinit>
 8008510:	e7b6      	b.n	8008480 <_fclose_r+0x18>
 8008512:	4628      	mov	r0, r5
 8008514:	6921      	ldr	r1, [r4, #16]
 8008516:	f7fd faa1 	bl	8005a5c <_free_r>
 800851a:	e7de      	b.n	80084da <_fclose_r+0x72>

0800851c <fclose>:
 800851c:	f240 236c 	movw	r3, #620	; 0x26c
 8008520:	4601      	mov	r1, r0
 8008522:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008526:	6818      	ldr	r0, [r3, #0]
 8008528:	e79e      	b.n	8008468 <_fclose_r>
 800852a:	bf00      	nop

0800852c <_setlocale_r>:
 800852c:	b510      	push	{r4, lr}
 800852e:	4614      	mov	r4, r2
 8008530:	b13a      	cbz	r2, 8008542 <_setlocale_r+0x16>
 8008532:	f64b 3190 	movw	r1, #48016	; 0xbb90
 8008536:	4610      	mov	r0, r2
 8008538:	f6c0 0100 	movt	r1, #2048	; 0x800
 800853c:	f7fc ff20 	bl	8005380 <strcmp>
 8008540:	b920      	cbnz	r0, 800854c <_setlocale_r+0x20>
 8008542:	f64b 3038 	movw	r0, #47928	; 0xbb38
 8008546:	f6c0 0000 	movt	r0, #2048	; 0x800
 800854a:	bd10      	pop	{r4, pc}
 800854c:	f64b 3138 	movw	r1, #47928	; 0xbb38
 8008550:	4620      	mov	r0, r4
 8008552:	f6c0 0100 	movt	r1, #2048	; 0x800
 8008556:	f7fc ff13 	bl	8005380 <strcmp>
 800855a:	b920      	cbnz	r0, 8008566 <_setlocale_r+0x3a>
 800855c:	f64b 3038 	movw	r0, #47928	; 0xbb38
 8008560:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008564:	bd10      	pop	{r4, pc}
 8008566:	f64b 315c 	movw	r1, #47964	; 0xbb5c
 800856a:	4620      	mov	r0, r4
 800856c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8008570:	f7fc ff06 	bl	8005380 <strcmp>
 8008574:	f64b 3338 	movw	r3, #47928	; 0xbb38
 8008578:	f6c0 0300 	movt	r3, #2048	; 0x800
 800857c:	2800      	cmp	r0, #0
 800857e:	bf0c      	ite	eq
 8008580:	4618      	moveq	r0, r3
 8008582:	2000      	movne	r0, #0
 8008584:	bd10      	pop	{r4, pc}
 8008586:	bf00      	nop

08008588 <__locale_charset>:
 8008588:	f240 7070 	movw	r0, #1904	; 0x770
 800858c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8008590:	4770      	bx	lr
 8008592:	bf00      	nop

08008594 <__locale_mb_cur_max>:
 8008594:	f240 7370 	movw	r3, #1904	; 0x770
 8008598:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800859c:	6a18      	ldr	r0, [r3, #32]
 800859e:	4770      	bx	lr

080085a0 <__locale_msgcharset>:
 80085a0:	4800      	ldr	r0, [pc, #0]	; (80085a4 <__locale_msgcharset+0x4>)
 80085a2:	4770      	bx	lr
 80085a4:	20000794 	.word	0x20000794

080085a8 <__locale_cjk_lang>:
 80085a8:	2000      	movs	r0, #0
 80085aa:	4770      	bx	lr

080085ac <_localeconv_r>:
 80085ac:	4800      	ldr	r0, [pc, #0]	; (80085b0 <_localeconv_r+0x4>)
 80085ae:	4770      	bx	lr
 80085b0:	200007b4 	.word	0x200007b4

080085b4 <setlocale>:
 80085b4:	f240 236c 	movw	r3, #620	; 0x26c
 80085b8:	460a      	mov	r2, r1
 80085ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80085be:	4601      	mov	r1, r0
 80085c0:	6818      	ldr	r0, [r3, #0]
 80085c2:	e7b3      	b.n	800852c <_setlocale_r>

080085c4 <localeconv>:
 80085c4:	4800      	ldr	r0, [pc, #0]	; (80085c8 <localeconv+0x4>)
 80085c6:	4770      	bx	lr
 80085c8:	200007b4 	.word	0x200007b4

080085cc <_lseek_r>:
 80085cc:	b538      	push	{r3, r4, r5, lr}
 80085ce:	f641 24e4 	movw	r4, #6884	; 0x1ae4
 80085d2:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80085d6:	4605      	mov	r5, r0
 80085d8:	4608      	mov	r0, r1
 80085da:	4611      	mov	r1, r2
 80085dc:	461a      	mov	r2, r3
 80085de:	2300      	movs	r3, #0
 80085e0:	6023      	str	r3, [r4, #0]
 80085e2:	f7f8 f9cb 	bl	800097c <_lseek>
 80085e6:	f1b0 3fff 	cmp.w	r0, #4294967295
 80085ea:	d000      	beq.n	80085ee <_lseek_r+0x22>
 80085ec:	bd38      	pop	{r3, r4, r5, pc}
 80085ee:	6823      	ldr	r3, [r4, #0]
 80085f0:	2b00      	cmp	r3, #0
 80085f2:	d0fb      	beq.n	80085ec <_lseek_r+0x20>
 80085f4:	602b      	str	r3, [r5, #0]
 80085f6:	bd38      	pop	{r3, r4, r5, pc}

080085f8 <memchr>:
 80085f8:	f010 0f03 	tst.w	r0, #3
 80085fc:	4603      	mov	r3, r0
 80085fe:	b470      	push	{r4, r5, r6}
 8008600:	b2c9      	uxtb	r1, r1
 8008602:	d011      	beq.n	8008628 <memchr+0x30>
 8008604:	2a00      	cmp	r2, #0
 8008606:	d022      	beq.n	800864e <memchr+0x56>
 8008608:	7803      	ldrb	r3, [r0, #0]
 800860a:	428b      	cmp	r3, r1
 800860c:	d01d      	beq.n	800864a <memchr+0x52>
 800860e:	3a01      	subs	r2, #1
 8008610:	3001      	adds	r0, #1
 8008612:	e005      	b.n	8008620 <memchr+0x28>
 8008614:	b1da      	cbz	r2, 800864e <memchr+0x56>
 8008616:	f810 4b01 	ldrb.w	r4, [r0], #1
 800861a:	3a01      	subs	r2, #1
 800861c:	428c      	cmp	r4, r1
 800861e:	d018      	beq.n	8008652 <memchr+0x5a>
 8008620:	f010 0f03 	tst.w	r0, #3
 8008624:	4603      	mov	r3, r0
 8008626:	d1f5      	bne.n	8008614 <memchr+0x1c>
 8008628:	2a03      	cmp	r2, #3
 800862a:	d814      	bhi.n	8008656 <memchr+0x5e>
 800862c:	b17a      	cbz	r2, 800864e <memchr+0x56>
 800862e:	7818      	ldrb	r0, [r3, #0]
 8008630:	4288      	cmp	r0, r1
 8008632:	d00e      	beq.n	8008652 <memchr+0x5a>
 8008634:	1e54      	subs	r4, r2, #1
 8008636:	1c5d      	adds	r5, r3, #1
 8008638:	e003      	b.n	8008642 <memchr+0x4a>
 800863a:	f815 6b01 	ldrb.w	r6, [r5], #1
 800863e:	428e      	cmp	r6, r1
 8008640:	d003      	beq.n	800864a <memchr+0x52>
 8008642:	3c01      	subs	r4, #1
 8008644:	4628      	mov	r0, r5
 8008646:	d2f8      	bcs.n	800863a <memchr+0x42>
 8008648:	2000      	movs	r0, #0
 800864a:	bc70      	pop	{r4, r5, r6}
 800864c:	4770      	bx	lr
 800864e:	4610      	mov	r0, r2
 8008650:	e7fb      	b.n	800864a <memchr+0x52>
 8008652:	4618      	mov	r0, r3
 8008654:	e7f9      	b.n	800864a <memchr+0x52>
 8008656:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 800865a:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 800865e:	4618      	mov	r0, r3
 8008660:	f853 4b04 	ldr.w	r4, [r3], #4
 8008664:	ea86 0404 	eor.w	r4, r6, r4
 8008668:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 800866c:	ea25 0404 	bic.w	r4, r5, r4
 8008670:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 8008674:	d103      	bne.n	800867e <memchr+0x86>
 8008676:	3a04      	subs	r2, #4
 8008678:	4618      	mov	r0, r3
 800867a:	2a03      	cmp	r2, #3
 800867c:	d8ef      	bhi.n	800865e <memchr+0x66>
 800867e:	4603      	mov	r3, r0
 8008680:	e7d4      	b.n	800862c <memchr+0x34>
 8008682:	bf00      	nop

08008684 <memcpy>:
 8008684:	2a03      	cmp	r2, #3
 8008686:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 800868a:	d809      	bhi.n	80086a0 <memcpy+0x1c>
 800868c:	b12a      	cbz	r2, 800869a <memcpy+0x16>
 800868e:	2300      	movs	r3, #0
 8008690:	5ccc      	ldrb	r4, [r1, r3]
 8008692:	54c4      	strb	r4, [r0, r3]
 8008694:	3301      	adds	r3, #1
 8008696:	4293      	cmp	r3, r2
 8008698:	d1fa      	bne.n	8008690 <memcpy+0xc>
 800869a:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 800869e:	4770      	bx	lr
 80086a0:	460b      	mov	r3, r1
 80086a2:	1882      	adds	r2, r0, r2
 80086a4:	4601      	mov	r1, r0
 80086a6:	e003      	b.n	80086b0 <memcpy+0x2c>
 80086a8:	7824      	ldrb	r4, [r4, #0]
 80086aa:	3301      	adds	r3, #1
 80086ac:	f801 4b01 	strb.w	r4, [r1], #1
 80086b0:	f011 0f03 	tst.w	r1, #3
 80086b4:	461c      	mov	r4, r3
 80086b6:	d1f7      	bne.n	80086a8 <memcpy+0x24>
 80086b8:	f013 0503 	ands.w	r5, r3, #3
 80086bc:	d05d      	beq.n	800877a <memcpy+0xf6>
 80086be:	426e      	negs	r6, r5
 80086c0:	f1c5 0c04 	rsb	ip, r5, #4
 80086c4:	00ed      	lsls	r5, r5, #3
 80086c6:	599b      	ldr	r3, [r3, r6]
 80086c8:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 80086cc:	e008      	b.n	80086e0 <memcpy+0x5c>
 80086ce:	3404      	adds	r4, #4
 80086d0:	59a7      	ldr	r7, [r4, r6]
 80086d2:	463b      	mov	r3, r7
 80086d4:	fa07 f70c 	lsl.w	r7, r7, ip
 80086d8:	ea48 0707 	orr.w	r7, r8, r7
 80086dc:	f841 7b04 	str.w	r7, [r1], #4
 80086e0:	1a57      	subs	r7, r2, r1
 80086e2:	fa23 f805 	lsr.w	r8, r3, r5
 80086e6:	2f03      	cmp	r7, #3
 80086e8:	dcf1      	bgt.n	80086ce <memcpy+0x4a>
 80086ea:	e003      	b.n	80086f4 <memcpy+0x70>
 80086ec:	f814 3b01 	ldrb.w	r3, [r4], #1
 80086f0:	f801 3b01 	strb.w	r3, [r1], #1
 80086f4:	428a      	cmp	r2, r1
 80086f6:	d8f9      	bhi.n	80086ec <memcpy+0x68>
 80086f8:	e7cf      	b.n	800869a <memcpy+0x16>
 80086fa:	f853 4c40 	ldr.w	r4, [r3, #-64]
 80086fe:	f841 4c40 	str.w	r4, [r1, #-64]
 8008702:	f853 4c3c 	ldr.w	r4, [r3, #-60]
 8008706:	f841 4c3c 	str.w	r4, [r1, #-60]
 800870a:	f853 4c38 	ldr.w	r4, [r3, #-56]
 800870e:	f841 4c38 	str.w	r4, [r1, #-56]
 8008712:	f853 4c34 	ldr.w	r4, [r3, #-52]
 8008716:	f841 4c34 	str.w	r4, [r1, #-52]
 800871a:	f853 4c30 	ldr.w	r4, [r3, #-48]
 800871e:	f841 4c30 	str.w	r4, [r1, #-48]
 8008722:	f853 4c2c 	ldr.w	r4, [r3, #-44]
 8008726:	f841 4c2c 	str.w	r4, [r1, #-44]
 800872a:	f853 4c28 	ldr.w	r4, [r3, #-40]
 800872e:	f841 4c28 	str.w	r4, [r1, #-40]
 8008732:	f853 4c24 	ldr.w	r4, [r3, #-36]
 8008736:	f841 4c24 	str.w	r4, [r1, #-36]
 800873a:	f853 4c20 	ldr.w	r4, [r3, #-32]
 800873e:	f841 4c20 	str.w	r4, [r1, #-32]
 8008742:	f853 4c1c 	ldr.w	r4, [r3, #-28]
 8008746:	f841 4c1c 	str.w	r4, [r1, #-28]
 800874a:	f853 4c18 	ldr.w	r4, [r3, #-24]
 800874e:	f841 4c18 	str.w	r4, [r1, #-24]
 8008752:	f853 4c14 	ldr.w	r4, [r3, #-20]
 8008756:	f841 4c14 	str.w	r4, [r1, #-20]
 800875a:	f853 4c10 	ldr.w	r4, [r3, #-16]
 800875e:	f841 4c10 	str.w	r4, [r1, #-16]
 8008762:	f853 4c0c 	ldr.w	r4, [r3, #-12]
 8008766:	f841 4c0c 	str.w	r4, [r1, #-12]
 800876a:	f853 4c08 	ldr.w	r4, [r3, #-8]
 800876e:	f841 4c08 	str.w	r4, [r1, #-8]
 8008772:	f853 4c04 	ldr.w	r4, [r3, #-4]
 8008776:	f841 4c04 	str.w	r4, [r1, #-4]
 800877a:	1a56      	subs	r6, r2, r1
 800877c:	461d      	mov	r5, r3
 800877e:	460c      	mov	r4, r1
 8008780:	3340      	adds	r3, #64	; 0x40
 8008782:	3140      	adds	r1, #64	; 0x40
 8008784:	2e3f      	cmp	r6, #63	; 0x3f
 8008786:	dcb8      	bgt.n	80086fa <memcpy+0x76>
 8008788:	462b      	mov	r3, r5
 800878a:	e00f      	b.n	80087ac <memcpy+0x128>
 800878c:	f853 1c10 	ldr.w	r1, [r3, #-16]
 8008790:	f844 1c10 	str.w	r1, [r4, #-16]
 8008794:	f853 1c0c 	ldr.w	r1, [r3, #-12]
 8008798:	f844 1c0c 	str.w	r1, [r4, #-12]
 800879c:	f853 1c08 	ldr.w	r1, [r3, #-8]
 80087a0:	f844 1c08 	str.w	r1, [r4, #-8]
 80087a4:	f853 1c04 	ldr.w	r1, [r3, #-4]
 80087a8:	f844 1c04 	str.w	r1, [r4, #-4]
 80087ac:	1b16      	subs	r6, r2, r4
 80087ae:	4621      	mov	r1, r4
 80087b0:	461d      	mov	r5, r3
 80087b2:	3410      	adds	r4, #16
 80087b4:	3310      	adds	r3, #16
 80087b6:	2e0f      	cmp	r6, #15
 80087b8:	dce8      	bgt.n	800878c <memcpy+0x108>
 80087ba:	462b      	mov	r3, r5
 80087bc:	e002      	b.n	80087c4 <memcpy+0x140>
 80087be:	6824      	ldr	r4, [r4, #0]
 80087c0:	f841 4b04 	str.w	r4, [r1], #4
 80087c4:	1a55      	subs	r5, r2, r1
 80087c6:	461c      	mov	r4, r3
 80087c8:	2d03      	cmp	r5, #3
 80087ca:	f103 0304 	add.w	r3, r3, #4
 80087ce:	dcf6      	bgt.n	80087be <memcpy+0x13a>
 80087d0:	e790      	b.n	80086f4 <memcpy+0x70>
 80087d2:	bf00      	nop

080087d4 <_Balloc>:
 80087d4:	b570      	push	{r4, r5, r6, lr}
 80087d6:	4606      	mov	r6, r0
 80087d8:	6a44      	ldr	r4, [r0, #36]	; 0x24
 80087da:	460d      	mov	r5, r1
 80087dc:	b15c      	cbz	r4, 80087f6 <_Balloc+0x22>
 80087de:	68e3      	ldr	r3, [r4, #12]
 80087e0:	b19b      	cbz	r3, 800880a <_Balloc+0x36>
 80087e2:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 80087e6:	b1e0      	cbz	r0, 8008822 <_Balloc+0x4e>
 80087e8:	6802      	ldr	r2, [r0, #0]
 80087ea:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
 80087ee:	2300      	movs	r3, #0
 80087f0:	6103      	str	r3, [r0, #16]
 80087f2:	60c3      	str	r3, [r0, #12]
 80087f4:	bd70      	pop	{r4, r5, r6, pc}
 80087f6:	2010      	movs	r0, #16
 80087f8:	f7fc fa3e 	bl	8004c78 <malloc>
 80087fc:	2300      	movs	r3, #0
 80087fe:	4604      	mov	r4, r0
 8008800:	6270      	str	r0, [r6, #36]	; 0x24
 8008802:	6043      	str	r3, [r0, #4]
 8008804:	6083      	str	r3, [r0, #8]
 8008806:	6003      	str	r3, [r0, #0]
 8008808:	60c3      	str	r3, [r0, #12]
 800880a:	4630      	mov	r0, r6
 800880c:	2104      	movs	r1, #4
 800880e:	2221      	movs	r2, #33	; 0x21
 8008810:	f001 fb7c 	bl	8009f0c <_calloc_r>
 8008814:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8008816:	60e0      	str	r0, [r4, #12]
 8008818:	68db      	ldr	r3, [r3, #12]
 800881a:	2b00      	cmp	r3, #0
 800881c:	d1e1      	bne.n	80087e2 <_Balloc+0xe>
 800881e:	4618      	mov	r0, r3
 8008820:	bd70      	pop	{r4, r5, r6, pc}
 8008822:	2401      	movs	r4, #1
 8008824:	4630      	mov	r0, r6
 8008826:	4621      	mov	r1, r4
 8008828:	40ac      	lsls	r4, r5
 800882a:	1d62      	adds	r2, r4, #5
 800882c:	0092      	lsls	r2, r2, #2
 800882e:	f001 fb6d 	bl	8009f0c <_calloc_r>
 8008832:	2800      	cmp	r0, #0
 8008834:	d0f4      	beq.n	8008820 <_Balloc+0x4c>
 8008836:	6045      	str	r5, [r0, #4]
 8008838:	6084      	str	r4, [r0, #8]
 800883a:	e7d8      	b.n	80087ee <_Balloc+0x1a>

0800883c <_Bfree>:
 800883c:	b530      	push	{r4, r5, lr}
 800883e:	4604      	mov	r4, r0
 8008840:	6a45      	ldr	r5, [r0, #36]	; 0x24
 8008842:	b083      	sub	sp, #12
 8008844:	b155      	cbz	r5, 800885c <_Bfree+0x20>
 8008846:	b139      	cbz	r1, 8008858 <_Bfree+0x1c>
 8008848:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800884a:	684a      	ldr	r2, [r1, #4]
 800884c:	68db      	ldr	r3, [r3, #12]
 800884e:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 8008852:	6008      	str	r0, [r1, #0]
 8008854:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8008858:	b003      	add	sp, #12
 800885a:	bd30      	pop	{r4, r5, pc}
 800885c:	2010      	movs	r0, #16
 800885e:	9101      	str	r1, [sp, #4]
 8008860:	f7fc fa0a 	bl	8004c78 <malloc>
 8008864:	9901      	ldr	r1, [sp, #4]
 8008866:	6260      	str	r0, [r4, #36]	; 0x24
 8008868:	6045      	str	r5, [r0, #4]
 800886a:	6085      	str	r5, [r0, #8]
 800886c:	6005      	str	r5, [r0, #0]
 800886e:	60c5      	str	r5, [r0, #12]
 8008870:	e7e9      	b.n	8008846 <_Bfree+0xa>
 8008872:	bf00      	nop

08008874 <__multadd>:
 8008874:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008878:	460c      	mov	r4, r1
 800887a:	4605      	mov	r5, r0
 800887c:	690e      	ldr	r6, [r1, #16]
 800887e:	f101 0014 	add.w	r0, r1, #20
 8008882:	b082      	sub	sp, #8
 8008884:	2100      	movs	r1, #0
 8008886:	6807      	ldr	r7, [r0, #0]
 8008888:	3101      	adds	r1, #1
 800888a:	fa1f fc87 	uxth.w	ip, r7
 800888e:	0c3f      	lsrs	r7, r7, #16
 8008890:	fb0c 3302 	mla	r3, ip, r2, r3
 8008894:	fb07 f702 	mul.w	r7, r7, r2
 8008898:	eb07 4713 	add.w	r7, r7, r3, lsr #16
 800889c:	fa1f fc83 	uxth.w	ip, r3
 80088a0:	0c3b      	lsrs	r3, r7, #16
 80088a2:	428e      	cmp	r6, r1
 80088a4:	ea4f 4807 	mov.w	r8, r7, lsl #16
 80088a8:	eb08 070c 	add.w	r7, r8, ip
 80088ac:	f840 7b04 	str.w	r7, [r0], #4
 80088b0:	dce9      	bgt.n	8008886 <__multadd+0x12>
 80088b2:	b13b      	cbz	r3, 80088c4 <__multadd+0x50>
 80088b4:	68a2      	ldr	r2, [r4, #8]
 80088b6:	4296      	cmp	r6, r2
 80088b8:	da08      	bge.n	80088cc <__multadd+0x58>
 80088ba:	eb04 0286 	add.w	r2, r4, r6, lsl #2
 80088be:	3601      	adds	r6, #1
 80088c0:	6126      	str	r6, [r4, #16]
 80088c2:	6153      	str	r3, [r2, #20]
 80088c4:	4620      	mov	r0, r4
 80088c6:	b002      	add	sp, #8
 80088c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80088cc:	6861      	ldr	r1, [r4, #4]
 80088ce:	4628      	mov	r0, r5
 80088d0:	9301      	str	r3, [sp, #4]
 80088d2:	3101      	adds	r1, #1
 80088d4:	f7ff ff7e 	bl	80087d4 <_Balloc>
 80088d8:	6922      	ldr	r2, [r4, #16]
 80088da:	f104 010c 	add.w	r1, r4, #12
 80088de:	3202      	adds	r2, #2
 80088e0:	0092      	lsls	r2, r2, #2
 80088e2:	4607      	mov	r7, r0
 80088e4:	300c      	adds	r0, #12
 80088e6:	f7ff fecd 	bl	8008684 <memcpy>
 80088ea:	4621      	mov	r1, r4
 80088ec:	4628      	mov	r0, r5
 80088ee:	463c      	mov	r4, r7
 80088f0:	f7ff ffa4 	bl	800883c <_Bfree>
 80088f4:	9b01      	ldr	r3, [sp, #4]
 80088f6:	e7e0      	b.n	80088ba <__multadd+0x46>

080088f8 <__s2b>:
 80088f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80088fc:	f648 6539 	movw	r5, #36409	; 0x8e39
 8008900:	461f      	mov	r7, r3
 8008902:	f6c3 05e3 	movt	r5, #14563	; 0x38e3
 8008906:	3308      	adds	r3, #8
 8008908:	460e      	mov	r6, r1
 800890a:	4604      	mov	r4, r0
 800890c:	4690      	mov	r8, r2
 800890e:	fb85 1503 	smull	r1, r5, r5, r3
 8008912:	17db      	asrs	r3, r3, #31
 8008914:	ebc3 0365 	rsb	r3, r3, r5, asr #1
 8008918:	2b01      	cmp	r3, #1
 800891a:	dd37      	ble.n	800898c <__s2b+0x94>
 800891c:	2201      	movs	r2, #1
 800891e:	2100      	movs	r1, #0
 8008920:	0052      	lsls	r2, r2, #1
 8008922:	3101      	adds	r1, #1
 8008924:	4293      	cmp	r3, r2
 8008926:	dcfb      	bgt.n	8008920 <__s2b+0x28>
 8008928:	4620      	mov	r0, r4
 800892a:	f7ff ff53 	bl	80087d4 <_Balloc>
 800892e:	9b08      	ldr	r3, [sp, #32]
 8008930:	6143      	str	r3, [r0, #20]
 8008932:	2301      	movs	r3, #1
 8008934:	f1b8 0f09 	cmp.w	r8, #9
 8008938:	4601      	mov	r1, r0
 800893a:	6103      	str	r3, [r0, #16]
 800893c:	dd22      	ble.n	8008984 <__s2b+0x8c>
 800893e:	f106 0909 	add.w	r9, r6, #9
 8008942:	4446      	add	r6, r8
 8008944:	464d      	mov	r5, r9
 8008946:	f815 3b01 	ldrb.w	r3, [r5], #1
 800894a:	220a      	movs	r2, #10
 800894c:	4620      	mov	r0, r4
 800894e:	3b30      	subs	r3, #48	; 0x30
 8008950:	f7ff ff90 	bl	8008874 <__multadd>
 8008954:	42b5      	cmp	r5, r6
 8008956:	4601      	mov	r1, r0
 8008958:	d1f5      	bne.n	8008946 <__s2b+0x4e>
 800895a:	eb09 0608 	add.w	r6, r9, r8
 800895e:	3e08      	subs	r6, #8
 8008960:	4547      	cmp	r7, r8
 8008962:	dd0c      	ble.n	800897e <__s2b+0x86>
 8008964:	19f7      	adds	r7, r6, r7
 8008966:	ebc8 0707 	rsb	r7, r8, r7
 800896a:	f816 3b01 	ldrb.w	r3, [r6], #1
 800896e:	220a      	movs	r2, #10
 8008970:	4620      	mov	r0, r4
 8008972:	3b30      	subs	r3, #48	; 0x30
 8008974:	f7ff ff7e 	bl	8008874 <__multadd>
 8008978:	42be      	cmp	r6, r7
 800897a:	4601      	mov	r1, r0
 800897c:	d1f5      	bne.n	800896a <__s2b+0x72>
 800897e:	4608      	mov	r0, r1
 8008980:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8008984:	360a      	adds	r6, #10
 8008986:	f04f 0809 	mov.w	r8, #9
 800898a:	e7e9      	b.n	8008960 <__s2b+0x68>
 800898c:	2100      	movs	r1, #0
 800898e:	e7cb      	b.n	8008928 <__s2b+0x30>

08008990 <__hi0bits>:
 8008990:	0c02      	lsrs	r2, r0, #16
 8008992:	4603      	mov	r3, r0
 8008994:	d119      	bne.n	80089ca <__hi0bits+0x3a>
 8008996:	0403      	lsls	r3, r0, #16
 8008998:	2010      	movs	r0, #16
 800899a:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
 800899e:	d101      	bne.n	80089a4 <__hi0bits+0x14>
 80089a0:	3008      	adds	r0, #8
 80089a2:	021b      	lsls	r3, r3, #8
 80089a4:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
 80089a8:	d101      	bne.n	80089ae <__hi0bits+0x1e>
 80089aa:	3004      	adds	r0, #4
 80089ac:	011b      	lsls	r3, r3, #4
 80089ae:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
 80089b2:	d101      	bne.n	80089b8 <__hi0bits+0x28>
 80089b4:	3002      	adds	r0, #2
 80089b6:	009b      	lsls	r3, r3, #2
 80089b8:	2b00      	cmp	r3, #0
 80089ba:	db05      	blt.n	80089c8 <__hi0bits+0x38>
 80089bc:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
 80089c0:	d001      	beq.n	80089c6 <__hi0bits+0x36>
 80089c2:	3001      	adds	r0, #1
 80089c4:	4770      	bx	lr
 80089c6:	2020      	movs	r0, #32
 80089c8:	4770      	bx	lr
 80089ca:	2000      	movs	r0, #0
 80089cc:	e7e5      	b.n	800899a <__hi0bits+0xa>
 80089ce:	bf00      	nop

080089d0 <__lo0bits>:
 80089d0:	6803      	ldr	r3, [r0, #0]
 80089d2:	4602      	mov	r2, r0
 80089d4:	f013 0007 	ands.w	r0, r3, #7
 80089d8:	d009      	beq.n	80089ee <__lo0bits+0x1e>
 80089da:	f013 0f01 	tst.w	r3, #1
 80089de:	d121      	bne.n	8008a24 <__lo0bits+0x54>
 80089e0:	f013 0f02 	tst.w	r3, #2
 80089e4:	d122      	bne.n	8008a2c <__lo0bits+0x5c>
 80089e6:	089b      	lsrs	r3, r3, #2
 80089e8:	2002      	movs	r0, #2
 80089ea:	6013      	str	r3, [r2, #0]
 80089ec:	4770      	bx	lr
 80089ee:	b299      	uxth	r1, r3
 80089f0:	b909      	cbnz	r1, 80089f6 <__lo0bits+0x26>
 80089f2:	0c1b      	lsrs	r3, r3, #16
 80089f4:	2010      	movs	r0, #16
 80089f6:	f013 0fff 	tst.w	r3, #255	; 0xff
 80089fa:	d101      	bne.n	8008a00 <__lo0bits+0x30>
 80089fc:	3008      	adds	r0, #8
 80089fe:	0a1b      	lsrs	r3, r3, #8
 8008a00:	f013 0f0f 	tst.w	r3, #15
 8008a04:	d101      	bne.n	8008a0a <__lo0bits+0x3a>
 8008a06:	3004      	adds	r0, #4
 8008a08:	091b      	lsrs	r3, r3, #4
 8008a0a:	f013 0f03 	tst.w	r3, #3
 8008a0e:	d101      	bne.n	8008a14 <__lo0bits+0x44>
 8008a10:	3002      	adds	r0, #2
 8008a12:	089b      	lsrs	r3, r3, #2
 8008a14:	f013 0f01 	tst.w	r3, #1
 8008a18:	d102      	bne.n	8008a20 <__lo0bits+0x50>
 8008a1a:	085b      	lsrs	r3, r3, #1
 8008a1c:	d004      	beq.n	8008a28 <__lo0bits+0x58>
 8008a1e:	3001      	adds	r0, #1
 8008a20:	6013      	str	r3, [r2, #0]
 8008a22:	4770      	bx	lr
 8008a24:	2000      	movs	r0, #0
 8008a26:	4770      	bx	lr
 8008a28:	2020      	movs	r0, #32
 8008a2a:	4770      	bx	lr
 8008a2c:	085b      	lsrs	r3, r3, #1
 8008a2e:	2001      	movs	r0, #1
 8008a30:	6013      	str	r3, [r2, #0]
 8008a32:	4770      	bx	lr

08008a34 <__i2b>:
 8008a34:	b510      	push	{r4, lr}
 8008a36:	460c      	mov	r4, r1
 8008a38:	2101      	movs	r1, #1
 8008a3a:	f7ff fecb 	bl	80087d4 <_Balloc>
 8008a3e:	2201      	movs	r2, #1
 8008a40:	6144      	str	r4, [r0, #20]
 8008a42:	6102      	str	r2, [r0, #16]
 8008a44:	bd10      	pop	{r4, pc}
 8008a46:	bf00      	nop

08008a48 <__multiply>:
 8008a48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008a4c:	4690      	mov	r8, r2
 8008a4e:	690f      	ldr	r7, [r1, #16]
 8008a50:	460d      	mov	r5, r1
 8008a52:	6916      	ldr	r6, [r2, #16]
 8008a54:	b085      	sub	sp, #20
 8008a56:	42b7      	cmp	r7, r6
 8008a58:	bfbf      	itttt	lt
 8008a5a:	4645      	movlt	r5, r8
 8008a5c:	463a      	movlt	r2, r7
 8008a5e:	4637      	movlt	r7, r6
 8008a60:	4616      	movlt	r6, r2
 8008a62:	68ab      	ldr	r3, [r5, #8]
 8008a64:	bfb8      	it	lt
 8008a66:	4688      	movlt	r8, r1
 8008a68:	19f4      	adds	r4, r6, r7
 8008a6a:	6869      	ldr	r1, [r5, #4]
 8008a6c:	429c      	cmp	r4, r3
 8008a6e:	bfc8      	it	gt
 8008a70:	3101      	addgt	r1, #1
 8008a72:	f7ff feaf 	bl	80087d4 <_Balloc>
 8008a76:	eb00 0384 	add.w	r3, r0, r4, lsl #2
 8008a7a:	f100 0c14 	add.w	ip, r0, #20
 8008a7e:	3314      	adds	r3, #20
 8008a80:	9001      	str	r0, [sp, #4]
 8008a82:	459c      	cmp	ip, r3
 8008a84:	9302      	str	r3, [sp, #8]
 8008a86:	d206      	bcs.n	8008a96 <__multiply+0x4e>
 8008a88:	9902      	ldr	r1, [sp, #8]
 8008a8a:	4663      	mov	r3, ip
 8008a8c:	2200      	movs	r2, #0
 8008a8e:	f843 2b04 	str.w	r2, [r3], #4
 8008a92:	4299      	cmp	r1, r3
 8008a94:	d8fb      	bhi.n	8008a8e <__multiply+0x46>
 8008a96:	eb08 0686 	add.w	r6, r8, r6, lsl #2
 8008a9a:	eb05 0787 	add.w	r7, r5, r7, lsl #2
 8008a9e:	f108 0814 	add.w	r8, r8, #20
 8008aa2:	3614      	adds	r6, #20
 8008aa4:	3514      	adds	r5, #20
 8008aa6:	3714      	adds	r7, #20
 8008aa8:	45b0      	cmp	r8, r6
 8008aaa:	9500      	str	r5, [sp, #0]
 8008aac:	d24d      	bcs.n	8008b4a <__multiply+0x102>
 8008aae:	9403      	str	r4, [sp, #12]
 8008ab0:	f858 4b04 	ldr.w	r4, [r8], #4
 8008ab4:	b2a0      	uxth	r0, r4
 8008ab6:	b1f0      	cbz	r0, 8008af6 <__multiply+0xae>
 8008ab8:	9a00      	ldr	r2, [sp, #0]
 8008aba:	4663      	mov	r3, ip
 8008abc:	2400      	movs	r4, #0
 8008abe:	f852 5b04 	ldr.w	r5, [r2], #4
 8008ac2:	6819      	ldr	r1, [r3, #0]
 8008ac4:	fa1f fa85 	uxth.w	sl, r5
 8008ac8:	0c2d      	lsrs	r5, r5, #16
 8008aca:	fa1f f981 	uxth.w	r9, r1
 8008ace:	0c09      	lsrs	r1, r1, #16
 8008ad0:	fb00 990a 	mla	r9, r0, sl, r9
 8008ad4:	fb00 1105 	mla	r1, r0, r5, r1
 8008ad8:	44a1      	add	r9, r4
 8008ada:	eb01 4119 	add.w	r1, r1, r9, lsr #16
 8008ade:	fa1f f989 	uxth.w	r9, r9
 8008ae2:	0c0c      	lsrs	r4, r1, #16
 8008ae4:	4297      	cmp	r7, r2
 8008ae6:	ea49 4501 	orr.w	r5, r9, r1, lsl #16
 8008aea:	f843 5b04 	str.w	r5, [r3], #4
 8008aee:	d8e6      	bhi.n	8008abe <__multiply+0x76>
 8008af0:	601c      	str	r4, [r3, #0]
 8008af2:	f858 4c04 	ldr.w	r4, [r8, #-4]
 8008af6:	0c24      	lsrs	r4, r4, #16
 8008af8:	d021      	beq.n	8008b3e <__multiply+0xf6>
 8008afa:	f8dc 2000 	ldr.w	r2, [ip]
 8008afe:	4660      	mov	r0, ip
 8008b00:	9b00      	ldr	r3, [sp, #0]
 8008b02:	46e1      	mov	r9, ip
 8008b04:	4611      	mov	r1, r2
 8008b06:	2500      	movs	r5, #0
 8008b08:	f8b3 a000 	ldrh.w	sl, [r3]
 8008b0c:	fa1f fb82 	uxth.w	fp, r2
 8008b10:	fb0a 5504 	mla	r5, sl, r4, r5
 8008b14:	eb05 4511 	add.w	r5, r5, r1, lsr #16
 8008b18:	ea4b 4205 	orr.w	r2, fp, r5, lsl #16
 8008b1c:	f840 2b04 	str.w	r2, [r0], #4
 8008b20:	f853 2b04 	ldr.w	r2, [r3], #4
 8008b24:	f859 1f04 	ldr.w	r1, [r9, #4]!
 8008b28:	0c12      	lsrs	r2, r2, #16
 8008b2a:	fa1f fa81 	uxth.w	sl, r1
 8008b2e:	fb02 a204 	mla	r2, r2, r4, sl
 8008b32:	eb02 4215 	add.w	r2, r2, r5, lsr #16
 8008b36:	0c15      	lsrs	r5, r2, #16
 8008b38:	429f      	cmp	r7, r3
 8008b3a:	d8e5      	bhi.n	8008b08 <__multiply+0xc0>
 8008b3c:	6002      	str	r2, [r0, #0]
 8008b3e:	4546      	cmp	r6, r8
 8008b40:	d902      	bls.n	8008b48 <__multiply+0x100>
 8008b42:	f10c 0c04 	add.w	ip, ip, #4
 8008b46:	e7b3      	b.n	8008ab0 <__multiply+0x68>
 8008b48:	9c03      	ldr	r4, [sp, #12]
 8008b4a:	2c00      	cmp	r4, #0
 8008b4c:	dd0a      	ble.n	8008b64 <__multiply+0x11c>
 8008b4e:	9902      	ldr	r1, [sp, #8]
 8008b50:	1f0b      	subs	r3, r1, #4
 8008b52:	f851 2c04 	ldr.w	r2, [r1, #-4]
 8008b56:	b11a      	cbz	r2, 8008b60 <__multiply+0x118>
 8008b58:	e004      	b.n	8008b64 <__multiply+0x11c>
 8008b5a:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 8008b5e:	b90a      	cbnz	r2, 8008b64 <__multiply+0x11c>
 8008b60:	3c01      	subs	r4, #1
 8008b62:	d1fa      	bne.n	8008b5a <__multiply+0x112>
 8008b64:	9a01      	ldr	r2, [sp, #4]
 8008b66:	4610      	mov	r0, r2
 8008b68:	6114      	str	r4, [r2, #16]
 8008b6a:	b005      	add	sp, #20
 8008b6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08008b70 <__pow5mult>:
 8008b70:	f012 0303 	ands.w	r3, r2, #3
 8008b74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008b78:	4615      	mov	r5, r2
 8008b7a:	4604      	mov	r4, r0
 8008b7c:	4688      	mov	r8, r1
 8008b7e:	d128      	bne.n	8008bd2 <__pow5mult+0x62>
 8008b80:	10ad      	asrs	r5, r5, #2
 8008b82:	d01a      	beq.n	8008bba <__pow5mult+0x4a>
 8008b84:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8008b86:	2e00      	cmp	r6, #0
 8008b88:	d02f      	beq.n	8008bea <__pow5mult+0x7a>
 8008b8a:	68b7      	ldr	r7, [r6, #8]
 8008b8c:	b92f      	cbnz	r7, 8008b9a <__pow5mult+0x2a>
 8008b8e:	e036      	b.n	8008bfe <__pow5mult+0x8e>
 8008b90:	106d      	asrs	r5, r5, #1
 8008b92:	d012      	beq.n	8008bba <__pow5mult+0x4a>
 8008b94:	683e      	ldr	r6, [r7, #0]
 8008b96:	b19e      	cbz	r6, 8008bc0 <__pow5mult+0x50>
 8008b98:	4637      	mov	r7, r6
 8008b9a:	f015 0f01 	tst.w	r5, #1
 8008b9e:	d0f7      	beq.n	8008b90 <__pow5mult+0x20>
 8008ba0:	4641      	mov	r1, r8
 8008ba2:	463a      	mov	r2, r7
 8008ba4:	4620      	mov	r0, r4
 8008ba6:	f7ff ff4f 	bl	8008a48 <__multiply>
 8008baa:	4641      	mov	r1, r8
 8008bac:	4606      	mov	r6, r0
 8008bae:	4620      	mov	r0, r4
 8008bb0:	f7ff fe44 	bl	800883c <_Bfree>
 8008bb4:	106d      	asrs	r5, r5, #1
 8008bb6:	46b0      	mov	r8, r6
 8008bb8:	d1ec      	bne.n	8008b94 <__pow5mult+0x24>
 8008bba:	4640      	mov	r0, r8
 8008bbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008bc0:	4639      	mov	r1, r7
 8008bc2:	463a      	mov	r2, r7
 8008bc4:	4620      	mov	r0, r4
 8008bc6:	f7ff ff3f 	bl	8008a48 <__multiply>
 8008bca:	6038      	str	r0, [r7, #0]
 8008bcc:	4607      	mov	r7, r0
 8008bce:	6006      	str	r6, [r0, #0]
 8008bd0:	e7e3      	b.n	8008b9a <__pow5mult+0x2a>
 8008bd2:	f24b 72f0 	movw	r2, #47088	; 0xb7f0
 8008bd6:	1e5e      	subs	r6, r3, #1
 8008bd8:	f6c0 0200 	movt	r2, #2048	; 0x800
 8008bdc:	2300      	movs	r3, #0
 8008bde:	f852 2026 	ldr.w	r2, [r2, r6, lsl #2]
 8008be2:	f7ff fe47 	bl	8008874 <__multadd>
 8008be6:	4680      	mov	r8, r0
 8008be8:	e7ca      	b.n	8008b80 <__pow5mult+0x10>
 8008bea:	2010      	movs	r0, #16
 8008bec:	f7fc f844 	bl	8004c78 <malloc>
 8008bf0:	2300      	movs	r3, #0
 8008bf2:	4606      	mov	r6, r0
 8008bf4:	6260      	str	r0, [r4, #36]	; 0x24
 8008bf6:	6043      	str	r3, [r0, #4]
 8008bf8:	6083      	str	r3, [r0, #8]
 8008bfa:	6003      	str	r3, [r0, #0]
 8008bfc:	60c3      	str	r3, [r0, #12]
 8008bfe:	4620      	mov	r0, r4
 8008c00:	f240 2171 	movw	r1, #625	; 0x271
 8008c04:	f7ff ff16 	bl	8008a34 <__i2b>
 8008c08:	2300      	movs	r3, #0
 8008c0a:	60b0      	str	r0, [r6, #8]
 8008c0c:	4607      	mov	r7, r0
 8008c0e:	6003      	str	r3, [r0, #0]
 8008c10:	e7c3      	b.n	8008b9a <__pow5mult+0x2a>
 8008c12:	bf00      	nop

08008c14 <__lshift>:
 8008c14:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008c18:	1156      	asrs	r6, r2, #5
 8008c1a:	690d      	ldr	r5, [r1, #16]
 8008c1c:	460c      	mov	r4, r1
 8008c1e:	688b      	ldr	r3, [r1, #8]
 8008c20:	4690      	mov	r8, r2
 8008c22:	3501      	adds	r5, #1
 8008c24:	4681      	mov	r9, r0
 8008c26:	19ad      	adds	r5, r5, r6
 8008c28:	6849      	ldr	r1, [r1, #4]
 8008c2a:	429d      	cmp	r5, r3
 8008c2c:	dd03      	ble.n	8008c36 <__lshift+0x22>
 8008c2e:	005b      	lsls	r3, r3, #1
 8008c30:	3101      	adds	r1, #1
 8008c32:	429d      	cmp	r5, r3
 8008c34:	dcfb      	bgt.n	8008c2e <__lshift+0x1a>
 8008c36:	4648      	mov	r0, r9
 8008c38:	f7ff fdcc 	bl	80087d4 <_Balloc>
 8008c3c:	2e00      	cmp	r6, #0
 8008c3e:	4607      	mov	r7, r0
 8008c40:	f100 0214 	add.w	r2, r0, #20
 8008c44:	dd0a      	ble.n	8008c5c <__lshift+0x48>
 8008c46:	2300      	movs	r3, #0
 8008c48:	4619      	mov	r1, r3
 8008c4a:	3301      	adds	r3, #1
 8008c4c:	f842 1b04 	str.w	r1, [r2], #4
 8008c50:	42b3      	cmp	r3, r6
 8008c52:	d1fa      	bne.n	8008c4a <__lshift+0x36>
 8008c54:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 8008c58:	f103 0214 	add.w	r2, r3, #20
 8008c5c:	6926      	ldr	r6, [r4, #16]
 8008c5e:	f104 0114 	add.w	r1, r4, #20
 8008c62:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 8008c66:	3614      	adds	r6, #20
 8008c68:	f018 081f 	ands.w	r8, r8, #31
 8008c6c:	d01a      	beq.n	8008ca4 <__lshift+0x90>
 8008c6e:	f1c8 0e20 	rsb	lr, r8, #32
 8008c72:	2000      	movs	r0, #0
 8008c74:	680b      	ldr	r3, [r1, #0]
 8008c76:	fa03 f308 	lsl.w	r3, r3, r8
 8008c7a:	4318      	orrs	r0, r3
 8008c7c:	f842 0b04 	str.w	r0, [r2], #4
 8008c80:	f851 0b04 	ldr.w	r0, [r1], #4
 8008c84:	428e      	cmp	r6, r1
 8008c86:	fa20 f00e 	lsr.w	r0, r0, lr
 8008c8a:	d8f3      	bhi.n	8008c74 <__lshift+0x60>
 8008c8c:	6010      	str	r0, [r2, #0]
 8008c8e:	b100      	cbz	r0, 8008c92 <__lshift+0x7e>
 8008c90:	3501      	adds	r5, #1
 8008c92:	4648      	mov	r0, r9
 8008c94:	3d01      	subs	r5, #1
 8008c96:	4621      	mov	r1, r4
 8008c98:	613d      	str	r5, [r7, #16]
 8008c9a:	f7ff fdcf 	bl	800883c <_Bfree>
 8008c9e:	4638      	mov	r0, r7
 8008ca0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8008ca4:	f851 3b04 	ldr.w	r3, [r1], #4
 8008ca8:	428e      	cmp	r6, r1
 8008caa:	f842 3b04 	str.w	r3, [r2], #4
 8008cae:	d9f0      	bls.n	8008c92 <__lshift+0x7e>
 8008cb0:	f851 3b04 	ldr.w	r3, [r1], #4
 8008cb4:	428e      	cmp	r6, r1
 8008cb6:	f842 3b04 	str.w	r3, [r2], #4
 8008cba:	d8f3      	bhi.n	8008ca4 <__lshift+0x90>
 8008cbc:	e7e9      	b.n	8008c92 <__lshift+0x7e>
 8008cbe:	bf00      	nop

08008cc0 <__mcmp>:
 8008cc0:	4603      	mov	r3, r0
 8008cc2:	690a      	ldr	r2, [r1, #16]
 8008cc4:	6900      	ldr	r0, [r0, #16]
 8008cc6:	b430      	push	{r4, r5}
 8008cc8:	1a80      	subs	r0, r0, r2
 8008cca:	d10f      	bne.n	8008cec <__mcmp+0x2c>
 8008ccc:	3204      	adds	r2, #4
 8008cce:	f103 0514 	add.w	r5, r3, #20
 8008cd2:	0092      	lsls	r2, r2, #2
 8008cd4:	189b      	adds	r3, r3, r2
 8008cd6:	1889      	adds	r1, r1, r2
 8008cd8:	3304      	adds	r3, #4
 8008cda:	3104      	adds	r1, #4
 8008cdc:	f853 4d04 	ldr.w	r4, [r3, #-4]!
 8008ce0:	f851 2d04 	ldr.w	r2, [r1, #-4]!
 8008ce4:	4294      	cmp	r4, r2
 8008ce6:	d103      	bne.n	8008cf0 <__mcmp+0x30>
 8008ce8:	429d      	cmp	r5, r3
 8008cea:	d3f7      	bcc.n	8008cdc <__mcmp+0x1c>
 8008cec:	bc30      	pop	{r4, r5}
 8008cee:	4770      	bx	lr
 8008cf0:	bf38      	it	cc
 8008cf2:	f04f 30ff 	movcc.w	r0, #4294967295
 8008cf6:	d3f9      	bcc.n	8008cec <__mcmp+0x2c>
 8008cf8:	2001      	movs	r0, #1
 8008cfa:	e7f7      	b.n	8008cec <__mcmp+0x2c>

08008cfc <__mdiff>:
 8008cfc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008d00:	4689      	mov	r9, r1
 8008d02:	4604      	mov	r4, r0
 8008d04:	4611      	mov	r1, r2
 8008d06:	4648      	mov	r0, r9
 8008d08:	4690      	mov	r8, r2
 8008d0a:	f7ff ffd9 	bl	8008cc0 <__mcmp>
 8008d0e:	1e05      	subs	r5, r0, #0
 8008d10:	d064      	beq.n	8008ddc <__mdiff+0xe0>
 8008d12:	bfbc      	itt	lt
 8008d14:	464b      	movlt	r3, r9
 8008d16:	46c1      	movlt	r9, r8
 8008d18:	4620      	mov	r0, r4
 8008d1a:	bfb8      	it	lt
 8008d1c:	4698      	movlt	r8, r3
 8008d1e:	f8d9 1004 	ldr.w	r1, [r9, #4]
 8008d22:	bfac      	ite	ge
 8008d24:	f04f 0a00 	movge.w	sl, #0
 8008d28:	f04f 0a01 	movlt.w	sl, #1
 8008d2c:	f7ff fd52 	bl	80087d4 <_Balloc>
 8008d30:	f8d9 6010 	ldr.w	r6, [r9, #16]
 8008d34:	f109 0514 	add.w	r5, r9, #20
 8008d38:	f8d8 3010 	ldr.w	r3, [r8, #16]
 8008d3c:	f108 0714 	add.w	r7, r8, #20
 8008d40:	2400      	movs	r4, #0
 8008d42:	eb09 0986 	add.w	r9, r9, r6, lsl #2
 8008d46:	f109 0914 	add.w	r9, r9, #20
 8008d4a:	4683      	mov	fp, r0
 8008d4c:	3014      	adds	r0, #20
 8008d4e:	f8cb a00c 	str.w	sl, [fp, #12]
 8008d52:	eb08 0a83 	add.w	sl, r8, r3, lsl #2
 8008d56:	f10a 0a14 	add.w	sl, sl, #20
 8008d5a:	f855 1b04 	ldr.w	r1, [r5], #4
 8008d5e:	4603      	mov	r3, r0
 8008d60:	f857 0b04 	ldr.w	r0, [r7], #4
 8008d64:	462a      	mov	r2, r5
 8008d66:	fa1f f881 	uxth.w	r8, r1
 8008d6a:	fa1f fc80 	uxth.w	ip, r0
 8008d6e:	0c00      	lsrs	r0, r0, #16
 8008d70:	ebcc 0c08 	rsb	ip, ip, r8
 8008d74:	ebc0 4011 	rsb	r0, r0, r1, lsr #16
 8008d78:	4464      	add	r4, ip
 8008d7a:	eb00 4024 	add.w	r0, r0, r4, asr #16
 8008d7e:	b2a4      	uxth	r4, r4
 8008d80:	ea44 4100 	orr.w	r1, r4, r0, lsl #16
 8008d84:	1404      	asrs	r4, r0, #16
 8008d86:	45ba      	cmp	sl, r7
 8008d88:	f843 1b04 	str.w	r1, [r3], #4
 8008d8c:	4618      	mov	r0, r3
 8008d8e:	d8e4      	bhi.n	8008d5a <__mdiff+0x5e>
 8008d90:	45a9      	cmp	r9, r5
 8008d92:	461f      	mov	r7, r3
 8008d94:	d914      	bls.n	8008dc0 <__mdiff+0xc4>
 8008d96:	f852 1b04 	ldr.w	r1, [r2], #4
 8008d9a:	b288      	uxth	r0, r1
 8008d9c:	0c09      	lsrs	r1, r1, #16
 8008d9e:	1824      	adds	r4, r4, r0
 8008da0:	eb01 4124 	add.w	r1, r1, r4, asr #16
 8008da4:	b2a4      	uxth	r4, r4
 8008da6:	ea44 4001 	orr.w	r0, r4, r1, lsl #16
 8008daa:	140c      	asrs	r4, r1, #16
 8008dac:	4591      	cmp	r9, r2
 8008dae:	f843 0b04 	str.w	r0, [r3], #4
 8008db2:	d8f0      	bhi.n	8008d96 <__mdiff+0x9a>
 8008db4:	43eb      	mvns	r3, r5
 8008db6:	444b      	add	r3, r9
 8008db8:	f023 0303 	bic.w	r3, r3, #3
 8008dbc:	3304      	adds	r3, #4
 8008dbe:	18fb      	adds	r3, r7, r3
 8008dc0:	f853 2c04 	ldr.w	r2, [r3, #-4]
 8008dc4:	3b04      	subs	r3, #4
 8008dc6:	b922      	cbnz	r2, 8008dd2 <__mdiff+0xd6>
 8008dc8:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 8008dcc:	3e01      	subs	r6, #1
 8008dce:	2a00      	cmp	r2, #0
 8008dd0:	d0fa      	beq.n	8008dc8 <__mdiff+0xcc>
 8008dd2:	f8cb 6010 	str.w	r6, [fp, #16]
 8008dd6:	4658      	mov	r0, fp
 8008dd8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008ddc:	4620      	mov	r0, r4
 8008dde:	4629      	mov	r1, r5
 8008de0:	f7ff fcf8 	bl	80087d4 <_Balloc>
 8008de4:	2301      	movs	r3, #1
 8008de6:	4683      	mov	fp, r0
 8008de8:	6145      	str	r5, [r0, #20]
 8008dea:	6103      	str	r3, [r0, #16]
 8008dec:	4658      	mov	r0, fp
 8008dee:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008df2:	bf00      	nop

08008df4 <__ulp>:
 8008df4:	2300      	movs	r3, #0
 8008df6:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 8008dfa:	ea01 0303 	and.w	r3, r1, r3
 8008dfe:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
 8008e02:	2b00      	cmp	r3, #0
 8008e04:	dd02      	ble.n	8008e0c <__ulp+0x18>
 8008e06:	4619      	mov	r1, r3
 8008e08:	2000      	movs	r0, #0
 8008e0a:	4770      	bx	lr
 8008e0c:	425b      	negs	r3, r3
 8008e0e:	151b      	asrs	r3, r3, #20
 8008e10:	2b13      	cmp	r3, #19
 8008e12:	dd0d      	ble.n	8008e30 <__ulp+0x3c>
 8008e14:	3b14      	subs	r3, #20
 8008e16:	2100      	movs	r1, #0
 8008e18:	2b1e      	cmp	r3, #30
 8008e1a:	dd02      	ble.n	8008e22 <__ulp+0x2e>
 8008e1c:	2301      	movs	r3, #1
 8008e1e:	4618      	mov	r0, r3
 8008e20:	4770      	bx	lr
 8008e22:	2201      	movs	r2, #1
 8008e24:	f1c3 031f 	rsb	r3, r3, #31
 8008e28:	fa12 f303 	lsls.w	r3, r2, r3
 8008e2c:	4618      	mov	r0, r3
 8008e2e:	4770      	bx	lr
 8008e30:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8008e34:	2000      	movs	r0, #0
 8008e36:	fa52 f103 	asrs.w	r1, r2, r3
 8008e3a:	4770      	bx	lr

08008e3c <__b2d>:
 8008e3c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008e40:	f100 0614 	add.w	r6, r0, #20
 8008e44:	6904      	ldr	r4, [r0, #16]
 8008e46:	460f      	mov	r7, r1
 8008e48:	3404      	adds	r4, #4
 8008e4a:	f850 5024 	ldr.w	r5, [r0, r4, lsl #2]
 8008e4e:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 8008e52:	46a0      	mov	r8, r4
 8008e54:	4628      	mov	r0, r5
 8008e56:	f7ff fd9b 	bl	8008990 <__hi0bits>
 8008e5a:	280a      	cmp	r0, #10
 8008e5c:	f1c0 0320 	rsb	r3, r0, #32
 8008e60:	603b      	str	r3, [r7, #0]
 8008e62:	dc15      	bgt.n	8008e90 <__b2d+0x54>
 8008e64:	f1c0 010b 	rsb	r1, r0, #11
 8008e68:	fa35 f701 	lsrs.w	r7, r5, r1
 8008e6c:	42a6      	cmp	r6, r4
 8008e6e:	f047 577e 	orr.w	r7, r7, #1065353216	; 0x3f800000
 8008e72:	f447 03e0 	orr.w	r3, r7, #7340032	; 0x700000
 8008e76:	d233      	bcs.n	8008ee0 <__b2d+0xa4>
 8008e78:	f854 4c04 	ldr.w	r4, [r4, #-4]
 8008e7c:	fa34 f101 	lsrs.w	r1, r4, r1
 8008e80:	3015      	adds	r0, #21
 8008e82:	4085      	lsls	r5, r0
 8008e84:	ea41 0205 	orr.w	r2, r1, r5
 8008e88:	4610      	mov	r0, r2
 8008e8a:	4619      	mov	r1, r3
 8008e8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008e90:	42a6      	cmp	r6, r4
 8008e92:	d321      	bcc.n	8008ed8 <__b2d+0x9c>
 8008e94:	2100      	movs	r1, #0
 8008e96:	380b      	subs	r0, #11
 8008e98:	bf02      	ittt	eq
 8008e9a:	f045 557e 	orreq.w	r5, r5, #1065353216	; 0x3f800000
 8008e9e:	460a      	moveq	r2, r1
 8008ea0:	f445 03e0 	orreq.w	r3, r5, #7340032	; 0x700000
 8008ea4:	d0f0      	beq.n	8008e88 <__b2d+0x4c>
 8008ea6:	4085      	lsls	r5, r0
 8008ea8:	f1c0 0720 	rsb	r7, r0, #32
 8008eac:	f045 557e 	orr.w	r5, r5, #1065353216	; 0x3f800000
 8008eb0:	42b4      	cmp	r4, r6
 8008eb2:	fa21 fc07 	lsr.w	ip, r1, r7
 8008eb6:	f445 05e0 	orr.w	r5, r5, #7340032	; 0x700000
 8008eba:	ea45 030c 	orr.w	r3, r5, ip
 8008ebe:	d911      	bls.n	8008ee4 <__b2d+0xa8>
 8008ec0:	f854 4c04 	ldr.w	r4, [r4, #-4]
 8008ec4:	fa34 f707 	lsrs.w	r7, r4, r7
 8008ec8:	fa11 f000 	lsls.w	r0, r1, r0
 8008ecc:	4619      	mov	r1, r3
 8008ece:	ea47 0200 	orr.w	r2, r7, r0
 8008ed2:	4610      	mov	r0, r2
 8008ed4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008ed8:	3c04      	subs	r4, #4
 8008eda:	f858 1c04 	ldr.w	r1, [r8, #-4]
 8008ede:	e7da      	b.n	8008e96 <__b2d+0x5a>
 8008ee0:	2100      	movs	r1, #0
 8008ee2:	e7cd      	b.n	8008e80 <__b2d+0x44>
 8008ee4:	2700      	movs	r7, #0
 8008ee6:	e7ef      	b.n	8008ec8 <__b2d+0x8c>

08008ee8 <__d2b>:
 8008ee8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008eec:	b083      	sub	sp, #12
 8008eee:	2101      	movs	r1, #1
 8008ef0:	461d      	mov	r5, r3
 8008ef2:	4614      	mov	r4, r2
 8008ef4:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8008ef6:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 8008ef8:	f7ff fc6c 	bl	80087d4 <_Balloc>
 8008efc:	f3c5 590a 	ubfx	r9, r5, #20, #11
 8008f00:	f025 437f 	bic.w	r3, r5, #4278190080	; 0xff000000
 8008f04:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 8008f08:	9300      	str	r3, [sp, #0]
 8008f0a:	4680      	mov	r8, r0
 8008f0c:	f1b9 0f00 	cmp.w	r9, #0
 8008f10:	d002      	beq.n	8008f18 <__d2b+0x30>
 8008f12:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8008f16:	9300      	str	r3, [sp, #0]
 8008f18:	2c00      	cmp	r4, #0
 8008f1a:	d025      	beq.n	8008f68 <__d2b+0x80>
 8008f1c:	a802      	add	r0, sp, #8
 8008f1e:	f840 4d04 	str.w	r4, [r0, #-4]!
 8008f22:	f7ff fd55 	bl	80089d0 <__lo0bits>
 8008f26:	2800      	cmp	r0, #0
 8008f28:	d136      	bne.n	8008f98 <__d2b+0xb0>
 8008f2a:	9a01      	ldr	r2, [sp, #4]
 8008f2c:	9b00      	ldr	r3, [sp, #0]
 8008f2e:	f8c8 2014 	str.w	r2, [r8, #20]
 8008f32:	2b00      	cmp	r3, #0
 8008f34:	bf0c      	ite	eq
 8008f36:	2401      	moveq	r4, #1
 8008f38:	2402      	movne	r4, #2
 8008f3a:	f8c8 3018 	str.w	r3, [r8, #24]
 8008f3e:	f8c8 4010 	str.w	r4, [r8, #16]
 8008f42:	f1b9 0f00 	cmp.w	r9, #0
 8008f46:	d11d      	bne.n	8008f84 <__d2b+0x9c>
 8008f48:	eb08 0384 	add.w	r3, r8, r4, lsl #2
 8008f4c:	f5a0 6086 	sub.w	r0, r0, #1072	; 0x430
 8008f50:	3802      	subs	r0, #2
 8008f52:	6038      	str	r0, [r7, #0]
 8008f54:	6918      	ldr	r0, [r3, #16]
 8008f56:	0164      	lsls	r4, r4, #5
 8008f58:	f7ff fd1a 	bl	8008990 <__hi0bits>
 8008f5c:	1a24      	subs	r4, r4, r0
 8008f5e:	6034      	str	r4, [r6, #0]
 8008f60:	4640      	mov	r0, r8
 8008f62:	b003      	add	sp, #12
 8008f64:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8008f68:	4668      	mov	r0, sp
 8008f6a:	f7ff fd31 	bl	80089d0 <__lo0bits>
 8008f6e:	2301      	movs	r3, #1
 8008f70:	461c      	mov	r4, r3
 8008f72:	f8c8 3010 	str.w	r3, [r8, #16]
 8008f76:	9b00      	ldr	r3, [sp, #0]
 8008f78:	f8c8 3014 	str.w	r3, [r8, #20]
 8008f7c:	3020      	adds	r0, #32
 8008f7e:	f1b9 0f00 	cmp.w	r9, #0
 8008f82:	d0e1      	beq.n	8008f48 <__d2b+0x60>
 8008f84:	f5a9 6986 	sub.w	r9, r9, #1072	; 0x430
 8008f88:	f1c0 0335 	rsb	r3, r0, #53	; 0x35
 8008f8c:	f1a9 0903 	sub.w	r9, r9, #3
 8008f90:	4448      	add	r0, r9
 8008f92:	6038      	str	r0, [r7, #0]
 8008f94:	6033      	str	r3, [r6, #0]
 8008f96:	e7e3      	b.n	8008f60 <__d2b+0x78>
 8008f98:	9b00      	ldr	r3, [sp, #0]
 8008f9a:	f1c0 0220 	rsb	r2, r0, #32
 8008f9e:	9901      	ldr	r1, [sp, #4]
 8008fa0:	fa13 f202 	lsls.w	r2, r3, r2
 8008fa4:	40c3      	lsrs	r3, r0
 8008fa6:	430a      	orrs	r2, r1
 8008fa8:	9300      	str	r3, [sp, #0]
 8008faa:	f8c8 2014 	str.w	r2, [r8, #20]
 8008fae:	e7c0      	b.n	8008f32 <__d2b+0x4a>

08008fb0 <__ratio>:
 8008fb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008fb4:	b082      	sub	sp, #8
 8008fb6:	4688      	mov	r8, r1
 8008fb8:	a901      	add	r1, sp, #4
 8008fba:	4606      	mov	r6, r0
 8008fbc:	f7ff ff3e 	bl	8008e3c <__b2d>
 8008fc0:	460d      	mov	r5, r1
 8008fc2:	4604      	mov	r4, r0
 8008fc4:	4669      	mov	r1, sp
 8008fc6:	4640      	mov	r0, r8
 8008fc8:	f7ff ff38 	bl	8008e3c <__b2d>
 8008fcc:	f8d8 e010 	ldr.w	lr, [r8, #16]
 8008fd0:	f8d6 c010 	ldr.w	ip, [r6, #16]
 8008fd4:	f8dd 8004 	ldr.w	r8, [sp, #4]
 8008fd8:	ebce 0c0c 	rsb	ip, lr, ip
 8008fdc:	f8dd e000 	ldr.w	lr, [sp]
 8008fe0:	ea4f 1c4c 	mov.w	ip, ip, lsl #5
 8008fe4:	ebce 0e08 	rsb	lr, lr, r8
 8008fe8:	44e6      	add	lr, ip
 8008fea:	f1be 0f00 	cmp.w	lr, #0
 8008fee:	ea4f 5e0e 	mov.w	lr, lr, lsl #20
 8008ff2:	bfc4      	itt	gt
 8008ff4:	eb0e 0705 	addgt.w	r7, lr, r5
 8008ff8:	463d      	movgt	r5, r7
 8008ffa:	460b      	mov	r3, r1
 8008ffc:	bfd8      	it	le
 8008ffe:	ebce 0101 	rsble	r1, lr, r1
 8009002:	4602      	mov	r2, r0
 8009004:	bfdc      	itt	le
 8009006:	460b      	movle	r3, r1
 8009008:	4602      	movle	r2, r0
 800900a:	4629      	mov	r1, r5
 800900c:	4620      	mov	r0, r4
 800900e:	f001 fe33 	bl	800ac78 <__aeabi_ddiv>
 8009012:	b002      	add	sp, #8
 8009014:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08009018 <_mprec_log10>:
 8009018:	2817      	cmp	r0, #23
 800901a:	b510      	push	{r4, lr}
 800901c:	4604      	mov	r4, r0
 800901e:	dd0c      	ble.n	800903a <_mprec_log10+0x22>
 8009020:	2100      	movs	r1, #0
 8009022:	2000      	movs	r0, #0
 8009024:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
 8009028:	2300      	movs	r3, #0
 800902a:	2200      	movs	r2, #0
 800902c:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8009030:	f001 fcf8 	bl	800aa24 <__aeabi_dmul>
 8009034:	3c01      	subs	r4, #1
 8009036:	d1f7      	bne.n	8009028 <_mprec_log10+0x10>
 8009038:	bd10      	pop	{r4, pc}
 800903a:	f24b 73f0 	movw	r3, #47088	; 0xb7f0
 800903e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8009042:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 8009046:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800904a:	bd10      	pop	{r4, pc}

0800904c <__copybits>:
 800904c:	b470      	push	{r4, r5, r6}
 800904e:	3901      	subs	r1, #1
 8009050:	6916      	ldr	r6, [r2, #16]
 8009052:	f102 0314 	add.w	r3, r2, #20
 8009056:	1149      	asrs	r1, r1, #5
 8009058:	3101      	adds	r1, #1
 800905a:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 800905e:	3614      	adds	r6, #20
 8009060:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8009064:	42b3      	cmp	r3, r6
 8009066:	d20c      	bcs.n	8009082 <__copybits+0x36>
 8009068:	4604      	mov	r4, r0
 800906a:	f853 5b04 	ldr.w	r5, [r3], #4
 800906e:	429e      	cmp	r6, r3
 8009070:	f844 5b04 	str.w	r5, [r4], #4
 8009074:	d8f9      	bhi.n	800906a <__copybits+0x1e>
 8009076:	1ab3      	subs	r3, r6, r2
 8009078:	3b15      	subs	r3, #21
 800907a:	f023 0303 	bic.w	r3, r3, #3
 800907e:	3304      	adds	r3, #4
 8009080:	18c0      	adds	r0, r0, r3
 8009082:	4281      	cmp	r1, r0
 8009084:	d904      	bls.n	8009090 <__copybits+0x44>
 8009086:	2300      	movs	r3, #0
 8009088:	f840 3b04 	str.w	r3, [r0], #4
 800908c:	4281      	cmp	r1, r0
 800908e:	d8fb      	bhi.n	8009088 <__copybits+0x3c>
 8009090:	bc70      	pop	{r4, r5, r6}
 8009092:	4770      	bx	lr

08009094 <__any_on>:
 8009094:	6902      	ldr	r2, [r0, #16]
 8009096:	114b      	asrs	r3, r1, #5
 8009098:	b410      	push	{r4}
 800909a:	429a      	cmp	r2, r3
 800909c:	db11      	blt.n	80090c2 <__any_on+0x2e>
 800909e:	dd0f      	ble.n	80090c0 <__any_on+0x2c>
 80090a0:	f011 011f 	ands.w	r1, r1, #31
 80090a4:	d00c      	beq.n	80090c0 <__any_on+0x2c>
 80090a6:	461a      	mov	r2, r3
 80090a8:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80090ac:	695b      	ldr	r3, [r3, #20]
 80090ae:	fa33 f401 	lsrs.w	r4, r3, r1
 80090b2:	fa14 f101 	lsls.w	r1, r4, r1
 80090b6:	4299      	cmp	r1, r3
 80090b8:	d003      	beq.n	80090c2 <__any_on+0x2e>
 80090ba:	2001      	movs	r0, #1
 80090bc:	bc10      	pop	{r4}
 80090be:	4770      	bx	lr
 80090c0:	461a      	mov	r2, r3
 80090c2:	3204      	adds	r2, #4
 80090c4:	f100 0114 	add.w	r1, r0, #20
 80090c8:	eb00 0382 	add.w	r3, r0, r2, lsl #2
 80090cc:	1d1c      	adds	r4, r3, #4
 80090ce:	42a1      	cmp	r1, r4
 80090d0:	d20b      	bcs.n	80090ea <__any_on+0x56>
 80090d2:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 80090d6:	2a00      	cmp	r2, #0
 80090d8:	d1ef      	bne.n	80090ba <__any_on+0x26>
 80090da:	4299      	cmp	r1, r3
 80090dc:	d205      	bcs.n	80090ea <__any_on+0x56>
 80090de:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 80090e2:	2a00      	cmp	r2, #0
 80090e4:	d1e9      	bne.n	80090ba <__any_on+0x26>
 80090e6:	4299      	cmp	r1, r3
 80090e8:	d3f9      	bcc.n	80090de <__any_on+0x4a>
 80090ea:	2000      	movs	r0, #0
 80090ec:	e7e6      	b.n	80090bc <__any_on+0x28>
 80090ee:	bf00      	nop

080090f0 <_read_r>:
 80090f0:	b538      	push	{r3, r4, r5, lr}
 80090f2:	f641 24e4 	movw	r4, #6884	; 0x1ae4
 80090f6:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80090fa:	4605      	mov	r5, r0
 80090fc:	4608      	mov	r0, r1
 80090fe:	4611      	mov	r1, r2
 8009100:	461a      	mov	r2, r3
 8009102:	2300      	movs	r3, #0
 8009104:	6023      	str	r3, [r4, #0]
 8009106:	f7f7 fc57 	bl	80009b8 <_read>
 800910a:	f1b0 3fff 	cmp.w	r0, #4294967295
 800910e:	d000      	beq.n	8009112 <_read_r+0x22>
 8009110:	bd38      	pop	{r3, r4, r5, pc}
 8009112:	6823      	ldr	r3, [r4, #0]
 8009114:	2b00      	cmp	r3, #0
 8009116:	d0fb      	beq.n	8009110 <_read_r+0x20>
 8009118:	602b      	str	r3, [r5, #0]
 800911a:	bd38      	pop	{r3, r4, r5, pc}

0800911c <cleanup_glue>:
 800911c:	b570      	push	{r4, r5, r6, lr}
 800911e:	460c      	mov	r4, r1
 8009120:	6809      	ldr	r1, [r1, #0]
 8009122:	4605      	mov	r5, r0
 8009124:	b109      	cbz	r1, 800912a <cleanup_glue+0xe>
 8009126:	f7ff fff9 	bl	800911c <cleanup_glue>
 800912a:	4628      	mov	r0, r5
 800912c:	4621      	mov	r1, r4
 800912e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8009132:	f7fc bc93 	b.w	8005a5c <_free_r>
 8009136:	bf00      	nop

08009138 <_reclaim_reent>:
 8009138:	f240 236c 	movw	r3, #620	; 0x26c
 800913c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009140:	b570      	push	{r4, r5, r6, lr}
 8009142:	4605      	mov	r5, r0
 8009144:	681b      	ldr	r3, [r3, #0]
 8009146:	4298      	cmp	r0, r3
 8009148:	d04a      	beq.n	80091e0 <_reclaim_reent+0xa8>
 800914a:	6a42      	ldr	r2, [r0, #36]	; 0x24
 800914c:	b302      	cbz	r2, 8009190 <_reclaim_reent+0x58>
 800914e:	68d3      	ldr	r3, [r2, #12]
 8009150:	b1cb      	cbz	r3, 8009186 <_reclaim_reent+0x4e>
 8009152:	2100      	movs	r1, #0
 8009154:	460e      	mov	r6, r1
 8009156:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 800915a:	b909      	cbnz	r1, 8009160 <_reclaim_reent+0x28>
 800915c:	e008      	b.n	8009170 <_reclaim_reent+0x38>
 800915e:	4621      	mov	r1, r4
 8009160:	680c      	ldr	r4, [r1, #0]
 8009162:	4628      	mov	r0, r5
 8009164:	f7fc fc7a 	bl	8005a5c <_free_r>
 8009168:	2c00      	cmp	r4, #0
 800916a:	d1f8      	bne.n	800915e <_reclaim_reent+0x26>
 800916c:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800916e:	68d3      	ldr	r3, [r2, #12]
 8009170:	3601      	adds	r6, #1
 8009172:	2e20      	cmp	r6, #32
 8009174:	4631      	mov	r1, r6
 8009176:	d001      	beq.n	800917c <_reclaim_reent+0x44>
 8009178:	68d3      	ldr	r3, [r2, #12]
 800917a:	e7ec      	b.n	8009156 <_reclaim_reent+0x1e>
 800917c:	4628      	mov	r0, r5
 800917e:	4619      	mov	r1, r3
 8009180:	f7fc fc6c 	bl	8005a5c <_free_r>
 8009184:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8009186:	6811      	ldr	r1, [r2, #0]
 8009188:	b111      	cbz	r1, 8009190 <_reclaim_reent+0x58>
 800918a:	4628      	mov	r0, r5
 800918c:	f7fc fc66 	bl	8005a5c <_free_r>
 8009190:	6969      	ldr	r1, [r5, #20]
 8009192:	b111      	cbz	r1, 800919a <_reclaim_reent+0x62>
 8009194:	4628      	mov	r0, r5
 8009196:	f7fc fc61 	bl	8005a5c <_free_r>
 800919a:	6a69      	ldr	r1, [r5, #36]	; 0x24
 800919c:	b111      	cbz	r1, 80091a4 <_reclaim_reent+0x6c>
 800919e:	4628      	mov	r0, r5
 80091a0:	f7fc fc5c 	bl	8005a5c <_free_r>
 80091a4:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 80091a6:	b111      	cbz	r1, 80091ae <_reclaim_reent+0x76>
 80091a8:	4628      	mov	r0, r5
 80091aa:	f7fc fc57 	bl	8005a5c <_free_r>
 80091ae:	6be9      	ldr	r1, [r5, #60]	; 0x3c
 80091b0:	b111      	cbz	r1, 80091b8 <_reclaim_reent+0x80>
 80091b2:	4628      	mov	r0, r5
 80091b4:	f7fc fc52 	bl	8005a5c <_free_r>
 80091b8:	6c29      	ldr	r1, [r5, #64]	; 0x40
 80091ba:	b111      	cbz	r1, 80091c2 <_reclaim_reent+0x8a>
 80091bc:	4628      	mov	r0, r5
 80091be:	f7fc fc4d 	bl	8005a5c <_free_r>
 80091c2:	6cab      	ldr	r3, [r5, #72]	; 0x48
 80091c4:	b12b      	cbz	r3, 80091d2 <_reclaim_reent+0x9a>
 80091c6:	f8d3 1088 	ldr.w	r1, [r3, #136]	; 0x88
 80091ca:	b111      	cbz	r1, 80091d2 <_reclaim_reent+0x9a>
 80091cc:	4628      	mov	r0, r5
 80091ce:	f7fc fc45 	bl	8005a5c <_free_r>
 80091d2:	6b69      	ldr	r1, [r5, #52]	; 0x34
 80091d4:	b111      	cbz	r1, 80091dc <_reclaim_reent+0xa4>
 80091d6:	4628      	mov	r0, r5
 80091d8:	f7fc fc40 	bl	8005a5c <_free_r>
 80091dc:	69ab      	ldr	r3, [r5, #24]
 80091de:	b903      	cbnz	r3, 80091e2 <_reclaim_reent+0xaa>
 80091e0:	bd70      	pop	{r4, r5, r6, pc}
 80091e2:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80091e4:	4628      	mov	r0, r5
 80091e6:	4798      	blx	r3
 80091e8:	f8d5 10d8 	ldr.w	r1, [r5, #216]	; 0xd8
 80091ec:	2900      	cmp	r1, #0
 80091ee:	d0f7      	beq.n	80091e0 <_reclaim_reent+0xa8>
 80091f0:	4628      	mov	r0, r5
 80091f2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80091f6:	e791      	b.n	800911c <cleanup_glue>

080091f8 <_wrapup_reent>:
 80091f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80091fa:	4607      	mov	r7, r0
 80091fc:	b198      	cbz	r0, 8009226 <_wrapup_reent+0x2e>
 80091fe:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8009200:	b163      	cbz	r3, 800921c <_wrapup_reent+0x24>
 8009202:	685e      	ldr	r6, [r3, #4]
 8009204:	2e00      	cmp	r6, #0
 8009206:	dd09      	ble.n	800921c <_wrapup_reent+0x24>
 8009208:	1cb5      	adds	r5, r6, #2
 800920a:	2400      	movs	r4, #0
 800920c:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8009210:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 8009214:	3401      	adds	r4, #1
 8009216:	4798      	blx	r3
 8009218:	42b4      	cmp	r4, r6
 800921a:	d1f9      	bne.n	8009210 <_wrapup_reent+0x18>
 800921c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800921e:	b10b      	cbz	r3, 8009224 <_wrapup_reent+0x2c>
 8009220:	4638      	mov	r0, r7
 8009222:	4798      	blx	r3
 8009224:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009226:	f240 236c 	movw	r3, #620	; 0x26c
 800922a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800922e:	681f      	ldr	r7, [r3, #0]
 8009230:	e7e5      	b.n	80091fe <_wrapup_reent+0x6>
 8009232:	bf00      	nop

08009234 <__fpclassifyd>:
 8009234:	ea50 0301 	orrs.w	r3, r0, r1
 8009238:	b410      	push	{r4}
 800923a:	d03c      	beq.n	80092b6 <__fpclassifyd+0x82>
 800923c:	f1d0 0201 	rsbs	r2, r0, #1
 8009240:	bf38      	it	cc
 8009242:	2200      	movcc	r2, #0
 8009244:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 8009248:	bf14      	ite	ne
 800924a:	2300      	movne	r3, #0
 800924c:	f002 0301 	andeq.w	r3, r2, #1
 8009250:	2b00      	cmp	r3, #0
 8009252:	d130      	bne.n	80092b6 <__fpclassifyd+0x82>
 8009254:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009258:	f5a1 1080 	sub.w	r0, r1, #1048576	; 0x100000
 800925c:	f6c7 73df 	movt	r3, #32735	; 0x7fdf
 8009260:	f101 44fe 	add.w	r4, r1, #2130706432	; 0x7f000000
 8009264:	4298      	cmp	r0, r3
 8009266:	f504 0470 	add.w	r4, r4, #15728640	; 0xf00000
 800926a:	bf8c      	ite	hi
 800926c:	2000      	movhi	r0, #0
 800926e:	2001      	movls	r0, #1
 8009270:	429c      	cmp	r4, r3
 8009272:	bf8c      	ite	hi
 8009274:	4603      	movhi	r3, r0
 8009276:	f040 0301 	orrls.w	r3, r0, #1
 800927a:	2b00      	cmp	r3, #0
 800927c:	d120      	bne.n	80092c0 <__fpclassifyd+0x8c>
 800927e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8009282:	f101 4000 	add.w	r0, r1, #2147483648	; 0x80000000
 8009286:	bf2c      	ite	cs
 8009288:	2300      	movcs	r3, #0
 800928a:	2301      	movcc	r3, #1
 800928c:	f5b0 1f80 	cmp.w	r0, #1048576	; 0x100000
 8009290:	bf38      	it	cc
 8009292:	f043 0301 	orrcc.w	r3, r3, #1
 8009296:	b98b      	cbnz	r3, 80092bc <__fpclassifyd+0x88>
 8009298:	f511 1f80 	cmn.w	r1, #1048576	; 0x100000
 800929c:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 80092a0:	bf14      	ite	ne
 80092a2:	2000      	movne	r0, #0
 80092a4:	2001      	moveq	r0, #1
 80092a6:	4299      	cmp	r1, r3
 80092a8:	bf14      	ite	ne
 80092aa:	4601      	movne	r1, r0
 80092ac:	f040 0101 	orreq.w	r1, r0, #1
 80092b0:	ea02 0001 	and.w	r0, r2, r1
 80092b4:	e000      	b.n	80092b8 <__fpclassifyd+0x84>
 80092b6:	2002      	movs	r0, #2
 80092b8:	bc10      	pop	{r4}
 80092ba:	4770      	bx	lr
 80092bc:	2003      	movs	r0, #3
 80092be:	e7fb      	b.n	80092b8 <__fpclassifyd+0x84>
 80092c0:	2004      	movs	r0, #4
 80092c2:	e7f9      	b.n	80092b8 <__fpclassifyd+0x84>

080092c4 <strlen>:
 80092c4:	f020 0103 	bic.w	r1, r0, #3
 80092c8:	f010 0003 	ands.w	r0, r0, #3
 80092cc:	f1c0 0000 	rsb	r0, r0, #0
 80092d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80092d4:	f100 0c04 	add.w	ip, r0, #4
 80092d8:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 80092dc:	f06f 0200 	mvn.w	r2, #0
 80092e0:	bf1c      	itt	ne
 80092e2:	fa22 f20c 	lsrne.w	r2, r2, ip
 80092e6:	4313      	orrne	r3, r2
 80092e8:	f04f 0c01 	mov.w	ip, #1
 80092ec:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 80092f0:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 80092f4:	eba3 020c 	sub.w	r2, r3, ip
 80092f8:	ea22 0203 	bic.w	r2, r2, r3
 80092fc:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 8009300:	bf04      	itt	eq
 8009302:	f851 3b04 	ldreq.w	r3, [r1], #4
 8009306:	3004      	addeq	r0, #4
 8009308:	d0f4      	beq.n	80092f4 <strlen+0x30>
 800930a:	f013 0fff 	tst.w	r3, #255	; 0xff
 800930e:	bf1f      	itttt	ne
 8009310:	3001      	addne	r0, #1
 8009312:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
 8009316:	3001      	addne	r0, #1
 8009318:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
 800931c:	bf18      	it	ne
 800931e:	3001      	addne	r0, #1
 8009320:	4770      	bx	lr
 8009322:	bf00      	nop

08009324 <__ssprint_r>:
 8009324:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009328:	b083      	sub	sp, #12
 800932a:	4691      	mov	r9, r2
 800932c:	460d      	mov	r5, r1
 800932e:	9001      	str	r0, [sp, #4]
 8009330:	6890      	ldr	r0, [r2, #8]
 8009332:	6817      	ldr	r7, [r2, #0]
 8009334:	2800      	cmp	r0, #0
 8009336:	d077      	beq.n	8009428 <__ssprint_r+0x104>
 8009338:	f04f 0a00 	mov.w	sl, #0
 800933c:	6808      	ldr	r0, [r1, #0]
 800933e:	688b      	ldr	r3, [r1, #8]
 8009340:	4654      	mov	r4, sl
 8009342:	2c00      	cmp	r4, #0
 8009344:	d04c      	beq.n	80093e0 <__ssprint_r+0xbc>
 8009346:	429c      	cmp	r4, r3
 8009348:	461e      	mov	r6, r3
 800934a:	4698      	mov	r8, r3
 800934c:	bf3c      	itt	cc
 800934e:	4626      	movcc	r6, r4
 8009350:	46a0      	movcc	r8, r4
 8009352:	d335      	bcc.n	80093c0 <__ssprint_r+0x9c>
 8009354:	89ab      	ldrh	r3, [r5, #12]
 8009356:	f413 6f90 	tst.w	r3, #1152	; 0x480
 800935a:	d031      	beq.n	80093c0 <__ssprint_r+0x9c>
 800935c:	696a      	ldr	r2, [r5, #20]
 800935e:	f104 0e01 	add.w	lr, r4, #1
 8009362:	6929      	ldr	r1, [r5, #16]
 8009364:	eb02 0b42 	add.w	fp, r2, r2, lsl #1
 8009368:	1a46      	subs	r6, r0, r1
 800936a:	eb0e 0006 	add.w	r0, lr, r6
 800936e:	eb0b 7bdb 	add.w	fp, fp, fp, lsr #31
 8009372:	ea4f 0b6b 	mov.w	fp, fp, asr #1
 8009376:	4583      	cmp	fp, r0
 8009378:	465a      	mov	r2, fp
 800937a:	bf3c      	itt	cc
 800937c:	4683      	movcc	fp, r0
 800937e:	4602      	movcc	r2, r0
 8009380:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8009384:	d031      	beq.n	80093ea <__ssprint_r+0xc6>
 8009386:	9801      	ldr	r0, [sp, #4]
 8009388:	4611      	mov	r1, r2
 800938a:	f7fb fc85 	bl	8004c98 <_malloc_r>
 800938e:	4680      	mov	r8, r0
 8009390:	2800      	cmp	r0, #0
 8009392:	d034      	beq.n	80093fe <__ssprint_r+0xda>
 8009394:	6929      	ldr	r1, [r5, #16]
 8009396:	4632      	mov	r2, r6
 8009398:	f7ff f974 	bl	8008684 <memcpy>
 800939c:	89ab      	ldrh	r3, [r5, #12]
 800939e:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 80093a2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80093a6:	81ab      	strh	r3, [r5, #12]
 80093a8:	eb08 0006 	add.w	r0, r8, r6
 80093ac:	ebc6 030b 	rsb	r3, r6, fp
 80093b0:	f8c5 8010 	str.w	r8, [r5, #16]
 80093b4:	4626      	mov	r6, r4
 80093b6:	46a0      	mov	r8, r4
 80093b8:	6028      	str	r0, [r5, #0]
 80093ba:	f8c5 b014 	str.w	fp, [r5, #20]
 80093be:	60ab      	str	r3, [r5, #8]
 80093c0:	4642      	mov	r2, r8
 80093c2:	4651      	mov	r1, sl
 80093c4:	f000 fdd0 	bl	8009f68 <memmove>
 80093c8:	f8d9 2008 	ldr.w	r2, [r9, #8]
 80093cc:	68ab      	ldr	r3, [r5, #8]
 80093ce:	6828      	ldr	r0, [r5, #0]
 80093d0:	1b14      	subs	r4, r2, r4
 80093d2:	1b9b      	subs	r3, r3, r6
 80093d4:	60ab      	str	r3, [r5, #8]
 80093d6:	4440      	add	r0, r8
 80093d8:	6028      	str	r0, [r5, #0]
 80093da:	f8c9 4008 	str.w	r4, [r9, #8]
 80093de:	b1ec      	cbz	r4, 800941c <__ssprint_r+0xf8>
 80093e0:	f8d7 a000 	ldr.w	sl, [r7]
 80093e4:	687c      	ldr	r4, [r7, #4]
 80093e6:	3708      	adds	r7, #8
 80093e8:	e7ab      	b.n	8009342 <__ssprint_r+0x1e>
 80093ea:	9801      	ldr	r0, [sp, #4]
 80093ec:	f000 fe16 	bl	800a01c <_realloc_r>
 80093f0:	4680      	mov	r8, r0
 80093f2:	2800      	cmp	r0, #0
 80093f4:	d1d8      	bne.n	80093a8 <__ssprint_r+0x84>
 80093f6:	9801      	ldr	r0, [sp, #4]
 80093f8:	6929      	ldr	r1, [r5, #16]
 80093fa:	f7fc fb2f 	bl	8005a5c <_free_r>
 80093fe:	9a01      	ldr	r2, [sp, #4]
 8009400:	230c      	movs	r3, #12
 8009402:	f04f 30ff 	mov.w	r0, #4294967295
 8009406:	6013      	str	r3, [r2, #0]
 8009408:	2300      	movs	r3, #0
 800940a:	89aa      	ldrh	r2, [r5, #12]
 800940c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8009410:	81aa      	strh	r2, [r5, #12]
 8009412:	f8c9 3008 	str.w	r3, [r9, #8]
 8009416:	f8c9 3004 	str.w	r3, [r9, #4]
 800941a:	e002      	b.n	8009422 <__ssprint_r+0xfe>
 800941c:	4620      	mov	r0, r4
 800941e:	f8c9 4004 	str.w	r4, [r9, #4]
 8009422:	b003      	add	sp, #12
 8009424:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009428:	6050      	str	r0, [r2, #4]
 800942a:	e7fa      	b.n	8009422 <__ssprint_r+0xfe>

0800942c <_svfiprintf_r>:
 800942c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009430:	b0ab      	sub	sp, #172	; 0xac
 8009432:	4689      	mov	r9, r1
 8009434:	4683      	mov	fp, r0
 8009436:	9306      	str	r3, [sp, #24]
 8009438:	898b      	ldrh	r3, [r1, #12]
 800943a:	f013 0f80 	tst.w	r3, #128	; 0x80
 800943e:	d003      	beq.n	8009448 <_svfiprintf_r+0x1c>
 8009440:	690b      	ldr	r3, [r1, #16]
 8009442:	2b00      	cmp	r3, #0
 8009444:	f000 8515 	beq.w	8009e72 <_svfiprintf_r+0xa46>
 8009448:	4617      	mov	r7, r2
 800944a:	2300      	movs	r3, #0
 800944c:	ae0c      	add	r6, sp, #48	; 0x30
 800944e:	9308      	str	r3, [sp, #32]
 8009450:	9305      	str	r3, [sp, #20]
 8009452:	9626      	str	r6, [sp, #152]	; 0x98
 8009454:	9328      	str	r3, [sp, #160]	; 0xa0
 8009456:	9327      	str	r3, [sp, #156]	; 0x9c
 8009458:	783b      	ldrb	r3, [r7, #0]
 800945a:	f1b3 0225 	subs.w	r2, r3, #37	; 0x25
 800945e:	bf18      	it	ne
 8009460:	2201      	movne	r2, #1
 8009462:	2b00      	cmp	r3, #0
 8009464:	bf0c      	ite	eq
 8009466:	2300      	moveq	r3, #0
 8009468:	f002 0301 	andne.w	r3, r2, #1
 800946c:	2b00      	cmp	r3, #0
 800946e:	f000 8360 	beq.w	8009b32 <_svfiprintf_r+0x706>
 8009472:	1c7a      	adds	r2, r7, #1
 8009474:	4614      	mov	r4, r2
 8009476:	3201      	adds	r2, #1
 8009478:	7823      	ldrb	r3, [r4, #0]
 800947a:	1e19      	subs	r1, r3, #0
 800947c:	bf18      	it	ne
 800947e:	2101      	movne	r1, #1
 8009480:	2b25      	cmp	r3, #37	; 0x25
 8009482:	bf0c      	ite	eq
 8009484:	2300      	moveq	r3, #0
 8009486:	f001 0301 	andne.w	r3, r1, #1
 800948a:	2b00      	cmp	r3, #0
 800948c:	d1f2      	bne.n	8009474 <_svfiprintf_r+0x48>
 800948e:	1be5      	subs	r5, r4, r7
 8009490:	d00e      	beq.n	80094b0 <_svfiprintf_r+0x84>
 8009492:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009494:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009496:	3301      	adds	r3, #1
 8009498:	6037      	str	r7, [r6, #0]
 800949a:	2b07      	cmp	r3, #7
 800949c:	6075      	str	r5, [r6, #4]
 800949e:	442a      	add	r2, r5
 80094a0:	9327      	str	r3, [sp, #156]	; 0x9c
 80094a2:	9228      	str	r2, [sp, #160]	; 0xa0
 80094a4:	f300 83bc 	bgt.w	8009c20 <_svfiprintf_r+0x7f4>
 80094a8:	3608      	adds	r6, #8
 80094aa:	9905      	ldr	r1, [sp, #20]
 80094ac:	1949      	adds	r1, r1, r5
 80094ae:	9105      	str	r1, [sp, #20]
 80094b0:	7823      	ldrb	r3, [r4, #0]
 80094b2:	2b00      	cmp	r3, #0
 80094b4:	f000 833f 	beq.w	8009b36 <_svfiprintf_r+0x70a>
 80094b8:	2200      	movs	r2, #0
 80094ba:	2300      	movs	r3, #0
 80094bc:	9204      	str	r2, [sp, #16]
 80094be:	1c67      	adds	r7, r4, #1
 80094c0:	f88d 30a7 	strb.w	r3, [sp, #167]	; 0xa7
 80094c4:	f04f 38ff 	mov.w	r8, #4294967295
 80094c8:	7863      	ldrb	r3, [r4, #1]
 80094ca:	4692      	mov	sl, r2
 80094cc:	f04f 0c20 	mov.w	ip, #32
 80094d0:	242b      	movs	r4, #43	; 0x2b
 80094d2:	3701      	adds	r7, #1
 80094d4:	f1a3 0220 	sub.w	r2, r3, #32
 80094d8:	2a58      	cmp	r2, #88	; 0x58
 80094da:	f200 824e 	bhi.w	800997a <_svfiprintf_r+0x54e>
 80094de:	e8df f012 	tbh	[pc, r2, lsl #1]
 80094e2:	025a      	.short	0x025a
 80094e4:	024c024c 	.word	0x024c024c
 80094e8:	024c01fb 	.word	0x024c01fb
 80094ec:	024c024c 	.word	0x024c024c
 80094f0:	024c024c 	.word	0x024c024c
 80094f4:	00fe024c 	.word	0x00fe024c
 80094f8:	024c0214 	.word	0x024c0214
 80094fc:	0218010a 	.word	0x0218010a
 8009500:	0210024c 	.word	0x0210024c
 8009504:	01ff01ff 	.word	0x01ff01ff
 8009508:	01ff01ff 	.word	0x01ff01ff
 800950c:	01ff01ff 	.word	0x01ff01ff
 8009510:	01ff01ff 	.word	0x01ff01ff
 8009514:	024c01ff 	.word	0x024c01ff
 8009518:	024c024c 	.word	0x024c024c
 800951c:	024c024c 	.word	0x024c024c
 8009520:	024c024c 	.word	0x024c024c
 8009524:	024c024c 	.word	0x024c024c
 8009528:	00c7024c 	.word	0x00c7024c
 800952c:	024c024c 	.word	0x024c024c
 8009530:	024c024c 	.word	0x024c024c
 8009534:	024c024c 	.word	0x024c024c
 8009538:	024c024c 	.word	0x024c024c
 800953c:	024c024c 	.word	0x024c024c
 8009540:	024c00bd 	.word	0x024c00bd
 8009544:	024c024c 	.word	0x024c024c
 8009548:	024c024c 	.word	0x024c024c
 800954c:	024c0059 	.word	0x024c0059
 8009550:	016d024c 	.word	0x016d024c
 8009554:	024c024c 	.word	0x024c024c
 8009558:	024c024c 	.word	0x024c024c
 800955c:	024c024c 	.word	0x024c024c
 8009560:	024c024c 	.word	0x024c024c
 8009564:	024c024c 	.word	0x024c024c
 8009568:	00c90192 	.word	0x00c90192
 800956c:	024c024c 	.word	0x024c024c
 8009570:	0169024c 	.word	0x0169024c
 8009574:	024c00c9 	.word	0x024c00c9
 8009578:	015f024c 	.word	0x015f024c
 800957c:	014c024c 	.word	0x014c024c
 8009580:	013400bf 	.word	0x013400bf
 8009584:	024c0130 	.word	0x024c0130
 8009588:	024c010e 	.word	0x024c010e
 800958c:	024c005b 	.word	0x024c005b
 8009590:	0235024c 	.word	0x0235024c
 8009594:	f04a 0a10 	orr.w	sl, sl, #16
 8009598:	f01a 0f20 	tst.w	sl, #32
 800959c:	f000 83bf 	beq.w	8009d1e <_svfiprintf_r+0x8f2>
 80095a0:	9b06      	ldr	r3, [sp, #24]
 80095a2:	1dda      	adds	r2, r3, #7
 80095a4:	2301      	movs	r3, #1
 80095a6:	f022 0207 	bic.w	r2, r2, #7
 80095aa:	f102 0508 	add.w	r5, r2, #8
 80095ae:	9506      	str	r5, [sp, #24]
 80095b0:	e9d2 4500 	ldrd	r4, r5, [r2]
 80095b4:	ea54 0005 	orrs.w	r0, r4, r5
 80095b8:	bf0c      	ite	eq
 80095ba:	2200      	moveq	r2, #0
 80095bc:	2201      	movne	r2, #1
 80095be:	2100      	movs	r1, #0
 80095c0:	f88d 10a7 	strb.w	r1, [sp, #167]	; 0xa7
 80095c4:	f1b8 0f00 	cmp.w	r8, #0
 80095c8:	bfa8      	it	ge
 80095ca:	f02a 0a80 	bicge.w	sl, sl, #128	; 0x80
 80095ce:	f1b8 0f00 	cmp.w	r8, #0
 80095d2:	bf18      	it	ne
 80095d4:	f042 0201 	orrne.w	r2, r2, #1
 80095d8:	2a00      	cmp	r2, #0
 80095da:	d070      	beq.n	80096be <_svfiprintf_r+0x292>
 80095dc:	2b01      	cmp	r3, #1
 80095de:	f000 8348 	beq.w	8009c72 <_svfiprintf_r+0x846>
 80095e2:	2b02      	cmp	r3, #2
 80095e4:	f000 836f 	beq.w	8009cc6 <_svfiprintf_r+0x89a>
 80095e8:	aa1c      	add	r2, sp, #112	; 0x70
 80095ea:	46b4      	mov	ip, r6
 80095ec:	f102 0327 	add.w	r3, r2, #39	; 0x27
 80095f0:	9202      	str	r2, [sp, #8]
 80095f2:	9703      	str	r7, [sp, #12]
 80095f4:	08ea      	lsrs	r2, r5, #3
 80095f6:	08e7      	lsrs	r7, r4, #3
 80095f8:	ea47 7745 	orr.w	r7, r7, r5, lsl #29
 80095fc:	f004 0407 	and.w	r4, r4, #7
 8009600:	4611      	mov	r1, r2
 8009602:	f104 0230 	add.w	r2, r4, #48	; 0x30
 8009606:	460d      	mov	r5, r1
 8009608:	463c      	mov	r4, r7
 800960a:	461e      	mov	r6, r3
 800960c:	701a      	strb	r2, [r3, #0]
 800960e:	3b01      	subs	r3, #1
 8009610:	ea54 0005 	orrs.w	r0, r4, r5
 8009614:	d1ee      	bne.n	80095f4 <_svfiprintf_r+0x1c8>
 8009616:	f01a 0f01 	tst.w	sl, #1
 800961a:	9609      	str	r6, [sp, #36]	; 0x24
 800961c:	9f03      	ldr	r7, [sp, #12]
 800961e:	4666      	mov	r6, ip
 8009620:	f000 83ab 	beq.w	8009d7a <_svfiprintf_r+0x94e>
 8009624:	2a30      	cmp	r2, #48	; 0x30
 8009626:	f000 8365 	beq.w	8009cf4 <_svfiprintf_r+0x8c8>
 800962a:	9309      	str	r3, [sp, #36]	; 0x24
 800962c:	9902      	ldr	r1, [sp, #8]
 800962e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8009630:	f101 0328 	add.w	r3, r1, #40	; 0x28
 8009634:	1a9b      	subs	r3, r3, r2
 8009636:	9303      	str	r3, [sp, #12]
 8009638:	2330      	movs	r3, #48	; 0x30
 800963a:	7013      	strb	r3, [r2, #0]
 800963c:	f8cd 801c 	str.w	r8, [sp, #28]
 8009640:	9803      	ldr	r0, [sp, #12]
 8009642:	9907      	ldr	r1, [sp, #28]
 8009644:	f89d 30a7 	ldrb.w	r3, [sp, #167]	; 0xa7
 8009648:	4288      	cmp	r0, r1
 800964a:	bfb8      	it	lt
 800964c:	4608      	movlt	r0, r1
 800964e:	9002      	str	r0, [sp, #8]
 8009650:	2b00      	cmp	r3, #0
 8009652:	f000 80e8 	beq.w	8009826 <_svfiprintf_r+0x3fa>
 8009656:	3001      	adds	r0, #1
 8009658:	9002      	str	r0, [sp, #8]
 800965a:	e0e4      	b.n	8009826 <_svfiprintf_r+0x3fa>
 800965c:	f04a 0a10 	orr.w	sl, sl, #16
 8009660:	f01a 0320 	ands.w	r3, sl, #32
 8009664:	f000 8366 	beq.w	8009d34 <_svfiprintf_r+0x908>
 8009668:	9b06      	ldr	r3, [sp, #24]
 800966a:	1dda      	adds	r2, r3, #7
 800966c:	2300      	movs	r3, #0
 800966e:	e79a      	b.n	80095a6 <_svfiprintf_r+0x17a>
 8009670:	f04a 0a10 	orr.w	sl, sl, #16
 8009674:	f01a 0f20 	tst.w	sl, #32
 8009678:	f000 8343 	beq.w	8009d02 <_svfiprintf_r+0x8d6>
 800967c:	9806      	ldr	r0, [sp, #24]
 800967e:	1dc3      	adds	r3, r0, #7
 8009680:	f023 0307 	bic.w	r3, r3, #7
 8009684:	f103 0108 	add.w	r1, r3, #8
 8009688:	9106      	str	r1, [sp, #24]
 800968a:	e9d3 4500 	ldrd	r4, r5, [r3]
 800968e:	2c00      	cmp	r4, #0
 8009690:	f175 0000 	sbcs.w	r0, r5, #0
 8009694:	f2c0 83ab 	blt.w	8009dee <_svfiprintf_r+0x9c2>
 8009698:	ea54 0105 	orrs.w	r1, r4, r5
 800969c:	f04f 0301 	mov.w	r3, #1
 80096a0:	bf0c      	ite	eq
 80096a2:	2200      	moveq	r2, #0
 80096a4:	2201      	movne	r2, #1
 80096a6:	f1b8 0f00 	cmp.w	r8, #0
 80096aa:	bfa8      	it	ge
 80096ac:	f02a 0a80 	bicge.w	sl, sl, #128	; 0x80
 80096b0:	f1b8 0f00 	cmp.w	r8, #0
 80096b4:	bf18      	it	ne
 80096b6:	f042 0201 	orrne.w	r2, r2, #1
 80096ba:	2a00      	cmp	r2, #0
 80096bc:	d18e      	bne.n	80095dc <_svfiprintf_r+0x1b0>
 80096be:	2b00      	cmp	r3, #0
 80096c0:	f040 82aa 	bne.w	8009c18 <_svfiprintf_r+0x7ec>
 80096c4:	f01a 0f01 	tst.w	sl, #1
 80096c8:	f000 82f9 	beq.w	8009cbe <_svfiprintf_r+0x892>
 80096cc:	2101      	movs	r1, #1
 80096ce:	2330      	movs	r3, #48	; 0x30
 80096d0:	f10d 0297 	add.w	r2, sp, #151	; 0x97
 80096d4:	9103      	str	r1, [sp, #12]
 80096d6:	f88d 3097 	strb.w	r3, [sp, #151]	; 0x97
 80096da:	9209      	str	r2, [sp, #36]	; 0x24
 80096dc:	e7ae      	b.n	800963c <_svfiprintf_r+0x210>
 80096de:	9806      	ldr	r0, [sp, #24]
 80096e0:	9906      	ldr	r1, [sp, #24]
 80096e2:	6800      	ldr	r0, [r0, #0]
 80096e4:	1d0a      	adds	r2, r1, #4
 80096e6:	2800      	cmp	r0, #0
 80096e8:	9004      	str	r0, [sp, #16]
 80096ea:	f280 8338 	bge.w	8009d5e <_svfiprintf_r+0x932>
 80096ee:	9b04      	ldr	r3, [sp, #16]
 80096f0:	9206      	str	r2, [sp, #24]
 80096f2:	425b      	negs	r3, r3
 80096f4:	9304      	str	r3, [sp, #16]
 80096f6:	f04a 0a04 	orr.w	sl, sl, #4
 80096fa:	783b      	ldrb	r3, [r7, #0]
 80096fc:	e6e9      	b.n	80094d2 <_svfiprintf_r+0xa6>
 80096fe:	9b06      	ldr	r3, [sp, #24]
 8009700:	2500      	movs	r5, #0
 8009702:	f88d 50a7 	strb.w	r5, [sp, #167]	; 0xa7
 8009706:	1d18      	adds	r0, r3, #4
 8009708:	9006      	str	r0, [sp, #24]
 800970a:	681b      	ldr	r3, [r3, #0]
 800970c:	9309      	str	r3, [sp, #36]	; 0x24
 800970e:	2b00      	cmp	r3, #0
 8009710:	f000 83ce 	beq.w	8009eb0 <_svfiprintf_r+0xa84>
 8009714:	f1b8 0f00 	cmp.w	r8, #0
 8009718:	f2c0 837b 	blt.w	8009e12 <_svfiprintf_r+0x9e6>
 800971c:	9809      	ldr	r0, [sp, #36]	; 0x24
 800971e:	2100      	movs	r1, #0
 8009720:	4642      	mov	r2, r8
 8009722:	f7fe ff69 	bl	80085f8 <memchr>
 8009726:	2800      	cmp	r0, #0
 8009728:	f000 83d4 	beq.w	8009ed4 <_svfiprintf_r+0xaa8>
 800972c:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800972e:	1b40      	subs	r0, r0, r5
 8009730:	9003      	str	r0, [sp, #12]
 8009732:	4540      	cmp	r0, r8
 8009734:	f340 837f 	ble.w	8009e36 <_svfiprintf_r+0xa0a>
 8009738:	2500      	movs	r5, #0
 800973a:	f8cd 800c 	str.w	r8, [sp, #12]
 800973e:	9507      	str	r5, [sp, #28]
 8009740:	e77e      	b.n	8009640 <_svfiprintf_r+0x214>
 8009742:	f04a 0a20 	orr.w	sl, sl, #32
 8009746:	783b      	ldrb	r3, [r7, #0]
 8009748:	e6c3      	b.n	80094d2 <_svfiprintf_r+0xa6>
 800974a:	9b06      	ldr	r3, [sp, #24]
 800974c:	f64b 3160 	movw	r1, #47968	; 0xbb60
 8009750:	2500      	movs	r5, #0
 8009752:	f6c0 0100 	movt	r1, #2048	; 0x800
 8009756:	f04a 0a02 	orr.w	sl, sl, #2
 800975a:	681a      	ldr	r2, [r3, #0]
 800975c:	3304      	adds	r3, #4
 800975e:	9306      	str	r3, [sp, #24]
 8009760:	2330      	movs	r3, #48	; 0x30
 8009762:	4614      	mov	r4, r2
 8009764:	f88d 30a4 	strb.w	r3, [sp, #164]	; 0xa4
 8009768:	2378      	movs	r3, #120	; 0x78
 800976a:	3a00      	subs	r2, #0
 800976c:	f88d 30a5 	strb.w	r3, [sp, #165]	; 0xa5
 8009770:	bf18      	it	ne
 8009772:	2201      	movne	r2, #1
 8009774:	9108      	str	r1, [sp, #32]
 8009776:	2302      	movs	r3, #2
 8009778:	e721      	b.n	80095be <_svfiprintf_r+0x192>
 800977a:	f01a 0f20 	tst.w	sl, #32
 800977e:	f040 830c 	bne.w	8009d9a <_svfiprintf_r+0x96e>
 8009782:	f01a 0f10 	tst.w	sl, #16
 8009786:	f040 834b 	bne.w	8009e20 <_svfiprintf_r+0x9f4>
 800978a:	f01a 0f40 	tst.w	sl, #64	; 0x40
 800978e:	f000 8347 	beq.w	8009e20 <_svfiprintf_r+0x9f4>
 8009792:	9d06      	ldr	r5, [sp, #24]
 8009794:	9805      	ldr	r0, [sp, #20]
 8009796:	682b      	ldr	r3, [r5, #0]
 8009798:	3504      	adds	r5, #4
 800979a:	9506      	str	r5, [sp, #24]
 800979c:	8018      	strh	r0, [r3, #0]
 800979e:	e65b      	b.n	8009458 <_svfiprintf_r+0x2c>
 80097a0:	783b      	ldrb	r3, [r7, #0]
 80097a2:	2b6c      	cmp	r3, #108	; 0x6c
 80097a4:	bf0a      	itet	eq
 80097a6:	f04a 0a20 	orreq.w	sl, sl, #32
 80097aa:	f04a 0a10 	orrne.w	sl, sl, #16
 80097ae:	f817 3f01 	ldrbeq.w	r3, [r7, #1]!
 80097b2:	e68e      	b.n	80094d2 <_svfiprintf_r+0xa6>
 80097b4:	f04a 0a40 	orr.w	sl, sl, #64	; 0x40
 80097b8:	783b      	ldrb	r3, [r7, #0]
 80097ba:	e68a      	b.n	80094d2 <_svfiprintf_r+0xa6>
 80097bc:	f01a 0f20 	tst.w	sl, #32
 80097c0:	f64b 324c 	movw	r2, #47948	; 0xbb4c
 80097c4:	f6c0 0200 	movt	r2, #2048	; 0x800
 80097c8:	9208      	str	r2, [sp, #32]
 80097ca:	f000 80c8 	beq.w	800995e <_svfiprintf_r+0x532>
 80097ce:	9d06      	ldr	r5, [sp, #24]
 80097d0:	1dea      	adds	r2, r5, #7
 80097d2:	f022 0207 	bic.w	r2, r2, #7
 80097d6:	f102 0008 	add.w	r0, r2, #8
 80097da:	9006      	str	r0, [sp, #24]
 80097dc:	e9d2 4500 	ldrd	r4, r5, [r2]
 80097e0:	ea54 0005 	orrs.w	r0, r4, r5
 80097e4:	bf0c      	ite	eq
 80097e6:	2200      	moveq	r2, #0
 80097e8:	2201      	movne	r2, #1
 80097ea:	ea1a 0f02 	tst.w	sl, r2
 80097ee:	f000 82b4 	beq.w	8009d5a <_svfiprintf_r+0x92e>
 80097f2:	f88d 30a5 	strb.w	r3, [sp, #165]	; 0xa5
 80097f6:	f04a 0a02 	orr.w	sl, sl, #2
 80097fa:	2330      	movs	r3, #48	; 0x30
 80097fc:	2201      	movs	r2, #1
 80097fe:	f88d 30a4 	strb.w	r3, [sp, #164]	; 0xa4
 8009802:	2302      	movs	r3, #2
 8009804:	e6db      	b.n	80095be <_svfiprintf_r+0x192>
 8009806:	9b06      	ldr	r3, [sp, #24]
 8009808:	2001      	movs	r0, #1
 800980a:	aa1c      	add	r2, sp, #112	; 0x70
 800980c:	2500      	movs	r5, #0
 800980e:	1d19      	adds	r1, r3, #4
 8009810:	9002      	str	r0, [sp, #8]
 8009812:	681b      	ldr	r3, [r3, #0]
 8009814:	9106      	str	r1, [sp, #24]
 8009816:	9003      	str	r0, [sp, #12]
 8009818:	9209      	str	r2, [sp, #36]	; 0x24
 800981a:	f88d 50a7 	strb.w	r5, [sp, #167]	; 0xa7
 800981e:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
 8009822:	2100      	movs	r1, #0
 8009824:	9107      	str	r1, [sp, #28]
 8009826:	f01a 0202 	ands.w	r2, sl, #2
 800982a:	920a      	str	r2, [sp, #40]	; 0x28
 800982c:	d002      	beq.n	8009834 <_svfiprintf_r+0x408>
 800982e:	9b02      	ldr	r3, [sp, #8]
 8009830:	3302      	adds	r3, #2
 8009832:	9302      	str	r3, [sp, #8]
 8009834:	f01a 0584 	ands.w	r5, sl, #132	; 0x84
 8009838:	950b      	str	r5, [sp, #44]	; 0x2c
 800983a:	f040 80b5 	bne.w	80099a8 <_svfiprintf_r+0x57c>
 800983e:	9804      	ldr	r0, [sp, #16]
 8009840:	9902      	ldr	r1, [sp, #8]
 8009842:	1a44      	subs	r4, r0, r1
 8009844:	2c00      	cmp	r4, #0
 8009846:	f340 80af 	ble.w	80099a8 <_svfiprintf_r+0x57c>
 800984a:	2c10      	cmp	r4, #16
 800984c:	f340 8321 	ble.w	8009e92 <_svfiprintf_r+0xa66>
 8009850:	f64b 1518 	movw	r5, #47384	; 0xb918
 8009854:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009856:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009858:	f6c0 0500 	movt	r5, #2048	; 0x800
 800985c:	f04f 0810 	mov.w	r8, #16
 8009860:	e002      	b.n	8009868 <_svfiprintf_r+0x43c>
 8009862:	3c10      	subs	r4, #16
 8009864:	2c10      	cmp	r4, #16
 8009866:	dd1c      	ble.n	80098a2 <_svfiprintf_r+0x476>
 8009868:	3301      	adds	r3, #1
 800986a:	6035      	str	r5, [r6, #0]
 800986c:	f8c6 8004 	str.w	r8, [r6, #4]
 8009870:	3210      	adds	r2, #16
 8009872:	3608      	adds	r6, #8
 8009874:	2b07      	cmp	r3, #7
 8009876:	9327      	str	r3, [sp, #156]	; 0x9c
 8009878:	f106 0c08 	add.w	ip, r6, #8
 800987c:	9228      	str	r2, [sp, #160]	; 0xa0
 800987e:	ddf0      	ble.n	8009862 <_svfiprintf_r+0x436>
 8009880:	aa26      	add	r2, sp, #152	; 0x98
 8009882:	4658      	mov	r0, fp
 8009884:	4649      	mov	r1, r9
 8009886:	ae0c      	add	r6, sp, #48	; 0x30
 8009888:	f7ff fd4c 	bl	8009324 <__ssprint_r>
 800988c:	aa0c      	add	r2, sp, #48	; 0x30
 800988e:	f102 0c08 	add.w	ip, r2, #8
 8009892:	2800      	cmp	r0, #0
 8009894:	f040 8156 	bne.w	8009b44 <_svfiprintf_r+0x718>
 8009898:	3c10      	subs	r4, #16
 800989a:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800989c:	2c10      	cmp	r4, #16
 800989e:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 80098a0:	dce2      	bgt.n	8009868 <_svfiprintf_r+0x43c>
 80098a2:	3301      	adds	r3, #1
 80098a4:	6035      	str	r5, [r6, #0]
 80098a6:	2b07      	cmp	r3, #7
 80098a8:	6074      	str	r4, [r6, #4]
 80098aa:	4422      	add	r2, r4
 80098ac:	9327      	str	r3, [sp, #156]	; 0x9c
 80098ae:	9228      	str	r2, [sp, #160]	; 0xa0
 80098b0:	bfdc      	itt	le
 80098b2:	f10c 0108 	addle.w	r1, ip, #8
 80098b6:	4666      	movle	r6, ip
 80098b8:	dd7a      	ble.n	80099b0 <_svfiprintf_r+0x584>
 80098ba:	4658      	mov	r0, fp
 80098bc:	4649      	mov	r1, r9
 80098be:	aa26      	add	r2, sp, #152	; 0x98
 80098c0:	f7ff fd30 	bl	8009324 <__ssprint_r>
 80098c4:	2800      	cmp	r0, #0
 80098c6:	f040 813d 	bne.w	8009b44 <_svfiprintf_r+0x718>
 80098ca:	ab0c      	add	r3, sp, #48	; 0x30
 80098cc:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 80098ce:	f103 0108 	add.w	r1, r3, #8
 80098d2:	ae0c      	add	r6, sp, #48	; 0x30
 80098d4:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 80098d6:	e06b      	b.n	80099b0 <_svfiprintf_r+0x584>
 80098d8:	f04a 0a01 	orr.w	sl, sl, #1
 80098dc:	783b      	ldrb	r3, [r7, #0]
 80098de:	e5f8      	b.n	80094d2 <_svfiprintf_r+0xa6>
 80098e0:	4639      	mov	r1, r7
 80098e2:	2200      	movs	r2, #0
 80098e4:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
 80098e8:	f811 3b01 	ldrb.w	r3, [r1], #1
 80098ec:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80098f0:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 80098f4:	460f      	mov	r7, r1
 80098f6:	2809      	cmp	r0, #9
 80098f8:	eb05 0242 	add.w	r2, r5, r2, lsl #1
 80098fc:	d9f2      	bls.n	80098e4 <_svfiprintf_r+0x4b8>
 80098fe:	9204      	str	r2, [sp, #16]
 8009900:	e5e8      	b.n	80094d4 <_svfiprintf_r+0xa8>
 8009902:	f04a 0a80 	orr.w	sl, sl, #128	; 0x80
 8009906:	783b      	ldrb	r3, [r7, #0]
 8009908:	e5e3      	b.n	80094d2 <_svfiprintf_r+0xa6>
 800990a:	f88d 40a7 	strb.w	r4, [sp, #167]	; 0xa7
 800990e:	783b      	ldrb	r3, [r7, #0]
 8009910:	e5df      	b.n	80094d2 <_svfiprintf_r+0xa6>
 8009912:	f817 3b01 	ldrb.w	r3, [r7], #1
 8009916:	2b2a      	cmp	r3, #42	; 0x2a
 8009918:	f000 82e1 	beq.w	8009ede <_svfiprintf_r+0xab2>
 800991c:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8009920:	2a09      	cmp	r2, #9
 8009922:	bf88      	it	hi
 8009924:	f04f 0800 	movhi.w	r8, #0
 8009928:	d80d      	bhi.n	8009946 <_svfiprintf_r+0x51a>
 800992a:	4639      	mov	r1, r7
 800992c:	f04f 0800 	mov.w	r8, #0
 8009930:	f811 3b01 	ldrb.w	r3, [r1], #1
 8009934:	eb08 0888 	add.w	r8, r8, r8, lsl #2
 8009938:	eb02 0848 	add.w	r8, r2, r8, lsl #1
 800993c:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8009940:	2a09      	cmp	r2, #9
 8009942:	460f      	mov	r7, r1
 8009944:	d9f4      	bls.n	8009930 <_svfiprintf_r+0x504>
 8009946:	ea48 78e8 	orr.w	r8, r8, r8, asr #31
 800994a:	e5c3      	b.n	80094d4 <_svfiprintf_r+0xa8>
 800994c:	f01a 0f20 	tst.w	sl, #32
 8009950:	f64b 3160 	movw	r1, #47968	; 0xbb60
 8009954:	f6c0 0100 	movt	r1, #2048	; 0x800
 8009958:	9108      	str	r1, [sp, #32]
 800995a:	f47f af38 	bne.w	80097ce <_svfiprintf_r+0x3a2>
 800995e:	f01a 0f10 	tst.w	sl, #16
 8009962:	f040 8226 	bne.w	8009db2 <_svfiprintf_r+0x986>
 8009966:	f01a 0f40 	tst.w	sl, #64	; 0x40
 800996a:	f000 8278 	beq.w	8009e5e <_svfiprintf_r+0xa32>
 800996e:	9a06      	ldr	r2, [sp, #24]
 8009970:	2500      	movs	r5, #0
 8009972:	8814      	ldrh	r4, [r2, #0]
 8009974:	3204      	adds	r2, #4
 8009976:	9206      	str	r2, [sp, #24]
 8009978:	e732      	b.n	80097e0 <_svfiprintf_r+0x3b4>
 800997a:	2b00      	cmp	r3, #0
 800997c:	f000 80db 	beq.w	8009b36 <_svfiprintf_r+0x70a>
 8009980:	2001      	movs	r0, #1
 8009982:	2100      	movs	r1, #0
 8009984:	aa1c      	add	r2, sp, #112	; 0x70
 8009986:	9002      	str	r0, [sp, #8]
 8009988:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
 800998c:	f88d 10a7 	strb.w	r1, [sp, #167]	; 0xa7
 8009990:	9003      	str	r0, [sp, #12]
 8009992:	9209      	str	r2, [sp, #36]	; 0x24
 8009994:	e745      	b.n	8009822 <_svfiprintf_r+0x3f6>
 8009996:	f89d 30a7 	ldrb.w	r3, [sp, #167]	; 0xa7
 800999a:	2b00      	cmp	r3, #0
 800999c:	f040 821a 	bne.w	8009dd4 <_svfiprintf_r+0x9a8>
 80099a0:	f88d c0a7 	strb.w	ip, [sp, #167]	; 0xa7
 80099a4:	783b      	ldrb	r3, [r7, #0]
 80099a6:	e594      	b.n	80094d2 <_svfiprintf_r+0xa6>
 80099a8:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 80099aa:	f106 0108 	add.w	r1, r6, #8
 80099ae:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 80099b0:	f89d 00a7 	ldrb.w	r0, [sp, #167]	; 0xa7
 80099b4:	b168      	cbz	r0, 80099d2 <_svfiprintf_r+0x5a6>
 80099b6:	3301      	adds	r3, #1
 80099b8:	f10d 00a7 	add.w	r0, sp, #167	; 0xa7
 80099bc:	6030      	str	r0, [r6, #0]
 80099be:	2001      	movs	r0, #1
 80099c0:	2b07      	cmp	r3, #7
 80099c2:	6070      	str	r0, [r6, #4]
 80099c4:	4402      	add	r2, r0
 80099c6:	9327      	str	r3, [sp, #156]	; 0x9c
 80099c8:	9228      	str	r2, [sp, #160]	; 0xa0
 80099ca:	f300 8132 	bgt.w	8009c32 <_svfiprintf_r+0x806>
 80099ce:	460e      	mov	r6, r1
 80099d0:	3108      	adds	r1, #8
 80099d2:	980a      	ldr	r0, [sp, #40]	; 0x28
 80099d4:	b160      	cbz	r0, 80099f0 <_svfiprintf_r+0x5c4>
 80099d6:	3301      	adds	r3, #1
 80099d8:	a829      	add	r0, sp, #164	; 0xa4
 80099da:	6030      	str	r0, [r6, #0]
 80099dc:	2002      	movs	r0, #2
 80099de:	2b07      	cmp	r3, #7
 80099e0:	6070      	str	r0, [r6, #4]
 80099e2:	4402      	add	r2, r0
 80099e4:	9327      	str	r3, [sp, #156]	; 0x9c
 80099e6:	9228      	str	r2, [sp, #160]	; 0xa0
 80099e8:	f300 8134 	bgt.w	8009c54 <_svfiprintf_r+0x828>
 80099ec:	460e      	mov	r6, r1
 80099ee:	3108      	adds	r1, #8
 80099f0:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80099f2:	2d80      	cmp	r5, #128	; 0x80
 80099f4:	f000 80b3 	beq.w	8009b5e <_svfiprintf_r+0x732>
 80099f8:	9807      	ldr	r0, [sp, #28]
 80099fa:	9d03      	ldr	r5, [sp, #12]
 80099fc:	1b44      	subs	r4, r0, r5
 80099fe:	2c00      	cmp	r4, #0
 8009a00:	dd3e      	ble.n	8009a80 <_svfiprintf_r+0x654>
 8009a02:	2c10      	cmp	r4, #16
 8009a04:	f340 8214 	ble.w	8009e30 <_svfiprintf_r+0xa04>
 8009a08:	4d91      	ldr	r5, [pc, #580]	; (8009c50 <_svfiprintf_r+0x824>)
 8009a0a:	f04f 0810 	mov.w	r8, #16
 8009a0e:	e002      	b.n	8009a16 <_svfiprintf_r+0x5ea>
 8009a10:	3c10      	subs	r4, #16
 8009a12:	2c10      	cmp	r4, #16
 8009a14:	dd1b      	ble.n	8009a4e <_svfiprintf_r+0x622>
 8009a16:	3301      	adds	r3, #1
 8009a18:	6035      	str	r5, [r6, #0]
 8009a1a:	f8c6 8004 	str.w	r8, [r6, #4]
 8009a1e:	3210      	adds	r2, #16
 8009a20:	3608      	adds	r6, #8
 8009a22:	2b07      	cmp	r3, #7
 8009a24:	9327      	str	r3, [sp, #156]	; 0x9c
 8009a26:	f106 0c08 	add.w	ip, r6, #8
 8009a2a:	9228      	str	r2, [sp, #160]	; 0xa0
 8009a2c:	ddf0      	ble.n	8009a10 <_svfiprintf_r+0x5e4>
 8009a2e:	4649      	mov	r1, r9
 8009a30:	4658      	mov	r0, fp
 8009a32:	aa26      	add	r2, sp, #152	; 0x98
 8009a34:	ae0c      	add	r6, sp, #48	; 0x30
 8009a36:	f7ff fc75 	bl	8009324 <__ssprint_r>
 8009a3a:	a90c      	add	r1, sp, #48	; 0x30
 8009a3c:	f101 0c08 	add.w	ip, r1, #8
 8009a40:	2800      	cmp	r0, #0
 8009a42:	d17f      	bne.n	8009b44 <_svfiprintf_r+0x718>
 8009a44:	3c10      	subs	r4, #16
 8009a46:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009a48:	2c10      	cmp	r4, #16
 8009a4a:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009a4c:	dce3      	bgt.n	8009a16 <_svfiprintf_r+0x5ea>
 8009a4e:	3301      	adds	r3, #1
 8009a50:	6035      	str	r5, [r6, #0]
 8009a52:	2b07      	cmp	r3, #7
 8009a54:	6074      	str	r4, [r6, #4]
 8009a56:	4422      	add	r2, r4
 8009a58:	9327      	str	r3, [sp, #156]	; 0x9c
 8009a5a:	9228      	str	r2, [sp, #160]	; 0xa0
 8009a5c:	bfdc      	itt	le
 8009a5e:	f10c 0108 	addle.w	r1, ip, #8
 8009a62:	4666      	movle	r6, ip
 8009a64:	dd0c      	ble.n	8009a80 <_svfiprintf_r+0x654>
 8009a66:	4658      	mov	r0, fp
 8009a68:	4649      	mov	r1, r9
 8009a6a:	aa26      	add	r2, sp, #152	; 0x98
 8009a6c:	f7ff fc5a 	bl	8009324 <__ssprint_r>
 8009a70:	2800      	cmp	r0, #0
 8009a72:	d167      	bne.n	8009b44 <_svfiprintf_r+0x718>
 8009a74:	ab0c      	add	r3, sp, #48	; 0x30
 8009a76:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009a78:	f103 0108 	add.w	r1, r3, #8
 8009a7c:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009a7e:	ae0c      	add	r6, sp, #48	; 0x30
 8009a80:	3301      	adds	r3, #1
 8009a82:	9803      	ldr	r0, [sp, #12]
 8009a84:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8009a86:	2b07      	cmp	r3, #7
 8009a88:	4402      	add	r2, r0
 8009a8a:	6070      	str	r0, [r6, #4]
 8009a8c:	6035      	str	r5, [r6, #0]
 8009a8e:	9327      	str	r3, [sp, #156]	; 0x9c
 8009a90:	9228      	str	r2, [sp, #160]	; 0xa0
 8009a92:	f300 80ae 	bgt.w	8009bf2 <_svfiprintf_r+0x7c6>
 8009a96:	f01a 0f04 	tst.w	sl, #4
 8009a9a:	d030      	beq.n	8009afe <_svfiprintf_r+0x6d2>
 8009a9c:	9b04      	ldr	r3, [sp, #16]
 8009a9e:	9d02      	ldr	r5, [sp, #8]
 8009aa0:	1b5c      	subs	r4, r3, r5
 8009aa2:	2c00      	cmp	r4, #0
 8009aa4:	dd2b      	ble.n	8009afe <_svfiprintf_r+0x6d2>
 8009aa6:	2c10      	cmp	r4, #16
 8009aa8:	f340 81fc 	ble.w	8009ea4 <_svfiprintf_r+0xa78>
 8009aac:	f64b 1518 	movw	r5, #47384	; 0xb918
 8009ab0:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009ab2:	f6c0 0500 	movt	r5, #2048	; 0x800
 8009ab6:	2610      	movs	r6, #16
 8009ab8:	e002      	b.n	8009ac0 <_svfiprintf_r+0x694>
 8009aba:	3c10      	subs	r4, #16
 8009abc:	2c10      	cmp	r4, #16
 8009abe:	dd15      	ble.n	8009aec <_svfiprintf_r+0x6c0>
 8009ac0:	3301      	adds	r3, #1
 8009ac2:	600d      	str	r5, [r1, #0]
 8009ac4:	604e      	str	r6, [r1, #4]
 8009ac6:	3210      	adds	r2, #16
 8009ac8:	3108      	adds	r1, #8
 8009aca:	2b07      	cmp	r3, #7
 8009acc:	9327      	str	r3, [sp, #156]	; 0x9c
 8009ace:	9228      	str	r2, [sp, #160]	; 0xa0
 8009ad0:	ddf3      	ble.n	8009aba <_svfiprintf_r+0x68e>
 8009ad2:	4649      	mov	r1, r9
 8009ad4:	4658      	mov	r0, fp
 8009ad6:	aa26      	add	r2, sp, #152	; 0x98
 8009ad8:	f7ff fc24 	bl	8009324 <__ssprint_r>
 8009adc:	a90c      	add	r1, sp, #48	; 0x30
 8009ade:	2800      	cmp	r0, #0
 8009ae0:	d130      	bne.n	8009b44 <_svfiprintf_r+0x718>
 8009ae2:	3c10      	subs	r4, #16
 8009ae4:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009ae6:	2c10      	cmp	r4, #16
 8009ae8:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009aea:	dce9      	bgt.n	8009ac0 <_svfiprintf_r+0x694>
 8009aec:	3301      	adds	r3, #1
 8009aee:	600d      	str	r5, [r1, #0]
 8009af0:	2b07      	cmp	r3, #7
 8009af2:	604c      	str	r4, [r1, #4]
 8009af4:	4422      	add	r2, r4
 8009af6:	9327      	str	r3, [sp, #156]	; 0x9c
 8009af8:	9228      	str	r2, [sp, #160]	; 0xa0
 8009afa:	f300 8134 	bgt.w	8009d66 <_svfiprintf_r+0x93a>
 8009afe:	9805      	ldr	r0, [sp, #20]
 8009b00:	9b02      	ldr	r3, [sp, #8]
 8009b02:	9904      	ldr	r1, [sp, #16]
 8009b04:	428b      	cmp	r3, r1
 8009b06:	bfac      	ite	ge
 8009b08:	18c0      	addge	r0, r0, r3
 8009b0a:	1840      	addlt	r0, r0, r1
 8009b0c:	9005      	str	r0, [sp, #20]
 8009b0e:	2a00      	cmp	r2, #0
 8009b10:	d179      	bne.n	8009c06 <_svfiprintf_r+0x7da>
 8009b12:	2500      	movs	r5, #0
 8009b14:	9527      	str	r5, [sp, #156]	; 0x9c
 8009b16:	783b      	ldrb	r3, [r7, #0]
 8009b18:	ae0c      	add	r6, sp, #48	; 0x30
 8009b1a:	f1b3 0225 	subs.w	r2, r3, #37	; 0x25
 8009b1e:	bf18      	it	ne
 8009b20:	2201      	movne	r2, #1
 8009b22:	2b00      	cmp	r3, #0
 8009b24:	bf0c      	ite	eq
 8009b26:	2300      	moveq	r3, #0
 8009b28:	f002 0301 	andne.w	r3, r2, #1
 8009b2c:	2b00      	cmp	r3, #0
 8009b2e:	f47f aca0 	bne.w	8009472 <_svfiprintf_r+0x46>
 8009b32:	463c      	mov	r4, r7
 8009b34:	e4bc      	b.n	80094b0 <_svfiprintf_r+0x84>
 8009b36:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 8009b38:	b123      	cbz	r3, 8009b44 <_svfiprintf_r+0x718>
 8009b3a:	4658      	mov	r0, fp
 8009b3c:	4649      	mov	r1, r9
 8009b3e:	aa26      	add	r2, sp, #152	; 0x98
 8009b40:	f7ff fbf0 	bl	8009324 <__ssprint_r>
 8009b44:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8009b48:	9805      	ldr	r0, [sp, #20]
 8009b4a:	f013 0f40 	tst.w	r3, #64	; 0x40
 8009b4e:	bf18      	it	ne
 8009b50:	f04f 30ff 	movne.w	r0, #4294967295
 8009b54:	9005      	str	r0, [sp, #20]
 8009b56:	9805      	ldr	r0, [sp, #20]
 8009b58:	b02b      	add	sp, #172	; 0xac
 8009b5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009b5e:	9804      	ldr	r0, [sp, #16]
 8009b60:	9d02      	ldr	r5, [sp, #8]
 8009b62:	1b44      	subs	r4, r0, r5
 8009b64:	2c00      	cmp	r4, #0
 8009b66:	bfd8      	it	le
 8009b68:	f106 0108 	addle.w	r1, r6, #8
 8009b6c:	f77f af44 	ble.w	80099f8 <_svfiprintf_r+0x5cc>
 8009b70:	2c10      	cmp	r4, #16
 8009b72:	f340 81ac 	ble.w	8009ece <_svfiprintf_r+0xaa2>
 8009b76:	4d36      	ldr	r5, [pc, #216]	; (8009c50 <_svfiprintf_r+0x824>)
 8009b78:	f04f 0810 	mov.w	r8, #16
 8009b7c:	e002      	b.n	8009b84 <_svfiprintf_r+0x758>
 8009b7e:	3c10      	subs	r4, #16
 8009b80:	2c10      	cmp	r4, #16
 8009b82:	dd1b      	ble.n	8009bbc <_svfiprintf_r+0x790>
 8009b84:	3301      	adds	r3, #1
 8009b86:	6035      	str	r5, [r6, #0]
 8009b88:	f8c6 8004 	str.w	r8, [r6, #4]
 8009b8c:	3210      	adds	r2, #16
 8009b8e:	3608      	adds	r6, #8
 8009b90:	2b07      	cmp	r3, #7
 8009b92:	9327      	str	r3, [sp, #156]	; 0x9c
 8009b94:	f106 0c08 	add.w	ip, r6, #8
 8009b98:	9228      	str	r2, [sp, #160]	; 0xa0
 8009b9a:	ddf0      	ble.n	8009b7e <_svfiprintf_r+0x752>
 8009b9c:	4649      	mov	r1, r9
 8009b9e:	4658      	mov	r0, fp
 8009ba0:	aa26      	add	r2, sp, #152	; 0x98
 8009ba2:	ae0c      	add	r6, sp, #48	; 0x30
 8009ba4:	f7ff fbbe 	bl	8009324 <__ssprint_r>
 8009ba8:	a90c      	add	r1, sp, #48	; 0x30
 8009baa:	f101 0c08 	add.w	ip, r1, #8
 8009bae:	2800      	cmp	r0, #0
 8009bb0:	d1c8      	bne.n	8009b44 <_svfiprintf_r+0x718>
 8009bb2:	3c10      	subs	r4, #16
 8009bb4:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009bb6:	2c10      	cmp	r4, #16
 8009bb8:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009bba:	dce3      	bgt.n	8009b84 <_svfiprintf_r+0x758>
 8009bbc:	3301      	adds	r3, #1
 8009bbe:	6035      	str	r5, [r6, #0]
 8009bc0:	2b07      	cmp	r3, #7
 8009bc2:	6074      	str	r4, [r6, #4]
 8009bc4:	4422      	add	r2, r4
 8009bc6:	9327      	str	r3, [sp, #156]	; 0x9c
 8009bc8:	9228      	str	r2, [sp, #160]	; 0xa0
 8009bca:	bfdc      	itt	le
 8009bcc:	f10c 0108 	addle.w	r1, ip, #8
 8009bd0:	4666      	movle	r6, ip
 8009bd2:	f77f af11 	ble.w	80099f8 <_svfiprintf_r+0x5cc>
 8009bd6:	4658      	mov	r0, fp
 8009bd8:	4649      	mov	r1, r9
 8009bda:	aa26      	add	r2, sp, #152	; 0x98
 8009bdc:	f7ff fba2 	bl	8009324 <__ssprint_r>
 8009be0:	2800      	cmp	r0, #0
 8009be2:	d1af      	bne.n	8009b44 <_svfiprintf_r+0x718>
 8009be4:	ab0c      	add	r3, sp, #48	; 0x30
 8009be6:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009be8:	f103 0108 	add.w	r1, r3, #8
 8009bec:	ae0c      	add	r6, sp, #48	; 0x30
 8009bee:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009bf0:	e702      	b.n	80099f8 <_svfiprintf_r+0x5cc>
 8009bf2:	4658      	mov	r0, fp
 8009bf4:	4649      	mov	r1, r9
 8009bf6:	aa26      	add	r2, sp, #152	; 0x98
 8009bf8:	f7ff fb94 	bl	8009324 <__ssprint_r>
 8009bfc:	2800      	cmp	r0, #0
 8009bfe:	d1a1      	bne.n	8009b44 <_svfiprintf_r+0x718>
 8009c00:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009c02:	a90c      	add	r1, sp, #48	; 0x30
 8009c04:	e747      	b.n	8009a96 <_svfiprintf_r+0x66a>
 8009c06:	4658      	mov	r0, fp
 8009c08:	4649      	mov	r1, r9
 8009c0a:	aa26      	add	r2, sp, #152	; 0x98
 8009c0c:	f7ff fb8a 	bl	8009324 <__ssprint_r>
 8009c10:	2800      	cmp	r0, #0
 8009c12:	f43f af7e 	beq.w	8009b12 <_svfiprintf_r+0x6e6>
 8009c16:	e795      	b.n	8009b44 <_svfiprintf_r+0x718>
 8009c18:	ab26      	add	r3, sp, #152	; 0x98
 8009c1a:	9203      	str	r2, [sp, #12]
 8009c1c:	9309      	str	r3, [sp, #36]	; 0x24
 8009c1e:	e50d      	b.n	800963c <_svfiprintf_r+0x210>
 8009c20:	4658      	mov	r0, fp
 8009c22:	4649      	mov	r1, r9
 8009c24:	aa26      	add	r2, sp, #152	; 0x98
 8009c26:	f7ff fb7d 	bl	8009324 <__ssprint_r>
 8009c2a:	2800      	cmp	r0, #0
 8009c2c:	d18a      	bne.n	8009b44 <_svfiprintf_r+0x718>
 8009c2e:	ae0c      	add	r6, sp, #48	; 0x30
 8009c30:	e43b      	b.n	80094aa <_svfiprintf_r+0x7e>
 8009c32:	4658      	mov	r0, fp
 8009c34:	4649      	mov	r1, r9
 8009c36:	aa26      	add	r2, sp, #152	; 0x98
 8009c38:	f7ff fb74 	bl	8009324 <__ssprint_r>
 8009c3c:	2800      	cmp	r0, #0
 8009c3e:	d181      	bne.n	8009b44 <_svfiprintf_r+0x718>
 8009c40:	ad0c      	add	r5, sp, #48	; 0x30
 8009c42:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009c44:	f105 0108 	add.w	r1, r5, #8
 8009c48:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009c4a:	462e      	mov	r6, r5
 8009c4c:	e6c1      	b.n	80099d2 <_svfiprintf_r+0x5a6>
 8009c4e:	bf00      	nop
 8009c50:	0800b928 	.word	0x0800b928
 8009c54:	4658      	mov	r0, fp
 8009c56:	4649      	mov	r1, r9
 8009c58:	aa26      	add	r2, sp, #152	; 0x98
 8009c5a:	f7ff fb63 	bl	8009324 <__ssprint_r>
 8009c5e:	2800      	cmp	r0, #0
 8009c60:	f47f af70 	bne.w	8009b44 <_svfiprintf_r+0x718>
 8009c64:	ab0c      	add	r3, sp, #48	; 0x30
 8009c66:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009c68:	f103 0108 	add.w	r1, r3, #8
 8009c6c:	ae0c      	add	r6, sp, #48	; 0x30
 8009c6e:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009c70:	e6be      	b.n	80099f0 <_svfiprintf_r+0x5c4>
 8009c72:	2c0a      	cmp	r4, #10
 8009c74:	f175 0300 	sbcs.w	r3, r5, #0
 8009c78:	f0c0 8086 	bcc.w	8009d88 <_svfiprintf_r+0x95c>
 8009c7c:	a91c      	add	r1, sp, #112	; 0x70
 8009c7e:	9703      	str	r7, [sp, #12]
 8009c80:	f101 0327 	add.w	r3, r1, #39	; 0x27
 8009c84:	9102      	str	r1, [sp, #8]
 8009c86:	461f      	mov	r7, r3
 8009c88:	9607      	str	r6, [sp, #28]
 8009c8a:	4620      	mov	r0, r4
 8009c8c:	4629      	mov	r1, r5
 8009c8e:	220a      	movs	r2, #10
 8009c90:	2300      	movs	r3, #0
 8009c92:	f001 f989 	bl	800afa8 <__aeabi_uldivmod>
 8009c96:	463e      	mov	r6, r7
 8009c98:	4620      	mov	r0, r4
 8009c9a:	4629      	mov	r1, r5
 8009c9c:	2300      	movs	r3, #0
 8009c9e:	3f01      	subs	r7, #1
 8009ca0:	f102 0430 	add.w	r4, r2, #48	; 0x30
 8009ca4:	220a      	movs	r2, #10
 8009ca6:	7034      	strb	r4, [r6, #0]
 8009ca8:	f001 f97e 	bl	800afa8 <__aeabi_uldivmod>
 8009cac:	4604      	mov	r4, r0
 8009cae:	460d      	mov	r5, r1
 8009cb0:	ea54 0205 	orrs.w	r2, r4, r5
 8009cb4:	d1e9      	bne.n	8009c8a <_svfiprintf_r+0x85e>
 8009cb6:	9609      	str	r6, [sp, #36]	; 0x24
 8009cb8:	9f03      	ldr	r7, [sp, #12]
 8009cba:	9e07      	ldr	r6, [sp, #28]
 8009cbc:	e01a      	b.n	8009cf4 <_svfiprintf_r+0x8c8>
 8009cbe:	ad26      	add	r5, sp, #152	; 0x98
 8009cc0:	9303      	str	r3, [sp, #12]
 8009cc2:	9509      	str	r5, [sp, #36]	; 0x24
 8009cc4:	e4ba      	b.n	800963c <_svfiprintf_r+0x210>
 8009cc6:	a91c      	add	r1, sp, #112	; 0x70
 8009cc8:	f8dd c020 	ldr.w	ip, [sp, #32]
 8009ccc:	f101 0027 	add.w	r0, r1, #39	; 0x27
 8009cd0:	9102      	str	r1, [sp, #8]
 8009cd2:	f004 020f 	and.w	r2, r4, #15
 8009cd6:	0923      	lsrs	r3, r4, #4
 8009cd8:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 8009cdc:	0929      	lsrs	r1, r5, #4
 8009cde:	f81c 2002 	ldrb.w	r2, [ip, r2]
 8009ce2:	461c      	mov	r4, r3
 8009ce4:	4603      	mov	r3, r0
 8009ce6:	460d      	mov	r5, r1
 8009ce8:	3801      	subs	r0, #1
 8009cea:	701a      	strb	r2, [r3, #0]
 8009cec:	ea54 0205 	orrs.w	r2, r4, r5
 8009cf0:	d1ef      	bne.n	8009cd2 <_svfiprintf_r+0x8a6>
 8009cf2:	9309      	str	r3, [sp, #36]	; 0x24
 8009cf4:	9d02      	ldr	r5, [sp, #8]
 8009cf6:	9809      	ldr	r0, [sp, #36]	; 0x24
 8009cf8:	f105 0328 	add.w	r3, r5, #40	; 0x28
 8009cfc:	1a1b      	subs	r3, r3, r0
 8009cfe:	9303      	str	r3, [sp, #12]
 8009d00:	e49c      	b.n	800963c <_svfiprintf_r+0x210>
 8009d02:	f01a 0f10 	tst.w	sl, #16
 8009d06:	d168      	bne.n	8009dda <_svfiprintf_r+0x9ae>
 8009d08:	f01a 0f40 	tst.w	sl, #64	; 0x40
 8009d0c:	f000 8096 	beq.w	8009e3c <_svfiprintf_r+0xa10>
 8009d10:	9b06      	ldr	r3, [sp, #24]
 8009d12:	f9b3 4000 	ldrsh.w	r4, [r3]
 8009d16:	3304      	adds	r3, #4
 8009d18:	9306      	str	r3, [sp, #24]
 8009d1a:	17e5      	asrs	r5, r4, #31
 8009d1c:	e4b7      	b.n	800968e <_svfiprintf_r+0x262>
 8009d1e:	f01a 0f10 	tst.w	sl, #16
 8009d22:	d172      	bne.n	8009e0a <_svfiprintf_r+0x9de>
 8009d24:	f01a 0f40 	tst.w	sl, #64	; 0x40
 8009d28:	f000 809f 	beq.w	8009e6a <_svfiprintf_r+0xa3e>
 8009d2c:	9b06      	ldr	r3, [sp, #24]
 8009d2e:	881a      	ldrh	r2, [r3, #0]
 8009d30:	2301      	movs	r3, #1
 8009d32:	e009      	b.n	8009d48 <_svfiprintf_r+0x91c>
 8009d34:	f01a 0110 	ands.w	r1, sl, #16
 8009d38:	d141      	bne.n	8009dbe <_svfiprintf_r+0x992>
 8009d3a:	f01a 0340 	ands.w	r3, sl, #64	; 0x40
 8009d3e:	f000 8083 	beq.w	8009e48 <_svfiprintf_r+0xa1c>
 8009d42:	9b06      	ldr	r3, [sp, #24]
 8009d44:	881a      	ldrh	r2, [r3, #0]
 8009d46:	460b      	mov	r3, r1
 8009d48:	9d06      	ldr	r5, [sp, #24]
 8009d4a:	4614      	mov	r4, r2
 8009d4c:	3504      	adds	r5, #4
 8009d4e:	9506      	str	r5, [sp, #24]
 8009d50:	2500      	movs	r5, #0
 8009d52:	3a00      	subs	r2, #0
 8009d54:	bf18      	it	ne
 8009d56:	2201      	movne	r2, #1
 8009d58:	e431      	b.n	80095be <_svfiprintf_r+0x192>
 8009d5a:	2302      	movs	r3, #2
 8009d5c:	e42f      	b.n	80095be <_svfiprintf_r+0x192>
 8009d5e:	783b      	ldrb	r3, [r7, #0]
 8009d60:	9206      	str	r2, [sp, #24]
 8009d62:	f7ff bbb6 	b.w	80094d2 <_svfiprintf_r+0xa6>
 8009d66:	4658      	mov	r0, fp
 8009d68:	4649      	mov	r1, r9
 8009d6a:	aa26      	add	r2, sp, #152	; 0x98
 8009d6c:	f7ff fada 	bl	8009324 <__ssprint_r>
 8009d70:	2800      	cmp	r0, #0
 8009d72:	f47f aee7 	bne.w	8009b44 <_svfiprintf_r+0x718>
 8009d76:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009d78:	e6c1      	b.n	8009afe <_svfiprintf_r+0x6d2>
 8009d7a:	9902      	ldr	r1, [sp, #8]
 8009d7c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8009d7e:	f101 0328 	add.w	r3, r1, #40	; 0x28
 8009d82:	1a9b      	subs	r3, r3, r2
 8009d84:	9303      	str	r3, [sp, #12]
 8009d86:	e459      	b.n	800963c <_svfiprintf_r+0x210>
 8009d88:	3430      	adds	r4, #48	; 0x30
 8009d8a:	2501      	movs	r5, #1
 8009d8c:	f10d 0097 	add.w	r0, sp, #151	; 0x97
 8009d90:	9503      	str	r5, [sp, #12]
 8009d92:	f88d 4097 	strb.w	r4, [sp, #151]	; 0x97
 8009d96:	9009      	str	r0, [sp, #36]	; 0x24
 8009d98:	e450      	b.n	800963c <_svfiprintf_r+0x210>
 8009d9a:	9b06      	ldr	r3, [sp, #24]
 8009d9c:	9d05      	ldr	r5, [sp, #20]
 8009d9e:	9806      	ldr	r0, [sp, #24]
 8009da0:	6819      	ldr	r1, [r3, #0]
 8009da2:	462a      	mov	r2, r5
 8009da4:	17eb      	asrs	r3, r5, #31
 8009da6:	3004      	adds	r0, #4
 8009da8:	9006      	str	r0, [sp, #24]
 8009daa:	e9c1 2300 	strd	r2, r3, [r1]
 8009dae:	f7ff bb53 	b.w	8009458 <_svfiprintf_r+0x2c>
 8009db2:	9906      	ldr	r1, [sp, #24]
 8009db4:	2500      	movs	r5, #0
 8009db6:	680c      	ldr	r4, [r1, #0]
 8009db8:	3104      	adds	r1, #4
 8009dba:	9106      	str	r1, [sp, #24]
 8009dbc:	e510      	b.n	80097e0 <_svfiprintf_r+0x3b4>
 8009dbe:	9906      	ldr	r1, [sp, #24]
 8009dc0:	680a      	ldr	r2, [r1, #0]
 8009dc2:	3104      	adds	r1, #4
 8009dc4:	4614      	mov	r4, r2
 8009dc6:	2500      	movs	r5, #0
 8009dc8:	3a00      	subs	r2, #0
 8009dca:	9106      	str	r1, [sp, #24]
 8009dcc:	bf18      	it	ne
 8009dce:	2201      	movne	r2, #1
 8009dd0:	f7ff bbf5 	b.w	80095be <_svfiprintf_r+0x192>
 8009dd4:	783b      	ldrb	r3, [r7, #0]
 8009dd6:	f7ff bb7c 	b.w	80094d2 <_svfiprintf_r+0xa6>
 8009dda:	9a06      	ldr	r2, [sp, #24]
 8009ddc:	6814      	ldr	r4, [r2, #0]
 8009dde:	3204      	adds	r2, #4
 8009de0:	9206      	str	r2, [sp, #24]
 8009de2:	17e5      	asrs	r5, r4, #31
 8009de4:	2c00      	cmp	r4, #0
 8009de6:	f175 0000 	sbcs.w	r0, r5, #0
 8009dea:	f6bf ac55 	bge.w	8009698 <_svfiprintf_r+0x26c>
 8009dee:	4264      	negs	r4, r4
 8009df0:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 8009df4:	232d      	movs	r3, #45	; 0x2d
 8009df6:	ea54 0205 	orrs.w	r2, r4, r5
 8009dfa:	f88d 30a7 	strb.w	r3, [sp, #167]	; 0xa7
 8009dfe:	bf0c      	ite	eq
 8009e00:	2200      	moveq	r2, #0
 8009e02:	2201      	movne	r2, #1
 8009e04:	2301      	movs	r3, #1
 8009e06:	f7ff bbdd 	b.w	80095c4 <_svfiprintf_r+0x198>
 8009e0a:	9906      	ldr	r1, [sp, #24]
 8009e0c:	2301      	movs	r3, #1
 8009e0e:	680a      	ldr	r2, [r1, #0]
 8009e10:	e7d7      	b.n	8009dc2 <_svfiprintf_r+0x996>
 8009e12:	9809      	ldr	r0, [sp, #36]	; 0x24
 8009e14:	2100      	movs	r1, #0
 8009e16:	9107      	str	r1, [sp, #28]
 8009e18:	f7ff fa54 	bl	80092c4 <strlen>
 8009e1c:	9003      	str	r0, [sp, #12]
 8009e1e:	e40f      	b.n	8009640 <_svfiprintf_r+0x214>
 8009e20:	9906      	ldr	r1, [sp, #24]
 8009e22:	9a05      	ldr	r2, [sp, #20]
 8009e24:	680b      	ldr	r3, [r1, #0]
 8009e26:	3104      	adds	r1, #4
 8009e28:	9106      	str	r1, [sp, #24]
 8009e2a:	601a      	str	r2, [r3, #0]
 8009e2c:	f7ff bb14 	b.w	8009458 <_svfiprintf_r+0x2c>
 8009e30:	4d35      	ldr	r5, [pc, #212]	; (8009f08 <_svfiprintf_r+0xadc>)
 8009e32:	468c      	mov	ip, r1
 8009e34:	e60b      	b.n	8009a4e <_svfiprintf_r+0x622>
 8009e36:	2300      	movs	r3, #0
 8009e38:	9307      	str	r3, [sp, #28]
 8009e3a:	e401      	b.n	8009640 <_svfiprintf_r+0x214>
 8009e3c:	9d06      	ldr	r5, [sp, #24]
 8009e3e:	682c      	ldr	r4, [r5, #0]
 8009e40:	3504      	adds	r5, #4
 8009e42:	9506      	str	r5, [sp, #24]
 8009e44:	17e5      	asrs	r5, r4, #31
 8009e46:	e422      	b.n	800968e <_svfiprintf_r+0x262>
 8009e48:	9806      	ldr	r0, [sp, #24]
 8009e4a:	6802      	ldr	r2, [r0, #0]
 8009e4c:	3004      	adds	r0, #4
 8009e4e:	4614      	mov	r4, r2
 8009e50:	2500      	movs	r5, #0
 8009e52:	3a00      	subs	r2, #0
 8009e54:	9006      	str	r0, [sp, #24]
 8009e56:	bf18      	it	ne
 8009e58:	2201      	movne	r2, #1
 8009e5a:	f7ff bbb0 	b.w	80095be <_svfiprintf_r+0x192>
 8009e5e:	9d06      	ldr	r5, [sp, #24]
 8009e60:	682c      	ldr	r4, [r5, #0]
 8009e62:	3504      	adds	r5, #4
 8009e64:	9506      	str	r5, [sp, #24]
 8009e66:	2500      	movs	r5, #0
 8009e68:	e4ba      	b.n	80097e0 <_svfiprintf_r+0x3b4>
 8009e6a:	9806      	ldr	r0, [sp, #24]
 8009e6c:	2301      	movs	r3, #1
 8009e6e:	6802      	ldr	r2, [r0, #0]
 8009e70:	e7ec      	b.n	8009e4c <_svfiprintf_r+0xa20>
 8009e72:	2140      	movs	r1, #64	; 0x40
 8009e74:	9201      	str	r2, [sp, #4]
 8009e76:	f7fa ff0f 	bl	8004c98 <_malloc_r>
 8009e7a:	9a01      	ldr	r2, [sp, #4]
 8009e7c:	f8c9 0000 	str.w	r0, [r9]
 8009e80:	f8c9 0010 	str.w	r0, [r9, #16]
 8009e84:	2800      	cmp	r0, #0
 8009e86:	d038      	beq.n	8009efa <_svfiprintf_r+0xace>
 8009e88:	2340      	movs	r3, #64	; 0x40
 8009e8a:	f8c9 3014 	str.w	r3, [r9, #20]
 8009e8e:	f7ff badb 	b.w	8009448 <_svfiprintf_r+0x1c>
 8009e92:	f64b 1518 	movw	r5, #47384	; 0xb918
 8009e96:	f106 0c08 	add.w	ip, r6, #8
 8009e9a:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8009e9c:	f6c0 0500 	movt	r5, #2048	; 0x800
 8009ea0:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009ea2:	e4fe      	b.n	80098a2 <_svfiprintf_r+0x476>
 8009ea4:	f64b 1518 	movw	r5, #47384	; 0xb918
 8009ea8:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8009eaa:	f6c0 0500 	movt	r5, #2048	; 0x800
 8009eae:	e61d      	b.n	8009aec <_svfiprintf_r+0x6c0>
 8009eb0:	f1b8 0f06 	cmp.w	r8, #6
 8009eb4:	bf34      	ite	cc
 8009eb6:	4641      	movcc	r1, r8
 8009eb8:	2106      	movcs	r1, #6
 8009eba:	f64b 3274 	movw	r2, #47988	; 0xbb74
 8009ebe:	ea21 73e1 	bic.w	r3, r1, r1, asr #31
 8009ec2:	f6c0 0200 	movt	r2, #2048	; 0x800
 8009ec6:	9103      	str	r1, [sp, #12]
 8009ec8:	9302      	str	r3, [sp, #8]
 8009eca:	9209      	str	r2, [sp, #36]	; 0x24
 8009ecc:	e4a9      	b.n	8009822 <_svfiprintf_r+0x3f6>
 8009ece:	4d0e      	ldr	r5, [pc, #56]	; (8009f08 <_svfiprintf_r+0xadc>)
 8009ed0:	468c      	mov	ip, r1
 8009ed2:	e673      	b.n	8009bbc <_svfiprintf_r+0x790>
 8009ed4:	f8cd 800c 	str.w	r8, [sp, #12]
 8009ed8:	9007      	str	r0, [sp, #28]
 8009eda:	f7ff bbb1 	b.w	8009640 <_svfiprintf_r+0x214>
 8009ede:	9d06      	ldr	r5, [sp, #24]
 8009ee0:	1d2a      	adds	r2, r5, #4
 8009ee2:	f8d5 8000 	ldr.w	r8, [r5]
 8009ee6:	f1b8 0f00 	cmp.w	r8, #0
 8009eea:	f6bf af38 	bge.w	8009d5e <_svfiprintf_r+0x932>
 8009eee:	783b      	ldrb	r3, [r7, #0]
 8009ef0:	f04f 38ff 	mov.w	r8, #4294967295
 8009ef4:	9206      	str	r2, [sp, #24]
 8009ef6:	f7ff baec 	b.w	80094d2 <_svfiprintf_r+0xa6>
 8009efa:	3801      	subs	r0, #1
 8009efc:	230c      	movs	r3, #12
 8009efe:	9005      	str	r0, [sp, #20]
 8009f00:	f8cb 3000 	str.w	r3, [fp]
 8009f04:	e627      	b.n	8009b56 <_svfiprintf_r+0x72a>
 8009f06:	bf00      	nop
 8009f08:	0800b928 	.word	0x0800b928

08009f0c <_calloc_r>:
 8009f0c:	b538      	push	{r3, r4, r5, lr}
 8009f0e:	fb01 f102 	mul.w	r1, r1, r2
 8009f12:	f7fa fec1 	bl	8004c98 <_malloc_r>
 8009f16:	4604      	mov	r4, r0
 8009f18:	b1f8      	cbz	r0, 8009f5a <_calloc_r+0x4e>
 8009f1a:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8009f1e:	f022 0203 	bic.w	r2, r2, #3
 8009f22:	3a04      	subs	r2, #4
 8009f24:	2a24      	cmp	r2, #36	; 0x24
 8009f26:	d81a      	bhi.n	8009f5e <_calloc_r+0x52>
 8009f28:	2a13      	cmp	r2, #19
 8009f2a:	4603      	mov	r3, r0
 8009f2c:	d90f      	bls.n	8009f4e <_calloc_r+0x42>
 8009f2e:	2100      	movs	r1, #0
 8009f30:	f840 1b04 	str.w	r1, [r0], #4
 8009f34:	1d03      	adds	r3, r0, #4
 8009f36:	2a1b      	cmp	r2, #27
 8009f38:	6061      	str	r1, [r4, #4]
 8009f3a:	d908      	bls.n	8009f4e <_calloc_r+0x42>
 8009f3c:	1d1d      	adds	r5, r3, #4
 8009f3e:	6041      	str	r1, [r0, #4]
 8009f40:	6059      	str	r1, [r3, #4]
 8009f42:	3308      	adds	r3, #8
 8009f44:	2a24      	cmp	r2, #36	; 0x24
 8009f46:	bf02      	ittt	eq
 8009f48:	6069      	streq	r1, [r5, #4]
 8009f4a:	6059      	streq	r1, [r3, #4]
 8009f4c:	3308      	addeq	r3, #8
 8009f4e:	461a      	mov	r2, r3
 8009f50:	2100      	movs	r1, #0
 8009f52:	f842 1b04 	str.w	r1, [r2], #4
 8009f56:	6059      	str	r1, [r3, #4]
 8009f58:	6051      	str	r1, [r2, #4]
 8009f5a:	4620      	mov	r0, r4
 8009f5c:	bd38      	pop	{r3, r4, r5, pc}
 8009f5e:	2100      	movs	r1, #0
 8009f60:	f7fb fe9e 	bl	8005ca0 <memset>
 8009f64:	4620      	mov	r0, r4
 8009f66:	bd38      	pop	{r3, r4, r5, pc}

08009f68 <memmove>:
 8009f68:	4288      	cmp	r0, r1
 8009f6a:	4603      	mov	r3, r0
 8009f6c:	b4f0      	push	{r4, r5, r6, r7}
 8009f6e:	460c      	mov	r4, r1
 8009f70:	d90e      	bls.n	8009f90 <memmove+0x28>
 8009f72:	188d      	adds	r5, r1, r2
 8009f74:	42a8      	cmp	r0, r5
 8009f76:	d20b      	bcs.n	8009f90 <memmove+0x28>
 8009f78:	b142      	cbz	r2, 8009f8c <memmove+0x24>
 8009f7a:	1883      	adds	r3, r0, r2
 8009f7c:	4629      	mov	r1, r5
 8009f7e:	1a9a      	subs	r2, r3, r2
 8009f80:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
 8009f84:	f803 4d01 	strb.w	r4, [r3, #-1]!
 8009f88:	4293      	cmp	r3, r2
 8009f8a:	d1f9      	bne.n	8009f80 <memmove+0x18>
 8009f8c:	bcf0      	pop	{r4, r5, r6, r7}
 8009f8e:	4770      	bx	lr
 8009f90:	2a0f      	cmp	r2, #15
 8009f92:	d938      	bls.n	800a006 <memmove+0x9e>
 8009f94:	ea41 0500 	orr.w	r5, r1, r0
 8009f98:	f015 0f03 	tst.w	r5, #3
 8009f9c:	d135      	bne.n	800a00a <memmove+0xa2>
 8009f9e:	f1a2 0610 	sub.w	r6, r2, #16
 8009fa2:	f101 0510 	add.w	r5, r1, #16
 8009fa6:	460b      	mov	r3, r1
 8009fa8:	4602      	mov	r2, r0
 8009faa:	0937      	lsrs	r7, r6, #4
 8009fac:	eb05 1507 	add.w	r5, r5, r7, lsl #4
 8009fb0:	681c      	ldr	r4, [r3, #0]
 8009fb2:	6014      	str	r4, [r2, #0]
 8009fb4:	685c      	ldr	r4, [r3, #4]
 8009fb6:	6054      	str	r4, [r2, #4]
 8009fb8:	689c      	ldr	r4, [r3, #8]
 8009fba:	6094      	str	r4, [r2, #8]
 8009fbc:	68dc      	ldr	r4, [r3, #12]
 8009fbe:	3310      	adds	r3, #16
 8009fc0:	60d4      	str	r4, [r2, #12]
 8009fc2:	3210      	adds	r2, #16
 8009fc4:	429d      	cmp	r5, r3
 8009fc6:	d1f3      	bne.n	8009fb0 <memmove+0x48>
 8009fc8:	1c7c      	adds	r4, r7, #1
 8009fca:	f006 020f 	and.w	r2, r6, #15
 8009fce:	0124      	lsls	r4, r4, #4
 8009fd0:	2a03      	cmp	r2, #3
 8009fd2:	eb00 0304 	add.w	r3, r0, r4
 8009fd6:	4421      	add	r1, r4
 8009fd8:	d914      	bls.n	800a004 <memmove+0x9c>
 8009fda:	3a04      	subs	r2, #4
 8009fdc:	460c      	mov	r4, r1
 8009fde:	461d      	mov	r5, r3
 8009fe0:	ea4f 0c92 	mov.w	ip, r2, lsr #2
 8009fe4:	eb01 078c 	add.w	r7, r1, ip, lsl #2
 8009fe8:	3704      	adds	r7, #4
 8009fea:	f854 6b04 	ldr.w	r6, [r4], #4
 8009fee:	42bc      	cmp	r4, r7
 8009ff0:	f845 6b04 	str.w	r6, [r5], #4
 8009ff4:	d1f9      	bne.n	8009fea <memmove+0x82>
 8009ff6:	f10c 0401 	add.w	r4, ip, #1
 8009ffa:	f002 0203 	and.w	r2, r2, #3
 8009ffe:	00a4      	lsls	r4, r4, #2
 800a000:	191b      	adds	r3, r3, r4
 800a002:	1909      	adds	r1, r1, r4
 800a004:	460c      	mov	r4, r1
 800a006:	2a00      	cmp	r2, #0
 800a008:	d0c0      	beq.n	8009f8c <memmove+0x24>
 800a00a:	4621      	mov	r1, r4
 800a00c:	18a2      	adds	r2, r4, r2
 800a00e:	f811 4b01 	ldrb.w	r4, [r1], #1
 800a012:	4291      	cmp	r1, r2
 800a014:	f803 4b01 	strb.w	r4, [r3], #1
 800a018:	d1f9      	bne.n	800a00e <memmove+0xa6>
 800a01a:	e7b7      	b.n	8009f8c <memmove+0x24>

0800a01c <_realloc_r>:
 800a01c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a020:	460d      	mov	r5, r1
 800a022:	b083      	sub	sp, #12
 800a024:	4607      	mov	r7, r0
 800a026:	4690      	mov	r8, r2
 800a028:	2900      	cmp	r1, #0
 800a02a:	f000 8155 	beq.w	800a2d8 <_realloc_r+0x2bc>
 800a02e:	f108 040b 	add.w	r4, r8, #11
 800a032:	f1a1 0a08 	sub.w	sl, r1, #8
 800a036:	f7fb f8ed 	bl	8005214 <__malloc_lock>
 800a03a:	2c16      	cmp	r4, #22
 800a03c:	f8da 3004 	ldr.w	r3, [sl, #4]
 800a040:	f200 8097 	bhi.w	800a172 <_realloc_r+0x156>
 800a044:	2210      	movs	r2, #16
 800a046:	2000      	movs	r0, #0
 800a048:	4614      	mov	r4, r2
 800a04a:	4544      	cmp	r4, r8
 800a04c:	bf38      	it	cc
 800a04e:	f040 0001 	orrcc.w	r0, r0, #1
 800a052:	2800      	cmp	r0, #0
 800a054:	f040 8146 	bne.w	800a2e4 <_realloc_r+0x2c8>
 800a058:	f023 0b03 	bic.w	fp, r3, #3
 800a05c:	4593      	cmp	fp, r2
 800a05e:	bfa4      	itt	ge
 800a060:	f10a 0808 	addge.w	r8, sl, #8
 800a064:	465e      	movge	r6, fp
 800a066:	da6e      	bge.n	800a146 <_realloc_r+0x12a>
 800a068:	f240 3960 	movw	r9, #864	; 0x360
 800a06c:	eb0a 010b 	add.w	r1, sl, fp
 800a070:	f2c2 0900 	movt	r9, #8192	; 0x2000
 800a074:	f8d9 e008 	ldr.w	lr, [r9, #8]
 800a078:	458e      	cmp	lr, r1
 800a07a:	f000 8138 	beq.w	800a2ee <_realloc_r+0x2d2>
 800a07e:	684e      	ldr	r6, [r1, #4]
 800a080:	f026 0c01 	bic.w	ip, r6, #1
 800a084:	448c      	add	ip, r1
 800a086:	f8dc c004 	ldr.w	ip, [ip, #4]
 800a08a:	f01c 0f01 	tst.w	ip, #1
 800a08e:	bf18      	it	ne
 800a090:	4601      	movne	r1, r0
 800a092:	d073      	beq.n	800a17c <_realloc_r+0x160>
 800a094:	f013 0f01 	tst.w	r3, #1
 800a098:	f040 8092 	bne.w	800a1c0 <_realloc_r+0x1a4>
 800a09c:	f855 3c08 	ldr.w	r3, [r5, #-8]
 800a0a0:	ebc3 0c0a 	rsb	ip, r3, sl
 800a0a4:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800a0a8:	f023 0303 	bic.w	r3, r3, #3
 800a0ac:	2900      	cmp	r1, #0
 800a0ae:	f000 80d1 	beq.w	800a254 <_realloc_r+0x238>
 800a0b2:	4571      	cmp	r1, lr
 800a0b4:	f000 814f 	beq.w	800a356 <_realloc_r+0x33a>
 800a0b8:	445b      	add	r3, fp
 800a0ba:	18c6      	adds	r6, r0, r3
 800a0bc:	42b2      	cmp	r2, r6
 800a0be:	f300 80ca 	bgt.w	800a256 <_realloc_r+0x23a>
 800a0c2:	68cb      	ldr	r3, [r1, #12]
 800a0c4:	46e0      	mov	r8, ip
 800a0c6:	6889      	ldr	r1, [r1, #8]
 800a0c8:	f1ab 0204 	sub.w	r2, fp, #4
 800a0cc:	2a24      	cmp	r2, #36	; 0x24
 800a0ce:	60cb      	str	r3, [r1, #12]
 800a0d0:	6099      	str	r1, [r3, #8]
 800a0d2:	f8dc 300c 	ldr.w	r3, [ip, #12]
 800a0d6:	f858 1f08 	ldr.w	r1, [r8, #8]!
 800a0da:	60cb      	str	r3, [r1, #12]
 800a0dc:	6099      	str	r1, [r3, #8]
 800a0de:	f200 8196 	bhi.w	800a40e <_realloc_r+0x3f2>
 800a0e2:	2a13      	cmp	r2, #19
 800a0e4:	4641      	mov	r1, r8
 800a0e6:	d921      	bls.n	800a12c <_realloc_r+0x110>
 800a0e8:	462b      	mov	r3, r5
 800a0ea:	f10c 0110 	add.w	r1, ip, #16
 800a0ee:	f853 0b04 	ldr.w	r0, [r3], #4
 800a0f2:	f8cc 0008 	str.w	r0, [ip, #8]
 800a0f6:	6868      	ldr	r0, [r5, #4]
 800a0f8:	1d1d      	adds	r5, r3, #4
 800a0fa:	2a1b      	cmp	r2, #27
 800a0fc:	f8cc 000c 	str.w	r0, [ip, #12]
 800a100:	d914      	bls.n	800a12c <_realloc_r+0x110>
 800a102:	6858      	ldr	r0, [r3, #4]
 800a104:	1d2b      	adds	r3, r5, #4
 800a106:	f10c 0118 	add.w	r1, ip, #24
 800a10a:	f8cc 0010 	str.w	r0, [ip, #16]
 800a10e:	6868      	ldr	r0, [r5, #4]
 800a110:	3508      	adds	r5, #8
 800a112:	2a24      	cmp	r2, #36	; 0x24
 800a114:	f8cc 0014 	str.w	r0, [ip, #20]
 800a118:	d108      	bne.n	800a12c <_realloc_r+0x110>
 800a11a:	685b      	ldr	r3, [r3, #4]
 800a11c:	f10c 0120 	add.w	r1, ip, #32
 800a120:	f8cc 3018 	str.w	r3, [ip, #24]
 800a124:	686b      	ldr	r3, [r5, #4]
 800a126:	3508      	adds	r5, #8
 800a128:	f8cc 301c 	str.w	r3, [ip, #28]
 800a12c:	462a      	mov	r2, r5
 800a12e:	460b      	mov	r3, r1
 800a130:	46e2      	mov	sl, ip
 800a132:	f852 0b04 	ldr.w	r0, [r2], #4
 800a136:	f843 0b04 	str.w	r0, [r3], #4
 800a13a:	6868      	ldr	r0, [r5, #4]
 800a13c:	6048      	str	r0, [r1, #4]
 800a13e:	6852      	ldr	r2, [r2, #4]
 800a140:	605a      	str	r2, [r3, #4]
 800a142:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800a146:	1b30      	subs	r0, r6, r4
 800a148:	280f      	cmp	r0, #15
 800a14a:	d824      	bhi.n	800a196 <_realloc_r+0x17a>
 800a14c:	eb0a 0206 	add.w	r2, sl, r6
 800a150:	f003 0301 	and.w	r3, r3, #1
 800a154:	ea43 0606 	orr.w	r6, r3, r6
 800a158:	f8ca 6004 	str.w	r6, [sl, #4]
 800a15c:	6853      	ldr	r3, [r2, #4]
 800a15e:	f043 0301 	orr.w	r3, r3, #1
 800a162:	6053      	str	r3, [r2, #4]
 800a164:	4638      	mov	r0, r7
 800a166:	f7fb f857 	bl	8005218 <__malloc_unlock>
 800a16a:	4640      	mov	r0, r8
 800a16c:	b003      	add	sp, #12
 800a16e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a172:	f024 0407 	bic.w	r4, r4, #7
 800a176:	4622      	mov	r2, r4
 800a178:	0fe0      	lsrs	r0, r4, #31
 800a17a:	e766      	b.n	800a04a <_realloc_r+0x2e>
 800a17c:	f026 0003 	bic.w	r0, r6, #3
 800a180:	eb00 060b 	add.w	r6, r0, fp
 800a184:	42b2      	cmp	r2, r6
 800a186:	dc85      	bgt.n	800a094 <_realloc_r+0x78>
 800a188:	68ca      	ldr	r2, [r1, #12]
 800a18a:	f10a 0808 	add.w	r8, sl, #8
 800a18e:	6889      	ldr	r1, [r1, #8]
 800a190:	60ca      	str	r2, [r1, #12]
 800a192:	6091      	str	r1, [r2, #8]
 800a194:	e7d7      	b.n	800a146 <_realloc_r+0x12a>
 800a196:	eb0a 0104 	add.w	r1, sl, r4
 800a19a:	f003 0301 	and.w	r3, r3, #1
 800a19e:	180a      	adds	r2, r1, r0
 800a1a0:	ea43 0404 	orr.w	r4, r3, r4
 800a1a4:	f040 0001 	orr.w	r0, r0, #1
 800a1a8:	f8ca 4004 	str.w	r4, [sl, #4]
 800a1ac:	6048      	str	r0, [r1, #4]
 800a1ae:	4638      	mov	r0, r7
 800a1b0:	6853      	ldr	r3, [r2, #4]
 800a1b2:	3108      	adds	r1, #8
 800a1b4:	f043 0301 	orr.w	r3, r3, #1
 800a1b8:	6053      	str	r3, [r2, #4]
 800a1ba:	f7fb fc4f 	bl	8005a5c <_free_r>
 800a1be:	e7d1      	b.n	800a164 <_realloc_r+0x148>
 800a1c0:	4641      	mov	r1, r8
 800a1c2:	4638      	mov	r0, r7
 800a1c4:	f7fa fd68 	bl	8004c98 <_malloc_r>
 800a1c8:	4680      	mov	r8, r0
 800a1ca:	2800      	cmp	r0, #0
 800a1cc:	d0ca      	beq.n	800a164 <_realloc_r+0x148>
 800a1ce:	f8da 3004 	ldr.w	r3, [sl, #4]
 800a1d2:	f1a0 0208 	sub.w	r2, r0, #8
 800a1d6:	f023 0101 	bic.w	r1, r3, #1
 800a1da:	4451      	add	r1, sl
 800a1dc:	428a      	cmp	r2, r1
 800a1de:	f000 810e 	beq.w	800a3fe <_realloc_r+0x3e2>
 800a1e2:	f1ab 0204 	sub.w	r2, fp, #4
 800a1e6:	2a24      	cmp	r2, #36	; 0x24
 800a1e8:	f200 80b1 	bhi.w	800a34e <_realloc_r+0x332>
 800a1ec:	2a13      	cmp	r2, #19
 800a1ee:	4629      	mov	r1, r5
 800a1f0:	4603      	mov	r3, r0
 800a1f2:	d91d      	bls.n	800a230 <_realloc_r+0x214>
 800a1f4:	462c      	mov	r4, r5
 800a1f6:	f854 3b04 	ldr.w	r3, [r4], #4
 800a1fa:	1d21      	adds	r1, r4, #4
 800a1fc:	f840 3b04 	str.w	r3, [r0], #4
 800a200:	1d03      	adds	r3, r0, #4
 800a202:	686e      	ldr	r6, [r5, #4]
 800a204:	2a1b      	cmp	r2, #27
 800a206:	f8c8 6004 	str.w	r6, [r8, #4]
 800a20a:	d911      	bls.n	800a230 <_realloc_r+0x214>
 800a20c:	f8d4 e004 	ldr.w	lr, [r4, #4]
 800a210:	1d0e      	adds	r6, r1, #4
 800a212:	1d1c      	adds	r4, r3, #4
 800a214:	f8c0 e004 	str.w	lr, [r0, #4]
 800a218:	6848      	ldr	r0, [r1, #4]
 800a21a:	3108      	adds	r1, #8
 800a21c:	6058      	str	r0, [r3, #4]
 800a21e:	3308      	adds	r3, #8
 800a220:	2a24      	cmp	r2, #36	; 0x24
 800a222:	d105      	bne.n	800a230 <_realloc_r+0x214>
 800a224:	6872      	ldr	r2, [r6, #4]
 800a226:	6062      	str	r2, [r4, #4]
 800a228:	684a      	ldr	r2, [r1, #4]
 800a22a:	3108      	adds	r1, #8
 800a22c:	605a      	str	r2, [r3, #4]
 800a22e:	3308      	adds	r3, #8
 800a230:	4608      	mov	r0, r1
 800a232:	461a      	mov	r2, r3
 800a234:	f850 4b04 	ldr.w	r4, [r0], #4
 800a238:	f842 4b04 	str.w	r4, [r2], #4
 800a23c:	6849      	ldr	r1, [r1, #4]
 800a23e:	6059      	str	r1, [r3, #4]
 800a240:	6843      	ldr	r3, [r0, #4]
 800a242:	6053      	str	r3, [r2, #4]
 800a244:	4638      	mov	r0, r7
 800a246:	4629      	mov	r1, r5
 800a248:	f7fb fc08 	bl	8005a5c <_free_r>
 800a24c:	4638      	mov	r0, r7
 800a24e:	f7fa ffe3 	bl	8005218 <__malloc_unlock>
 800a252:	e78a      	b.n	800a16a <_realloc_r+0x14e>
 800a254:	445b      	add	r3, fp
 800a256:	429a      	cmp	r2, r3
 800a258:	dcb2      	bgt.n	800a1c0 <_realloc_r+0x1a4>
 800a25a:	46e0      	mov	r8, ip
 800a25c:	f8dc 100c 	ldr.w	r1, [ip, #12]
 800a260:	f1ab 0204 	sub.w	r2, fp, #4
 800a264:	f858 0f08 	ldr.w	r0, [r8, #8]!
 800a268:	2a24      	cmp	r2, #36	; 0x24
 800a26a:	60c1      	str	r1, [r0, #12]
 800a26c:	6088      	str	r0, [r1, #8]
 800a26e:	d85f      	bhi.n	800a330 <_realloc_r+0x314>
 800a270:	2a13      	cmp	r2, #19
 800a272:	4640      	mov	r0, r8
 800a274:	d921      	bls.n	800a2ba <_realloc_r+0x29e>
 800a276:	4629      	mov	r1, r5
 800a278:	f10c 0010 	add.w	r0, ip, #16
 800a27c:	f851 6b04 	ldr.w	r6, [r1], #4
 800a280:	f8cc 6008 	str.w	r6, [ip, #8]
 800a284:	686e      	ldr	r6, [r5, #4]
 800a286:	1d0d      	adds	r5, r1, #4
 800a288:	2a1b      	cmp	r2, #27
 800a28a:	f8cc 600c 	str.w	r6, [ip, #12]
 800a28e:	d914      	bls.n	800a2ba <_realloc_r+0x29e>
 800a290:	684e      	ldr	r6, [r1, #4]
 800a292:	1d29      	adds	r1, r5, #4
 800a294:	f10c 0018 	add.w	r0, ip, #24
 800a298:	f8cc 6010 	str.w	r6, [ip, #16]
 800a29c:	686e      	ldr	r6, [r5, #4]
 800a29e:	3508      	adds	r5, #8
 800a2a0:	2a24      	cmp	r2, #36	; 0x24
 800a2a2:	f8cc 6014 	str.w	r6, [ip, #20]
 800a2a6:	d108      	bne.n	800a2ba <_realloc_r+0x29e>
 800a2a8:	684a      	ldr	r2, [r1, #4]
 800a2aa:	f10c 0020 	add.w	r0, ip, #32
 800a2ae:	f8cc 2018 	str.w	r2, [ip, #24]
 800a2b2:	686a      	ldr	r2, [r5, #4]
 800a2b4:	3508      	adds	r5, #8
 800a2b6:	f8cc 201c 	str.w	r2, [ip, #28]
 800a2ba:	4629      	mov	r1, r5
 800a2bc:	461e      	mov	r6, r3
 800a2be:	4602      	mov	r2, r0
 800a2c0:	46e2      	mov	sl, ip
 800a2c2:	f851 3b04 	ldr.w	r3, [r1], #4
 800a2c6:	f842 3b04 	str.w	r3, [r2], #4
 800a2ca:	686b      	ldr	r3, [r5, #4]
 800a2cc:	6043      	str	r3, [r0, #4]
 800a2ce:	684b      	ldr	r3, [r1, #4]
 800a2d0:	6053      	str	r3, [r2, #4]
 800a2d2:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800a2d6:	e736      	b.n	800a146 <_realloc_r+0x12a>
 800a2d8:	4611      	mov	r1, r2
 800a2da:	b003      	add	sp, #12
 800a2dc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a2e0:	f7fa bcda 	b.w	8004c98 <_malloc_r>
 800a2e4:	230c      	movs	r3, #12
 800a2e6:	f04f 0800 	mov.w	r8, #0
 800a2ea:	603b      	str	r3, [r7, #0]
 800a2ec:	e73d      	b.n	800a16a <_realloc_r+0x14e>
 800a2ee:	f8de 0004 	ldr.w	r0, [lr, #4]
 800a2f2:	f104 0c10 	add.w	ip, r4, #16
 800a2f6:	f020 0003 	bic.w	r0, r0, #3
 800a2fa:	eb00 010b 	add.w	r1, r0, fp
 800a2fe:	4561      	cmp	r1, ip
 800a300:	bfb8      	it	lt
 800a302:	4671      	movlt	r1, lr
 800a304:	f6ff aec6 	blt.w	800a094 <_realloc_r+0x78>
 800a308:	eb0a 0304 	add.w	r3, sl, r4
 800a30c:	1b0a      	subs	r2, r1, r4
 800a30e:	f042 0201 	orr.w	r2, r2, #1
 800a312:	f8c9 3008 	str.w	r3, [r9, #8]
 800a316:	605a      	str	r2, [r3, #4]
 800a318:	4638      	mov	r0, r7
 800a31a:	f8da 2004 	ldr.w	r2, [sl, #4]
 800a31e:	46a8      	mov	r8, r5
 800a320:	f002 0301 	and.w	r3, r2, #1
 800a324:	431c      	orrs	r4, r3
 800a326:	f8ca 4004 	str.w	r4, [sl, #4]
 800a32a:	f7fa ff75 	bl	8005218 <__malloc_unlock>
 800a32e:	e71c      	b.n	800a16a <_realloc_r+0x14e>
 800a330:	4640      	mov	r0, r8
 800a332:	4629      	mov	r1, r5
 800a334:	9301      	str	r3, [sp, #4]
 800a336:	f8cd c000 	str.w	ip, [sp]
 800a33a:	f7ff fe15 	bl	8009f68 <memmove>
 800a33e:	f8dd c000 	ldr.w	ip, [sp]
 800a342:	9b01      	ldr	r3, [sp, #4]
 800a344:	46e2      	mov	sl, ip
 800a346:	461e      	mov	r6, r3
 800a348:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800a34c:	e6fb      	b.n	800a146 <_realloc_r+0x12a>
 800a34e:	4629      	mov	r1, r5
 800a350:	f7ff fe0a 	bl	8009f68 <memmove>
 800a354:	e776      	b.n	800a244 <_realloc_r+0x228>
 800a356:	445b      	add	r3, fp
 800a358:	f104 0110 	add.w	r1, r4, #16
 800a35c:	18c6      	adds	r6, r0, r3
 800a35e:	428e      	cmp	r6, r1
 800a360:	f6ff af79 	blt.w	800a256 <_realloc_r+0x23a>
 800a364:	46e0      	mov	r8, ip
 800a366:	f8dc 300c 	ldr.w	r3, [ip, #12]
 800a36a:	f1ab 0204 	sub.w	r2, fp, #4
 800a36e:	f858 1f08 	ldr.w	r1, [r8, #8]!
 800a372:	2a24      	cmp	r2, #36	; 0x24
 800a374:	60cb      	str	r3, [r1, #12]
 800a376:	6099      	str	r1, [r3, #8]
 800a378:	d855      	bhi.n	800a426 <_realloc_r+0x40a>
 800a37a:	2a13      	cmp	r2, #19
 800a37c:	4641      	mov	r1, r8
 800a37e:	d921      	bls.n	800a3c4 <_realloc_r+0x3a8>
 800a380:	462b      	mov	r3, r5
 800a382:	f10c 0110 	add.w	r1, ip, #16
 800a386:	f853 0b04 	ldr.w	r0, [r3], #4
 800a38a:	f8cc 0008 	str.w	r0, [ip, #8]
 800a38e:	6868      	ldr	r0, [r5, #4]
 800a390:	1d1d      	adds	r5, r3, #4
 800a392:	2a1b      	cmp	r2, #27
 800a394:	f8cc 000c 	str.w	r0, [ip, #12]
 800a398:	d914      	bls.n	800a3c4 <_realloc_r+0x3a8>
 800a39a:	6858      	ldr	r0, [r3, #4]
 800a39c:	1d2b      	adds	r3, r5, #4
 800a39e:	f10c 0118 	add.w	r1, ip, #24
 800a3a2:	f8cc 0010 	str.w	r0, [ip, #16]
 800a3a6:	6868      	ldr	r0, [r5, #4]
 800a3a8:	3508      	adds	r5, #8
 800a3aa:	2a24      	cmp	r2, #36	; 0x24
 800a3ac:	f8cc 0014 	str.w	r0, [ip, #20]
 800a3b0:	d108      	bne.n	800a3c4 <_realloc_r+0x3a8>
 800a3b2:	685b      	ldr	r3, [r3, #4]
 800a3b4:	f10c 0120 	add.w	r1, ip, #32
 800a3b8:	f8cc 3018 	str.w	r3, [ip, #24]
 800a3bc:	686b      	ldr	r3, [r5, #4]
 800a3be:	3508      	adds	r5, #8
 800a3c0:	f8cc 301c 	str.w	r3, [ip, #28]
 800a3c4:	462a      	mov	r2, r5
 800a3c6:	460b      	mov	r3, r1
 800a3c8:	f852 0b04 	ldr.w	r0, [r2], #4
 800a3cc:	f843 0b04 	str.w	r0, [r3], #4
 800a3d0:	6868      	ldr	r0, [r5, #4]
 800a3d2:	6048      	str	r0, [r1, #4]
 800a3d4:	6852      	ldr	r2, [r2, #4]
 800a3d6:	605a      	str	r2, [r3, #4]
 800a3d8:	eb0c 0304 	add.w	r3, ip, r4
 800a3dc:	1b32      	subs	r2, r6, r4
 800a3de:	f042 0201 	orr.w	r2, r2, #1
 800a3e2:	f8c9 3008 	str.w	r3, [r9, #8]
 800a3e6:	605a      	str	r2, [r3, #4]
 800a3e8:	4638      	mov	r0, r7
 800a3ea:	f8dc 2004 	ldr.w	r2, [ip, #4]
 800a3ee:	f002 0301 	and.w	r3, r2, #1
 800a3f2:	431c      	orrs	r4, r3
 800a3f4:	f8cc 4004 	str.w	r4, [ip, #4]
 800a3f8:	f7fa ff0e 	bl	8005218 <__malloc_unlock>
 800a3fc:	e6b5      	b.n	800a16a <_realloc_r+0x14e>
 800a3fe:	f850 6c04 	ldr.w	r6, [r0, #-4]
 800a402:	f10a 0808 	add.w	r8, sl, #8
 800a406:	f026 0603 	bic.w	r6, r6, #3
 800a40a:	445e      	add	r6, fp
 800a40c:	e69b      	b.n	800a146 <_realloc_r+0x12a>
 800a40e:	4640      	mov	r0, r8
 800a410:	4629      	mov	r1, r5
 800a412:	f8cd c000 	str.w	ip, [sp]
 800a416:	f7ff fda7 	bl	8009f68 <memmove>
 800a41a:	f8dd c000 	ldr.w	ip, [sp]
 800a41e:	46e2      	mov	sl, ip
 800a420:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800a424:	e68f      	b.n	800a146 <_realloc_r+0x12a>
 800a426:	4640      	mov	r0, r8
 800a428:	4629      	mov	r1, r5
 800a42a:	f8cd c000 	str.w	ip, [sp]
 800a42e:	f7ff fd9b 	bl	8009f68 <memmove>
 800a432:	f8dd c000 	ldr.w	ip, [sp]
 800a436:	e7cf      	b.n	800a3d8 <_realloc_r+0x3bc>

0800a438 <__aeabi_uidiv>:
 800a438:	1e4a      	subs	r2, r1, #1
 800a43a:	bf08      	it	eq
 800a43c:	4770      	bxeq	lr
 800a43e:	f0c0 8124 	bcc.w	800a68a <__aeabi_uidiv+0x252>
 800a442:	4288      	cmp	r0, r1
 800a444:	f240 8116 	bls.w	800a674 <__aeabi_uidiv+0x23c>
 800a448:	4211      	tst	r1, r2
 800a44a:	f000 8117 	beq.w	800a67c <__aeabi_uidiv+0x244>
 800a44e:	fab0 f380 	clz	r3, r0
 800a452:	fab1 f281 	clz	r2, r1
 800a456:	eba2 0303 	sub.w	r3, r2, r3
 800a45a:	f1c3 031f 	rsb	r3, r3, #31
 800a45e:	a204      	add	r2, pc, #16	; (adr r2, 800a470 <__aeabi_uidiv+0x38>)
 800a460:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800a464:	f04f 0200 	mov.w	r2, #0
 800a468:	469f      	mov	pc, r3
 800a46a:	bf00      	nop
 800a46c:	f3af 8000 	nop.w
 800a470:	ebb0 7fc1 	cmp.w	r0, r1, lsl #31
 800a474:	bf00      	nop
 800a476:	eb42 0202 	adc.w	r2, r2, r2
 800a47a:	bf28      	it	cs
 800a47c:	eba0 70c1 	subcs.w	r0, r0, r1, lsl #31
 800a480:	ebb0 7f81 	cmp.w	r0, r1, lsl #30
 800a484:	bf00      	nop
 800a486:	eb42 0202 	adc.w	r2, r2, r2
 800a48a:	bf28      	it	cs
 800a48c:	eba0 7081 	subcs.w	r0, r0, r1, lsl #30
 800a490:	ebb0 7f41 	cmp.w	r0, r1, lsl #29
 800a494:	bf00      	nop
 800a496:	eb42 0202 	adc.w	r2, r2, r2
 800a49a:	bf28      	it	cs
 800a49c:	eba0 7041 	subcs.w	r0, r0, r1, lsl #29
 800a4a0:	ebb0 7f01 	cmp.w	r0, r1, lsl #28
 800a4a4:	bf00      	nop
 800a4a6:	eb42 0202 	adc.w	r2, r2, r2
 800a4aa:	bf28      	it	cs
 800a4ac:	eba0 7001 	subcs.w	r0, r0, r1, lsl #28
 800a4b0:	ebb0 6fc1 	cmp.w	r0, r1, lsl #27
 800a4b4:	bf00      	nop
 800a4b6:	eb42 0202 	adc.w	r2, r2, r2
 800a4ba:	bf28      	it	cs
 800a4bc:	eba0 60c1 	subcs.w	r0, r0, r1, lsl #27
 800a4c0:	ebb0 6f81 	cmp.w	r0, r1, lsl #26
 800a4c4:	bf00      	nop
 800a4c6:	eb42 0202 	adc.w	r2, r2, r2
 800a4ca:	bf28      	it	cs
 800a4cc:	eba0 6081 	subcs.w	r0, r0, r1, lsl #26
 800a4d0:	ebb0 6f41 	cmp.w	r0, r1, lsl #25
 800a4d4:	bf00      	nop
 800a4d6:	eb42 0202 	adc.w	r2, r2, r2
 800a4da:	bf28      	it	cs
 800a4dc:	eba0 6041 	subcs.w	r0, r0, r1, lsl #25
 800a4e0:	ebb0 6f01 	cmp.w	r0, r1, lsl #24
 800a4e4:	bf00      	nop
 800a4e6:	eb42 0202 	adc.w	r2, r2, r2
 800a4ea:	bf28      	it	cs
 800a4ec:	eba0 6001 	subcs.w	r0, r0, r1, lsl #24
 800a4f0:	ebb0 5fc1 	cmp.w	r0, r1, lsl #23
 800a4f4:	bf00      	nop
 800a4f6:	eb42 0202 	adc.w	r2, r2, r2
 800a4fa:	bf28      	it	cs
 800a4fc:	eba0 50c1 	subcs.w	r0, r0, r1, lsl #23
 800a500:	ebb0 5f81 	cmp.w	r0, r1, lsl #22
 800a504:	bf00      	nop
 800a506:	eb42 0202 	adc.w	r2, r2, r2
 800a50a:	bf28      	it	cs
 800a50c:	eba0 5081 	subcs.w	r0, r0, r1, lsl #22
 800a510:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
 800a514:	bf00      	nop
 800a516:	eb42 0202 	adc.w	r2, r2, r2
 800a51a:	bf28      	it	cs
 800a51c:	eba0 5041 	subcs.w	r0, r0, r1, lsl #21
 800a520:	ebb0 5f01 	cmp.w	r0, r1, lsl #20
 800a524:	bf00      	nop
 800a526:	eb42 0202 	adc.w	r2, r2, r2
 800a52a:	bf28      	it	cs
 800a52c:	eba0 5001 	subcs.w	r0, r0, r1, lsl #20
 800a530:	ebb0 4fc1 	cmp.w	r0, r1, lsl #19
 800a534:	bf00      	nop
 800a536:	eb42 0202 	adc.w	r2, r2, r2
 800a53a:	bf28      	it	cs
 800a53c:	eba0 40c1 	subcs.w	r0, r0, r1, lsl #19
 800a540:	ebb0 4f81 	cmp.w	r0, r1, lsl #18
 800a544:	bf00      	nop
 800a546:	eb42 0202 	adc.w	r2, r2, r2
 800a54a:	bf28      	it	cs
 800a54c:	eba0 4081 	subcs.w	r0, r0, r1, lsl #18
 800a550:	ebb0 4f41 	cmp.w	r0, r1, lsl #17
 800a554:	bf00      	nop
 800a556:	eb42 0202 	adc.w	r2, r2, r2
 800a55a:	bf28      	it	cs
 800a55c:	eba0 4041 	subcs.w	r0, r0, r1, lsl #17
 800a560:	ebb0 4f01 	cmp.w	r0, r1, lsl #16
 800a564:	bf00      	nop
 800a566:	eb42 0202 	adc.w	r2, r2, r2
 800a56a:	bf28      	it	cs
 800a56c:	eba0 4001 	subcs.w	r0, r0, r1, lsl #16
 800a570:	ebb0 3fc1 	cmp.w	r0, r1, lsl #15
 800a574:	bf00      	nop
 800a576:	eb42 0202 	adc.w	r2, r2, r2
 800a57a:	bf28      	it	cs
 800a57c:	eba0 30c1 	subcs.w	r0, r0, r1, lsl #15
 800a580:	ebb0 3f81 	cmp.w	r0, r1, lsl #14
 800a584:	bf00      	nop
 800a586:	eb42 0202 	adc.w	r2, r2, r2
 800a58a:	bf28      	it	cs
 800a58c:	eba0 3081 	subcs.w	r0, r0, r1, lsl #14
 800a590:	ebb0 3f41 	cmp.w	r0, r1, lsl #13
 800a594:	bf00      	nop
 800a596:	eb42 0202 	adc.w	r2, r2, r2
 800a59a:	bf28      	it	cs
 800a59c:	eba0 3041 	subcs.w	r0, r0, r1, lsl #13
 800a5a0:	ebb0 3f01 	cmp.w	r0, r1, lsl #12
 800a5a4:	bf00      	nop
 800a5a6:	eb42 0202 	adc.w	r2, r2, r2
 800a5aa:	bf28      	it	cs
 800a5ac:	eba0 3001 	subcs.w	r0, r0, r1, lsl #12
 800a5b0:	ebb0 2fc1 	cmp.w	r0, r1, lsl #11
 800a5b4:	bf00      	nop
 800a5b6:	eb42 0202 	adc.w	r2, r2, r2
 800a5ba:	bf28      	it	cs
 800a5bc:	eba0 20c1 	subcs.w	r0, r0, r1, lsl #11
 800a5c0:	ebb0 2f81 	cmp.w	r0, r1, lsl #10
 800a5c4:	bf00      	nop
 800a5c6:	eb42 0202 	adc.w	r2, r2, r2
 800a5ca:	bf28      	it	cs
 800a5cc:	eba0 2081 	subcs.w	r0, r0, r1, lsl #10
 800a5d0:	ebb0 2f41 	cmp.w	r0, r1, lsl #9
 800a5d4:	bf00      	nop
 800a5d6:	eb42 0202 	adc.w	r2, r2, r2
 800a5da:	bf28      	it	cs
 800a5dc:	eba0 2041 	subcs.w	r0, r0, r1, lsl #9
 800a5e0:	ebb0 2f01 	cmp.w	r0, r1, lsl #8
 800a5e4:	bf00      	nop
 800a5e6:	eb42 0202 	adc.w	r2, r2, r2
 800a5ea:	bf28      	it	cs
 800a5ec:	eba0 2001 	subcs.w	r0, r0, r1, lsl #8
 800a5f0:	ebb0 1fc1 	cmp.w	r0, r1, lsl #7
 800a5f4:	bf00      	nop
 800a5f6:	eb42 0202 	adc.w	r2, r2, r2
 800a5fa:	bf28      	it	cs
 800a5fc:	eba0 10c1 	subcs.w	r0, r0, r1, lsl #7
 800a600:	ebb0 1f81 	cmp.w	r0, r1, lsl #6
 800a604:	bf00      	nop
 800a606:	eb42 0202 	adc.w	r2, r2, r2
 800a60a:	bf28      	it	cs
 800a60c:	eba0 1081 	subcs.w	r0, r0, r1, lsl #6
 800a610:	ebb0 1f41 	cmp.w	r0, r1, lsl #5
 800a614:	bf00      	nop
 800a616:	eb42 0202 	adc.w	r2, r2, r2
 800a61a:	bf28      	it	cs
 800a61c:	eba0 1041 	subcs.w	r0, r0, r1, lsl #5
 800a620:	ebb0 1f01 	cmp.w	r0, r1, lsl #4
 800a624:	bf00      	nop
 800a626:	eb42 0202 	adc.w	r2, r2, r2
 800a62a:	bf28      	it	cs
 800a62c:	eba0 1001 	subcs.w	r0, r0, r1, lsl #4
 800a630:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
 800a634:	bf00      	nop
 800a636:	eb42 0202 	adc.w	r2, r2, r2
 800a63a:	bf28      	it	cs
 800a63c:	eba0 00c1 	subcs.w	r0, r0, r1, lsl #3
 800a640:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
 800a644:	bf00      	nop
 800a646:	eb42 0202 	adc.w	r2, r2, r2
 800a64a:	bf28      	it	cs
 800a64c:	eba0 0081 	subcs.w	r0, r0, r1, lsl #2
 800a650:	ebb0 0f41 	cmp.w	r0, r1, lsl #1
 800a654:	bf00      	nop
 800a656:	eb42 0202 	adc.w	r2, r2, r2
 800a65a:	bf28      	it	cs
 800a65c:	eba0 0041 	subcs.w	r0, r0, r1, lsl #1
 800a660:	ebb0 0f01 	cmp.w	r0, r1
 800a664:	bf00      	nop
 800a666:	eb42 0202 	adc.w	r2, r2, r2
 800a66a:	bf28      	it	cs
 800a66c:	eba0 0001 	subcs.w	r0, r0, r1
 800a670:	4610      	mov	r0, r2
 800a672:	4770      	bx	lr
 800a674:	bf0c      	ite	eq
 800a676:	2001      	moveq	r0, #1
 800a678:	2000      	movne	r0, #0
 800a67a:	4770      	bx	lr
 800a67c:	fab1 f281 	clz	r2, r1
 800a680:	f1c2 021f 	rsb	r2, r2, #31
 800a684:	fa20 f002 	lsr.w	r0, r0, r2
 800a688:	4770      	bx	lr
 800a68a:	b108      	cbz	r0, 800a690 <__aeabi_uidiv+0x258>
 800a68c:	f04f 30ff 	mov.w	r0, #4294967295
 800a690:	f000 b80e 	b.w	800a6b0 <__aeabi_idiv0>

0800a694 <__aeabi_uidivmod>:
 800a694:	2900      	cmp	r1, #0
 800a696:	d0f8      	beq.n	800a68a <__aeabi_uidiv+0x252>
 800a698:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
 800a69c:	f7ff fecc 	bl	800a438 <__aeabi_uidiv>
 800a6a0:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
 800a6a4:	fb02 f300 	mul.w	r3, r2, r0
 800a6a8:	eba1 0103 	sub.w	r1, r1, r3
 800a6ac:	4770      	bx	lr
 800a6ae:	bf00      	nop

0800a6b0 <__aeabi_idiv0>:
 800a6b0:	4770      	bx	lr
 800a6b2:	bf00      	nop

0800a6b4 <__aeabi_drsub>:
 800a6b4:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 800a6b8:	e002      	b.n	800a6c0 <__adddf3>
 800a6ba:	bf00      	nop

0800a6bc <__aeabi_dsub>:
 800a6bc:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800a6c0 <__adddf3>:
 800a6c0:	b530      	push	{r4, r5, lr}
 800a6c2:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800a6c6:	ea4f 0543 	mov.w	r5, r3, lsl #1
 800a6ca:	ea94 0f05 	teq	r4, r5
 800a6ce:	bf08      	it	eq
 800a6d0:	ea90 0f02 	teqeq	r0, r2
 800a6d4:	bf1f      	itttt	ne
 800a6d6:	ea54 0c00 	orrsne.w	ip, r4, r0
 800a6da:	ea55 0c02 	orrsne.w	ip, r5, r2
 800a6de:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800a6e2:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800a6e6:	f000 80e2 	beq.w	800a8ae <__adddf3+0x1ee>
 800a6ea:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800a6ee:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800a6f2:	bfb8      	it	lt
 800a6f4:	426d      	neglt	r5, r5
 800a6f6:	dd0c      	ble.n	800a712 <__adddf3+0x52>
 800a6f8:	442c      	add	r4, r5
 800a6fa:	ea80 0202 	eor.w	r2, r0, r2
 800a6fe:	ea81 0303 	eor.w	r3, r1, r3
 800a702:	ea82 0000 	eor.w	r0, r2, r0
 800a706:	ea83 0101 	eor.w	r1, r3, r1
 800a70a:	ea80 0202 	eor.w	r2, r0, r2
 800a70e:	ea81 0303 	eor.w	r3, r1, r3
 800a712:	2d36      	cmp	r5, #54	; 0x36
 800a714:	bf88      	it	hi
 800a716:	bd30      	pophi	{r4, r5, pc}
 800a718:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800a71c:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800a720:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 800a724:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800a728:	d002      	beq.n	800a730 <__adddf3+0x70>
 800a72a:	4240      	negs	r0, r0
 800a72c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800a730:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 800a734:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800a738:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 800a73c:	d002      	beq.n	800a744 <__adddf3+0x84>
 800a73e:	4252      	negs	r2, r2
 800a740:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800a744:	ea94 0f05 	teq	r4, r5
 800a748:	f000 80a7 	beq.w	800a89a <__adddf3+0x1da>
 800a74c:	f1a4 0401 	sub.w	r4, r4, #1
 800a750:	f1d5 0e20 	rsbs	lr, r5, #32
 800a754:	db0d      	blt.n	800a772 <__adddf3+0xb2>
 800a756:	fa02 fc0e 	lsl.w	ip, r2, lr
 800a75a:	fa22 f205 	lsr.w	r2, r2, r5
 800a75e:	1880      	adds	r0, r0, r2
 800a760:	f141 0100 	adc.w	r1, r1, #0
 800a764:	fa03 f20e 	lsl.w	r2, r3, lr
 800a768:	1880      	adds	r0, r0, r2
 800a76a:	fa43 f305 	asr.w	r3, r3, r5
 800a76e:	4159      	adcs	r1, r3
 800a770:	e00e      	b.n	800a790 <__adddf3+0xd0>
 800a772:	f1a5 0520 	sub.w	r5, r5, #32
 800a776:	f10e 0e20 	add.w	lr, lr, #32
 800a77a:	2a01      	cmp	r2, #1
 800a77c:	fa03 fc0e 	lsl.w	ip, r3, lr
 800a780:	bf28      	it	cs
 800a782:	f04c 0c02 	orrcs.w	ip, ip, #2
 800a786:	fa43 f305 	asr.w	r3, r3, r5
 800a78a:	18c0      	adds	r0, r0, r3
 800a78c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800a790:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800a794:	d507      	bpl.n	800a7a6 <__adddf3+0xe6>
 800a796:	f04f 0e00 	mov.w	lr, #0
 800a79a:	f1dc 0c00 	rsbs	ip, ip, #0
 800a79e:	eb7e 0000 	sbcs.w	r0, lr, r0
 800a7a2:	eb6e 0101 	sbc.w	r1, lr, r1
 800a7a6:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 800a7aa:	d31b      	bcc.n	800a7e4 <__adddf3+0x124>
 800a7ac:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800a7b0:	d30c      	bcc.n	800a7cc <__adddf3+0x10c>
 800a7b2:	0849      	lsrs	r1, r1, #1
 800a7b4:	ea5f 0030 	movs.w	r0, r0, rrx
 800a7b8:	ea4f 0c3c 	mov.w	ip, ip, rrx
 800a7bc:	f104 0401 	add.w	r4, r4, #1
 800a7c0:	ea4f 5244 	mov.w	r2, r4, lsl #21
 800a7c4:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 800a7c8:	f080 809a 	bcs.w	800a900 <__adddf3+0x240>
 800a7cc:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800a7d0:	bf08      	it	eq
 800a7d2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800a7d6:	f150 0000 	adcs.w	r0, r0, #0
 800a7da:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800a7de:	ea41 0105 	orr.w	r1, r1, r5
 800a7e2:	bd30      	pop	{r4, r5, pc}
 800a7e4:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800a7e8:	4140      	adcs	r0, r0
 800a7ea:	eb41 0101 	adc.w	r1, r1, r1
 800a7ee:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800a7f2:	f1a4 0401 	sub.w	r4, r4, #1
 800a7f6:	d1e9      	bne.n	800a7cc <__adddf3+0x10c>
 800a7f8:	f091 0f00 	teq	r1, #0
 800a7fc:	bf04      	itt	eq
 800a7fe:	4601      	moveq	r1, r0
 800a800:	2000      	moveq	r0, #0
 800a802:	fab1 f381 	clz	r3, r1
 800a806:	bf08      	it	eq
 800a808:	3320      	addeq	r3, #32
 800a80a:	f1a3 030b 	sub.w	r3, r3, #11
 800a80e:	f1b3 0220 	subs.w	r2, r3, #32
 800a812:	da0c      	bge.n	800a82e <__adddf3+0x16e>
 800a814:	320c      	adds	r2, #12
 800a816:	dd08      	ble.n	800a82a <__adddf3+0x16a>
 800a818:	f102 0c14 	add.w	ip, r2, #20
 800a81c:	f1c2 020c 	rsb	r2, r2, #12
 800a820:	fa01 f00c 	lsl.w	r0, r1, ip
 800a824:	fa21 f102 	lsr.w	r1, r1, r2
 800a828:	e00c      	b.n	800a844 <__adddf3+0x184>
 800a82a:	f102 0214 	add.w	r2, r2, #20
 800a82e:	bfd8      	it	le
 800a830:	f1c2 0c20 	rsble	ip, r2, #32
 800a834:	fa01 f102 	lsl.w	r1, r1, r2
 800a838:	fa20 fc0c 	lsr.w	ip, r0, ip
 800a83c:	bfdc      	itt	le
 800a83e:	ea41 010c 	orrle.w	r1, r1, ip
 800a842:	4090      	lslle	r0, r2
 800a844:	1ae4      	subs	r4, r4, r3
 800a846:	bfa2      	ittt	ge
 800a848:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 800a84c:	4329      	orrge	r1, r5
 800a84e:	bd30      	popge	{r4, r5, pc}
 800a850:	ea6f 0404 	mvn.w	r4, r4
 800a854:	3c1f      	subs	r4, #31
 800a856:	da1c      	bge.n	800a892 <__adddf3+0x1d2>
 800a858:	340c      	adds	r4, #12
 800a85a:	dc0e      	bgt.n	800a87a <__adddf3+0x1ba>
 800a85c:	f104 0414 	add.w	r4, r4, #20
 800a860:	f1c4 0220 	rsb	r2, r4, #32
 800a864:	fa20 f004 	lsr.w	r0, r0, r4
 800a868:	fa01 f302 	lsl.w	r3, r1, r2
 800a86c:	ea40 0003 	orr.w	r0, r0, r3
 800a870:	fa21 f304 	lsr.w	r3, r1, r4
 800a874:	ea45 0103 	orr.w	r1, r5, r3
 800a878:	bd30      	pop	{r4, r5, pc}
 800a87a:	f1c4 040c 	rsb	r4, r4, #12
 800a87e:	f1c4 0220 	rsb	r2, r4, #32
 800a882:	fa20 f002 	lsr.w	r0, r0, r2
 800a886:	fa01 f304 	lsl.w	r3, r1, r4
 800a88a:	ea40 0003 	orr.w	r0, r0, r3
 800a88e:	4629      	mov	r1, r5
 800a890:	bd30      	pop	{r4, r5, pc}
 800a892:	fa21 f004 	lsr.w	r0, r1, r4
 800a896:	4629      	mov	r1, r5
 800a898:	bd30      	pop	{r4, r5, pc}
 800a89a:	f094 0f00 	teq	r4, #0
 800a89e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800a8a2:	bf06      	itte	eq
 800a8a4:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 800a8a8:	3401      	addeq	r4, #1
 800a8aa:	3d01      	subne	r5, #1
 800a8ac:	e74e      	b.n	800a74c <__adddf3+0x8c>
 800a8ae:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800a8b2:	bf18      	it	ne
 800a8b4:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800a8b8:	d029      	beq.n	800a90e <__adddf3+0x24e>
 800a8ba:	ea94 0f05 	teq	r4, r5
 800a8be:	bf08      	it	eq
 800a8c0:	ea90 0f02 	teqeq	r0, r2
 800a8c4:	d005      	beq.n	800a8d2 <__adddf3+0x212>
 800a8c6:	ea54 0c00 	orrs.w	ip, r4, r0
 800a8ca:	bf04      	itt	eq
 800a8cc:	4619      	moveq	r1, r3
 800a8ce:	4610      	moveq	r0, r2
 800a8d0:	bd30      	pop	{r4, r5, pc}
 800a8d2:	ea91 0f03 	teq	r1, r3
 800a8d6:	bf1e      	ittt	ne
 800a8d8:	2100      	movne	r1, #0
 800a8da:	2000      	movne	r0, #0
 800a8dc:	bd30      	popne	{r4, r5, pc}
 800a8de:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800a8e2:	d105      	bne.n	800a8f0 <__adddf3+0x230>
 800a8e4:	0040      	lsls	r0, r0, #1
 800a8e6:	4149      	adcs	r1, r1
 800a8e8:	bf28      	it	cs
 800a8ea:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800a8ee:	bd30      	pop	{r4, r5, pc}
 800a8f0:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 800a8f4:	bf3c      	itt	cc
 800a8f6:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800a8fa:	bd30      	popcc	{r4, r5, pc}
 800a8fc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800a900:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 800a904:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800a908:	f04f 0000 	mov.w	r0, #0
 800a90c:	bd30      	pop	{r4, r5, pc}
 800a90e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800a912:	bf1a      	itte	ne
 800a914:	4619      	movne	r1, r3
 800a916:	4610      	movne	r0, r2
 800a918:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 800a91c:	bf1c      	itt	ne
 800a91e:	460b      	movne	r3, r1
 800a920:	4602      	movne	r2, r0
 800a922:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800a926:	bf06      	itte	eq
 800a928:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 800a92c:	ea91 0f03 	teqeq	r1, r3
 800a930:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 800a934:	bd30      	pop	{r4, r5, pc}
 800a936:	bf00      	nop

0800a938 <__aeabi_ui2d>:
 800a938:	f090 0f00 	teq	r0, #0
 800a93c:	bf04      	itt	eq
 800a93e:	2100      	moveq	r1, #0
 800a940:	4770      	bxeq	lr
 800a942:	b530      	push	{r4, r5, lr}
 800a944:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800a948:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800a94c:	f04f 0500 	mov.w	r5, #0
 800a950:	f04f 0100 	mov.w	r1, #0
 800a954:	e750      	b.n	800a7f8 <__adddf3+0x138>
 800a956:	bf00      	nop

0800a958 <__aeabi_i2d>:
 800a958:	f090 0f00 	teq	r0, #0
 800a95c:	bf04      	itt	eq
 800a95e:	2100      	moveq	r1, #0
 800a960:	4770      	bxeq	lr
 800a962:	b530      	push	{r4, r5, lr}
 800a964:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800a968:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800a96c:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800a970:	bf48      	it	mi
 800a972:	4240      	negmi	r0, r0
 800a974:	f04f 0100 	mov.w	r1, #0
 800a978:	e73e      	b.n	800a7f8 <__adddf3+0x138>
 800a97a:	bf00      	nop

0800a97c <__aeabi_f2d>:
 800a97c:	0042      	lsls	r2, r0, #1
 800a97e:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800a982:	ea4f 0131 	mov.w	r1, r1, rrx
 800a986:	ea4f 7002 	mov.w	r0, r2, lsl #28
 800a98a:	bf1f      	itttt	ne
 800a98c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800a990:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800a994:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 800a998:	4770      	bxne	lr
 800a99a:	f092 0f00 	teq	r2, #0
 800a99e:	bf14      	ite	ne
 800a9a0:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800a9a4:	4770      	bxeq	lr
 800a9a6:	b530      	push	{r4, r5, lr}
 800a9a8:	f44f 7460 	mov.w	r4, #896	; 0x380
 800a9ac:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800a9b0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800a9b4:	e720      	b.n	800a7f8 <__adddf3+0x138>
 800a9b6:	bf00      	nop

0800a9b8 <__aeabi_ul2d>:
 800a9b8:	ea50 0201 	orrs.w	r2, r0, r1
 800a9bc:	bf08      	it	eq
 800a9be:	4770      	bxeq	lr
 800a9c0:	b530      	push	{r4, r5, lr}
 800a9c2:	f04f 0500 	mov.w	r5, #0
 800a9c6:	e00a      	b.n	800a9de <__aeabi_l2d+0x16>

0800a9c8 <__aeabi_l2d>:
 800a9c8:	ea50 0201 	orrs.w	r2, r0, r1
 800a9cc:	bf08      	it	eq
 800a9ce:	4770      	bxeq	lr
 800a9d0:	b530      	push	{r4, r5, lr}
 800a9d2:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800a9d6:	d502      	bpl.n	800a9de <__aeabi_l2d+0x16>
 800a9d8:	4240      	negs	r0, r0
 800a9da:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800a9de:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800a9e2:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800a9e6:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800a9ea:	f43f aedc 	beq.w	800a7a6 <__adddf3+0xe6>
 800a9ee:	f04f 0203 	mov.w	r2, #3
 800a9f2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800a9f6:	bf18      	it	ne
 800a9f8:	3203      	addne	r2, #3
 800a9fa:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800a9fe:	bf18      	it	ne
 800aa00:	3203      	addne	r2, #3
 800aa02:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800aa06:	f1c2 0320 	rsb	r3, r2, #32
 800aa0a:	fa00 fc03 	lsl.w	ip, r0, r3
 800aa0e:	fa20 f002 	lsr.w	r0, r0, r2
 800aa12:	fa01 fe03 	lsl.w	lr, r1, r3
 800aa16:	ea40 000e 	orr.w	r0, r0, lr
 800aa1a:	fa21 f102 	lsr.w	r1, r1, r2
 800aa1e:	4414      	add	r4, r2
 800aa20:	e6c1      	b.n	800a7a6 <__adddf3+0xe6>
 800aa22:	bf00      	nop

0800aa24 <__aeabi_dmul>:
 800aa24:	b570      	push	{r4, r5, r6, lr}
 800aa26:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800aa2a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800aa2e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800aa32:	bf1d      	ittte	ne
 800aa34:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800aa38:	ea94 0f0c 	teqne	r4, ip
 800aa3c:	ea95 0f0c 	teqne	r5, ip
 800aa40:	f000 f8de 	bleq	800ac00 <__aeabi_dmul+0x1dc>
 800aa44:	442c      	add	r4, r5
 800aa46:	ea81 0603 	eor.w	r6, r1, r3
 800aa4a:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800aa4e:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800aa52:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800aa56:	bf18      	it	ne
 800aa58:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 800aa5c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800aa60:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800aa64:	d038      	beq.n	800aad8 <__aeabi_dmul+0xb4>
 800aa66:	fba0 ce02 	umull	ip, lr, r0, r2
 800aa6a:	f04f 0500 	mov.w	r5, #0
 800aa6e:	fbe1 e502 	umlal	lr, r5, r1, r2
 800aa72:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800aa76:	fbe0 e503 	umlal	lr, r5, r0, r3
 800aa7a:	f04f 0600 	mov.w	r6, #0
 800aa7e:	fbe1 5603 	umlal	r5, r6, r1, r3
 800aa82:	f09c 0f00 	teq	ip, #0
 800aa86:	bf18      	it	ne
 800aa88:	f04e 0e01 	orrne.w	lr, lr, #1
 800aa8c:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800aa90:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 800aa94:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 800aa98:	d204      	bcs.n	800aaa4 <__aeabi_dmul+0x80>
 800aa9a:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800aa9e:	416d      	adcs	r5, r5
 800aaa0:	eb46 0606 	adc.w	r6, r6, r6
 800aaa4:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800aaa8:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 800aaac:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800aab0:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 800aab4:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800aab8:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800aabc:	bf88      	it	hi
 800aabe:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800aac2:	d81e      	bhi.n	800ab02 <__aeabi_dmul+0xde>
 800aac4:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 800aac8:	bf08      	it	eq
 800aaca:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800aace:	f150 0000 	adcs.w	r0, r0, #0
 800aad2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800aad6:	bd70      	pop	{r4, r5, r6, pc}
 800aad8:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 800aadc:	ea46 0101 	orr.w	r1, r6, r1
 800aae0:	ea40 0002 	orr.w	r0, r0, r2
 800aae4:	ea81 0103 	eor.w	r1, r1, r3
 800aae8:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 800aaec:	bfc2      	ittt	gt
 800aaee:	ebd4 050c 	rsbsgt	r5, r4, ip
 800aaf2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800aaf6:	bd70      	popgt	{r4, r5, r6, pc}
 800aaf8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800aafc:	f04f 0e00 	mov.w	lr, #0
 800ab00:	3c01      	subs	r4, #1
 800ab02:	f300 80ab 	bgt.w	800ac5c <__aeabi_dmul+0x238>
 800ab06:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800ab0a:	bfde      	ittt	le
 800ab0c:	2000      	movle	r0, #0
 800ab0e:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800ab12:	bd70      	pople	{r4, r5, r6, pc}
 800ab14:	f1c4 0400 	rsb	r4, r4, #0
 800ab18:	3c20      	subs	r4, #32
 800ab1a:	da35      	bge.n	800ab88 <__aeabi_dmul+0x164>
 800ab1c:	340c      	adds	r4, #12
 800ab1e:	dc1b      	bgt.n	800ab58 <__aeabi_dmul+0x134>
 800ab20:	f104 0414 	add.w	r4, r4, #20
 800ab24:	f1c4 0520 	rsb	r5, r4, #32
 800ab28:	fa00 f305 	lsl.w	r3, r0, r5
 800ab2c:	fa20 f004 	lsr.w	r0, r0, r4
 800ab30:	fa01 f205 	lsl.w	r2, r1, r5
 800ab34:	ea40 0002 	orr.w	r0, r0, r2
 800ab38:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 800ab3c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800ab40:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800ab44:	fa21 f604 	lsr.w	r6, r1, r4
 800ab48:	eb42 0106 	adc.w	r1, r2, r6
 800ab4c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800ab50:	bf08      	it	eq
 800ab52:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800ab56:	bd70      	pop	{r4, r5, r6, pc}
 800ab58:	f1c4 040c 	rsb	r4, r4, #12
 800ab5c:	f1c4 0520 	rsb	r5, r4, #32
 800ab60:	fa00 f304 	lsl.w	r3, r0, r4
 800ab64:	fa20 f005 	lsr.w	r0, r0, r5
 800ab68:	fa01 f204 	lsl.w	r2, r1, r4
 800ab6c:	ea40 0002 	orr.w	r0, r0, r2
 800ab70:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800ab74:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800ab78:	f141 0100 	adc.w	r1, r1, #0
 800ab7c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800ab80:	bf08      	it	eq
 800ab82:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800ab86:	bd70      	pop	{r4, r5, r6, pc}
 800ab88:	f1c4 0520 	rsb	r5, r4, #32
 800ab8c:	fa00 f205 	lsl.w	r2, r0, r5
 800ab90:	ea4e 0e02 	orr.w	lr, lr, r2
 800ab94:	fa20 f304 	lsr.w	r3, r0, r4
 800ab98:	fa01 f205 	lsl.w	r2, r1, r5
 800ab9c:	ea43 0302 	orr.w	r3, r3, r2
 800aba0:	fa21 f004 	lsr.w	r0, r1, r4
 800aba4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800aba8:	fa21 f204 	lsr.w	r2, r1, r4
 800abac:	ea20 0002 	bic.w	r0, r0, r2
 800abb0:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 800abb4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800abb8:	bf08      	it	eq
 800abba:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800abbe:	bd70      	pop	{r4, r5, r6, pc}
 800abc0:	f094 0f00 	teq	r4, #0
 800abc4:	d10f      	bne.n	800abe6 <__aeabi_dmul+0x1c2>
 800abc6:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800abca:	0040      	lsls	r0, r0, #1
 800abcc:	eb41 0101 	adc.w	r1, r1, r1
 800abd0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800abd4:	bf08      	it	eq
 800abd6:	3c01      	subeq	r4, #1
 800abd8:	d0f7      	beq.n	800abca <__aeabi_dmul+0x1a6>
 800abda:	ea41 0106 	orr.w	r1, r1, r6
 800abde:	f095 0f00 	teq	r5, #0
 800abe2:	bf18      	it	ne
 800abe4:	4770      	bxne	lr
 800abe6:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800abea:	0052      	lsls	r2, r2, #1
 800abec:	eb43 0303 	adc.w	r3, r3, r3
 800abf0:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800abf4:	bf08      	it	eq
 800abf6:	3d01      	subeq	r5, #1
 800abf8:	d0f7      	beq.n	800abea <__aeabi_dmul+0x1c6>
 800abfa:	ea43 0306 	orr.w	r3, r3, r6
 800abfe:	4770      	bx	lr
 800ac00:	ea94 0f0c 	teq	r4, ip
 800ac04:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800ac08:	bf18      	it	ne
 800ac0a:	ea95 0f0c 	teqne	r5, ip
 800ac0e:	d00c      	beq.n	800ac2a <__aeabi_dmul+0x206>
 800ac10:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800ac14:	bf18      	it	ne
 800ac16:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800ac1a:	d1d1      	bne.n	800abc0 <__aeabi_dmul+0x19c>
 800ac1c:	ea81 0103 	eor.w	r1, r1, r3
 800ac20:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800ac24:	f04f 0000 	mov.w	r0, #0
 800ac28:	bd70      	pop	{r4, r5, r6, pc}
 800ac2a:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800ac2e:	bf06      	itte	eq
 800ac30:	4610      	moveq	r0, r2
 800ac32:	4619      	moveq	r1, r3
 800ac34:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800ac38:	d019      	beq.n	800ac6e <__aeabi_dmul+0x24a>
 800ac3a:	ea94 0f0c 	teq	r4, ip
 800ac3e:	d102      	bne.n	800ac46 <__aeabi_dmul+0x222>
 800ac40:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 800ac44:	d113      	bne.n	800ac6e <__aeabi_dmul+0x24a>
 800ac46:	ea95 0f0c 	teq	r5, ip
 800ac4a:	d105      	bne.n	800ac58 <__aeabi_dmul+0x234>
 800ac4c:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800ac50:	bf1c      	itt	ne
 800ac52:	4610      	movne	r0, r2
 800ac54:	4619      	movne	r1, r3
 800ac56:	d10a      	bne.n	800ac6e <__aeabi_dmul+0x24a>
 800ac58:	ea81 0103 	eor.w	r1, r1, r3
 800ac5c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800ac60:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800ac64:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800ac68:	f04f 0000 	mov.w	r0, #0
 800ac6c:	bd70      	pop	{r4, r5, r6, pc}
 800ac6e:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800ac72:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800ac76:	bd70      	pop	{r4, r5, r6, pc}

0800ac78 <__aeabi_ddiv>:
 800ac78:	b570      	push	{r4, r5, r6, lr}
 800ac7a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800ac7e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800ac82:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800ac86:	bf1d      	ittte	ne
 800ac88:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800ac8c:	ea94 0f0c 	teqne	r4, ip
 800ac90:	ea95 0f0c 	teqne	r5, ip
 800ac94:	f000 f8a7 	bleq	800ade6 <__aeabi_ddiv+0x16e>
 800ac98:	eba4 0405 	sub.w	r4, r4, r5
 800ac9c:	ea81 0e03 	eor.w	lr, r1, r3
 800aca0:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800aca4:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800aca8:	f000 8088 	beq.w	800adbc <__aeabi_ddiv+0x144>
 800acac:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800acb0:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800acb4:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800acb8:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800acbc:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800acc0:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 800acc4:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800acc8:	ea4f 2600 	mov.w	r6, r0, lsl #8
 800accc:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800acd0:	429d      	cmp	r5, r3
 800acd2:	bf08      	it	eq
 800acd4:	4296      	cmpeq	r6, r2
 800acd6:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 800acda:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800acde:	d202      	bcs.n	800ace6 <__aeabi_ddiv+0x6e>
 800ace0:	085b      	lsrs	r3, r3, #1
 800ace2:	ea4f 0232 	mov.w	r2, r2, rrx
 800ace6:	1ab6      	subs	r6, r6, r2
 800ace8:	eb65 0503 	sbc.w	r5, r5, r3
 800acec:	085b      	lsrs	r3, r3, #1
 800acee:	ea4f 0232 	mov.w	r2, r2, rrx
 800acf2:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800acf6:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800acfa:	ebb6 0e02 	subs.w	lr, r6, r2
 800acfe:	eb75 0e03 	sbcs.w	lr, r5, r3
 800ad02:	bf22      	ittt	cs
 800ad04:	1ab6      	subcs	r6, r6, r2
 800ad06:	4675      	movcs	r5, lr
 800ad08:	ea40 000c 	orrcs.w	r0, r0, ip
 800ad0c:	085b      	lsrs	r3, r3, #1
 800ad0e:	ea4f 0232 	mov.w	r2, r2, rrx
 800ad12:	ebb6 0e02 	subs.w	lr, r6, r2
 800ad16:	eb75 0e03 	sbcs.w	lr, r5, r3
 800ad1a:	bf22      	ittt	cs
 800ad1c:	1ab6      	subcs	r6, r6, r2
 800ad1e:	4675      	movcs	r5, lr
 800ad20:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 800ad24:	085b      	lsrs	r3, r3, #1
 800ad26:	ea4f 0232 	mov.w	r2, r2, rrx
 800ad2a:	ebb6 0e02 	subs.w	lr, r6, r2
 800ad2e:	eb75 0e03 	sbcs.w	lr, r5, r3
 800ad32:	bf22      	ittt	cs
 800ad34:	1ab6      	subcs	r6, r6, r2
 800ad36:	4675      	movcs	r5, lr
 800ad38:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 800ad3c:	085b      	lsrs	r3, r3, #1
 800ad3e:	ea4f 0232 	mov.w	r2, r2, rrx
 800ad42:	ebb6 0e02 	subs.w	lr, r6, r2
 800ad46:	eb75 0e03 	sbcs.w	lr, r5, r3
 800ad4a:	bf22      	ittt	cs
 800ad4c:	1ab6      	subcs	r6, r6, r2
 800ad4e:	4675      	movcs	r5, lr
 800ad50:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 800ad54:	ea55 0e06 	orrs.w	lr, r5, r6
 800ad58:	d018      	beq.n	800ad8c <__aeabi_ddiv+0x114>
 800ad5a:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800ad5e:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800ad62:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800ad66:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800ad6a:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800ad6e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800ad72:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800ad76:	d1c0      	bne.n	800acfa <__aeabi_ddiv+0x82>
 800ad78:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800ad7c:	d10b      	bne.n	800ad96 <__aeabi_ddiv+0x11e>
 800ad7e:	ea41 0100 	orr.w	r1, r1, r0
 800ad82:	f04f 0000 	mov.w	r0, #0
 800ad86:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800ad8a:	e7b6      	b.n	800acfa <__aeabi_ddiv+0x82>
 800ad8c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800ad90:	bf04      	itt	eq
 800ad92:	4301      	orreq	r1, r0
 800ad94:	2000      	moveq	r0, #0
 800ad96:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800ad9a:	bf88      	it	hi
 800ad9c:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800ada0:	f63f aeaf 	bhi.w	800ab02 <__aeabi_dmul+0xde>
 800ada4:	ebb5 0c03 	subs.w	ip, r5, r3
 800ada8:	bf04      	itt	eq
 800adaa:	ebb6 0c02 	subseq.w	ip, r6, r2
 800adae:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800adb2:	f150 0000 	adcs.w	r0, r0, #0
 800adb6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800adba:	bd70      	pop	{r4, r5, r6, pc}
 800adbc:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800adc0:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 800adc4:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 800adc8:	bfc2      	ittt	gt
 800adca:	ebd4 050c 	rsbsgt	r5, r4, ip
 800adce:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800add2:	bd70      	popgt	{r4, r5, r6, pc}
 800add4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800add8:	f04f 0e00 	mov.w	lr, #0
 800addc:	3c01      	subs	r4, #1
 800adde:	e690      	b.n	800ab02 <__aeabi_dmul+0xde>
 800ade0:	ea45 0e06 	orr.w	lr, r5, r6
 800ade4:	e68d      	b.n	800ab02 <__aeabi_dmul+0xde>
 800ade6:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800adea:	ea94 0f0c 	teq	r4, ip
 800adee:	bf08      	it	eq
 800adf0:	ea95 0f0c 	teqeq	r5, ip
 800adf4:	f43f af3b 	beq.w	800ac6e <__aeabi_dmul+0x24a>
 800adf8:	ea94 0f0c 	teq	r4, ip
 800adfc:	d10a      	bne.n	800ae14 <__aeabi_ddiv+0x19c>
 800adfe:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800ae02:	f47f af34 	bne.w	800ac6e <__aeabi_dmul+0x24a>
 800ae06:	ea95 0f0c 	teq	r5, ip
 800ae0a:	f47f af25 	bne.w	800ac58 <__aeabi_dmul+0x234>
 800ae0e:	4610      	mov	r0, r2
 800ae10:	4619      	mov	r1, r3
 800ae12:	e72c      	b.n	800ac6e <__aeabi_dmul+0x24a>
 800ae14:	ea95 0f0c 	teq	r5, ip
 800ae18:	d106      	bne.n	800ae28 <__aeabi_ddiv+0x1b0>
 800ae1a:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800ae1e:	f43f aefd 	beq.w	800ac1c <__aeabi_dmul+0x1f8>
 800ae22:	4610      	mov	r0, r2
 800ae24:	4619      	mov	r1, r3
 800ae26:	e722      	b.n	800ac6e <__aeabi_dmul+0x24a>
 800ae28:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800ae2c:	bf18      	it	ne
 800ae2e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800ae32:	f47f aec5 	bne.w	800abc0 <__aeabi_dmul+0x19c>
 800ae36:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 800ae3a:	f47f af0d 	bne.w	800ac58 <__aeabi_dmul+0x234>
 800ae3e:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800ae42:	f47f aeeb 	bne.w	800ac1c <__aeabi_dmul+0x1f8>
 800ae46:	e712      	b.n	800ac6e <__aeabi_dmul+0x24a>

0800ae48 <__gedf2>:
 800ae48:	f04f 3cff 	mov.w	ip, #4294967295
 800ae4c:	e006      	b.n	800ae5c <__cmpdf2+0x4>
 800ae4e:	bf00      	nop

0800ae50 <__ledf2>:
 800ae50:	f04f 0c01 	mov.w	ip, #1
 800ae54:	e002      	b.n	800ae5c <__cmpdf2+0x4>
 800ae56:	bf00      	nop

0800ae58 <__cmpdf2>:
 800ae58:	f04f 0c01 	mov.w	ip, #1
 800ae5c:	f84d cd04 	str.w	ip, [sp, #-4]!
 800ae60:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800ae64:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800ae68:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800ae6c:	bf18      	it	ne
 800ae6e:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 800ae72:	d01b      	beq.n	800aeac <__cmpdf2+0x54>
 800ae74:	b001      	add	sp, #4
 800ae76:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 800ae7a:	bf0c      	ite	eq
 800ae7c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 800ae80:	ea91 0f03 	teqne	r1, r3
 800ae84:	bf02      	ittt	eq
 800ae86:	ea90 0f02 	teqeq	r0, r2
 800ae8a:	2000      	moveq	r0, #0
 800ae8c:	4770      	bxeq	lr
 800ae8e:	f110 0f00 	cmn.w	r0, #0
 800ae92:	ea91 0f03 	teq	r1, r3
 800ae96:	bf58      	it	pl
 800ae98:	4299      	cmppl	r1, r3
 800ae9a:	bf08      	it	eq
 800ae9c:	4290      	cmpeq	r0, r2
 800ae9e:	bf2c      	ite	cs
 800aea0:	17d8      	asrcs	r0, r3, #31
 800aea2:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 800aea6:	f040 0001 	orr.w	r0, r0, #1
 800aeaa:	4770      	bx	lr
 800aeac:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800aeb0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800aeb4:	d102      	bne.n	800aebc <__cmpdf2+0x64>
 800aeb6:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800aeba:	d107      	bne.n	800aecc <__cmpdf2+0x74>
 800aebc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800aec0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800aec4:	d1d6      	bne.n	800ae74 <__cmpdf2+0x1c>
 800aec6:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800aeca:	d0d3      	beq.n	800ae74 <__cmpdf2+0x1c>
 800aecc:	f85d 0b04 	ldr.w	r0, [sp], #4
 800aed0:	4770      	bx	lr
 800aed2:	bf00      	nop

0800aed4 <__aeabi_cdrcmple>:
 800aed4:	4684      	mov	ip, r0
 800aed6:	4610      	mov	r0, r2
 800aed8:	4662      	mov	r2, ip
 800aeda:	468c      	mov	ip, r1
 800aedc:	4619      	mov	r1, r3
 800aede:	4663      	mov	r3, ip
 800aee0:	e000      	b.n	800aee4 <__aeabi_cdcmpeq>
 800aee2:	bf00      	nop

0800aee4 <__aeabi_cdcmpeq>:
 800aee4:	b501      	push	{r0, lr}
 800aee6:	f7ff ffb7 	bl	800ae58 <__cmpdf2>
 800aeea:	2800      	cmp	r0, #0
 800aeec:	bf48      	it	mi
 800aeee:	f110 0f00 	cmnmi.w	r0, #0
 800aef2:	bd01      	pop	{r0, pc}

0800aef4 <__aeabi_dcmpeq>:
 800aef4:	f84d ed08 	str.w	lr, [sp, #-8]!
 800aef8:	f7ff fff4 	bl	800aee4 <__aeabi_cdcmpeq>
 800aefc:	bf0c      	ite	eq
 800aefe:	2001      	moveq	r0, #1
 800af00:	2000      	movne	r0, #0
 800af02:	f85d fb08 	ldr.w	pc, [sp], #8
 800af06:	bf00      	nop

0800af08 <__aeabi_dcmplt>:
 800af08:	f84d ed08 	str.w	lr, [sp, #-8]!
 800af0c:	f7ff ffea 	bl	800aee4 <__aeabi_cdcmpeq>
 800af10:	bf34      	ite	cc
 800af12:	2001      	movcc	r0, #1
 800af14:	2000      	movcs	r0, #0
 800af16:	f85d fb08 	ldr.w	pc, [sp], #8
 800af1a:	bf00      	nop

0800af1c <__aeabi_dcmple>:
 800af1c:	f84d ed08 	str.w	lr, [sp, #-8]!
 800af20:	f7ff ffe0 	bl	800aee4 <__aeabi_cdcmpeq>
 800af24:	bf94      	ite	ls
 800af26:	2001      	movls	r0, #1
 800af28:	2000      	movhi	r0, #0
 800af2a:	f85d fb08 	ldr.w	pc, [sp], #8
 800af2e:	bf00      	nop

0800af30 <__aeabi_dcmpge>:
 800af30:	f84d ed08 	str.w	lr, [sp, #-8]!
 800af34:	f7ff ffce 	bl	800aed4 <__aeabi_cdrcmple>
 800af38:	bf94      	ite	ls
 800af3a:	2001      	movls	r0, #1
 800af3c:	2000      	movhi	r0, #0
 800af3e:	f85d fb08 	ldr.w	pc, [sp], #8
 800af42:	bf00      	nop

0800af44 <__aeabi_dcmpgt>:
 800af44:	f84d ed08 	str.w	lr, [sp, #-8]!
 800af48:	f7ff ffc4 	bl	800aed4 <__aeabi_cdrcmple>
 800af4c:	bf34      	ite	cc
 800af4e:	2001      	movcc	r0, #1
 800af50:	2000      	movcs	r0, #0
 800af52:	f85d fb08 	ldr.w	pc, [sp], #8
 800af56:	bf00      	nop

0800af58 <__aeabi_d2iz>:
 800af58:	ea4f 0241 	mov.w	r2, r1, lsl #1
 800af5c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 800af60:	d215      	bcs.n	800af8e <__aeabi_d2iz+0x36>
 800af62:	d511      	bpl.n	800af88 <__aeabi_d2iz+0x30>
 800af64:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 800af68:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 800af6c:	d912      	bls.n	800af94 <__aeabi_d2iz+0x3c>
 800af6e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800af72:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800af76:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 800af7a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800af7e:	fa23 f002 	lsr.w	r0, r3, r2
 800af82:	bf18      	it	ne
 800af84:	4240      	negne	r0, r0
 800af86:	4770      	bx	lr
 800af88:	f04f 0000 	mov.w	r0, #0
 800af8c:	4770      	bx	lr
 800af8e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 800af92:	d105      	bne.n	800afa0 <__aeabi_d2iz+0x48>
 800af94:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 800af98:	bf08      	it	eq
 800af9a:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 800af9e:	4770      	bx	lr
 800afa0:	f04f 0000 	mov.w	r0, #0
 800afa4:	4770      	bx	lr
 800afa6:	bf00      	nop

0800afa8 <__aeabi_uldivmod>:
 800afa8:	b94b      	cbnz	r3, 800afbe <__aeabi_uldivmod+0x16>
 800afaa:	b942      	cbnz	r2, 800afbe <__aeabi_uldivmod+0x16>
 800afac:	2900      	cmp	r1, #0
 800afae:	bf08      	it	eq
 800afb0:	2800      	cmpeq	r0, #0
 800afb2:	d002      	beq.n	800afba <__aeabi_uldivmod+0x12>
 800afb4:	f04f 31ff 	mov.w	r1, #4294967295
 800afb8:	4608      	mov	r0, r1
 800afba:	f7ff bb79 	b.w	800a6b0 <__aeabi_idiv0>
 800afbe:	b082      	sub	sp, #8
 800afc0:	46ec      	mov	ip, sp
 800afc2:	e92d 5000 	stmdb	sp!, {ip, lr}
 800afc6:	f000 f81d 	bl	800b004 <__gnu_uldivmod_helper>
 800afca:	f8dd e004 	ldr.w	lr, [sp, #4]
 800afce:	b002      	add	sp, #8
 800afd0:	bc0c      	pop	{r2, r3}
 800afd2:	4770      	bx	lr

0800afd4 <__gnu_ldivmod_helper>:
 800afd4:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 800afd8:	4616      	mov	r6, r2
 800afda:	4680      	mov	r8, r0
 800afdc:	4689      	mov	r9, r1
 800afde:	461d      	mov	r5, r3
 800afe0:	f000 f828 	bl	800b034 <__divdi3>
 800afe4:	fb00 f305 	mul.w	r3, r0, r5
 800afe8:	fba0 4506 	umull	r4, r5, r0, r6
 800afec:	fb06 3601 	mla	r6, r6, r1, r3
 800aff0:	9b06      	ldr	r3, [sp, #24]
 800aff2:	1975      	adds	r5, r6, r5
 800aff4:	ebb8 0404 	subs.w	r4, r8, r4
 800aff8:	eb69 0505 	sbc.w	r5, r9, r5
 800affc:	e9c3 4500 	strd	r4, r5, [r3]
 800b000:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

0800b004 <__gnu_uldivmod_helper>:
 800b004:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 800b008:	4616      	mov	r6, r2
 800b00a:	4680      	mov	r8, r0
 800b00c:	4689      	mov	r9, r1
 800b00e:	461d      	mov	r5, r3
 800b010:	f000 f9c0 	bl	800b394 <__udivdi3>
 800b014:	fb00 f305 	mul.w	r3, r0, r5
 800b018:	fba0 4506 	umull	r4, r5, r0, r6
 800b01c:	fb06 3601 	mla	r6, r6, r1, r3
 800b020:	9b06      	ldr	r3, [sp, #24]
 800b022:	1975      	adds	r5, r6, r5
 800b024:	ebb8 0404 	subs.w	r4, r8, r4
 800b028:	eb69 0505 	sbc.w	r5, r9, r5
 800b02c:	e9c3 4500 	strd	r4, r5, [r3]
 800b030:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

0800b034 <__divdi3>:
 800b034:	2900      	cmp	r1, #0
 800b036:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b03a:	461c      	mov	r4, r3
 800b03c:	b085      	sub	sp, #20
 800b03e:	f2c0 80cb 	blt.w	800b1d8 <__divdi3+0x1a4>
 800b042:	2600      	movs	r6, #0
 800b044:	2c00      	cmp	r4, #0
 800b046:	f2c0 80c2 	blt.w	800b1ce <__divdi3+0x19a>
 800b04a:	468c      	mov	ip, r1
 800b04c:	4617      	mov	r7, r2
 800b04e:	4614      	mov	r4, r2
 800b050:	4605      	mov	r5, r0
 800b052:	4688      	mov	r8, r1
 800b054:	469a      	mov	sl, r3
 800b056:	2b00      	cmp	r3, #0
 800b058:	d14a      	bne.n	800b0f0 <__divdi3+0xbc>
 800b05a:	428a      	cmp	r2, r1
 800b05c:	d96e      	bls.n	800b13c <__divdi3+0x108>
 800b05e:	fab2 f382 	clz	r3, r2
 800b062:	b15b      	cbz	r3, 800b07c <__divdi3+0x48>
 800b064:	f1c3 0420 	rsb	r4, r3, #32
 800b068:	fa01 f803 	lsl.w	r8, r1, r3
 800b06c:	fa30 f204 	lsrs.w	r2, r0, r4
 800b070:	fa10 f503 	lsls.w	r5, r0, r3
 800b074:	fa17 f403 	lsls.w	r4, r7, r3
 800b078:	ea42 0808 	orr.w	r8, r2, r8
 800b07c:	ea4f 4a14 	mov.w	sl, r4, lsr #16
 800b080:	4640      	mov	r0, r8
 800b082:	4651      	mov	r1, sl
 800b084:	fa1f fb84 	uxth.w	fp, r4
 800b088:	f7ff f9d6 	bl	800a438 <__aeabi_uidiv>
 800b08c:	4651      	mov	r1, sl
 800b08e:	4681      	mov	r9, r0
 800b090:	4640      	mov	r0, r8
 800b092:	f7ff faff 	bl	800a694 <__aeabi_uidivmod>
 800b096:	0c28      	lsrs	r0, r5, #16
 800b098:	fb0b f309 	mul.w	r3, fp, r9
 800b09c:	ea40 4801 	orr.w	r8, r0, r1, lsl #16
 800b0a0:	4543      	cmp	r3, r8
 800b0a2:	d909      	bls.n	800b0b8 <__divdi3+0x84>
 800b0a4:	eb18 0804 	adds.w	r8, r8, r4
 800b0a8:	f109 39ff 	add.w	r9, r9, #4294967295
 800b0ac:	d204      	bcs.n	800b0b8 <__divdi3+0x84>
 800b0ae:	4543      	cmp	r3, r8
 800b0b0:	bf84      	itt	hi
 800b0b2:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800b0b6:	44a0      	addhi	r8, r4
 800b0b8:	ebc3 0808 	rsb	r8, r3, r8
 800b0bc:	4651      	mov	r1, sl
 800b0be:	4640      	mov	r0, r8
 800b0c0:	b2ad      	uxth	r5, r5
 800b0c2:	f7ff f9b9 	bl	800a438 <__aeabi_uidiv>
 800b0c6:	4651      	mov	r1, sl
 800b0c8:	4607      	mov	r7, r0
 800b0ca:	4640      	mov	r0, r8
 800b0cc:	f7ff fae2 	bl	800a694 <__aeabi_uidivmod>
 800b0d0:	fb0b fb07 	mul.w	fp, fp, r7
 800b0d4:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
 800b0d8:	45ab      	cmp	fp, r5
 800b0da:	d905      	bls.n	800b0e8 <__divdi3+0xb4>
 800b0dc:	3f01      	subs	r7, #1
 800b0de:	192d      	adds	r5, r5, r4
 800b0e0:	d202      	bcs.n	800b0e8 <__divdi3+0xb4>
 800b0e2:	45ab      	cmp	fp, r5
 800b0e4:	bf88      	it	hi
 800b0e6:	3f01      	subhi	r7, #1
 800b0e8:	ea47 4909 	orr.w	r9, r7, r9, lsl #16
 800b0ec:	2400      	movs	r4, #0
 800b0ee:	e003      	b.n	800b0f8 <__divdi3+0xc4>
 800b0f0:	428b      	cmp	r3, r1
 800b0f2:	d90c      	bls.n	800b10e <__divdi3+0xda>
 800b0f4:	2400      	movs	r4, #0
 800b0f6:	46a1      	mov	r9, r4
 800b0f8:	464a      	mov	r2, r9
 800b0fa:	4623      	mov	r3, r4
 800b0fc:	b116      	cbz	r6, 800b104 <__divdi3+0xd0>
 800b0fe:	4252      	negs	r2, r2
 800b100:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800b104:	4610      	mov	r0, r2
 800b106:	4619      	mov	r1, r3
 800b108:	b005      	add	sp, #20
 800b10a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b10e:	fab3 f483 	clz	r4, r3
 800b112:	2c00      	cmp	r4, #0
 800b114:	f040 80b3 	bne.w	800b27e <__divdi3+0x24a>
 800b118:	428b      	cmp	r3, r1
 800b11a:	f04f 0901 	mov.w	r9, #1
 800b11e:	bf2c      	ite	cs
 800b120:	f04f 0c00 	movcs.w	ip, #0
 800b124:	f04f 0c01 	movcc.w	ip, #1
 800b128:	4282      	cmp	r2, r0
 800b12a:	bf8c      	ite	hi
 800b12c:	4667      	movhi	r7, ip
 800b12e:	f04c 0701 	orrls.w	r7, ip, #1
 800b132:	2f00      	cmp	r7, #0
 800b134:	d1e0      	bne.n	800b0f8 <__divdi3+0xc4>
 800b136:	463c      	mov	r4, r7
 800b138:	46b9      	mov	r9, r7
 800b13a:	e7dd      	b.n	800b0f8 <__divdi3+0xc4>
 800b13c:	b922      	cbnz	r2, 800b148 <__divdi3+0x114>
 800b13e:	2001      	movs	r0, #1
 800b140:	4611      	mov	r1, r2
 800b142:	f7ff f979 	bl	800a438 <__aeabi_uidiv>
 800b146:	4604      	mov	r4, r0
 800b148:	fab4 f384 	clz	r3, r4
 800b14c:	2b00      	cmp	r3, #0
 800b14e:	d149      	bne.n	800b1e4 <__divdi3+0x1b0>
 800b150:	ebc4 0808 	rsb	r8, r4, r8
 800b154:	0c27      	lsrs	r7, r4, #16
 800b156:	fa1f fa84 	uxth.w	sl, r4
 800b15a:	2101      	movs	r1, #1
 800b15c:	9102      	str	r1, [sp, #8]
 800b15e:	4639      	mov	r1, r7
 800b160:	4640      	mov	r0, r8
 800b162:	f7ff f969 	bl	800a438 <__aeabi_uidiv>
 800b166:	4639      	mov	r1, r7
 800b168:	4681      	mov	r9, r0
 800b16a:	4640      	mov	r0, r8
 800b16c:	f7ff fa92 	bl	800a694 <__aeabi_uidivmod>
 800b170:	0c2a      	lsrs	r2, r5, #16
 800b172:	fb0a f309 	mul.w	r3, sl, r9
 800b176:	ea42 4b01 	orr.w	fp, r2, r1, lsl #16
 800b17a:	455b      	cmp	r3, fp
 800b17c:	d909      	bls.n	800b192 <__divdi3+0x15e>
 800b17e:	eb1b 0b04 	adds.w	fp, fp, r4
 800b182:	f109 39ff 	add.w	r9, r9, #4294967295
 800b186:	d204      	bcs.n	800b192 <__divdi3+0x15e>
 800b188:	455b      	cmp	r3, fp
 800b18a:	bf84      	itt	hi
 800b18c:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800b190:	44a3      	addhi	fp, r4
 800b192:	ebc3 0b0b 	rsb	fp, r3, fp
 800b196:	4639      	mov	r1, r7
 800b198:	4658      	mov	r0, fp
 800b19a:	b2ad      	uxth	r5, r5
 800b19c:	f7ff f94c 	bl	800a438 <__aeabi_uidiv>
 800b1a0:	4639      	mov	r1, r7
 800b1a2:	4680      	mov	r8, r0
 800b1a4:	4658      	mov	r0, fp
 800b1a6:	f7ff fa75 	bl	800a694 <__aeabi_uidivmod>
 800b1aa:	fb0a fa08 	mul.w	sl, sl, r8
 800b1ae:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
 800b1b2:	45aa      	cmp	sl, r5
 800b1b4:	d907      	bls.n	800b1c6 <__divdi3+0x192>
 800b1b6:	192d      	adds	r5, r5, r4
 800b1b8:	f108 38ff 	add.w	r8, r8, #4294967295
 800b1bc:	d203      	bcs.n	800b1c6 <__divdi3+0x192>
 800b1be:	45aa      	cmp	sl, r5
 800b1c0:	bf88      	it	hi
 800b1c2:	f108 38ff 	addhi.w	r8, r8, #4294967295
 800b1c6:	ea48 4909 	orr.w	r9, r8, r9, lsl #16
 800b1ca:	9c02      	ldr	r4, [sp, #8]
 800b1cc:	e794      	b.n	800b0f8 <__divdi3+0xc4>
 800b1ce:	43f6      	mvns	r6, r6
 800b1d0:	4252      	negs	r2, r2
 800b1d2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800b1d6:	e738      	b.n	800b04a <__divdi3+0x16>
 800b1d8:	4240      	negs	r0, r0
 800b1da:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800b1de:	f04f 36ff 	mov.w	r6, #4294967295
 800b1e2:	e72f      	b.n	800b044 <__divdi3+0x10>
 800b1e4:	409c      	lsls	r4, r3
 800b1e6:	f1c3 0720 	rsb	r7, r3, #32
 800b1ea:	fa28 fa07 	lsr.w	sl, r8, r7
 800b1ee:	fa35 f207 	lsrs.w	r2, r5, r7
 800b1f2:	0c27      	lsrs	r7, r4, #16
 800b1f4:	fa08 fb03 	lsl.w	fp, r8, r3
 800b1f8:	4639      	mov	r1, r7
 800b1fa:	4650      	mov	r0, sl
 800b1fc:	ea42 020b 	orr.w	r2, r2, fp
 800b200:	409d      	lsls	r5, r3
 800b202:	9202      	str	r2, [sp, #8]
 800b204:	f7ff f918 	bl	800a438 <__aeabi_uidiv>
 800b208:	4639      	mov	r1, r7
 800b20a:	4683      	mov	fp, r0
 800b20c:	4650      	mov	r0, sl
 800b20e:	f7ff fa41 	bl	800a694 <__aeabi_uidivmod>
 800b212:	9b02      	ldr	r3, [sp, #8]
 800b214:	fa1f fa84 	uxth.w	sl, r4
 800b218:	ea4f 4913 	mov.w	r9, r3, lsr #16
 800b21c:	fb0a f30b 	mul.w	r3, sl, fp
 800b220:	ea49 4801 	orr.w	r8, r9, r1, lsl #16
 800b224:	4543      	cmp	r3, r8
 800b226:	d905      	bls.n	800b234 <__divdi3+0x200>
 800b228:	eb18 0804 	adds.w	r8, r8, r4
 800b22c:	f10b 3bff 	add.w	fp, fp, #4294967295
 800b230:	f0c0 80aa 	bcc.w	800b388 <__divdi3+0x354>
 800b234:	ebc3 0808 	rsb	r8, r3, r8
 800b238:	4639      	mov	r1, r7
 800b23a:	4640      	mov	r0, r8
 800b23c:	f7ff f8fc 	bl	800a438 <__aeabi_uidiv>
 800b240:	4639      	mov	r1, r7
 800b242:	4681      	mov	r9, r0
 800b244:	4640      	mov	r0, r8
 800b246:	f7ff fa25 	bl	800a694 <__aeabi_uidivmod>
 800b24a:	9802      	ldr	r0, [sp, #8]
 800b24c:	fb0a f309 	mul.w	r3, sl, r9
 800b250:	fa1f fc80 	uxth.w	ip, r0
 800b254:	ea4c 4801 	orr.w	r8, ip, r1, lsl #16
 800b258:	4543      	cmp	r3, r8
 800b25a:	d909      	bls.n	800b270 <__divdi3+0x23c>
 800b25c:	eb18 0804 	adds.w	r8, r8, r4
 800b260:	f109 39ff 	add.w	r9, r9, #4294967295
 800b264:	d204      	bcs.n	800b270 <__divdi3+0x23c>
 800b266:	4543      	cmp	r3, r8
 800b268:	bf84      	itt	hi
 800b26a:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800b26e:	44a0      	addhi	r8, r4
 800b270:	ea49 4e0b 	orr.w	lr, r9, fp, lsl #16
 800b274:	ebc3 0808 	rsb	r8, r3, r8
 800b278:	f8cd e008 	str.w	lr, [sp, #8]
 800b27c:	e76f      	b.n	800b15e <__divdi3+0x12a>
 800b27e:	f1c4 0320 	rsb	r3, r4, #32
 800b282:	fa0a fa04 	lsl.w	sl, sl, r4
 800b286:	40da      	lsrs	r2, r3
 800b288:	fa21 f803 	lsr.w	r8, r1, r3
 800b28c:	ea42 0a0a 	orr.w	sl, r2, sl
 800b290:	fa01 f904 	lsl.w	r9, r1, r4
 800b294:	fa30 f203 	lsrs.w	r2, r0, r3
 800b298:	4640      	mov	r0, r8
 800b29a:	ea4f 4b1a 	mov.w	fp, sl, lsr #16
 800b29e:	ea42 0109 	orr.w	r1, r2, r9
 800b2a2:	9103      	str	r1, [sp, #12]
 800b2a4:	4659      	mov	r1, fp
 800b2a6:	fa17 f304 	lsls.w	r3, r7, r4
 800b2aa:	9302      	str	r3, [sp, #8]
 800b2ac:	f7ff f8c4 	bl	800a438 <__aeabi_uidiv>
 800b2b0:	4659      	mov	r1, fp
 800b2b2:	4681      	mov	r9, r0
 800b2b4:	4640      	mov	r0, r8
 800b2b6:	f7ff f9ed 	bl	800a694 <__aeabi_uidivmod>
 800b2ba:	fa1f f38a 	uxth.w	r3, sl
 800b2be:	9803      	ldr	r0, [sp, #12]
 800b2c0:	fb03 f209 	mul.w	r2, r3, r9
 800b2c4:	0c07      	lsrs	r7, r0, #16
 800b2c6:	ea47 4801 	orr.w	r8, r7, r1, lsl #16
 800b2ca:	4542      	cmp	r2, r8
 800b2cc:	d904      	bls.n	800b2d8 <__divdi3+0x2a4>
 800b2ce:	eb18 080a 	adds.w	r8, r8, sl
 800b2d2:	f109 39ff 	add.w	r9, r9, #4294967295
 800b2d6:	d351      	bcc.n	800b37c <__divdi3+0x348>
 800b2d8:	ebc2 0808 	rsb	r8, r2, r8
 800b2dc:	4659      	mov	r1, fp
 800b2de:	4640      	mov	r0, r8
 800b2e0:	9301      	str	r3, [sp, #4]
 800b2e2:	f7ff f8a9 	bl	800a438 <__aeabi_uidiv>
 800b2e6:	4659      	mov	r1, fp
 800b2e8:	4607      	mov	r7, r0
 800b2ea:	4640      	mov	r0, r8
 800b2ec:	f7ff f9d2 	bl	800a694 <__aeabi_uidivmod>
 800b2f0:	9b01      	ldr	r3, [sp, #4]
 800b2f2:	9803      	ldr	r0, [sp, #12]
 800b2f4:	fb03 f307 	mul.w	r3, r3, r7
 800b2f8:	fa1f fc80 	uxth.w	ip, r0
 800b2fc:	ea4c 4c01 	orr.w	ip, ip, r1, lsl #16
 800b300:	4563      	cmp	r3, ip
 800b302:	d907      	bls.n	800b314 <__divdi3+0x2e0>
 800b304:	3f01      	subs	r7, #1
 800b306:	eb1c 0c0a 	adds.w	ip, ip, sl
 800b30a:	d203      	bcs.n	800b314 <__divdi3+0x2e0>
 800b30c:	4563      	cmp	r3, ip
 800b30e:	d901      	bls.n	800b314 <__divdi3+0x2e0>
 800b310:	3f01      	subs	r7, #1
 800b312:	44d4      	add	ip, sl
 800b314:	ea47 4909 	orr.w	r9, r7, r9, lsl #16
 800b318:	9f02      	ldr	r7, [sp, #8]
 800b31a:	ebc3 0c0c 	rsb	ip, r3, ip
 800b31e:	fa1f fe89 	uxth.w	lr, r9
 800b322:	ea4f 4319 	mov.w	r3, r9, lsr #16
 800b326:	b2b8      	uxth	r0, r7
 800b328:	0c3f      	lsrs	r7, r7, #16
 800b32a:	fb00 f80e 	mul.w	r8, r0, lr
 800b32e:	fb00 f103 	mul.w	r1, r0, r3
 800b332:	fb07 120e 	mla	r2, r7, lr, r1
 800b336:	fb07 f003 	mul.w	r0, r7, r3
 800b33a:	eb02 4218 	add.w	r2, r2, r8, lsr #16
 800b33e:	4291      	cmp	r1, r2
 800b340:	bf88      	it	hi
 800b342:	f500 3080 	addhi.w	r0, r0, #65536	; 0x10000
 800b346:	eb00 4e12 	add.w	lr, r0, r2, lsr #16
 800b34a:	45f4      	cmp	ip, lr
 800b34c:	d312      	bcc.n	800b374 <__divdi3+0x340>
 800b34e:	ea4f 4202 	mov.w	r2, r2, lsl #16
 800b352:	fa1f f888 	uxth.w	r8, r8
 800b356:	bf14      	ite	ne
 800b358:	2100      	movne	r1, #0
 800b35a:	2101      	moveq	r1, #1
 800b35c:	eb02 0c08 	add.w	ip, r2, r8
 800b360:	fa15 f404 	lsls.w	r4, r5, r4
 800b364:	4564      	cmp	r4, ip
 800b366:	bf2c      	ite	cs
 800b368:	2400      	movcs	r4, #0
 800b36a:	f001 0401 	andcc.w	r4, r1, #1
 800b36e:	2c00      	cmp	r4, #0
 800b370:	f43f aec2 	beq.w	800b0f8 <__divdi3+0xc4>
 800b374:	f109 39ff 	add.w	r9, r9, #4294967295
 800b378:	2400      	movs	r4, #0
 800b37a:	e6bd      	b.n	800b0f8 <__divdi3+0xc4>
 800b37c:	4542      	cmp	r2, r8
 800b37e:	bf84      	itt	hi
 800b380:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800b384:	44d0      	addhi	r8, sl
 800b386:	e7a7      	b.n	800b2d8 <__divdi3+0x2a4>
 800b388:	4543      	cmp	r3, r8
 800b38a:	bf84      	itt	hi
 800b38c:	f10b 3bff 	addhi.w	fp, fp, #4294967295
 800b390:	44a0      	addhi	r8, r4
 800b392:	e74f      	b.n	800b234 <__divdi3+0x200>

0800b394 <__udivdi3>:
 800b394:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b398:	4605      	mov	r5, r0
 800b39a:	b083      	sub	sp, #12
 800b39c:	460c      	mov	r4, r1
 800b39e:	4617      	mov	r7, r2
 800b3a0:	4680      	mov	r8, r0
 800b3a2:	460e      	mov	r6, r1
 800b3a4:	2b00      	cmp	r3, #0
 800b3a6:	d14d      	bne.n	800b444 <__udivdi3+0xb0>
 800b3a8:	428a      	cmp	r2, r1
 800b3aa:	d961      	bls.n	800b470 <__udivdi3+0xdc>
 800b3ac:	fab2 f382 	clz	r3, r2
 800b3b0:	b153      	cbz	r3, 800b3c8 <__udivdi3+0x34>
 800b3b2:	f1c3 0420 	rsb	r4, r3, #32
 800b3b6:	fa11 f603 	lsls.w	r6, r1, r3
 800b3ba:	fa30 f204 	lsrs.w	r2, r0, r4
 800b3be:	409f      	lsls	r7, r3
 800b3c0:	ea42 0606 	orr.w	r6, r2, r6
 800b3c4:	fa00 f803 	lsl.w	r8, r0, r3
 800b3c8:	0c3c      	lsrs	r4, r7, #16
 800b3ca:	4630      	mov	r0, r6
 800b3cc:	4621      	mov	r1, r4
 800b3ce:	fa1f fa87 	uxth.w	sl, r7
 800b3d2:	f7ff f831 	bl	800a438 <__aeabi_uidiv>
 800b3d6:	4621      	mov	r1, r4
 800b3d8:	4681      	mov	r9, r0
 800b3da:	4630      	mov	r0, r6
 800b3dc:	f7ff f95a 	bl	800a694 <__aeabi_uidivmod>
 800b3e0:	ea4f 4018 	mov.w	r0, r8, lsr #16
 800b3e4:	fb0a f309 	mul.w	r3, sl, r9
 800b3e8:	ea40 4601 	orr.w	r6, r0, r1, lsl #16
 800b3ec:	42b3      	cmp	r3, r6
 800b3ee:	d908      	bls.n	800b402 <__udivdi3+0x6e>
 800b3f0:	19f6      	adds	r6, r6, r7
 800b3f2:	f109 39ff 	add.w	r9, r9, #4294967295
 800b3f6:	d204      	bcs.n	800b402 <__udivdi3+0x6e>
 800b3f8:	42b3      	cmp	r3, r6
 800b3fa:	bf84      	itt	hi
 800b3fc:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800b400:	19f6      	addhi	r6, r6, r7
 800b402:	1af6      	subs	r6, r6, r3
 800b404:	4621      	mov	r1, r4
 800b406:	4630      	mov	r0, r6
 800b408:	fa1f f888 	uxth.w	r8, r8
 800b40c:	f7ff f814 	bl	800a438 <__aeabi_uidiv>
 800b410:	4621      	mov	r1, r4
 800b412:	4605      	mov	r5, r0
 800b414:	4630      	mov	r0, r6
 800b416:	f7ff f93d 	bl	800a694 <__aeabi_uidivmod>
 800b41a:	fb0a fa05 	mul.w	sl, sl, r5
 800b41e:	ea48 4801 	orr.w	r8, r8, r1, lsl #16
 800b422:	45c2      	cmp	sl, r8
 800b424:	d906      	bls.n	800b434 <__udivdi3+0xa0>
 800b426:	3d01      	subs	r5, #1
 800b428:	eb18 0807 	adds.w	r8, r8, r7
 800b42c:	d202      	bcs.n	800b434 <__udivdi3+0xa0>
 800b42e:	45c2      	cmp	sl, r8
 800b430:	bf88      	it	hi
 800b432:	3d01      	subhi	r5, #1
 800b434:	ea45 4a09 	orr.w	sl, r5, r9, lsl #16
 800b438:	2600      	movs	r6, #0
 800b43a:	4631      	mov	r1, r6
 800b43c:	4650      	mov	r0, sl
 800b43e:	b003      	add	sp, #12
 800b440:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b444:	428b      	cmp	r3, r1
 800b446:	d85b      	bhi.n	800b500 <__udivdi3+0x16c>
 800b448:	fab3 f683 	clz	r6, r3
 800b44c:	2e00      	cmp	r6, #0
 800b44e:	d15a      	bne.n	800b506 <__udivdi3+0x172>
 800b450:	428b      	cmp	r3, r1
 800b452:	f04f 0a01 	mov.w	sl, #1
 800b456:	bf2c      	ite	cs
 800b458:	2400      	movcs	r4, #0
 800b45a:	2401      	movcc	r4, #1
 800b45c:	4282      	cmp	r2, r0
 800b45e:	bf8c      	ite	hi
 800b460:	4625      	movhi	r5, r4
 800b462:	f044 0501 	orrls.w	r5, r4, #1
 800b466:	2d00      	cmp	r5, #0
 800b468:	d1e7      	bne.n	800b43a <__udivdi3+0xa6>
 800b46a:	462e      	mov	r6, r5
 800b46c:	46aa      	mov	sl, r5
 800b46e:	e7e4      	b.n	800b43a <__udivdi3+0xa6>
 800b470:	b922      	cbnz	r2, 800b47c <__udivdi3+0xe8>
 800b472:	2001      	movs	r0, #1
 800b474:	4611      	mov	r1, r2
 800b476:	f7fe ffdf 	bl	800a438 <__aeabi_uidiv>
 800b47a:	4607      	mov	r7, r0
 800b47c:	fab7 f387 	clz	r3, r7
 800b480:	2b00      	cmp	r3, #0
 800b482:	f040 80b6 	bne.w	800b5f2 <__udivdi3+0x25e>
 800b486:	1be4      	subs	r4, r4, r7
 800b488:	ea4f 4b17 	mov.w	fp, r7, lsr #16
 800b48c:	b2bd      	uxth	r5, r7
 800b48e:	2601      	movs	r6, #1
 800b490:	4659      	mov	r1, fp
 800b492:	4620      	mov	r0, r4
 800b494:	f7fe ffd0 	bl	800a438 <__aeabi_uidiv>
 800b498:	4659      	mov	r1, fp
 800b49a:	ea4f 4918 	mov.w	r9, r8, lsr #16
 800b49e:	4682      	mov	sl, r0
 800b4a0:	4620      	mov	r0, r4
 800b4a2:	f7ff f8f7 	bl	800a694 <__aeabi_uidivmod>
 800b4a6:	fb05 f30a 	mul.w	r3, r5, sl
 800b4aa:	ea49 4401 	orr.w	r4, r9, r1, lsl #16
 800b4ae:	42a3      	cmp	r3, r4
 800b4b0:	d908      	bls.n	800b4c4 <__udivdi3+0x130>
 800b4b2:	19e4      	adds	r4, r4, r7
 800b4b4:	f10a 3aff 	add.w	sl, sl, #4294967295
 800b4b8:	d204      	bcs.n	800b4c4 <__udivdi3+0x130>
 800b4ba:	42a3      	cmp	r3, r4
 800b4bc:	bf84      	itt	hi
 800b4be:	f10a 3aff 	addhi.w	sl, sl, #4294967295
 800b4c2:	19e4      	addhi	r4, r4, r7
 800b4c4:	1ae4      	subs	r4, r4, r3
 800b4c6:	4659      	mov	r1, fp
 800b4c8:	4620      	mov	r0, r4
 800b4ca:	f7fe ffb5 	bl	800a438 <__aeabi_uidiv>
 800b4ce:	4659      	mov	r1, fp
 800b4d0:	4681      	mov	r9, r0
 800b4d2:	4620      	mov	r0, r4
 800b4d4:	f7ff f8de 	bl	800a694 <__aeabi_uidivmod>
 800b4d8:	fa1f f388 	uxth.w	r3, r8
 800b4dc:	fb05 f509 	mul.w	r5, r5, r9
 800b4e0:	ea43 4801 	orr.w	r8, r3, r1, lsl #16
 800b4e4:	4545      	cmp	r5, r8
 800b4e6:	d908      	bls.n	800b4fa <__udivdi3+0x166>
 800b4e8:	eb18 0807 	adds.w	r8, r8, r7
 800b4ec:	f109 39ff 	add.w	r9, r9, #4294967295
 800b4f0:	d203      	bcs.n	800b4fa <__udivdi3+0x166>
 800b4f2:	4545      	cmp	r5, r8
 800b4f4:	bf88      	it	hi
 800b4f6:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800b4fa:	ea49 4a0a 	orr.w	sl, r9, sl, lsl #16
 800b4fe:	e79c      	b.n	800b43a <__udivdi3+0xa6>
 800b500:	2600      	movs	r6, #0
 800b502:	46b2      	mov	sl, r6
 800b504:	e799      	b.n	800b43a <__udivdi3+0xa6>
 800b506:	f1c6 0120 	rsb	r1, r6, #32
 800b50a:	40b3      	lsls	r3, r6
 800b50c:	fa32 f701 	lsrs.w	r7, r2, r1
 800b510:	fa24 f901 	lsr.w	r9, r4, r1
 800b514:	431f      	orrs	r7, r3
 800b516:	40b4      	lsls	r4, r6
 800b518:	fa30 f301 	lsrs.w	r3, r0, r1
 800b51c:	4648      	mov	r0, r9
 800b51e:	ea4f 4817 	mov.w	r8, r7, lsr #16
 800b522:	ea43 0104 	orr.w	r1, r3, r4
 800b526:	9101      	str	r1, [sp, #4]
 800b528:	4641      	mov	r1, r8
 800b52a:	40b2      	lsls	r2, r6
 800b52c:	9200      	str	r2, [sp, #0]
 800b52e:	f7fe ff83 	bl	800a438 <__aeabi_uidiv>
 800b532:	4641      	mov	r1, r8
 800b534:	b2bc      	uxth	r4, r7
 800b536:	4682      	mov	sl, r0
 800b538:	4648      	mov	r0, r9
 800b53a:	f7ff f8ab 	bl	800a694 <__aeabi_uidivmod>
 800b53e:	9801      	ldr	r0, [sp, #4]
 800b540:	fb04 f30a 	mul.w	r3, r4, sl
 800b544:	ea4f 4b10 	mov.w	fp, r0, lsr #16
 800b548:	ea4b 4b01 	orr.w	fp, fp, r1, lsl #16
 800b54c:	455b      	cmp	r3, fp
 800b54e:	d905      	bls.n	800b55c <__udivdi3+0x1c8>
 800b550:	eb1b 0b07 	adds.w	fp, fp, r7
 800b554:	f10a 3aff 	add.w	sl, sl, #4294967295
 800b558:	f0c0 8093 	bcc.w	800b682 <__udivdi3+0x2ee>
 800b55c:	ebc3 0b0b 	rsb	fp, r3, fp
 800b560:	4641      	mov	r1, r8
 800b562:	4658      	mov	r0, fp
 800b564:	f7fe ff68 	bl	800a438 <__aeabi_uidiv>
 800b568:	4641      	mov	r1, r8
 800b56a:	4681      	mov	r9, r0
 800b56c:	4658      	mov	r0, fp
 800b56e:	f7ff f891 	bl	800a694 <__aeabi_uidivmod>
 800b572:	9801      	ldr	r0, [sp, #4]
 800b574:	fb04 f409 	mul.w	r4, r4, r9
 800b578:	fa1f fc80 	uxth.w	ip, r0
 800b57c:	ea4c 4301 	orr.w	r3, ip, r1, lsl #16
 800b580:	429c      	cmp	r4, r3
 800b582:	d903      	bls.n	800b58c <__udivdi3+0x1f8>
 800b584:	19db      	adds	r3, r3, r7
 800b586:	f109 39ff 	add.w	r9, r9, #4294967295
 800b58a:	d374      	bcc.n	800b676 <__udivdi3+0x2e2>
 800b58c:	9f00      	ldr	r7, [sp, #0]
 800b58e:	ea49 4a0a 	orr.w	sl, r9, sl, lsl #16
 800b592:	1b1c      	subs	r4, r3, r4
 800b594:	fa1f fe8a 	uxth.w	lr, sl
 800b598:	b2b8      	uxth	r0, r7
 800b59a:	0c3a      	lsrs	r2, r7, #16
 800b59c:	ea4f 471a 	mov.w	r7, sl, lsr #16
 800b5a0:	fb00 fc0e 	mul.w	ip, r0, lr
 800b5a4:	fb00 f307 	mul.w	r3, r0, r7
 800b5a8:	fb02 310e 	mla	r1, r2, lr, r3
 800b5ac:	fb02 f207 	mul.w	r2, r2, r7
 800b5b0:	eb01 411c 	add.w	r1, r1, ip, lsr #16
 800b5b4:	428b      	cmp	r3, r1
 800b5b6:	bf88      	it	hi
 800b5b8:	f502 3280 	addhi.w	r2, r2, #65536	; 0x10000
 800b5bc:	eb02 4e11 	add.w	lr, r2, r1, lsr #16
 800b5c0:	4574      	cmp	r4, lr
 800b5c2:	d312      	bcc.n	800b5ea <__udivdi3+0x256>
 800b5c4:	ea4f 4101 	mov.w	r1, r1, lsl #16
 800b5c8:	fa1f f28c 	uxth.w	r2, ip
 800b5cc:	bf14      	ite	ne
 800b5ce:	2300      	movne	r3, #0
 800b5d0:	2301      	moveq	r3, #1
 800b5d2:	eb01 0c02 	add.w	ip, r1, r2
 800b5d6:	fa15 f606 	lsls.w	r6, r5, r6
 800b5da:	4566      	cmp	r6, ip
 800b5dc:	bf2c      	ite	cs
 800b5de:	2600      	movcs	r6, #0
 800b5e0:	f003 0601 	andcc.w	r6, r3, #1
 800b5e4:	2e00      	cmp	r6, #0
 800b5e6:	f43f af28 	beq.w	800b43a <__udivdi3+0xa6>
 800b5ea:	f10a 3aff 	add.w	sl, sl, #4294967295
 800b5ee:	2600      	movs	r6, #0
 800b5f0:	e723      	b.n	800b43a <__udivdi3+0xa6>
 800b5f2:	409f      	lsls	r7, r3
 800b5f4:	f1c3 0120 	rsb	r1, r3, #32
 800b5f8:	fa34 f601 	lsrs.w	r6, r4, r1
 800b5fc:	fa14 f203 	lsls.w	r2, r4, r3
 800b600:	ea4f 4b17 	mov.w	fp, r7, lsr #16
 800b604:	fa25 fa01 	lsr.w	sl, r5, r1
 800b608:	4630      	mov	r0, r6
 800b60a:	4659      	mov	r1, fp
 800b60c:	fa05 f803 	lsl.w	r8, r5, r3
 800b610:	ea4a 0a02 	orr.w	sl, sl, r2
 800b614:	f7fe ff10 	bl	800a438 <__aeabi_uidiv>
 800b618:	4659      	mov	r1, fp
 800b61a:	b2bd      	uxth	r5, r7
 800b61c:	4681      	mov	r9, r0
 800b61e:	4630      	mov	r0, r6
 800b620:	f7ff f838 	bl	800a694 <__aeabi_uidivmod>
 800b624:	ea4f 4c1a 	mov.w	ip, sl, lsr #16
 800b628:	fb05 f309 	mul.w	r3, r5, r9
 800b62c:	ea4c 4401 	orr.w	r4, ip, r1, lsl #16
 800b630:	42a3      	cmp	r3, r4
 800b632:	d903      	bls.n	800b63c <__udivdi3+0x2a8>
 800b634:	19e4      	adds	r4, r4, r7
 800b636:	f109 39ff 	add.w	r9, r9, #4294967295
 800b63a:	d328      	bcc.n	800b68e <__udivdi3+0x2fa>
 800b63c:	1ae4      	subs	r4, r4, r3
 800b63e:	4659      	mov	r1, fp
 800b640:	4620      	mov	r0, r4
 800b642:	f7fe fef9 	bl	800a438 <__aeabi_uidiv>
 800b646:	4659      	mov	r1, fp
 800b648:	4606      	mov	r6, r0
 800b64a:	4620      	mov	r0, r4
 800b64c:	f7ff f822 	bl	800a694 <__aeabi_uidivmod>
 800b650:	fa1f f48a 	uxth.w	r4, sl
 800b654:	fb05 f306 	mul.w	r3, r5, r6
 800b658:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 800b65c:	42a3      	cmp	r3, r4
 800b65e:	d906      	bls.n	800b66e <__udivdi3+0x2da>
 800b660:	3e01      	subs	r6, #1
 800b662:	19e4      	adds	r4, r4, r7
 800b664:	d203      	bcs.n	800b66e <__udivdi3+0x2da>
 800b666:	42a3      	cmp	r3, r4
 800b668:	d901      	bls.n	800b66e <__udivdi3+0x2da>
 800b66a:	3e01      	subs	r6, #1
 800b66c:	19e4      	adds	r4, r4, r7
 800b66e:	1ae4      	subs	r4, r4, r3
 800b670:	ea46 4609 	orr.w	r6, r6, r9, lsl #16
 800b674:	e70c      	b.n	800b490 <__udivdi3+0xfc>
 800b676:	429c      	cmp	r4, r3
 800b678:	bf84      	itt	hi
 800b67a:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800b67e:	19db      	addhi	r3, r3, r7
 800b680:	e784      	b.n	800b58c <__udivdi3+0x1f8>
 800b682:	455b      	cmp	r3, fp
 800b684:	bf84      	itt	hi
 800b686:	f10a 3aff 	addhi.w	sl, sl, #4294967295
 800b68a:	44bb      	addhi	fp, r7
 800b68c:	e766      	b.n	800b55c <__udivdi3+0x1c8>
 800b68e:	42a3      	cmp	r3, r4
 800b690:	bf84      	itt	hi
 800b692:	f109 39ff 	addhi.w	r9, r9, #4294967295
 800b696:	19e4      	addhi	r4, r4, r7
 800b698:	e7d0      	b.n	800b63c <__udivdi3+0x2a8>
 800b69a:	bf00      	nop

0800b69c <Reset_Handler>:
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
 800b69c:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800b69e:	e003      	b.n	800b6a8 <LoopCopyDataInit>

0800b6a0 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800b6a0:	4b0b      	ldr	r3, [pc, #44]	; (800b6d0 <LoopFillZerobss+0x14>)
  ldr  r3, [r3, r1]
 800b6a2:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800b6a4:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800b6a6:	3104      	adds	r1, #4

0800b6a8 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr  r0, =_sdata
 800b6a8:	480a      	ldr	r0, [pc, #40]	; (800b6d4 <LoopFillZerobss+0x18>)
  ldr  r3, =_edata
 800b6aa:	4b0b      	ldr	r3, [pc, #44]	; (800b6d8 <LoopFillZerobss+0x1c>)
  adds  r2, r0, r1
 800b6ac:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800b6ae:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800b6b0:	d3f6      	bcc.n	800b6a0 <CopyDataInit>
  ldr  r2, =_sbss
 800b6b2:	4a0a      	ldr	r2, [pc, #40]	; (800b6dc <LoopFillZerobss+0x20>)
  b  LoopFillZerobss
 800b6b4:	e002      	b.n	800b6bc <LoopFillZerobss>

0800b6b6 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs  r3, #0
 800b6b6:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800b6b8:	f842 3b04 	str.w	r3, [r2], #4

0800b6bc <LoopFillZerobss>:

LoopFillZerobss:
  ldr  r3, = _ebss
 800b6bc:	4b08      	ldr	r3, [pc, #32]	; (800b6e0 <LoopFillZerobss+0x24>)
  cmp  r2, r3
 800b6be:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800b6c0:	d3f9      	bcc.n	800b6b6 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 800b6c2:	f7f5 fad7 	bl	8000c74 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 800b6c6:	f7f9 faaf 	bl	8004c28 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800b6ca:	f7f5 f883 	bl	80007d4 <main>
  bx  lr
 800b6ce:	4770      	bx	lr
 800b6d0:	0800bba4 	.word	0x0800bba4
 800b6d4:	20000000 	.word	0x20000000
 800b6d8:	200007ec 	.word	0x200007ec
 800b6dc:	200007ec 	.word	0x200007ec
 800b6e0:	20001ae8 	.word	0x20001ae8

0800b6e4 <Default_Handler2>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler2:
Infinite_Loop:
  b  Infinite_Loop
 800b6e4:	e7fe      	b.n	800b6e4 <Default_Handler2>
	...

0800b6e8 <clocks>:
 800b6e8:	0101 0405 0000 0000 1200 007a 0007 0000     ..........z.....
 800b6f8:	0054 0002                                   T...

0800b6fc <outpp>:
 800b6fc:	0001 0003 aa00                                   .....

0800b701 <C.5.7763>:
 800b701:	55aa 0231                                        .U1

0800b704 <CSWTCH.6>:
 800b704:	0102 0002                                   ....

0800b708 <outputcs>:
 800b708:	0001 0003 0200                                   .....

0800b70d <outputaf>:
 800b70d:	0002 0003 0205                                   .....

0800b712 <inputaf>:
 800b712:	0002 0100 0005                              ......

0800b718 <ahbtbl>:
 800b718:	0001 0001 0001 0001 0001 0001 0001 0001     ................
 800b728:	0002 0004 0008 0010 0040 0080 0100 0200     ........@.......

0800b738 <tcif_tbl>:
 800b738:	0600 1610                                   ....

0800b73c <open_name>:
 800b73c:	bb10 0800 bb15 0800 bb1a 0800 bb1f 0800     ................
 800b74c:	bb24 0800 bb29 0800 bb2e 0800 bb33 0800     $...).......3...

0800b75c <C.0.4985>:
 800b75c:	0002 0003 0200                                   .....

0800b761 <C.1.4986>:
 800b761:	0002 0100 0000 7000                              .......

0800b768 <_global_impure_ptr>:
 800b768:	0270 2000                                   p.. 

0800b76c <__sf_fake_stdin>:
	...

0800b78c <__sf_fake_stdout>:
	...

0800b7ac <__sf_fake_stderr>:
	...

0800b7cc <blanks.6598>:
 800b7cc:	2020 2020 2020 2020 2020 2020 2020 2020                     

0800b7dc <zeroes.6599>:
 800b7dc:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000
 800b7ec:	0000 0000                                   ....

0800b7f0 <p05.5124>:
 800b7f0:	0005 0000 0019 0000 007d 0000 0000 0000     ........}.......

0800b800 <__mprec_tens>:
 800b800:	0000 0000 0000 3ff0 0000 0000 0000 4024     .......?......$@
 800b810:	0000 0000 0000 4059 0000 0000 4000 408f     ......Y@.....@.@
 800b820:	0000 0000 8800 40c3 0000 0000 6a00 40f8     .......@.....j.@
 800b830:	0000 0000 8480 412e 0000 0000 12d0 4163     .......A......cA
 800b840:	0000 0000 d784 4197 0000 0000 cd65 41cd     .......A....e..A
 800b850:	0000 2000 a05f 4202 0000 e800 4876 4237     ... _..B....vH7B
 800b860:	0000 a200 1a94 426d 0000 e540 309c 42a2     ......mB..@..0.B
 800b870:	0000 1e90 bcc4 42d6 0000 2634 6bf5 430c     .......B..4&.k.C
 800b880:	8000 37e0 c379 4341 a000 85d8 3457 4376     ...7y.AC....W4vC
 800b890:	c800 674e c16d 43ab 3d00 6091 58e4 43e1     ..Ngm..C.=.`.X.C
 800b8a0:	8c40 78b5 af1d 4415 ef50 d6e2 1ae4 444b     @..x...DP.....KD
 800b8b0:	d592 064d f0cf 4480 4af6 c7e1 2d02 44b5     ..M....D.J...-.D
 800b8c0:	9db4 79d9 7843 44ea                         ...yCx.D

0800b8c8 <__mprec_bigtens>:
 800b8c8:	8000 37e0 c379 4341 6e17 b505 b8b5 4693     ...7y.AC.n.....F
 800b8d8:	f9f5 e93f 4f03 4d38 1d32 f930 7748 5a82     ..?..O8M2.0.Hw.Z
 800b8e8:	bf3c 7f73 4fdd 7515                         <.s..O.u

0800b8f0 <__mprec_tinytens>:
 800b8f0:	89bc 97d8 d2b2 3c9c a733 d5a8 f623 3949     .......<3...#.I9
 800b900:	a73d 44f4 0ffd 32a5 979d cf8c ba08 255b     =..D...2......[%
 800b910:	6f43 64ac 0628 0ac8                         Co.d(...

0800b918 <blanks.6542>:
 800b918:	2020 2020 2020 2020 2020 2020 2020 2020                     

0800b928 <zeroes.6543>:
 800b928:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000
 800b938:	6325 2000 0d0a 4944 4353 564f 5245 2059     %c. ..DISCOVERY 
 800b948:	3446 5320 4950 5432 5345 3a54 3020 2d32     F4 SPI2TEST: 02-
 800b958:	3630 322d 3130 2034 7620 0a30 000d 2020     06-2014  v0...  
 800b968:	6820 6c63 5f6b 7266 7165 2820 484d 297a      hclk_freq (MHz)
 800b978:	3a20 2520 7539 2e2e 2e2e 2e2e 2e2e 2e2e      : %9u..........
 800b988:	2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e     ................
 800b998:	2e2e 2e2e 0a2e 000d 2020 6370 6b6c 5f31     ........  pclk1_
 800b9a8:	7266 7165 2820 484d 297a 3a20 2520 7539     freq (MHz) : %9u
 800b9b8:	2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e     ................
 800b9c8:	2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 0a2e     ................
 800b9d8:	000d 2020 6370 6b6c 5f32 7266 7165 2820     ..  pclk2_freq (
 800b9e8:	484d 297a 3a20 2520 7539 2e2e 2e2e 2e2e     MHz) : %9u......
 800b9f8:	2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e     ................
 800ba08:	2e2e 2e2e 2e2e 2e2e 0a2e 000d 7320 7379     ............ sys
 800ba18:	6c63 5f6b 7266 7165 2820 484d 297a 3a20     clk_freq (MHz) :
 800ba28:	2520 7539 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e      %9u............
 800ba38:	2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e     ................
 800ba48:	2e2e 0a2e 000d 0d0a 754f 7074 7475 7020     ........Output p
 800ba58:	7461 6574 6e72 6220 7469 0a73 000d 0d0a     attern bits.....
 800ba68:	6e49 6f63 696d 676e 6220 7469 7020 7461     Incoming bit pat
 800ba78:	6574 6e72 0d0a 2500 7535 2520 7535 0020     tern...%5u %5u .
 800ba88:	4356 2050 6e49 6574 6672 6361 0065 4356     VCP Interface.VC
 800ba98:	2050 6f43 666e 6769 3000 3030 3030 3030     P Config.0000000
 800baa8:	3030 3035 0042 3030 3030 3030 3030 3530     0050B.0000000005
 800bab8:	4330 5300 4d54 6369 6f72 6c65 6365 7274     0C.STMicroelectr
 800bac8:	6e6f 6369 0073 5453 334d 2032 6956 7472     onics.STM32 Virt
 800bad8:	6175 206c 6f43 506d 726f 2074 6e69 4820     ual ComPort in H
 800bae8:	2053 6f6d 6564 5300 4d54 3233 5620 7269     S mode.STM32 Vir
 800baf8:	7574 6c61 4320 6d6f 6f50 7472 6920 206e     tual ComPort in 
 800bb08:	5346 4d20 646f 0065 7474 3179 7400 7974     FS Mode.tty1.tty
 800bb18:	0032 7474 3379 7400 7974 0034 7474 3579     2.tty3.tty4.tty5
 800bb28:	7400 7974 0036 7474 3779 7400 7974 0038     .tty6.tty7.tty8.
 800bb38:	0043 0000 4e49 0046 6e69 0066 414e 004e     C...INF.inf.NAN.
 800bb48:	616e 006e 3130 3332 3534 3736 3938 4241     nan.0123456789AB
 800bb58:	4443 4645 0000 0000 3130 3332 3534 3736     CDEF....01234567
 800bb68:	3938 6261 6463 6665 0000 0000 6e28 6c75     89abcdef....(nul
 800bb78:	296c 0000 0030 0000 6e49 6966 696e 7974     l)..0...Infinity
 800bb88:	0000 0000 614e 004e 4f50 4953 0058 0000     ....NaN.POSIX...
 800bb98:	002e 0000                                   ....
